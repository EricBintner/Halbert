{"text": "CUDA C++ Programming Guide — CUDA C++ Programming Guide\n»\nCUDA C++ Programming Guide\nv13.0 |\nPDF\n|\nArchive\nCUDA C++ Programming Guide\n1.\nOverview\nï\nCUDA is a parallel computing platform and programming model developed by NVIDIA that enables dramatic increases in computing performance by harnessing the power of the GPU. It allows developers to accelerate compute-intensive applications using C, C++, and Fortran, and is widely adopted in fields such as deep learning, scientific computing, and high-performance computing (HPC).\n2.\nWhat Is the CUDA C Programming Guide?\nï\nThe CUDA C Programming Guide is the official, comprehensive resource that explains how to write programs using the CUDA platform. It provides detailed documentation of the CUDA architecture, programming model, language extensions, and performance guidelines. Whether youâre just getting started or optimizing complex GPU kernels, this guide is an essential reference for effectively leveraging CUDAâs full capabilities.\n3.\nIntroduction\nï\n3.1.\nThe Benefits of Using GPUs\nï\nThe Graphics Processing Unit (GPU)\n1\nprovides much higher instruction throughput and memory bandwidth than the CPU within a similar price and power envelope. Many applications leverage these higher capabilities to run faster on the GPU than on the CPU (see\nGPU Applications\n). Other computing devices, like FPGAs, are also very energy efficient, but offer much less programming flexibility than GPUs.\nThis difference in capabilities between the GPU and the CPU exists because they are designed with different goals in mind. While the CPU is designed to excel at executing a sequence of operations, called a\nthread\n, as fast as possible and can execute a few tens of these threads in parallel, the GPU is designed to excel at executing thousands of them in parallel (amortizing the slower single-thread performance to achieve greater throughput).\nThe GPU is specialized for highly parallel computations and therefore designed such that more transistors are devoted to data processing rather than data caching and flow control. The schematic\nFigure 1\nshows an example distribution of chip resources for a CPU versus a GPU.\nFigure 1\nThe GPU Devotes More Transistors to Data Processing\nï\nDevoting more transistors to data processing, for example, floating-point computations, is beneficial for highly parallel computations; the GPU can hide memory access latencies with computation, instead of relying on large data caches and complex flow control to avoid long memory access latencies, both of which are expensive in terms of transistors.\nIn general, an application has a mix of parallel parts and sequential parts, so systems are designed with a mix of GPUs and CPUs in order to maximize overall performance. Applications with a high degree of parallelism can exploit this massively parallel nature of the GPU to achieve higher performance than on the CPU.\n1\nThe\ngraphics\nqualifier comes from the fact that when the GPU was originally created, two decades ago, it was designed as a specialized processor to accelerate graphics rendering. Driven by the insatiable market demand for real-time, high-definition, 3D graphics, it has evolved into a general processor used for many more workloads than just graphics rendering.\n3.2.\nCUDAÂ®: A General-Purpose Parallel Computing Platform and Programming Model\nï\nIn November 2006, NVIDIA\nÂ®\nintroduced CUDA\nÂ®\n, a general purpose parallel computing platform and programming model that leverages the parallel compute engine in NVIDIA GPUs to solve many complex computational problems in a more efficient way than on a CPU.\nCUDA comes with a software environment that allows developers to use C++ as a high-level programming language. As illustrated by\nFigure 2\n, other languages, application programming interfaces, or directives-based approaches are supported, such as FORTRAN, DirectCompute, OpenACC.\nFigure 2\nGPU Computing Applications. CUDA is designed to support various languages and application programming interfaces.\nï\n3.3.\nA Scalable Programming Model\nï\nThe advent of multicore CPUs and manycore GPUs means that mainstream processor chips are now parallel systems. The challenge is to develop application software that transparently scales its parallelism to leverage the increasing number of processor cores, much as 3D graphics applications transparently scale their parallelism to manycore GPUs with widely varying numbers of cores.\nThe CUDA parallel programming model is designed to overcome this challenge while maintaining a low learning curve for programmers familiar with standard programming languages such as C.\nAt its core are three key abstractions â a hierarchy of thread groups, shared memories, and barrier synchronization â that are simply exposed to the programmer as a minimal set of language extensions.\nThese abstractions provide fine-grained data parallelism and thread parallelism, nested within coarse-grained data parallelism and task parallelism. They guide the programmer to partition the problem into coarse sub-problems that can be solved independently in parallel by blocks of threads, and each sub-problem into finer pieces that can be solved cooperatively in parallel by all threads within the block.\nThis decomposition preserves language expressivity by allowing threads to cooperate when solving each sub-problem, and at the same time enables automatic scalability. Indeed, each block of threads can be scheduled on any of the available multiprocessors within a GPU, in any order, concurrently or sequentially, so that a compiled CUDA program can execute on any number of multiprocessors as illustrated by\nFigure 3\n, and only the runtime system needs to know the physical multiprocessor count.\nThis scalable programming model allows the GPU architecture to span a wide market range by simply scaling the number of multiprocessors and memory partitions: from the high-performance enthusiast GeForce GPUs and professional Quadro and Tesla computing products to a variety of inexpensive, mainstream GeForce GPUs (see\nCUDA-Enabled GPUs\nfor a list of all CUDA-enabled GPUs).\nFigure 3\nAutomatic Scalability\nï\nNote\nA GPU is built around an array of Streaming Multiprocessors (SMs) (see\nHardware Implementation\nfor more details). A multithreaded program is partitioned into blocks of threads that execute independently from each other, so that a GPU with more multiprocessors will automatically execute the program in less time than a GPU with fewer multiprocessors.\n4.\nChangelog\nï\nTable 1\nChange Log\nï\nVersion\nChanges\n13.0\nMoved the instruction throughput table from the\nPerformance Guidelines\nsection of the CUDA C++ Programming Guide to the\nInstruction-optimization\nsection of the CUDA C++ Best Practices Guide. Removed unsupported architectures and corrected entries for integer arithmetic and type conversion.\n12.9\nAdded section\nError Log Management\nand CUDA_LOG_FILE to\nCUDA Environment Variables\n12.8\nAdded section\nTMA Swizzle\n5.\nProgramming Model\nï\nThis chapter introduces the main concepts behind the CUDA programming model by outlining how they are exposed in C++.\nAn extensive description of CUDA C++ is given in\nProgramming Interface\n.\nFull code for the vector addition example used in this chapter and the next can be found in the\nvectorAdd CUDA sample\n.\n5.1.\nKernels\nï\nCUDA C++ extends C++ by allowing the programmer to define C++ functions, called\nkernels\n, that, when called, are executed N times in parallel by N different\nCUDA threads\n, as opposed to only once like regular C++ functions.\nA kernel is defined using the\n__global__\ndeclaration specifier and the number of CUDA threads that execute that kernel for a given kernel call is specified using a new\n<<<...>>>\nexecution configuration\nsyntax (see\nExecution Configuration\n). Each thread that executes the kernel is given a unique\nthread ID\nthat is accessible within the kernel through built-in variables.\nAs an illustration, the following sample code, using the built-in variable\nthreadIdx\n, adds two vectors\nA\nand\nB\nof size\nN\nand stores the result into vector\nC\n.\n// Kernel definition\n__global__\nvoid\nVecAdd\n(\nfloat\n*\nA\n,\nfloat\n*\nB\n,\nfloat\n*\nC\n)\n{\nint\ni\n=\nthreadIdx\n.\nx\n;\nC\n[\ni\n]\n=\nA\n[\ni\n]\n+\nB\n[\ni\n];\n}\nint\nmain\n()\n{\n...\n// Kernel invocation with N threads\nVecAdd\n<<<\n1\n,\nN\n>>>\n(\nA\n,\nB\n,\nC\n);\n...\n}\nHere, each of the\nN\nthreads that execute\nVecAdd()\nperforms one pair-wise addition.\n5.2.\nThread Hierarchy\nï\nFor convenience,\nthreadIdx\nis a 3-component vector, so that threads can be identified using a one-dimensional, two-dimensional, or three-dimensional\nthread index\n, forming a one-dimensional, two-dimensional, or three-dimensional block of threads, called a\nthread block\n. This provides a natural way to invoke computation across the elements in a domain such as a vector, matrix, or volume.\nThe index of a thread and its thread ID relate to each other in a straightforward way: For a one-dimensional block, they are the same; for a two-dimensional block of size\n(Dx, Dy)\n, the thread ID of a thread of index\n(x, y)\nis\n(x + y Dx)\n; for a three-dimensional block of size\n(Dx, Dy, Dz)\n, the thread ID of a thread of index\n(x, y, z)\nis\n(x + y Dx + z Dx Dy)\n.\nAs an example, the following code adds two matrices\nA\nand\nB\nof size\nNxN\nand stores the result into matrix\nC\n.\n// Kernel definition\n__global__\nvoid\nMatAdd\n(\nfloat\nA\n[\nN\n][\nN\n],\nfloat\nB\n[\nN\n][\nN\n],\nfloat\nC\n[\nN\n][\nN\n])\n{\nint\ni\n=\nthreadIdx\n.\nx\n;\nint\nj\n=\nthreadIdx\n.\ny\n;\nC\n[\ni\n][\nj\n]\n=\nA\n[\ni\n][\nj\n]\n+\nB\n[\ni\n][\nj\n];\n}\nint\nmain\n()\n{\n...\n// Kernel invocation with one block of N * N * 1 threads\nint\nnumBlocks\n=\n1\n;\ndim3\nthreadsPerBlock\n(\nN\n,\nN\n);\nMatAdd\n<<<\nnumBlocks\n,\nthreadsPerBlock\n>>>\n(\nA\n,\nB\n,\nC\n);\n...\n}\nThere is a limit to the number of threads per block, since all threads of a block are expected to reside on the same streaming multiprocessor core and must share the limited memory resources of that core. On current GPUs, a thread block may contain up to 1024 threads.\nHowever, a kernel can be executed by multiple equally-shaped thread blocks, so that the total number of threads is equal to the number of threads per block times the number of blocks.\nBlocks are organized into a one-dimensional, two-dimensional, or three-dimensional\ngrid\nof thread blocks as illustrated by\nFigure 4\n. The number of thread blocks in a grid is usually dictated by the size of the data being processed, which typically exceeds the number of processors in the system.\nFigure 4\nGrid of Thread Blocks\nï\nThe number of threads per block and the number of blocks per grid specified in the\n<<<...>>>\nsyntax can be of type\nint\nor\ndim3\n. Two-dimensional blocks or grids can be specified as in the example above.\nEach block within the grid can be identified by a one-dimensional, two-dimensional, or three-dimensional unique index accessible within the kernel through the built-in\nblockIdx\nvariable. The dimension of the thread block is accessible within the kernel through the built-in\nblockDim\nvariable.\nExtending the previous\nMatAdd()\nexample to handle multiple blocks, the code becomes as follows.\n// Kernel definition\n__global__\nvoid\nMatAdd\n(\nfloat\nA\n[\nN\n][\nN\n],\nfloat\nB\n[\nN\n][\nN\n],\nfloat\nC\n[\nN\n][\nN\n])\n{\nint\ni\n=\nblockIdx\n.\nx\n*\nblockDim\n.\nx\n+\nthreadIdx\n.\nx\n;\nint\nj\n=\nblockIdx\n.\ny\n*\nblockDim\n.\ny\n+\nthreadIdx\n.\ny\n;\nif\n(\ni\n<\nN\n&&\nj\n<\nN\n)\nC\n[\ni\n][\nj\n]\n=\nA\n[\ni\n][\nj\n]\n+\nB\n[\ni\n][\nj\n];\n}\nint\nmain\n()\n{\n...\n// Kernel invocation\ndim3\nthreadsPerBlock\n(\n16\n,\n16\n);\ndim3\nnumBlocks\n(\nN\n/\nthreadsPerBlock\n.\nx\n,\nN\n/\nthreadsPerBlock\n.\ny\n);\nMatAdd\n<<<\nnumBlocks\n,\nthreadsPerBlock\n>>>\n(\nA\n,\nB\n,\nC\n);\n...\n}\nA thread block size of 16x16 (256 threads), although arbitrary in this case, is a common choice. The grid is created with enough blocks to have one thread per matrix element as before. For simplicity, this example assumes that the number of threads per grid in each dimension is evenly divisible by the number of threads per block in that dimension, although that need not be the case.\nThread blocks are required to execute independently. It must be possible to execute blocks in any order, in parallel or in series. This independence requirement allows thread blocks to be scheduled in any order and across any number of cores as illustrated by\nFigure 3\n, enabling programmers to write code that scales with the number of cores.\nThreads within a block can cooperate by sharing data through some\nshared memory\nand by synchronizing their execution to coordinate memory accesses. More precisely, one can specify synchronization points in the kernel by calling the\n__syncthreads()\nintrinsic function;\n__syncthreads()\nacts as a barrier at which all threads in the block must wait before any is allowed to proceed.\nShared Memory\ngives an example of using shared memory. In addition to\n__syncthreads()\n, the\nCooperative Groups API\nprovides a rich set of thread-synchronization primitives.\nFor efficient cooperation, shared memory is expected to be a low-latency memory near each processor core (much like an L1 cache) and\n__syncthreads()\nis expected to be lightweight.\n5.2.1.\nThread Block Clusters\nï\nWith the introduction of NVIDIA\nCompute Capability 9.0\n, the CUDA programming model introduces an optional level of hierarchy called Thread Block Clusters that are made up of thread blocks. Similar to how threads in a thread block are guaranteed to be co-scheduled on a streaming multiprocessor, thread blocks in a cluster are also guaranteed to be co-scheduled on a GPU Processing Cluster (GPC) in the GPU.\nSimilar to thread blocks, clusters are also organized into a one-dimension, two-dimension, or three-dimension grid of thread block clusters as illustrated by\nFigure 5\n. The number of thread blocks in a cluster can be user-defined, and a maximum of 8 thread blocks in a cluster is supported as a portable cluster size in CUDA.\nNote that on GPU hardware or MIG configurations which are too small to support 8 multiprocessors the maximum cluster size will be reduced accordingly. Identification of these smaller configurations, as well as of larger configurations supporting a thread block cluster size beyond 8, is architecture-specific and can be queried using the\ncudaOccupancyMaxPotentialClusterSize\nAPI.\nFigure 5\nGrid of Thread Block Clusters\nï\nNote\nIn a kernel launched using cluster support, the gridDim variable still denotes the size in terms of number of thread blocks, for compatibility purposes. The rank of a block in a cluster can be found using the\nCluster Group\nAPI.\nA thread block cluster can be enabled in a kernel either using a compile-time kernel attribute using\n__cluster_dims__(X,Y,Z)\nor using the CUDA kernel launch API\ncudaLaunchKernelEx\n. The example below shows how to launch a cluster using a compile-time kernel attribute. The cluster size using kernel attribute is fixed at compile time and then the kernel can be launched using the classical\n<<<\n,\n>>>\n. If a kernel uses compile-time cluster size, the cluster size cannot be modified when launching the kernel.\n// Kernel definition\n// Compile time cluster size 2 in X-dimension and 1 in Y and Z dimension\n__global__\nvoid\n__cluster_dims__\n(\n2\n,\n1\n,\n1\n)\ncluster_kernel\n(\nfloat\n*\ninput\n,\nfloat\n*\noutput\n)\n{\n}\nint\nmain\n()\n{\nfloat\n*\ninput\n,\n*\noutput\n;\n// Kernel invocation with compile time cluster size\ndim3\nthreadsPerBlock\n(\n16\n,\n16\n);\ndim3\nnumBlocks\n(\nN\n/\nthreadsPerBlock\n.\nx\n,\nN\n/\nthreadsPerBlock\n.\ny\n);\n// The grid dimension is not affected by cluster launch, and is still enumerated\n// using number of blocks.\n// The grid dimension must be a multiple of cluster size.\ncluster_kernel\n<<<\nnumBlocks\n,\nthreadsPerBlock\n>>>\n(\ninput\n,\noutput\n);\n}\nA thread block cluster size can also be set at runtime and the kernel can be launched using the CUDA kernel launch API\ncudaLaunchKernelEx\n. The code example below shows how to launch a cluster kernel using the extensible API.\n// Kernel definition\n// No compile time attribute attached to the kernel\n__global__\nvoid\ncluster_kernel\n(\nfloat\n*\ninput\n,\nfloat\n*\noutput\n)\n{\n}\nint\nmain\n()\n{\nfloat\n*\ninput\n,\n*\noutput\n;\ndim3\nthreadsPerBlock\n(\n16\n,\n16\n);\ndim3\nnumBlocks\n(\nN\n/\nthreadsPerBlock\n.\nx\n,\nN\n/\nthreadsPerBlock\n.\ny\n);\n// Kernel invocation with runtime cluster size\n{\ncudaLaunchConfig_t\nconfig\n=\n{\n0\n};\n// The grid dimension is not affected by cluster launch, and is still enumerated\n// using number of blocks.\n// The grid dimension should be a multiple of cluster size.\nconfig\n.\ngridDim\n=\nnumBlocks\n;\nconfig\n.\nblockDim\n=\nthreadsPerBlock\n;\ncudaLaunchAttribute\nattribute\n[\n1\n];\nattribute\n[\n0\n].\nid\n=\ncudaLaunchAttributeClusterDimension\n;\nattribute\n[\n0\n].\nval\n.\nclusterDim\n.\nx\n=\n2\n;\n// Cluster size in X-dimension\nattribute\n[\n0\n].\nval\n.\nclusterDim\n.\ny\n=\n1\n;\nattribute\n[\n0\n].\nval\n.\nclusterDim\n.\nz\n=\n1\n;\nconfig\n.\nattrs\n=\nattribute\n;\nconfig\n.\nnumAttrs\n=\n1\n;\ncudaLaunchKernelEx\n(\n&\nconfig\n,\ncluster_kernel\n,\ninput\n,\noutput\n);\n}\n}\nIn GPUs with compute capability 9.0, all the thread blocks in the cluster are guaranteed to be co-scheduled on a single GPU Processing Cluster (GPC) and allow thread blocks in the cluster to perform hardware-supported synchronization using the\nCluster Group\nAPI\ncluster.sync()\n. Cluster group also provides member functions to query cluster group size in terms of number of threads or number of blocks using\nnum_threads()\nand\nnum_blocks()\nAPI respectively. The rank of a thread or block in the cluster group can be queried using\ndim_threads()\nand\ndim_blocks()\nAPI respectively.\nThread blocks that belong to a cluster have access to the Distributed Shared Memory. Thread blocks in a cluster have the ability to read, write, and perform atomics to any address in the distributed shared memory.\nDistributed Shared Memory\ngives an example of performing histograms in distributed shared memory.\n5.2.2.\nBlocks as Clusters\nï\nWith\n__cluster_dims__\n, the number of launched clusters is kept implicit and can only be calculated manually.\n__cluster_dims__\n((\n2\n,\n2\n,\n2\n))\n__global__\nvoid\nfoo\n();\n// 8x8x8 clusters each with 2x2x2 thread blocks.\nfoo\n<<<\ndim3\n(\n16\n,\n16\n,\n16\n),\ndim3\n(\n1024\n,\n1\n,\n1\n)\n>>>\n();\nIn the above example, the kernel is launched as a grid of 16x16x16 thread blocks, or in fact a grid of 8x8x8 clusters. Alternatively, with another compile-time kernel attribute\n__block_size__\n, one is allowed to launch a grid explicitly configured with the number of thread block clusters.\n// Implementation detail of how many threads per block and blocks per cluster\n// is handled as an attribute of the kernel.\n__block_size__\n((\n1024\n,\n1\n,\n1\n),\n(\n2\n,\n2\n,\n2\n))\n__global__\nvoid\nfoo\n();\n// 8x8x8 clusters.\nfoo\n<<<\ndim3\n(\n8\n,\n8\n,\n8\n)\n>>>\n();\n__block_size__\nrequires two fields each being a tuple of 3 elements. The first tuple denotes block dimension and second cluster size. The second tuple is assumed to be\n(1,1,1)\nif itâs not passed. To specify the stream, one must pass\n1\nand\n0\nas the second and third arguments within\n<<<>>>\nand lastly the stream. Passing other values would lead to undefined behavior.\nNote that it is illegal for the second tuple of\n__block_size__\nand\n__cluster_dims__\nto be specified at the same time. When the second tuple of\n__block_size__\nis specified, it implies the âBlocks as Clustersâ being enabled and the compiler would recognize the first argument inside\n<<<>>>\nas the number of clusters instead of thread blocks.\n5.3.\nMemory Hierarchy\nï\nCUDA threads may access data from multiple memory spaces during their execution as illustrated by\nFigure 6\n. Each thread has private local memory. Each thread block has shared memory visible to all threads of the block and with the same lifetime as the block. Thread blocks in a thread block cluster can perform read, write, and atomics operations on each otherâs shared memory. All threads have access to the same global memory.\nThere are also two additional read-only memory spaces accessible by all threads: the constant and texture memory spaces. The global, constant, and texture memory spaces are optimized for different memory usages (see\nDevice Memory Accesses\n). Texture memory also offers different addressing modes, as well as data filtering, for some specific data formats (see\nTexture and Surface Memory\n).\nThe global, constant, and texture memory spaces are persistent across kernel launches by the same application.\nFigure 6\nMemory Hierarchy\nï\n5.4.\nHeterogeneous Programming\nï\nAs illustrated by\nFigure 7\n, the CUDA programming model assumes that the CUDA threads execute on a physically separate\ndevice\nthat operates as a coprocessor to the\nhost\nrunning the C++ program. This is the case, for example, when the kernels execute on a GPU and the rest of the C++ program executes on a CPU.\nThe CUDA programming model also assumes that both the host and the device maintain their own separate memory spaces in DRAM, referred to as\nhost memory\nand\ndevice memory\n, respectively. Therefore, a program manages the global, constant, and texture memory spaces visible to kernels through calls to the CUDA runtime (described in\nProgramming Interface\n). This includes device memory allocation and deallocation as well as data transfer between host and device memory.\nUnified Memory provides\nmanaged memory\nto bridge the host and device memory spaces. Managed memory is accessible from all CPUs and GPUs in the system as a single, coherent memory image with a common address space. This capability enables oversubscription of device memory and can greatly simplify the task of porting applications by eliminating the need to explicitly mirror data on host and device. See\nUnified Memory Programming\nfor an introduction to Unified Memory.\nFigure 7\nHeterogeneous Programming\nï\nNote\nSerial code executes on the host while parallel code executes on the device.\n5.5.\nAsynchronous SIMT Programming Model\nï\nIn the CUDA programming model a thread is the lowest level of abstraction for doing a computation or a memory operation. Starting with devices based on the\nNVIDIA Ampere GPU Architecture\n, the CUDA programming model provides acceleration to memory operations via the asynchronous programming model. The asynchronous programming model defines the behavior of asynchronous operations with respect to CUDA threads.\nThe asynchronous programming model defines the behavior of\nAsynchronous Barrier\nfor synchronization between CUDA threads. The model also explains and defines how\ncuda::memcpy_async\ncan be used to move data asynchronously from global memory while computing in the GPU.\n5.5.1.\nAsynchronous Operations\nï\nAn asynchronous operation is defined as an operation that is initiated by a CUDA thread and is executed asynchronously as-if by another thread. In a well formed program one or more CUDA threads synchronize with the asynchronous operation. The CUDA thread that initiated the asynchronous operation is not required to be among the synchronizing threads.\nSuch an asynchronous thread (an as-if thread) is always associated with the CUDA thread that initiated the asynchronous operation. An asynchronous operation uses a synchronization object to synchronize the completion of the operation. Such a synchronization object can be explicitly managed by a user (e.g.,\ncuda::memcpy_async\n) or implicitly managed within a library (e.g.,\ncooperative_groups::memcpy_async\n).\nA synchronization object could be a\ncuda::barrier\nor a\ncuda::pipeline\n. These objects are explained in detail in\nAsynchronous Barrier\nand\nAsynchronous Data Copies using cuda::pipeline\n. These synchronization objects can be used at different thread scopes. A scope defines the set of threads that may use the synchronization object to synchronize with the asynchronous operation. The following table defines the thread scopes available in CUDA C++ and the threads that can be synchronized with each.\nThread Scope\nDescription\ncuda::thread_scope::thread_scope_thread\nOnly the CUDA thread which initiated asynchronous operations synchronizes.\ncuda::thread_scope::thread_scope_block\nAll or any CUDA threads within the same thread block as the initiating thread synchronizes.\ncuda::thread_scope::thread_scope_device\nAll or any CUDA threads in the same GPU device as the initiating thread synchronizes.\ncuda::thread_scope::thread_scope_system\nAll or any CUDA or CPU threads in the same system as the initiating thread synchronizes.\nThese thread scopes are implemented as extensions to standard C++ in the\nCUDA Standard C++\nlibrary.\n5.6.\nCompute Capability\nï\nThe\ncompute capability\nof a device is represented by a version number, also sometimes called its âSM versionâ. This version number identifies the features supported by the GPU hardware and is used by applications at runtime to determine which hardware features and/or instructions are available on the present GPU.\nThe compute capability comprises a major revision number\nX\nand a minor revision number\nY\nand is denoted by\nX.Y\n.\nThe major revision number indicates the core GPU architecture of a device. Devices with the same major revision number share the same fundamental architecture. The table below lists the major revision numbers corresponding to each NVIDIA GPU architecture.\nTable 2\nGPU Architecture and Major Revision Numbers\nï\nMajor Revision Number\nNVIDIA GPU Architecture\n9\nNVIDIA Hopper GPU Architecture\n8\nNVIDIA Ampere GPU Architecture\n7\nNVIDIA Volta GPU Architecture\n6\nNVIDIA Pascal GPU Architecture\n5\nNVIDIA Maxwell GPU Architecture\n3\nNVIDIA Kepler GPU Architecture\nThe minor revision number corresponds to an incremental improvement to the core architecture, possibly including new features.\nTable 3\nIncremental Updates in GPU Architectures\nï\nCompute Capability\nNVIDIA GPU Architecture\nBased On\n7.5\nNVIDIA Turing GPU Architecture\nNVIDIA Volta GPU Architecture\nCUDA-Enabled GPUs\nlists of all CUDA-enabled devices along with their compute capability.\nCompute Capabilities\ngives the technical specifications of each compute capability.\nNote\nThe compute capability version of a particular GPU should not be confused with the CUDA version (for example, CUDA 7.5, CUDA 8, CUDA 9), which is the version of the CUDA\nsoftware platform\n. The CUDA platform is used by application developers to create applications that run on many generations of GPU architectures, including future GPU architectures yet to be invented. While new versions of the CUDA platform often add native support for a new GPU architecture by supporting the compute capability version of that architecture, new versions of the CUDA platform typically also include software features that are independent of hardware generation.\nThe\nTesla\nand\nFermi\narchitectures are no longer supported starting with CUDA 7.0 and CUDA 9.0, respectively.\n6.\nProgramming Interface\nï\nCUDA C++ provides a simple path for users familiar with the C++ programming language to easily write programs for execution by the device.\nIt consists of a minimal set of extensions to the C++ language and a runtime library.\nThe core language extensions have been introduced in\nProgramming Model\n. They allow programmers to define a kernel as a C++ function and use some new syntax to specify the grid and block dimension each time the function is called. A complete description of all extensions can be found in\nC++ Language Extensions\n. Any source file that contains some of these extensions must be compiled with\nnvcc\nas outlined in\nCompilation with NVCC\n.\nThe runtime is introduced in\nCUDA Runtime\n. It provides C and C++ functions that execute on the host to allocate and deallocate device memory, transfer data between host memory and device memory, manage systems with multiple devices, etc. A complete description of the runtime can be found in the CUDA reference manual.\nThe runtime is built on top of a lower-level C API, the CUDA driver API, which is also accessible by the application. The driver API provides an additional level of control by exposing lower-level concepts such as CUDA contexts - the analogue of host processes for the device - and CUDA modules - the analogue of dynamically loaded libraries for the device. Most applications do not use the driver API as they do not need this additional level of control and when using the runtime, context and module management are implicit, resulting in more concise code. As the runtime is interoperable with the driver API, most applications that need some driver API features can default to use the runtime API and only use the driver API where needed. The driver API is introduced in\nDriver API\nand fully described in the reference manual.\n6.1.\nCompilation with NVCC\nï\nKernels can be written using the CUDA instruction set architecture, called\nPTX\n, which is described in the PTX reference manual. It is however usually more effective to use a high-level programming language such as C++. In both cases, kernels must be compiled into binary code by\nnvcc\nto execute on the device.\nnvcc\nis a compiler driver that simplifies the process of compiling\nC++\nor\nPTX\ncode: It provides simple and familiar command line options and executes them by invoking the collection of tools that implement the different compilation stages. This section gives an overview of\nnvcc\nworkflow and command options. A complete description can be found in the\nnvcc\nuser manual.\n6.1.1.\nCompilation Workflow\nï\n6.1.1.1.\nOffline Compilation\nï\nSource files compiled with\nnvcc\ncan include a mix of host code (i.e., code that executes on the host) and device code (i.e., code that executes on the device).\nnvcc\nâs basic workflow consists in separating device code from host code and then:\ncompiling the device code into an assembly form (\nPTX\ncode) and/or binary form (\ncubin\nobject),\nand modifying the host code by replacing the\n<<<...>>>\nsyntax introduced in\nKernels\n(and described in more details in\nExecution Configuration\n) by the necessary CUDA runtime function calls to load and launch each compiled kernel from the\nPTX\ncode and/or\ncubin\nobject.\nThe modified host code is output either as C++ code that is left to be compiled using another tool or as object code directly by letting\nnvcc\ninvoke the host compiler during the last compilation stage.\nApplications can then:\nEither link to the compiled host code (this is the most common case),\nOr ignore the modified host code (if any) and use the CUDA driver API (see\nDriver API\n) to load and execute the\nPTX\ncode or\ncubin\nobject.\n6.1.1.2.\nJust-in-Time Compilation\nï\nAny\nPTX\ncode loaded by an application at runtime is compiled further to binary code by the device driver. This is called\njust-in-time compilation\n. Just-in-time compilation increases application load time, but allows the application to benefit from any new compiler improvements coming with each new device driver. It is also the only way for applications to run on devices that did not exist at the time the application was compiled, as detailed in\nApplication Compatibility\n.\nWhen the device driver just-in-time compiles some\nPTX\ncode for some application, it automatically caches a copy of the generated binary code in order to avoid repeating the compilation in subsequent invocations of the application. The cache - referred to as\ncompute cache\n- is automatically invalidated when the device driver is upgraded, so that applications can benefit from the improvements in the new just-in-time compiler built into the device driver.\nEnvironment variables are available to control just-in-time compilation as described in\nCUDA Environment Variables\nAs an alternative to using\nnvcc\nto compile CUDA C++ device code, NVRTC can be used to compile CUDA C++ device code to PTX at runtime. NVRTC is a runtime compilation library for CUDA C++; more information can be found in the NVRTC User guide.\n6.1.2.\nBinary Compatibility\nï\nBinary code is architecture-specific. A\ncubin\nobject is generated using the compiler option\n-code\nthat specifies the targeted architecture: For example, compiling with\n-code=sm_80\nproduces binary code for devices of\ncompute capability\n8.0. Binary compatibility is guaranteed from one minor revision to the next one, but not from one minor revision to the previous one or across major revisions. In other words, a\ncubin\nobject generated for compute capability\nX.y\nwill only execute on devices of compute capability\nX.z\nwhere\nzâ¥y\n.\nNote\nBinary compatibility is supported only for the desktop. It is not supported for Tegra. Also, the binary compatibility between desktop and Tegra is not supported.\n6.1.3.\nPTX Compatibility\nï\nSome\nPTX\ninstructions are only supported on devices of higher compute capabilities. For example,\nWarp Shuffle Functions\nare only supported on devices of compute capability 5.0 and above. The\n-arch\ncompiler option specifies the compute capability that is assumed when compiling C++ to\nPTX\ncode. So, code that contains warp shuffle, for example, must be compiled with\n-arch=compute_50\n(or higher).\nPTX\ncode produced for some specific compute capability can always be compiled to binary code of greater or equal compute capability. Note that a binary compiled from an earlier PTX version may not make use of some hardware features. For example, a binary targeting devices of compute capability 7.0 (Volta) compiled from PTX generated for compute capability 6.0 (Pascal) will not make use of Tensor Core instructions, since these were not available on Pascal. As a result, the final binary may perform worse than would be possible if the binary were generated using the latest version of PTX.\nPTX\ncode compiled to target\nArchitecture-Specific Features\nonly runs on the exact same physical architecture and nowhere else. Architecture-specific\nPTX\ncode is not forward and backward compatible.\nExample code compiled with\nsm_90a\nor\ncompute_90a\nonly runs on devices with compute capability 9.0 and is not backward or forward compatible.\nPTX\ncode compiled to target\nFamily-Specific Features\nonly runs on the exact same physical architecture and other architectures in the same family. Family-specific\nPTX\ncode is forward compatible with other devices in the same family, and is not backward compatible.\nExample code compiled with\nsm_100f\nor\ncompute_100f\nonly runs on devices with compute capability 10.0 and 10.3.\nTable 25\nshows the compatibility of family-specific targets with compute capability.\n6.1.4.\nApplication Compatibility\nï\nTo execute code on devices of specific compute capability, an application must load binary or\nPTX\ncode that is compatible with this compute capability as described in\nBinary Compatibility\nand\nPTX Compatibility\n. In particular, to be able to execute code on future architectures with higher compute capability (for which no binary code can be generated yet), an application must load\nPTX\ncode that will be just-in-time compiled for these devices (see\nJust-in-Time Compilation\n).\nWhich\nPTX\nand binary code gets embedded in a CUDA C++ application is controlled by the\n-arch\nand\n-code\ncompiler options or the\n-gencode\ncompiler option as detailed in the\nnvcc\nuser manual. For example,\nnvcc x.cu\n-gencode arch=compute_50,code=sm_50\n-gencode arch=compute_60,code=sm_60\n-gencode arch=compute_70,code=\\\"compute_70,sm_70\\\"\nembeds binary code compatible with compute capability 5.0 and 6.0 (first and second\n-gencode\noptions) and\nPTX\nand binary code compatible with compute capability 7.0 (third\n-gencode\noption).\nHost code is generated to automatically select at runtime the most appropriate code to load and execute, which, in the above example, will be:\n5.0 binary code for devices with compute capability 5.0 and 5.2,\n6.0 binary code for devices with compute capability 6.0 and 6.1,\n7.0 binary code for devices with compute capability 7.0 and 7.5,\nPTX\ncode which is compiled to binary code at runtime for devices with compute capability later than 7.5\nx.cu\ncan have an optimized code path that uses warp reduction operations, for example, which are only supported in devices of compute capability 8.0 and higher. The\n__CUDA_ARCH__\nmacro can be used to differentiate various code paths based on compute capability. It is only defined for device code. When compiling with\n-arch=compute_80\nfor example,\n__CUDA_ARCH__\nis equal to\n800\n.\nIf\nx.cu\nis compiled for\nFamily-Specific Features\nwith\nsm_100f\nor\ncompute_100f\n, the code can only run on devices in that specific family, which are devices with compute capability 10.0 and 10.3.  For family-specific code targets an additional macro\n__CUDA_ARCH_FAMILY_SPECIFIC__\nis defined.  In this example,\n__CUDA_ARCH_FAMILY_SPECIFIC__\nis equal to\n1000\n.\nIf\nx.cu\nis compiled for\nArchitecture-Specific Features\nwith\nsm_100a\nor\ncompute_100a\n, the code can only run on devices with compute capability 10.0.  For architecture-specific code targets an additional macro\n__CUDA_ARCH_SPECIFIC__\nis defined.  In this example,\n__CUDA_ARCH_SPECIFIC__\nis equal to\n1000\n.  Because architecture-specific features are a superset of family-specific features, the family-specific macro\n__CUDA_ARCH_FAMILY_SPECIFIC__\nis also defined and is equal to\n1000\n.\nApplications using the driver API must compile code to separate files and explicitly load and execute the most appropriate file at runtime.\nThe Volta architecture introduces\nIndependent Thread Scheduling\nwhich changes the way threads are scheduled on the GPU. For code relying on specific behavior of\nSIMT scheduling\nin previous architectures, Independent Thread Scheduling may alter the set of participating threads, leading to incorrect results. To aid migration while implementing the corrective actions detailed in\nIndependent Thread Scheduling\n, Volta developers can opt-in to Pascalâs thread scheduling with the compiler option combination\n-arch=compute_60\n-code=sm_70\n.\nThe\nnvcc\nuser manual lists various shorthands for the\n-arch\n,\n-code\n, and\n-gencode\ncompiler options. For example,\n-arch=sm_70\nis a shorthand for\n-arch=compute_70\n-code=compute_70,sm_70\n(which is the same as\n-gencode\narch=compute_70,code=\\\"compute_70,sm_70\\\"\n).\n6.1.5.\nC++ Compatibility\nï\nThe front end of the compiler processes CUDA source files according to C++ syntax rules. Full C++ is supported for the host code. However, only a subset of C++ is fully supported for the device code as described in\nC++ Language Support\n.\n6.1.6.\n64-Bit Compatibility\nï\nThe 64-bit version of\nnvcc\ncompiles device code in 64-bit mode (i.e., pointers are 64-bit). Device code compiled in 64-bit mode is only supported with host code compiled in 64-bit mode.\n6.2.\nCUDA Runtime\nï\nThe runtime is implemented in the\ncudart\nlibrary, which is linked to the application, either statically via\ncudart.lib\nor\nlibcudart.a\n, or dynamically via\ncudart.dll\nor\nlibcudart.so\n. Applications that require\ncudart.dll\nand/or\ncudart.so\nfor dynamic linking typically include them as part of the application installation package. It is only safe to pass the address of CUDA runtime symbols between components that link to the same instance of the CUDA runtime.\nAll its entry points are prefixed with\ncuda\n.\nAs mentioned in\nHeterogeneous Programming\n, the CUDA programming model assumes a system composed of a host and a device, each with their own separate memory.\nDevice Memory\ngives an overview of the runtime functions used to manage device memory.\nShared Memory\nillustrates the use of shared memory, introduced in\nThread Hierarchy\n, to maximize performance.\nPage-Locked Host Memory\nintroduces page-locked host memory that is required to overlap kernel execution with data transfers between host and device memory.\nAsynchronous Concurrent Execution\ndescribes the concepts and API used to enable asynchronous concurrent execution at various levels in the system.\nMulti-Device System\nshows how the programming model extends to a system with multiple devices attached to the same host.\nError Checking\ndescribes how to properly check the errors generated by the runtime.\nCall Stack\nmentions the runtime functions used to manage the CUDA C++ call stack.\nTexture and Surface Memory\npresents the texture and surface memory spaces that provide another way to access device memory; they also expose a subset of the GPU texturing hardware.\nGraphics Interoperability\nintroduces the various functions the runtime provides to interoperate with the two main graphics APIs, OpenGL and Direct3D.\n6.2.1.\nInitialization\nï\nAs of CUDA 12.0, the\ncudaInitDevice()\nand\ncudaSetDevice()\ncalls initialize the runtime and the primary context\nassociated with the specified device. Absent these calls, the runtime will implicitly use device 0 and self-initialize\nas needed to process other runtime API requests. One needs to keep this in mind when timing runtime function calls and\nwhen interpreting the error code from the first call into the runtime. Before 12.0,\ncudaSetDevice()\nwould not\ninitialize the runtime and applications would often use the no-op runtime call\ncudaFree(0)\nto isolate the runtime\ninitialization from other api activity (both for the sake of timing and error handling).\nThe runtime creates a CUDA context for each device in the system (see\nContext\nfor more details on CUDA contexts). This\ncontext is the\nprimary context\nfor this device and is initialized at the first runtime function which requires an active\ncontext on this device. It is shared among all the host threads of the application. As part of this context creation, the\ndevice code is just-in-time compiled if necessary (see\nJust-in-Time Compilation\n) and loaded into device memory. This\nall happens transparently. If needed, for example, for driver API interoperability, the primary context of a device can be\naccessed from the driver API as described in\nInteroperability between Runtime and Driver APIs\n.\nWhen a host thread calls\ncudaDeviceReset()\n, this destroys the primary context of the device the host thread currently\noperates on (that is, the current device as defined in\nDevice Selection\n). The next runtime function call made by any\nhost thread that has this device as current will create a new primary context for this device.\nNote\nThe CUDA interfaces use global state that is initialized during host program initiation and destroyed during host program termination. The CUDA runtime and driver cannot detect if this state is invalid, so using any of these interfaces (implicitly or explicitly) during program initiation or termination after main) will result in undefined behavior.\nAs of CUDA 12.0,\ncudaSetDevice()\nwill now explicitly initialize the runtime after changing the current device for the host thread. Previous versions of CUDA delayed runtime initialization on the new device until the first runtime call was made after\ncudaSetDevice()\n. This change means that it is now very important to check the return value of\ncudaSetDevice()\nfor initialization errors.\nThe runtime functions from the error handling and version management sections of the reference manual do not initialize the runtime.\n6.2.2.\nDevice Memory\nï\nAs mentioned in\nHeterogeneous Programming\n, the CUDA programming model assumes a system composed of a host and a device, each with their own separate memory. Kernels operate out of device memory, so the runtime provides functions to allocate, deallocate, and copy device memory, as well as transfer data between host memory and device memory.\nDevice memory can be allocated either as\nlinear memory\nor as\nCUDA arrays\n.\nCUDA arrays are opaque memory layouts optimized for texture fetching. They are described in\nTexture and Surface Memory\n.\nLinear memory is allocated in a single unified address space, which means that separately allocated entities can reference one another via pointers, for example, in a binary tree or linked list. The size of the address space depends on the host system (CPU) and the compute capability of the used GPU:\nTable 4\nLinear Memory Address Space\nï\nx86_64 (AMD64)\nPOWER (ppc64le)\nARM64\nup to compute capability 5.3 (Maxwell)\n40bit\n40bit\n40bit\ncompute capability 6.0 (Pascal) or newer\nup to 47bit\nup to 49bit\nup to 48bit\nNote\nOn devices of compute capability 5.3 (Maxwell) and earlier, the CUDA driver creates an uncommitted 40bit virtual address reservation to ensure that memory allocations (pointers) fall into the supported range. This reservation appears as reserved virtual memory, but does not occupy any physical memory until the program actually allocates memory.\nLinear memory is typically allocated using\ncudaMalloc()\nand freed using\ncudaFree()\nand data transfer between host memory and device memory are typically done using\ncudaMemcpy()\n. In the vector addition code sample of\nKernels\n, the vectors need to be copied from host memory to device memory:\n// Device code\n__global__\nvoid\nVecAdd\n(\nfloat\n*\nA\n,\nfloat\n*\nB\n,\nfloat\n*\nC\n,\nint\nN\n)\n{\nint\ni\n=\nblockDim\n.\nx\n*\nblockIdx\n.\nx\n+\nthreadIdx\n.\nx\n;\nif\n(\ni\n<\nN\n)\nC\n[\ni\n]\n=\nA\n[\ni\n]\n+\nB\n[\ni\n];\n}\n// Host code\nint\nmain\n()\n{\nint\nN\n=\n...;\nsize_t\nsize\n=\nN\n*\nsizeof\n(\nfloat\n);\n// Allocate input vectors h_A and h_B in host memory\nfloat\n*\nh_A\n=\n(\nfloat\n*\n)\nmalloc\n(\nsize\n);\nfloat\n*\nh_B\n=\n(\nfloat\n*\n)\nmalloc\n(\nsize\n);\nfloat\n*\nh_C\n=\n(\nfloat\n*\n)\nmalloc\n(\nsize\n);\n// Initialize input vectors\n...\n// Allocate vectors in device memory\nfloat\n*\nd_A\n;\ncudaMalloc\n(\n&\nd_A\n,\nsize\n);\nfloat\n*\nd_B\n;\ncudaMalloc\n(\n&\nd_B\n,\nsize\n);\nfloat\n*\nd_C\n;\ncudaMalloc\n(\n&\nd_C\n,\nsize\n);\n// Copy vectors from host memory to device memory\ncudaMemcpy\n(\nd_A\n,\nh_A\n,\nsize\n,\ncudaMemcpyHostToDevice\n);\ncudaMemcpy\n(\nd_B\n,\nh_B\n,\nsize\n,\ncudaMemcpyHostToDevice\n);\n// Invoke kernel\nint\nthreadsPerBlock\n=\n256\n;\nint\nblocksPerGrid\n=\n(\nN\n+\nthreadsPerBlock\n-\n1\n)\n/\nthreadsPerBlock\n;\nVecAdd\n<<<\nblocksPerGrid\n,\nthreadsPerBlock\n>>>\n(\nd_A\n,\nd_B\n,\nd_C\n,\nN\n);\n// Copy result from device memory to host memory\n// h_C contains the result in host memory\ncudaMemcpy\n(\nh_C\n,\nd_C\n,\nsize\n,\ncudaMemcpyDeviceToHost\n);\n// Free device memory\ncudaFree\n(\nd_A\n);\ncudaFree\n(\nd_B\n);\ncudaFree\n(\nd_C\n);\n// Free host memory\n...\n}\nLinear memory can also be allocated through\ncudaMallocPitch()\nand\ncudaMalloc3D()\n. These functions are recommended for allocations of 2D or 3D arrays as it makes sure that the allocation is appropriately padded to meet the alignment requirements described in\nDevice Memory Accesses\n, therefore ensuring best performance when accessing the row addresses or performing copies between 2D arrays and other regions of device memory (using the\ncudaMemcpy2D()\nand\ncudaMemcpy3D()\nfunctions). The returned pitch (or stride) must be used to access array elements. The following code sample allocates a\nwidth\nx\nheight\n2D array of floating-point values and shows how to loop over the array elements in device code:\n// Host code\nint\nwidth\n=\n64\n,\nheight\n=\n64\n;\nfloat\n*\ndevPtr\n;\nsize_t\npitch\n;\ncudaMallocPitch\n(\n&\ndevPtr\n,\n&\npitch\n,\nwidth\n*\nsizeof\n(\nfloat\n),\nheight\n);\nMyKernel\n<<<\n100\n,\n512\n>>>\n(\ndevPtr\n,\npitch\n,\nwidth\n,\nheight\n);\n// Device code\n__global__\nvoid\nMyKernel\n(\nfloat\n*\ndevPtr\n,\nsize_t\npitch\n,\nint\nwidth\n,\nint\nheight\n)\n{\nfor\n(\nint\nr\n=\n0\n;\nr\n<\nheight\n;\n++\nr\n)\n{\nfloat\n*\nrow\n=\n(\nfloat\n*\n)((\nchar\n*\n)\ndevPtr\n+\nr\n*\npitch\n);\nfor\n(\nint\nc\n=\n0\n;\nc\n<\nwidth\n;\n++\nc\n)\n{\nfloat\nelement\n=\nrow\n[\nc\n];\n}\n}\n}\nThe following code sample allocates a\nwidth\nx\nheight\nx\ndepth\n3D array of floating-point values and shows how to loop over the array elements in device code:\n// Host code\nint\nwidth\n=\n64\n,\nheight\n=\n64\n,\ndepth\n=\n64\n;\ncudaExtent\nextent\n=\nmake_cudaExtent\n(\nwidth\n*\nsizeof\n(\nfloat\n),\nheight\n,\ndepth\n);\ncudaPitchedPtr\ndevPitchedPtr\n;\ncudaMalloc3D\n(\n&\ndevPitchedPtr\n,\nextent\n);\nMyKernel\n<<<\n100\n,\n512\n>>>\n(\ndevPitchedPtr\n,\nwidth\n,\nheight\n,\ndepth\n);\n// Device code\n__global__\nvoid\nMyKernel\n(\ncudaPitchedPtr\ndevPitchedPtr\n,\nint\nwidth\n,\nint\nheight\n,\nint\ndepth\n)\n{\nchar\n*\ndevPtr\n=\ndevPitchedPtr\n.\nptr\n;\nsize_t\npitch\n=\ndevPitchedPtr\n.\npitch\n;\nsize_t\nslicePitch\n=\npitch\n*\nheight\n;\nfor\n(\nint\nz\n=\n0\n;\nz\n<\ndepth\n;\n++\nz\n)\n{\nchar\n*\nslice\n=\ndevPtr\n+\nz\n*\nslicePitch\n;\nfor\n(\nint\ny\n=\n0\n;\ny\n<\nheight\n;\n++\ny\n)\n{\nfloat\n*\nrow\n=\n(\nfloat\n*\n)(\nslice\n+\ny\n*\npitch\n);\nfor\n(\nint\nx\n=\n0\n;\nx\n<\nwidth\n;\n++\nx\n)\n{\nfloat\nelement\n=\nrow\n[\nx\n];\n}\n}\n}\n}\nNote\nTo avoid allocating too much memory and thus impacting system-wide performance, request the allocation parameters from the user based on the problem size. If the allocation fails, you can fallback to other slower memory types (\ncudaMallocHost()\n,\ncudaHostRegister()\n, etc.), or return an error telling the user how much memory was needed that was denied. If your application cannot request the allocation parameters for some reason, we recommend using\ncudaMallocManaged()\nfor platforms that support it.\nThe reference manual lists all the various functions used to copy memory between linear memory allocated with\ncudaMalloc()\n, linear memory allocated with\ncudaMallocPitch()\nor\ncudaMalloc3D()\n, CUDA arrays, and memory allocated for variables declared in global or constant memory space.\nThe following code sample illustrates various ways of accessing global variables via the runtime API:\n__constant__\nfloat\nconstData\n[\n256\n];\nfloat\ndata\n[\n256\n];\ncudaMemcpyToSymbol\n(\nconstData\n,\ndata\n,\nsizeof\n(\ndata\n));\ncudaMemcpyFromSymbol\n(\ndata\n,\nconstData\n,\nsizeof\n(\ndata\n));\n__device__\nfloat\ndevData\n;\nfloat\nvalue\n=\n3.14f\n;\ncudaMemcpyToSymbol\n(\ndevData\n,\n&\nvalue\n,\nsizeof\n(\nfloat\n));\n__device__\nfloat\n*\ndevPointer\n;\nfloat\n*\nptr\n;\ncudaMalloc\n(\n&\nptr\n,\n256\n*\nsizeof\n(\nfloat\n));\ncudaMemcpyToSymbol\n(\ndevPointer\n,\n&\nptr\n,\nsizeof\n(\nptr\n));\ncudaGetSymbolAddress()\nis used to retrieve the address pointing to the memory allocated for a variable declared in global memory space. The size of the allocated memory is obtained through\ncudaGetSymbolSize()\n.\n6.2.3.\nDevice Memory L2 Access Management\nï\nWhen a CUDA kernel accesses a data region in the global memory repeatedly, such data accesses can be considered to be\npersisting\n. On the other hand, if the data is only accessed once, such data accesses can be considered to be\nstreaming\n.\nStarting with CUDA 11.0, devices of compute capability 8.0 and above have the capability to influence persistence of data in the L2 cache, potentially providing higher bandwidth and lower latency accesses to global memory.\n6.2.3.1.\nL2 Cache Set-Aside for Persisting Accesses\nï\nA portion of the L2 cache can be set aside to be used for persisting data accesses to global memory. Persisting accesses have prioritized use of this set-aside portion of L2 cache, whereas normal or streaming, accesses to global memory can only utilize this portion of L2 when it is unused by persisting accesses.\nThe L2 cache set-aside size for persisting accesses may be adjusted, within limits:\ncudaGetDeviceProperties\n(\n&\nprop\n,\ndevice_id\n);\nsize_t\nsize\n=\nmin\n(\nint\n(\nprop\n.\nl2CacheSize\n*\n0.75\n),\nprop\n.\npersistingL2CacheMaxSize\n);\ncudaDeviceSetLimit\n(\ncudaLimitPersistingL2CacheSize\n,\nsize\n);\n/* set-aside 3/4 of L2 cache for persisting accesses or the max allowed*/\nWhen the GPU is configured in Multi-Instance GPU (MIG) mode, the L2 cache set-aside functionality is disabled.\nWhen using the Multi-Process Service (MPS), the L2 cache set-aside size cannot be changed by\ncudaDeviceSetLimit\n. Instead, the set-aside size can only be specified at start up of MPS server through the environment variable\nCUDA_DEVICE_DEFAULT_PERSISTING_L2_CACHE_PERCENTAGE_LIMIT\n.\n6.2.3.2.\nL2 Policy for Persisting Accesses\nï\nAn access policy window specifies a contiguous region of global memory and a persistence property in the L2 cache for accesses within that region.\nThe code example below shows how to set an L2 persisting access window using a CUDA Stream.\nCUDA Stream Example\ncudaStreamAttrValue\nstream_attribute\n;\n// Stream level attributes data structure\nstream_attribute\n.\naccessPolicyWindow\n.\nbase_ptr\n=\nreinterpret_cast\n<\nvoid\n*>\n(\nptr\n);\n// Global Memory data pointer\nstream_attribute\n.\naccessPolicyWindow\n.\nnum_bytes\n=\nnum_bytes\n;\n// Number of bytes for persistence access.\n// (Must be less than cudaDeviceProp::accessPolicyMaxWindowSize)\nstream_attribute\n.\naccessPolicyWindow\n.\nhitRatio\n=\n0.6\n;\n// Hint for cache hit ratio\nstream_attribute\n.\naccessPolicyWindow\n.\nhitProp\n=\ncudaAccessPropertyPersisting\n;\n// Type of access property on cache hit\nstream_attribute\n.\naccessPolicyWindow\n.\nmissProp\n=\ncudaAccessPropertyStreaming\n;\n// Type of access property on cache miss.\n//Set the attributes to a CUDA stream of type cudaStream_t\ncudaStreamSetAttribute\n(\nstream\n,\ncudaStreamAttributeAccessPolicyWindow\n,\n&\nstream_attribute\n);\nWhen a kernel subsequently executes in CUDA\nstream\n, memory accesses within the global memory extent\n[ptr..ptr+num_bytes)\nare more likely to persist in the L2 cache than accesses to other global memory locations.\nL2 persistence can also be set for a CUDA Graph Kernel Node as shown in the example below:\nCUDA GraphKernelNode Example\ncudaKernelNodeAttrValue\nnode_attribute\n;\n// Kernel level attributes data structure\nnode_attribute\n.\naccessPolicyWindow\n.\nbase_ptr\n=\nreinterpret_cast\n<\nvoid\n*>\n(\nptr\n);\n// Global Memory data pointer\nnode_attribute\n.\naccessPolicyWindow\n.\nnum_bytes\n=\nnum_bytes\n;\n// Number of bytes for persistence access.\n// (Must be less than cudaDeviceProp::accessPolicyMaxWindowSize)\nnode_attribute\n.\naccessPolicyWindow\n.\nhitRatio\n=\n0.6\n;\n// Hint for cache hit ratio\nnode_attribute\n.\naccessPolicyWindow\n.\nhitProp\n=\ncudaAccessPropertyPersisting\n;\n// Type of access property on cache hit\nnode_attribute\n.\naccessPolicyWindow\n.\nmissProp\n=\ncudaAccessPropertyStreaming\n;\n// Type of access property on cache miss.\n//Set the attributes to a CUDA Graph Kernel node of type cudaGraphNode_t\ncudaGraphKernelNodeSetAttribute\n(\nnode\n,\ncudaKernelNodeAttributeAccessPolicyWindow\n,\n&\nnode_attribute\n);\nThe\nhitRatio\nparameter can be used to specify the fraction of accesses that receive the\nhitProp\nproperty. In both of the examples above, 60% of the memory accesses in the global memory region\n[ptr..ptr+num_bytes)\nhave the persisting property and 40% of the memory accesses have the streaming property. Which specific memory accesses are classified as persisting (the\nhitProp\n) is random with a probability of approximately\nhitRatio\n; the probability distribution depends upon the hardware architecture and the memory extent.\nFor example, if the L2 set-aside cache size is 16KB and the\nnum_bytes\nin the\naccessPolicyWindow\nis 32KB:\nWith a\nhitRatio\nof 0.5, the hardware will select, at random, 16KB of the 32KB window to be designated as persisting and cached in the set-aside L2 cache area.\nWith a\nhitRatio\nof 1.0, the hardware will attempt to cache the whole 32KB window in the set-aside L2 cache area. Since the set-aside area is smaller than the window, cache lines will be evicted to keep the most recently used 16KB of the 32KB data in the set-aside portion of the L2 cache.\nThe\nhitRatio\ncan therefore be used to avoid thrashing of cache lines and overall reduce the amount of data moved into and out of the L2 cache.\nA\nhitRatio\nvalue below 1.0 can be used to manually control the amount of data different\naccessPolicyWindow\ns from concurrent CUDA streams can cache in L2. For example, let the L2 set-aside cache size be 16KB; two concurrent kernels in two different CUDA streams, each with a 16KB\naccessPolicyWindow\n, and both with\nhitRatio\nvalue 1.0, might evict each othersâ cache lines when competing for the shared L2 resource. However, if both\naccessPolicyWindows\nhave a hitRatio value of 0.5, they will be less likely to evict their own or each othersâ persisting cache lines.\n6.2.3.3.\nL2 Access Properties\nï\nThree types of access properties are defined for different global memory data accesses:\ncudaAccessPropertyStreaming\n: Memory accesses that occur with the streaming property are less likely to persist in the L2 cache because these accesses are preferentially evicted.\ncudaAccessPropertyPersisting\n: Memory accesses that occur with the persisting property are more likely to persist in the L2 cache because these accesses are preferentially retained in the set-aside portion of L2 cache.\ncudaAccessPropertyNormal\n: This access property forcibly resets previously applied persisting access property to a normal status. Memory accesses with the persisting property from previous CUDA kernels may be retained in L2 cache long after their intended use. This persistence-after-use reduces the amount of L2 cache available to subsequent kernels that do not use the persisting property. Resetting an access property window with the\ncudaAccessPropertyNormal\nproperty removes the persisting (preferential retention) status of the prior access, as if the prior access had been without an access property.\n6.2.3.4.\nL2 Persistence Example\nï\nThe following example shows how to set-aside L2 cache for persistent accesses, use the set-aside L2 cache in CUDA kernels via CUDA Stream and then reset the L2 cache.\ncudaStream_t\nstream\n;\ncudaStreamCreate\n(\n&\nstream\n);\n// Create CUDA stream\ncudaDeviceProp\nprop\n;\n// CUDA device properties variable\ncudaGetDeviceProperties\n(\n&\nprop\n,\ndevice_id\n);\n// Query GPU properties\nsize_t\nsize\n=\nmin\n(\nint\n(\nprop\n.\nl2CacheSize\n*\n0.75\n)\n,\nprop\n.\npersistingL2CacheMaxSize\n);\ncudaDeviceSetLimit\n(\ncudaLimitPersistingL2CacheSize\n,\nsize\n);\n// set-aside 3/4 of L2 cache for persisting accesses or the max allowed\nsize_t\nwindow_size\n=\nmin\n(\nprop\n.\naccessPolicyMaxWindowSize\n,\nnum_bytes\n);\n// Select minimum of user defined num_bytes and max window size.\ncudaStreamAttrValue\nstream_attribute\n;\n// Stream level attributes data structure\nstream_attribute\n.\naccessPolicyWindow\n.\nbase_ptr\n=\nreinterpret_cast\n<\nvoid\n*>\n(\ndata1\n);\n// Global Memory data pointer\nstream_attribute\n.\naccessPolicyWindow\n.\nnum_bytes\n=\nwindow_size\n;\n// Number of bytes for persistence access\nstream_attribute\n.\naccessPolicyWindow\n.\nhitRatio\n=\n0.6\n;\n// Hint for cache hit ratio\nstream_attribute\n.\naccessPolicyWindow\n.\nhitProp\n=\ncudaAccessPropertyPersisting\n;\n// Persistence Property\nstream_attribute\n.\naccessPolicyWindow\n.\nmissProp\n=\ncudaAccessPropertyStreaming\n;\n// Type of access property on cache miss\ncudaStreamSetAttribute\n(\nstream\n,\ncudaStreamAttributeAccessPolicyWindow\n,\n&\nstream_attribute\n);\n// Set the attributes to a CUDA Stream\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n10\n;\ni\n++\n)\n{\ncuda_kernelA\n<<<\ngrid_size\n,\nblock_size\n,\n0\n,\nstream\n>>>\n(\ndata1\n);\n// This data1 is used by a kernel multiple times\n}\n// [data1 + num_bytes) benefits from L2 persistence\ncuda_kernelB\n<<<\ngrid_size\n,\nblock_size\n,\n0\n,\nstream\n>>>\n(\ndata1\n);\n// A different kernel in the same stream can also benefit\n// from the persistence of data1\nstream_attribute\n.\naccessPolicyWindow\n.\nnum_bytes\n=\n0\n;\n// Setting the window size to 0 disable it\ncudaStreamSetAttribute\n(\nstream\n,\ncudaStreamAttributeAccessPolicyWindow\n,\n&\nstream_attribute\n);\n// Overwrite the access policy attribute to a CUDA Stream\ncudaCtxResetPersistingL2Cache\n();\n// Remove any persistent lines in L2\ncuda_kernelC\n<<<\ngrid_size\n,\nblock_size\n,\n0\n,\nstream\n>>>\n(\ndata2\n);\n// data2 can now benefit from full L2 in normal mode\n6.2.3.5.\nReset L2 Access to Normal\nï\nA persisting L2 cache line from a previous CUDA kernel may persist in L2 long after it has been used. Hence, a reset to normal for L2 cache is important for streaming or normal memory accesses to utilize the L2 cache with normal priority. There are three ways a persisting access can be reset to normal status.\nReset a previous persisting memory region with the access property,\ncudaAccessPropertyNormal\n.\nReset all persisting L2 cache lines to normal by calling\ncudaCtxResetPersistingL2Cache()\n.\nEventually\nuntouched lines are automatically reset to normal. Reliance on automatic reset is strongly discouraged because of the undetermined length of time required for automatic reset to occur.\n6.2.3.6.\nManage Utilization of L2 set-aside cache\nï\nMultiple CUDA kernels executing concurrently in different CUDA streams may have a different access policy window assigned to their streams. However, the L2 set-aside cache portion is shared among all these concurrent CUDA kernels. As a result, the net utilization of this set-aside cache portion is the sum of all the concurrent kernelsâ individual use. The benefits of designating memory accesses as persisting diminish as the volume of persisting accesses exceeds the set-aside L2 cache capacity.\nTo manage utilization of the set-aside L2 cache portion, an application must consider the following:\nSize of L2 set-aside cache.\nCUDA kernels that may concurrently execute.\nThe access policy window for all the CUDA kernels that may concurrently execute.\nWhen and how L2 reset is required to allow normal or streaming accesses to utilize the previously set-aside L2 cache with equal priority.\n6.2.3.7.\nQuery L2 cache Properties\nï\nProperties related to L2 cache are a part of\ncudaDeviceProp\nstruct and can be queried using CUDA runtime API\ncudaGetDeviceProperties\nCUDA Device Properties include:\nl2CacheSize\n: The amount of available L2 cache on the GPU.\npersistingL2CacheMaxSize\n: The maximum amount of L2 cache that can be set-aside for persisting memory accesses.\naccessPolicyMaxWindowSize\n: The maximum size of the access policy window.\n6.2.3.8.\nControl L2 Cache Set-Aside Size for Persisting Memory Access\nï\nThe L2 set-aside cache size for persisting memory accesses is queried using CUDA runtime API\ncudaDeviceGetLimit\nand set using CUDA runtime API\ncudaDeviceSetLimit\nas a\ncudaLimit\n. The maximum value for setting this limit is\ncudaDeviceProp::persistingL2CacheMaxSize\n.\nenum\ncudaLimit\n{\n/* other fields not shown */\ncudaLimitPersistingL2CacheSize\n};\n6.2.4.\nShared Memory\nï\nAs detailed in\nVariable Memory Space Specifiers\nshared memory is allocated using the\n__shared__\nmemory space specifier.\nShared memory is expected to be much faster than global memory as mentioned in\nThread Hierarchy\nand detailed in\nShared Memory\n. It can be used as scratchpad memory (or software managed cache) to minimize global memory accesses from a CUDA block as illustrated by the following matrix multiplication example.\nThe following code sample is a straightforward implementation of matrix multiplication that does not take advantage of shared memory. Each thread reads one row of\nA\nand one column of\nB\nand computes the corresponding element of\nC\nas illustrated in\nFigure 8\n.\nA\nis therefore read\nB.width\ntimes from global memory and\nB\nis read\nA.height\ntimes.\n// Matrices are stored in row-major order:\n// M(row, col) = *(M.elements + row * M.width + col)\ntypedef\nstruct\n{\nint\nwidth\n;\nint\nheight\n;\nfloat\n*\nelements\n;\n}\nMatrix\n;\n// Thread block size\n#define BLOCK_SIZE 16\n// Forward declaration of the matrix multiplication kernel\n__global__\nvoid\nMatMulKernel\n(\nconst\nMatrix\n,\nconst\nMatrix\n,\nMatrix\n);\n// Matrix multiplication - Host code\n// Matrix dimensions are assumed to be multiples of BLOCK_SIZE\nvoid\nMatMul\n(\nconst\nMatrix\nA\n,\nconst\nMatrix\nB\n,\nMatrix\nC\n)\n{\n// Load A and B to device memory\nMatrix\nd_A\n;\nd_A\n.\nwidth\n=\nA\n.\nwidth\n;\nd_A\n.\nheight\n=\nA\n.\nheight\n;\nsize_t\nsize\n=\nA\n.\nwidth\n*\nA\n.\nheight\n*\nsizeof\n(\nfloat\n);\ncudaMalloc\n(\n&\nd_A\n.\nelements\n,\nsize\n);\ncudaMemcpy\n(\nd_A\n.\nelements\n,\nA\n.\nelements\n,\nsize\n,\ncudaMemcpyHostToDevice\n);\nMatrix\nd_B\n;\nd_B\n.\nwidth\n=\nB\n.\nwidth\n;\nd_B\n.\nheight\n=\nB\n.\nheight\n;\nsize\n=\nB\n.\nwidth\n*\nB\n.\nheight\n*\nsizeof\n(\nfloat\n);\ncudaMalloc\n(\n&\nd_B\n.\nelements\n,\nsize\n);\ncudaMemcpy\n(\nd_B\n.\nelements\n,\nB\n.\nelements\n,\nsize\n,\ncudaMemcpyHostToDevice\n);\n// Allocate C in device memory\nMatrix\nd_C\n;\nd_C\n.\nwidth\n=\nC\n.\nwidth\n;\nd_C\n.\nheight\n=\nC\n.\nheight\n;\nsize\n=\nC\n.\nwidth\n*\nC\n.\nheight\n*\nsizeof\n(\nfloat\n);\ncudaMalloc\n(\n&\nd_C\n.\nelements\n,\nsize\n);\n// Invoke kernel\ndim3\ndimBlock\n(\nBLOCK_SIZE\n,\nBLOCK_SIZE\n);\ndim3\ndimGrid\n(\nB\n.\nwidth\n/\ndimBlock\n.\nx\n,\nA\n.\nheight\n/\ndimBlock\n.\ny\n);\nMatMulKernel\n<<<\ndimGrid\n,\ndimBlock\n>>>\n(\nd_A\n,\nd_B\n,\nd_C\n);\n// Read C from device memory\ncudaMemcpy\n(\nC\n.\nelements\n,\nd_C\n.\nelements\n,\nsize\n,\ncudaMemcpyDeviceToHost\n);\n// Free device memory\ncudaFree\n(\nd_A\n.\nelements\n);\ncudaFree\n(\nd_B\n.\nelements\n);\ncudaFree\n(\nd_C\n.\nelements\n);\n}\n// Matrix multiplication kernel called by MatMul()\n__global__\nvoid\nMatMulKernel\n(\nMatrix\nA\n,\nMatrix\nB\n,\nMatrix\nC\n)\n{\n// Each thread computes one element of C\n// by accumulating results into Cvalue\nfloat\nCvalue\n=\n0\n;\nint\nrow\n=\nblockIdx\n.\ny\n*\nblockDim\n.\ny\n+\nthreadIdx\n.\ny\n;\nint\ncol\n=\nblockIdx\n.\nx\n*\nblockDim\n.\nx\n+\nthreadIdx\n.\nx\n;\nfor\n(\nint\ne\n=\n0\n;\ne\n<\nA\n.\nwidth\n;\n++\ne\n)\nCvalue\n+=\nA\n.\nelements\n[\nrow\n*\nA\n.\nwidth\n+\ne\n]\n*\nB\n.\nelements\n[\ne\n*\nB\n.\nwidth\n+\ncol\n];\nC\n.\nelements\n[\nrow\n*\nC\n.\nwidth\n+\ncol\n]\n=\nCvalue\n;\n}\nFigure 8\nMatrix Multiplication without Shared Memory\nï\nThe following code sample is an implementation of matrix multiplication that does take advantage of shared memory. In this implementation, each thread block is responsible for computing one square sub-matrix\nCsub\nof\nC\nand each thread within the block is responsible for computing one element of\nCsub\n. As illustrated in\nFigure 9\n,\nCsub\nis equal to the product of two rectangular matrices: the sub-matrix of\nA\nof dimension (\nA.width, block_size\n) that has the same row indices as\nCsub\n, and the sub-matrix of\nB\nof dimension (\nblock_size, A.width\n)that has the same column indices as\nCsub\n. In order to fit into the deviceâs resources, these two rectangular matrices are divided into as many square matrices of dimension\nblock_size\nas necessary and\nCsub\nis computed as the sum of the products of these square matrices. Each of these products is performed by first loading the two corresponding square matrices from global memory to shared memory with one thread loading one element of each matrix, and then by having each thread compute one element of the product. Each thread accumulates the result of each of these products into a register and once done writes the result to global memory.\nBy blocking the computation this way, we take advantage of fast shared memory and save a lot of global memory bandwidth since\nA\nis only read (\nB.width / block_size\n) times from global memory and\nB\nis read (\nA.height / block_size\n) times.\nThe\nMatrix\ntype from the previous code sample is augmented with a\nstride\nfield, so that sub-matrices can be efficiently represented with the same type.\n__device__\nfunctions are used to get and set elements and build any sub-matrix from a matrix.\n// Matrices are stored in row-major order:\n// M(row, col) = *(M.elements + row * M.stride + col)\ntypedef\nstruct\n{\nint\nwidth\n;\nint\nheight\n;\nint\nstride\n;\nfloat\n*\nelements\n;\n}\nMatrix\n;\n// Get a matrix element\n__device__\nfloat\nGetElement\n(\nconst\nMatrix\nA\n,\nint\nrow\n,\nint\ncol\n)\n{\nreturn\nA\n.\nelements\n[\nrow\n*\nA\n.\nstride\n+\ncol\n];\n}\n// Set a matrix element\n__device__\nvoid\nSetElement\n(\nMatrix\nA\n,\nint\nrow\n,\nint\ncol\n,\nfloat\nvalue\n)\n{\nA\n.\nelements\n[\nrow\n*\nA\n.\nstride\n+\ncol\n]\n=\nvalue\n;\n}\n// Get the BLOCK_SIZExBLOCK_SIZE sub-matrix Asub of A that is\n// located col sub-matrices to the right and row sub-matrices down\n// from the upper-left corner of A\n__device__\nMatrix\nGetSubMatrix\n(\nMatrix\nA\n,\nint\nrow\n,\nint\ncol\n)\n{\nMatrix\nAsub\n;\nAsub\n.\nwidth\n=\nBLOCK_SIZE\n;\nAsub\n.\nheight\n=\nBLOCK_SIZE\n;\nAsub\n.\nstride\n=\nA\n.\nstride\n;\nAsub\n.\nelements\n=\n&\nA\n.\nelements\n[\nA\n.\nstride\n*\nBLOCK_SIZE\n*\nrow\n+\nBLOCK_SIZE\n*\ncol\n];\nreturn\nAsub\n;\n}\n// Thread block size\n#define BLOCK_SIZE 16\n// Forward declaration of the matrix multiplication kernel\n__global__\nvoid\nMatMulKernel\n(\nconst\nMatrix\n,\nconst\nMatrix\n,\nMatrix\n);\n// Matrix multiplication - Host code\n// Matrix dimensions are assumed to be multiples of BLOCK_SIZE\nvoid\nMatMul\n(\nconst\nMatrix\nA\n,\nconst\nMatrix\nB\n,\nMatrix\nC\n)\n{\n// Load A and B to device memory\nMatrix\nd_A\n;\nd_A\n.\nwidth\n=\nd_A\n.\nstride\n=\nA\n.\nwidth\n;\nd_A\n.\nheight\n=\nA\n.\nheight\n;\nsize_t\nsize\n=\nA\n.\nwidth\n*\nA\n.\nheight\n*\nsizeof\n(\nfloat\n);\ncudaMalloc\n(\n&\nd_A\n.\nelements\n,\nsize\n);\ncudaMemcpy\n(\nd_A\n.\nelements\n,\nA\n.\nelements\n,\nsize\n,\ncudaMemcpyHostToDevice\n);\nMatrix\nd_B\n;\nd_B\n.\nwidth\n=\nd_B\n.\nstride\n=\nB\n.\nwidth\n;\nd_B\n.\nheight\n=\nB\n.\nheight\n;\nsize\n=\nB\n.\nwidth\n*\nB\n.\nheight\n*\nsizeof\n(\nfloat\n);\ncudaMalloc\n(\n&\nd_B\n.\nelements\n,\nsize\n);\ncudaMemcpy\n(\nd_B\n.\nelements\n,\nB\n.\nelements\n,\nsize\n,\ncudaMemcpyHostToDevice\n);\n// Allocate C in device memory\nMatrix\nd_C\n;\nd_C\n.\nwidth\n=\nd_C\n.\nstride\n=\nC\n.\nwidth\n;\nd_C\n.\nheight\n=\nC\n.\nheight\n;\nsize\n=\nC\n.\nwidth\n*\nC\n.\nheight\n*\nsizeof\n(\nfloat\n);\ncudaMalloc\n(\n&\nd_C\n.\nelements\n,\nsize\n);\n// Invoke kernel\ndim3\ndimBlock\n(\nBLOCK_SIZE\n,\nBLOCK_SIZE\n);\ndim3\ndimGrid\n(\nB\n.\nwidth\n/\ndimBlock\n.\nx\n,\nA\n.\nheight\n/\ndimBlock\n.\ny\n);\nMatMulKernel\n<<<\ndimGrid\n,\ndimBlock\n>>>\n(\nd_A\n,\nd_B\n,\nd_C\n);\n// Read C from device memory\ncudaMemcpy\n(\nC\n.\nelements\n,\nd_C\n.\nelements\n,\nsize\n,\ncudaMemcpyDeviceToHost\n);\n// Free device memory\ncudaFree\n(\nd_A\n.\nelements\n);\ncudaFree\n(\nd_B\n.\nelements\n);\ncudaFree\n(\nd_C\n.\nelements\n);\n}\n// Matrix multiplication kernel called by MatMul()\n__global__\nvoid\nMatMulKernel\n(\nMatrix\nA\n,\nMatrix\nB\n,\nMatrix\nC\n)\n{\n// Block row and column\nint\nblockRow\n=\nblockIdx\n.\ny\n;\nint\nblockCol\n=\nblockIdx\n.\nx\n;\n// Each thread block computes one sub-matrix Csub of C\nMatrix\nCsub\n=\nGetSubMatrix\n(\nC\n,\nblockRow\n,\nblockCol\n);\n// Each thread computes one element of Csub\n// by accumulating results into Cvalue\nfloat\nCvalue\n=\n0\n;\n// Thread row and column within Csub\nint\nrow\n=\nthreadIdx\n.\ny\n;\nint\ncol\n=\nthreadIdx\n.\nx\n;\n// Loop over all the sub-matrices of A and B that are\n// required to compute Csub\n// Multiply each pair of sub-matrices together\n// and accumulate the results\nfor\n(\nint\nm\n=\n0\n;\nm\n<\n(\nA\n.\nwidth\n/\nBLOCK_SIZE\n);\n++\nm\n)\n{\n// Get sub-matrix Asub of A\nMatrix\nAsub\n=\nGetSubMatrix\n(\nA\n,\nblockRow\n,\nm\n);\n// Get sub-matrix Bsub of B\nMatrix\nBsub\n=\nGetSubMatrix\n(\nB\n,\nm\n,\nblockCol\n);\n// Shared memory used to store Asub and Bsub respectively\n__shared__\nfloat\nAs\n[\nBLOCK_SIZE\n][\nBLOCK_SIZE\n];\n__shared__\nfloat\nBs\n[\nBLOCK_SIZE\n][\nBLOCK_SIZE\n];\n// Load Asub and Bsub from device memory to shared memory\n// Each thread loads one element of each sub-matrix\nAs\n[\nrow\n][\ncol\n]\n=\nGetElement\n(\nAsub\n,\nrow\n,\ncol\n);\nBs\n[\nrow\n][\ncol\n]\n=\nGetElement\n(\nBsub\n,\nrow\n,\ncol\n);\n// Synchronize to make sure the sub-matrices are loaded\n// before starting the computation\n__syncthreads\n();\n// Multiply Asub and Bsub together\nfor\n(\nint\ne\n=\n0\n;\ne\n<\nBLOCK_SIZE\n;\n++\ne\n)\nCvalue\n+=\nAs\n[\nrow\n][\ne\n]\n*\nBs\n[\ne\n][\ncol\n];\n// Synchronize to make sure that the preceding\n// computation is done before loading two new\n// sub-matrices of A and B in the next iteration\n__syncthreads\n();\n}\n// Write Csub to device memory\n// Each thread writes one element\nSetElement\n(\nCsub\n,\nrow\n,\ncol\n,\nCvalue\n);\n}\nFigure 9\nMatrix Multiplication with Shared Memory\nï\n6.2.5.\nDistributed Shared Memory\nï\nThread block clusters introduced in compute capability 9.0 provide the ability for threads in a thread block cluster to access shared memory of all the participating thread blocks in a cluster. This partitioned shared memory is called\nDistributed Shared Memory\n, and the corresponding address space is called Distributed shared memory address space. Threads that belong to a thread block cluster, can read, write or perform atomics in the distributed address space, regardless whether the address belongs to the local thread block or a remote thread block. Whether a kernel uses distributed shared memory or not, the shared memory size specifications, static or dynamic is still per thread block. The size of distributed shared memory is just the number of thread blocks per cluster multiplied by the size of shared memory per thread block.\nAccessing data in distributed shared memory requires all the thread blocks to exist. A user can guarantee that all thread blocks have started executing using\ncluster.sync()\nfrom\nCluster Group\nAPI.\nThe user also needs to ensure that all distributed shared memory operations happen before the exit of a thread block, e.g., if a remote thread block is trying to read a given thread blockâs shared memory, user needs to ensure that the shared memory read by remote thread block is completed before it can exit.\nCUDA provides a mechanism to access to distributed shared memory, and applications can benefit from leveraging its capabilities. Lets look at a simple histogram computation and how to optimize it on the GPU using thread block cluster. A standard way of computing histograms is do the computation in the shared memory of each thread block and then perform global memory atomics. A limitation of this approach is the shared memory capacity. Once the histogram bins no longer fit in the shared memory, a user needs to directly compute histograms and hence the atomics in the global memory. With distributed shared memory, CUDA provides an intermediate step, where a depending on the histogram bins size, histogram can be computed in shared memory, distributed shared memory or global memory directly.\nThe CUDA kernel example below shows how to compute histograms in shared memory or distributed shared memory, depending on the number of histogram bins.\n#include\n<cooperative_groups.h>\n// Distributed Shared memory histogram kernel\n__global__\nvoid\nclusterHist_kernel\n(\nint\n*\nbins\n,\nconst\nint\nnbins\n,\nconst\nint\nbins_per_block\n,\nconst\nint\n*\n__restrict__\ninput\n,\nsize_t\narray_size\n)\n{\nextern\n__shared__\nint\nsmem\n[];\nnamespace\ncg\n=\ncooperative_groups\n;\nint\ntid\n=\ncg\n::\nthis_grid\n().\nthread_rank\n();\n// Cluster initialization, size and calculating local bin offsets.\ncg\n::\ncluster_group\ncluster\n=\ncg\n::\nthis_cluster\n();\nunsigned\nint\nclusterBlockRank\n=\ncluster\n.\nblock_rank\n();\nint\ncluster_size\n=\ncluster\n.\ndim_blocks\n().\nx\n;\nfor\n(\nint\ni\n=\nthreadIdx\n.\nx\n;\ni\n<\nbins_per_block\n;\ni\n+=\nblockDim\n.\nx\n)\n{\nsmem\n[\ni\n]\n=\n0\n;\n//Initialize shared memory histogram to zeros\n}\n// cluster synchronization ensures that shared memory is initialized to zero in\n// all thread blocks in the cluster. It also ensures that all thread blocks\n// have started executing and they exist concurrently.\ncluster\n.\nsync\n();\nfor\n(\nint\ni\n=\ntid\n;\ni\n<\narray_size\n;\ni\n+=\nblockDim\n.\nx\n*\ngridDim\n.\nx\n)\n{\nint\nldata\n=\ninput\n[\ni\n];\n//Find the right histogram bin.\nint\nbinid\n=\nldata\n;\nif\n(\nldata\n<\n0\n)\nbinid\n=\n0\n;\nelse\nif\n(\nldata\n>=\nnbins\n)\nbinid\n=\nnbins\n-\n1\n;\n//Find destination block rank and offset for computing\n//distributed shared memory histogram\nint\ndst_block_rank\n=\n(\nint\n)(\nbinid\n/\nbins_per_block\n);\nint\ndst_offset\n=\nbinid\n%\nbins_per_block\n;\n//Pointer to target block shared memory\nint\n*\ndst_smem\n=\ncluster\n.\nmap_shared_rank\n(\nsmem\n,\ndst_block_rank\n);\n//Perform atomic update of the histogram bin\natomicAdd\n(\ndst_smem\n+\ndst_offset\n,\n1\n);\n}\n// cluster synchronization is required to ensure all distributed shared\n// memory operations are completed and no thread block exits while\n// other thread blocks are still accessing distributed shared memory\ncluster\n.\nsync\n();\n// Perform global memory histogram, using the local distributed memory histogram\nint\n*\nlbins\n=\nbins\n+\ncluster\n.\nblock_rank\n()\n*\nbins_per_block\n;\nfor\n(\nint\ni\n=\nthreadIdx\n.\nx\n;\ni\n<\nbins_per_block\n;\ni\n+=\nblockDim\n.\nx\n)\n{\natomicAdd\n(\n&\nlbins\n[\ni\n],\nsmem\n[\ni\n]);\n}\n}\nThe above kernel can be launched at runtime with a cluster size depending on the amount of distributed shared memory required. If histogram is small enough to fit in shared memory of just one block, user can launch kernel with cluster size 1. The code snippet below shows how to launch a cluster kernel dynamically based depending on shared memory requirements.\n// Launch via extensible launch\n{\ncudaLaunchConfig_t\nconfig\n=\n{\n0\n};\nconfig\n.\ngridDim\n=\narray_size\n/\nthreads_per_block\n;\nconfig\n.\nblockDim\n=\nthreads_per_block\n;\n// cluster_size depends on the histogram size.\n// ( cluster_size == 1 ) implies no distributed shared memory, just thread block local shared memory\nint\ncluster_size\n=\n2\n;\n// size 2 is an example here\nint\nnbins_per_block\n=\nnbins\n/\ncluster_size\n;\n//dynamic shared memory size is per block.\n//Distributed shared memory size =  cluster_size * nbins_per_block * sizeof(int)\nconfig\n.\ndynamicSmemBytes\n=\nnbins_per_block\n*\nsizeof\n(\nint\n);\nCUDA_CHECK\n(\n::\ncudaFuncSetAttribute\n((\nvoid\n*\n)\nclusterHist_kernel\n,\ncudaFuncAttributeMaxDynamicSharedMemorySize\n,\nconfig\n.\ndynamicSmemBytes\n));\ncudaLaunchAttribute\nattribute\n[\n1\n];\nattribute\n[\n0\n].\nid\n=\ncudaLaunchAttributeClusterDimension\n;\nattribute\n[\n0\n].\nval\n.\nclusterDim\n.\nx\n=\ncluster_size\n;\nattribute\n[\n0\n].\nval\n.\nclusterDim\n.\ny\n=\n1\n;\nattribute\n[\n0\n].\nval\n.\nclusterDim\n.\nz\n=\n1\n;\nconfig\n.\nnumAttrs\n=\n1\n;\nconfig\n.\nattrs\n=\nattribute\n;\ncudaLaunchKernelEx\n(\n&\nconfig\n,\nclusterHist_kernel\n,\nbins\n,\nnbins\n,\nnbins_per_block\n,\ninput\n,\narray_size\n);\n}\n6.2.6.\nPage-Locked Host Memory\nï\nThe runtime provides functions to allow the use of\npage-locked\n(also known as\npinned\n) host memory (as opposed to regular pageable host memory allocated by\nmalloc()\n):\ncudaHostAlloc()\nand\ncudaFreeHost()\nallocate and free page-locked host memory;\ncudaHostRegister()\npage-locks a range of memory allocated by\nmalloc()\n(see reference manual for limitations).\nUsing page-locked host memory has several benefits:\nCopies between page-locked host memory and device memory can be performed concurrently with kernel execution for some devices as mentioned in\nAsynchronous Concurrent Execution\n.\nOn some devices, page-locked host memory can be mapped into the address space of the device, eliminating the need to copy it to or from device memory as detailed in\nMapped Memory\n.\nOn systems with a front-side bus, bandwidth between host memory and device memory is higher if host memory is allocated as page-locked and even higher if in addition it is allocated as write-combining as described in\nWrite-Combining Memory\n.\nNote\nPage-locked host memory is not cached on non I/O coherent Tegra devices. Also,\ncudaHostRegister()\nis not supported on non I/O coherent Tegra devices.\nThe simple zero-copy CUDA sample comes with a detailed document on the page-locked memory APIs.\n6.2.6.1.\nPortable Memory\nï\nA block of page-locked memory can be used in conjunction with any device in the system (see\nMulti-Device System\nfor more details on multi-device systems), but by default, the benefits of using page-locked memory described above are only available in conjunction with the device that was current when the block was allocated (and with all devices sharing the same unified address space, if any, as described in\nUnified Virtual Address Space\n). To make these advantages available to all devices, the block needs to be allocated by passing the flag\ncudaHostAllocPortable\nto\ncudaHostAlloc()\nor page-locked by passing the flag\ncudaHostRegisterPortable\nto\ncudaHostRegister()\n.\n6.2.6.2.\nWrite-Combining Memory\nï\nBy default page-locked host memory is allocated as cacheable. It can optionally be allocated as\nwrite-combining\ninstead by passing flag\ncudaHostAllocWriteCombined\nto\ncudaHostAlloc()\n. Write-combining memory frees up the hostâs L1 and L2 cache resources, making more cache available to the rest of the application. In addition, write-combining memory is not snooped during transfers across the PCI Express bus, which can improve transfer performance by up to 40%.\nReading from write-combining memory from the host is prohibitively slow, so write-combining memory should in general be used for memory that the host only writes to.\nUsing CPU atomic instructions on WC memory should be avoided because not all CPU implementations guarantee that functionality.\n6.2.6.3.\nMapped Memory\nï\nA block of page-locked host memory can also be mapped into the address space of the device by passing flag\ncudaHostAllocMapped\nto\ncudaHostAlloc()\nor by passing flag\ncudaHostRegisterMapped\nto\ncudaHostRegister()\n. Such a block has therefore in general two addresses: one in host memory that is returned by\ncudaHostAlloc()\nor\nmalloc()\n, and one in device memory that can be retrieved using\ncudaHostGetDevicePointer()\nand then used to access the block from within a kernel. The only exception is for pointers allocated with\ncudaHostAlloc()\nand when a unified address space is used for the host and the device as mentioned in\nUnified Virtual Address Space\n.\nAccessing host memory directly from within a kernel does not provide the same bandwidth as device memory, but does have some advantages:\nThere is no need to allocate a block in device memory and copy data between this block and the block in host memory; data transfers are implicitly performed as needed by the kernel;\nThere is no need to use streams (see\nConcurrent Data Transfers\n) to overlap data transfers with kernel execution; the kernel-originated data transfers automatically overlap with kernel execution.\nSince mapped page-locked memory is shared between host and device however, the application must synchronize memory accesses using streams or events (see\nAsynchronous Concurrent Execution\n) to avoid any potential read-after-write, write-after-read, or write-after-write hazards.\nTo be able to retrieve the device pointer to any mapped page-locked memory, page-locked memory mapping must be enabled by calling\ncudaSetDeviceFlags()\nwith the\ncudaDeviceMapHost\nflag before any other CUDA call is performed. Otherwise,\ncudaHostGetDevicePointer()\nwill return an error.\ncudaHostGetDevicePointer()\nalso returns an error if the device does not support mapped page-locked host memory. Applications may query this capability by checking the\ncanMapHostMemory\ndevice property (see\nDevice Enumeration\n), which is equal to 1 for devices that support mapped page-locked host memory.\nNote that atomic functions (see\nAtomic Functions\n) operating on mapped page-locked memory are not atomic from the point of view of the host or other devices.\nAlso note that CUDA runtime requires that 1-byte, 2-byte, 4-byte, 8-byte, and 16-byte naturally aligned\nloads and stores to host memory initiated from the device are preserved as single accesses\nfrom the point of view of the host and other devices.\nOn some platforms, atomics to memory may be broken by the hardware into separate\nload and store operations.\nThese component load and store operations have the same requirements on preservation of naturally aligned accesses.\nThe CUDA runtime does not support a PCI Express bus topology where a PCI Express bridge splits\n8-byte naturally aligned operations and NVIDIA is not aware of any topology that splits\n16-byte naturally aligned operations.\n6.2.7.\nMemory Synchronization Domains\nï\n6.2.7.1.\nMemory Fence Interference\nï\nSome CUDA applications may see degraded performance due to memory fence/flush operations waiting on more transactions than those necessitated by the CUDA memory consistency model.\n__managed__\nint\nx\n=\n0\n;\n__device__\ncuda\n::\natomic\n<\nint\n,\ncuda\n::\nthread_scope_device\n>\na\n(\n0\n);\n__managed__\ncuda\n::\natomic\n<\nint\n,\ncuda\n::\nthread_scope_system\n>\nb\n(\n0\n);\nThread 1 (SM)\nx\n=\n1\n;\na\n=\n1\n;\nThread 2 (SM)\nwhile\n(\na\n!=\n1\n)\n;\nassert\n(\nx\n==\n1\n);\nb\n=\n1\n;\nThread 3 (CPU)\nwhile\n(\nb\n!=\n1\n)\n;\nassert\n(\nx\n==\n1\n);\nConsider the example above. The CUDA memory consistency model guarantees that the asserted condition will be true, so the write to\nx\nfrom thread 1 must be visible to thread 3, before the write to\nb\nfrom thread 2.\nThe memory ordering provided by the release and acquire of\na\nis only sufficient to make\nx\nvisible to thread 2, not thread 3, as it is a device-scope operation. The system-scope ordering provided by release and acquire of\nb\n, therefore, needs to ensure not only writes issued from thread 2 itself are visible to thread 3, but also writes from other threads that are visible to thread 2. This is known as cumulativity. As the GPU cannot know at the time of execution which writes have been guaranteed at the source level to be visible and which are visible only by chance timing, it must cast a conservatively wide net for in-flight memory operations.\nThis sometimes leads to interference: because the GPU is waiting on memory operations it is not required to at the source level, the fence/flush may take longer than necessary.\nNote that fences may occur explicitly as intrinsics or atomics in code, like in the example, or implicitly to implement\nsynchronizes-with\nrelationships at task boundaries.\nA common example is when a kernel is performing computation in local GPU memory, and a parallel kernel (e.g. from NCCL) is performing communications with a peer. Upon completion, the local kernel will implicitly flush its writes to satisfy any\nsynchronizes-with\nrelationships to downstream work. This may unnecessarily wait, fully or partially, on slower nvlink or PCIe writes from the communication kernel.\n6.2.7.2.\nIsolating Traffic with Domains\nï\nBeginning with Hopper architecture GPUs and CUDA 12.0, the memory synchronization domains feature provides a way to alleviate such interference. In exchange for explicit assistance from code, the GPU can reduce the net cast by a fence operation. Each kernel launch is given a domain ID. Writes and fences are tagged with the ID, and a fence will only order writes matching the fenceâs domain. In the concurrent compute vs communication example, the communication kernels can be placed in a different domain.\nWhen using domains, code must abide by the rule that\nordering or synchronization between distinct domains on the same GPU requires system-scope fencing\n. Within a domain, device-scope fencing remains sufficient. This is necessary for cumulativity as one kernelâs writes will not be encompassed by a fence issued from a kernel in another domain. In essence, cumulativity is satisfied by ensuring that cross-domain traffic is flushed to the system scope ahead of time.\nNote that this modifies the definition of\nthread_scope_device\n. However, because kernels will default to domain 0 as described below, backward compatibility is maintained.\n6.2.7.3.\nUsing Domains in CUDA\nï\nDomains are accessible via the new launch attributes\ncudaLaunchAttributeMemSyncDomain\nand\ncudaLaunchAttributeMemSyncDomainMap\n. The former selects between logical domains\ncudaLaunchMemSyncDomainDefault\nand\ncudaLaunchMemSyncDomainRemote\n, and the latter provides a mapping from logical to physical domains. The remote domain is intended for kernels performing remote memory access in order to isolate their memory traffic from local kernels. Note, however, the selection of a particular domain does not affect what memory access a kernel may legally perform.\nThe domain count can be queried via device attribute\ncudaDevAttrMemSyncDomainCount\n. Hopper has 4 domains. To facilitate portable code, domains functionality can be used on all devices and CUDA will report a count of 1 prior to Hopper.\nHaving logical domains eases application composition. An individual kernel launch at a low level in the stack, such as from NCCL, can select a semantic logical domain without concern for the surrounding application architecture. Higher levels can steer logical domains using the mapping. The default value for the logical domain if it is not set is the default domain, and the default mapping is to map the default domain to 0 and the remote domain to 1 (on GPUs with more than 1 domain). Specific libraries may tag launches with the remote domain in CUDA 12.0 and later; for example, NCCL 2.16 will do so. Together, this provides a beneficial use pattern for common applications out of the box, with no code changes needed in other components, frameworks, or at application level. An alternative use pattern, for example in an application using nvshmem or with no clear separation of kernel types, could be to partition parallel streams. Stream A may map both logical domains to physical domain 0, stream B to 1, and so on.\n// Example of launching a kernel with the remote logical domain\ncudaLaunchAttribute\ndomainAttr\n;\ndomainAttr\n.\nid\n=\ncudaLaunchAttrMemSyncDomain\n;\ndomainAttr\n.\nval\n=\ncudaLaunchMemSyncDomainRemote\n;\ncudaLaunchConfig_t\nconfig\n;\n// Fill out other config fields\nconfig\n.\nattrs\n=\n&\ndomainAttr\n;\nconfig\n.\nnumAttrs\n=\n1\n;\ncudaLaunchKernelEx\n(\n&\nconfig\n,\nmyKernel\n,\nkernelArg1\n,\nkernelArg2\n...);\n// Example of setting a mapping for a stream\n// (This mapping is the default for streams starting on Hopper if not\n// explicitly set, and provided for illustration)\ncudaLaunchAttributeValue\nmapAttr\n;\nmapAttr\n.\nmemSyncDomainMap\n.\ndefault_\n=\n0\n;\nmapAttr\n.\nmemSyncDomainMap\n.\nremote\n=\n1\n;\ncudaStreamSetAttribute\n(\nstream\n,\ncudaLaunchAttributeMemSyncDomainMap\n,\n&\nmapAttr\n);\n// Example of mapping different streams to different physical domains, ignoring\n// logical domain settings\ncudaLaunchAttributeValue\nmapAttr\n;\nmapAttr\n.\nmemSyncDomainMap\n.\ndefault_\n=\n0\n;\nmapAttr\n.\nmemSyncDomainMap\n.\nremote\n=\n0\n;\ncudaStreamSetAttribute\n(\nstreamA\n,\ncudaLaunchAttributeMemSyncDomainMap\n,\n&\nmapAttr\n);\nmapAttr\n.\nmemSyncDomainMap\n.\ndefault_\n=\n1\n;\nmapAttr\n.\nmemSyncDomainMap\n.\nremote\n=\n1\n;\ncudaStreamSetAttribute\n(\nstreamB\n,\ncudaLaunchAttributeMemSyncDomainMap\n,\n&\nmapAttr\n);\nAs with other launch attributes, these are exposed uniformly on CUDA streams, individual launches using\ncudaLaunchKernelEx\n, and kernel nodes in CUDA graphs. A typical use would set the mapping at stream level and the logical domain at launch level (or bracketing a section of stream use) as described above.\nBoth attributes are copied to graph nodes during stream capture. Graphs take both attributes from the node itself, essentially an indirect way of specifying a physical domain. Domain-related attributes set on the stream a graph is launched into are not used in execution of the graph.\n6.2.8.\nAsynchronous Concurrent Execution\nï\nCUDA exposes the following operations as independent tasks that can operate concurrently with one another:\nComputation on the host;\nComputation on the device;\nMemory transfers from the host to the device;\nMemory transfers from the device to the host;\nMemory transfers within the memory of a given device;\nMemory transfers among devices.\nThe level of concurrency achieved between these operations will depend on the feature set and compute capability of the device as described below.\n6.2.8.1.\nConcurrent Execution between Host and Device\nï\nConcurrent host execution is facilitated through asynchronous library functions that return control to the host thread before the device completes the requested task. Using asynchronous calls, many device operations can be queued up together to be executed by the CUDA driver when appropriate device resources are available. This relieves the host thread of much of the responsibility to manage the device, leaving it free for other tasks. The following device operations are asynchronous with respect to the host:\nKernel launches;\nMemory copies within a single deviceâs memory;\nMemory copies from host to device of a memory block of 64 KB or less;\nMemory copies performed by functions that are suffixed with\nAsync\n;\nMemory set function calls.\nProgrammers can globally disable asynchronicity of kernel launches for all CUDA applications running on a system by setting the\nCUDA_LAUNCH_BLOCKING\nenvironment variable to 1. This feature is provided for debugging purposes only and should not be used as a way to make production software run reliably.\nKernel launches are synchronous if hardware counters are collected via a profiler (Nsight Compute) unless concurrent kernel profiling is enabled.\nAsync\nmemory copies might also be synchronous if they involve host memory that is not page-locked.\n6.2.8.2.\nConcurrent Kernel Execution\nï\nSome devices of compute capability 2.x and higher can execute multiple kernels concurrently. Applications may query this capability by checking the\nconcurrentKernels\ndevice property (see\nDevice Enumeration\n), which is equal to 1 for devices that support it.\nThe maximum number of kernel launches that a device can execute concurrently depends on its compute capability and is listed in\nTable 27\n.\nA kernel from one CUDA context cannot execute concurrently with a kernel from another CUDA context. The GPU may time slice to provide forward progress to each context. If a user wants to run kernels from multiple process simultaneously on the SM, one must enable MPS.\nKernels that use many textures or a large amount of local memory are less likely to execute concurrently with other kernels.\n6.2.8.3.\nOverlap of Data Transfer and Kernel Execution\nï\nSome devices can perform an asynchronous memory copy to or from the GPU concurrently with kernel execution. Applications may query this capability by checking the\nasyncEngineCount\ndevice property (see\nDevice Enumeration\n), which is greater than zero for devices that support it. If host memory is involved in the copy, it must be page-locked.\nIt is also possible to perform an intra-device copy simultaneously with kernel execution (on devices that support the\nconcurrentKernels\ndevice property) and/or with copies to or from the device (for devices that support the\nasyncEngineCount\nproperty). Intra-device copies are initiated using the standard memory copy functions with destination and source addresses residing on the same device.\n6.2.8.4.\nConcurrent Data Transfers\nï\nSome devices of compute capability 2.x and higher can overlap copies to and from the device. Applications may query this capability by checking the\nasyncEngineCount\ndevice property (see\nDevice Enumeration\n), which is equal to 2 for devices that support it. In order to be overlapped, any host memory involved in the transfers must be page-locked.\n6.2.8.5.\nStreams\nï\nApplications manage the concurrent operations described above through\nstreams\n. A stream is a sequence of commands (possibly issued by different host threads) that execute in order. Different streams, on the other hand, may execute their commands out of order with respect to one another or concurrently; this behavior is not guaranteed and should therefore not be relied upon for correctness (for example, inter-kernel communication is undefined). The commands issued on a stream may execute when all the dependencies of the command are met. The dependencies could be previously launched commands on same stream or dependencies from other streams. The successful completion of synchronize call guarantees that all the commands launched are completed.\n6.2.8.5.1.\nCreation and Destruction of Streams\nï\nA stream is defined by creating a stream object and specifying it as the stream parameter to a sequence of kernel launches and host\n<->\ndevice memory copies. The following code sample creates two streams and allocates an array\nhostPtr\nof\nfloat\nin page-locked memory.\ncudaStream_t\nstream\n[\n2\n];\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n2\n;\n++\ni\n)\ncudaStreamCreate\n(\n&\nstream\n[\ni\n]);\nfloat\n*\nhostPtr\n;\ncudaMallocHost\n(\n&\nhostPtr\n,\n2\n*\nsize\n);\nEach of these streams is defined by the following code sample as a sequence of one memory copy from host to device, one kernel launch, and one memory copy from device to host:\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n2\n;\n++\ni\n)\n{\ncudaMemcpyAsync\n(\ninputDevPtr\n+\ni\n*\nsize\n,\nhostPtr\n+\ni\n*\nsize\n,\nsize\n,\ncudaMemcpyHostToDevice\n,\nstream\n[\ni\n]);\nMyKernel\n<<<\n100\n,\n512\n,\n0\n,\nstream\n[\ni\n]\n>>>\n(\noutputDevPtr\n+\ni\n*\nsize\n,\ninputDevPtr\n+\ni\n*\nsize\n,\nsize\n);\ncudaMemcpyAsync\n(\nhostPtr\n+\ni\n*\nsize\n,\noutputDevPtr\n+\ni\n*\nsize\n,\nsize\n,\ncudaMemcpyDeviceToHost\n,\nstream\n[\ni\n]);\n}\nEach stream copies its portion of input array\nhostPtr\nto array\ninputDevPtr\nin device memory, processes\ninputDevPtr\non the device by calling\nMyKernel()\n, and copies the result\noutputDevPtr\nback to the same portion of\nhostPtr\n.\nOverlapping Behavior\ndescribes how the streams overlap in this example depending on the capability of the device. Note that\nhostPtr\nmust point to page-locked host memory for any overlap to occur.\nStreams are released by calling\ncudaStreamDestroy()\n.\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n2\n;\n++\ni\n)\ncudaStreamDestroy\n(\nstream\n[\ni\n]);\nIn case the device is still doing work in the stream when\ncudaStreamDestroy()\nis called, the function will return immediately and the resources associated with the stream will be released automatically once the device has completed all work in the stream.\n6.2.8.5.2.\nDefault Stream\nï\nKernel launches and host\n<->\ndevice memory copies that do not specify any stream parameter, or equivalently that set the stream parameter to zero, are issued to the default stream. They are therefore executed in order.\nFor code that is compiled using the\n--default-stream\nper-thread\ncompilation flag (or that defines the\nCUDA_API_PER_THREAD_DEFAULT_STREAM\nmacro before including CUDA headers (\ncuda.h\nand\ncuda_runtime.h\n)), the default stream is a regular stream and each host thread has its own default stream.\nNote\n#define\nCUDA_API_PER_THREAD_DEFAULT_STREAM\n1\ncannot be used to enable this behavior when the code is compiled by\nnvcc\nas\nnvcc\nimplicitly includes\ncuda_runtime.h\nat the top of the translation unit. In this case the\n--default-stream\nper-thread\ncompilation flag needs to be used or the\nCUDA_API_PER_THREAD_DEFAULT_STREAM\nmacro needs to be defined with the\n-DCUDA_API_PER_THREAD_DEFAULT_STREAM=1\ncompiler flag.\nFor code that is compiled using the\n--default-stream\nlegacy\ncompilation flag, the default stream is a special stream called the\nNULL stream\nand each device has a single NULL stream used for all host threads. The NULL stream is special as it causes implicit synchronization as described in\nImplicit Synchronization\n.\nFor code that is compiled without specifying a\n--default-stream\ncompilation flag,\n--default-stream\nlegacy\nis assumed as the default.\n6.2.8.5.3.\nExplicit Synchronization\nï\nThere are various ways to explicitly synchronize streams with each other.\ncudaDeviceSynchronize()\nwaits until all preceding commands in all streams of all host threads have completed.\ncudaStreamSynchronize()\ntakes a stream as a parameter and waits until all preceding commands in the given stream have completed. It can be used to synchronize the host with a specific stream, allowing other streams to continue executing on the device.\ncudaStreamWaitEvent()\ntakes a stream and an event as parameters (see\nEvents\nfor a description of events)and makes all the commands added to the given stream after the call to\ncudaStreamWaitEvent()\ndelay their execution until the given event has completed.\ncudaStreamQuery()\nprovides applications with a way to know if all preceding commands in a stream have completed.\n6.2.8.5.4.\nImplicit Synchronization\nï\nTwo operations from different streams cannot run concurrently if any CUDA operation on the NULL stream is submitted\nin-between them, unless the streams are non-blocking streams (created with the\ncudaStreamNonBlocking\nflag).\nApplications should follow these guidelines to improve\ntheir potential for concurrent kernel execution:\nAll independent operations should be issued before dependent operations,\nSynchronization of any kind should be delayed as long as possible.\n6.2.8.5.5.\nOverlapping Behavior\nï\nThe amount of execution overlap between two streams depends on the order in which the commands are issued to each stream\nand whether or not the device supports overlap of data transfer and kernel execution (see\nOverlap of Data Transfer and Kernel Execution\n),\nconcurrent kernel execution (see\nConcurrent Kernel Execution\n), and/or concurrent data transfers (see\nConcurrent Data Transfers\n).\nFor example, on devices that do not support concurrent data transfers, the two streams of the code sample of\nCreation and Destruction of Streams\ndo not overlap at all because the memory copy from host to device is issued to stream[1] after the memory copy from device to host\nis issued to stream[0], so it can only start once the memory copy from device to host issued to stream[0] has completed. If the\ncode is rewritten the following way (and assuming the device supports overlap of data transfer and kernel execution)\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n2\n;\n++\ni\n)\ncudaMemcpyAsync\n(\ninputDevPtr\n+\ni\n*\nsize\n,\nhostPtr\n+\ni\n*\nsize\n,\nsize\n,\ncudaMemcpyHostToDevice\n,\nstream\n[\ni\n]);\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n2\n;\n++\ni\n)\nMyKernel\n<<<\n100\n,\n512\n,\n0\n,\nstream\n[\ni\n]\n>>>\n(\noutputDevPtr\n+\ni\n*\nsize\n,\ninputDevPtr\n+\ni\n*\nsize\n,\nsize\n);\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n2\n;\n++\ni\n)\ncudaMemcpyAsync\n(\nhostPtr\n+\ni\n*\nsize\n,\noutputDevPtr\n+\ni\n*\nsize\n,\nsize\n,\ncudaMemcpyDeviceToHost\n,\nstream\n[\ni\n]);\nthen the memory copy from host to device issued to stream[1] overlaps with the kernel launch issued to stream[0].\nOn devices that do support concurrent data transfers, the two streams of the code sample of\nCreation and Destruction of Streams\ndo overlap: The memory copy from host to device issued to stream[1] overlaps with the memory copy from device to host issued to\nstream[0] and even with the kernel launch issued to stream[0] (assuming the device supports overlap of data transfer and kernel execution).\n6.2.8.5.6.\nHost Functions (Callbacks)\nï\nThe runtime provides a way to insert a CPU function call at any point into a stream via\ncudaLaunchHostFunc()\n. The provided function is executed on the host once all commands issued to the stream before the callback have completed.\nThe following code sample adds the host function\nMyCallback\nto each of two streams after issuing a host-to-device memory copy, a kernel launch and a device-to-host memory copy into each stream. The function will begin execution on the host after each of the device-to-host memory copies completes.\nvoid\nCUDART_CB\nMyCallback\n(\nvoid\n*\ndata\n){\nprintf\n(\n\"Inside callback %d\n\\n\n\"\n,\n(\nsize_t\n)\ndata\n);\n}\n...\nfor\n(\nsize_t\ni\n=\n0\n;\ni\n<\n2\n;\n++\ni\n)\n{\ncudaMemcpyAsync\n(\ndevPtrIn\n[\ni\n],\nhostPtr\n[\ni\n],\nsize\n,\ncudaMemcpyHostToDevice\n,\nstream\n[\ni\n]);\nMyKernel\n<<<\n100\n,\n512\n,\n0\n,\nstream\n[\ni\n]\n>>>\n(\ndevPtrOut\n[\ni\n],\ndevPtrIn\n[\ni\n],\nsize\n);\ncudaMemcpyAsync\n(\nhostPtr\n[\ni\n],\ndevPtrOut\n[\ni\n],\nsize\n,\ncudaMemcpyDeviceToHost\n,\nstream\n[\ni\n]);\ncudaLaunchHostFunc\n(\nstream\n[\ni\n],\nMyCallback\n,\n(\nvoid\n*\n)\ni\n);\n}\nThe commands that are issued in a stream after a host function do not start executing before the function has completed.\nA host function enqueued into a stream must not make CUDA API calls (directly or indirectly), as it might end up waiting on itself if it makes such a call leading to a deadlock.\n6.2.8.5.7.\nStream Priorities\nï\nThe relative priorities of streams can be specified at creation using\ncudaStreamCreateWithPriority()\n. The range of allowable priorities, ordered as [ greatest priority, least priority ] can be obtained using the\ncudaDeviceGetStreamPriorityRange()\nfunction. At runtime, the GPU scheduler utilizes stream priorities to determine task execution order, but these priorities serve as hints rather than guarantees. When selecting work to launch, pending tasks in higher-priority streams take precedence over those in lower-priority streams. Higher-priority tasks do not preempt already running lower-priority tasks. The GPU does not reassess work queues during task execution, and increasing a streamâs priority will not interrupt ongoing work. Stream priorities influence task execution without enforcing strict ordering, so users can leverage stream priorities to influence task execution without relying on strict ordering guarantees.\nThe following code sample obtains the allowable range of priorities for the current device, and creates streams with the highest and lowest available priorities.\n// get the range of stream priorities for this device\nint\nleastPriority\n,\ngreatestPriority\n;\ncudaDeviceGetStreamPriorityRange\n(\n&\nleastPriority\n,\n&\ngreatestPriority\n);\n// create streams with highest and lowest available priorities\ncudaStream_t\nst_high\n,\nst_low\n;\ncudaStreamCreateWithPriority\n(\n&\nst_high\n,\ncudaStreamNonBlocking\n,\ngreatestPriority\n));\ncudaStreamCreateWithPriority\n(\n&\nst_low\n,\ncudaStreamNonBlocking\n,\nleastPriority\n);\n6.2.8.6.\nProgrammatic Dependent Launch and Synchronization\nï\nThe\nProgrammatic Dependent Launch\nmechanism allows for a dependent\nsecondary\nkernel\nto launch before the\nprimary\nkernel it depends on in the same CUDA stream has finished executing.\nAvailable starting with devices of compute capability 9.0, this technique can provide performance\nbenefits when the\nsecondary\nkernel can complete significant work that does not depend on the results of the\nprimary\nkernel.\n6.2.8.6.1.\nBackground\nï\nA CUDA application utilizes the GPU by launching and executing multiple kernels on it.\nA typical GPU activity timeline is shown in\nFigure 10\n.\nFigure 10\nGPU activity timeline\nï\nHere,\nsecondary_kernel\nis launched after\nprimary_kernel\nfinishes its execution.\nSerialized execution is usually necessary because\nsecondary_kernel\ndepends on result data\nproduced by\nprimary_kernel\n. If\nsecondary_kernel\nhas no dependency on\nprimary_kernel\n,\nboth of them can be launched concurrently by using\nStreams\n.\nEven if\nsecondary_kernel\nis dependent on\nprimary_kernel\n, there is some potential for\nconcurrent execution. For example, almost all the kernels have\nsome sort of\npreamble\nsection during which tasks such as zeroing buffers or loading\nconstant values are performed.\nFigure 11\nPreamble section of\nsecondary_kernel\nï\nFigure 11\ndemonstrates the portion of\nsecondary_kernel\nthat could\nbe executed concurrently without impacting the application.\nNote that concurrent launch also allows us to hide the launch latency of\nsecondary_kernel\nbehind\nthe execution of\nprimary_kernel\n.\nFigure 12\nConcurrent execution of\nprimary_kernel\nand\nsecondary_kernel\nï\nThe concurrent launch and execution of\nsecondary_kernel\nshown in\nFigure 12\nis\nachievable using\nProgrammatic Dependent Launch\n.\nProgrammatic Dependent Launch\nintroduces changes to the CUDA kernel launch APIs as explained in following section.\nThese APIs require at least compute capability 9.0 to provide overlapping execution.\n6.2.8.6.2.\nAPI Description\nï\nIn Programmatic Dependent Launch, a primary and a secondary kernel are launched in the same CUDA stream.\nThe primary kernel should execute\ncudaTriggerProgrammaticLaunchCompletion\nwith all thread blocks when\nitâs ready for the secondary kernel to launch. The secondary kernel must be launched using the extensible launch API as shown.\n__global__\nvoid\nprimary_kernel\n()\n{\n// Initial work that should finish before starting secondary kernel\n// Trigger the secondary kernel\ncudaTriggerProgrammaticLaunchCompletion\n();\n// Work that can coincide with the secondary kernel\n}\n__global__\nvoid\nsecondary_kernel\n()\n{\n// Independent work\n// Will block until all primary kernels the secondary kernel is dependent on have completed and flushed results to global memory\ncudaGridDependencySynchronize\n();\n// Dependent work\n}\ncudaLaunchAttribute\nattribute\n[\n1\n];\nattribute\n[\n0\n].\nid\n=\ncudaLaunchAttributeProgrammaticStreamSerialization\n;\nattribute\n[\n0\n].\nval\n.\nprogrammaticStreamSerializationAllowed\n=\n1\n;\nconfigSecondary\n.\nattrs\n=\nattribute\n;\nconfigSecondary\n.\nnumAttrs\n=\n1\n;\nprimary_kernel\n<<<\ngrid_dim\n,\nblock_dim\n,\n0\n,\nstream\n>>>\n();\ncudaLaunchKernelEx\n(\n&\nconfigSecondary\n,\nsecondary_kernel\n);\nWhen the secondary kernel is launched using the\ncudaLaunchAttributeProgrammaticStreamSerialization\nattribute,\nthe CUDA driver is safe to launch the secondary kernel early and not wait on the\ncompletion and memory flush of the primary before launching the secondary.\nThe CUDA driver can launch the secondary kernel when all primary thread blocks have launched and executed\ncudaTriggerProgrammaticLaunchCompletion\n.\nIf the primary kernel doesnât execute the trigger, it implicitly occurs after\nall thread blocks in the primary kernel exit.\nIn either case, the secondary thread blocks might launch\nbefore data written by the primary kernel is visible. As such, when the secondary kernel is configured with\nProgrammatic Dependent Launch\n,\nit must always use\ncudaGridDependencySynchronize\nor other means to verify that the result data from the primary is available.\nPlease note that these methods provide the opportunity for the primary and secondary kernels to execute concurrently, however\nthis behavior is opportunistic and not guaranteed to lead to concurrent kernel execution.\nReliance on concurrent execution in this manner is unsafe and can lead to deadlock.\n6.2.8.6.3.\nUse in CUDA Graphs\nï\nProgrammatic Dependent Launch can be used in\nCUDA Graphs\nvia\nstream capture\nor\ndirectly via\nedge data\n. To program this feature in a CUDA Graph with edge data, use a\ncudaGraphDependencyType\nvalue of\ncudaGraphDependencyTypeProgrammatic\non an edge connecting two kernel nodes. This edge type makes the upstream kernel\nvisible to a\ncudaGridDependencySynchronize()\nin the downstream kernel. This type must be used with an outgoing port of\neither\ncudaGraphKernelNodePortLaunchCompletion\nor\ncudaGraphKernelNodePortProgrammatic\n.\nThe resulting graph equivalents for stream capture are as follows:\nStream code (abbreviated)\nResulting graph edge\ncudaLaunchAttribute\nattribute\n;\nattribute\n.\nid\n=\ncudaLaunchAttributeProgrammaticStreamSerialization\n;\nattribute\n.\nval\n.\nprogrammaticStreamSerializationAllowed\n=\n1\n;\ncudaGraphEdgeData\nedgeData\n;\nedgeData\n.\ntype\n=\ncudaGraphDependencyTypeProgrammatic\n;\nedgeData\n.\nfrom_port\n=\ncudaGraphKernelNodePortProgrammatic\n;\ncudaLaunchAttribute\nattribute\n;\nattribute\n.\nid\n=\ncudaLaunchAttributeProgrammaticEvent\n;\nattribute\n.\nval\n.\nprogrammaticEvent\n.\ntriggerAtBlockStart\n=\n0\n;\ncudaGraphEdgeData\nedgeData\n;\nedgeData\n.\ntype\n=\ncudaGraphDependencyTypeProgrammatic\n;\nedgeData\n.\nfrom_port\n=\ncudaGraphKernelNodePortProgrammatic\n;\ncudaLaunchAttribute\nattribute\n;\nattribute\n.\nid\n=\ncudaLaunchAttributeProgrammaticEvent\n;\nattribute\n.\nval\n.\nprogrammaticEvent\n.\ntriggerAtBlockStart\n=\n1\n;\ncudaGraphEdgeData\nedgeData\n;\nedgeData\n.\ntype\n=\ncudaGraphDependencyTypeProgrammatic\n;\nedgeData\n.\nfrom_port\n=\ncudaGraphKernelNodePortLaunchCompletion\n;\n6.2.8.7.\nCUDA Graphs\nï\nCUDA Graphs present a new model for work submission in CUDA. A graph is a series of operations, such as kernel launches, connected by dependencies, which is defined separately from its execution. This allows a graph to be defined once and then launched repeatedly. Separating out the definition of a graph from its execution enables a number of optimizations: first, CPU launch costs are reduced compared to streams, because much of the setup is done in advance; second, presenting the whole workflow to CUDA enables optimizations which might not be possible with the piecewise work submission mechanism of streams.\nTo see the optimizations possible with graphs, consider what happens in a stream: when you place a kernel into a stream, the host driver performs a sequence of operations in preparation for the execution of the kernel on the GPU. These operations, necessary for setting up and launching the kernel, are an overhead cost which must be paid for each kernel that is issued. For a GPU kernel with a short execution time, this overhead cost can be a significant fraction of the overall end-to-end execution time.\nWork submission using graphs is separated into three distinct stages: definition, instantiation, and execution.\nDuring the definition phase, a program creates a description of the operations in the graph along with the dependencies between them.\nInstantiation takes a snapshot of the graph template, validates it, and performs much of the setup and initialization of work with the aim of minimizing what needs to be done at launch. The resulting instance is known as an\nexecutable graph.\nAn executable graph may be launched into a stream, similar to any other CUDA work. It may be launched any number of times without repeating the instantiation.\n6.2.8.7.1.\nGraph Structure\nï\nAn operation forms a node in a graph. The dependencies between the operations are the edges. These dependencies constrain the execution sequence of the operations.\nAn operation may be scheduled at any time once the nodes on which it depends are complete. Scheduling is left up to the CUDA system.\n6.2.8.7.1.1.\nNode Types\nï\nA graph node can be one of:\nkernel\nCPU function call\nmemory copy\nmemset\nempty node\nwaiting on an\nevent\nrecording an\nevent\nsignalling an\nexternal semaphore\nwaiting on an\nexternal semaphore\nconditional node\nGraph Memory Nodes\nchild graph: To execute a separate nested graph, as shown in the following figure.\nFigure 13\nChild Graph Example\nï\n6.2.8.7.1.2.\nEdge Data\nï\nCUDA 12.3 introduced edge data on CUDA Graphs. Edge data modifies a dependency specified by an edge and consists of three parts:\nan outgoing port, an incoming port, and a type. An outgoing port specifies when an associated edge is triggered. An incoming port\nspecifies what portion of a node is dependent on an associated edge. A type modifies the relation between the endpoints.\nPort values are specific to node type and direction, and edge types may be restricted to specific node types. In all cases,\nzero-initialized edge data represents default behavior. Outgoing port 0 waits on an entire task, incoming port 0 blocks an\nentire task, and edge type 0 is associated with a full dependency with memory synchronizing behavior.\nEdge data is optionally specified in various graph APIs via a parallel array to the associated nodes. If it is omitted as an\ninput parameter, zero-initialized data is used. If it is omitted as an output (query) parameter, the API accepts this if the\nedge data being ignored is all zero-initialized, and returns\ncudaErrorLossyQuery\nif the call would discard information.\nEdge data is also available in some stream capture APIs:\ncudaStreamBeginCaptureToGraph()\n,\ncudaStreamGetCaptureInfo()\n,\nand\ncudaStreamUpdateCaptureDependencies()\n. In these cases, there is not yet a downstream node. The data is associated with\na dangling edge (half edge) which will either be connected to a future captured node or discarded at termination of stream capture.\nNote that some edge types do not wait on full completion of the upstream node. These edges are ignored when considering if a\nstream capture has been fully rejoined to the origin stream, and cannot be discarded at the end of capture. See\nCreating a Graph Using Stream Capture\n.\nCurrently, no node types define additional incoming ports, and only kernel nodes define additional outgoing ports. There is\none non-default dependency type,\ncudaGraphDependencyTypeProgrammatic\n, which enables\nProgrammatic Dependent Launch\nbetween two kernel nodes.\n6.2.8.7.2.\nCreating a Graph Using Graph APIs\nï\nGraphs can be created via two mechanisms: explicit API and stream capture. The following is an example of creating and executing the below graph.\nFigure 14\nCreating a Graph Using Graph APIs Example\nï\n// Create the graph - it starts out empty\ncudaGraphCreate\n(\n&\ngraph\n,\n0\n);\n// For the purpose of this example, we'll create\n// the nodes separately from the dependencies to\n// demonstrate that it can be done in two stages.\n// Note that dependencies can also be specified\n// at node creation.\ncudaGraphAddKernelNode\n(\n&\na\n,\ngraph\n,\nNULL\n,\n0\n,\n&\nnodeParams\n);\ncudaGraphAddKernelNode\n(\n&\nb\n,\ngraph\n,\nNULL\n,\n0\n,\n&\nnodeParams\n);\ncudaGraphAddKernelNode\n(\n&\nc\n,\ngraph\n,\nNULL\n,\n0\n,\n&\nnodeParams\n);\ncudaGraphAddKernelNode\n(\n&\nd\n,\ngraph\n,\nNULL\n,\n0\n,\n&\nnodeParams\n);\n// Now set up dependencies on each node\ncudaGraphAddDependencies\n(\ngraph\n,\n&\na\n,\n&\nb\n,\nNULL\n,\n1\n);\n// A->B\ncudaGraphAddDependencies\n(\ngraph\n,\n&\na\n,\n&\nc\n,\nNULL\n,\n1\n);\n// A->C\ncudaGraphAddDependencies\n(\ngraph\n,\n&\nb\n,\n&\nd\n,\nNULL\n,\n1\n);\n// B->D\ncudaGraphAddDependencies\n(\ngraph\n,\n&\nc\n,\n&\nd\n,\nNULL\n,\n1\n);\n// C->D\n6.2.8.7.3.\nCreating a Graph Using Stream Capture\nï\nStream capture provides a mechanism to create a graph from existing stream-based APIs. A section of code which launches work into streams, including existing code, can be bracketed with calls to\ncudaStreamBeginCapture()\nand\ncudaStreamEndCapture()\n. See below.\ncudaGraph_t\ngraph\n;\ncudaStreamBeginCapture\n(\nstream\n);\nkernel_A\n<<<\n...,\nstream\n>>>\n(...);\nkernel_B\n<<<\n...,\nstream\n>>>\n(...);\nlibraryCall\n(\nstream\n);\nkernel_C\n<<<\n...,\nstream\n>>>\n(...);\ncudaStreamEndCapture\n(\nstream\n,\n&\ngraph\n);\nA call to\ncudaStreamBeginCapture()\nplaces a stream in capture mode. When a stream is being captured, work launched into the stream is not enqueued for execution. It is instead appended to an internal graph that is progressively being built up. This graph is then returned by calling\ncudaStreamEndCapture()\n, which also ends capture mode for the stream. A graph which is actively being constructed by stream capture is referred to as a\ncapture graph.\nStream capture can be used on any CUDA stream except\ncudaStreamLegacy\n(the âNULL streamâ). Note that it\ncan\nbe used on\ncudaStreamPerThread\n. If a program is using the legacy stream, it may be possible to redefine stream 0 to be the per-thread stream with no functional change. See\nDefault Stream\n.\nWhether a stream is being captured can be queried with\ncudaStreamIsCapturing()\n.\nWork can be captured to an existing graph using\ncudaStreamBeginCaptureToGraph()\n.  Instead of capturing to an internal graph, work is captured to a graph provided by the user.\n6.2.8.7.3.1.\nCross-stream Dependencies and Events\nï\nStream capture can handle cross-stream dependencies expressed with\ncudaEventRecord()\nand\ncudaStreamWaitEvent()\n, provided the event being waited upon was recorded into the same capture graph.\nWhen an event is recorded in a stream that is in capture mode, it results in a\ncaptured event.\nA captured event represents a set of nodes in a capture graph.\nWhen a captured event is waited on by a stream, it places the stream in capture mode if it is not already, and the next item in the stream will have additional dependencies on the nodes in the captured event. The two streams are then being captured to the same capture graph.\nWhen cross-stream dependencies are present in stream capture,\ncudaStreamEndCapture()\nmust still be called in the same stream where\ncudaStreamBeginCapture()\nwas called; this is the\norigin stream\n. Any other streams which are being captured to the same capture graph, due to event-based dependencies, must also be joined back to the origin stream. This is illustrated below. All streams being captured to the same capture graph are taken out of capture mode upon\ncudaStreamEndCapture()\n. Failure to rejoin to the origin stream will result in failure of the overall capture operation.\n// stream1 is the origin stream\ncudaStreamBeginCapture\n(\nstream1\n);\nkernel_A\n<<<\n...,\nstream1\n>>>\n(...);\n// Fork into stream2\ncudaEventRecord\n(\nevent1\n,\nstream1\n);\ncudaStreamWaitEvent\n(\nstream2\n,\nevent1\n);\nkernel_B\n<<<\n...,\nstream1\n>>>\n(...);\nkernel_C\n<<<\n...,\nstream2\n>>>\n(...);\n// Join stream2 back to origin stream (stream1)\ncudaEventRecord\n(\nevent2\n,\nstream2\n);\ncudaStreamWaitEvent\n(\nstream1\n,\nevent2\n);\nkernel_D\n<<<\n...,\nstream1\n>>>\n(...);\n// End capture in the origin stream\ncudaStreamEndCapture\n(\nstream1\n,\n&\ngraph\n);\n// stream1 and stream2 no longer in capture mode\nGraph returned by the above code is shown in\nFigure 14\n.\nNote\nWhen a stream is taken out of capture mode, the next non-captured item in the stream (if any) will still have a dependency on the most recent prior non-captured item, despite intermediate items having been removed.\n6.2.8.7.3.2.\nProhibited and Unhandled Operations\nï\nIt is invalid to synchronize or query the execution status of a stream which is being captured or a captured event, because they do not represent items scheduled for execution. It is also invalid to query the execution status of or synchronize a broader handle which encompasses an active stream capture, such as a device or context handle when any associated stream is in capture mode.\nWhen any stream in the same context is being captured, and it was not created with\ncudaStreamNonBlocking\n, any attempted use of the legacy stream is invalid. This is because the legacy stream handle at all times encompasses these other streams; enqueueing to the legacy stream would create a dependency on the streams being captured, and querying it or synchronizing it would query or synchronize the streams being captured.\nIt is therefore also invalid to call synchronous APIs in this case. Synchronous APIs, such as\ncudaMemcpy()\n, enqueue work to the legacy stream and synchronize it before returning.\nNote\nAs a general rule, when a dependency relation would connect something that is captured with something that was not captured and instead enqueued for execution, CUDA prefers to return an error rather than ignore the dependency. An exception is made for placing a stream into or out of capture mode; this severs a dependency relation between items added to the stream immediately before and after the mode transition.\nIt is invalid to merge two separate capture graphs by waiting on a captured event from a stream which is being captured and is associated with a different capture graph than the event. It is invalid to wait on a non-captured event from a stream which is being captured without specifying the cudaEventWaitExternal flag.\nA small number of APIs that enqueue asynchronous operations into streams are not currently supported in graphs and will return an error if called with a stream which is being captured, such as\ncudaStreamAttachMemAsync()\n.\n6.2.8.7.3.3.\nInvalidation\nï\nWhen an invalid operation is attempted during stream capture, any associated capture graphs are\ninvalidated\n. When a capture graph is invalidated, further use of any streams which are being captured or captured events associated with the graph is invalid and will return an error, until stream capture is ended with\ncudaStreamEndCapture()\n. This call will take the associated streams out of capture mode, but will also return an error value and a NULL graph.\n6.2.8.7.4.\nCUDA User Objects\nï\nCUDA User Objects can be used to help manage the lifetime of resources used by asynchronous work in CUDA. In particular, this feature is useful for\nCUDA Graphs\nand\nstream capture\n.\nVarious resource management schemes are not compatible with CUDA graphs. Consider for example an event-based pool or a synchronous-create, asynchronous-destroy scheme.\n// Library API with pool allocation\nvoid\nlibraryWork\n(\ncudaStream_t\nstream\n)\n{\nauto\n&\nresource\n=\npool\n.\nclaimTemporaryResource\n();\nresource\n.\nwaitOnReadyEventInStream\n(\nstream\n);\nlaunchWork\n(\nstream\n,\nresource\n);\nresource\n.\nrecordReadyEvent\n(\nstream\n);\n}\n// Library API with asynchronous resource deletion\nvoid\nlibraryWork\n(\ncudaStream_t\nstream\n)\n{\nResource\n*\nresource\n=\nnew\nResource\n(...);\nlaunchWork\n(\nstream\n,\nresource\n);\ncudaLaunchHostFunc\n(\nstream\n,\n[](\nvoid\n*\nresource\n)\n{\ndelete\nstatic_cast\n<\nResource\n*>\n(\nresource\n);\n},\nresource\n,\n0\n);\n// Error handling considerations not shown\n}\nThese schemes are difficult with CUDA graphs because of the non-fixed pointer or handle for the resource which requires indirection or graph update, and the synchronous CPU code needed each time the work is submitted. They also do not work with stream capture if these considerations are hidden from the caller of the library, and because of use of disallowed APIs during capture. Various solutions exist such as exposing the resource to the caller. CUDA user objects present another approach.\nA CUDA user object associates a user-specified destructor callback with an internal refcount, similar to C++\nshared_ptr\n. References may be owned by user code on the CPU and by CUDA graphs. Note that for user-owned references, unlike C++ smart pointers, there is no object representing the reference; users must track user-owned references manually. A typical use case would be to immediately move the sole user-owned reference to a CUDA graph after the user object is created.\nWhen a reference is associated to a CUDA graph, CUDA will manage the graph operations automatically. A cloned\ncudaGraph_t\nretains a copy of every reference owned by the source\ncudaGraph_t\n, with the same multiplicity. An instantiated\ncudaGraphExec_t\nretains a copy of every reference in the source\ncudaGraph_t\n. When a\ncudaGraphExec_t\nis destroyed without being synchronized, the references are retained until the execution is completed.\nHere is an example use.\ncudaGraph_t\ngraph\n;\n// Preexisting graph\nObject\n*\nobject\n=\nnew\nObject\n;\n// C++ object with possibly nontrivial destructor\ncudaUserObject_t\ncuObject\n;\ncudaUserObjectCreate\n(\n&\ncuObject\n,\nobject\n,\n// Here we use a CUDA-provided template wrapper for this API,\n// which supplies a callback to delete the C++ object pointer\n1\n,\n// Initial refcount\ncudaUserObjectNoDestructorSync\n// Acknowledge that the callback cannot be\n// waited on via CUDA\n);\ncudaGraphRetainUserObject\n(\ngraph\n,\ncuObject\n,\n1\n,\n// Number of references\ncudaGraphUserObjectMove\n// Transfer a reference owned by the caller (do\n// not modify the total reference count)\n);\n// No more references owned by this thread; no need to call release API\ncudaGraphExec_t\ngraphExec\n;\ncudaGraphInstantiate\n(\n&\ngraphExec\n,\ngraph\n,\nnullptr\n,\nnullptr\n,\n0\n);\n// Will retain a\n// new reference\ncudaGraphDestroy\n(\ngraph\n);\n// graphExec still owns a reference\ncudaGraphLaunch\n(\ngraphExec\n,\n0\n);\n// Async launch has access to the user objects\ncudaGraphExecDestroy\n(\ngraphExec\n);\n// Launch is not synchronized; the release\n// will be deferred if needed\ncudaStreamSynchronize\n(\n0\n);\n// After the launch is synchronized, the remaining\n// reference is released and the destructor will\n// execute. Note this happens asynchronously.\n// If the destructor callback had signaled a synchronization object, it would\n// be safe to wait on it at this point.\nReferences owned by graphs in child graph nodes are associated to the child graphs, not the parents. If a child graph is updated or deleted, the references change accordingly. If an executable graph or child graph is updated with\ncudaGraphExecUpdate\nor\ncudaGraphExecChildGraphNodeSetParams\n, the references in the new source graph are cloned and replace the references in the target graph. In either case, if previous launches are not synchronized, any references which would be released are held until the launches have finished executing.\nThere is not currently a mechanism to wait on user object destructors via a CUDA API. Users may signal a synchronization object manually from the destructor code. In addition, it is not legal to call CUDA APIs from the destructor, similar to the restriction on\ncudaLaunchHostFunc\n. This is to avoid blocking a CUDA internal shared thread and preventing forward progress. It is legal to signal another thread to perform an API call, if the dependency is one way and the thread doing the call cannot block forward progress of CUDA work.\nUser objects are created with\ncudaUserObjectCreate\n, which is a good starting point to browse related APIs.\n6.2.8.7.5.\nUpdating Instantiated Graphs\nï\nWork submission using graphs is separated into three distinct stages: definition, instantiation, and execution. In situations where the workflow is not changing, the overhead of definition and instantiation can be amortized over many executions, and graphs provide a clear advantage over streams.\nA graph is a snapshot of a workflow, including kernels, parameters, and dependencies, in order to replay it as rapidly and efficiently as possible. In situations where the workflow changes the graph becomes out of date and must be modified. Major changes to graph structure such as topology or types of nodes will require re-instantiation of the source graph because various topology-related optimization techniques must be re-applied.\nThe cost of repeated instantiation can reduce the overall performance benefit from graph execution, but it is common for only node parameters, such as kernel parameters and\ncudaMemcpy\naddresses, to change while graph topology remains the same. For this case, CUDA provides a lightweight mechanism known as âGraph Update,â which allows certain node parameters to be modified in-place without having to rebuild the entire graph. This is much more efficient than re-instantiation.\nUpdates will take effect the next time the graph is launched, so they will not impact previous graph launches, even if they are running at the time of the update. A graph may be updated and relaunched repeatedly, so multiple updates/launches can be queued on a stream.\nCUDA provides two mechanisms for updating instantiated graph parameters, whole graph update and individual node update. Whole graph update allows the user to supply a topologically identical\ncudaGraph_t\nobject whose nodes contain updated parameters. Individual node update allows the user to explicitly update the parameters of individual nodes. Using an updated\ncudaGraph_t\nis more convenient when a large number of nodes are being updated, or when the graph topology is unknown to the caller (i.e., The graph resulted from stream capture of a library call). Using individual node update is preferred when the number of changes is small and the user has the handles to the nodes requiring updates. Individual node update skips the topology checks and comparisons for unchanged nodes, so it can be more efficient in many cases.\nCUDA also provides a mechanism for enabling and disabling individual nodes without affecting their current parameters.\nThe following sections explain each approach in more detail.\n6.2.8.7.5.1.\nGraph Update Limitations\nï\nKernel nodes:\nThe owning context of the function cannot change.\nA node whose function originally did not use CUDA dynamic parallelism cannot be updated to a function which uses CUDA dynamic parallelism.\ncudaMemset\nand\ncudaMemcpy\nnodes:\nThe CUDA device(s) to which the operand(s) was allocated/mapped cannot change.\nThe source/destination memory must be allocated from the same context as the original source/destination memory.\nOnly 1D\ncudaMemset\n/\ncudaMemcpy\nnodes can be changed.\nAdditional memcpy node restrictions:\nChanging either the source or destination memory type (i.e.,\ncudaPitchedPtr\n,\ncudaArray_t\n, etc.), or the type of transfer (i.e.,\ncudaMemcpyKind\n) is not supported.\nExternal semaphore wait nodes and record nodes:\nChanging the number of semaphores is not supported.\nConditional nodes:\nThe order of handle creation and assignment must match between the graphs.\nChanging node parameters is not supported (i.e. number of graphs in the conditional, node context, etc).\nChanging parameters of nodes within the conditional body graph is subject to the rules above.\nMemory nodes:\nIt is not possible to update a\ncudaGraphExec_t\nwith a\ncudaGraph_t\nif the\ncudaGraph_t\nis currently instantiated as a different\ncudaGraphExec_t\n.\nThere are no restrictions on updates to host nodes, event record nodes, or event wait nodes.\n6.2.8.7.5.2.\nWhole Graph Update\nï\ncudaGraphExecUpdate()\nallows an instantiated graph (the âoriginal graphâ) to be updated with the parameters from a topologically identical graph (the âupdatingâ graph). The topology of the updating graph must be identical to the original graph used to instantiate the\ncudaGraphExec_t\n. In addition, the order in which the dependencies are specified must match. Finally, CUDA needs to consistently order the sink nodes (nodes with no dependencies). CUDA relies on the order of specific api calls to achieve consistent sink node ordering.\nMore explicitly, following the following rules will cause\ncudaGraphExecUpdate()\nto pair the nodes in the original graph and the updating graph deterministically:\nFor any capturing stream, the API calls operating on that stream must be made in the same order, including event wait and other api calls not directly corresponding to node creation.\nThe API calls which directly manipulate a given graph nodeâs incoming edges (including captured stream APIs, node add APIs, and edge addition / removal APIs) must be made in the same order. Moreover, when dependencies are specified in arrays to these APIs, the order in which the dependencies are specified inside those arrays must match.\nSink nodes must be consistently ordered. Sink nodes are nodes without dependent nodes / outgoing edges in the final graph at the time of the\ncudaGraphExecUpdate()\ninvocation. The following operations affect sink node ordering (if present) and must (as a combined set) be made in the same order:\nNode add APIs resulting in a sink node.\nEdge removal resulting in a node becoming a sink node.\ncudaStreamUpdateCaptureDependencies()\n, if it removes a sink node from a capturing streamâs dependency set.\ncudaStreamEndCapture()\n.\nThe following example shows how the API could be used to update an instantiated graph:\ncudaGraphExec_t\ngraphExec\n=\nNULL\n;\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n10\n;\ni\n++\n)\n{\ncudaGraph_t\ngraph\n;\ncudaGraphExecUpdateResult\nupdateResult\n;\ncudaGraphNode_t\nerrorNode\n;\n// In this example we use stream capture to create the graph.\n// You can also use the Graph API to produce a graph.\ncudaStreamBeginCapture\n(\nstream\n,\ncudaStreamCaptureModeGlobal\n);\n// Call a user-defined, stream based workload, for example\ndo_cuda_work\n(\nstream\n);\ncudaStreamEndCapture\n(\nstream\n,\n&\ngraph\n);\n// If we've already instantiated the graph, try to update it directly\n// and avoid the instantiation overhead\nif\n(\ngraphExec\n!=\nNULL\n)\n{\n// If the graph fails to update, errorNode will be set to the\n// node causing the failure and updateResult will be set to a\n// reason code.\ncudaGraphExecUpdate\n(\ngraphExec\n,\ngraph\n,\n&\nerrorNode\n,\n&\nupdateResult\n);\n}\n// Instantiate during the first iteration or whenever the update\n// fails for any reason\nif\n(\ngraphExec\n==\nNULL\n||\nupdateResult\n!=\ncudaGraphExecUpdateSuccess\n)\n{\n// If a previous update failed, destroy the cudaGraphExec_t\n// before re-instantiating it\nif\n(\ngraphExec\n!=\nNULL\n)\n{\ncudaGraphExecDestroy\n(\ngraphExec\n);\n}\n// Instantiate graphExec from graph. The error node and\n// error message parameters are unused here.\ncudaGraphInstantiate\n(\n&\ngraphExec\n,\ngraph\n,\nNULL\n,\nNULL\n,\n0\n);\n}\ncudaGraphDestroy\n(\ngraph\n);\ncudaGraphLaunch\n(\ngraphExec\n,\nstream\n);\ncudaStreamSynchronize\n(\nstream\n);\n}\nA typical workflow is to create the initial\ncudaGraph_t\nusing either the stream capture or graph API. The\ncudaGraph_t\nis then instantiated and launched as normal. After the initial launch, a new\ncudaGraph_t\nis created using the same method as the initial graph and\ncudaGraphExecUpdate()\nis called. If the graph update is successful, indicated by the\nupdateResult\nparameter in the above example, the updated\ncudaGraphExec_t\nis launched. If the update fails for any reason, the\ncudaGraphExecDestroy()\nand\ncudaGraphInstantiate()\nare called to destroy the original\ncudaGraphExec_t\nand instantiate a new one.\nIt is also possible to update the\ncudaGraph_t\nnodes directly (i.e., Using\ncudaGraphKernelNodeSetParams()\n) and subsequently update the\ncudaGraphExec_t\n, however it is more efficient to use the explicit node update APIs covered in the next section.\nConditional handle flags and default values are updated as part of the graph update.\nPlease see the\nGraph API\nfor more information on usage and current limitations.\n6.2.8.7.5.3.\nIndividual Node Update\nï\nInstantiated graph node parameters can be updated directly. This eliminates the overhead of instantiation as well as the overhead of creating a new\ncudaGraph_t\n. If the number of nodes requiring update is small relative to the total number of nodes in the graph, it is better to update the nodes individually. The following methods are available for updating\ncudaGraphExec_t\nnodes:\ncudaGraphExecKernelNodeSetParams()\ncudaGraphExecMemcpyNodeSetParams()\ncudaGraphExecMemsetNodeSetParams()\ncudaGraphExecHostNodeSetParams()\ncudaGraphExecChildGraphNodeSetParams()\ncudaGraphExecEventRecordNodeSetEvent()\ncudaGraphExecEventWaitNodeSetEvent()\ncudaGraphExecExternalSemaphoresSignalNodeSetParams()\ncudaGraphExecExternalSemaphoresWaitNodeSetParams()\nPlease see the\nGraph API\nfor more information on usage and current limitations.\n6.2.8.7.5.4.\nIndividual Node Enable\nï\nKernel, memset and memcpy nodes in an instantiated graph can be enabled or disabled using the\ncudaGraphNodeSetEnabled()\nAPI. This allows the creation of a graph which contains a superset of the desired functionality which can be customized for each launch. The enable state of a node can be queried using the\ncudaGraphNodeGetEnabled()\nAPI.\nA disabled node is functionally equivalent to empty node until it is reenabled. Node parameters are not affected by enabling/disabling a node. Enable state is unaffected by individual node update or whole graph update with\ncudaGraphExecUpdate()\n. Parameter updates while the node is disabled will take effect when the node is reenabled.\nThe following methods are available for enabling/disabling\ncudaGraphExec_t\nnodes, as well as querying their status:\ncudaGraphNodeSetEnabled()\ncudaGraphNodeGetEnabled()\nRefer to the\nGraph API\nfor more information on usage and current limitations.\n6.2.8.7.6.\nUsing Graph APIs\nï\ncudaGraph_t\nobjects are not thread-safe. It is the responsibility of the user to ensure that multiple threads do not concurrently access the same\ncudaGraph_t\n.\nA\ncudaGraphExec_t\ncannot run concurrently with itself. A launch of a\ncudaGraphExec_t\nwill be ordered after previous launches of the same executable graph.\nGraph execution is done in streams for ordering with other asynchronous work. However, the stream is for ordering only; it does not constrain the internal parallelism of the graph, nor does it affect where graph nodes execute.\nSee\nGraph API.\n6.2.8.7.7.\nDevice Graph Launch\nï\nThere are many workflows which need to make data-dependent decisions during runtime and execute different operations depending on those decisions. Rather than offloading this decision-making process to the host, which may require a round-trip from the device, users may prefer to perform it on the device. To that end, CUDA provides a mechanism to launch graphs from the device.\nDevice graph launch provides a convenient way to perform dynamic control flow from the device, be it something as simple as a loop or as complex as a device-side work scheduler. This functionality is only available on systems which support\nunified addressing\n.\nGraphs which can be launched from the device will henceforth be referred to as device graphs, and graphs which cannot be launched from the device will be referred to as host graphs.\nDevice graphs can be launched from both the host and device, whereas host graphs can only be launched from the host. Unlike host launches, launching a device graph from the device while a previous launch of the graph is running will result in an error, returning\ncudaErrorInvalidValue\n; therefore, a device graph cannot be launched twice from the device at the same time. Launching a device graph from the host and device simultaneously will result in undefined behavior.\n6.2.8.7.7.1.\nDevice Graph Creation\nï\nIn order for a graph to be launched from the device, it must be instantiated explicitly for device launch. This is achieved by passing the\ncudaGraphInstantiateFlagDeviceLaunch\nflag to the\ncudaGraphInstantiate()\ncall. As is the case for host graphs, device graph structure is fixed at time of instantiation and cannot be updated without re-instantiation, and instantiation can only be performed on the host. In order for a graph to be able to be instantiated for device launch, it must adhere to various requirements.\n6.2.8.7.7.1.1.\nDevice Graph Requirements\nï\nGeneral requirements:\nThe graphâs nodes must all reside on a single device.\nThe graph can only contain kernel nodes, memcpy nodes, memset nodes, and child graph nodes.\nKernel nodes:\nUse of CUDA Dynamic Parallelism by kernels in the graph is not permitted.\nCooperative launches are permitted so long as MPS is not in use.\nMemcpy nodes:\nOnly copies involving device memory and/or pinned device-mapped host memory are permitted.\nCopies involving CUDA arrays are not permitted.\nBoth operands must be accessible from the current device at time of instantiation. Note that the copy operation will be performed from the device on which the graph resides, even if it is targeting memory on another device.\n6.2.8.7.7.1.2.\nDevice Graph Upload\nï\nIn order to launch a graph on the device, it must first be uploaded to the device to populate the necessary device resources. This can be achieved in one of two ways.\nFirstly, the graph can be uploaded explicitly, either via\ncudaGraphUpload()\nor by requesting an upload as part of instantiation via\ncudaGraphInstantiateWithParams()\n.\nAlternatively, the graph can first be launched from the host, which will perform this upload step implicitly as part of the launch.\nExamples of all three methods can be seen below:\n// Explicit upload after instantiation\ncudaGraphInstantiate\n(\n&\ndeviceGraphExec1\n,\ndeviceGraph1\n,\ncudaGraphInstantiateFlagDeviceLaunch\n);\ncudaGraphUpload\n(\ndeviceGraphExec1\n,\nstream\n);\n// Explicit upload as part of instantiation\ncudaGraphInstantiateParams\ninstantiateParams\n=\n{\n0\n};\ninstantiateParams\n.\nflags\n=\ncudaGraphInstantiateFlagDeviceLaunch\n|\ncudaGraphInstantiateFlagUpload\n;\ninstantiateParams\n.\nuploadStream\n=\nstream\n;\ncudaGraphInstantiateWithParams\n(\n&\ndeviceGraphExec2\n,\ndeviceGraph2\n,\n&\ninstantiateParams\n);\n// Implicit upload via host launch\ncudaGraphInstantiate\n(\n&\ndeviceGraphExec3\n,\ndeviceGraph3\n,\ncudaGraphInstantiateFlagDeviceLaunch\n);\ncudaGraphLaunch\n(\ndeviceGraphExec3\n,\nstream\n);\n6.2.8.7.7.1.3.\nDevice Graph Update\nï\nDevice graphs can only be updated from the host, and must be re-uploaded to the device upon executable graph update in order for the changes to take effect. This can be achieved using the same methods outlined in the previous section. Unlike host graphs, launching a device graph from the device while an update is being applied will result in undefined behavior.\n6.2.8.7.7.2.\nDevice Launch\nï\nDevice graphs can be launched from both the host and the device via\ncudaGraphLaunch()\n, which has the same signature on the device as on the host. Device graphs are launched via the same handle on the host and the device. Device graphs must be launched from another graph when launched from the device.\nDevice-side graph launch is per-thread and multiple launches may occur from different threads at the same time, so the user will need to select a single thread from which to launch a given graph.\n6.2.8.7.7.2.1.\nDevice Launch Modes\nï\nUnlike host launch, device graphs cannot be launched into regular CUDA streams, and can only be launched into distinct named streams, which each denote a specific launch mode:\nTable 5\nDevice-only Graph Launch Streams\nï\nStream\nLaunch Mode\ncudaStreamGraphFireAndForget\nFire and forget launch\ncudaStreamGraphTailLaunch\nTail launch\ncudaStreamGraphFireAndForgetAsSibling\nSibling launch\n6.2.8.7.7.2.1.1.\nFire and Forget Launch\nï\nAs the name suggests, a fire and forget launch is submitted to the GPU immediately, and it runs independently of the launching graph. In a fire-and-forget scenario, the launching graph is the parent, and the launched graph is the child.\nFigure 15\nFire and forget launch\nï\nThe above diagram can be generated by the sample code below:\n__global__\nvoid\nlaunchFireAndForgetGraph\n(\ncudaGraphExec_t\ngraph\n)\n{\ncudaGraphLaunch\n(\ngraph\n,\ncudaStreamGraphFireAndForget\n);\n}\nvoid\ngraphSetup\n()\n{\ncudaGraphExec_t\ngExec1\n,\ngExec2\n;\ncudaGraph_t\ng1\n,\ng2\n;\n// Create, instantiate, and upload the device graph.\ncreate_graph\n(\n&\ng2\n);\ncudaGraphInstantiate\n(\n&\ngExec2\n,\ng2\n,\ncudaGraphInstantiateFlagDeviceLaunch\n);\ncudaGraphUpload\n(\ngExec2\n,\nstream\n);\n// Create and instantiate the launching graph.\ncudaStreamBeginCapture\n(\nstream\n,\ncudaStreamCaptureModeGlobal\n);\nlaunchFireAndForgetGraph\n<<<\n1\n,\n1\n,\n0\n,\nstream\n>>>\n(\ngExec2\n);\ncudaStreamEndCapture\n(\nstream\n,\n&\ng1\n);\ncudaGraphInstantiate\n(\n&\ngExec1\n,\ng1\n);\n// Launch the host graph, which will in turn launch the device graph.\ncudaGraphLaunch\n(\ngExec1\n,\nstream\n);\n}\nA graph can have up to 120 total fire-and-forget graphs during the course of its execution. This total resets between launches of the same parent graph.\n6.2.8.7.7.2.1.2.\nGraph Execution Environments\nï\nIn order to fully understand the device-side synchronization model, it is first necessary to understand the concept of an execution environment.\nWhen a graph is launched from the device, it is launched into its own execution environment. The execution environment of a given graph encapsulates all work in the graph as well as all generated fire and forget work. The graph can be considered complete when it has completed execution and when all generated child work is complete.\nThe below diagram shows the environment encapsulation that would be generated by the fire-and-forget sample code in the previous section.\nFigure 16\nFire and forget launch, with execution environments\nï\nThese environments are also hierarchical, so a graph environment can include multiple levels of child-environments from fire and forget launches.\nFigure 17\nNested fire and forget environments\nï\nWhen a graph is launched from the host, there exists a stream environment that parents the execution environment of the launched graph. The stream environment encapsulates all work generated as part of the overall launch. The stream launch is complete (i.e. downstream dependent work may now run) when the overall stream environment is marked as complete.\nFigure 18\nThe stream environment, visualized\nï\n6.2.8.7.7.2.1.3.\nTail Launch\nï\nUnlike on the host, it is not possible to synchronize with device graphs from the GPU via traditional methods such as\ncudaDeviceSynchronize()\nor\ncudaStreamSynchronize()\n. Rather, in order to enable serial work dependencies, a different launch mode - tail launch - is offered, to provide similar functionality.\nA tail launch executes when a graphâs environment is considered complete - ie, when the graph and all its children are complete. When a graph completes, the environment of the next graph in the tail launch list will replace the completed environment as a child of the parent environment. Like fire-and-forget launches, a graph can have multiple graphs enqueued for tail launch.\nFigure 19\nA simple tail launch\nï\nThe above execution flow can be generated by the code below:\n__global__\nvoid\nlaunchTailGraph\n(\ncudaGraphExec_t\ngraph\n)\n{\ncudaGraphLaunch\n(\ngraph\n,\ncudaStreamGraphTailLaunch\n);\n}\nvoid\ngraphSetup\n()\n{\ncudaGraphExec_t\ngExec1\n,\ngExec2\n;\ncudaGraph_t\ng1\n,\ng2\n;\n// Create, instantiate, and upload the device graph.\ncreate_graph\n(\n&\ng2\n);\ncudaGraphInstantiate\n(\n&\ngExec2\n,\ng2\n,\ncudaGraphInstantiateFlagDeviceLaunch\n);\ncudaGraphUpload\n(\ngExec2\n,\nstream\n);\n// Create and instantiate the launching graph.\ncudaStreamBeginCapture\n(\nstream\n,\ncudaStreamCaptureModeGlobal\n);\nlaunchTailGraph\n<<<\n1\n,\n1\n,\n0\n,\nstream\n>>>\n(\ngExec2\n);\ncudaStreamEndCapture\n(\nstream\n,\n&\ng1\n);\ncudaGraphInstantiate\n(\n&\ngExec1\n,\ng1\n);\n// Launch the host graph, which will in turn launch the device graph.\ncudaGraphLaunch\n(\ngExec1\n,\nstream\n);\n}\nTail launches enqueued by a given graph will execute one at a time, in order of when they were enqueued. So the first enqueued graph will run first, and then the second, and so on.\nFigure 20\nTail launch ordering\nï\nTail launches enqueued by a tail graph will execute before tail launches enqueued by previous graphs in the tail launch list. These new tail launches will execute in the order they are enqueued.\nFigure 21\nTail launch ordering when enqueued from multiple graphs\nï\nA graph can have up to 255 pending tail launches.\n6.2.8.7.7.2.1.3.1.\nTail Self-launch\nï\nIt is possible for a device graph to enqueue itself for a tail launch, although a given graph can only have one self-launch enqueued at a time. In order to query the currently running device graph so that it can be relaunched, a new device-side function is added:\ncudaGraphExec_t\ncudaGetCurrentGraphExec\n();\nThis function returns the handle of the currently running graph if it is a device graph. If the currently executing kernel is not a node within a device graph, this function will return NULL.\nBelow is sample code showing usage of this function for a relaunch loop:\n__device__\nint\nrelaunchCount\n=\n0\n;\n__global__\nvoid\nrelaunchSelf\n()\n{\nint\nrelaunchMax\n=\n100\n;\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\nif\n(\nrelaunchCount\n<\nrelaunchMax\n)\n{\ncudaGraphLaunch\n(\ncudaGetCurrentGraphExec\n(),\ncudaStreamGraphTailLaunch\n);\n}\nrelaunchCount\n++\n;\n}\n}\n6.2.8.7.7.2.1.4.\nSibling Launch\nï\nSibling launch is a variation of fire-and-forget launch in which the graph is launched not as a child of the launching graphâs execution environment, but rather as a child of the launching graphâs parent environment. Sibling launch is equivalent to a fire-and-forget launch from the launching graphâs parent environment.\nFigure 22\nA simple sibling launch\nï\nThe above diagram can be generated by the sample code below:\n__global__\nvoid\nlaunchSiblingGraph\n(\ncudaGraphExec_t\ngraph\n)\n{\ncudaGraphLaunch\n(\ngraph\n,\ncudaStreamGraphFireAndForgetAsSibling\n);\n}\nvoid\ngraphSetup\n()\n{\ncudaGraphExec_t\ngExec1\n,\ngExec2\n;\ncudaGraph_t\ng1\n,\ng2\n;\n// Create, instantiate, and upload the device graph.\ncreate_graph\n(\n&\ng2\n);\ncudaGraphInstantiate\n(\n&\ngExec2\n,\ng2\n,\ncudaGraphInstantiateFlagDeviceLaunch\n);\ncudaGraphUpload\n(\ngExec2\n,\nstream\n);\n// Create and instantiate the launching graph.\ncudaStreamBeginCapture\n(\nstream\n,\ncudaStreamCaptureModeGlobal\n);\nlaunchSiblingGraph\n<<<\n1\n,\n1\n,\n0\n,\nstream\n>>>\n(\ngExec2\n);\ncudaStreamEndCapture\n(\nstream\n,\n&\ng1\n);\ncudaGraphInstantiate\n(\n&\ngExec1\n,\ng1\n);\n// Launch the host graph, which will in turn launch the device graph.\ncudaGraphLaunch\n(\ngExec1\n,\nstream\n);\n}\nSince sibling launches are not launched into the launching graphâs execution environment, they will not gate tail launches enqueued by the launching graph.\n6.2.8.7.8.\nConditional Graph Nodes\nï\nConditional nodes allow conditional execution and looping of a graph contained within the conditional node. This allows dynamic and iterative workflows to be represented completely within a graph and frees up the host CPU to perform other work in parallel.\nEvaluation of the condition value is performed on the device when the dependencies of the conditional node have been met. Conditional nodes can be one of the following types:\nConditional\nIF nodes\nexecute their body graph once if the condition value is non-zero when the node is executed. An optional second body graph can be provided and this will be executed once if the condition value is zero when the node is executed.\nConditional\nWHILE nodes\nexecute their body graph if the condition value is non-zero when the node is executed and will continue to execute their body graph until the condition value is zero.\nConditional\nSWITCH nodes\nexecute the nth body graph once if the condition value is equal to n.  If the condition value does not correspond to a body graph, no body graph is launched.\nA condition value is accessed by a\nconditional handle\n, which must be created before the node. The condition value can be set by device code using\ncudaGraphSetConditional()\n. A default value, applied on each graph launch, can also be specified when the handle is created.\nWhen the conditional node is created, an empty graph is created and the handle is returned to the user so that the graph can be populated.  This conditional body graph can be populated using either the\ngraph APIs\nor\ncudaStreamBeginCaptureToGraph()\n.\nConditional nodes can be nested.\n6.2.8.7.8.1.\nConditional Handles\nï\nA condition value is represented by\ncudaGraphConditionalHandle\nand is created by\ncudaGraphConditionalHandleCreate()\n.\nThe handle must be associated with a single conditional node. Handles cannot be destroyed.\nIf\ncudaGraphCondAssignDefault\nis specified when the handle is created, the condition value will be initialized to the specified default at the beginning of each graph execution. If this flag is not provided, the condition value is undefined at the start of each graph execution and code should not assume that the condition value persists across executions.\nThe default value and flags associated with a handle will be updated during\nwhole graph update\n.\n6.2.8.7.8.2.\nConditional Node Body Graph Requirements\nï\nGeneral requirements:\nThe graphâs nodes must all reside on a single device.\nThe graph can only contain kernel nodes, empty nodes, memcpy nodes, memset nodes, child graph nodes, and conditional nodes.\nKernel nodes:\nUse of CUDA Dynamic Parallelism or Device Graph Launch by kernels in the graph is not permitted.\nCooperative launches are permitted so long as MPS is not in use.\nMemcpy/Memset nodes:\nOnly copies/memsets involving device memory and/or pinned device-mapped host memory are permitted.\nCopies/memsets involving CUDA arrays are not permitted.\nBoth operands must be accessible from the current device at time of instantiation. Note that the copy operation will be performed from the device on which the graph resides, even if it is targeting memory on another device.\n6.2.8.7.8.3.\nConditional IF Nodes\nï\nThe body graph of an IF node will be executed once if the condition is non-zero when the node is executed.  The following diagram depicts a 3 node graph where the middle node, B, is a conditional node:\nFigure 23\nConditional IF Node\nï\nThe following code illustrates the creation of a graph containing an IF conditional node. The default value of the condition is set using an upstream kernel. The body of the conditional is populated using the\ngraph API\n.\n__global__\nvoid\nsetHandle\n(\ncudaGraphConditionalHandle\nhandle\n)\n{\n...\ncudaGraphSetConditional\n(\nhandle\n,\nvalue\n);\n...\n}\nvoid\ngraphSetup\n()\n{\ncudaGraph_t\ngraph\n;\ncudaGraphExec_t\ngraphExec\n;\ncudaGraphNode_t\nnode\n;\nvoid\n*\nkernelArgs\n[\n1\n];\nint\nvalue\n=\n1\n;\ncudaGraphCreate\n(\n&\ngraph\n,\n0\n);\ncudaGraphConditionalHandle\nhandle\n;\ncudaGraphConditionalHandleCreate\n(\n&\nhandle\n,\ngraph\n);\n// Use a kernel upstream of the conditional to set the handle value\ncudaGraphNodeParams\nparams\n=\n{\ncudaGraphNodeTypeKernel\n};\nparams\n.\nkernel\n.\nfunc\n=\n(\nvoid\n*\n)\nsetHandle\n;\nparams\n.\nkernel\n.\ngridDim\n.\nx\n=\nparams\n.\nkernel\n.\ngridDim\n.\ny\n=\nparams\n.\nkernel\n.\ngridDim\n.\nz\n=\n1\n;\nparams\n.\nkernel\n.\nblockDim\n.\nx\n=\nparams\n.\nkernel\n.\nblockDim\n.\ny\n=\nparams\n.\nkernel\n.\nblockDim\n.\nz\n=\n1\n;\nparams\n.\nkernel\n.\nkernelParams\n=\nkernelArgs\n;\nkernelArgs\n[\n0\n]\n=\n&\nhandle\n;\ncudaGraphAddNode\n(\n&\nnode\n,\ngraph\n,\nNULL\n,\nNULL\n,\n0\n,\n&\nparams\n);\ncudaGraphNodeParams\ncParams\n=\n{\ncudaGraphNodeTypeConditional\n};\ncParams\n.\nconditional\n.\nhandle\n=\nhandle\n;\ncParams\n.\nconditional\n.\ntype\n=\ncudaGraphCondTypeIf\n;\ncParams\n.\nconditional\n.\nsize\n=\n1\n;\ncudaGraphAddNode\n(\n&\nnode\n,\ngraph\n,\n&\nnode\n,\nNULL\n,\n1\n,\n&\ncParams\n);\ncudaGraph_t\nbodyGraph\n=\ncParams\n.\nconditional\n.\nphGraph_out\n[\n0\n];\n// Populate the body of the conditional node\n...\ncudaGraphAddNode\n(\n&\nnode\n,\nbodyGraph\n,\nNULL\n,\nNULL\n,\n0\n,\n&\nparams\n);\ncudaGraphInstantiate\n(\n&\ngraphExec\n,\ngraph\n,\nNULL\n,\nNULL\n,\n0\n);\ncudaGraphLaunch\n(\ngraphExec\n,\n0\n);\ncudaDeviceSynchronize\n();\ncudaGraphExecDestroy\n(\ngraphExec\n);\ncudaGraphDestroy\n(\ngraph\n);\n}\nStarting in CUDA 12.8, IF nodes can also have an optional second body graph which is executed once when the node is executed if the condition value is zero.\nvoid\ngraphSetup\n()\n{\ncudaGraph_t\ngraph\n;\ncudaGraphExec_t\ngraphExec\n;\ncudaGraphNode_t\nnode\n;\nvoid\n*\nkernelArgs\n[\n1\n];\nint\nvalue\n=\n1\n;\ncudaGraphCreate\n(\n&\ngraph\n,\n0\n);\ncudaGraphConditionalHandle\nhandle\n;\ncudaGraphConditionalHandleCreate\n(\n&\nhandle\n,\ngraph\n);\n// Use a kernel upstream of the conditional to set the handle value\ncudaGraphNodeParams\nparams\n=\n{\ncudaGraphNodeTypeKernel\n};\nparams\n.\nkernel\n.\nfunc\n=\n(\nvoid\n*\n)\nsetHandle\n;\nparams\n.\nkernel\n.\ngridDim\n.\nx\n=\nparams\n.\nkernel\n.\ngridDim\n.\ny\n=\nparams\n.\nkernel\n.\ngridDim\n.\nz\n=\n1\n;\nparams\n.\nkernel\n.\nblockDim\n.\nx\n=\nparams\n.\nkernel\n.\nblockDim\n.\ny\n=\nparams\n.\nkernel\n.\nblockDim\n.\nz\n=\n1\n;\nparams\n.\nkernel\n.\nkernelParams\n=\nkernelArgs\n;\nkernelArgs\n[\n0\n]\n=\n&\nhandle\n;\ncudaGraphAddNode\n(\n&\nnode\n,\ngraph\n,\nNULL\n,\nNULL\n,\n0\n,\n&\nparams\n);\ncudaGraphNodeParams\ncParams\n=\n{\ncudaGraphNodeTypeConditional\n};\ncParams\n.\nconditional\n.\nhandle\n=\nhandle\n;\ncParams\n.\nconditional\n.\ntype\n=\ncudaGraphCondTypeIf\n;\ncParams\n.\nconditional\n.\nsize\n=\n2\n;\n// Note that size is now set to '2'\ncudaGraphAddNode\n(\n&\nnode\n,\ngraph\n,\n&\nnode\n,\nNULL\n,\n1\n,\n&\ncParams\n);\ncudaGraph_t\nifBodyGraph\n=\ncParams\n.\nconditional\n.\nphGraph_out\n[\n0\n];\ncudaGraph_t\nelseBodyGraph\n=\ncParams\n.\nconditional\n.\nphGraph_out\n[\n1\n];\n// Populate the body graphs of the conditional node\n...\ncudaGraphAddNode\n(\n&\nnode\n,\nifBodyGraph\n,\nNULL\n,\nNULL\n,\n0\n,\n&\nparams\n);\n...\ncudaGraphAddNode\n(\n&\nnode\n,\nelseBodyGraph\n,\nNULL\n,\nNULL\n,\n0\n,\n&\nparams\n);\ncudaGraphInstantiate\n(\n&\ngraphExec\n,\ngraph\n,\nNULL\n,\nNULL\n,\n0\n);\ncudaGraphLaunch\n(\ngraphExec\n,\n0\n);\ncudaDeviceSynchronize\n();\ncudaGraphExecDestroy\n(\ngraphExec\n);\ncudaGraphDestroy\n(\ngraph\n);\n}\n6.2.8.7.8.4.\nConditional WHILE Nodes\nï\nThe body graph of a WHILE node will be executed as long as the condition is non-zero. The condition will be\nevaluated when the node is executed and after completion of the body graph. The following diagram depicts\na 3 node graph where the middle node, B, is a conditional node:\nFigure 24\nConditional WHILE Node\nï\nThe following code illustrates the creation of a graph containing a WHILE conditional node. The handle\nis created using\ncudaGraphCondAssignDefault\nto avoid the need for an upstream kernel. The body of the\nconditional is populated using the\ngraph API\n.\n__global__\nvoid\nloopKernel\n(\ncudaGraphConditionalHandle\nhandle\n)\n{\nstatic\nint\ncount\n=\n10\n;\ncudaGraphSetConditional\n(\nhandle\n,\n--\ncount\n?\n1\n:\n0\n);\n}\nvoid\ngraphSetup\n()\n{\ncudaGraph_t\ngraph\n;\ncudaGraphExec_t\ngraphExec\n;\ncudaGraphNode_t\nnode\n;\nvoid\n*\nkernelArgs\n[\n1\n];\ncuGraphCreate\n(\n&\ngraph\n,\n0\n);\ncudaGraphConditionalHandle\nhandle\n;\ncudaGraphConditionalHandleCreate\n(\n&\nhandle\n,\ngraph\n,\n1\n,\ncudaGraphCondAssignDefault\n);\ncudaGraphNodeParams\ncParams\n=\n{\ncudaGraphNodeTypeConditional\n};\ncParams\n.\nconditional\n.\nhandle\n=\nhandle\n;\ncParams\n.\nconditional\n.\ntype\n=\ncudaGraphCondTypeWhile\n;\ncParams\n.\nconditional\n.\nsize\n=\n1\n;\ncudaGraphAddNode\n(\n&\nnode\n,\ngraph\n,\nNULL\n,\nNULL\n,\n0\n,\n&\ncParams\n);\ncudaGraph_t\nbodyGraph\n=\ncParams\n.\nconditional\n.\nphGraph_out\n[\n0\n];\ncudaGraphNodeParams\nparams\n=\n{\ncudaGraphNodeTypeKernel\n};\nparams\n.\nkernel\n.\nfunc\n=\n(\nvoid\n*\n)\nloopKernel\n;\nparams\n.\nkernel\n.\ngridDim\n.\nx\n=\nparams\n.\nkernel\n.\ngridDim\n.\ny\n=\nparams\n.\nkernel\n.\ngridDim\n.\nz\n=\n1\n;\nparams\n.\nkernel\n.\nblockDim\n.\nx\n=\nparams\n.\nkernel\n.\nblockDim\n.\ny\n=\nparams\n.\nkernel\n.\nblockDim\n.\nz\n=\n1\n;\nparams\n.\nkernel\n.\nkernelParams\n=\nkernelArgs\n;\nkernelArgs\n[\n0\n]\n=\n&\nhandle\n;\ncudaGraphAddNode\n(\n&\nnode\n,\nbodyGraph\n,\nNULL\n,\nNULL\n,\n0\n,\n&\nparams\n);\ncudaGraphInstantiate\n(\n&\ngraphExec\n,\ngraph\n,\nNULL\n,\nNULL\n,\n0\n);\ncudaGraphLaunch\n(\ngraphExec\n,\n0\n);\ncudaDeviceSynchronize\n();\ncudaGraphExecDestroy\n(\ngraphExec\n);\ncudaGraphDestroy\n(\ngraph\n);\n}\n6.2.8.7.8.5.\nConditional SWITCH Nodes\nï\nSWITCH nodes, added in CUDA 12.8, execute 1 of n different graphs within the conditional node. The nth graph will be executed when the SWITCH node is evaluated if the condition value is n. If the condition value is greater than or equal to n, no graph will be executed. The following diagram depicts a 3 node graph where the middle node, B, is a conditional node:\nFigure 25\nConditional SWITCH Node\nï\nThe following code illustrates the creation of a graph containing a SWITCH conditional node. The value of the condition is set using an upstream kernel. The bodies of the conditional are populated using the\ngraph API\n.\n__global__\nvoid\nsetHandle\n(\ncudaGraphConditionalHandle\nhandle\n)\n{\n...\ncudaGraphSetConditional\n(\nhandle\n,\nvalue\n);\n...\n}\nvoid\ngraphSetup\n()\n{\ncudaGraph_t\ngraph\n;\ncudaGraphExec_t\ngraphExec\n;\ncudaGraphNode_t\nnode\n;\nvoid\n*\nkernelArgs\n[\n1\n];\nint\nvalue\n=\n1\n;\ncudaGraphCreate\n(\n&\ngraph\n,\n0\n);\ncudaGraphConditionalHandle\nhandle\n;\ncudaGraphConditionalHandleCreate\n(\n&\nhandle\n,\ngraph\n);\n// Use a kernel upstream of the conditional to set the handle value\ncudaGraphNodeParams\nparams\n=\n{\ncudaGraphNodeTypeKernel\n};\nparams\n.\nkernel\n.\nfunc\n=\n(\nvoid\n*\n)\nsetHandle\n;\nparams\n.\nkernel\n.\ngridDim\n.\nx\n=\nparams\n.\nkernel\n.\ngridDim\n.\ny\n=\nparams\n.\nkernel\n.\ngridDim\n.\nz\n=\n1\n;\nparams\n.\nkernel\n.\nblockDim\n.\nx\n=\nparams\n.\nkernel\n.\nblockDim\n.\ny\n=\nparams\n.\nkernel\n.\nblockDim\n.\nz\n=\n1\n;\nparams\n.\nkernel\n.\nkernelParams\n=\nkernelArgs\n;\nkernelArgs\n[\n0\n]\n=\n&\nhandle\n;\ncudaGraphAddNode\n(\n&\nnode\n,\ngraph\n,\nNULL\n,\nNULL\n,\n0\n,\n&\nparams\n);\ncudaGraphNodeParams\ncParams\n=\n{\ncudaGraphNodeTypeConditional\n};\ncParams\n.\nconditional\n.\nhandle\n=\nhandle\n;\ncParams\n.\nconditional\n.\ntype\n=\ncudaGraphCondTypeSwitch\n;\ncParams\n.\nconditional\n.\nsize\n=\n5\n;\ncudaGraphAddNode\n(\n&\nnode\n,\ngraph\n,\n&\nnode\n,\nNULL\n,\n1\n,\n&\ncParams\n);\ncudaGraph_t\n*\nbodyGraphs\n=\ncParams\n.\nconditional\n.\nphGraph_out\n;\n// Populate the first body of the conditional node\n...\ncudaGraphAddNode\n(\n&\nnode\n,\nbodyGraphs\n[\n0\n],\nNULL\n,\nNULL\n,\n0\n,\n&\nparams\n);\n...\n// Populate the last body of the conditional node\ncudaGraphAddNode\n(\n&\nnode\n,\nbodyGraphs\n[\n4\n],\nNULL\n,\nNULL\n,\n0\n,\n&\nparams\n);\ncudaGraphInstantiate\n(\n&\ngraphExec\n,\ngraph\n,\nNULL\n,\nNULL\n,\n0\n);\ncudaGraphLaunch\n(\ngraphExec\n,\n0\n);\ncudaDeviceSynchronize\n();\ncudaGraphExecDestroy\n(\ngraphExec\n);\ncudaGraphDestroy\n(\ngraph\n);\n}\n6.2.8.8.\nEvents\nï\nThe runtime also provides a way to closely monitor the deviceâs progress, as well as perform accurate timing, by letting the application asynchronously record\nevents\nat any point in the program, and query when these events are completed. An event has completed when all tasks - or optionally, all commands in a given stream - preceding the event have completed. Events in stream zero are completed after all preceding tasks and commands in all streams are completed.\n6.2.8.8.1.\nCreation and Destruction of Events\nï\nThe following code sample creates two events:\ncudaEvent_t\nstart\n,\nstop\n;\ncudaEventCreate\n(\n&\nstart\n);\ncudaEventCreate\n(\n&\nstop\n);\nThey are destroyed this way:\ncudaEventDestroy\n(\nstart\n);\ncudaEventDestroy\n(\nstop\n);\n6.2.8.8.2.\nElapsed Time\nï\nThe events created in\nCreation and Destruction of Events\ncan be used to time the code sample of\nCreation and Destruction of Streams\nthe following way:\ncudaEventRecord\n(\nstart\n,\n0\n);\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n2\n;\n++\ni\n)\n{\ncudaMemcpyAsync\n(\ninputDev\n+\ni\n*\nsize\n,\ninputHost\n+\ni\n*\nsize\n,\nsize\n,\ncudaMemcpyHostToDevice\n,\nstream\n[\ni\n]);\nMyKernel\n<<<\n100\n,\n512\n,\n0\n,\nstream\n[\ni\n]\n>>>\n(\noutputDev\n+\ni\n*\nsize\n,\ninputDev\n+\ni\n*\nsize\n,\nsize\n);\ncudaMemcpyAsync\n(\noutputHost\n+\ni\n*\nsize\n,\noutputDev\n+\ni\n*\nsize\n,\nsize\n,\ncudaMemcpyDeviceToHost\n,\nstream\n[\ni\n]);\n}\ncudaEventRecord\n(\nstop\n,\n0\n);\ncudaEventSynchronize\n(\nstop\n);\nfloat\nelapsedTime\n;\ncudaEventElapsedTime\n(\n&\nelapsedTime\n,\nstart\n,\nstop\n);\n6.2.8.9.\nSynchronous Calls\nï\nWhen a synchronous function is called, control is not returned to the host thread before the device has completed the requested task. Whether the host thread will then yield, block, or spin can be specified by calling\ncudaSetDeviceFlags()\nwith some specific flags (see reference manual for details) before any other CUDA call is performed by the host thread.\n6.2.9.\nMulti-Device System\nï\n6.2.9.1.\nDevice Enumeration\nï\nA host system can have multiple devices. The following code sample shows how to enumerate these devices, query their properties, and determine the number of CUDA-enabled devices.\nint\ndeviceCount\n;\ncudaGetDeviceCount\n(\n&\ndeviceCount\n);\nint\ndevice\n;\nfor\n(\ndevice\n=\n0\n;\ndevice\n<\ndeviceCount\n;\n++\ndevice\n)\n{\ncudaDeviceProp\ndeviceProp\n;\ncudaGetDeviceProperties\n(\n&\ndeviceProp\n,\ndevice\n);\nprintf\n(\n\"Device %d has compute capability %d.%d.\n\\n\n\"\n,\ndevice\n,\ndeviceProp\n.\nmajor\n,\ndeviceProp\n.\nminor\n);\n}\n6.2.9.2.\nDevice Selection\nï\nA host thread can set the device it operates on at any time by calling\ncudaSetDevice()\n. Device memory allocations and kernel launches are made on the currently set device; streams and events are created in association with the currently set device. If no call to\ncudaSetDevice()\nis made, the current device is device 0.\nThe following code sample illustrates how setting the current device affects memory allocation and kernel execution.\nsize_t\nsize\n=\n1024\n*\nsizeof\n(\nfloat\n);\ncudaSetDevice\n(\n0\n);\n// Set device 0 as current\nfloat\n*\np0\n;\ncudaMalloc\n(\n&\np0\n,\nsize\n);\n// Allocate memory on device 0\nMyKernel\n<<<\n1000\n,\n128\n>>>\n(\np0\n);\n// Launch kernel on device 0\ncudaSetDevice\n(\n1\n);\n// Set device 1 as current\nfloat\n*\np1\n;\ncudaMalloc\n(\n&\np1\n,\nsize\n);\n// Allocate memory on device 1\nMyKernel\n<<<\n1000\n,\n128\n>>>\n(\np1\n);\n// Launch kernel on device 1\n6.2.9.3.\nStream and Event Behavior\nï\nA kernel launch will fail if it is issued to a stream that is not associated to the current device as illustrated in the following code sample.\ncudaSetDevice\n(\n0\n);\n// Set device 0 as current\ncudaStream_t\ns0\n;\ncudaStreamCreate\n(\n&\ns0\n);\n// Create stream s0 on device 0\nMyKernel\n<<<\n100\n,\n64\n,\n0\n,\ns0\n>>>\n();\n// Launch kernel on device 0 in s0\ncudaSetDevice\n(\n1\n);\n// Set device 1 as current\ncudaStream_t\ns1\n;\ncudaStreamCreate\n(\n&\ns1\n);\n// Create stream s1 on device 1\nMyKernel\n<<<\n100\n,\n64\n,\n0\n,\ns1\n>>>\n();\n// Launch kernel on device 1 in s1\n// This kernel launch will fail:\nMyKernel\n<<<\n100\n,\n64\n,\n0\n,\ns0\n>>>\n();\n// Launch kernel on device 1 in s0\nA memory copy will succeed even if it is issued to a stream that is not associated to the current device.\ncudaEventRecord()\nwill fail if the input event and input stream are associated to different devices.\ncudaEventElapsedTime()\nwill fail if the two input events are associated to different devices.\ncudaEventSynchronize()\nand\ncudaEventQuery()\nwill succeed even if the input event is associated to a device that is different from the current device.\ncudaStreamWaitEvent()\nwill succeed even if the input stream and input event are associated to different devices.\ncudaStreamWaitEvent()\ncan therefore be used to synchronize multiple devices with each other.\nEach device has its own default stream (see\nDefault Stream\n), so commands issued to the default stream of a device may execute out of order or concurrently with respect to commands issued to the default stream of any other device.\n6.2.9.4.\nPeer-to-Peer Memory Access\nï\nDepending on the system properties, specifically the PCIe and/or NVLINK topology, devices are able to address each otherâs memory (i.e., a kernel executing on one device can dereference a pointer to the memory of the other device). This peer-to-peer memory access feature is supported between two devices if\ncudaDeviceCanAccessPeer()\nreturns true for these two devices.\nPeer-to-peer memory access is only supported in 64-bit applications and must be enabled between two devices by calling\ncudaDeviceEnablePeerAccess()\nas illustrated in the following code sample. On non-NVSwitch enabled systems, each device can support a system-wide maximum of eight peer connections.\nA unified address space is used for both devices (see\nUnified Virtual Address Space\n), so the same pointer can be used to address memory from both devices as shown in the code sample below.\ncudaSetDevice\n(\n0\n);\n// Set device 0 as current\nfloat\n*\np0\n;\nsize_t\nsize\n=\n1024\n*\nsizeof\n(\nfloat\n);\ncudaMalloc\n(\n&\np0\n,\nsize\n);\n// Allocate memory on device 0\nMyKernel\n<<<\n1000\n,\n128\n>>>\n(\np0\n);\n// Launch kernel on device 0\ncudaSetDevice\n(\n1\n);\n// Set device 1 as current\ncudaDeviceEnablePeerAccess\n(\n0\n,\n0\n);\n// Enable peer-to-peer access\n// with device 0\n// Launch kernel on device 1\n// This kernel launch can access memory on device 0 at address p0\nMyKernel\n<<<\n1000\n,\n128\n>>>\n(\np0\n);\n6.2.9.4.1.\nIOMMU on Linux\nï\nOn Linux only, CUDA and the display driver does not support IOMMU-enabled bare-metal PCIe peer to peer memory copy. However, CUDA and the display driver does support IOMMU via VM pass through. As a consequence, users on Linux, when running on a native bare metal system, should disable the IOMMU. The IOMMU should be enabled and the VFIO driver be used as a PCIe pass through for virtual machines.\nOn Windows the above limitation does not exist.\nSee also\nAllocating DMA Buffers on 64-bit Platforms\n.\n6.2.9.5.\nPeer-to-Peer Memory Copy\nï\nMemory copies can be performed between the memories of two different devices.\nWhen a unified address space is used for both devices (see\nUnified Virtual Address Space\n), this is done using the regular memory copy functions mentioned in\nDevice Memory\n.\nOtherwise, this is done using\ncudaMemcpyPeer()\n,\ncudaMemcpyPeerAsync()\n,\ncudaMemcpy3DPeer()\n, or\ncudaMemcpy3DPeerAsync()\nas illustrated in the following code sample.\ncudaSetDevice\n(\n0\n);\n// Set device 0 as current\nfloat\n*\np0\n;\nsize_t\nsize\n=\n1024\n*\nsizeof\n(\nfloat\n);\ncudaMalloc\n(\n&\np0\n,\nsize\n);\n// Allocate memory on device 0\ncudaSetDevice\n(\n1\n);\n// Set device 1 as current\nfloat\n*\np1\n;\ncudaMalloc\n(\n&\np1\n,\nsize\n);\n// Allocate memory on device 1\ncudaSetDevice\n(\n0\n);\n// Set device 0 as current\nMyKernel\n<<<\n1000\n,\n128\n>>>\n(\np0\n);\n// Launch kernel on device 0\ncudaSetDevice\n(\n1\n);\n// Set device 1 as current\ncudaMemcpyPeer\n(\np1\n,\n1\n,\np0\n,\n0\n,\nsize\n);\n// Copy p0 to p1\nMyKernel\n<<<\n1000\n,\n128\n>>>\n(\np1\n);\n// Launch kernel on device 1\nA copy (in the implicit\nNULL\nstream) between the memories of two different devices:\ndoes not start until all commands previously issued to either device have completed and\nruns to completion before any commands (see\nAsynchronous Concurrent Execution\n) issued after the copy to either device can start.\nConsistent with the normal behavior of streams, an asynchronous copy between the memories of two devices may overlap with copies or kernels in another stream.\nNote that if peer-to-peer access is enabled between two devices via\ncudaDeviceEnablePeerAccess()\nas described in\nPeer-to-Peer Memory Access\n, peer-to-peer memory copy between these two devices no longer needs to be staged through the host and is therefore faster.\n6.2.10.\nUnified Virtual Address Space\nï\nWhen the application is run as a 64-bit process, a single address space is used for the host and all the devices of compute capability 2.0 and higher. All host memory allocations made via CUDA API calls and all device memory allocations on supported devices are within this virtual address range. As a consequence:\nThe location of any memory on the host allocated through CUDA, or on any of the devices which use the unified address space, can be determined from the value of the pointer using\ncudaPointerGetAttributes()\n.\nWhen copying to or from the memory of any device which uses the unified address space, the\ncudaMemcpyKind\nparameter of\ncudaMemcpy*()\ncan be set to\ncudaMemcpyDefault\nto determine locations from the pointers. This also works for host pointers not allocated through CUDA, as long as the current device uses unified addressing.\nAllocations via\ncudaHostAlloc()\nare automatically portable (see\nPortable Memory\n) across all the devices for which the unified address space is used, and pointers returned by\ncudaHostAlloc()\ncan be used directly from within kernels running on these devices (i.e., there is no need to obtain a device pointer via\ncudaHostGetDevicePointer()\nas described in\nMapped Memory\n.\nApplications may query if the unified address space is used for a particular device by checking that the\nunifiedAddressing\ndevice property (see\nDevice Enumeration\n) is equal to 1.\n6.2.11.\nInterprocess Communication\nï\nAny device memory pointer or event handle created by a host thread can be directly referenced by any other thread within the same process. It is not valid outside this process however, and therefore cannot be directly referenced by threads belonging to a different process.\nTo share device memory pointers and events across processes, an application must use the Inter Process Communication API, which is described in detail in the reference manual. The IPC API is only supported for 64-bit processes on Linux and for devices of compute capability 2.0 and higher. Note that the IPC API is not supported for\ncudaMallocManaged\nallocations.\nUsing this API, an application can get the IPC handle for a given device memory pointer using\ncudaIpcGetMemHandle()\n, pass it to another process using standard IPC mechanisms (for example, interprocess shared memory or files), and use\ncudaIpcOpenMemHandle()\nto retrieve a device pointer from the IPC handle that is a valid pointer within this other process. Event handles can be shared using similar entry points.\nNote that allocations made by\ncudaMalloc()\nmay be sub-allocated from a larger block of memory for performance reasons. In such case, CUDA IPC APIs will share the entire underlying memory block which may cause other sub-allocations to be shared, which can potentially lead to information disclosure between processes. To prevent this behavior, it is recommended to only share allocations with a 2MiB aligned size.\nAn example of using the IPC API is where a single primary process generates a batch of input data, making the data available to multiple secondary processes without requiring regeneration or copying.\nApplications using CUDA IPC to communicate with each other should be compiled, linked, and run with the same CUDA driver and runtime.\nNote\nSince CUDA 11.5, only events-sharing IPC APIs are supported on L4T and embedded Linux Tegra devices with compute capability 7.x and higher. The memory-sharing IPC APIs are still not supported on Tegra platforms.\n6.2.12.\nError Checking\nï\nAll runtime functions return an error code, but for an asynchronous function (see\nAsynchronous Concurrent Execution\n), this error code cannot possibly report any of the asynchronous errors that could occur on the device since the function returns before the device has completed the task; the error code only reports errors that occur on the host prior to executing the task, typically related to parameter validation; if an asynchronous error occurs, it will be reported by some subsequent unrelated runtime function call.\nThe only way to check for asynchronous errors just after some asynchronous function call is therefore to synchronize just after the call by calling\ncudaDeviceSynchronize()\n(or by using any other synchronization mechanisms described in\nAsynchronous Concurrent Execution\n) and checking the error code returned by\ncudaDeviceSynchronize()\n.\nThe runtime maintains an error variable for each host thread that is initialized to\ncudaSuccess\nand is overwritten by the error code every time an error occurs (be it a parameter validation error or an asynchronous error).\ncudaPeekAtLastError()\nreturns this variable.\ncudaGetLastError()\nreturns this variable and resets it to\ncudaSuccess\n.\nKernel launches do not return any error code, so\ncudaPeekAtLastError()\nor\ncudaGetLastError()\nmust be called just after the kernel launch to retrieve any pre-launch errors. To ensure that any error returned by\ncudaPeekAtLastError()\nor\ncudaGetLastError()\ndoes not originate from calls prior to the kernel launch, one has to make sure that the runtime error variable is set to\ncudaSuccess\njust before the kernel launch, for example, by calling\ncudaGetLastError()\njust before the kernel launch. Kernel launches are asynchronous, so to check for asynchronous errors, the application must synchronize in-between the kernel launch and the call to\ncudaPeekAtLastError()\nor\ncudaGetLastError()\n.\nNote that\ncudaErrorNotReady\nthat may be returned by\ncudaStreamQuery()\nand\ncudaEventQuery()\nis not considered an error and is therefore not reported by\ncudaPeekAtLastError()\nor\ncudaGetLastError()\n.\n6.2.13.\nCall Stack\nï\nOn devices of compute capability 2.x and higher, the size of the call stack can be queried using\ncudaDeviceGetLimit()\nand set using\ncudaDeviceSetLimit()\n.\nWhen the call stack overflows, the kernel call fails with a stack overflow error if the application is run via a CUDA debugger (CUDA-GDB, Nsight) or an unspecified launch error, otherwise.\nWhen the compiler cannot determine the stack size, it issues a warning saying Stack size cannot be statically determined. This is usually the case with recursive functions.\nOnce this warning is issued, user will need to set stack size manually if default stack size is not sufficient.\n6.2.14.\nTexture and Surface Memory\nï\nCUDA supports a subset of the texturing hardware that the GPU uses for graphics to access texture and surface memory. Reading data from texture or surface memory instead of global memory can have several performance benefits as described in\nDevice Memory Accesses\n.\n6.2.14.1.\nTexture Memory\nï\nTexture memory is read from kernels using the device functions described in\nTexture Functions\n. The process of reading a texture calling one of these functions is called a\ntexture fetch\n. Each texture fetch specifies a parameter called a\ntexture object\nfor the texture object API.\nThe texture object specifies:\nThe\ntexture\n, which is the piece of texture memory that is fetched. Texture objects are created at runtime and the texture is specified when creating the texture object as described in\nTexture Object API\n.\nIts\ndimensionality\nthat specifies whether the texture is addressed as a one dimensional array using one texture coordinate, a two-dimensional array using two texture coordinates, or a three-dimensional array using three texture coordinates. Elements of the array are called\ntexels\n, short for\ntexture elements\n. The\ntexture width\n,\nheight\n, and\ndepth\nrefer to the size of the array in each dimension.\nTable 27\nlists the maximum texture width, height, and depth depending on the compute capability of the device.\nThe type of a texel, which is restricted to the basic integer and single-precision floating-point types and any of the 1-, 2-, and 4-component vector types defined in\nBuilt-in Vector Types\nthat are derived from the basic integer and single-precision floating-point types.\nThe\nread mode\n, which is equal to\ncudaReadModeNormalizedFloat\nor\ncudaReadModeElementType\n. If it is\ncudaReadModeNormalizedFloat\nand the type of the texel is a 16-bit or 8-bit integer type, the value returned by the texture fetch is actually returned as floating-point type and the full range of the integer type is mapped to [0.0, 1.0] for unsigned integer type and [-1.0, 1.0] for signed integer type; for example, an unsigned 8-bit texture element with the value 0xff reads as 1. If it is\ncudaReadModeElementType\n, no conversion is performed.\nWhether texture coordinates are normalized or not. By default, textures are referenced (by the functions of\nTexture Functions\n) using floating-point coordinates in the range [0, N-1] where N is the size of the texture in the dimension corresponding to the coordinate. For example, a texture that is 64x32 in size will be referenced with coordinates in the range [0, 63] and [0, 31] for the x and y dimensions, respectively. Normalized texture coordinates cause the coordinates to be specified in the range [0.0, 1.0-1/N] instead of [0, N-1], so the same 64x32 texture would be addressed by normalized coordinates in the range [0, 1-1/N] in both the x and y dimensions. Normalized texture coordinates are a natural fit to some applicationsâ requirements, if it is preferable for the texture coordinates to be independent of the texture size.\nThe\naddressing mode\n. It is valid to call the device functions of Section B.8 with coordinates that are out of range. The addressing mode defines what happens in that case. The default addressing mode is to clamp the coordinates to the valid range: [0, N) for non-normalized coordinates and [0.0, 1.0) for normalized coordinates. If the border mode is specified instead, texture fetches with out-of-range texture coordinates return zero. For normalized coordinates, the wrap mode and the mirror mode are also available. When using the wrap mode, each coordinate x is converted to\nfrac(x)=x - floor(x)\nwhere\nfloor(x)\nis the largest integer not greater than\nx\n. When using the mirror mode, each coordinate\nx\nis converted to\nfrac(x)\nif\nfloor(x)\nis even and\n1-frac(x)\nif\nfloor(x)\nis odd. The addressing mode is specified as an array of size three whose first, second, and third elements specify the addressing mode for the first, second, and third texture coordinates, respectively; the addressing mode are\ncudaAddressModeBorder\n,\ncudaAddressModeClamp\n,\ncudaAddressModeWrap\n, and\ncudaAddressModeMirror\n;\ncudaAddressModeWrap\nand\ncudaAddressModeMirror\nare only supported for normalized texture coordinates\nThe\nfiltering\nmode which specifies how the value returned when fetching the texture is computed based on the input texture coordinates. Linear texture filtering may be done only for textures that are configured to return floating-point data. It performs low-precision interpolation between neighboring texels. When enabled, the texels surrounding a texture fetch location are read and the return value of the texture fetch is interpolated based on where the texture coordinates fell between the texels. Simple linear interpolation is performed for one-dimensional textures, bilinear interpolation for two-dimensional textures, and trilinear interpolation for three-dimensional textures.\nTexture Fetching\ngives more details on texture fetching. The filtering mode is equal to\ncudaFilterModePoint\nor\ncudaFilterModeLinear\n. If it is\ncudaFilterModePoint\n, the returned value is the texel whose texture coordinates are the closest to the input texture coordinates. If it is\ncudaFilterModeLinear\n, the returned value is the linear interpolation of the two (for a one-dimensional texture), four (for a two dimensional texture), or eight (for a three dimensional texture) texels whose texture coordinates are the closest to the input texture coordinates.\ncudaFilterModeLinear\nis only valid for returned values of floating-point type.\nTexture Object API\nintroduces the texture object API.\n16-Bit Floating-Point Textures\nexplains how to deal with 16-bit floating-point textures.\nTextures can also be layered as described in\nLayered Textures\n.\nCubemap Textures\nand\nCubemap Layered Textures\ndescribe a special type of texture, the cubemap texture.\nTexture Gather\ndescribes a special texture fetch, texture gather.\n6.2.14.1.1.\nTexture Object API\nï\nA texture object is created using\ncudaCreateTextureObject()\nfrom a resource description of type\nstruct\ncudaResourceDesc\n, which specifies the texture, and from a texture description defined as such:\nstruct\ncudaTextureDesc\n{\nenum\ncudaTextureAddressMode\naddressMode\n[\n3\n];\nenum\ncudaTextureFilterMode\nfilterMode\n;\nenum\ncudaTextureReadMode\nreadMode\n;\nint\nsRGB\n;\nint\nnormalizedCoords\n;\nunsigned\nint\nmaxAnisotropy\n;\nenum\ncudaTextureFilterMode\nmipmapFilterMode\n;\nfloat\nmipmapLevelBias\n;\nfloat\nminMipmapLevelClamp\n;\nfloat\nmaxMipmapLevelClamp\n;\n};\naddressMode\nspecifies the addressing mode;\nfilterMode\nspecifies the filter mode;\nreadMode\nspecifies the read mode;\nnormalizedCoords\nspecifies whether texture coordinates are normalized or not;\nSee reference manual for\nsRGB\n,\nmaxAnisotropy\n,\nmipmapFilterMode\n,\nmipmapLevelBias\n,\nminMipmapLevelClamp\n, and\nmaxMipmapLevelClamp\n.\nThe following code sample applies some simple transformation kernel to a texture.\n// Simple transformation kernel\n__global__\nvoid\ntransformKernel\n(\nfloat\n*\noutput\n,\ncudaTextureObject_t\ntexObj\n,\nint\nwidth\n,\nint\nheight\n,\nfloat\ntheta\n)\n{\n// Calculate normalized texture coordinates\nunsigned\nint\nx\n=\nblockIdx\n.\nx\n*\nblockDim\n.\nx\n+\nthreadIdx\n.\nx\n;\nunsigned\nint\ny\n=\nblockIdx\n.\ny\n*\nblockDim\n.\ny\n+\nthreadIdx\n.\ny\n;\nfloat\nu\n=\nx\n/\n(\nfloat\n)\nwidth\n;\nfloat\nv\n=\ny\n/\n(\nfloat\n)\nheight\n;\n// Transform coordinates\nu\n-=\n0.5f\n;\nv\n-=\n0.5f\n;\nfloat\ntu\n=\nu\n*\ncosf\n(\ntheta\n)\n-\nv\n*\nsinf\n(\ntheta\n)\n+\n0.5f\n;\nfloat\ntv\n=\nv\n*\ncosf\n(\ntheta\n)\n+\nu\n*\nsinf\n(\ntheta\n)\n+\n0.5f\n;\n// Read from texture and write to global memory\noutput\n[\ny\n*\nwidth\n+\nx\n]\n=\ntex2D\n<\nfloat\n>\n(\ntexObj\n,\ntu\n,\ntv\n);\n}\n// Host code\nint\nmain\n()\n{\nconst\nint\nheight\n=\n1024\n;\nconst\nint\nwidth\n=\n1024\n;\nfloat\nangle\n=\n0.5\n;\n// Allocate and set some host data\nfloat\n*\nh_data\n=\n(\nfloat\n*\n)\nstd\n::\nmalloc\n(\nsizeof\n(\nfloat\n)\n*\nwidth\n*\nheight\n);\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nheight\n*\nwidth\n;\n++\ni\n)\nh_data\n[\ni\n]\n=\ni\n;\n// Allocate CUDA array in device memory\ncudaChannelFormatDesc\nchannelDesc\n=\ncudaCreateChannelDesc\n(\n32\n,\n0\n,\n0\n,\n0\n,\ncudaChannelFormatKindFloat\n);\ncudaArray_t\ncuArray\n;\ncudaMallocArray\n(\n&\ncuArray\n,\n&\nchannelDesc\n,\nwidth\n,\nheight\n);\n// Set pitch of the source (the width in memory in bytes of the 2D array pointed\n// to by src, including padding), we dont have any padding\nconst\nsize_t\nspitch\n=\nwidth\n*\nsizeof\n(\nfloat\n);\n// Copy data located at address h_data in host memory to device memory\ncudaMemcpy2DToArray\n(\ncuArray\n,\n0\n,\n0\n,\nh_data\n,\nspitch\n,\nwidth\n*\nsizeof\n(\nfloat\n),\nheight\n,\ncudaMemcpyHostToDevice\n);\n// Specify texture\nstruct\ncudaResourceDesc\nresDesc\n;\nmemset\n(\n&\nresDesc\n,\n0\n,\nsizeof\n(\nresDesc\n));\nresDesc\n.\nresType\n=\ncudaResourceTypeArray\n;\nresDesc\n.\nres\n.\narray\n.\narray\n=\ncuArray\n;\n// Specify texture object parameters\nstruct\ncudaTextureDesc\ntexDesc\n;\nmemset\n(\n&\ntexDesc\n,\n0\n,\nsizeof\n(\ntexDesc\n));\ntexDesc\n.\naddressMode\n[\n0\n]\n=\ncudaAddressModeWrap\n;\ntexDesc\n.\naddressMode\n[\n1\n]\n=\ncudaAddressModeWrap\n;\ntexDesc\n.\nfilterMode\n=\ncudaFilterModeLinear\n;\ntexDesc\n.\nreadMode\n=\ncudaReadModeElementType\n;\ntexDesc\n.\nnormalizedCoords\n=\n1\n;\n// Create texture object\ncudaTextureObject_t\ntexObj\n=\n0\n;\ncudaCreateTextureObject\n(\n&\ntexObj\n,\n&\nresDesc\n,\n&\ntexDesc\n,\nNULL\n);\n// Allocate result of transformation in device memory\nfloat\n*\noutput\n;\ncudaMalloc\n(\n&\noutput\n,\nwidth\n*\nheight\n*\nsizeof\n(\nfloat\n));\n// Invoke kernel\ndim3\nthreadsperBlock\n(\n16\n,\n16\n);\ndim3\nnumBlocks\n((\nwidth\n+\nthreadsperBlock\n.\nx\n-\n1\n)\n/\nthreadsperBlock\n.\nx\n,\n(\nheight\n+\nthreadsperBlock\n.\ny\n-\n1\n)\n/\nthreadsperBlock\n.\ny\n);\ntransformKernel\n<<<\nnumBlocks\n,\nthreadsperBlock\n>>>\n(\noutput\n,\ntexObj\n,\nwidth\n,\nheight\n,\nangle\n);\n// Copy data from device back to host\ncudaMemcpy\n(\nh_data\n,\noutput\n,\nwidth\n*\nheight\n*\nsizeof\n(\nfloat\n),\ncudaMemcpyDeviceToHost\n);\n// Destroy texture object\ncudaDestroyTextureObject\n(\ntexObj\n);\n// Free device memory\ncudaFreeArray\n(\ncuArray\n);\ncudaFree\n(\noutput\n);\n// Free host memory\nfree\n(\nh_data\n);\nreturn\n0\n;\n}\n6.2.14.1.2.\n16-Bit Floating-Point Textures\nï\nThe 16-bit floating-point or\nhalf\nformat supported by CUDA arrays is the same as the IEEE 754-2008 binary2 format.\nCUDA C++ does not support a matching data type, but provides intrinsic functions to convert to and from the 32-bit floating-point format via the\nunsigned\nshort\ntype:\n__float2half_rn(float)\nand\n__half2float(unsigned\nshort)\n. These functions are only supported in device code. Equivalent functions for the host code can be found in the OpenEXR library, for example.\n16-bit floating-point components are promoted to 32 bit float during texture fetching before any filtering is performed.\nA channel description for the 16-bit floating-point format can be created by calling one of the\ncudaCreateChannelDescHalf*()\nfunctions.\n6.2.14.1.3.\nLayered Textures\nï\nA one-dimensional or two-dimensional layered texture (also known as\ntexture array\nin Direct3D and\narray texture\nin OpenGL) is a texture made up of a sequence of layers, all of which are regular textures of same dimensionality, size, and data type.\nA one-dimensional layered texture is addressed using an integer index and a floating-point texture coordinate; the index denotes a layer within the sequence and the coordinate addresses a texel within that layer. A two-dimensional layered texture is addressed using an integer index and two floating-point texture coordinates; the index denotes a layer within the sequence and the coordinates address a texel within that layer.\nA layered texture can only be a CUDA array by calling\ncudaMalloc3DArray()\nwith the\ncudaArrayLayered\nflag (and a height of zero for one-dimensional layered texture).\nLayered textures are fetched using the device functions described in\ntex1DLayered()\nand\ntex2DLayered()\n. Texture filtering (see\nTexture Fetching\n) is done only within a layer, not across layers.\nLayered textures are only supported on devices of compute capability 2.0 and higher.\n6.2.14.1.4.\nCubemap Textures\nï\nA\ncubemap\ntexture is a special type of two-dimensional layered texture that has six layers representing the faces of a cube:\nThe width of a layer is equal to its height.\nThe cubemap is addressed using three texture coordinates\nx\n,\ny\n, and\nz\nthat are interpreted as a direction vector emanating from the center of the cube and pointing to one face of the cube and a texel within the layer corresponding to that face. More specifically, the face is selected by the coordinate with largest magnitude\nm\nand the corresponding layer is addressed using coordinates\n(s/m+1)/2\nand\n(t/m+1)/2\nwhere\ns\nand\nt\nare defined in\nTable 6\n.\nTable 6\nCubemap Fetch\nï\nface\nm\ns\nt\n|x|\n>\n|y|\nand\n|x|\n>\n|z|\nx â¥ 0\n0\nx\n-z\n-y\nx < 0\n1\n-x\nz\n-y\n|y|\n>\n|x|\nand\n|y|\n>\n|z|\ny â¥ 0\n2\ny\nx\nz\ny < 0\n3\n-y\nx\n-z\n|z|\n>\n|x|\nand\n|z|\n>\n|y|\nz â¥ 0\n4\nz\nx\n-y\nz < 0\n5\n-z\n-x\n-y\nA cubemap texture can only be a CUDA array by calling\ncudaMalloc3DArray()\nwith the\ncudaArrayCubemap\nflag.\nCubemap textures are fetched using the device function described in\ntexCubemap()\n.\nCubemap textures are only supported on devices of compute capability 2.0 and higher.\n6.2.14.1.5.\nCubemap Layered Textures\nï\nA\ncubemap layered\ntexture is a layered texture whose layers are cubemaps of same dimension.\nA cubemap layered texture is addressed using an integer index and three floating-point texture coordinates; the index denotes a cubemap within the sequence and the coordinates address a texel within that cubemap.\nA cubemap layered texture can only be a CUDA array by calling\ncudaMalloc3DArray()\nwith the\ncudaArrayLayered\nand\ncudaArrayCubemap\nflags.\nCubemap layered textures are fetched using the device function described in\ntexCubemapLayered()\n. Texture filtering (see\nTexture Fetching\n) is done only within a layer, not across layers.\nCubemap layered textures are only supported on devices of compute capability 2.0 and higher.\n6.2.14.1.6.\nTexture Gather\nï\nTexture gather is a special texture fetch that is available for two-dimensional textures only. It is performed by the\ntex2Dgather()\nfunction, which has the same parameters as\ntex2D()\n, plus an additional\ncomp\nparameter equal to 0, 1, 2, or 3 (see\ntex2Dgather()\n). It returns four 32-bit numbers that correspond to the value of the component\ncomp\nof each of the four texels that would have been used for bilinear filtering during a regular texture fetch. For example, if these texels are of values (253, 20, 31, 255), (250, 25, 29, 254), (249, 16, 37, 253), (251, 22, 30, 250), and\ncomp\nis 2,\ntex2Dgather()\nreturns (31, 29, 37, 30).\nNote that texture coordinates are computed with only 8 bits of fractional precision.\ntex2Dgather()\nmay therefore return unexpected results for cases where\ntex2D()\nwould use 1.0 for one of its weights (Î± or Î², see\nLinear Filtering\n). For example, with an\nx\ntexture coordinate of 2.49805:\nxB=x-0.5=1.99805\n, however the fractional part of\nxB\nis stored in an 8-bit fixed-point format. Since 0.99805 is closer to 256.f/256.f than it is to 255.f/256.f,\nxB\nhas the value 2. A\ntex2Dgather()\nin this case would therefore return indices 2 and 3 in\nx\n, instead of indices 1 and 2.\nTexture gather is only supported for CUDA arrays created with the\ncudaArrayTextureGather\nflag and of width and height less than the maximum specified in\nTable 27\nfor texture gather, which is smaller than for regular texture fetch.\nTexture gather is only supported on devices of compute capability 2.0 and higher.\n6.2.14.2.\nSurface Memory\nï\nFor devices of compute capability 2.0 and higher, a CUDA array (described in\nCubemap Surfaces\n), created with the\ncudaArraySurfaceLoadStore\nflag, can be read and written via a\nsurface object\nusing the functions described in\nSurface Functions\n.\nTable 27\nlists the maximum surface width, height, and depth depending on the compute capability of the device.\n6.2.14.2.1.\nSurface Object API\nï\nA surface object is created using\ncudaCreateSurfaceObject()\nfrom a resource description of type\nstruct\ncudaResourceDesc\n. Unlike\ntexture memory, surface memory uses byte addressing. This means that the x-coordinate used to access a texture element via texture functions\nneeds to be multiplied by the byte size of the element to access the same element via a surface function. For example, the element at\ntexture coordinate x of a one-dimensional floating-point CUDA array bound to a texture object\ntexObj\nand a surface object\nsurfObj\nis read using\ntex1d(texObj,\nx)\nvia\ntexObj\n, but\nsurf1Dread(surfObj,\n4*x)\nvia\nsurfObj\n. Similarly, the element at texture\ncoordinate x and y of a two-dimensional floating-point CUDA array bound to a texture object\ntexObj\nand a surface object\nsurfObj\nis accessed using\ntex2d(texObj,\nx,\ny)\nvia\ntexObj\n, but\nsurf2Dread(surfObj,\n4*x,\ny)\nvia\nsurObj\n(the byte offset of the\ny-coordinate is internally calculated from the underlying line pitch of the CUDA array).\nThe following code sample applies some simple transformation kernel to a surface.\n// Simple copy kernel\n__global__\nvoid\ncopyKernel\n(\ncudaSurfaceObject_t\ninputSurfObj\n,\ncudaSurfaceObject_t\noutputSurfObj\n,\nint\nwidth\n,\nint\nheight\n)\n{\n// Calculate surface coordinates\nunsigned\nint\nx\n=\nblockIdx\n.\nx\n*\nblockDim\n.\nx\n+\nthreadIdx\n.\nx\n;\nunsigned\nint\ny\n=\nblockIdx\n.\ny\n*\nblockDim\n.\ny\n+\nthreadIdx\n.\ny\n;\nif\n(\nx\n<\nwidth\n&&\ny\n<\nheight\n)\n{\nuchar4\ndata\n;\n// Read from input surface\nsurf2Dread\n(\n&\ndata\n,\ninputSurfObj\n,\nx\n*\n4\n,\ny\n);\n// Write to output surface\nsurf2Dwrite\n(\ndata\n,\noutputSurfObj\n,\nx\n*\n4\n,\ny\n);\n}\n}\n// Host code\nint\nmain\n()\n{\nconst\nint\nheight\n=\n1024\n;\nconst\nint\nwidth\n=\n1024\n;\n// Allocate and set some host data\nunsigned\nchar\n*\nh_data\n=\n(\nunsigned\nchar\n*\n)\nstd\n::\nmalloc\n(\nsizeof\n(\nunsigned\nchar\n)\n*\nwidth\n*\nheight\n*\n4\n);\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nheight\n*\nwidth\n*\n4\n;\n++\ni\n)\nh_data\n[\ni\n]\n=\ni\n;\n// Allocate CUDA arrays in device memory\ncudaChannelFormatDesc\nchannelDesc\n=\ncudaCreateChannelDesc\n(\n8\n,\n8\n,\n8\n,\n8\n,\ncudaChannelFormatKindUnsigned\n);\ncudaArray_t\ncuInputArray\n;\ncudaMallocArray\n(\n&\ncuInputArray\n,\n&\nchannelDesc\n,\nwidth\n,\nheight\n,\ncudaArraySurfaceLoadStore\n);\ncudaArray_t\ncuOutputArray\n;\ncudaMallocArray\n(\n&\ncuOutputArray\n,\n&\nchannelDesc\n,\nwidth\n,\nheight\n,\ncudaArraySurfaceLoadStore\n);\n// Set pitch of the source (the width in memory in bytes of the 2D array\n// pointed to by src, including padding), we dont have any padding\nconst\nsize_t\nspitch\n=\n4\n*\nwidth\n*\nsizeof\n(\nunsigned\nchar\n);\n// Copy data located at address h_data in host memory to device memory\ncudaMemcpy2DToArray\n(\ncuInputArray\n,\n0\n,\n0\n,\nh_data\n,\nspitch\n,\n4\n*\nwidth\n*\nsizeof\n(\nunsigned\nchar\n),\nheight\n,\ncudaMemcpyHostToDevice\n);\n// Specify surface\nstruct\ncudaResourceDesc\nresDesc\n;\nmemset\n(\n&\nresDesc\n,\n0\n,\nsizeof\n(\nresDesc\n));\nresDesc\n.\nresType\n=\ncudaResourceTypeArray\n;\n// Create the surface objects\nresDesc\n.\nres\n.\narray\n.\narray\n=\ncuInputArray\n;\ncudaSurfaceObject_t\ninputSurfObj\n=\n0\n;\ncudaCreateSurfaceObject\n(\n&\ninputSurfObj\n,\n&\nresDesc\n);\nresDesc\n.\nres\n.\narray\n.\narray\n=\ncuOutputArray\n;\ncudaSurfaceObject_t\noutputSurfObj\n=\n0\n;\ncudaCreateSurfaceObject\n(\n&\noutputSurfObj\n,\n&\nresDesc\n);\n// Invoke kernel\ndim3\nthreadsperBlock\n(\n16\n,\n16\n);\ndim3\nnumBlocks\n((\nwidth\n+\nthreadsperBlock\n.\nx\n-\n1\n)\n/\nthreadsperBlock\n.\nx\n,\n(\nheight\n+\nthreadsperBlock\n.\ny\n-\n1\n)\n/\nthreadsperBlock\n.\ny\n);\ncopyKernel\n<<<\nnumBlocks\n,\nthreadsperBlock\n>>>\n(\ninputSurfObj\n,\noutputSurfObj\n,\nwidth\n,\nheight\n);\n// Copy data from device back to host\ncudaMemcpy2DFromArray\n(\nh_data\n,\nspitch\n,\ncuOutputArray\n,\n0\n,\n0\n,\n4\n*\nwidth\n*\nsizeof\n(\nunsigned\nchar\n),\nheight\n,\ncudaMemcpyDeviceToHost\n);\n// Destroy surface objects\ncudaDestroySurfaceObject\n(\ninputSurfObj\n);\ncudaDestroySurfaceObject\n(\noutputSurfObj\n);\n// Free device memory\ncudaFreeArray\n(\ncuInputArray\n);\ncudaFreeArray\n(\ncuOutputArray\n);\n// Free host memory\nfree\n(\nh_data\n);\nreturn\n0\n;\n}\n6.2.14.2.2.\nCubemap Surfaces\nï\nCubemap surfaces are accessed using\nsurfCubemapread()\nand\nsurfCubemapwrite()\n(\nsurfCubemapread()\nand\nsurfCubemapwrite()\n) as a two-dimensional layered surface, i.e., using an integer index denoting a face and two floating-point texture coordinates addressing a texel within the layer corresponding to this face. Faces are ordered as indicated in\nTable 6\n.\n6.2.14.2.3.\nCubemap Layered Surfaces\nï\nCubemap layered surfaces are accessed using\nsurfCubemapLayeredread()\nand\nsurfCubemapLayeredwrite()\n(\nsurfCubemapLayeredread()\nand\nsurfCubemapLayeredwrite()\n) as a two-dimensional layered surface, i.e., using an integer index denoting a face of one of the cubemaps and two floating-point texture coordinates addressing a texel within the layer corresponding to this face. Faces are ordered as indicated in\nTable 6\n, so index ((2 * 6) + 3), for example, accesses the fourth face of the third cubemap.\n6.2.14.3.\nCUDA Arrays\nï\nCUDA arrays are opaque memory layouts optimized for texture fetching. They are one dimensional, two dimensional, or three-dimensional and composed of elements, each of which has 1, 2 or 4 components that may be signed or unsigned 8-, 16-, or 32-bit integers, 16-bit floats, or 32-bit floats. CUDA arrays are only accessible by kernels through texture fetching as described in\nTexture Memory\nor surface reading and writing as described in\nSurface Memory\n.\n6.2.14.4.\nRead/Write Coherency\nï\nThe texture and surface memory is cached (see\nDevice Memory Accesses\n) and within the same kernel call, the cache is not kept coherent with respect to global memory writes and surface memory writes, so any texture fetch or surface read to an address that has been written to via a global write or a surface write in the same kernel call returns undefined data. In other words, a thread can safely read some texture or surface memory location only if this memory location has been updated by a previous kernel call or memory copy, but not if it has been previously updated by the same thread or another thread from the same kernel call.\n6.2.15.\nGraphics Interoperability\nï\nSome resources from OpenGL and Direct3D may be mapped into the address space of CUDA, either to enable CUDA to read data written by OpenGL or Direct3D, or to enable CUDA to write data for consumption by OpenGL or Direct3D.\nA resource must be registered to CUDA before it can be mapped using the functions mentioned in\nOpenGL Interoperability\nand\nDirect3D Interoperability\n. These functions return a pointer to a CUDA graphics resource of type\nstruct\ncudaGraphicsResource\n. Registering a resource is potentially high-overhead and therefore typically called only once per resource. A CUDA graphics resource is unregistered using\ncudaGraphicsUnregisterResource()\n. Each CUDA context which intends to use the resource is required to register it separately.\nOnce a resource is registered to CUDA, it can be mapped and unmapped as many times as necessary using\ncudaGraphicsMapResources()\nand\ncudaGraphicsUnmapResources()\n.\ncudaGraphicsResourceSetMapFlags()\ncan be called to specify usage hints (write-only, read-only) that the CUDA driver can use to optimize resource management.\nA mapped resource can be read from or written to by kernels using the device memory address returned by\ncudaGraphicsResourceGetMappedPointer()\nfor buffers and\ncudaGraphicsSubResourceGetMappedArray()\nfor CUDA arrays.\nAccessing a resource through OpenGL, Direct3D, or another CUDA context while it is mapped produces undefined results.\nOpenGL Interoperability\nand\nDirect3D Interoperability\ngive specifics for each graphics API and some code samples.\nSLI Interoperability\ngives specifics for when the system is in SLI mode.\n6.2.15.1.\nOpenGL Interoperability\nï\nThe OpenGL resources that may be mapped into the address space of CUDA are OpenGL buffer, texture, and renderbuffer objects.\nA buffer object is registered using\ncudaGraphicsGLRegisterBuffer()\n. In CUDA, it appears as a device pointer and can therefore be read and written by kernels or via\ncudaMemcpy()\ncalls.\nA texture or renderbuffer object is registered using\ncudaGraphicsGLRegisterImage()\n. In CUDA, it appears as a CUDA array. Kernels can read from the array by binding it to a texture or surface reference. They can also write to it via the surface write functions if the resource has been registered with the\ncudaGraphicsRegisterFlagsSurfaceLoadStore\nflag. The array can also be read and written via\ncudaMemcpy2D()\ncalls.\ncudaGraphicsGLRegisterImage()\nsupports all texture formats with 1, 2, or 4 components and an internal type of float (for example,\nGL_RGBA_FLOAT32\n), normalized integer (for example,\nGL_RGBA8,\nGL_INTENSITY16\n), and unnormalized integer (for example,\nGL_RGBA8UI\n) (please note that since unnormalized integer formats require OpenGL 3.0, they can only be written by shaders, not the fixed function pipeline).\nThe OpenGL context whose resources are being shared has to be current to the host thread making any OpenGL interoperability API calls.\nPlease note: When an OpenGL texture is made bindless (say for example by requesting an image or texture handle using the\nglGetTextureHandle\n*/\nglGetImageHandle\n* APIs) it cannot be registered with CUDA. The application needs to register the texture for interop before requesting an image or texture handle.\nThe following code sample uses a kernel to dynamically modify a 2D\nwidth\nx\nheight\ngrid of vertices stored in a vertex buffer object:\nGLuint\npositionsVBO\n;\nstruct\ncudaGraphicsResource\n*\npositionsVBO_CUDA\n;\nint\nmain\n()\n{\n// Initialize OpenGL and GLUT for device 0\n// and make the OpenGL context current\n...\nglutDisplayFunc\n(\ndisplay\n);\n// Explicitly set device 0\ncudaSetDevice\n(\n0\n);\n// Create buffer object and register it with CUDA\nglGenBuffers\n(\n1\n,\n&\npositionsVBO\n);\nglBindBuffer\n(\nGL_ARRAY_BUFFER\n,\npositionsVBO\n);\nunsigned\nint\nsize\n=\nwidth\n*\nheight\n*\n4\n*\nsizeof\n(\nfloat\n);\nglBufferData\n(\nGL_ARRAY_BUFFER\n,\nsize\n,\n0\n,\nGL_DYNAMIC_DRAW\n);\nglBindBuffer\n(\nGL_ARRAY_BUFFER\n,\n0\n);\ncudaGraphicsGLRegisterBuffer\n(\n&\npositionsVBO_CUDA\n,\npositionsVBO\n,\ncudaGraphicsMapFlagsWriteDiscard\n);\n// Launch rendering loop\nglutMainLoop\n();\n...\n}\nvoid\ndisplay\n()\n{\n// Map buffer object for writing from CUDA\nfloat4\n*\npositions\n;\ncudaGraphicsMapResources\n(\n1\n,\n&\npositionsVBO_CUDA\n,\n0\n);\nsize_t\nnum_bytes\n;\ncudaGraphicsResourceGetMappedPointer\n((\nvoid\n**\n)\n&\npositions\n,\n&\nnum_bytes\n,\npositionsVBO_CUDA\n));\n// Execute kernel\ndim3\ndimBlock\n(\n16\n,\n16\n,\n1\n);\ndim3\ndimGrid\n(\nwidth\n/\ndimBlock\n.\nx\n,\nheight\n/\ndimBlock\n.\ny\n,\n1\n);\ncreateVertices\n<<<\ndimGrid\n,\ndimBlock\n>>>\n(\npositions\n,\ntime\n,\nwidth\n,\nheight\n);\n// Unmap buffer object\ncudaGraphicsUnmapResources\n(\n1\n,\n&\npositionsVBO_CUDA\n,\n0\n);\n// Render from buffer object\nglClear\n(\nGL_COLOR_BUFFER_BIT\n|\nGL_DEPTH_BUFFER_BIT\n);\nglBindBuffer\n(\nGL_ARRAY_BUFFER\n,\npositionsVBO\n);\nglVertexPointer\n(\n4\n,\nGL_FLOAT\n,\n0\n,\n0\n);\nglEnableClientState\n(\nGL_VERTEX_ARRAY\n);\nglDrawArrays\n(\nGL_POINTS\n,\n0\n,\nwidth\n*\nheight\n);\nglDisableClientState\n(\nGL_VERTEX_ARRAY\n);\n// Swap buffers\nglutSwapBuffers\n();\nglutPostRedisplay\n();\n}\nvoid\ndeleteVBO\n()\n{\ncudaGraphicsUnregisterResource\n(\npositionsVBO_CUDA\n);\nglDeleteBuffers\n(\n1\n,\n&\npositionsVBO\n);\n}\n__global__\nvoid\ncreateVertices\n(\nfloat4\n*\npositions\n,\nfloat\ntime\n,\nunsigned\nint\nwidth\n,\nunsigned\nint\nheight\n)\n{\nunsigned\nint\nx\n=\nblockIdx\n.\nx\n*\nblockDim\n.\nx\n+\nthreadIdx\n.\nx\n;\nunsigned\nint\ny\n=\nblockIdx\n.\ny\n*\nblockDim\n.\ny\n+\nthreadIdx\n.\ny\n;\n// Calculate uv coordinates\nfloat\nu\n=\nx\n/\n(\nfloat\n)\nwidth\n;\nfloat\nv\n=\ny\n/\n(\nfloat\n)\nheight\n;\nu\n=\nu\n*\n2.0f\n-\n1.0f\n;\nv\n=\nv\n*\n2.0f\n-\n1.0f\n;\n// calculate simple sine wave pattern\nfloat\nfreq\n=\n4.0f\n;\nfloat\nw\n=\nsinf\n(\nu\n*\nfreq\n+\ntime\n)\n*\ncosf\n(\nv\n*\nfreq\n+\ntime\n)\n*\n0.5f\n;\n// Write positions\npositions\n[\ny\n*\nwidth\n+\nx\n]\n=\nmake_float4\n(\nu\n,\nw\n,\nv\n,\n1.0f\n);\n}\nOn Windows and for Quadro GPUs,\ncudaWGLGetDevice()\ncan be used to retrieve the CUDA device associated to the handle returned by\nwglEnumGpusNV()\n. Quadro GPUs offer higher performance OpenGL interoperability than GeForce and Tesla GPUs in a multi-GPU configuration where OpenGL rendering is performed on the Quadro GPU and CUDA computations are performed on other GPUs in the system.\n6.2.15.2.\nDirect3D Interoperability\nï\nDirect3D interoperability is supported for Direct3D 9Ex, Direct3D 10, and Direct3D 11.\nA CUDA context may interoperate only with Direct3D devices that fulfill the following criteria: Direct3D 9Ex devices must be created with\nDeviceType\nset to\nD3DDEVTYPE_HAL\nand\nBehaviorFlags\nwith the\nD3DCREATE_HARDWARE_VERTEXPROCESSING\nflag; Direct3D 10 and Direct3D 11 devices must be created with\nDriverType\nset to\nD3D_DRIVER_TYPE_HARDWARE\n.\nThe Direct3D resources that may be mapped into the address space of CUDA are Direct3D buffers, textures, and surfaces. These resources are registered using\ncudaGraphicsD3D9RegisterResource()\n,\ncudaGraphicsD3D10RegisterResource()\n, and\ncudaGraphicsD3D11RegisterResource()\n.\nThe following code sample uses a kernel to dynamically modify a 2D\nwidth\nx\nheight\ngrid of vertices stored in a vertex buffer object.\n6.2.15.2.1.\nDirect3D 9 Version\nï\nIDirect3D9\n*\nD3D\n;\nIDirect3DDevice9\n*\ndevice\n;\nstruct\nCUSTOMVERTEX\n{\nFLOAT\nx\n,\ny\n,\nz\n;\nDWORD\ncolor\n;\n};\nIDirect3DVertexBuffer9\n*\npositionsVB\n;\nstruct\ncudaGraphicsResource\n*\npositionsVB_CUDA\n;\nint\nmain\n()\n{\nint\ndev\n;\n// Initialize Direct3D\nD3D\n=\nDirect3DCreate9Ex\n(\nD3D_SDK_VERSION\n);\n// Get a CUDA-enabled adapter\nunsigned\nint\nadapter\n=\n0\n;\nfor\n(;\nadapter\n<\ng_pD3D\n->\nGetAdapterCount\n();\nadapter\n++\n)\n{\nD3DADAPTER_IDENTIFIER9\nadapterId\n;\ng_pD3D\n->\nGetAdapterIdentifier\n(\nadapter\n,\n0\n,\n&\nadapterId\n);\nif\n(\ncudaD3D9GetDevice\n(\n&\ndev\n,\nadapterId\n.\nDeviceName\n)\n==\ncudaSuccess\n)\nbreak\n;\n}\n// Create device\n...\nD3D\n->\nCreateDeviceEx\n(\nadapter\n,\nD3DDEVTYPE_HAL\n,\nhWnd\n,\nD3DCREATE_HARDWARE_VERTEXPROCESSING\n,\n&\nparams\n,\nNULL\n,\n&\ndevice\n);\n// Use the same device\ncudaSetDevice\n(\ndev\n);\n// Create vertex buffer and register it with CUDA\nunsigned\nint\nsize\n=\nwidth\n*\nheight\n*\nsizeof\n(\nCUSTOMVERTEX\n);\ndevice\n->\nCreateVertexBuffer\n(\nsize\n,\n0\n,\nD3DFVF_CUSTOMVERTEX\n,\nD3DPOOL_DEFAULT\n,\n&\npositionsVB\n,\n0\n);\ncudaGraphicsD3D9RegisterResource\n(\n&\npositionsVB_CUDA\n,\npositionsVB\n,\ncudaGraphicsRegisterFlagsNone\n);\ncudaGraphicsResourceSetMapFlags\n(\npositionsVB_CUDA\n,\ncudaGraphicsMapFlagsWriteDiscard\n);\n// Launch rendering loop\nwhile\n(...)\n{\n...\nRender\n();\n...\n}\n...\n}\nvoid\nRender\n()\n{\n// Map vertex buffer for writing from CUDA\nfloat4\n*\npositions\n;\ncudaGraphicsMapResources\n(\n1\n,\n&\npositionsVB_CUDA\n,\n0\n);\nsize_t\nnum_bytes\n;\ncudaGraphicsResourceGetMappedPointer\n((\nvoid\n**\n)\n&\npositions\n,\n&\nnum_bytes\n,\npositionsVB_CUDA\n));\n// Execute kernel\ndim3\ndimBlock\n(\n16\n,\n16\n,\n1\n);\ndim3\ndimGrid\n(\nwidth\n/\ndimBlock\n.\nx\n,\nheight\n/\ndimBlock\n.\ny\n,\n1\n);\ncreateVertices\n<<<\ndimGrid\n,\ndimBlock\n>>>\n(\npositions\n,\ntime\n,\nwidth\n,\nheight\n);\n// Unmap vertex buffer\ncudaGraphicsUnmapResources\n(\n1\n,\n&\npositionsVB_CUDA\n,\n0\n);\n// Draw and present\n...\n}\nvoid\nreleaseVB\n()\n{\ncudaGraphicsUnregisterResource\n(\npositionsVB_CUDA\n);\npositionsVB\n->\nRelease\n();\n}\n__global__\nvoid\ncreateVertices\n(\nfloat4\n*\npositions\n,\nfloat\ntime\n,\nunsigned\nint\nwidth\n,\nunsigned\nint\nheight\n)\n{\nunsigned\nint\nx\n=\nblockIdx\n.\nx\n*\nblockDim\n.\nx\n+\nthreadIdx\n.\nx\n;\nunsigned\nint\ny\n=\nblockIdx\n.\ny\n*\nblockDim\n.\ny\n+\nthreadIdx\n.\ny\n;\n// Calculate uv coordinates\nfloat\nu\n=\nx\n/\n(\nfloat\n)\nwidth\n;\nfloat\nv\n=\ny\n/\n(\nfloat\n)\nheight\n;\nu\n=\nu\n*\n2.0f\n-\n1.0f\n;\nv\n=\nv\n*\n2.0f\n-\n1.0f\n;\n// Calculate simple sine wave pattern\nfloat\nfreq\n=\n4.0f\n;\nfloat\nw\n=\nsinf\n(\nu\n*\nfreq\n+\ntime\n)\n*\ncosf\n(\nv\n*\nfreq\n+\ntime\n)\n*\n0.5f\n;\n// Write positions\npositions\n[\ny\n*\nwidth\n+\nx\n]\n=\nmake_float4\n(\nu\n,\nw\n,\nv\n,\n__int_as_float\n(\n0xff00ff00\n));\n}\n6.2.15.2.2.\nDirect3D 10 Version\nï\nID3D10Device\n*\ndevice\n;\nstruct\nCUSTOMVERTEX\n{\nFLOAT\nx\n,\ny\n,\nz\n;\nDWORD\ncolor\n;\n};\nID3D10Buffer\n*\npositionsVB\n;\nstruct\ncudaGraphicsResource\n*\npositionsVB_CUDA\n;\nint\nmain\n()\n{\nint\ndev\n;\n// Get a CUDA-enabled adapter\nIDXGIFactory\n*\nfactory\n;\nCreateDXGIFactory\n(\n__uuidof\n(\nIDXGIFactory\n),\n(\nvoid\n**\n)\n&\nfactory\n);\nIDXGIAdapter\n*\nadapter\n=\n0\n;\nfor\n(\nunsigned\nint\ni\n=\n0\n;\n!\nadapter\n;\n++\ni\n)\n{\nif\n(\nFAILED\n(\nfactory\n->\nEnumAdapters\n(\ni\n,\n&\nadapter\n))\nbreak\n;\nif\n(\ncudaD3D10GetDevice\n(\n&\ndev\n,\nadapter\n)\n==\ncudaSuccess\n)\nbreak\n;\nadapter\n->\nRelease\n();\n}\nfactory\n->\nRelease\n();\n// Create swap chain and device\n...\nD3D10CreateDeviceAndSwapChain\n(\nadapter\n,\nD3D10_DRIVER_TYPE_HARDWARE\n,\n0\n,\nD3D10_CREATE_DEVICE_DEBUG\n,\nD3D10_SDK_VERSION\n,\n&\nswapChainDesc\n,\n&\nswapChain\n,\n&\ndevice\n);\nadapter\n->\nRelease\n();\n// Use the same device\ncudaSetDevice\n(\ndev\n);\n// Create vertex buffer and register it with CUDA\nunsigned\nint\nsize\n=\nwidth\n*\nheight\n*\nsizeof\n(\nCUSTOMVERTEX\n);\nD3D10_BUFFER_DESC\nbufferDesc\n;\nbufferDesc\n.\nUsage\n=\nD3D10_USAGE_DEFAULT\n;\nbufferDesc\n.\nByteWidth\n=\nsize\n;\nbufferDesc\n.\nBindFlags\n=\nD3D10_BIND_VERTEX_BUFFER\n;\nbufferDesc\n.\nCPUAccessFlags\n=\n0\n;\nbufferDesc\n.\nMiscFlags\n=\n0\n;\ndevice\n->\nCreateBuffer\n(\n&\nbufferDesc\n,\n0\n,\n&\npositionsVB\n);\ncudaGraphicsD3D10RegisterResource\n(\n&\npositionsVB_CUDA\n,\npositionsVB\n,\ncudaGraphicsRegisterFlagsNone\n);\ncudaGraphicsResourceSetMapFlags\n(\npositionsVB_CUDA\n,\ncudaGraphicsMapFlagsWriteDiscard\n);\n// Launch rendering loop\nwhile\n(...)\n{\n...\nRender\n();\n...\n}\n...\n}\nvoid\nRender\n()\n{\n// Map vertex buffer for writing from CUDA\nfloat4\n*\npositions\n;\ncudaGraphicsMapResources\n(\n1\n,\n&\npositionsVB_CUDA\n,\n0\n);\nsize_t\nnum_bytes\n;\ncudaGraphicsResourceGetMappedPointer\n((\nvoid\n**\n)\n&\npositions\n,\n&\nnum_bytes\n,\npositionsVB_CUDA\n));\n// Execute kernel\ndim3\ndimBlock\n(\n16\n,\n16\n,\n1\n);\ndim3\ndimGrid\n(\nwidth\n/\ndimBlock\n.\nx\n,\nheight\n/\ndimBlock\n.\ny\n,\n1\n);\ncreateVertices\n<<<\ndimGrid\n,\ndimBlock\n>>>\n(\npositions\n,\ntime\n,\nwidth\n,\nheight\n);\n// Unmap vertex buffer\ncudaGraphicsUnmapResources\n(\n1\n,\n&\npositionsVB_CUDA\n,\n0\n);\n// Draw and present\n...\n}\nvoid\nreleaseVB\n()\n{\ncudaGraphicsUnregisterResource\n(\npositionsVB_CUDA\n);\npositionsVB\n->\nRelease\n();\n}\n__global__\nvoid\ncreateVertices\n(\nfloat4\n*\npositions\n,\nfloat\ntime\n,\nunsigned\nint\nwidth\n,\nunsigned\nint\nheight\n)\n{\nunsigned\nint\nx\n=\nblockIdx\n.\nx\n*\nblockDim\n.\nx\n+\nthreadIdx\n.\nx\n;\nunsigned\nint\ny\n=\nblockIdx\n.\ny\n*\nblockDim\n.\ny\n+\nthreadIdx\n.\ny\n;\n// Calculate uv coordinates\nfloat\nu\n=\nx\n/\n(\nfloat\n)\nwidth\n;\nfloat\nv\n=\ny\n/\n(\nfloat\n)\nheight\n;\nu\n=\nu\n*\n2.0f\n-\n1.0f\n;\nv\n=\nv\n*\n2.0f\n-\n1.0f\n;\n// Calculate simple sine wave pattern\nfloat\nfreq\n=\n4.0f\n;\nfloat\nw\n=\nsinf\n(\nu\n*\nfreq\n+\ntime\n)\n*\ncosf\n(\nv\n*\nfreq\n+\ntime\n)\n*\n0.5f\n;\n// Write positions\npositions\n[\ny\n*\nwidth\n+\nx\n]\n=\nmake_float4\n(\nu\n,\nw\n,\nv\n,\n__int_as_float\n(\n0xff00ff00\n));\n}\n6.2.15.2.3.\nDirect3D 11 Version\nï\nID3D11Device\n*\ndevice\n;\nstruct\nCUSTOMVERTEX\n{\nFLOAT\nx\n,\ny\n,\nz\n;\nDWORD\ncolor\n;\n};\nID3D11Buffer\n*\npositionsVB\n;\nstruct\ncudaGraphicsResource\n*\npositionsVB_CUDA\n;\nint\nmain\n()\n{\nint\ndev\n;\n// Get a CUDA-enabled adapter\nIDXGIFactory\n*\nfactory\n;\nCreateDXGIFactory\n(\n__uuidof\n(\nIDXGIFactory\n),\n(\nvoid\n**\n)\n&\nfactory\n);\nIDXGIAdapter\n*\nadapter\n=\n0\n;\nfor\n(\nunsigned\nint\ni\n=\n0\n;\n!\nadapter\n;\n++\ni\n)\n{\nif\n(\nFAILED\n(\nfactory\n->\nEnumAdapters\n(\ni\n,\n&\nadapter\n))\nbreak\n;\nif\n(\ncudaD3D11GetDevice\n(\n&\ndev\n,\nadapter\n)\n==\ncudaSuccess\n)\nbreak\n;\nadapter\n->\nRelease\n();\n}\nfactory\n->\nRelease\n();\n// Create swap chain and device\n...\nsFnPtr_D3D11CreateDeviceAndSwapChain\n(\nadapter\n,\nD3D11_DRIVER_TYPE_HARDWARE\n,\n0\n,\nD3D11_CREATE_DEVICE_DEBUG\n,\nfeatureLevels\n,\n3\n,\nD3D11_SDK_VERSION\n,\n&\nswapChainDesc\n,\n&\nswapChain\n,\n&\ndevice\n,\n&\nfeatureLevel\n,\n&\ndeviceContext\n);\nadapter\n->\nRelease\n();\n// Use the same device\ncudaSetDevice\n(\ndev\n);\n// Create vertex buffer and register it with CUDA\nunsigned\nint\nsize\n=\nwidth\n*\nheight\n*\nsizeof\n(\nCUSTOMVERTEX\n);\nD3D11_BUFFER_DESC\nbufferDesc\n;\nbufferDesc\n.\nUsage\n=\nD3D11_USAGE_DEFAULT\n;\nbufferDesc\n.\nByteWidth\n=\nsize\n;\nbufferDesc\n.\nBindFlags\n=\nD3D11_BIND_VERTEX_BUFFER\n;\nbufferDesc\n.\nCPUAccessFlags\n=\n0\n;\nbufferDesc\n.\nMiscFlags\n=\n0\n;\ndevice\n->\nCreateBuffer\n(\n&\nbufferDesc\n,\n0\n,\n&\npositionsVB\n);\ncudaGraphicsD3D11RegisterResource\n(\n&\npositionsVB_CUDA\n,\npositionsVB\n,\ncudaGraphicsRegisterFlagsNone\n);\ncudaGraphicsResourceSetMapFlags\n(\npositionsVB_CUDA\n,\ncudaGraphicsMapFlagsWriteDiscard\n);\n// Launch rendering loop\nwhile\n(...)\n{\n...\nRender\n();\n...\n}\n...\n}\nvoid\nRender\n()\n{\n// Map vertex buffer for writing from CUDA\nfloat4\n*\npositions\n;\ncudaGraphicsMapResources\n(\n1\n,\n&\npositionsVB_CUDA\n,\n0\n);\nsize_t\nnum_bytes\n;\ncudaGraphicsResourceGetMappedPointer\n((\nvoid\n**\n)\n&\npositions\n,\n&\nnum_bytes\n,\npositionsVB_CUDA\n));\n// Execute kernel\ndim3\ndimBlock\n(\n16\n,\n16\n,\n1\n);\ndim3\ndimGrid\n(\nwidth\n/\ndimBlock\n.\nx\n,\nheight\n/\ndimBlock\n.\ny\n,\n1\n);\ncreateVertices\n<<<\ndimGrid\n,\ndimBlock\n>>>\n(\npositions\n,\ntime\n,\nwidth\n,\nheight\n);\n// Unmap vertex buffer\ncudaGraphicsUnmapResources\n(\n1\n,\n&\npositionsVB_CUDA\n,\n0\n);\n// Draw and present\n...\n}\nvoid\nreleaseVB\n()\n{\ncudaGraphicsUnregisterResource\n(\npositionsVB_CUDA\n);\npositionsVB\n->\nRelease\n();\n}\n__global__\nvoid\ncreateVertices\n(\nfloat4\n*\npositions\n,\nfloat\ntime\n,\nunsigned\nint\nwidth\n,\nunsigned\nint\nheight\n)\n{\nunsigned\nint\nx\n=\nblockIdx\n.\nx\n*\nblockDim\n.\nx\n+\nthreadIdx\n.\nx\n;\nunsigned\nint\ny\n=\nblockIdx\n.\ny\n*\nblockDim\n.\ny\n+\nthreadIdx\n.\ny\n;\n// Calculate uv coordinates\nfloat\nu\n=\nx\n/\n(\nfloat\n)\nwidth\n;\nfloat\nv\n=\ny\n/\n(\nfloat\n)\nheight\n;\nu\n=\nu\n*\n2.0f\n-\n1.0f\n;\nv\n=\nv\n*\n2.0f\n-\n1.0f\n;\n// Calculate simple sine wave pattern\nfloat\nfreq\n=\n4.0f\n;\nfloat\nw\n=\nsinf\n(\nu\n*\nfreq\n+\ntime\n)\n*\ncosf\n(\nv\n*\nfreq\n+\ntime\n)\n*\n0.5f\n;\n// Write positions\npositions\n[\ny\n*\nwidth\n+\nx\n]\n=\nmake_float4\n(\nu\n,\nw\n,\nv\n,\n__int_as_float\n(\n0xff00ff00\n));\n}\n6.2.15.3.\nSLI Interoperability\nï\nIn a system with multiple GPUs, all CUDA-enabled GPUs are accessible via the CUDA driver and runtime as separate devices. There are however special considerations as described below when the system is in SLI mode.\nFirst, an allocation in one CUDA device on one GPU will consume memory on other GPUs that are part of the SLI configuration of the Direct3D or OpenGL device. Because of this, allocations may fail earlier than otherwise expected.\nSecond, applications should create multiple CUDA contexts, one for each GPU in the SLI configuration. While this is not a strict requirement, it avoids unnecessary data transfers between devices. The application can use the\ncudaD3D[9|10|11]GetDevices()\nfor Direct3D and\ncudaGLGetDevices()\nfor OpenGL set of calls to identify the CUDA device handle(s) for the device(s) that are performing the rendering in the current and next frame. Given this information the application will typically choose the appropriate device and map Direct3D or OpenGL resources to the CUDA device returned by\ncudaD3D[9|10|11]GetDevices()\nor\ncudaGLGetDevices()\nwhen the\ndeviceList\nparameter is set to\ncudaD3D[9|10|11]DeviceListCurrentFrame\nor\ncudaGLDeviceListCurrentFrame\n.\nPlease note that resource returned from\ncudaGraphicsD9D[9|10|11]RegisterResource\nand\ncudaGraphicsGLRegister[Buffer|Image]\nmust be only used on device the registration happened. Therefore on SLI configurations when data for different frames is computed on different CUDA devices it is necessary to register the resources for each separately.\nSee\nDirect3D Interoperability\nand\nOpenGL Interoperability\nfor details on how the CUDA runtime interoperate with Direct3D and OpenGL, respectively.\n6.2.16.\nExternal Resource Interoperability\nï\nExternal resource interoperability allows CUDA to import certain resources that are explicitly exported by other APIs. These objects are typically exported by other APIs using handles native to the Operating System, like file descriptors on Linux or NT handles on Windows. They could also be exported using other unified interfaces such as the NVIDIA Software Communication Interface. There are two types of resources that can be imported: memory objects and synchronization objects.\nMemory objects can be imported into CUDA using\ncudaImportExternalMemory()\n. An imported memory object can be accessed from within kernels using device pointers mapped onto the memory object via\ncudaExternalMemoryGetMappedBuffer()\nor CUDA mipmapped arrays mapped via\ncudaExternalMemoryGetMappedMipmappedArray()\n. Depending on the type of memory object, it may be possible for more than one mapping to be setup on a single memory object. The mappings must match the mappings setup in the exporting API. Any mismatched mappings result in undefined behavior. Imported memory objects must be freed using\ncudaDestroyExternalMemory()\n. Freeing a memory object does not free any mappings to that object. Therefore, any device pointers mapped onto that object must be explicitly freed using\ncudaFree()\nand any CUDA mipmapped arrays mapped onto that object must be explicitly freed using\ncudaFreeMipmappedArray()\n. It is illegal to access mappings to an object after it has been destroyed.\nSynchronization objects can be imported into CUDA using\ncudaImportExternalSemaphore()\n. An imported synchronization object can then be signaled using\ncudaSignalExternalSemaphoresAsync()\nand waited on using\ncudaWaitExternalSemaphoresAsync()\n. It is illegal to issue a wait before the corresponding signal has been issued. Also, depending on the type of the imported synchronization object, there may be additional constraints imposed on how they can be signaled and waited on, as described in subsequent sections. Imported semaphore objects must be freed using\ncudaDestroyExternalSemaphore()\n. All outstanding signals and waits must have completed before the semaphore object is destroyed.\n6.2.16.1.\nVulkan Interoperability\nï\n6.2.16.1.1.\nMatching device UUIDs\nï\nWhen importing memory and synchronization objects exported by Vulkan, they must be imported and mapped on the same device as they were created on. The CUDA device that corresponds to the Vulkan physical device on which the objects were created can be determined by comparing the UUID of a CUDA device with that of the Vulkan physical device, as shown in the following code sample. Note that the Vulkan physical device should not be part of a device group that contains more than one Vulkan physical device. The device group as returned by\nvkEnumeratePhysicalDeviceGroups\nthat contains the given Vulkan physical device must have a physical device count of 1.\nint\ngetCudaDeviceForVulkanPhysicalDevice\n(\nVkPhysicalDevice\nvkPhysicalDevice\n)\n{\nVkPhysicalDeviceIDProperties\nvkPhysicalDeviceIDProperties\n=\n{};\nvkPhysicalDeviceIDProperties\n.\nsType\n=\nVK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES\n;\nvkPhysicalDeviceIDProperties\n.\npNext\n=\nNULL\n;\nVkPhysicalDeviceProperties2\nvkPhysicalDeviceProperties2\n=\n{};\nvkPhysicalDeviceProperties2\n.\nsType\n=\nVK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2\n;\nvkPhysicalDeviceProperties2\n.\npNext\n=\n&\nvkPhysicalDeviceIDProperties\n;\nvkGetPhysicalDeviceProperties2\n(\nvkPhysicalDevice\n,\n&\nvkPhysicalDeviceProperties2\n);\nint\ncudaDeviceCount\n;\ncudaGetDeviceCount\n(\n&\ncudaDeviceCount\n);\nfor\n(\nint\ncudaDevice\n=\n0\n;\ncudaDevice\n<\ncudaDeviceCount\n;\ncudaDevice\n++\n)\n{\ncudaDeviceProp\ndeviceProp\n;\ncudaGetDeviceProperties\n(\n&\ndeviceProp\n,\ncudaDevice\n);\nif\n(\n!\nmemcmp\n(\n&\ndeviceProp\n.\nuuid\n,\nvkPhysicalDeviceIDProperties\n.\ndeviceUUID\n,\nVK_UUID_SIZE\n))\n{\nreturn\ncudaDevice\n;\n}\n}\nreturn\ncudaInvalidDeviceId\n;\n}\n6.2.16.1.2.\nImporting Memory Objects\nï\nOn Linux and Windows 10, both dedicated and non-dedicated memory objects exported by Vulkan can be imported into CUDA. On Windows 7, only dedicated memory objects can be imported. When importing a Vulkan dedicated memory object, the flag\ncudaExternalMemoryDedicated\nmust be set.\nA Vulkan memory object exported using\nVK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT\ncan be imported into CUDA using the file descriptor associated with that object as shown below. Note that CUDA assumes ownership of the file descriptor once it is imported. Using the file descriptor after a successful import results in undefined behavior.\ncudaExternalMemory_t\nimportVulkanMemoryObjectFromFileDescriptor\n(\nint\nfd\n,\nunsigned\nlong\nlong\nsize\n,\nbool\nisDedicated\n)\n{\ncudaExternalMemory_t\nextMem\n=\nNULL\n;\ncudaExternalMemoryHandleDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\ntype\n=\ncudaExternalMemoryHandleTypeOpaqueFd\n;\ndesc\n.\nhandle\n.\nfd\n=\nfd\n;\ndesc\n.\nsize\n=\nsize\n;\nif\n(\nisDedicated\n)\n{\ndesc\n.\nflags\n|=\ncudaExternalMemoryDedicated\n;\n}\ncudaImportExternalMemory\n(\n&\nextMem\n,\n&\ndesc\n);\n// Input parameter 'fd' should not be used beyond this point as CUDA has assumed ownership of it\nreturn\nextMem\n;\n}\nA Vulkan memory object exported using\nVK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT\ncan be imported into CUDA using the NT handle associated with that object as shown below. Note that CUDA does not assume ownership of the NT handle and it is the applicationâs responsibility to close the handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying memory can be freed.\ncudaExternalMemory_t\nimportVulkanMemoryObjectFromNTHandle\n(\nHANDLE\nhandle\n,\nunsigned\nlong\nlong\nsize\n,\nbool\nisDedicated\n)\n{\ncudaExternalMemory_t\nextMem\n=\nNULL\n;\ncudaExternalMemoryHandleDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\ntype\n=\ncudaExternalMemoryHandleTypeOpaqueWin32\n;\ndesc\n.\nhandle\n.\nwin32\n.\nhandle\n=\nhandle\n;\ndesc\n.\nsize\n=\nsize\n;\nif\n(\nisDedicated\n)\n{\ndesc\n.\nflags\n|=\ncudaExternalMemoryDedicated\n;\n}\ncudaImportExternalMemory\n(\n&\nextMem\n,\n&\ndesc\n);\n// Input parameter 'handle' should be closed if it's not needed anymore\nCloseHandle\n(\nhandle\n);\nreturn\nextMem\n;\n}\nA Vulkan memory object exported using\nVK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT\ncan also be imported using a named handle if one exists as shown below.\ncudaExternalMemory_t\nimportVulkanMemoryObjectFromNamedNTHandle\n(\nLPCWSTR\nname\n,\nunsigned\nlong\nlong\nsize\n,\nbool\nisDedicated\n)\n{\ncudaExternalMemory_t\nextMem\n=\nNULL\n;\ncudaExternalMemoryHandleDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\ntype\n=\ncudaExternalMemoryHandleTypeOpaqueWin32\n;\ndesc\n.\nhandle\n.\nwin32\n.\nname\n=\n(\nvoid\n*\n)\nname\n;\ndesc\n.\nsize\n=\nsize\n;\nif\n(\nisDedicated\n)\n{\ndesc\n.\nflags\n|=\ncudaExternalMemoryDedicated\n;\n}\ncudaImportExternalMemory\n(\n&\nextMem\n,\n&\ndesc\n);\nreturn\nextMem\n;\n}\nA Vulkan memory object exported using VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT can be imported into CUDA using the globally shared D3DKMT handle associated with that object as shown below. Since a globally shared D3DKMT handle does not hold a reference to the underlying memory it is automatically destroyed when all other references to the resource are destroyed.\ncudaExternalMemory_t\nimportVulkanMemoryObjectFromKMTHandle\n(\nHANDLE\nhandle\n,\nunsigned\nlong\nlong\nsize\n,\nbool\nisDedicated\n)\n{\ncudaExternalMemory_t\nextMem\n=\nNULL\n;\ncudaExternalMemoryHandleDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\ntype\n=\ncudaExternalMemoryHandleTypeOpaqueWin32Kmt\n;\ndesc\n.\nhandle\n.\nwin32\n.\nhandle\n=\n(\nvoid\n*\n)\nhandle\n;\ndesc\n.\nsize\n=\nsize\n;\nif\n(\nisDedicated\n)\n{\ndesc\n.\nflags\n|=\ncudaExternalMemoryDedicated\n;\n}\ncudaImportExternalMemory\n(\n&\nextMem\n,\n&\ndesc\n);\nreturn\nextMem\n;\n}\n6.2.16.1.3.\nMapping Buffers onto Imported Memory Objects\nï\nA device pointer can be mapped onto an imported memory object as shown below. The offset and size of the mapping must match that specified when creating the mapping using the corresponding Vulkan API. All mapped device pointers must be freed using\ncudaFree()\n.\nvoid\n*\nmapBufferOntoExternalMemory\n(\ncudaExternalMemory_t\nextMem\n,\nunsigned\nlong\nlong\noffset\n,\nunsigned\nlong\nlong\nsize\n)\n{\nvoid\n*\nptr\n=\nNULL\n;\ncudaExternalMemoryBufferDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\noffset\n=\noffset\n;\ndesc\n.\nsize\n=\nsize\n;\ncudaExternalMemoryGetMappedBuffer\n(\n&\nptr\n,\nextMem\n,\n&\ndesc\n);\n// Note: âptrâ must eventually be freed using cudaFree()\nreturn\nptr\n;\n}\n6.2.16.1.4.\nMapping Mipmapped Arrays onto Imported Memory Objects\nï\nA CUDA mipmapped array can be mapped onto an imported memory object as shown below. The offset, dimensions, format and number of mip levels must match that specified when creating the mapping using the corresponding Vulkan API. Additionally, if the mipmapped array is bound as a color target in Vulkan, the flag\ncudaArrayColorAttachment\nmust be set. All mapped mipmapped arrays must be freed using\ncudaFreeMipmappedArray()\n. The following code sample shows how to convert Vulkan parameters into the corresponding CUDA parameters when mapping mipmapped arrays onto imported memory objects.\ncudaMipmappedArray_t\nmapMipmappedArrayOntoExternalMemory\n(\ncudaExternalMemory_t\nextMem\n,\nunsigned\nlong\nlong\noffset\n,\ncudaChannelFormatDesc\n*\nformatDesc\n,\ncudaExtent\n*\nextent\n,\nunsigned\nint\nflags\n,\nunsigned\nint\nnumLevels\n)\n{\ncudaMipmappedArray_t\nmipmap\n=\nNULL\n;\ncudaExternalMemoryMipmappedArrayDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\noffset\n=\noffset\n;\ndesc\n.\nformatDesc\n=\n*\nformatDesc\n;\ndesc\n.\nextent\n=\n*\nextent\n;\ndesc\n.\nflags\n=\nflags\n;\ndesc\n.\nnumLevels\n=\nnumLevels\n;\n// Note: 'mipmap' must eventually be freed using cudaFreeMipmappedArray()\ncudaExternalMemoryGetMappedMipmappedArray\n(\n&\nmipmap\n,\nextMem\n,\n&\ndesc\n);\nreturn\nmipmap\n;\n}\ncudaChannelFormatDesc\ngetCudaChannelFormatDescForVulkanFormat\n(\nVkFormat\nformat\n)\n{\ncudaChannelFormatDesc\nd\n;\nmemset\n(\n&\nd\n,\n0\n,\nsizeof\n(\nd\n));\nswitch\n(\nformat\n)\n{\ncase\nVK_FORMAT_R8_UINT\n:\nd\n.\nx\n=\n8\n;\nd\n.\ny\n=\n0\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nVK_FORMAT_R8_SINT\n:\nd\n.\nx\n=\n8\n;\nd\n.\ny\n=\n0\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nVK_FORMAT_R8G8_UINT\n:\nd\n.\nx\n=\n8\n;\nd\n.\ny\n=\n8\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nVK_FORMAT_R8G8_SINT\n:\nd\n.\nx\n=\n8\n;\nd\n.\ny\n=\n8\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nVK_FORMAT_R8G8B8A8_UINT\n:\nd\n.\nx\n=\n8\n;\nd\n.\ny\n=\n8\n;\nd\n.\nz\n=\n8\n;\nd\n.\nw\n=\n8\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nVK_FORMAT_R8G8B8A8_SINT\n:\nd\n.\nx\n=\n8\n;\nd\n.\ny\n=\n8\n;\nd\n.\nz\n=\n8\n;\nd\n.\nw\n=\n8\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nVK_FORMAT_R16_UINT\n:\nd\n.\nx\n=\n16\n;\nd\n.\ny\n=\n0\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nVK_FORMAT_R16_SINT\n:\nd\n.\nx\n=\n16\n;\nd\n.\ny\n=\n0\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nVK_FORMAT_R16G16_UINT\n:\nd\n.\nx\n=\n16\n;\nd\n.\ny\n=\n16\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nVK_FORMAT_R16G16_SINT\n:\nd\n.\nx\n=\n16\n;\nd\n.\ny\n=\n16\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nVK_FORMAT_R16G16B16A16_UINT\n:\nd\n.\nx\n=\n16\n;\nd\n.\ny\n=\n16\n;\nd\n.\nz\n=\n16\n;\nd\n.\nw\n=\n16\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nVK_FORMAT_R16G16B16A16_SINT\n:\nd\n.\nx\n=\n16\n;\nd\n.\ny\n=\n16\n;\nd\n.\nz\n=\n16\n;\nd\n.\nw\n=\n16\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nVK_FORMAT_R32_UINT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n0\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nVK_FORMAT_R32_SINT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n0\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nVK_FORMAT_R32_SFLOAT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n0\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindFloat\n;\nbreak\n;\ncase\nVK_FORMAT_R32G32_UINT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n32\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nVK_FORMAT_R32G32_SINT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n32\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nVK_FORMAT_R32G32_SFLOAT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n32\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindFloat\n;\nbreak\n;\ncase\nVK_FORMAT_R32G32B32A32_UINT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n32\n;\nd\n.\nz\n=\n32\n;\nd\n.\nw\n=\n32\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nVK_FORMAT_R32G32B32A32_SINT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n32\n;\nd\n.\nz\n=\n32\n;\nd\n.\nw\n=\n32\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nVK_FORMAT_R32G32B32A32_SFLOAT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n32\n;\nd\n.\nz\n=\n32\n;\nd\n.\nw\n=\n32\n;\nd\n.\nf\n=\ncudaChannelFormatKindFloat\n;\nbreak\n;\ndefault\n:\nassert\n(\n0\n);\n}\nreturn\nd\n;\n}\ncudaExtent\ngetCudaExtentForVulkanExtent\n(\nVkExtent3D\nvkExt\n,\nuint32_t\narrayLayers\n,\nVkImageViewType\nvkImageViewType\n)\n{\ncudaExtent\ne\n=\n{\n0\n,\n0\n,\n0\n};\nswitch\n(\nvkImageViewType\n)\n{\ncase\nVK_IMAGE_VIEW_TYPE_1D\n:\ne\n.\nwidth\n=\nvkExt\n.\nwidth\n;\ne\n.\nheight\n=\n0\n;\ne\n.\ndepth\n=\n0\n;\nbreak\n;\ncase\nVK_IMAGE_VIEW_TYPE_2D\n:\ne\n.\nwidth\n=\nvkExt\n.\nwidth\n;\ne\n.\nheight\n=\nvkExt\n.\nheight\n;\ne\n.\ndepth\n=\n0\n;\nbreak\n;\ncase\nVK_IMAGE_VIEW_TYPE_3D\n:\ne\n.\nwidth\n=\nvkExt\n.\nwidth\n;\ne\n.\nheight\n=\nvkExt\n.\nheight\n;\ne\n.\ndepth\n=\nvkExt\n.\ndepth\n;\nbreak\n;\ncase\nVK_IMAGE_VIEW_TYPE_CUBE\n:\ne\n.\nwidth\n=\nvkExt\n.\nwidth\n;\ne\n.\nheight\n=\nvkExt\n.\nheight\n;\ne\n.\ndepth\n=\narrayLayers\n;\nbreak\n;\ncase\nVK_IMAGE_VIEW_TYPE_1D_ARRAY\n:\ne\n.\nwidth\n=\nvkExt\n.\nwidth\n;\ne\n.\nheight\n=\n0\n;\ne\n.\ndepth\n=\narrayLayers\n;\nbreak\n;\ncase\nVK_IMAGE_VIEW_TYPE_2D_ARRAY\n:\ne\n.\nwidth\n=\nvkExt\n.\nwidth\n;\ne\n.\nheight\n=\nvkExt\n.\nheight\n;\ne\n.\ndepth\n=\narrayLayers\n;\nbreak\n;\ncase\nVK_IMAGE_VIEW_TYPE_CUBE_ARRAY\n:\ne\n.\nwidth\n=\nvkExt\n.\nwidth\n;\ne\n.\nheight\n=\nvkExt\n.\nheight\n;\ne\n.\ndepth\n=\narrayLayers\n;\nbreak\n;\ndefault\n:\nassert\n(\n0\n);\n}\nreturn\ne\n;\n}\nunsigned\nint\ngetCudaMipmappedArrayFlagsForVulkanImage\n(\nVkImageViewType\nvkImageViewType\n,\nVkImageUsageFlags\nvkImageUsageFlags\n,\nbool\nallowSurfaceLoadStore\n)\n{\nunsigned\nint\nflags\n=\n0\n;\nswitch\n(\nvkImageViewType\n)\n{\ncase\nVK_IMAGE_VIEW_TYPE_CUBE\n:\nflags\n|=\ncudaArrayCubemap\n;\nbreak\n;\ncase\nVK_IMAGE_VIEW_TYPE_CUBE_ARRAY\n:\nflags\n|=\ncudaArrayCubemap\n|\ncudaArrayLayered\n;\nbreak\n;\ncase\nVK_IMAGE_VIEW_TYPE_1D_ARRAY\n:\nflags\n|=\ncudaArrayLayered\n;\nbreak\n;\ncase\nVK_IMAGE_VIEW_TYPE_2D_ARRAY\n:\nflags\n|=\ncudaArrayLayered\n;\nbreak\n;\ndefault\n:\nbreak\n;\n}\nif\n(\nvkImageUsageFlags\n&\nVK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT\n)\n{\nflags\n|=\ncudaArrayColorAttachment\n;\n}\nif\n(\nallowSurfaceLoadStore\n)\n{\nflags\n|=\ncudaArraySurfaceLoadStore\n;\n}\nreturn\nflags\n;\n}\n6.2.16.1.5.\nImporting Synchronization Objects\nï\nA Vulkan semaphore object exported using\nVK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT\ncan be imported into CUDA using the file descriptor associated with that object as shown below. Note that CUDA assumes ownership of the file descriptor once it is imported. Using the file descriptor after a successful import results in undefined behavior.\ncudaExternalSemaphore_t\nimportVulkanSemaphoreObjectFromFileDescriptor\n(\nint\nfd\n)\n{\ncudaExternalSemaphore_t\nextSem\n=\nNULL\n;\ncudaExternalSemaphoreHandleDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\ntype\n=\ncudaExternalSemaphoreHandleTypeOpaqueFd\n;\ndesc\n.\nhandle\n.\nfd\n=\nfd\n;\ncudaImportExternalSemaphore\n(\n&\nextSem\n,\n&\ndesc\n);\n// Input parameter 'fd' should not be used beyond this point as CUDA has assumed ownership of it\nreturn\nextSem\n;\n}\nA Vulkan semaphore object exported using\nVK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT\ncan be imported into CUDA using the NT handle associated with that object as shown below. Note that CUDA does not assume ownership of the NT handle and it is the applicationâs responsibility to close the handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying semaphore can be freed.\ncudaExternalSemaphore_t\nimportVulkanSemaphoreObjectFromNTHandle\n(\nHANDLE\nhandle\n)\n{\ncudaExternalSemaphore_t\nextSem\n=\nNULL\n;\ncudaExternalSemaphoreHandleDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\ntype\n=\ncudaExternalSemaphoreHandleTypeOpaqueWin32\n;\ndesc\n.\nhandle\n.\nwin32\n.\nhandle\n=\nhandle\n;\ncudaImportExternalSemaphore\n(\n&\nextSem\n,\n&\ndesc\n);\n// Input parameter 'handle' should be closed if it's not needed anymore\nCloseHandle\n(\nhandle\n);\nreturn\nextSem\n;\n}\nA Vulkan semaphore object exported using\nVK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT\ncan also be imported using a named handle if one exists as shown below.\ncudaExternalSemaphore_t\nimportVulkanSemaphoreObjectFromNamedNTHandle\n(\nLPCWSTR\nname\n)\n{\ncudaExternalSemaphore_t\nextSem\n=\nNULL\n;\ncudaExternalSemaphoreHandleDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\ntype\n=\ncudaExternalSemaphoreHandleTypeOpaqueWin32\n;\ndesc\n.\nhandle\n.\nwin32\n.\nname\n=\n(\nvoid\n*\n)\nname\n;\ncudaImportExternalSemaphore\n(\n&\nextSem\n,\n&\ndesc\n);\nreturn\nextSem\n;\n}\nA Vulkan semaphore object exported using\nVK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT\ncan be imported into CUDA using the globally shared D3DKMT handle associated with that object as shown below. Since a globally shared D3DKMT handle does not hold a reference to the underlying semaphore it is automatically destroyed when all other references to the resource are destroyed.\ncudaExternalSemaphore_t\nimportVulkanSemaphoreObjectFromKMTHandle\n(\nHANDLE\nhandle\n)\n{\ncudaExternalSemaphore_t\nextSem\n=\nNULL\n;\ncudaExternalSemaphoreHandleDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\ntype\n=\ncudaExternalSemaphoreHandleTypeOpaqueWin32Kmt\n;\ndesc\n.\nhandle\n.\nwin32\n.\nhandle\n=\n(\nvoid\n*\n)\nhandle\n;\ncudaImportExternalSemaphore\n(\n&\nextSem\n,\n&\ndesc\n);\nreturn\nextSem\n;\n}\n6.2.16.1.6.\nSignaling/Waiting on Imported Synchronization Objects\nï\nAn imported Vulkan semaphore object can be signaled as shown below. Signaling such a semaphore object sets it to the signaled state. The corresponding wait that waits on this signal must be issued in Vulkan. Additionally, the wait that waits on this signal must be issued after this signal has been issued.\nvoid\nsignalExternalSemaphore\n(\ncudaExternalSemaphore_t\nextSem\n,\ncudaStream_t\nstream\n)\n{\ncudaExternalSemaphoreSignalParams\nparams\n=\n{};\nmemset\n(\n&\nparams\n,\n0\n,\nsizeof\n(\nparams\n));\ncudaSignalExternalSemaphoresAsync\n(\n&\nextSem\n,\n&\nparams\n,\n1\n,\nstream\n);\n}\nAn imported Vulkan semaphore object can be waited on as shown below. Waiting on such a semaphore object waits until it reaches the signaled state and then resets it back to the unsignaled state. The corresponding signal that this wait is waiting on must be issued in Vulkan. Additionally, the signal must be issued before this wait can be issued.\nvoid\nwaitExternalSemaphore\n(\ncudaExternalSemaphore_t\nextSem\n,\ncudaStream_t\nstream\n)\n{\ncudaExternalSemaphoreWaitParams\nparams\n=\n{};\nmemset\n(\n&\nparams\n,\n0\n,\nsizeof\n(\nparams\n));\ncudaWaitExternalSemaphoresAsync\n(\n&\nextSem\n,\n&\nparams\n,\n1\n,\nstream\n);\n}\n6.2.16.2.\nOpenGL Interoperability\nï\nTraditional OpenGL-CUDA interop as outlined in\nOpenGL Interoperability\nworks by CUDA directly consuming handles created in OpenGL. However, since OpenGL can also consume memory and synchronization objects created in Vulkan, there exists an alternative approach to doing OpenGL-CUDA interop. Essentially, memory and synchronization objects exported by Vulkan could be imported into both, OpenGL and CUDA, and then used to coordinate memory accesses between OpenGL and CUDA. Please refer to the following OpenGL extensions for further details on how to import memory and synchronization objects exported by Vulkan:\nGL_EXT_memory_object\nGL_EXT_memory_object_fd\nGL_EXT_memory_object_win32\nGL_EXT_semaphore\nGL_EXT_semaphore_fd\nGL_EXT_semaphore_win32\n6.2.16.3.\nDirect3D 12 Interoperability\nï\n6.2.16.3.1.\nMatching Device LUIDs\nï\nWhen importing memory and synchronization objects exported by Direct3D 12, they must be imported and mapped on the same device as they were created on. The CUDA device that corresponds to the Direct3D 12 device on which the objects were created can be determined by comparing the LUID of a CUDA device with that of the Direct3D 12 device, as shown in the following code sample. Note that the Direct3D 12 device must not be created on a linked node adapter. I.e. the node count as returned by\nID3D12Device::GetNodeCount\nmust be 1.\nint\ngetCudaDeviceForD3D12Device\n(\nID3D12Device\n*\nd3d12Device\n)\n{\nLUID\nd3d12Luid\n=\nd3d12Device\n->\nGetAdapterLuid\n();\nint\ncudaDeviceCount\n;\ncudaGetDeviceCount\n(\n&\ncudaDeviceCount\n);\nfor\n(\nint\ncudaDevice\n=\n0\n;\ncudaDevice\n<\ncudaDeviceCount\n;\ncudaDevice\n++\n)\n{\ncudaDeviceProp\ndeviceProp\n;\ncudaGetDeviceProperties\n(\n&\ndeviceProp\n,\ncudaDevice\n);\nchar\n*\ncudaLuid\n=\ndeviceProp\n.\nluid\n;\nif\n(\n!\nmemcmp\n(\n&\nd3d12Luid\n.\nLowPart\n,\ncudaLuid\n,\nsizeof\n(\nd3d12Luid\n.\nLowPart\n))\n&&\n!\nmemcmp\n(\n&\nd3d12Luid\n.\nHighPart\n,\ncudaLuid\n+\nsizeof\n(\nd3d12Luid\n.\nLowPart\n),\nsizeof\n(\nd3d12Luid\n.\nHighPart\n)))\n{\nreturn\ncudaDevice\n;\n}\n}\nreturn\ncudaInvalidDeviceId\n;\n}\n6.2.16.3.2.\nImporting Memory Objects\nï\nA shareable Direct3D 12 heap memory object, created by setting the flag\nD3D12_HEAP_FLAG_SHARED\nin the call to\nID3D12Device::CreateHeap\n, can be imported into CUDA using the NT handle associated with that object as shown below. Note that it is the applicationâs responsibility to close the NT handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying memory can be freed.\ncudaExternalMemory_t\nimportD3D12HeapFromNTHandle\n(\nHANDLE\nhandle\n,\nunsigned\nlong\nlong\nsize\n)\n{\ncudaExternalMemory_t\nextMem\n=\nNULL\n;\ncudaExternalMemoryHandleDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\ntype\n=\ncudaExternalMemoryHandleTypeD3D12Heap\n;\ndesc\n.\nhandle\n.\nwin32\n.\nhandle\n=\n(\nvoid\n*\n)\nhandle\n;\ndesc\n.\nsize\n=\nsize\n;\ncudaImportExternalMemory\n(\n&\nextMem\n,\n&\ndesc\n);\n// Input parameter 'handle' should be closed if it's not needed anymore\nCloseHandle\n(\nhandle\n);\nreturn\nextMem\n;\n}\nA shareable Direct3D 12 heap memory object can also be imported using a named handle if one exists as shown below.\ncudaExternalMemory_t\nimportD3D12HeapFromNamedNTHandle\n(\nLPCWSTR\nname\n,\nunsigned\nlong\nlong\nsize\n)\n{\ncudaExternalMemory_t\nextMem\n=\nNULL\n;\ncudaExternalMemoryHandleDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\ntype\n=\ncudaExternalMemoryHandleTypeD3D12Heap\n;\ndesc\n.\nhandle\n.\nwin32\n.\nname\n=\n(\nvoid\n*\n)\nname\n;\ndesc\n.\nsize\n=\nsize\n;\ncudaImportExternalMemory\n(\n&\nextMem\n,\n&\ndesc\n);\nreturn\nextMem\n;\n}\nA shareable Direct3D 12 committed resource, created by setting the flag\nD3D12_HEAP_FLAG_SHARED\nin the call to\nD3D12Device::CreateCommittedResource\n, can be imported into CUDA using the NT handle associated with that object as shown below. When importing a Direct3D 12 committed resource, the flag\ncudaExternalMemoryDedicated\nmust be set. Note that it is the applicationâs responsibility to close the NT handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying memory can be freed.\ncudaExternalMemory_t\nimportD3D12CommittedResourceFromNTHandle\n(\nHANDLE\nhandle\n,\nunsigned\nlong\nlong\nsize\n)\n{\ncudaExternalMemory_t\nextMem\n=\nNULL\n;\ncudaExternalMemoryHandleDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\ntype\n=\ncudaExternalMemoryHandleTypeD3D12Resource\n;\ndesc\n.\nhandle\n.\nwin32\n.\nhandle\n=\n(\nvoid\n*\n)\nhandle\n;\ndesc\n.\nsize\n=\nsize\n;\ndesc\n.\nflags\n|=\ncudaExternalMemoryDedicated\n;\ncudaImportExternalMemory\n(\n&\nextMem\n,\n&\ndesc\n);\n// Input parameter 'handle' should be closed if it's not needed anymore\nCloseHandle\n(\nhandle\n);\nreturn\nextMem\n;\n}\nA shareable Direct3D 12 committed resource can also be imported using a named handle if one exists as shown below.\ncudaExternalMemory_t\nimportD3D12CommittedResourceFromNamedNTHandle\n(\nLPCWSTR\nname\n,\nunsigned\nlong\nlong\nsize\n)\n{\ncudaExternalMemory_t\nextMem\n=\nNULL\n;\ncudaExternalMemoryHandleDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\ntype\n=\ncudaExternalMemoryHandleTypeD3D12Resource\n;\ndesc\n.\nhandle\n.\nwin32\n.\nname\n=\n(\nvoid\n*\n)\nname\n;\ndesc\n.\nsize\n=\nsize\n;\ndesc\n.\nflags\n|=\ncudaExternalMemoryDedicated\n;\ncudaImportExternalMemory\n(\n&\nextMem\n,\n&\ndesc\n);\nreturn\nextMem\n;\n}\n6.2.16.3.3.\nMapping Buffers onto Imported Memory Objects\nï\nA device pointer can be mapped onto an imported memory object as shown below. The offset and size of the mapping must match that specified when creating the mapping using the corresponding Direct3D 12 API. All mapped device pointers must be freed using\ncudaFree()\n.\nvoid\n*\nmapBufferOntoExternalMemory\n(\ncudaExternalMemory_t\nextMem\n,\nunsigned\nlong\nlong\noffset\n,\nunsigned\nlong\nlong\nsize\n)\n{\nvoid\n*\nptr\n=\nNULL\n;\ncudaExternalMemoryBufferDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\noffset\n=\noffset\n;\ndesc\n.\nsize\n=\nsize\n;\ncudaExternalMemoryGetMappedBuffer\n(\n&\nptr\n,\nextMem\n,\n&\ndesc\n);\n// Note: 'ptr' must eventually be freed using cudaFree()\nreturn\nptr\n;\n}\n6.2.16.3.4.\nMapping Mipmapped Arrays onto Imported Memory Objects\nï\nA CUDA mipmapped array can be mapped onto an imported memory object as shown below. The offset, dimensions, format and number of mip levels must match that specified when creating the mapping using the corresponding Direct3D 12 API. Additionally, if the mipmapped array can be bound as a render target in Direct3D 12, the flag\ncudaArrayColorAttachment\nmust be set. All mapped mipmapped arrays must be freed using\ncudaFreeMipmappedArray()\n. The following code sample shows how to convert Vulkan parameters into the corresponding CUDA parameters when mapping mipmapped arrays onto imported memory objects.\ncudaMipmappedArray_t\nmapMipmappedArrayOntoExternalMemory\n(\ncudaExternalMemory_t\nextMem\n,\nunsigned\nlong\nlong\noffset\n,\ncudaChannelFormatDesc\n*\nformatDesc\n,\ncudaExtent\n*\nextent\n,\nunsigned\nint\nflags\n,\nunsigned\nint\nnumLevels\n)\n{\ncudaMipmappedArray_t\nmipmap\n=\nNULL\n;\ncudaExternalMemoryMipmappedArrayDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\noffset\n=\noffset\n;\ndesc\n.\nformatDesc\n=\n*\nformatDesc\n;\ndesc\n.\nextent\n=\n*\nextent\n;\ndesc\n.\nflags\n=\nflags\n;\ndesc\n.\nnumLevels\n=\nnumLevels\n;\n// Note: 'mipmap' must eventually be freed using cudaFreeMipmappedArray()\ncudaExternalMemoryGetMappedMipmappedArray\n(\n&\nmipmap\n,\nextMem\n,\n&\ndesc\n);\nreturn\nmipmap\n;\n}\ncudaChannelFormatDesc\ngetCudaChannelFormatDescForDxgiFormat\n(\nDXGI_FORMAT\ndxgiFormat\n)\n{\ncudaChannelFormatDesc\nd\n;\nmemset\n(\n&\nd\n,\n0\n,\nsizeof\n(\nd\n));\nswitch\n(\ndxgiFormat\n)\n{\ncase\nDXGI_FORMAT_R8_UINT\n:\nd\n.\nx\n=\n8\n;\nd\n.\ny\n=\n0\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R8_SINT\n:\nd\n.\nx\n=\n8\n;\nd\n.\ny\n=\n0\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R8G8_UINT\n:\nd\n.\nx\n=\n8\n;\nd\n.\ny\n=\n8\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R8G8_SINT\n:\nd\n.\nx\n=\n8\n;\nd\n.\ny\n=\n8\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R8G8B8A8_UINT\n:\nd\n.\nx\n=\n8\n;\nd\n.\ny\n=\n8\n;\nd\n.\nz\n=\n8\n;\nd\n.\nw\n=\n8\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R8G8B8A8_SINT\n:\nd\n.\nx\n=\n8\n;\nd\n.\ny\n=\n8\n;\nd\n.\nz\n=\n8\n;\nd\n.\nw\n=\n8\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R16_UINT\n:\nd\n.\nx\n=\n16\n;\nd\n.\ny\n=\n0\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R16_SINT\n:\nd\n.\nx\n=\n16\n;\nd\n.\ny\n=\n0\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R16G16_UINT\n:\nd\n.\nx\n=\n16\n;\nd\n.\ny\n=\n16\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R16G16_SINT\n:\nd\n.\nx\n=\n16\n;\nd\n.\ny\n=\n16\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R16G16B16A16_UINT\n:\nd\n.\nx\n=\n16\n;\nd\n.\ny\n=\n16\n;\nd\n.\nz\n=\n16\n;\nd\n.\nw\n=\n16\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R16G16B16A16_SINT\n:\nd\n.\nx\n=\n16\n;\nd\n.\ny\n=\n16\n;\nd\n.\nz\n=\n16\n;\nd\n.\nw\n=\n16\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R32_UINT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n0\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R32_SINT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n0\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R32_FLOAT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n0\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindFloat\n;\nbreak\n;\ncase\nDXGI_FORMAT_R32G32_UINT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n32\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R32G32_SINT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n32\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R32G32_FLOAT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n32\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindFloat\n;\nbreak\n;\ncase\nDXGI_FORMAT_R32G32B32A32_UINT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n32\n;\nd\n.\nz\n=\n32\n;\nd\n.\nw\n=\n32\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R32G32B32A32_SINT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n32\n;\nd\n.\nz\n=\n32\n;\nd\n.\nw\n=\n32\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R32G32B32A32_FLOAT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n32\n;\nd\n.\nz\n=\n32\n;\nd\n.\nw\n=\n32\n;\nd\n.\nf\n=\ncudaChannelFormatKindFloat\n;\nbreak\n;\ndefault\n:\nassert\n(\n0\n);\n}\nreturn\nd\n;\n}\ncudaExtent\ngetCudaExtentForD3D12Extent\n(\nUINT64\nwidth\n,\nUINT\nheight\n,\nUINT16\ndepthOrArraySize\n,\nD3D12_SRV_DIMENSION\nd3d12SRVDimension\n)\n{\ncudaExtent\ne\n=\n{\n0\n,\n0\n,\n0\n};\nswitch\n(\nd3d12SRVDimension\n)\n{\ncase\nD3D12_SRV_DIMENSION_TEXTURE1D\n:\ne\n.\nwidth\n=\nwidth\n;\ne\n.\nheight\n=\n0\n;\ne\n.\ndepth\n=\n0\n;\nbreak\n;\ncase\nD3D12_SRV_DIMENSION_TEXTURE2D\n:\ne\n.\nwidth\n=\nwidth\n;\ne\n.\nheight\n=\nheight\n;\ne\n.\ndepth\n=\n0\n;\nbreak\n;\ncase\nD3D12_SRV_DIMENSION_TEXTURE3D\n:\ne\n.\nwidth\n=\nwidth\n;\ne\n.\nheight\n=\nheight\n;\ne\n.\ndepth\n=\ndepthOrArraySize\n;\nbreak\n;\ncase\nD3D12_SRV_DIMENSION_TEXTURECUBE\n:\ne\n.\nwidth\n=\nwidth\n;\ne\n.\nheight\n=\nheight\n;\ne\n.\ndepth\n=\ndepthOrArraySize\n;\nbreak\n;\ncase\nD3D12_SRV_DIMENSION_TEXTURE1DARRAY\n:\ne\n.\nwidth\n=\nwidth\n;\ne\n.\nheight\n=\n0\n;\ne\n.\ndepth\n=\ndepthOrArraySize\n;\nbreak\n;\ncase\nD3D12_SRV_DIMENSION_TEXTURE2DARRAY\n:\ne\n.\nwidth\n=\nwidth\n;\ne\n.\nheight\n=\nheight\n;\ne\n.\ndepth\n=\ndepthOrArraySize\n;\nbreak\n;\ncase\nD3D12_SRV_DIMENSION_TEXTURECUBEARRAY\n:\ne\n.\nwidth\n=\nwidth\n;\ne\n.\nheight\n=\nheight\n;\ne\n.\ndepth\n=\ndepthOrArraySize\n;\nbreak\n;\ndefault\n:\nassert\n(\n0\n);\n}\nreturn\ne\n;\n}\nunsigned\nint\ngetCudaMipmappedArrayFlagsForD3D12Resource\n(\nD3D12_SRV_DIMENSION\nd3d12SRVDimension\n,\nD3D12_RESOURCE_FLAGS\nd3d12ResourceFlags\n,\nbool\nallowSurfaceLoadStore\n)\n{\nunsigned\nint\nflags\n=\n0\n;\nswitch\n(\nd3d12SRVDimension\n)\n{\ncase\nD3D12_SRV_DIMENSION_TEXTURECUBE\n:\nflags\n|=\ncudaArrayCubemap\n;\nbreak\n;\ncase\nD3D12_SRV_DIMENSION_TEXTURECUBEARRAY\n:\nflags\n|=\ncudaArrayCubemap\n|\ncudaArrayLayered\n;\nbreak\n;\ncase\nD3D12_SRV_DIMENSION_TEXTURE1DARRAY\n:\nflags\n|=\ncudaArrayLayered\n;\nbreak\n;\ncase\nD3D12_SRV_DIMENSION_TEXTURE2DARRAY\n:\nflags\n|=\ncudaArrayLayered\n;\nbreak\n;\ndefault\n:\nbreak\n;\n}\nif\n(\nd3d12ResourceFlags\n&\nD3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET\n)\n{\nflags\n|=\ncudaArrayColorAttachment\n;\n}\nif\n(\nallowSurfaceLoadStore\n)\n{\nflags\n|=\ncudaArraySurfaceLoadStore\n;\n}\nreturn\nflags\n;\n}\n6.2.16.3.5.\nImporting Synchronization Objects\nï\nA shareable Direct3D 12 fence object, created by setting the flag\nD3D12_FENCE_FLAG_SHARED\nin the call to\nID3D12Device::CreateFence\n, can be imported into CUDA using the NT handle associated with that object as shown below. Note that it is the applicationâs responsibility to close the handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying semaphore can be freed.\ncudaExternalSemaphore_t\nimportD3D12FenceFromNTHandle\n(\nHANDLE\nhandle\n)\n{\ncudaExternalSemaphore_t\nextSem\n=\nNULL\n;\ncudaExternalSemaphoreHandleDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\ntype\n=\ncudaExternalSemaphoreHandleTypeD3D12Fence\n;\ndesc\n.\nhandle\n.\nwin32\n.\nhandle\n=\nhandle\n;\ncudaImportExternalSemaphore\n(\n&\nextSem\n,\n&\ndesc\n);\n// Input parameter 'handle' should be closed if it's not needed anymore\nCloseHandle\n(\nhandle\n);\nreturn\nextSem\n;\n}\nA shareable Direct3D 12 fence object can also be imported using a named handle if one exists as shown below.\ncudaExternalSemaphore_t\nimportD3D12FenceFromNamedNTHandle\n(\nLPCWSTR\nname\n)\n{\ncudaExternalSemaphore_t\nextSem\n=\nNULL\n;\ncudaExternalSemaphoreHandleDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\ntype\n=\ncudaExternalSemaphoreHandleTypeD3D12Fence\n;\ndesc\n.\nhandle\n.\nwin32\n.\nname\n=\n(\nvoid\n*\n)\nname\n;\ncudaImportExternalSemaphore\n(\n&\nextSem\n,\n&\ndesc\n);\nreturn\nextSem\n;\n}\n6.2.16.3.6.\nSignaling/Waiting on Imported Synchronization Objects\nï\nAn imported Direct3D 12 fence object can be signaled as shown below. Signaling such a fence object sets its value to the one specified. The corresponding wait that waits on this signal must be issued in Direct3D 12. Additionally, the wait that waits on this signal must be issued after this signal has been issued.\nvoid\nsignalExternalSemaphore\n(\ncudaExternalSemaphore_t\nextSem\n,\nunsigned\nlong\nlong\nvalue\n,\ncudaStream_t\nstream\n)\n{\ncudaExternalSemaphoreSignalParams\nparams\n=\n{};\nmemset\n(\n&\nparams\n,\n0\n,\nsizeof\n(\nparams\n));\nparams\n.\nparams\n.\nfence\n.\nvalue\n=\nvalue\n;\ncudaSignalExternalSemaphoresAsync\n(\n&\nextSem\n,\n&\nparams\n,\n1\n,\nstream\n);\n}\nAn imported Direct3D 12 fence object can be waited on as shown below. Waiting on such a fence object waits until its value becomes greater than or equal to the specified value. The corresponding signal that this wait is waiting on must be issued in Direct3D 12. Additionally, the signal must be issued before this wait can be issued.\nvoid\nwaitExternalSemaphore\n(\ncudaExternalSemaphore_t\nextSem\n,\nunsigned\nlong\nlong\nvalue\n,\ncudaStream_t\nstream\n)\n{\ncudaExternalSemaphoreWaitParams\nparams\n=\n{};\nmemset\n(\n&\nparams\n,\n0\n,\nsizeof\n(\nparams\n));\nparams\n.\nparams\n.\nfence\n.\nvalue\n=\nvalue\n;\ncudaWaitExternalSemaphoresAsync\n(\n&\nextSem\n,\n&\nparams\n,\n1\n,\nstream\n);\n}\n6.2.16.4.\nDirect3D 11 Interoperability\nï\n6.2.16.4.1.\nMatching Device LUIDs\nï\nWhen importing memory and synchronization objects exported by Direct3D 11, they must be imported and mapped on the same device as they were created on. The CUDA device that corresponds to the Direct3D 11 device on which the objects were created can be determined by comparing the LUID of a CUDA device with that of the Direct3D 11 device, as shown in the following code sample.\nint\ngetCudaDeviceForD3D11Device\n(\nID3D11Device\n*\nd3d11Device\n)\n{\nIDXGIDevice\n*\ndxgiDevice\n;\nd3d11Device\n->\nQueryInterface\n(\n__uuidof\n(\nIDXGIDevice\n),\n(\nvoid\n**\n)\n&\ndxgiDevice\n);\nIDXGIAdapter\n*\ndxgiAdapter\n;\ndxgiDevice\n->\nGetAdapter\n(\n&\ndxgiAdapter\n);\nDXGI_ADAPTER_DESC\ndxgiAdapterDesc\n;\ndxgiAdapter\n->\nGetDesc\n(\n&\ndxgiAdapterDesc\n);\nLUID\nd3d11Luid\n=\ndxgiAdapterDesc\n.\nAdapterLuid\n;\nint\ncudaDeviceCount\n;\ncudaGetDeviceCount\n(\n&\ncudaDeviceCount\n);\nfor\n(\nint\ncudaDevice\n=\n0\n;\ncudaDevice\n<\ncudaDeviceCount\n;\ncudaDevice\n++\n)\n{\ncudaDeviceProp\ndeviceProp\n;\ncudaGetDeviceProperties\n(\n&\ndeviceProp\n,\ncudaDevice\n);\nchar\n*\ncudaLuid\n=\ndeviceProp\n.\nluid\n;\nif\n(\n!\nmemcmp\n(\n&\nd3d11Luid\n.\nLowPart\n,\ncudaLuid\n,\nsizeof\n(\nd3d11Luid\n.\nLowPart\n))\n&&\n!\nmemcmp\n(\n&\nd3d11Luid\n.\nHighPart\n,\ncudaLuid\n+\nsizeof\n(\nd3d11Luid\n.\nLowPart\n),\nsizeof\n(\nd3d11Luid\n.\nHighPart\n)))\n{\nreturn\ncudaDevice\n;\n}\n}\nreturn\ncudaInvalidDeviceId\n;\n}\n6.2.16.4.2.\nImporting Memory Objects\nï\nA shareable Direct3D 11 texture resource, viz,\nID3D11Texture1D\n,\nID3D11Texture2D\nor\nID3D11Texture3D\n, can be created by setting either the\nD3D11_RESOURCE_MISC_SHARED\nor\nD3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX\n(on Windows 7) or\nD3D11_RESOURCE_MISC_SHARED_NTHANDLE\n(on Windows 10) when calling\nID3D11Device:CreateTexture1D\n,\nID3D11Device:CreateTexture2D\nor\nID3D11Device:CreateTexture3D\nrespectively. A shareable Direct3D 11 buffer resource,\nID3D11Buffer\n, can be created by specifying either of the above flags when calling\nID3D11Device::CreateBuffer\n. A shareable resource created by specifying the\nD3D11_RESOURCE_MISC_SHARED_NTHANDLE\ncan be imported into CUDA using the NT handle associated with that object as shown below. Note that it is the applicationâs responsibility to close the NT handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying memory can be freed. When importing a Direct3D 11 resource, the flag\ncudaExternalMemoryDedicated\nmust be set.\ncudaExternalMemory_t\nimportD3D11ResourceFromNTHandle\n(\nHANDLE\nhandle\n,\nunsigned\nlong\nlong\nsize\n)\n{\ncudaExternalMemory_t\nextMem\n=\nNULL\n;\ncudaExternalMemoryHandleDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\ntype\n=\ncudaExternalMemoryHandleTypeD3D11Resource\n;\ndesc\n.\nhandle\n.\nwin32\n.\nhandle\n=\n(\nvoid\n*\n)\nhandle\n;\ndesc\n.\nsize\n=\nsize\n;\ndesc\n.\nflags\n|=\ncudaExternalMemoryDedicated\n;\ncudaImportExternalMemory\n(\n&\nextMem\n,\n&\ndesc\n);\n// Input parameter 'handle' should be closed if it's not needed anymore\nCloseHandle\n(\nhandle\n);\nreturn\nextMem\n;\n}\nA shareable Direct3D 11 resource can also be imported using a named handle if one exists as shown below.\ncudaExternalMemory_t\nimportD3D11ResourceFromNamedNTHandle\n(\nLPCWSTR\nname\n,\nunsigned\nlong\nlong\nsize\n)\n{\ncudaExternalMemory_t\nextMem\n=\nNULL\n;\ncudaExternalMemoryHandleDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\ntype\n=\ncudaExternalMemoryHandleTypeD3D11Resource\n;\ndesc\n.\nhandle\n.\nwin32\n.\nname\n=\n(\nvoid\n*\n)\nname\n;\ndesc\n.\nsize\n=\nsize\n;\ndesc\n.\nflags\n|=\ncudaExternalMemoryDedicated\n;\ncudaImportExternalMemory\n(\n&\nextMem\n,\n&\ndesc\n);\nreturn\nextMem\n;\n}\nA shareable Direct3D 11 resource, created by specifying the\nD3D11_RESOURCE_MISC_SHARED\nor\nD3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX\n, can be imported into CUDA using the globally shared\nD3DKMT\nhandle associated with that object as shown below. Since a globally shared\nD3DKMT\nhandle does not hold a reference to the underlying memory it is automatically destroyed when all other references to the resource are destroyed.\ncudaExternalMemory_t\nimportD3D11ResourceFromKMTHandle\n(\nHANDLE\nhandle\n,\nunsigned\nlong\nlong\nsize\n)\n{\ncudaExternalMemory_t\nextMem\n=\nNULL\n;\ncudaExternalMemoryHandleDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\ntype\n=\ncudaExternalMemoryHandleTypeD3D11ResourceKmt\n;\ndesc\n.\nhandle\n.\nwin32\n.\nhandle\n=\n(\nvoid\n*\n)\nhandle\n;\ndesc\n.\nsize\n=\nsize\n;\ndesc\n.\nflags\n|=\ncudaExternalMemoryDedicated\n;\ncudaImportExternalMemory\n(\n&\nextMem\n,\n&\ndesc\n);\nreturn\nextMem\n;\n}\n6.2.16.4.3.\nMapping Buffers onto Imported Memory Objects\nï\nA device pointer can be mapped onto an imported memory object as shown below. The offset and size of the mapping must match that specified when creating the mapping using the corresponding Direct3D 11 API. All mapped device pointers must be freed using\ncudaFree()\n.\nvoid\n*\nmapBufferOntoExternalMemory\n(\ncudaExternalMemory_t\nextMem\n,\nunsigned\nlong\nlong\noffset\n,\nunsigned\nlong\nlong\nsize\n)\n{\nvoid\n*\nptr\n=\nNULL\n;\ncudaExternalMemoryBufferDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\noffset\n=\noffset\n;\ndesc\n.\nsize\n=\nsize\n;\ncudaExternalMemoryGetMappedBuffer\n(\n&\nptr\n,\nextMem\n,\n&\ndesc\n);\n// Note: âptrâ must eventually be freed using cudaFree()\nreturn\nptr\n;\n}\n6.2.16.4.4.\nMapping Mipmapped Arrays onto Imported Memory Objects\nï\nA CUDA mipmapped array can be mapped onto an imported memory object as shown below. The offset, dimensions, format and number of mip levels must match that specified when creating the mapping using the corresponding Direct3D 11 API. Additionally, if the mipmapped array can be bound as a render target in Direct3D 12, the flag\ncudaArrayColorAttachment\nmust be set. All mapped mipmapped arrays must be freed using\ncudaFreeMipmappedArray()\n. The following code sample shows how to convert Direct3D 11 parameters into the corresponding CUDA parameters when mapping mipmapped arrays onto imported memory objects.\ncudaMipmappedArray_t\nmapMipmappedArrayOntoExternalMemory\n(\ncudaExternalMemory_t\nextMem\n,\nunsigned\nlong\nlong\noffset\n,\ncudaChannelFormatDesc\n*\nformatDesc\n,\ncudaExtent\n*\nextent\n,\nunsigned\nint\nflags\n,\nunsigned\nint\nnumLevels\n)\n{\ncudaMipmappedArray_t\nmipmap\n=\nNULL\n;\ncudaExternalMemoryMipmappedArrayDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\noffset\n=\noffset\n;\ndesc\n.\nformatDesc\n=\n*\nformatDesc\n;\ndesc\n.\nextent\n=\n*\nextent\n;\ndesc\n.\nflags\n=\nflags\n;\ndesc\n.\nnumLevels\n=\nnumLevels\n;\n// Note: 'mipmap' must eventually be freed using cudaFreeMipmappedArray()\ncudaExternalMemoryGetMappedMipmappedArray\n(\n&\nmipmap\n,\nextMem\n,\n&\ndesc\n);\nreturn\nmipmap\n;\n}\ncudaChannelFormatDesc\ngetCudaChannelFormatDescForDxgiFormat\n(\nDXGI_FORMAT\ndxgiFormat\n)\n{\ncudaChannelFormatDesc\nd\n;\nmemset\n(\n&\nd\n,\n0\n,\nsizeof\n(\nd\n));\nswitch\n(\ndxgiFormat\n)\n{\ncase\nDXGI_FORMAT_R8_UINT\n:\nd\n.\nx\n=\n8\n;\nd\n.\ny\n=\n0\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R8_SINT\n:\nd\n.\nx\n=\n8\n;\nd\n.\ny\n=\n0\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R8G8_UINT\n:\nd\n.\nx\n=\n8\n;\nd\n.\ny\n=\n8\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R8G8_SINT\n:\nd\n.\nx\n=\n8\n;\nd\n.\ny\n=\n8\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R8G8B8A8_UINT\n:\nd\n.\nx\n=\n8\n;\nd\n.\ny\n=\n8\n;\nd\n.\nz\n=\n8\n;\nd\n.\nw\n=\n8\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R8G8B8A8_SINT\n:\nd\n.\nx\n=\n8\n;\nd\n.\ny\n=\n8\n;\nd\n.\nz\n=\n8\n;\nd\n.\nw\n=\n8\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R16_UINT\n:\nd\n.\nx\n=\n16\n;\nd\n.\ny\n=\n0\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R16_SINT\n:\nd\n.\nx\n=\n16\n;\nd\n.\ny\n=\n0\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R16G16_UINT\n:\nd\n.\nx\n=\n16\n;\nd\n.\ny\n=\n16\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R16G16_SINT\n:\nd\n.\nx\n=\n16\n;\nd\n.\ny\n=\n16\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R16G16B16A16_UINT\n:\nd\n.\nx\n=\n16\n;\nd\n.\ny\n=\n16\n;\nd\n.\nz\n=\n16\n;\nd\n.\nw\n=\n16\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R16G16B16A16_SINT\n:\nd\n.\nx\n=\n16\n;\nd\n.\ny\n=\n16\n;\nd\n.\nz\n=\n16\n;\nd\n.\nw\n=\n16\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R32_UINT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n0\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R32_SINT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n0\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R32_FLOAT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n0\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindFloat\n;\nbreak\n;\ncase\nDXGI_FORMAT_R32G32_UINT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n32\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R32G32_SINT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n32\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R32G32_FLOAT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n32\n;\nd\n.\nz\n=\n0\n;\nd\n.\nw\n=\n0\n;\nd\n.\nf\n=\ncudaChannelFormatKindFloat\n;\nbreak\n;\ncase\nDXGI_FORMAT_R32G32B32A32_UINT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n32\n;\nd\n.\nz\n=\n32\n;\nd\n.\nw\n=\n32\n;\nd\n.\nf\n=\ncudaChannelFormatKindUnsigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R32G32B32A32_SINT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n32\n;\nd\n.\nz\n=\n32\n;\nd\n.\nw\n=\n32\n;\nd\n.\nf\n=\ncudaChannelFormatKindSigned\n;\nbreak\n;\ncase\nDXGI_FORMAT_R32G32B32A32_FLOAT\n:\nd\n.\nx\n=\n32\n;\nd\n.\ny\n=\n32\n;\nd\n.\nz\n=\n32\n;\nd\n.\nw\n=\n32\n;\nd\n.\nf\n=\ncudaChannelFormatKindFloat\n;\nbreak\n;\ndefault\n:\nassert\n(\n0\n);\n}\nreturn\nd\n;\n}\ncudaExtent\ngetCudaExtentForD3D11Extent\n(\nUINT64\nwidth\n,\nUINT\nheight\n,\nUINT16\ndepthOrArraySize\n,\nD3D12_SRV_DIMENSION\nd3d11SRVDimension\n)\n{\ncudaExtent\ne\n=\n{\n0\n,\n0\n,\n0\n};\nswitch\n(\nd3d11SRVDimension\n)\n{\ncase\nD3D11_SRV_DIMENSION_TEXTURE1D\n:\ne\n.\nwidth\n=\nwidth\n;\ne\n.\nheight\n=\n0\n;\ne\n.\ndepth\n=\n0\n;\nbreak\n;\ncase\nD3D11_SRV_DIMENSION_TEXTURE2D\n:\ne\n.\nwidth\n=\nwidth\n;\ne\n.\nheight\n=\nheight\n;\ne\n.\ndepth\n=\n0\n;\nbreak\n;\ncase\nD3D11_SRV_DIMENSION_TEXTURE3D\n:\ne\n.\nwidth\n=\nwidth\n;\ne\n.\nheight\n=\nheight\n;\ne\n.\ndepth\n=\ndepthOrArraySize\n;\nbreak\n;\ncase\nD3D11_SRV_DIMENSION_TEXTURECUBE\n:\ne\n.\nwidth\n=\nwidth\n;\ne\n.\nheight\n=\nheight\n;\ne\n.\ndepth\n=\ndepthOrArraySize\n;\nbreak\n;\ncase\nD3D11_SRV_DIMENSION_TEXTURE1DARRAY\n:\ne\n.\nwidth\n=\nwidth\n;\ne\n.\nheight\n=\n0\n;\ne\n.\ndepth\n=\ndepthOrArraySize\n;\nbreak\n;\ncase\nD3D11_SRV_DIMENSION_TEXTURE2DARRAY\n:\ne\n.\nwidth\n=\nwidth\n;\ne\n.\nheight\n=\nheight\n;\ne\n.\ndepth\n=\ndepthOrArraySize\n;\nbreak\n;\ncase\nD3D11_SRV_DIMENSION_TEXTURECUBEARRAY\n:\ne\n.\nwidth\n=\nwidth\n;\ne\n.\nheight\n=\nheight\n;\ne\n.\ndepth\n=\ndepthOrArraySize\n;\nbreak\n;\ndefault\n:\nassert\n(\n0\n);\n}\nreturn\ne\n;\n}\nunsigned\nint\ngetCudaMipmappedArrayFlagsForD3D12Resource\n(\nD3D11_SRV_DIMENSION\nd3d11SRVDimension\n,\nD3D11_BIND_FLAG\nd3d11BindFlags\n,\nbool\nallowSurfaceLoadStore\n)\n{\nunsigned\nint\nflags\n=\n0\n;\nswitch\n(\nd3d11SRVDimension\n)\n{\ncase\nD3D11_SRV_DIMENSION_TEXTURECUBE\n:\nflags\n|=\ncudaArrayCubemap\n;\nbreak\n;\ncase\nD3D11_SRV_DIMENSION_TEXTURECUBEARRAY\n:\nflags\n|=\ncudaArrayCubemap\n|\ncudaArrayLayered\n;\nbreak\n;\ncase\nD3D11_SRV_DIMENSION_TEXTURE1DARRAY\n:\nflags\n|=\ncudaArrayLayered\n;\nbreak\n;\ncase\nD3D11_SRV_DIMENSION_TEXTURE2DARRAY\n:\nflags\n|=\ncudaArrayLayered\n;\nbreak\n;\ndefault\n:\nbreak\n;\n}\nif\n(\nd3d11BindFlags\n&\nD3D11_BIND_RENDER_TARGET\n)\n{\nflags\n|=\ncudaArrayColorAttachment\n;\n}\nif\n(\nallowSurfaceLoadStore\n)\n{\nflags\n|=\ncudaArraySurfaceLoadStore\n;\n}\nreturn\nflags\n;\n}\n6.2.16.4.5.\nImporting Synchronization Objects\nï\nA shareable Direct3D 11 fence object, created by setting the flag\nD3D11_FENCE_FLAG_SHARED\nin the call to\nID3D11Device5::CreateFence\n, can be imported into CUDA using the NT handle associated with that object as shown below. Note that it is the applicationâs responsibility to close the handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying semaphore can be freed.\ncudaExternalSemaphore_t\nimportD3D11FenceFromNTHandle\n(\nHANDLE\nhandle\n)\n{\ncudaExternalSemaphore_t\nextSem\n=\nNULL\n;\ncudaExternalSemaphoreHandleDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\ntype\n=\ncudaExternalSemaphoreHandleTypeD3D11Fence\n;\ndesc\n.\nhandle\n.\nwin32\n.\nhandle\n=\nhandle\n;\ncudaImportExternalSemaphore\n(\n&\nextSem\n,\n&\ndesc\n);\n// Input parameter 'handle' should be closed if it's not needed anymore\nCloseHandle\n(\nhandle\n);\nreturn\nextSem\n;\n}\nA shareable Direct3D 11 fence object can also be imported using a named handle if one exists as shown below.\ncudaExternalSemaphore_t\nimportD3D11FenceFromNamedNTHandle\n(\nLPCWSTR\nname\n)\n{\ncudaExternalSemaphore_t\nextSem\n=\nNULL\n;\ncudaExternalSemaphoreHandleDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\ntype\n=\ncudaExternalSemaphoreHandleTypeD3D11Fence\n;\ndesc\n.\nhandle\n.\nwin32\n.\nname\n=\n(\nvoid\n*\n)\nname\n;\ncudaImportExternalSemaphore\n(\n&\nextSem\n,\n&\ndesc\n);\nreturn\nextSem\n;\n}\nA shareable Direct3D 11 keyed mutex object associated with a shareable Direct3D 11 resource, viz,\nIDXGIKeyedMutex\n, created by setting the flag\nD3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX\n, can be imported into CUDA using the NT handle associated with that object as shown below. Note that it is the applicationâs responsibility to close the handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying semaphore can be freed.\ncudaExternalSemaphore_t\nimportD3D11KeyedMutexFromNTHandle\n(\nHANDLE\nhandle\n)\n{\ncudaExternalSemaphore_t\nextSem\n=\nNULL\n;\ncudaExternalSemaphoreHandleDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\ntype\n=\ncudaExternalSemaphoreHandleTypeKeyedMutex\n;\ndesc\n.\nhandle\n.\nwin32\n.\nhandle\n=\nhandle\n;\ncudaImportExternalSemaphore\n(\n&\nextSem\n,\n&\ndesc\n);\n// Input parameter 'handle' should be closed if it's not needed anymore\nCloseHandle\n(\nhandle\n);\nreturn\nextSem\n;\n}\nA shareable Direct3D 11 keyed mutex object can also be imported using a named handle if one exists as shown below.\ncudaExternalSemaphore_t\nimportD3D11KeyedMutexFromNamedNTHandle\n(\nLPCWSTR\nname\n)\n{\ncudaExternalSemaphore_t\nextSem\n=\nNULL\n;\ncudaExternalSemaphoreHandleDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\ntype\n=\ncudaExternalSemaphoreHandleTypeKeyedMutex\n;\ndesc\n.\nhandle\n.\nwin32\n.\nname\n=\n(\nvoid\n*\n)\nname\n;\ncudaImportExternalSemaphore\n(\n&\nextSem\n,\n&\ndesc\n);\nreturn\nextSem\n;\n}\nA shareable Direct3D 11 keyed mutex object can be imported into CUDA using the globally shared D3DKMT handle associated with that object as shown below. Since a globally shared D3DKMT handle does not hold a reference to the underlying memory it is automatically destroyed when all other references to the resource are destroyed.\ncudaExternalSemaphore_t\nimportD3D11FenceFromKMTHandle\n(\nHANDLE\nhandle\n)\n{\ncudaExternalSemaphore_t\nextSem\n=\nNULL\n;\ncudaExternalSemaphoreHandleDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\ntype\n=\ncudaExternalSemaphoreHandleTypeKeyedMutexKmt\n;\ndesc\n.\nhandle\n.\nwin32\n.\nhandle\n=\nhandle\n;\ncudaImportExternalSemaphore\n(\n&\nextSem\n,\n&\ndesc\n);\n// Input parameter 'handle' should be closed if it's not needed anymore\nCloseHandle\n(\nhandle\n);\nreturn\nextSem\n;\n}\n6.2.16.4.6.\nSignaling/Waiting on Imported Synchronization Objects\nï\nAn imported Direct3D 11 fence object can be signaled as shown below. Signaling such a fence object sets its value to the one specified. The corresponding wait that waits on this signal must be issued in Direct3D 11. Additionally, the wait that waits on this signal must be issued after this signal has been issued.\nvoid\nsignalExternalSemaphore\n(\ncudaExternalSemaphore_t\nextSem\n,\nunsigned\nlong\nlong\nvalue\n,\ncudaStream_t\nstream\n)\n{\ncudaExternalSemaphoreSignalParams\nparams\n=\n{};\nmemset\n(\n&\nparams\n,\n0\n,\nsizeof\n(\nparams\n));\nparams\n.\nparams\n.\nfence\n.\nvalue\n=\nvalue\n;\ncudaSignalExternalSemaphoresAsync\n(\n&\nextSem\n,\n&\nparams\n,\n1\n,\nstream\n);\n}\nAn imported Direct3D 11 fence object can be waited on as shown below. Waiting on such a fence object waits until its value becomes greater than or equal to the specified value. The corresponding signal that this wait is waiting on must be issued in Direct3D 11. Additionally, the signal must be issued before this wait can be issued.\nvoid\nwaitExternalSemaphore\n(\ncudaExternalSemaphore_t\nextSem\n,\nunsigned\nlong\nlong\nvalue\n,\ncudaStream_t\nstream\n)\n{\ncudaExternalSemaphoreWaitParams\nparams\n=\n{};\nmemset\n(\n&\nparams\n,\n0\n,\nsizeof\n(\nparams\n));\nparams\n.\nparams\n.\nfence\n.\nvalue\n=\nvalue\n;\ncudaWaitExternalSemaphoresAsync\n(\n&\nextSem\n,\n&\nparams\n,\n1\n,\nstream\n);\n}\nAn imported Direct3D 11 keyed mutex object can be signaled as shown below. Signaling such a keyed mutex object by specifying a key value releases the keyed mutex for that value. The corresponding wait that waits on this signal must be issued in Direct3D 11 with the same key value. Additionally, the Direct3D 11 wait must be issued after this signal has been issued.\nvoid\nsignalExternalSemaphore\n(\ncudaExternalSemaphore_t\nextSem\n,\nunsigned\nlong\nlong\nkey\n,\ncudaStream_t\nstream\n)\n{\ncudaExternalSemaphoreSignalParams\nparams\n=\n{};\nmemset\n(\n&\nparams\n,\n0\n,\nsizeof\n(\nparams\n));\nparams\n.\nparams\n.\nkeyedmutex\n.\nkey\n=\nkey\n;\ncudaSignalExternalSemaphoresAsync\n(\n&\nextSem\n,\n&\nparams\n,\n1\n,\nstream\n);\n}\nAn imported Direct3D 11 keyed mutex object can be waited on as shown below. A timeout value in milliseconds is needed when waiting on such a keyed mutex. The wait operation waits until the keyed mutex value is equal to the specified key value or until the timeout has elapsed. The timeout interval can also be an infinite value. In case an infinite value is specified the timeout never elapses. The windows INFINITE macro must be used to specify an infinite timeout. The corresponding signal that this wait is waiting on must be issued in Direct3D 11. Additionally, the Direct3D 11 signal must be issued before this wait can be issued.\nvoid\nwaitExternalSemaphore\n(\ncudaExternalSemaphore_t\nextSem\n,\nunsigned\nlong\nlong\nkey\n,\nunsigned\nint\ntimeoutMs\n,\ncudaStream_t\nstream\n)\n{\ncudaExternalSemaphoreWaitParams\nparams\n=\n{};\nmemset\n(\n&\nparams\n,\n0\n,\nsizeof\n(\nparams\n));\nparams\n.\nparams\n.\nkeyedmutex\n.\nkey\n=\nkey\n;\nparams\n.\nparams\n.\nkeyedmutex\n.\ntimeoutMs\n=\ntimeoutMs\n;\ncudaWaitExternalSemaphoresAsync\n(\n&\nextSem\n,\n&\nparams\n,\n1\n,\nstream\n);\n}\n6.2.16.5.\nNVIDIA Software Communication Interface Interoperability (NVSCI)\nï\nNvSciBuf and NvSciSync are interfaces developed for serving the following purposes:\nNvSciBuf: Allows applications to allocate and exchange buffers in memory\nNvSciSync: Allows applications to manage synchronization objects at operation boundaries\nMore details on these interfaces are available at:\nhttps://docs.nvidia.com/drive\n.\n6.2.16.5.1.\nImporting Memory Objects\nï\nFor allocating an NvSciBuf object compatible with a given CUDA device, the corresponding GPU id must be set with\nNvSciBufGeneralAttrKey_GpuId\nin the NvSciBuf attribute list as shown below. Optionally, applications can specify the following attributes -\nNvSciBufGeneralAttrKey_NeedCpuAccess\n: Specifies if CPU access is required for the buffer\nNvSciBufRawBufferAttrKey_Align\n: Specifies the alignment requirement of\nNvSciBufType_RawBuffer\nNvSciBufGeneralAttrKey_RequiredPerm\n: Different access permissions can be configured for different UMDs per NvSciBuf memory object instance. For example, to provide the GPU with read-only access permissions to the buffer, create a duplicate NvSciBuf object using\nNvSciBufObjDupWithReducePerm()\nwith\nNvSciBufAccessPerm_Readonly\nas the input parameter. Then import this newly created duplicate object with reduced permission into CUDA as shown\nNvSciBufGeneralAttrKey_EnableGpuCache\n: To control GPU L2 cacheability\nNvSciBufGeneralAttrKey_EnableGpuCompression\n: To specify GPU compression\nNote\nFor more details on these attributes and their valid input options, refer to NvSciBuf Documentation.\nThe following code snippet illustrates their sample usage.\nNvSciBufObj\ncreateNvSciBufObject\n()\n{\n// Raw Buffer Attributes for CUDA\nNvSciBufType\nbufType\n=\nNvSciBufType_RawBuffer\n;\nuint64_t\nrawsize\n=\nSIZE\n;\nuint64_t\nalign\n=\n0\n;\nbool\ncpuaccess_flag\n=\ntrue\n;\nNvSciBufAttrValAccessPerm\nperm\n=\nNvSciBufAccessPerm_ReadWrite\n;\nNvSciRmGpuId\ngpuid\n[]\n=\n{};\nCUuuid\nuuid\n;\ncuDeviceGetUuid\n(\n&\nuuid\n,\ndev\n));\nmemcpy\n(\n&\ngpuid\n[\n0\n].\nbytes\n,\n&\nuuid\n.\nbytes\n,\nsizeof\n(\nuuid\n.\nbytes\n));\n// Disable cache on dev\nNvSciBufAttrValGpuCache\ngpuCache\n[]\n=\n{{\ngpuid\n[\n0\n],\nfalse\n}};\nNvSciBufAttrValGpuCompression\ngpuCompression\n[]\n=\n{{\ngpuid\n[\n0\n],\nNvSciBufCompressionType_GenericCompressible\n}};\n// Fill in values\nNvSciBufAttrKeyValuePair\nrawbuffattrs\n[]\n=\n{\n{\nNvSciBufGeneralAttrKey_Types\n,\n&\nbufType\n,\nsizeof\n(\nbufType\n)\n},\n{\nNvSciBufRawBufferAttrKey_Size\n,\n&\nrawsize\n,\nsizeof\n(\nrawsize\n)\n},\n{\nNvSciBufRawBufferAttrKey_Align\n,\n&\nalign\n,\nsizeof\n(\nalign\n)\n},\n{\nNvSciBufGeneralAttrKey_NeedCpuAccess\n,\n&\ncpuaccess_flag\n,\nsizeof\n(\ncpuaccess_flag\n)\n},\n{\nNvSciBufGeneralAttrKey_RequiredPerm\n,\n&\nperm\n,\nsizeof\n(\nperm\n)\n},\n{\nNvSciBufGeneralAttrKey_GpuId\n,\n&\ngpuid\n,\nsizeof\n(\ngpuid\n)\n},\n{\nNvSciBufGeneralAttrKey_EnableGpuCache\n&\ngpuCache\n,\nsizeof\n(\ngpuCache\n)\n},\n{\nNvSciBufGeneralAttrKey_EnableGpuCompression\n&\ngpuCompression\n,\nsizeof\n(\ngpuCompression\n)\n}\n};\n// Create list by setting attributes\nerr\n=\nNvSciBufAttrListSetAttrs\n(\nattrListBuffer\n,\nrawbuffattrs\n,\nsizeof\n(\nrawbuffattrs\n)\n/\nsizeof\n(\nNvSciBufAttrKeyValuePair\n));\nNvSciBufAttrListCreate\n(\nNvSciBufModule\n,\n&\nattrListBuffer\n);\n// Reconcile And Allocate\nNvSciBufAttrListReconcile\n(\n&\nattrListBuffer\n,\n1\n,\n&\nattrListReconciledBuffer\n,\n&\nattrListConflictBuffer\n)\nNvSciBufObjAlloc\n(\nattrListReconciledBuffer\n,\n&\nbufferObjRaw\n);\nreturn\nbufferObjRaw\n;\n}\nNvSciBufObj\nbufferObjRo\n;\n// Readonly NvSciBuf memory obj\n// Create a duplicate handle to the same memory buffer with reduced permissions\nNvSciBufObjDupWithReducePerm\n(\nbufferObjRaw\n,\nNvSciBufAccessPerm_Readonly\n,\n&\nbufferObjRo\n);\nreturn\nbufferObjRo\n;\nThe allocated NvSciBuf memory object can be imported in CUDA using the NvSciBufObj handle as shown below. Application should query the allocated NvSciBufObj for attributes required for filling CUDA External Memory Descriptor. Note that the attribute list and NvSciBuf objects should be maintained by the application. If the NvSciBuf object imported into CUDA is also mapped by other drivers, then based on\nNvSciBufGeneralAttrKey_GpuSwNeedCacheCoherency\noutput attribute value the application must use NvSciSync objects (refer to\nImporting Synchronization Objects\n) as appropriate barriers to maintain coherence between CUDA and the other drivers.\nNote\nFor more details on how to allocate and maintain NvSciBuf objects refer to NvSciBuf API Documentation.\ncudaExternalMemory_t\nimportNvSciBufObject\n(\nNvSciBufObj\nbufferObjRaw\n)\n{\n/*************** Query NvSciBuf Object **************/\nNvSciBufAttrKeyValuePair\nbufattrs\n[]\n=\n{\n{\nNvSciBufRawBufferAttrKey_Size\n,\nNULL\n,\n0\n},\n{\nNvSciBufGeneralAttrKey_GpuSwNeedCacheCoherency\n,\nNULL\n,\n0\n},\n{\nNvSciBufGeneralAttrKey_EnableGpuCompression\n,\nNULL\n,\n0\n}\n};\nNvSciBufAttrListGetAttrs\n(\nretList\n,\nbufattrs\n,\nsizeof\n(\nbufattrs\n)\n/\nsizeof\n(\nNvSciBufAttrKeyValuePair\n)));\nret_size\n=\n*\n(\nstatic_cast\n<\nconst\nuint64_t\n*>\n(\nbufattrs\n[\n0\n].\nvalue\n));\n// Note cache and compression are per GPU attributes, so read values for specific gpu by comparing UUID\n// Read cacheability granted by NvSciBuf\nint\nnumGpus\n=\nbufattrs\n[\n1\n].\nlen\n/\nsizeof\n(\nNvSciBufAttrValGpuCache\n);\nNvSciBufAttrValGpuCache\n[]\ncacheVal\n=\n(\nNvSciBufAttrValGpuCache\n*\n)\nbufattrs\n[\n1\n].\nvalue\n;\nbool\nret_cacheVal\n;\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nnumGpus\n;\ni\n++\n)\n{\nif\n(\nmemcmp\n(\ngpuid\n[\n0\n].\nbytes\n,\ncacheVal\n[\ni\n].\ngpuId\n.\nbytes\n,\nsizeof\n(\nCUuuid\n))\n==\n0\n)\n{\nret_cacheVal\n=\ncacheVal\n[\ni\n].\ncacheability\n);\n}\n}\n// Read compression granted by NvSciBuf\nnumGpus\n=\nbufattrs\n[\n2\n].\nlen\n/\nsizeof\n(\nNvSciBufAttrValGpuCompression\n);\nNvSciBufAttrValGpuCompression\n[]\ncompVal\n=\n(\nNvSciBufAttrValGpuCompression\n*\n)\nbufattrs\n[\n2\n].\nvalue\n;\nNvSciBufCompressionType\nret_compVal\n;\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nnumGpus\n;\ni\n++\n)\n{\nif\n(\nmemcmp\n(\ngpuid\n[\n0\n].\nbytes\n,\ncompVal\n[\ni\n].\ngpuId\n.\nbytes\n,\nsizeof\n(\nCUuuid\n))\n==\n0\n)\n{\nret_compVal\n=\ncompVal\n[\ni\n].\ncompressionType\n);\n}\n}\n/*************** NvSciBuf Registration With CUDA **************/\n// Fill up CUDA_EXTERNAL_MEMORY_HANDLE_DESC\ncudaExternalMemoryHandleDesc\nmemHandleDesc\n;\nmemset\n(\n&\nmemHandleDesc\n,\n0\n,\nsizeof\n(\nmemHandleDesc\n));\nmemHandleDesc\n.\ntype\n=\ncudaExternalMemoryHandleTypeNvSciBuf\n;\nmemHandleDesc\n.\nhandle\n.\nnvSciBufObject\n=\nbufferObjRaw\n;\n// Set the NvSciBuf object with required access permissions in this step\nmemHandleDesc\n.\nhandle\n.\nnvSciBufObject\n=\nbufferObjRo\n;\nmemHandleDesc\n.\nsize\n=\nret_size\n;\ncudaImportExternalMemory\n(\n&\nextMemBuffer\n,\n&\nmemHandleDesc\n);\nreturn\nextMemBuffer\n;\n}\n6.2.16.5.2.\nMapping Buffers onto Imported Memory Objects\nï\nA device pointer can be mapped onto an imported memory object as shown below. The offset and size of the mapping can be filled as per the attributes of the allocated\nNvSciBufObj\n. All mapped device pointers must be freed using\ncudaFree()\n.\nvoid\n*\nmapBufferOntoExternalMemory\n(\ncudaExternalMemory_t\nextMem\n,\nunsigned\nlong\nlong\noffset\n,\nunsigned\nlong\nlong\nsize\n)\n{\nvoid\n*\nptr\n=\nNULL\n;\ncudaExternalMemoryBufferDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\noffset\n=\noffset\n;\ndesc\n.\nsize\n=\nsize\n;\ncudaExternalMemoryGetMappedBuffer\n(\n&\nptr\n,\nextMem\n,\n&\ndesc\n);\n// Note: 'ptr' must eventually be freed using cudaFree()\nreturn\nptr\n;\n}\n6.2.16.5.3.\nMapping Mipmapped Arrays onto Imported Memory Objects\nï\nA CUDA mipmapped array can be mapped onto an imported memory object as shown below. The offset, dimensions and format can be filled as per the attributes of the allocated\nNvSciBufObj\n. All mapped mipmapped arrays must be freed using\ncudaFreeMipmappedArray()\n. The following code sample shows how to convert NvSciBuf attributes into the corresponding CUDA parameters when mapping mipmapped arrays onto imported memory objects.\nNote\nThe number of mip levels must be 1.\ncudaMipmappedArray_t\nmapMipmappedArrayOntoExternalMemory\n(\ncudaExternalMemory_t\nextMem\n,\nunsigned\nlong\nlong\noffset\n,\ncudaChannelFormatDesc\n*\nformatDesc\n,\ncudaExtent\n*\nextent\n,\nunsigned\nint\nflags\n,\nunsigned\nint\nnumLevels\n)\n{\ncudaMipmappedArray_t\nmipmap\n=\nNULL\n;\ncudaExternalMemoryMipmappedArrayDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\noffset\n=\noffset\n;\ndesc\n.\nformatDesc\n=\n*\nformatDesc\n;\ndesc\n.\nextent\n=\n*\nextent\n;\ndesc\n.\nflags\n=\nflags\n;\ndesc\n.\nnumLevels\n=\nnumLevels\n;\n// Note: 'mipmap' must eventually be freed using cudaFreeMipmappedArray()\ncudaExternalMemoryGetMappedMipmappedArray\n(\n&\nmipmap\n,\nextMem\n,\n&\ndesc\n);\nreturn\nmipmap\n;\n}\n6.2.16.5.4.\nImporting Synchronization Objects\nï\nNvSciSync attributes that are compatible with a given CUDA device can be generated using\ncudaDeviceGetNvSciSyncAttributes()\n. The returned attribute list can be used to create a\nNvSciSyncObj\nthat is guaranteed compatibility with a given CUDA device.\nNvSciSyncObj\ncreateNvSciSyncObject\n()\n{\nNvSciSyncObj\nnvSciSyncObj\nint\ncudaDev0\n=\n0\n;\nint\ncudaDev1\n=\n1\n;\nNvSciSyncAttrList\nsignalerAttrList\n=\nNULL\n;\nNvSciSyncAttrList\nwaiterAttrList\n=\nNULL\n;\nNvSciSyncAttrList\nreconciledList\n=\nNULL\n;\nNvSciSyncAttrList\nnewConflictList\n=\nNULL\n;\nNvSciSyncAttrListCreate\n(\nmodule\n,\n&\nsignalerAttrList\n);\nNvSciSyncAttrListCreate\n(\nmodule\n,\n&\nwaiterAttrList\n);\nNvSciSyncAttrList\nunreconciledList\n[\n2\n]\n=\n{\nNULL\n,\nNULL\n};\nunreconciledList\n[\n0\n]\n=\nsignalerAttrList\n;\nunreconciledList\n[\n1\n]\n=\nwaiterAttrList\n;\ncudaDeviceGetNvSciSyncAttributes\n(\nsignalerAttrList\n,\ncudaDev0\n,\nCUDA_NVSCISYNC_ATTR_SIGNAL\n);\ncudaDeviceGetNvSciSyncAttributes\n(\nwaiterAttrList\n,\ncudaDev1\n,\nCUDA_NVSCISYNC_ATTR_WAIT\n);\nNvSciSyncAttrListReconcile\n(\nunreconciledList\n,\n2\n,\n&\nreconciledList\n,\n&\nnewConflictList\n);\nNvSciSyncObjAlloc\n(\nreconciledList\n,\n&\nnvSciSyncObj\n);\nreturn\nnvSciSyncObj\n;\n}\nAn NvSciSync object (created as above) can be imported into CUDA using the NvSciSyncObj handle as shown below. Note that ownership of the NvSciSyncObj handle continues to lie with the application even after it is imported.\ncudaExternalSemaphore_t\nimportNvSciSyncObject\n(\nvoid\n*\nnvSciSyncObj\n)\n{\ncudaExternalSemaphore_t\nextSem\n=\nNULL\n;\ncudaExternalSemaphoreHandleDesc\ndesc\n=\n{};\nmemset\n(\n&\ndesc\n,\n0\n,\nsizeof\n(\ndesc\n));\ndesc\n.\ntype\n=\ncudaExternalSemaphoreHandleTypeNvSciSync\n;\ndesc\n.\nhandle\n.\nnvSciSyncObj\n=\nnvSciSyncObj\n;\ncudaImportExternalSemaphore\n(\n&\nextSem\n,\n&\ndesc\n);\n// Deleting/Freeing the nvSciSyncObj beyond this point will lead to undefined behavior in CUDA\nreturn\nextSem\n;\n}\n6.2.16.5.5.\nSignaling/Waiting on Imported Synchronization Objects\nï\nAn imported\nNvSciSyncObj\nobject can be signaled as outlined below. Signaling NvSciSync backed semaphore object initializes the\nfence\nparameter passed as input. This fence parameter is waited upon by a wait operation that corresponds to the aforementioned signal. Additionally, the wait that waits on this signal must be issued after this signal has been issued. If the flags are set to\ncudaExternalSemaphoreSignalSkipNvSciBufMemSync\nthen memory synchronization operations (over all the imported NvSciBuf in this process) that are executed as a part of the signal operation by default are skipped. When\nNvsciBufGeneralAttrKey_GpuSwNeedCacheCoherency\nis FALSE, this flag should be set.\nvoid\nsignalExternalSemaphore\n(\ncudaExternalSemaphore_t\nextSem\n,\ncudaStream_t\nstream\n,\nvoid\n*\nfence\n)\n{\ncudaExternalSemaphoreSignalParams\nsignalParams\n=\n{};\nmemset\n(\n&\nsignalParams\n,\n0\n,\nsizeof\n(\nsignalParams\n));\nsignalParams\n.\nparams\n.\nnvSciSync\n.\nfence\n=\n(\nvoid\n*\n)\nfence\n;\nsignalParams\n.\nflags\n=\n0\n;\n//OR cudaExternalSemaphoreSignalSkipNvSciBufMemSync\ncudaSignalExternalSemaphoresAsync\n(\n&\nextSem\n,\n&\nsignalParams\n,\n1\n,\nstream\n);\n}\nAn imported\nNvSciSyncObj\nobject can be waited upon as outlined below. Waiting on NvSciSync backed semaphore object waits until the input\nfence\nparameter is signaled by the corresponding signaler. Additionally, the signal must be issued before the wait can be issued. If the flags are set to\ncudaExternalSemaphoreWaitSkipNvSciBufMemSync\nthen memory synchronization operations (over all the imported NvSciBuf in this process) that are executed as a part of the signal operation by default are skipped. When\nNvsciBufGeneralAttrKey_GpuSwNeedCacheCoherency\nis FALSE, this flag should be set.\nvoid\nwaitExternalSemaphore\n(\ncudaExternalSemaphore_t\nextSem\n,\ncudaStream_t\nstream\n,\nvoid\n*\nfence\n)\n{\ncudaExternalSemaphoreWaitParams\nwaitParams\n=\n{};\nmemset\n(\n&\nwaitParams\n,\n0\n,\nsizeof\n(\nwaitParams\n));\nwaitParams\n.\nparams\n.\nnvSciSync\n.\nfence\n=\n(\nvoid\n*\n)\nfence\n;\nwaitParams\n.\nflags\n=\n0\n;\n//OR cudaExternalSemaphoreWaitSkipNvSciBufMemSync\ncudaWaitExternalSemaphoresAsync\n(\n&\nextSem\n,\n&\nwaitParams\n,\n1\n,\nstream\n);\n}\n6.3.\nVersioning and Compatibility\nï\nThere are two version numbers that developers should care about when developing a CUDA application: The compute capability that describes the general specifications and features of the compute device (see\nCompute Capability\n) and the version of the CUDA driver API that describes the features supported by the driver API and runtime.\nThe version of the driver API is defined in the driver header file as\nCUDA_VERSION\n. It allows developers to check whether their application requires a newer device driver than the one currently installed. This is important, because the driver API is\nbackward compatible\n, meaning that applications, plug-ins, and libraries (including the CUDA runtime) compiled against a particular version of the driver API will continue to work on subsequent device driver releases as illustrated in\nFigure 26\n. The driver API is not\nforward compatible\n, which means that applications, plug-ins, and libraries (including the CUDA runtime) compiled against a particular version of the driver API will not work on previous versions of the device driver.\nIt is important to note that there are limitations on the mixing and matching of versions that is supported:\nSince only one version of the CUDA Driver can be installed at a time on a system, the installed driver must be of the same or higher version than the maximum Driver API version against which any application, plug-ins, or libraries that must run on that system were built.\nAll plug-ins and libraries used by an application must use the same version of the CUDA Runtime unless they statically link to the Runtime, in which case multiple versions of the runtime can coexist in the same process space. Note that if\nnvcc\nis used to link the application, the static version of the CUDA Runtime library will be used by default, and all CUDA Toolkit libraries are statically linked against the CUDA Runtime.\nAll plug-ins and libraries used by an application must use the same version of any libraries that use the runtime (such as cuFFT, cuBLAS, â¦) unless statically linking to those libraries.\nFigure 26\nThe Driver API Is Backward but Not Forward Compatible\nï\nFor Tesla GPU products, CUDA 10 introduced a new forward-compatible upgrade path for the user-mode components of the CUDA Driver. This feature is described in\nCUDA Compatibility\n. The requirements on the CUDA Driver version described here apply to the version of the user-mode components.\n6.4.\nCompute Modes\nï\nOn Tesla solutions running Windows Server 2008 and later or Linux, one can set any device in a system in one of the three following modes using NVIDIAâs System Management Interface (nvidia-smi), which is a tool distributed as part of the driver:\nDefault\ncompute mode: Multiple host threads can use the device (by calling\ncudaSetDevice()\non this device, when using the runtime API, or by making current a context associated to the device, when using the driver API) at the same time.\nExclusive-process\ncompute mode: Only one CUDA context may be created on the device across all processes in the system. The context may be current to as many threads as desired within the process that created that context.\nProhibited\ncompute mode: No CUDA context can be created on the device.\nThis means, in particular, that a host thread using the runtime API without explicitly calling\ncudaSetDevice()\nmight be associated with a device other than device 0 if device 0 turns out to be in prohibited mode or in exclusive-process mode and used by another process.\ncudaSetValidDevices()\ncan be used to set a device from a prioritized list of devices.\nNote also that, for devices featuring the Pascal architecture onwards (compute capability with major revision number 6 and higher), there exists support for Compute Preemption. This allows compute tasks to be preempted at instruction-level granularity, rather than thread block granularity as in prior Maxwell and Kepler GPU architecture, with the benefit that applications with long-running kernels can be prevented from either monopolizing the system or timing out. However, there will be context switch overheads associated with Compute Preemption, which is automatically enabled on those devices for which support exists. The individual attribute query function\ncudaDeviceGetAttribute()\nwith the attribute\ncudaDevAttrComputePreemptionSupported\ncan be used to determine if the device in use supports Compute Preemption. Users wishing to avoid context switch overheads associated with different processes can ensure that only one process is active on the GPU by selecting exclusive-process mode.\nApplications may query the compute mode of a device by checking the attribute\ncudaDevAttrComputeMode\n.\n6.5.\nMode Switches\nï\nGPUs that have a display output dedicate some DRAM memory to the so-called\nprimary surface\n, which is used to refresh the display device whose output is viewed by the user. When users initiate a\nmode switch\nof the display by changing the resolution or bit depth of the display (using NVIDIA control panel or the Display control panel on Windows), the amount of memory needed for the primary surface changes. For example, if the user changes the display resolution from 1280x1024x32-bit to 1600x1200x32-bit, the system must dedicate 7.68 MB to the primary surface rather than 5.24 MB. (Full-screen graphics applications running with anti-aliasing enabled may require much more display memory for the primary surface.) On Windows, other events that may initiate display mode switches include launching a full-screen DirectX application, hitting Alt+Tab to task switch away from a full-screen DirectX application, or hitting Ctrl+Alt+Del to lock the computer.\nIf a mode switch increases the amount of memory needed for the primary surface, the system may have to cannibalize memory allocations dedicated to CUDA applications. Therefore, a mode switch results in any call to the CUDA runtime to fail and return an invalid context error.\n6.6.\nTesla Compute Cluster Mode for Windows\nï\nUsing NVIDIAâs System Management Interface (\nnvidia-smi\n), the Windows device driver can be put in TCC (Tesla Compute Cluster) mode for devices of the Tesla and Quadro Series.\nTCC mode removes support for any graphics functionality.\n7.\nHardware Implementation\nï\nThe NVIDIA GPU architecture is built around a scalable array of multithreaded\nStreaming Multiprocessors\n(\nSMs\n). When a CUDA program on the host CPU invokes a kernel grid, the blocks of the grid are enumerated and distributed to multiprocessors with available execution capacity. The threads of a thread block execute concurrently on one multiprocessor, and multiple thread blocks can execute concurrently on one multiprocessor. As thread blocks terminate, new blocks are launched on the vacated multiprocessors.\nA multiprocessor is designed to execute hundreds of threads concurrently. To manage such a large number of threads, it employs a unique architecture called\nSIMT\n(\nSingle-Instruction, Multiple-Thread\n) that is described in\nSIMT Architecture\n. The instructions are pipelined, leveraging instruction-level parallelism within a single thread, as well as extensive thread-level parallelism through simultaneous hardware multithreading as detailed in\nHardware Multithreading\n. Unlike CPU cores, they are issued in order and there is no branch prediction or speculative execution.\nSIMT Architecture\nand\nHardware Multithreading\ndescribe the architecture features of the streaming multiprocessor that are common to all devices.\nCompute Capability 5.x\n,\nCompute Capability 6.x\n, and\nCompute Capability 7.x\nprovide the specifics for devices of compute capabilities 5.x, 6.x, and 7.x respectively.\nThe NVIDIA GPU architecture uses a little-endian representation.\n7.1.\nSIMT Architecture\nï\nThe multiprocessor creates, manages, schedules, and executes threads in groups of 32 parallel threads called\nwarps\n. Individual threads composing a warp start together at the same program address, but they have their own instruction address counter and register state and are therefore free to branch and execute independently. The term\nwarp\noriginates from weaving, the first parallel thread technology. A\nhalf-warp\nis either the first or second half of a warp. A\nquarter-warp\nis either the first, second, third, or fourth quarter of a warp.\nWhen a multiprocessor is given one or more thread blocks to execute, it partitions them into warps and each warp gets scheduled by a\nwarp scheduler\nfor execution. The way a block is partitioned into warps is always the same; each warp contains threads of consecutive, increasing thread IDs with the first warp containing thread 0.\nThread Hierarchy\ndescribes how thread IDs relate to thread indices in the block.\nA warp executes one common instruction at a time, so full efficiency is realized when all 32 threads of a warp agree on their execution path. If threads of a warp diverge via a data-dependent conditional branch, the warp executes each branch path taken, disabling threads that are not on that path. Branch divergence occurs only within a warp; different warps execute independently regardless of whether they are executing common or disjoint code paths.\nThe SIMT architecture is akin to SIMD (Single Instruction, Multiple Data) vector organizations in that a single instruction controls multiple processing elements. A key difference is that SIMD vector organizations expose the SIMD width to the software, whereas SIMT instructions specify the execution and branching behavior of a single thread. In contrast with SIMD vector machines, SIMT enables programmers to write thread-level parallel code for independent, scalar threads, as well as data-parallel code for coordinated threads. For the purposes of correctness, the programmer can essentially ignore the SIMT behavior; however, substantial performance improvements can be realized by taking care that the code seldom requires threads in a warp to diverge. In practice, this is analogous to the role of cache lines in traditional code: Cache line size can be safely ignored when designing for correctness but must be considered in the code structure when designing for peak performance. Vector architectures, on the other hand, require the software to coalesce loads into vectors and manage divergence manually.\nPrior to NVIDIA Volta, warps used a single program counter shared amongst all 32 threads in the warp together with an active mask specifying the active threads of the warp. As a result, threads from the same warp in divergent regions or different states of execution cannot signal each other or exchange data, and algorithms requiring fine-grained sharing of data guarded by locks or mutexes can easily lead to deadlock, depending on which warp the contending threads come from.\nStarting with the NVIDIA Volta architecture,\nIndependent Thread Scheduling\nallows full concurrency between threads, regardless of warp. With Independent Thread Scheduling, the GPU maintains execution state per thread, including a program counter and call stack, and can yield execution at a per-thread granularity, either to make better use of execution resources or to allow one thread to wait for data to be produced by another. A schedule optimizer determines how to group active threads from the same warp together into SIMT units. This retains the high throughput of SIMT execution as in prior NVIDIA GPUs, but with much more flexibility: threads can now diverge and reconverge at sub-warp granularity.\nIndependent Thread Scheduling can lead to a rather different set of threads participating in the executed code than intended if the developer made assumptions about warp-synchronicity\n2\nof previous hardware architectures. In particular, any warp-synchronous code (such as synchronization-free, intra-warp reductions) should be revisited to ensure compatibility with NVIDIA Volta and beyond. See\nCompute Capability 7.x\nfor further details.\nNote\nThe threads of a warp that are participating in the current instruction are called the\nactive\nthreads, whereas threads not on the current instruction are\ninactive\n(disabled). Threads can be inactive for a variety of reasons including having exited earlier than other threads of their warp, having taken a different branch path than the branch path currently executed by the warp, or being the last threads of a block whose number of threads is not a multiple of the warp size.\nIf a non-atomic instruction executed by a warp writes to the same location in global or shared memory for more than one of the threads of the warp, the number of serialized writes that occur to that location varies depending on the compute capability of the device (see\nCompute Capability 5.x\n,\nCompute Capability 6.x\n, and\nCompute Capability 7.x\n), and which thread performs the final write is undefined.\nIf an\natomic\ninstruction executed by a warp reads, modifies, and writes to the same location in global memory for more than one of the threads of the warp, each read/modify/write to that location occurs and they are all serialized, but the order in which they occur is undefined.\n7.2.\nHardware Multithreading\nï\nThe execution context (program counters, registers, and so on) for each warp processed by a multiprocessor is maintained on-chip during the entire lifetime of the warp. Therefore, switching from one execution context to another has no cost, and at every instruction issue time, a warp scheduler selects a warp that has threads ready to execute its next instruction (the\nactive threads\nof the warp) and issues the instruction to those threads.\nIn particular, each multiprocessor has a set of 32-bit registers that are partitioned among the warps, and a\nparallel data cache\nor\nshared memory\nthat is partitioned among the thread blocks.\nThe number of blocks and warps that can reside and be processed together on the multiprocessor for a given kernel depends on the amount of registers and shared memory used by the kernel and the amount of registers and shared memory available on the multiprocessor. There are also a maximum number of resident blocks and a maximum number of resident warps per multiprocessor. These limits as well the amount of registers and shared memory available on the multiprocessor are a function of the compute capability of the device and are given in\nCompute Capabilities\n. If there are not enough registers or shared memory available per multiprocessor to process at least one block, the kernel will fail to launch.\nThe total number of warps in a block is as follows:\n\\(\\text{ceil}\\left( \\frac{T}{W_{size}},1 \\right)\\)\nT\nis the number of threads per block,\nWsize\nis the warp size, which is equal to 32,\nceil(x, y) is equal to x rounded up to the nearest multiple of y.\nThe total number of registers and total amount of shared memory allocated for a block are documented in the CUDA Occupancy Calculator provided in the CUDA Toolkit.\n2\nThe term\nwarp-synchronous\nrefers to code that implicitly assumes threads in the same warp are synchronized at every instruction.\n8.\nPerformance Guidelines\nï\n8.1.\nOverall Performance Optimization Strategies\nï\nPerformance optimization revolves around four basic strategies:\nMaximize parallel execution to achieve maximum utilization;\nOptimize memory usage to achieve maximum memory throughput;\nOptimize instruction usage to achieve maximum instruction throughput;\nMinimize memory thrashing.\nWhich strategies will yield the best performance gain for a particular portion of an application depends on the performance limiters for that portion; optimizing instruction usage of a kernel that is mostly limited by memory accesses will not yield any significant performance gain, for example. Optimization efforts should therefore be constantly directed by measuring and monitoring the performance limiters, for example using the CUDA profiler. Also, comparing the floating-point operation throughput or memory throughputâwhichever makes more senseâof a particular kernel to the corresponding peak theoretical throughput of the device indicates how much room for improvement there is for the kernel.\n8.2.\nMaximize Utilization\nï\nTo maximize utilization the application should be structured in a way that it exposes as much parallelism as possible and efficiently maps this parallelism to the various components of the system to keep them busy most of the time.\n8.2.1.\nApplication Level\nï\nAt a high level, the application should maximize parallel execution between the host, the devices, and the bus connecting the host to the devices, by using asynchronous functions calls and streams as described in\nAsynchronous Concurrent Execution\n. It should assign to each processor the type of work it does best: serial workloads to the host; parallel workloads to the devices.\nFor the parallel workloads, at points in the algorithm where parallelism is broken because some threads need to synchronize in order to share data with each other, there are two cases: Either these threads belong to the same block, in which case they should use\n__syncthreads()\nand share data through shared memory within the same kernel invocation, or they belong to different blocks, in which case they must share data through global memory using two separate kernel invocations, one for writing to and one for reading from global memory. The second case is much less optimal since it adds the overhead of extra kernel invocations and global memory traffic. Its occurrence should therefore be minimized by mapping the algorithm to the CUDA programming model in such a way that the computations that require inter-thread communication are performed within a single thread block as much as possible.\n8.2.2.\nDevice Level\nï\nAt a lower level, the application should maximize parallel execution between the multiprocessors of a device.\nMultiple kernels can execute concurrently on a device, so maximum utilization can also be achieved by using streams to enable enough kernels to execute concurrently as described in\nAsynchronous Concurrent Execution\n.\n8.2.3.\nMultiprocessor Level\nï\nAt an even lower level, the application should maximize parallel execution between the various functional units within a multiprocessor.\nAs described in\nHardware Multithreading\n, a GPU multiprocessor primarily relies on thread-level parallelism to maximize utilization of its functional units. Utilization is therefore directly linked to the number of resident warps. At every instruction issue time, a warp scheduler selects an instruction that is ready to execute. This instruction can be another independent instruction of the same warp, exploiting instruction-level parallelism, or more commonly an instruction of another warp, exploiting thread-level parallelism. If a ready to execute instruction is selected it is issued to the\nactive\nthreads of the warp. The number of clock cycles it takes for a warp to be ready to execute its next instruction is called the\nlatency\n, and full utilization is achieved when all warp schedulers always have some instruction to issue for some warp at every clock cycle during that latency period, or in other words, when latency is completely âhiddenâ. The number of instructions required to hide a latency of L clock cycles depends on the respective throughputs of these instructions (see the\nCUDA C++ Best Practices Guide\nfor the throughputs of various arithmetic instructions). If we assume instructions with maximum throughput, it is equal to:\n4L\nfor devices of compute capability 5.x, 6.1, 6.2, 7.x and 8.x since for these devices, a multiprocessor issues one instruction per warp over one clock cycle for four warps at a time, as mentioned in\nCompute Capabilities\n.\n2L\nfor devices of compute capability 6.0 since for these devices, the two instructions issued every cycle are one instruction for two different warps.\nThe most common reason a warp is not ready to execute its next instruction is that the instructionâs input operands are not available yet.\nIf all input operands are registers, latency is caused by register dependencies, i.e., some of the input operands are written by some previous instruction(s) whose execution has not completed yet. In this case, the latency is equal to the execution time of the previous instruction and the warp schedulers must schedule instructions of other warps during that time. Execution time varies depending on the instruction. On devices of compute capability 7.x, for most arithmetic instructions, it is typically 4 clock cycles. This means that 16 active warps per multiprocessor (4 cycles, 4 warp schedulers) are required to hide arithmetic instruction latencies (assuming that warps execute instructions with maximum throughput, otherwise fewer warps are needed). If the individual warps exhibit instruction-level parallelism, i.e. have multiple independent instructions in their instruction stream, fewer warps are needed because multiple independent instructions from a single warp can be issued back to back.\nIf some input operand resides in off-chip memory, the latency is much higher: typically hundreds of clock cycles. The number of warps required to keep the warp schedulers busy during such high latency periods depends on the kernel code and its degree of instruction-level parallelism. In general, more warps are required if the ratio of the number of instructions with no off-chip memory operands (i.e., arithmetic instructions most of the time) to the number of instructions with off-chip memory operands is low (this ratio is commonly called the arithmetic intensity of the program).\nAnother reason a warp is not ready to execute its next instruction is that it is waiting at some memory fence (\nMemory Fence Functions\n) or synchronization point (\nSynchronization Functions\n). A synchronization point can force the multiprocessor to idle as more and more warps wait for other warps in the same block to complete execution of instructions prior to the synchronization point. Having multiple resident blocks per multiprocessor can help reduce idling in this case, as warps from different blocks do not need to wait for each other at synchronization points.\nThe number of blocks and warps residing on each multiprocessor for a given kernel call depends on the execution configuration of the call (\nExecution Configuration\n), the memory resources of the multiprocessor, and the resource requirements of the kernel as described in\nHardware Multithreading\n. Register and shared memory usage are reported by the compiler when compiling with the\n--ptxas-options=-v\noption.\nThe total amount of shared memory required for a block is equal to the sum of the amount of statically allocated shared memory and the amount of dynamically allocated shared memory.\nThe number of registers used by a kernel can have a significant impact on the number of resident warps. For example, for devices of compute capability 6.x, if a kernel uses 64\nregisters and each block has 512 threads and requires very little shared memory, then two blocks (i.e., 32 warps) can reside on the multiprocessor since they require 2x512x64\nregisters, which exactly matches the number of registers available on the multiprocessor. But as soon as the kernel uses one more register, only one block (i.e., 16 warps) can be\nresident since two blocks would require 2x512x65 registers, which are more registers than are available on the multiprocessor. Therefore, the compiler attempts to minimize register\nusage while keeping register spilling (see\nDevice Memory Accesses\n) and the number of instructions to a minimum. Register usage can be\ncontrolled using the\nmaxrregcount\ncompiler option, the\n__launch_bounds__()\nqualifier as described in\nLaunch Bounds\n, or the\n__maxnreg__()\nqualifier as described in\nMaximum Number of Registers per Thread\n.\nThe register file is organized as 32-bit registers. So, each variable stored in a register needs at least one 32-bit register, for example, a\ndouble\nvariable uses two 32-bit registers.\nThe effect of execution configuration on performance for a given kernel call generally depends on the kernel code. Experimentation is therefore recommended. Applications can also parametrize execution configurations based on register file size and shared memory size, which depends on the compute capability of the device, as well as on the number of multiprocessors and memory bandwidth of the device, all of which can be queried using the runtime (see reference manual).\nThe number of threads per block should be chosen as a multiple of the warp size to avoid wasting computing resources with under-populated warps as much as possible.\n8.2.3.1.\nOccupancy Calculator\nï\nSeveral API functions exist to assist programmers in choosing thread block size and cluster size based on register and shared memory requirements.\nThe occupancy calculator API,\ncudaOccupancyMaxActiveBlocksPerMultiprocessor\n, can provide an occupancy prediction based on the block size and shared memory usage of a kernel. This function reports occupancy in terms of the number of concurrent thread blocks per multiprocessor.\nNote that this value can be converted to other metrics. Multiplying by the number of warps per block yields the number of concurrent warps per multiprocessor; further dividing concurrent warps by max warps per multiprocessor gives the occupancy as a percentage.\nThe occupancy-based launch configurator APIs,\ncudaOccupancyMaxPotentialBlockSize\nand\ncudaOccupancyMaxPotentialBlockSizeVariableSMem\n, heuristically calculate an execution configuration that achieves the maximum multiprocessor-level occupancy.\nThe occupancy calculator API,\ncudaOccupancyMaxActiveClusters\n, can provided occupancy prediction based on the cluster size, block size and shared memory usage of a kernel. This function reports occupancy in terms of number of max active clusters of a given size on the GPU present in the system.\nThe following code sample calculates the occupancy of MyKernel. It then reports the occupancy level with the ratio between concurrent warps versus maximum warps per multiprocessor.\n// Device code\n__global__\nvoid\nMyKernel\n(\nint\n*\nd\n,\nint\n*\na\n,\nint\n*\nb\n)\n{\nint\nidx\n=\nthreadIdx\n.\nx\n+\nblockIdx\n.\nx\n*\nblockDim\n.\nx\n;\nd\n[\nidx\n]\n=\na\n[\nidx\n]\n*\nb\n[\nidx\n];\n}\n// Host code\nint\nmain\n()\n{\nint\nnumBlocks\n;\n// Occupancy in terms of active blocks\nint\nblockSize\n=\n32\n;\n// These variables are used to convert occupancy to warps\nint\ndevice\n;\ncudaDeviceProp\nprop\n;\nint\nactiveWarps\n;\nint\nmaxWarps\n;\ncudaGetDevice\n(\n&\ndevice\n);\ncudaGetDeviceProperties\n(\n&\nprop\n,\ndevice\n);\ncudaOccupancyMaxActiveBlocksPerMultiprocessor\n(\n&\nnumBlocks\n,\nMyKernel\n,\nblockSize\n,\n0\n);\nactiveWarps\n=\nnumBlocks\n*\nblockSize\n/\nprop\n.\nwarpSize\n;\nmaxWarps\n=\nprop\n.\nmaxThreadsPerMultiProcessor\n/\nprop\n.\nwarpSize\n;\nstd\n::\ncout\n<<\n\"Occupancy: \"\n<<\n(\ndouble\n)\nactiveWarps\n/\nmaxWarps\n*\n100\n<<\n\"%\"\n<<\nstd\n::\nendl\n;\nreturn\n0\n;\n}\nThe following code sample configures an occupancy-based kernel launch of MyKernel according to the user input.\n// Device code\n__global__\nvoid\nMyKernel\n(\nint\n*\narray\n,\nint\narrayCount\n)\n{\nint\nidx\n=\nthreadIdx\n.\nx\n+\nblockIdx\n.\nx\n*\nblockDim\n.\nx\n;\nif\n(\nidx\n<\narrayCount\n)\n{\narray\n[\nidx\n]\n*=\narray\n[\nidx\n];\n}\n}\n// Host code\nint\nlaunchMyKernel\n(\nint\n*\narray\n,\nint\narrayCount\n)\n{\nint\nblockSize\n;\n// The launch configurator returned block size\nint\nminGridSize\n;\n// The minimum grid size needed to achieve the\n// maximum occupancy for a full device\n// launch\nint\ngridSize\n;\n// The actual grid size needed, based on input\n// size\ncudaOccupancyMaxPotentialBlockSize\n(\n&\nminGridSize\n,\n&\nblockSize\n,\n(\nvoid\n*\n)\nMyKernel\n,\n0\n,\narrayCount\n);\n// Round up according to array size\ngridSize\n=\n(\narrayCount\n+\nblockSize\n-\n1\n)\n/\nblockSize\n;\nMyKernel\n<<<\ngridSize\n,\nblockSize\n>>>\n(\narray\n,\narrayCount\n);\ncudaDeviceSynchronize\n();\n// If interested, the occupancy can be calculated with\n// cudaOccupancyMaxActiveBlocksPerMultiprocessor\nreturn\n0\n;\n}\nThe following code sample shows how to use the cluster occupancy API to find the max number of active clusters of a given size. Example code below calcualtes occupancy for cluster of size 2 and 128 threads per block.\nCluster size of 8 is forward compatible starting compute capability 9.0, except on GPU hardware or MIG configurations which are too small to support 8 multiprocessors in which case the maximum cluster size will be reduced. But it is recommended that the users query the maximum cluster size before launching a cluster kernel. Max cluster size can be queried using\ncudaOccupancyMaxPotentialClusterSize\nAPI.\n{\ncudaLaunchConfig_t\nconfig\n=\n{\n0\n};\nconfig\n.\ngridDim\n=\nnumber_of_blocks\n;\nconfig\n.\nblockDim\n=\n128\n;\n// threads_per_block = 128\nconfig\n.\ndynamicSmemBytes\n=\ndynamic_shared_memory_size\n;\ncudaLaunchAttribute\nattribute\n[\n1\n];\nattribute\n[\n0\n].\nid\n=\ncudaLaunchAttributeClusterDimension\n;\nattribute\n[\n0\n].\nval\n.\nclusterDim\n.\nx\n=\n2\n;\n// cluster_size = 2\nattribute\n[\n0\n].\nval\n.\nclusterDim\n.\ny\n=\n1\n;\nattribute\n[\n0\n].\nval\n.\nclusterDim\n.\nz\n=\n1\n;\nconfig\n.\nattrs\n=\nattribute\n;\nconfig\n.\nnumAttrs\n=\n1\n;\nint\nmax_cluster_size\n=\n0\n;\ncudaOccupancyMaxPotentialClusterSize\n(\n&\nmax_cluster_size\n,\n(\nvoid\n*\n)\nkernel\n,\n&\nconfig\n);\nint\nmax_active_clusters\n=\n0\n;\ncudaOccupancyMaxActiveClusters\n(\n&\nmax_active_clusters\n,\n(\nvoid\n*\n)\nkernel\n,\n&\nconfig\n);\nstd\n::\ncout\n<<\n\"Max Active Clusters of size 2: \"\n<<\nmax_active_clusters\n<<\nstd\n::\nendl\n;\n}\nThe CUDA Nsight Compute User Interface also provides a standalone occupancy calculator and launch configurator implementation in\n<CUDA_Toolkit_Path>/include/cuda_occupancy.h\nfor any use cases that cannot depend on the CUDA software stack. The Nsight Compute version of the occupancy calculator is particularly useful as a learning tool that visualizes the impact of changes to the parameters that affect occupancy (block size, registers per thread, and shared memory per thread).\n8.3.\nMaximize Memory Throughput\nï\nThe first step in maximizing overall memory throughput for the application is to minimize data transfers with low bandwidth.\nThat means minimizing data transfers between the host and the device, as detailed in\nData Transfer between Host and Device\n, since these have much lower bandwidth than data transfers between global memory and the device.\nThat also means minimizing data transfers between global memory and the device by maximizing use of on-chip memory: shared memory and caches (i.e., L1 cache and L2 cache available on devices of compute capability 2.x and higher, texture cache and constant cache available on all devices).\nShared memory is equivalent to a user-managed cache: The application explicitly allocates and accesses it. As illustrated in\nCUDA Runtime\n, a typical programming pattern is to stage data coming from device memory into shared memory; in other words, to have each thread of a block:\nLoad data from device memory to shared memory,\nSynchronize with all the other threads of the block so that each thread can safely read shared memory locations that were populated by different threads,\nProcess the data in shared memory,\nSynchronize again if necessary to make sure that shared memory has been updated with the results,\nWrite the results back to device memory.\nFor some applications (for example, for which global memory access patterns are data-dependent), a traditional hardware-managed cache is more appropriate to exploit data locality. As mentioned in\nCompute Capability 7.x\n,\nCompute Capability 8.x\nand\nCompute Capability 9.0\n, for devices of compute capability 7.x, 8.x and 9.0, the same on-chip memory is used for both L1 and shared memory, and how much of it is dedicated to L1 versus shared memory is configurable for each kernel call.\nThe throughput of memory accesses by a kernel can vary by an order of magnitude depending on access pattern for each type of memory. The next step in maximizing memory throughput is therefore to organize memory accesses as optimally as possible based on the optimal memory access patterns described in\nDevice Memory Accesses\n. This optimization is especially important for global memory accesses as global memory bandwidth is low compared to available on-chip bandwidths and arithmetic instruction throughput, so non-optimal global memory accesses generally have a high impact on performance.\n8.3.1.\nData Transfer between Host and Device\nï\nApplications should strive to minimize data transfer between the host and the device. One way to accomplish this is to move more code from the host to the device, even if that means running kernels that do not expose enough parallelism to execute on the device with full efficiency. Intermediate data structures may be created in device memory, operated on by the device, and destroyed without ever being mapped by the host or copied to host memory.\nAlso, because of the overhead associated with each transfer, batching many small transfers into a single large transfer always performs better than making each transfer separately.\nOn systems with a front-side bus, higher performance for data transfers between host and device is achieved by using page-locked host memory as described in\nPage-Locked Host Memory\n.\nIn addition, when using mapped page-locked memory (\nMapped Memory\n), there is no need to allocate any device memory and explicitly copy data between device and host memory. Data transfers are implicitly performed each time the kernel accesses the mapped memory. For maximum performance, these memory accesses must be coalesced as with accesses to global memory (see\nDevice Memory Accesses\n). Assuming that they are and that the mapped memory is read or written only once, using mapped page-locked memory instead of explicit copies between device and host memory can be a win for performance.\nOn integrated systems where device memory and host memory are physically the same, any copy between host and device memory is superfluous and mapped page-locked memory should be used instead. Applications may query a device is\nintegrated\nby checking that the integrated device property (see\nDevice Enumeration\n) is equal to 1.\n8.3.2.\nDevice Memory Accesses\nï\nAn instruction that accesses addressable memory (i.e., global, local, shared, constant, or texture memory) might need to be re-issued multiple times depending on the distribution of the memory addresses across the threads within the warp. How the distribution affects the instruction throughput this way is specific to each type of memory and described in the following sections. For example, for global memory, as a general rule, the more scattered the addresses are, the more reduced the throughput is.\nGlobal Memory\nGlobal memory resides in device memory and device memory is accessed via 32-, 64-, or 128-byte memory transactions. These memory transactions must be naturally aligned: Only the 32-, 64-, or 128-byte segments of device memory that are aligned to their size (i.e., whose first address is a multiple of their size) can be read or written by memory transactions.\nWhen a warp executes an instruction that accesses global memory, it coalesces the memory accesses of the threads within the warp into one or more of these memory transactions depending on the size of the word accessed by each thread and the distribution of the memory addresses across the threads. In general, the more transactions are necessary, the more unused words are transferred in addition to the words accessed by the threads, reducing the instruction throughput accordingly. For example, if a 32-byte memory transaction is generated for each threadâs 4-byte access, throughput is divided by 8.\nHow many transactions are necessary and how much throughput is ultimately affected varies with the compute capability of the device.\nCompute Capability 5.x\n,\nCompute Capability 6.x\n,\nCompute Capability 7.x\n,\nCompute Capability 8.x\n,\nCompute Capability 9.0\n,\nCompute Capability 10.0\n, and\nCompute Capability 12.0\ngive more details on how global memory accesses are handled for various compute capabilities.\nTo maximize global memory throughput, it is therefore important to maximize coalescing by:\nFollowing the most optimal access patterns based on\nCompute Capability 5.x\n,\nCompute Capability 6.x\n,\nCompute Capability 7.x\n,\nCompute Capability 8.x\n,\nCompute Capability 9.0\n,\nCompute Capability 10.0\n, and\nCompute Capability 12.0\n.\nUsing data types that meet the size and alignment requirement detailed in the section Size and Alignment Requirement below,\nPadding data in some cases, for example, when accessing a two-dimensional array as described in the section Two-Dimensional Arrays below.\nSize and Alignment Requirement\nGlobal memory instructions support reading or writing words of size equal to 1, 2, 4, 8, or 16 bytes. Any access (via a variable or a pointer) to data residing in global memory compiles to a single global memory instruction if and only if the size of the data type is 1, 2, 4, 8, or 16 bytes and the data is naturally aligned (i.e., its address is a multiple of that size).\nIf this size and alignment requirement is not fulfilled, the access compiles to multiple instructions with interleaved access patterns that prevent these instructions from fully coalescing. It is therefore recommended to use types that meet this requirement for data that resides in global memory.\nThe alignment requirement is automatically fulfilled for the\nBuilt-in Vector Types\n.\nFor structures, the size and alignment requirements can be enforced by the compiler using the alignment specifiers\n__align__(8)\nor\n__align__(16)\n, such as\nstruct\n__align__\n(\n8\n)\n{\nfloat\nx\n;\nfloat\ny\n;\n};\nor\nstruct\n__align__\n(\n16\n)\n{\nfloat\nx\n;\nfloat\ny\n;\nfloat\nz\n;\n};\nAny address of a variable residing in global memory or returned by one of the memory allocation routines from the driver or runtime API is always aligned to at least 256 bytes.\nReading non-naturally aligned 8-byte or 16-byte words produces incorrect results (off by a few words), so special care must be taken to maintain alignment of the starting address of any value or array of values of these types. A typical case where this might be easily overlooked is when using some custom global memory allocation scheme, whereby the allocations of multiple arrays (with multiple calls to\ncudaMalloc()\nor\ncuMemAlloc()\n) is replaced by the allocation of a single large block of memory partitioned into multiple arrays, in which case the starting address of each array is offset from the blockâs starting address.\nTwo-Dimensional Arrays\nA common global memory access pattern is when each thread of index\n(tx,ty)\nuses the following address to access one element of a 2D array of width\nwidth\n, located at address\nBaseAddress\nof type\ntype*\n(where\ntype\nmeets the requirement described in\nMaximize Utilization\n):\nBaseAddress\n+\nwidth\n*\nty\n+\ntx\nFor these accesses to be fully coalesced, both the width of the thread block and the width of the array must be a multiple of the warp size.\nIn particular, this means that an array whose width is not a multiple of this size will be accessed much more efficiently if it is actually allocated with a width rounded up to the closest multiple of this size and its rows padded accordingly. The\ncudaMallocPitch()\nand\ncuMemAllocPitch()\nfunctions and associated memory copy functions described in the reference manual enable programmers to write non-hardware-dependent code to allocate arrays that conform to these constraints.\nLocal Memory\nLocal memory accesses only occur for some automatic variables as mentioned in\nVariable Memory Space Specifiers\n. Automatic variables that the compiler is likely to place in local memory are:\nArrays for which it cannot determine that they are indexed with constant quantities,\nLarge structures or arrays that would consume too much register space,\nAny variable if the kernel uses more registers than available (this is also known as\nregister spilling\n).\nInspection of the\nPTX\nassembly code (obtained by compiling with the\n-ptx\nor\n-keep\noption) will tell if a variable has been placed in local memory during the first compilation phases as it will be declared using the\n.local\nmnemonic and accessed using the\nld.local\nand\nst.local\nmnemonics. Even if it has not, subsequent compilation phases might still decide otherwise though if they find it consumes too much register space for the targeted architecture: Inspection of the\ncubin\nobject using\ncuobjdump\nwill tell if this is the case. Also, the compiler reports total local memory usage per kernel (\nlmem\n) when compiling with the\n--ptxas-options=-v\noption. Note that some mathematical functions have implementation paths that might access local memory.\nThe local memory space resides in device memory, so local memory accesses have the same high latency and low bandwidth as global memory accesses and are subject to the same requirements for memory coalescing as described in\nDevice Memory Accesses\n. Local memory is however organized such that consecutive 32-bit words are accessed by consecutive thread IDs. Accesses are therefore fully coalesced as long as all threads in a warp access the same relative address (for example, same index in an array variable, same member in a structure variable).\nOn devices of compute capability 5.x onwards, local memory accesses are always cached in L2 in the same way as global memory accesses (see\nCompute Capability 5.x\nand\nCompute Capability 6.x\n).\nShared Memory\nBecause it is on-chip, shared memory has much higher bandwidth and much lower latency than local or global memory.\nTo achieve high bandwidth, shared memory is divided into equally-sized memory modules, called banks, which can be accessed simultaneously. Any memory read or write request made of\nn\naddresses that fall in\nn\ndistinct memory banks can therefore be serviced simultaneously, yielding an overall bandwidth that is\nn\ntimes as high as the bandwidth of a single module.\nHowever, if two addresses of a memory request fall in the same memory bank, there is a bank conflict and the access has to be serialized. The hardware splits a memory request with bank conflicts into as many separate conflict-free requests as necessary, decreasing throughput by a factor equal to the number of separate memory requests. If the number of separate memory requests is\nn\n, the initial memory request is said to cause\nn\n-way bank conflicts.\nTo get maximum performance, it is therefore important to understand how memory addresses map to memory banks in order to schedule the memory requests so as to minimize bank conflicts. This is described in\nCompute Capability 5.x\n,\nCompute Capability 6.x\n,\nCompute Capability 7.x\n,\nCompute Capability 8.x\n,\nCompute Capability 9.0\n,\nCompute Capability 10.0\n, and\nCompute Capability 12.0\nfor devices of these compute capabilities respectively.\nConstant Memory\nThe constant memory space resides in device memory and is cached in the constant cache.\nA request is then split into as many separate requests as there are different memory addresses in the initial request, decreasing throughput by a factor equal to the number of separate requests.\nThe resulting requests are then serviced at the throughput of the constant cache in case of a cache hit, or at the throughput of device memory otherwise.\nTexture and Surface Memory\nThe texture and surface memory spaces reside in device memory and are cached in texture cache, so a texture fetch or surface read costs one memory read from device memory only on a cache miss, otherwise it just costs one read from texture cache. The texture cache is optimized for 2D spatial locality, so threads of the same warp that read texture or surface addresses that are close together in 2D will achieve best performance. Also, it is designed for streaming fetches with a constant latency; a cache hit reduces DRAM bandwidth demand but not fetch latency.\nReading device memory through texture or surface fetching present some benefits that can make it an advantageous alternative to reading device memory from global or constant memory:\nIf the memory reads do not follow the access patterns that global or constant memory reads must follow to get good performance, higher bandwidth can be achieved providing that there is locality in the texture fetches or surface reads;\nAddressing calculations are performed outside the kernel by dedicated units;\nPacked data may be broadcast to separate variables in a single operation;\n8-bit and 16-bit integer input data may be optionally converted to 32 bit floating-point values in the range [0.0, 1.0] or [-1.0, 1.0] (see\nTexture Memory\n).\n8.4.\nMaximize Instruction Throughput\nï\nSee the\nCUDA C++ Best Practices Guide\nfor more details on optimizing instruction throughput.\n8.5.\nMinimize Memory Thrashing\nï\nApplications that constantly allocate and free memory too often may find that the allocation calls tend to get slower over time up to a limit. This is typically expected due to the nature of releasing memory back to the operating system for its own use. For best performance in this regard, we recommend the following:\nTry to size your allocation to the problem at hand. Donât try to allocate all available memory with\ncudaMalloc\n/\ncudaMallocHost\n/\ncuMemCreate\n, as this forces memory to be resident immediately and prevents other applications from being able to use that memory. This can put more pressure on operating system schedulers, or just prevent other applications using the same GPU from running entirely.\nTry to allocate memory in appropriately sized allocations early in the application and allocations only when the application does not have any use for it. Reduce the number of\ncudaMalloc\n+\ncudaFree\ncalls in the application, especially in performance-critical regions.\nIf an application cannot allocate enough device memory, consider falling back on other memory types such as\ncudaMallocHost\nor\ncudaMallocManaged\n, which may not be as performant, but will enable the application to make progress.\nFor platforms that support the feature,\ncudaMallocManaged\nallows for oversubscription, and with the correct\ncudaMemAdvise\npolicies enabled, will allow the application to retain most if not all the performance of\ncudaMalloc\n.\ncudaMallocManaged\nalso wonât force an allocation to be resident until it is needed or prefetched, reducing the overall pressure on the operating system schedulers and better enabling multi-tenet use cases.\n9.\nCUDA-Enabled GPUs\nï\nhttps://developer.nvidia.com/cuda-gpus\nlists all CUDA-enabled devices with their compute capability.\nThe compute capability, number of multiprocessors, clock frequency, total amount of device memory, and other properties can be queried using the runtime (see reference manual).\n10.\nC++ Language Extensions\nï\n10.1.\nFunction Execution Space Specifiers\nï\nFunction execution space specifiers denote whether a function executes on the host or on the device and whether it is callable from the host or from the device.\n10.1.1.\n__global__\nï\nThe\n__global__\nexecution space specifier declares a function as being a kernel. Such a function is:\nExecuted on the device,\nCallable from the host,\nCallable from the device for devices of compute capability 5.0 or higher (see\nCUDA Dynamic Parallelism\nfor more details).\nA\n__global__\nfunction must have void return type, and cannot be a member of a class.\nAny call to a\n__global__\nfunction must specify its execution configuration as described in\nExecution Configuration\n.\nA call to a\n__global__\nfunction is asynchronous, meaning it returns before the device has completed its execution.\n10.1.2.\n__device__\nï\nThe\n__device__\nexecution space specifier declares a function that is:\nExecuted on the device,\nCallable from the device only.\nThe\n__global__\nand\n__device__\nexecution space specifiers cannot be used together.\n10.1.3.\n__host__\nï\nThe\n__host__\nexecution space specifier declares a function that is:\nExecuted on the host,\nCallable from the host only.\nIt is equivalent to declare a function with only the\n__host__\nexecution space specifier or to declare it without any of the\n__host__\n,\n__device__\n, or\n__global__\nexecution space specifier; in either case the function is compiled for the host only.\nThe\n__global__\nand\n__host__\nexecution space specifiers cannot be used together.\nThe\n__device__\nand\n__host__\nexecution space specifiers can be used together however, in which case the function is compiled for both the host and the device. The\n__CUDA_ARCH__\nmacro introduced in\nApplication Compatibility\ncan be used to differentiate code paths between host and device:\n__host__\n__device__\nfunc\n()\n{\n#if __CUDA_ARCH__ >= 800\n// Device code path for compute capability 8.x\n#elif __CUDA_ARCH__ >= 700\n// Device code path for compute capability 7.x\n#elif __CUDA_ARCH__ >= 600\n// Device code path for compute capability 6.x\n#elif __CUDA_ARCH__ >= 500\n// Device code path for compute capability 5.x\n#elif !defined(__CUDA_ARCH__)\n// Host code path\n#endif\n}\n10.1.4.\nUndefined behavior\nï\nA âcross-execution spaceâ call has undefined behavior when:\n__CUDA_ARCH__\nis defined, a call from within a\n__global__\n,\n__device__\nor\n__host__\n__device__\nfunction to a\n__host__\nfunction.\n__CUDA_ARCH__\nis undefined, a call from within a\n__host__\nfunction to a\n__device__\nfunction.\n4\n10.1.5.\n__noinline__ and __forceinline__\nï\nThe compiler inlines any\n__device__\nfunction when deemed appropriate.\nThe\n__noinline__\nfunction qualifier can be used as a hint for the compiler not to inline the function if possible.\nThe\n__forceinline__\nfunction qualifier can be used to force the compiler to inline the function.\nThe\n__noinline__\nand\n__forceinline__\nfunction qualifiers cannot be used together, and neither function qualifier can be applied to an inline function.\n10.1.6.\n__inline_hint__\nï\nThe\n__inline_hint__\nqualifier enables more aggressive inlining in the compiler. Unlike\n__forceinline__\n, it does not imply that the function is inline. It can be used to improve inlining across modules when using LTO.\nNeither the\n__noinline__\nnor the\n__forceinline__\nfunction qualifier can be used with the\n__inline_hint__\nfunction qualifier.\n10.2.\nVariable Memory Space Specifiers\nï\nVariable memory space specifiers denote the memory location on the device of a variable.\nAn automatic variable declared in device code without any of the\n__device__\n,\n__shared__\nand\n__constant__\nmemory space specifiers described in this section generally resides in a register. However in some cases the compiler might choose to place it in local memory, which can have adverse performance consequences as detailed in\nDevice Memory Accesses\n.\n10.2.1.\n__device__\nï\nThe\n__device__\nmemory space specifier declares a variable that resides on the device.\nAt most one of the other memory space specifiers defined in the next three sections may be used together with\n__device__\nto further denote which memory space the variable belongs to. If none of them is present, the variable:\nResides in global memory space,\nHas the lifetime of the CUDA context in which it is created,\nHas a distinct object per device,\nIs accessible from all the threads within the grid and from the host through the runtime library\n(cudaGetSymbolAddress()\n/\ncudaGetSymbolSize()\n/\ncudaMemcpyToSymbol()\n/\ncudaMemcpyFromSymbol()\n).\n10.2.2.\n__constant__\nï\nThe\n__constant__\nmemory space specifier, optionally used together with\n__device__\n, declares a variable that:\nResides in constant memory space,\nHas the lifetime of the CUDA context in which it is created,\nHas a distinct object per device,\nIs accessible from all the threads within the grid and from the host through the runtime library (\ncudaGetSymbolAddress()\n/\ncudaGetSymbolSize()\n/\ncudaMemcpyToSymbol()\n/\ncudaMemcpyFromSymbol()\n).\nThe behavior of modifying a constant from the host while there is a concurrent grid that access that constant at any point of this gridâs lifetime is undefined.\n10.2.3.\n__shared__\nï\nThe\n__shared__\nmemory space specifier, optionally used together with\n__device__\n, declares a variable that:\nResides in the shared memory space of a thread block,\nHas the lifetime of the block,\nHas a distinct object per block,\nIs only accessible from all the threads within the block,\nDoes not have a constant address.\nWhen declaring a variable in shared memory as an external array such as\nextern\n__shared__\nfloat\nshared\n[];\nthe size of the array is determined at launch time (see\nExecution Configuration\n). All variables declared in this fashion, start at the same address in memory, so that the layout of the variables in the array must be explicitly managed through offsets. For example, if one wants the equivalent of\nshort\narray0\n[\n128\n];\nfloat\narray1\n[\n64\n];\nint\narray2\n[\n256\n];\nin dynamically allocated shared memory, one could declare and initialize the arrays the following way:\nextern\n__shared__\nfloat\narray\n[];\n__device__\nvoid\nfunc\n()\n// __device__ or __global__ function\n{\nshort\n*\narray0\n=\n(\nshort\n*\n)\narray\n;\nfloat\n*\narray1\n=\n(\nfloat\n*\n)\n&\narray0\n[\n128\n];\nint\n*\narray2\n=\n(\nint\n*\n)\n&\narray1\n[\n64\n];\n}\nNote that pointers need to be aligned to the type they point to, so the following code, for example, does not work since array1 is not aligned to 4 bytes.\nextern\n__shared__\nfloat\narray\n[];\n__device__\nvoid\nfunc\n()\n// __device__ or __global__ function\n{\nshort\n*\narray0\n=\n(\nshort\n*\n)\narray\n;\nfloat\n*\narray1\n=\n(\nfloat\n*\n)\n&\narray0\n[\n127\n];\n}\nAlignment requirements for the built-in vector types are listed in\nTable 7\n.\n10.2.4.\n__grid_constant__\nï\nThe\n__grid_constant__\nannotation for compute architectures greater or equal to 7.0 annotates a\nconst\n-qualified\n__global__\nfunction parameter of non-reference type that:\nHas the lifetime of the grid,\nIs private to the grid, i.e., the object is not accessible to host threads and threads from other grids, including sub-grids,\nHas a distinct object per grid, i.e., all threads in the grid see the same address,\nIs read-only, i.e., modifying a\n__grid_constant__\nobject or any of its sub-objects is\nundefined behavior\n, including\nmutable\nmembers.\nRequirements:\nKernel parameters annotated with\n__grid_constant__\nmust have\nconst\n-qualified non-reference types.\nAll function declarations must match with respect to any\n__grid_constant_\nparameters.\nA function template specialization must match the primary template declaration with respect to any\n__grid_constant__\nparameters.\nA function template instantiation directive must match the primary template declaration with respect to any\n__grid_constant__\nparameters.\nIf the address of a\n__global__\nfunction parameter is taken, the compiler will ordinarily make a copy of the kernel parameter in thread local memory and use the address of the copy, to partially support C++ semantics, which allow each thread to modify its own local copy of function parameters. Annotating a\n__global__\nfunction parameter with\n__grid_constant__\nensures that the compiler will not create a copy of the kernel parameter in thread local memory, but will instead use the generic address of the parameter itself. Avoiding the local copy may result in improved performance.\n__device__\nvoid\nunknown_function\n(\nS\nconst\n&\n);\n__global__\nvoid\nkernel\n(\nconst\n__grid_constant__\nS\ns\n)\n{\ns\n.\nx\n+=\nthreadIdx\n.\nx\n;\n// Undefined Behavior: tried to modify read-only memory\n// Compiler will _not_ create a per-thread thread local copy of \"s\":\nunknown_function\n(\ns\n);\n}\n10.2.5.\n__managed__\nï\nThe\n__managed__\nmemory space specifier, optionally used together with\n__device__\n, declares a variable that:\nCan be referenced from both device and host code, for example, its address can be taken or it can be read or written directly from a device or host function.\nHas the lifetime of an application.\nSee\n__managed__ Memory Space Specifier\nfor more details.\n10.2.6.\n__restrict__\nï\nnvcc\nsupports restricted pointers via the\n__restrict__\nkeyword.\nRestricted pointers were introduced in C99 to alleviate the aliasing problem that exists in C-type languages, and which inhibits all kind of optimization from code re-ordering to common sub-expression elimination.\nHere is an example subject to the aliasing issue, where use of restricted pointer can help the compiler to reduce the number of instructions:\nvoid\nfoo\n(\nconst\nfloat\n*\na\n,\nconst\nfloat\n*\nb\n,\nfloat\n*\nc\n)\n{\nc\n[\n0\n]\n=\na\n[\n0\n]\n*\nb\n[\n0\n];\nc\n[\n1\n]\n=\na\n[\n0\n]\n*\nb\n[\n0\n];\nc\n[\n2\n]\n=\na\n[\n0\n]\n*\nb\n[\n0\n]\n*\na\n[\n1\n];\nc\n[\n3\n]\n=\na\n[\n0\n]\n*\na\n[\n1\n];\nc\n[\n4\n]\n=\na\n[\n0\n]\n*\nb\n[\n0\n];\nc\n[\n5\n]\n=\nb\n[\n0\n];\n...\n}\nIn C-type languages, the pointers\na\n,\nb\n, and\nc\nmay be aliased, so any write through\nc\ncould modify elements of\na\nor\nb\n. This means that to guarantee functional correctness, the compiler cannot load\na[0]\nand\nb[0]\ninto registers, multiply them, and store the result to both\nc[0]\nand\nc[1]\n, because the results would differ from the abstract execution model if, say,\na[0]\nis really the same location as\nc[0]\n. So the compiler cannot take advantage of the common sub-expression. Likewise, the compiler cannot just reorder the computation of\nc[4]\ninto the proximity of the computation of\nc[0]\nand\nc[1]\nbecause the preceding write to\nc[3]\ncould change the inputs to the computation of\nc[4]\n.\nBy making\na\n,\nb\n, and\nc\nrestricted pointers, the programmer asserts to the compiler that the pointers are in fact not aliased, which in this case means writes through\nc\nwould never overwrite elements of\na\nor\nb\n. This changes the function prototype as follows:\nvoid\nfoo\n(\nconst\nfloat\n*\n__restrict__\na\n,\nconst\nfloat\n*\n__restrict__\nb\n,\nfloat\n*\n__restrict__\nc\n);\nNote that all pointer arguments need to be made restricted for the compiler optimizer to derive any benefit. With the\n__restrict__\nkeywords added, the compiler can now reorder and do common sub-expression elimination at will, while retaining functionality identical with the abstract execution model:\nvoid\nfoo\n(\nconst\nfloat\n*\n__restrict__\na\n,\nconst\nfloat\n*\n__restrict__\nb\n,\nfloat\n*\n__restrict__\nc\n)\n{\nfloat\nt0\n=\na\n[\n0\n];\nfloat\nt1\n=\nb\n[\n0\n];\nfloat\nt2\n=\nt0\n*\nt1\n;\nfloat\nt3\n=\na\n[\n1\n];\nc\n[\n0\n]\n=\nt2\n;\nc\n[\n1\n]\n=\nt2\n;\nc\n[\n4\n]\n=\nt2\n;\nc\n[\n2\n]\n=\nt2\n*\nt3\n;\nc\n[\n3\n]\n=\nt0\n*\nt3\n;\nc\n[\n5\n]\n=\nt1\n;\n...\n}\nThe effects here are a reduced number of memory accesses and reduced number of computations. This is balanced by an increase in register pressure due to âcachedâ loads and common sub-expressions.\nSince register pressure is a critical issue in many CUDA codes, use of restricted pointers can have negative performance impact on CUDA code, due to reduced occupancy.\n10.3.\nBuilt-in Vector Types\nï\n10.3.1.\nchar, short, int, long, longlong, float, double\nï\nThese are vector types derived from the basic integer and floating-point types. They are structures and the 1st, 2nd, 3rd, and 4th components are accessible through the fields\nx\n,\ny\n,\nz\n, and\nw\n, respectively. They all come with a constructor function of the form\nmake_<type\nname>\n; for example,\nint2\nmake_int2\n(\nint\nx\n,\nint\ny\n);\nwhich creates a vector of type\nint2\nwith value\n(x,\ny)\n.\nThe alignment requirements of the vector types are detailed in\nTable 7\n.\nTable 7\nAlignment Requirements\nï\nType\nAlignment\nchar1, uchar1\n1\nchar2, uchar2\n2\nchar3, uchar3\n1\nchar4, uchar4\n4\nshort1, ushort1\n2\nshort2, ushort2\n4\nshort3, ushort3\n2\nshort4, ushort4\n8\nint1, uint1\n4\nint2, uint2\n8\nint3, uint3\n4\nint4, uint4\n16\nlong1, ulong1\n4 if sizeof(long) is equal to sizeof(int) 8, otherwise\nlong2, ulong2\n8 if sizeof(long) is equal to sizeof(int), 16, otherwise\nlong3, ulong3\n4 if sizeof(long) is equal to sizeof(int), 8, otherwise\nlong4\n3\n16\nlong4_16a\nlong4_32a\n32\nulong4\n3\n16\nulong4_16a\nulong4_32a\n32\nlonglong1, ulonglong1\n8\nlonglong2, ulonglong2\n16\nlonglong3, ulonglong3\n8\nlonglong4\n3\n16\nlonglong4_16a\nlonglong4_32a\n32\nulonglong4\n3\n16\nulonglong4_16a\nulonglong4_32a\n32\nfloat1\n4\nfloat2\n8\nfloat3\n4\nfloat4\n16\ndouble1\n8\ndouble2\n16\ndouble3\n8\ndouble4\n3\n16\ndouble4_16a\ndouble4_32a\n32\n3\n(\n1\n,\n2\n,\n3\n,\n4\n,\n5\n)\nThis vector type was deprecated in CUDA Toolkit 13.0.  Please use the\n_16a\nor\n_32a\nvariant instead, depending on your alignment requirements.\n10.3.2.\ndim3\nï\nThis type is an integer vector type based on\nuint3\nthat is used to specify dimensions. When defining a variable of type\ndim3\n, any component left unspecified is initialized to 1.\n10.4.\nBuilt-in Variables\nï\nBuilt-in variables specify the grid and block dimensions and the block and thread indices. They are only valid within functions that are executed on the device.\n10.4.1.\ngridDim\nï\nThis variable is of type\ndim3\n(see\ndim3\n) and contains the dimensions of the grid.\n10.4.2.\nblockIdx\nï\nThis variable is of type\nuint3\n(see\nchar, short, int, long, longlong, float, double\n) and contains the block index within the grid.\n10.4.3.\nblockDim\nï\nThis variable is of type\ndim3\n(see\ndim3\n) and contains the dimensions of the block.\n10.4.4.\nthreadIdx\nï\nThis variable is of type\nuint3\n(see\nchar, short, int, long, longlong, float, double\n) and contains the thread index within the block.\n10.4.5.\nwarpSize\nï\nThis variable is of type\nint\nand contains the warp size in threads (see\nSIMT Architecture\nfor the definition of a warp).\n10.5.\nMemory Fence Functions\nï\nThe CUDA programming model assumes a device with a weakly-ordered memory model, that is the order in which a CUDA thread writes data to shared memory, global memory, page-locked host memory, or the memory of a peer device is not necessarily the order in which the data is observed being written by another CUDA or host thread. It is undefined behavior for two threads to read from or write to the same memory location without synchronization.\nIn the following example, thread 1 executes\nwriteXY()\n, while thread 2 executes\nreadXY()\n.\n__device__\nint\nX\n=\n1\n,\nY\n=\n2\n;\n__device__\nvoid\nwriteXY\n()\n{\nX\n=\n10\n;\nY\n=\n20\n;\n}\n__device__\nvoid\nreadXY\n()\n{\nint\nB\n=\nY\n;\nint\nA\n=\nX\n;\n}\nThe two threads read and write from the same memory locations\nX\nand\nY\nsimultaneously. Any data-race is undefined behavior, and has no defined semantics. The resulting values for\nA\nand\nB\ncan be anything.\nMemory fence functions can be used to enforce a\nsequentially-consistent\nordering on memory accesses. The memory fence functions differ in the\nscope\nin which the orderings are enforced but they are independent of the accessed memory space (shared memory, global memory, page-locked host memory, and the memory of a peer device).\nvoid\n__threadfence_block\n();\nis equivalent to\ncuda::atomic_thread_fence(cuda::memory_order_seq_cst, cuda::thread_scope_block)\nand ensures that:\nAll writes to all memory made by the calling thread before the call to\n__threadfence_block()\nare observed by all threads in the block of the calling thread as occurring before all writes to all memory made by the calling thread after the call to\n__threadfence_block()\n;\nAll reads from all memory made by the calling thread before the call to\n__threadfence_block()\nare ordered before all reads from all memory made by the calling thread after the call to\n__threadfence_block()\n.\nvoid\n__threadfence\n();\nis equivalent to\ncuda::atomic_thread_fence(cuda::memory_order_seq_cst, cuda::thread_scope_device)\nand ensures that no writes to all memory made by the calling thread after the call to\n__threadfence()\nare observed by any thread in the device as occurring before any write to all memory made by the calling thread before the call to\n__threadfence()\n.\nvoid\n__threadfence_system\n();\nis equivalent to\ncuda::atomic_thread_fence(cuda::memory_order_seq_cst, cuda::thread_scope_system)\nand ensures that all writes to all memory made by the calling thread before the call to\n__threadfence_system()\nare observed by all threads in the device, host threads, and all threads in peer devices as occurring before all writes to all memory made by the calling thread after the call to\n__threadfence_system()\n.\n__threadfence_system()\nis only supported by devices of compute capability 2.x and higher.\nIn the previous code sample, we can insert fences in the codes as follows:\n__device__\nint\nX\n=\n1\n,\nY\n=\n2\n;\n__device__\nvoid\nwriteXY\n()\n{\nX\n=\n10\n;\n__threadfence\n();\nY\n=\n20\n;\n}\n__device__\nvoid\nreadXY\n()\n{\nint\nB\n=\nY\n;\n__threadfence\n();\nint\nA\n=\nX\n;\n}\nFor this code, the following outcomes can be observed:\nA\nequal to 1 and\nB\nequal to 2,\nA\nequal to 10 and\nB\nequal to 2,\nA\nequal to 10 and\nB\nequal to 20.\nThe fourth outcome is not possible, because the first write must be visible before the second write. If thread 1 and 2 belong to the same block, it is enough to use\n__threadfence_block()\n. If thread 1 and 2 do not belong to the same block,\n__threadfence()\nmust be used if they are CUDA threads from the same device and\n__threadfence_system()\nmust be used if they are CUDA threads from two different devices.\nA common use case is when threads consume some data produced by other threads as illustrated by the following code sample of a kernel that computes the sum of an array of N numbers in one call. Each block first sums a subset of the array and stores the result in global memory. When all blocks are done, the last block done reads each of these partial sums from global memory and sums them to obtain the final result. In order to determine which block is finished last, each block atomically increments a counter to signal that it is done with computing and storing its partial sum (see\nAtomic Functions\nabout atomic functions). The last block is the one that receives the counter value equal to\ngridDim.x-1\n. If no fence is placed between storing the partial sum and incrementing the counter, the counter might increment before the partial sum is stored and therefore, might reach\ngridDim.x-1\nand let the last block start reading partial sums before they have been actually updated in memory.\nMemory fence functions only affect the ordering of memory operations by a thread; they do not, by themselves, ensure that these memory operations are visible to other threads (like\n__syncthreads()\ndoes for threads within a block; see\nSynchronization Functions\n). In the code sample below, the visibility of memory operations on the\nresult\nvariable is ensured by declaring it as volatile (see\nVolatile Qualifier\n).\n__device__\nunsigned\nint\ncount\n=\n0\n;\n__shared__\nbool\nisLastBlockDone\n;\n__global__\nvoid\nsum\n(\nconst\nfloat\n*\narray\n,\nunsigned\nint\nN\n,\nvolatile\nfloat\n*\nresult\n)\n{\n// Each block sums a subset of the input array.\nfloat\npartialSum\n=\ncalculatePartialSum\n(\narray\n,\nN\n);\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\n// Thread 0 of each block stores the partial sum\n// to global memory. The compiler will use\n// a store operation that bypasses the L1 cache\n// since the \"result\" variable is declared as\n// volatile. This ensures that the threads of\n// the last block will read the correct partial\n// sums computed by all other blocks.\nresult\n[\nblockIdx\n.\nx\n]\n=\npartialSum\n;\n// Thread 0 makes sure that the incrementing\n// of the \"count\" variable is only performed after\n// the partial sum has been written to global memory.\n__threadfence\n();\n// Thread 0 signals that it is done.\nunsigned\nint\nvalue\n=\natomicInc\n(\n&\ncount\n,\ngridDim\n.\nx\n);\n// Thread 0 determines if its block is the last\n// block to be done.\nisLastBlockDone\n=\n(\nvalue\n==\n(\ngridDim\n.\nx\n-\n1\n));\n}\n// Synchronize to make sure that each thread reads\n// the correct value of isLastBlockDone.\n__syncthreads\n();\nif\n(\nisLastBlockDone\n)\n{\n// The last block sums the partial sums\n// stored in result[0 .. gridDim.x-1]\nfloat\ntotalSum\n=\ncalculateTotalSum\n(\nresult\n);\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\n// Thread 0 of last block stores the total sum\n// to global memory and resets the count\n// variable, so that the next kernel call\n// works properly.\nresult\n[\n0\n]\n=\ntotalSum\n;\ncount\n=\n0\n;\n}\n}\n}\n10.6.\nSynchronization Functions\nï\nvoid\n__syncthreads\n();\nwaits until all threads in the thread block have reached this point and all global and shared memory accesses made by these threads prior to\n__syncthreads()\nare visible to all threads in the block.\n__syncthreads()\nis used to coordinate communication between the threads of the same block. When some threads within a block access the same addresses in shared or global memory, there are potential read-after-write, write-after-read, or write-after-write hazards for some of these memory accesses. These data hazards can be avoided by synchronizing threads in-between these accesses.\n__syncthreads()\nis allowed in conditional code but only if the conditional evaluates identically across the entire thread block, otherwise the code execution is likely to hang or produce unintended side effects.\nDevices of compute capability 2.x and higher support three variations of\n__syncthreads()\ndescribed below.\nint\n__syncthreads_count\n(\nint\npredicate\n);\nis identical to\n__syncthreads()\nwith the additional feature that it evaluates predicate for all threads of the block and returns the number of threads for which predicate evaluates to non-zero.\nint\n__syncthreads_and\n(\nint\npredicate\n);\nis identical to\n__syncthreads()\nwith the additional feature that it evaluates predicate for all threads of the block and returns non-zero if and only if predicate evaluates to non-zero for all of them.\nint\n__syncthreads_or\n(\nint\npredicate\n);\nis identical to\n__syncthreads()\nwith the additional feature that it evaluates predicate for all threads of the block and returns non-zero if and only if predicate evaluates to non-zero for any of them.\nvoid\n__syncwarp\n(\nunsigned\nmask\n=\n0xffffffff\n);\nwill cause the executing thread to wait until all warp lanes named in mask have executed a\n__syncwarp()\n(with the same mask) before resuming execution. Each calling thread must have its own bit set in the mask and all non-exited threads named in mask must execute a corresponding\n__syncwarp()\nwith the same mask, or the result is undefined.\nExecuting\n__syncwarp()\nguarantees memory ordering among threads participating in the barrier. Thus, threads within a warp that wish to communicate via memory can store to memory, execute\n__syncwarp()\n, and then safely read values stored by other threads in the warp.\nNote\nFor .target sm_6x or below, all threads in mask must execute the same\n__syncwarp()\nin convergence, and the union of all values in mask must be equal to the active mask. Otherwise, the behavior is undefined.\n10.7.\nMathematical Functions\nï\nThe reference manual lists all C/C++ standard library mathematical functions that are supported in device code and all intrinsic functions that are only supported in device code.\nMathematical Functions\nprovides accuracy information for some of these functions when relevant.\n10.8.\nTexture Functions\nï\nTexture objects are described in\nTexture Object API\n.\nTexture fetching is described in\nTexture Fetching\n.\n10.8.1.\nTexture Object API\nï\n10.8.1.1.\ntex1Dfetch()\nï\ntemplate\n<\nclass\nT\n>\nT\ntex1Dfetch\n(\ncudaTextureObject_t\ntexObj\n,\nint\nx\n);\nfetches from the region of linear memory specified by the one-dimensional texture object\ntexObj\nusing integer texture coordinate\nx\n.\ntex1Dfetch()\nonly works with non-normalized coordinates, so only the border and clamp addressing modes are supported. It does not perform any texture filtering. For integer types, it may optionally promote the integer to single-precision floating point.\n10.8.1.2.\ntex1D()\nï\ntemplate\n<\nclass\nT\n>\nT\ntex1D\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n);\nfetches from the CUDA array specified by the one-dimensional texture object\ntexObj\nusing texture coordinate\nx\n.\n10.8.1.3.\ntex1DLod()\nï\ntemplate\n<\nclass\nT\n>\nT\ntex1DLod\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\nlevel\n);\nfetches from the CUDA array specified by the one-dimensional texture object\ntexObj\nusing texture coordinate\nx\nat the level-of-detail\nlevel\n.\n10.8.1.4.\ntex1DGrad()\nï\ntemplate\n<\nclass\nT\n>\nT\ntex1DGrad\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ndx\n,\nfloat\ndy\n);\nfetches from the CUDA array specified by the one-dimensional texture object\ntexObj\nusing texture coordinate\nx\n. The level-of-detail is derived from the X-gradient\ndx\nand Y-gradient\ndy\n.\n10.8.1.5.\ntex2D()\nï\ntemplate\n<\nclass\nT\n>\nT\ntex2D\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n);\nfetches from the CUDA array or the region of linear memory specified by the two-dimensional texture object\ntexObj\nusing texture coordinate\n(x,y)\n.\n10.8.1.6.\ntex2D() for sparse CUDA arrays\nï\ntemplate\n<\nclass\nT\n>\nT\ntex2D\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n,\nbool\n*\nisResident\n);\nfetches from the CUDA array specified by the two-dimensional texture object\ntexObj\nusing texture coordinate\n(x,y)\n. Also returns whether the texel is resident in memory via\nisResident\npointer. If not, the values fetched will be zeros.\n10.8.1.7.\ntex2Dgather()\nï\ntemplate\n<\nclass\nT\n>\nT\ntex2Dgather\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n,\nint\ncomp\n=\n0\n);\nfetches from the CUDA array specified by the 2D texture object\ntexObj\nusing texture coordinates\nx\nand\ny\nand the\ncomp\nparameter as described in\nTexture Gather\n.\n10.8.1.8.\ntex2Dgather() for sparse CUDA arrays\nï\ntemplate\n<\nclass\nT\n>\nT\ntex2Dgather\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n,\nbool\n*\nisResident\n,\nint\ncomp\n=\n0\n);\nfetches from the CUDA array specified by the 2D texture object\ntexObj\nusing texture coordinates\nx\nand\ny\nand the\ncomp\nparameter as described in\nTexture Gather\n. Also returns whether the texel is resident in memory via\nisResident\npointer. If not, the values fetched will be zeros.\n10.8.1.9.\ntex2DGrad()\nï\ntemplate\n<\nclass\nT\n>\nT\ntex2DGrad\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n,\nfloat2\ndx\n,\nfloat2\ndy\n);\nfetches from the CUDA array specified by the two-dimensional texture object\ntexObj\nusing texture coordinate\n(x,y)\n. The level-of-detail is derived from the\ndx\nand\ndy\ngradients.\n10.8.1.10.\ntex2DGrad() for sparse CUDA arrays\nï\ntemplate\n<\nclass\nT\n>\nT\ntex2DGrad\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n,\nfloat2\ndx\n,\nfloat2\ndy\n,\nbool\n*\nisResident\n);\nfetches from the CUDA array specified by the two-dimensional texture object\ntexObj\nusing texture coordinate\n(x,y)\n. The level-of-detail is derived from the\ndx\nand\ndy\ngradients. Also returns whether the texel is resident in memory via\nisResident\npointer. If not, the values fetched will be zeros.\n10.8.1.11.\ntex2DLod()\nï\ntemplate\n<\nclass\nT\n>\ntex2DLod\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n,\nfloat\nlevel\n);\nfetches from the CUDA array or the region of linear memory specified by the two-dimensional texture object\ntexObj\nusing texture coordinate\n(x,y)\nat level-of-detail\nlevel\n.\n10.8.1.12.\ntex2DLod() for sparse CUDA arrays\nï\ntemplate\n<\nclass\nT\n>\ntex2DLod\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n,\nfloat\nlevel\n,\nbool\n*\nisResident\n);\nfetches from the CUDA array specified by the two-dimensional texture object\ntexObj\nusing texture coordinate\n(x,y)\nat level-of-detail\nlevel\n. Also returns whether the texel is resident in memory via\nisResident\npointer. If not, the values fetched will be zeros.\n10.8.1.13.\ntex3D()\nï\ntemplate\n<\nclass\nT\n>\nT\ntex3D\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n,\nfloat\nz\n);\nfetches from the CUDA array specified by the three-dimensional texture object\ntexObj\nusing texture coordinate\n(x,y,z)\n.\n10.8.1.14.\ntex3D() for sparse CUDA arrays\nï\ntemplate\n<\nclass\nT\n>\nT\ntex3D\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n,\nfloat\nz\n,\nbool\n*\nisResident\n);\nfetches from the CUDA array specified by the three-dimensional texture object\ntexObj\nusing texture coordinate\n(x,y,z)\n. Also returns whether the texel is resident in memory via\nisResident\npointer. If not, the values fetched will be zeros.\n10.8.1.15.\ntex3DLod()\nï\ntemplate\n<\nclass\nT\n>\nT\ntex3DLod\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n,\nfloat\nz\n,\nfloat\nlevel\n);\nfetches from the CUDA array or the region of linear memory specified by the three-dimensional texture object\ntexObj\nusing texture coordinate\n(x,y,z)\nat level-of-detail\nlevel\n.\n10.8.1.16.\ntex3DLod() for sparse CUDA arrays\nï\ntemplate\n<\nclass\nT\n>\nT\ntex3DLod\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n,\nfloat\nz\n,\nfloat\nlevel\n,\nbool\n*\nisResident\n);\nfetches from the CUDA array or the region of linear memory specified by the three-dimensional texture object\ntexObj\nusing texture coordinate\n(x,y,z)\nat level-of-detail\nlevel\n. Also returns whether the texel is resident in memory via\nisResident\npointer. If not, the values fetched will be zeros.\n10.8.1.17.\ntex3DGrad()\nï\ntemplate\n<\nclass\nT\n>\nT\ntex3DGrad\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n,\nfloat\nz\n,\nfloat4\ndx\n,\nfloat4\ndy\n);\nfetches from the CUDA array specified by the three-dimensional texture object\ntexObj\nusing texture coordinate\n(x,y,z)\nat a level-of-detail derived from the X and Y gradients\ndx\nand\ndy\n.\n10.8.1.18.\ntex3DGrad() for sparse CUDA arrays\nï\ntemplate\n<\nclass\nT\n>\nT\ntex3DGrad\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n,\nfloat\nz\n,\nfloat4\ndx\n,\nfloat4\ndy\n,\nbool\n*\nisResident\n);\nfetches from the CUDA array specified by the three-dimensional texture object\ntexObj\nusing texture coordinate\n(x,y,z)\nat a level-of-detail derived from the X and Y gradients\ndx\nand\ndy\n. Also returns whether the texel is resident in memory via\nisResident\npointer. If not, the values fetched will be zeros.\n10.8.1.19.\ntex1DLayered()\nï\ntemplate\n<\nclass\nT\n>\nT\ntex1DLayered\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nint\nlayer\n);\nfetches from the CUDA array specified by the one-dimensional texture object\ntexObj\nusing texture coordinate\nx\nand index\nlayer\n, as described in\nLayered Textures\n.\n10.8.1.20.\ntex1DLayeredLod()\nï\ntemplate\n<\nclass\nT\n>\nT\ntex1DLayeredLod\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nint\nlayer\n,\nfloat\nlevel\n);\nfetches from the CUDA array specified by the one-dimensional\nLayered Textures\nat layer\nlayer\nusing texture coordinate\nx\nand level-of-detail\nlevel\n.\n10.8.1.21.\ntex1DLayeredGrad()\nï\ntemplate\n<\nclass\nT\n>\nT\ntex1DLayeredGrad\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nint\nlayer\n,\nfloat\ndx\n,\nfloat\ndy\n);\nfetches from the CUDA array specified by the one-dimensional\nlayered texture\nat layer\nlayer\nusing texture coordinate\nx\nand a level-of-detail derived from the\ndx\nand\ndy\ngradients.\n10.8.1.22.\ntex2DLayered()\nï\ntemplate\n<\nclass\nT\n>\nT\ntex2DLayered\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n,\nint\nlayer\n);\nfetches from the CUDA array specified by the two-dimensional texture object\ntexObj\nusing texture coordinate\n(x,y)\nand index\nlayer\n, as described in\nLayered Textures\n.\n10.8.1.23.\ntex2DLayered() for Sparse CUDA Arrays\nï\ntemplate\n<\nclass\nT\n>\nT\ntex2DLayered\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n,\nint\nlayer\n,\nbool\n*\nisResident\n);\nfetches from the CUDA array specified by the two-dimensional texture object\ntexObj\nusing texture coordinate\n(x,y)\nand index\nlayer\n, as described in\nLayered Textures\n. Also returns whether the texel is resident in memory via\nisResident\npointer. If not, the values fetched will be zeros.\n10.8.1.24.\ntex2DLayeredLod()\nï\ntemplate\n<\nclass\nT\n>\nT\ntex2DLayeredLod\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n,\nint\nlayer\n,\nfloat\nlevel\n);\nfetches from the CUDA array specified by the two-dimensional\nlayered texture\nat layer\nlayer\nusing texture coordinate\n(x,y)\n.\n10.8.1.25.\ntex2DLayeredLod() for sparse CUDA arrays\nï\ntemplate\n<\nclass\nT\n>\nT\ntex2DLayeredLod\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n,\nint\nlayer\n,\nfloat\nlevel\n,\nbool\n*\nisResident\n);\nfetches from the CUDA array specified by the two-dimensional\nlayered texture\nat layer\nlayer\nusing texture coordinate\n(x,y)\n. Also returns whether the texel is resident in memory via\nisResident\npointer. If not, the values fetched will be zeros.\n10.8.1.26.\ntex2DLayeredGrad()\nï\ntemplate\n<\nclass\nT\n>\nT\ntex2DLayeredGrad\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n,\nint\nlayer\n,\nfloat2\ndx\n,\nfloat2\ndy\n);\nfetches from the CUDA array specified by the two-dimensional\nlayered texture\nat layer\nlayer\nusing texture coordinate\n(x,y)\nand a level-of-detail derived from the\ndx\nand\ndy\ngradients.\n10.8.1.27.\ntex2DLayeredGrad() for sparse CUDA arrays\nï\ntemplate\n<\nclass\nT\n>\nT\ntex2DLayeredGrad\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n,\nint\nlayer\n,\nfloat2\ndx\n,\nfloat2\ndy\n,\nbool\n*\nisResident\n);\nfetches from the CUDA array specified by the two-dimensional\nlayered texture\nat layer\nlayer\nusing texture coordinate\n(x,y)\nand a level-of-detail derived from the\ndx\nand\ndy\ngradients. Also returns whether the texel is resident in memory via\nisResident\npointer. If not, the values fetched will be zeros.\n10.8.1.28.\ntexCubemap()\nï\ntemplate\n<\nclass\nT\n>\nT\ntexCubemap\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n,\nfloat\nz\n);\nfetches the CUDA array specified by the cubemap texture object\ntexObj\nusing texture coordinate\n(x,y,z)\n, as described in\nCubemap Textures\n.\n10.8.1.29.\ntexCubemapGrad()\nï\ntemplate\n<\nclass\nT\n>\nT\ntexCubemapGrad\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\n,\ny\n,\nfloat\nz\n,\nfloat4\ndx\n,\nfloat4\ndy\n);\nfetches from the CUDA array specified by the cubemap texture object\ntexObj\nusing texture coordinate\n(x,y,z)\nas described in\nCubemap Textures\n. The level-of-detail used is derived from the\ndx\nand\ndy\ngradients.\n10.8.1.30.\ntexCubemapLod()\nï\ntemplate\n<\nclass\nT\n>\nT\ntexCubemapLod\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\n,\ny\n,\nfloat\nz\n,\nfloat\nlevel\n);\nfetches from the CUDA array specified by the cubemap texture object\ntexObj\nusing texture coordinate\n(x,y,z)\nas described in\nCubemap Textures\n. The level-of-detail used is given by\nlevel\n.\n10.8.1.31.\ntexCubemapLayered()\nï\ntemplate\n<\nclass\nT\n>\nT\ntexCubemapLayered\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n,\nfloat\nz\n,\nint\nlayer\n);\nfetches from the CUDA array specified by the cubemap layered texture object\ntexObj\nusing texture coordinates\n(x,y,z)\n, and index\nlayer\n, as described in\nCubemap Layered Textures\n.\n10.8.1.32.\ntexCubemapLayeredGrad()\nï\ntemplate\n<\nclass\nT\n>\nT\ntexCubemapLayeredGrad\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n,\nfloat\nz\n,\nint\nlayer\n,\nfloat4\ndx\n,\nfloat4\ndy\n);\nfetches from the CUDA array specified by the cubemap layered texture object\ntexObj\nusing texture coordinate\n(x,y,z)\nand index\nlayer\n, as described in\nCubemap Layered Textures\n, at level-of-detail derived from the\ndx\nand\ndy\ngradients.\n10.8.1.33.\ntexCubemapLayeredLod()\nï\ntemplate\n<\nclass\nT\n>\nT\ntexCubemapLayeredLod\n(\ncudaTextureObject_t\ntexObj\n,\nfloat\nx\n,\nfloat\ny\n,\nfloat\nz\n,\nint\nlayer\n,\nfloat\nlevel\n);\nfetches from the CUDA array specified by the cubemap layered texture object\ntexObj\nusing texture coordinate\n(x,y,z)\nand index\nlayer\n, as described in\nCubemap Layered Textures\n, at level-of-detail level\nlevel\n.\n10.9.\nSurface Functions\nï\nSurface functions are only supported by devices of compute capability 2.0 and higher.\nSurface objects are described in described in\nSurface Object API\n.\nIn the sections below,\nboundaryMode\nspecifies the boundary mode, that is how out-of-range surface coordinates are handled; it is equal to either\ncudaBoundaryModeClamp\n, in which case out-of-range coordinates are clamped to the valid range, or\ncudaBoundaryModeZero\n, in which case out-of-range reads return zero and out-of-range writes are ignored, or\ncudaBoundaryModeTrap\n, in which case out-of-range accesses cause the kernel execution to fail.\n10.9.1.\nSurface Object API\nï\n10.9.1.1.\nsurf1Dread()\nï\ntemplate\n<\nclass\nT\n>\nT\nsurf1Dread\n(\ncudaSurfaceObject_t\nsurfObj\n,\nint\nx\n,\nboundaryMode\n=\ncudaBoundaryModeTrap\n);\nreads the CUDA array specified by the one-dimensional surface object\nsurfObj\nusing byte coordinate x.\n10.9.1.2.\nsurf1Dwrite\nï\ntemplate\n<\nclass\nT\n>\nvoid\nsurf1Dwrite\n(\nT\ndata\n,\ncudaSurfaceObject_t\nsurfObj\n,\nint\nx\n,\nboundaryMode\n=\ncudaBoundaryModeTrap\n);\nwrites value data to the CUDA array specified by the one-dimensional surface object\nsurfObj\nat byte coordinate x.\n10.9.1.3.\nsurf2Dread()\nï\ntemplate\n<\nclass\nT\n>\nT\nsurf2Dread\n(\ncudaSurfaceObject_t\nsurfObj\n,\nint\nx\n,\nint\ny\n,\nboundaryMode\n=\ncudaBoundaryModeTrap\n);\ntemplate\n<\nclass\nT\n>\nvoid\nsurf2Dread\n(\nT\n*\ndata\n,\ncudaSurfaceObject_t\nsurfObj\n,\nint\nx\n,\nint\ny\n,\nboundaryMode\n=\ncudaBoundaryModeTrap\n);\nreads the CUDA array specified by the two-dimensional surface object\nsurfObj\nusing byte coordinates x and y.\n10.9.1.4.\nsurf2Dwrite()\nï\ntemplate\n<\nclass\nT\n>\nvoid\nsurf2Dwrite\n(\nT\ndata\n,\ncudaSurfaceObject_t\nsurfObj\n,\nint\nx\n,\nint\ny\n,\nboundaryMode\n=\ncudaBoundaryModeTrap\n);\nwrites value data to the CUDA array specified by the two-dimensional surface object\nsurfObj\nat byte coordinate x and y.\n10.9.1.5.\nsurf3Dread()\nï\ntemplate\n<\nclass\nT\n>\nT\nsurf3Dread\n(\ncudaSurfaceObject_t\nsurfObj\n,\nint\nx\n,\nint\ny\n,\nint\nz\n,\nboundaryMode\n=\ncudaBoundaryModeTrap\n);\ntemplate\n<\nclass\nT\n>\nvoid\nsurf3Dread\n(\nT\n*\ndata\n,\ncudaSurfaceObject_t\nsurfObj\n,\nint\nx\n,\nint\ny\n,\nint\nz\n,\nboundaryMode\n=\ncudaBoundaryModeTrap\n);\nreads the CUDA array specified by the three-dimensional surface object\nsurfObj\nusing byte coordinates x, y, and z.\n10.9.1.6.\nsurf3Dwrite()\nï\ntemplate\n<\nclass\nT\n>\nvoid\nsurf3Dwrite\n(\nT\ndata\n,\ncudaSurfaceObject_t\nsurfObj\n,\nint\nx\n,\nint\ny\n,\nint\nz\n,\nboundaryMode\n=\ncudaBoundaryModeTrap\n);\nwrites value data to the CUDA array specified by the three-dimensional object\nsurfObj\nat byte coordinate x, y, and z.\n10.9.1.7.\nsurf1DLayeredread()\nï\ntemplate\n<\nclass\nT\n>\nT\nsurf1DLayeredread\n(\ncudaSurfaceObject_t\nsurfObj\n,\nint\nx\n,\nint\nlayer\n,\nboundaryMode\n=\ncudaBoundaryModeTrap\n);\ntemplate\n<\nclass\nT\n>\nvoid\nsurf1DLayeredread\n(\nT\ndata\n,\ncudaSurfaceObject_t\nsurfObj\n,\nint\nx\n,\nint\nlayer\n,\nboundaryMode\n=\ncudaBoundaryModeTrap\n);\nreads the CUDA array specified by the one-dimensional layered surface object\nsurfObj\nusing byte coordinate x and index\nlayer\n.\n10.9.1.8.\nsurf1DLayeredwrite()\nï\ntemplate\n<\nclass\nType\n>\nvoid\nsurf1DLayeredwrite\n(\nT\ndata\n,\ncudaSurfaceObject_t\nsurfObj\n,\nint\nx\n,\nint\nlayer\n,\nboundaryMode\n=\ncudaBoundaryModeTrap\n);\nwrites value data to the CUDA array specified by the two-dimensional layered surface object\nsurfObj\nat byte coordinate x and index\nlayer\n.\n10.9.1.9.\nsurf2DLayeredread()\nï\ntemplate\n<\nclass\nT\n>\nT\nsurf2DLayeredread\n(\ncudaSurfaceObject_t\nsurfObj\n,\nint\nx\n,\nint\ny\n,\nint\nlayer\n,\nboundaryMode\n=\ncudaBoundaryModeTrap\n);\ntemplate\n<\nclass\nT\n>\nvoid\nsurf2DLayeredread\n(\nT\ndata\n,\ncudaSurfaceObject_t\nsurfObj\n,\nint\nx\n,\nint\ny\n,\nint\nlayer\n,\nboundaryMode\n=\ncudaBoundaryModeTrap\n);\nreads the CUDA array specified by the two-dimensional layered surface object\nsurfObj\nusing byte coordinate x and y, and index\nlayer\n.\n10.9.1.10.\nsurf2DLayeredwrite()\nï\ntemplate\n<\nclass\nT\n>\nvoid\nsurf2DLayeredwrite\n(\nT\ndata\n,\ncudaSurfaceObject_t\nsurfObj\n,\nint\nx\n,\nint\ny\n,\nint\nlayer\n,\nboundaryMode\n=\ncudaBoundaryModeTrap\n);\nwrites value data to the CUDA array specified by the one-dimensional layered surface object\nsurfObj\nat byte coordinate x and y, and index\nlayer\n.\n10.9.1.11.\nsurfCubemapread()\nï\ntemplate\n<\nclass\nT\n>\nT\nsurfCubemapread\n(\ncudaSurfaceObject_t\nsurfObj\n,\nint\nx\n,\nint\ny\n,\nint\nface\n,\nboundaryMode\n=\ncudaBoundaryModeTrap\n);\ntemplate\n<\nclass\nT\n>\nvoid\nsurfCubemapread\n(\nT\ndata\n,\ncudaSurfaceObject_t\nsurfObj\n,\nint\nx\n,\nint\ny\n,\nint\nface\n,\nboundaryMode\n=\ncudaBoundaryModeTrap\n);\nreads the CUDA array specified by the cubemap surface object\nsurfObj\nusing byte coordinate x and y, and face index face.\n10.9.1.12.\nsurfCubemapwrite()\nï\ntemplate\n<\nclass\nT\n>\nvoid\nsurfCubemapwrite\n(\nT\ndata\n,\ncudaSurfaceObject_t\nsurfObj\n,\nint\nx\n,\nint\ny\n,\nint\nface\n,\nboundaryMode\n=\ncudaBoundaryModeTrap\n);\nwrites value data to the CUDA array specified by the cubemap object\nsurfObj\nat byte coordinate x and y, and face index face.\n10.9.1.13.\nsurfCubemapLayeredread()\nï\ntemplate\n<\nclass\nT\n>\nT\nsurfCubemapLayeredread\n(\ncudaSurfaceObject_t\nsurfObj\n,\nint\nx\n,\nint\ny\n,\nint\nlayerFace\n,\nboundaryMode\n=\ncudaBoundaryModeTrap\n);\ntemplate\n<\nclass\nT\n>\nvoid\nsurfCubemapLayeredread\n(\nT\ndata\n,\ncudaSurfaceObject_t\nsurfObj\n,\nint\nx\n,\nint\ny\n,\nint\nlayerFace\n,\nboundaryMode\n=\ncudaBoundaryModeTrap\n);\nreads the CUDA array specified by the cubemap layered surface object\nsurfObj\nusing byte coordinate x and y, and index\nlayerFace.\n10.9.1.14.\nsurfCubemapLayeredwrite()\nï\ntemplate\n<\nclass\nT\n>\nvoid\nsurfCubemapLayeredwrite\n(\nT\ndata\n,\ncudaSurfaceObject_t\nsurfObj\n,\nint\nx\n,\nint\ny\n,\nint\nlayerFace\n,\nboundaryMode\n=\ncudaBoundaryModeTrap\n);\nwrites value data to the CUDA array specified by the cubemap layered object\nsurfObj\nat byte coordinate\nx\nand\ny\n, and index\nlayerFace\n.\n10.10.\nRead-Only Data Cache Load Function\nï\nThe read-only data cache load function is only supported by devices of compute capability 5.0 and higher.\nT\n__ldg\n(\nconst\nT\n*\naddress\n);\nreturns the data of type\nT\nlocated at address\naddress\n, where\nT\nis\nchar\n,\nsigned\nchar\n,\nshort\n,\nint\n,\nlong\n,\nlong\nlong\nunsigned\nchar\n,\nunsigned\nshort\n,\nunsigned\nint\n,\nunsigned\nlong\n,\nunsigned\nlong\nlong\n,\nchar2\n,\nchar4\n,\nshort2\n,\nshort4\n,\nint2\n,\nint4\n,\nlonglong2\nuchar2\n,\nuchar4\n,\nushort2\n,\nushort4\n,\nuint2\n,\nuint4\n,\nulonglong2\nfloat\n,\nfloat2\n,\nfloat4\n,\ndouble\n, or\ndouble2\n. With the\ncuda_fp16.h\nheader included,\nT\ncan be\n__half\nor\n__half2\n. Similarly, with the\ncuda_bf16.h\nheader included,\nT\ncan also be\n__nv_bfloat16\nor\n__nv_bfloat162\n. The operation is cached in the read-only data cache (see\nGlobal Memory\n).\n10.11.\nLoad Functions Using Cache Hints\nï\nThese load functions are only supported by devices of compute capability 5.0 and higher.\nT\n__ldcg\n(\nconst\nT\n*\naddress\n);\nT\n__ldca\n(\nconst\nT\n*\naddress\n);\nT\n__ldcs\n(\nconst\nT\n*\naddress\n);\nT\n__ldlu\n(\nconst\nT\n*\naddress\n);\nT\n__ldcv\n(\nconst\nT\n*\naddress\n);\nreturns the data of type\nT\nlocated at address\naddress\n, where\nT\nis\nchar\n,\nsigned\nchar\n,\nshort\n,\nint\n,\nlong\n,\nlong\nlong\nunsigned\nchar\n,\nunsigned\nshort\n,\nunsigned\nint\n,\nunsigned\nlong\n,\nunsigned\nlong\nlong\n,\nchar2\n,\nchar4\n,\nshort2\n,\nshort4\n,\nint2\n,\nint4\n,\nlonglong2\nuchar2\n,\nuchar4\n,\nushort2\n,\nushort4\n,\nuint2\n,\nuint4\n,\nulonglong2\nfloat\n,\nfloat2\n,\nfloat4\n,\ndouble\n, or\ndouble2\n. With the\ncuda_fp16.h\nheader included,\nT\ncan be\n__half\nor\n__half2\n. Similarly, with the\ncuda_bf16.h\nheader included,\nT\ncan also be\n__nv_bfloat16\nor\n__nv_bfloat162\n. The operation is using the corresponding cache operator (see\nPTX ISA\n)\n10.12.\nStore Functions Using Cache Hints\nï\nThese store functions are only supported by devices of compute capability 5.0 and higher.\nvoid\n__stwb\n(\nT\n*\naddress\n,\nT\nvalue\n);\nvoid\n__stcg\n(\nT\n*\naddress\n,\nT\nvalue\n);\nvoid\n__stcs\n(\nT\n*\naddress\n,\nT\nvalue\n);\nvoid\n__stwt\n(\nT\n*\naddress\n,\nT\nvalue\n);\nstores the\nvalue\nargument of type\nT\nto the location at address\naddress\n, where\nT\nis\nchar\n,\nsigned\nchar\n,\nshort\n,\nint\n,\nlong\n,\nlong\nlong\nunsigned\nchar\n,\nunsigned\nshort\n,\nunsigned\nint\n,\nunsigned\nlong\n,\nunsigned\nlong\nlong\n,\nchar2\n,\nchar4\n,\nshort2\n,\nshort4\n,\nint2\n,\nint4\n,\nlonglong2\nuchar2\n,\nuchar4\n,\nushort2\n,\nushort4\n,\nuint2\n,\nuint4\n,\nulonglong2\nfloat\n,\nfloat2\n,\nfloat4\n,\ndouble\n, or\ndouble2\n. With the\ncuda_fp16.h\nheader included,\nT\ncan be\n__half\nor\n__half2\n. Similarly, with the\ncuda_bf16.h\nheader included,\nT\ncan also be\n__nv_bfloat16\nor\n__nv_bfloat162\n. The operation is using the corresponding cache operator (see\nPTX ISA\n)\n10.13.\nTime Function\nï\nclock_t\nclock\n();\nlong\nlong\nint\nclock64\n();\nwhen executed in device code, returns the value of a per-multiprocessor counter that is incremented every clock cycle. Sampling this counter at the beginning and at the end of a kernel, taking the difference of the two samples, and recording the result per thread provides a measure for each thread of the number of clock cycles taken by the device to completely execute the thread, but not of the number of clock cycles the device actually spent executing thread instructions. The former number is greater than the latter since threads are time sliced.\n10.14.\nAtomic Functions\nï\nAn atomic function performs a read-modify-write atomic operation on one 32-bit, 64-bit, or 128-bit word residing in global or shared memory. In the case of\nfloat2\nor\nfloat4\n, the read-modify-write operation is performed on each element of the vector residing in global memory. For example,\natomicAdd()\nreads a word at some address in global or shared memory, adds a number to it, and writes the result back to the same address. Atomic functions can only be used in device functions.\nThe atomic functions described in this section have ordering\ncuda::memory_order_relaxed\nand are only atomic at a particular\nscope\n:\nAtomic APIs with\n_system\nsuffix (example:\natomicAdd_system\n) are atomic at scope\ncuda::thread_scope_system\nif they meet particular\nconditions\n.\nAtomic APIs without a suffix (example:\natomicAdd\n) are atomic at scope\ncuda::thread_scope_device\n.\nAtomic APIs with\n_block\nsuffix (example:\natomicAdd_block\n) are atomic at scope\ncuda::thread_scope_block\n.\nIn the following example both the CPU and the GPU atomically update an integer value at address\naddr\n:\n__global__\nvoid\nmykernel\n(\nint\n*\naddr\n)\n{\natomicAdd_system\n(\naddr\n,\n10\n);\n// only available on devices with compute capability 6.x\n}\nvoid\nfoo\n()\n{\nint\n*\naddr\n;\ncudaMallocManaged\n(\n&\naddr\n,\n4\n);\n*\naddr\n=\n0\n;\nmykernel\n<<<\n...\n>>>\n(\naddr\n);\n__sync_fetch_and_add\n(\naddr\n,\n10\n);\n// CPU atomic operation\n}\nNote that any atomic operation can be implemented based on\natomicCAS()\n(Compare And Swap). For example,\natomicAdd()\nfor double-precision floating-point numbers is not available on devices with compute capability lower than 6.0 but it can be implemented as follows:\n#if __CUDA_ARCH__ < 600\n__device__\ndouble\natomicAdd\n(\ndouble\n*\naddress\n,\ndouble\nval\n)\n{\nunsigned\nlong\nlong\nint\n*\naddress_as_ull\n=\n(\nunsigned\nlong\nlong\nint\n*\n)\naddress\n;\nunsigned\nlong\nlong\nint\nold\n=\n*\naddress_as_ull\n,\nassumed\n;\ndo\n{\nassumed\n=\nold\n;\nold\n=\natomicCAS\n(\naddress_as_ull\n,\nassumed\n,\n__double_as_longlong\n(\nval\n+\n__longlong_as_double\n(\nassumed\n)));\n// Note: uses integer comparison to avoid hang in case of NaN (since NaN != NaN)\n}\nwhile\n(\nassumed\n!=\nold\n);\nreturn\n__longlong_as_double\n(\nold\n);\n}\n#endif\nThere are system-wide and block-wide variants of the following device-wide atomic APIs, with the following exceptions:\nDevices with compute capability less than 6.0 only support device-wide atomic operations,\nTegra devices with compute capability less than 7.2 do not support system-wide atomic operations.\nCUDA 12.8 and later support CUDA compiler builtin functions for atomic operations with memory order and thread scope. We follows the\nGNUâs atomic built-in function signature\nwith an extra argument of thread scope.\nWe use the following atomic operation memory orders and thread scopes:\nenum\n{\n__NV_ATOMIC_RELAXED\n,\n__NV_ATOMIC_CONSUME\n,\n__NV_ATOMIC_ACQUIRE\n,\n__NV_ATOMIC_RELEASE\n,\n__NV_ATOMIC_ACQ_REL\n,\n__NV_ATOMIC_SEQ_CST\n};\nenum\n{\n__NV_THREAD_SCOPE_THREAD\n,\n__NV_THREAD_SCOPE_BLOCK\n,\n__NV_THREAD_SCOPE_CLUSTER\n,\n__NV_THREAD_SCOPE_DEVICE\n,\n__NV_THREAD_SCOPE_SYSTEM\n};\nExample:\n__device__\nT\n__nv_atomic_load_n\n(\nT\n*\nptr\n,\nint\norder\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\nT can be any integral type that is size of 1, 2, 4, 8 and 16 bytes.\nThese atomic functions cannot operate on local memory. For example:\n__device__\nvoid\nfoo\n()\n{\nint\na\n=\n1\n;\n// defined in local memory\nint\nb\n;\n__nv_atomic_load\n(\n&\na\n,\n&\nb\n,\n__NV_ATOMIC_RELAXED\n,\n__NV_THREAD_SCOPE_SYSTEM\n);\n}\nThese functions must only be used within the block scope of a\n__device__\nfunction. For example:\n__device__\nvoid\nfoo\n()\n{\n__shared__\nunsigned\nint\nu1\n=\n1\n;\n__shared__\nunsigned\nint\nu2\n=\n2\n;\n__nv_atomic_load\n(\n&\nu1\n,\n&\nu2\n,\n__NV_ATOMIC_RELAXED\n,\n__NV_THREAD_SCOPE_SYSTEM\n);\n}\nAnd these functionsâ address cannot be taken. Here are three unsupported examples:\n// Not permitted to be used in a host function\n__host__\nvoid\nbar\n()\n{\n__shared__\nunsigned\nint\nu1\n=\n1\n;\n__shared__\nunsigned\nint\nu2\n=\n2\n;\n__nv_atomic_load\n(\n&\nu1\n,\n&\nu2\n,\n__NV_ATOMIC_RELAXED\n,\n__NV_THREAD_SCOPE_SYSTEM\n);\n}\n// Not permitted to be used as a template default argument.\n// The function address cannot be taken.\ntemplate\n<\nvoid\n*\nF\n=\n__nv_atomic_load_n\n>\nclass\nX\n{\nvoid\n*\nf\n=\nF\n;\n};\n// Not permitted to be called in a constructor initialization list.\nclass\nY\n{\nint\na\n;\npublic\n:\n__device__\nY\n(\nint\n*\nb\n)\n:\na\n(\n__nv_atomic_load_n\n(\nb\n,\n__NV_ATOMIC_RELAXED\n))\n{}\n};\nThe memory order corresponds to\nC++ standard atomic operationâs memory order\n. And for thread scope, we follows cuda::thread_scopeâs\ndefinition\n.\n__NV_ATOMIC_CONSUME\nmemory order is currently implemented using stronger\n__NV_ATOMIC_ACQUIRE\nmemory order.\n__NV_THREAD_SCOPE_THREAD\nthread scope is currently implemented using wider\n__NV_THREAD_SCOPE_BLOCK\nthread scope.\nFor the supported data types, please refer to the corresponding section of different atomic operations.\n10.14.1.\nArithmetic Functions\nï\n10.14.1.1.\natomicAdd()\nï\nint\natomicAdd\n(\nint\n*\naddress\n,\nint\nval\n);\nunsigned\nint\natomicAdd\n(\nunsigned\nint\n*\naddress\n,\nunsigned\nint\nval\n);\nunsigned\nlong\nlong\nint\natomicAdd\n(\nunsigned\nlong\nlong\nint\n*\naddress\n,\nunsigned\nlong\nlong\nint\nval\n);\nfloat\natomicAdd\n(\nfloat\n*\naddress\n,\nfloat\nval\n);\ndouble\natomicAdd\n(\ndouble\n*\naddress\n,\ndouble\nval\n);\n__half2\natomicAdd\n(\n__half2\n*\naddress\n,\n__half2\nval\n);\n__half\natomicAdd\n(\n__half\n*\naddress\n,\n__half\nval\n);\n__nv_bfloat162\natomicAdd\n(\n__nv_bfloat162\n*\naddress\n,\n__nv_bfloat162\nval\n);\n__nv_bfloat16\natomicAdd\n(\n__nv_bfloat16\n*\naddress\n,\n__nv_bfloat16\nval\n);\nfloat2\natomicAdd\n(\nfloat2\n*\naddress\n,\nfloat2\nval\n);\nfloat4\natomicAdd\n(\nfloat4\n*\naddress\n,\nfloat4\nval\n);\nreads the 16-bit, 32-bit or 64-bit\nold\nlocated at the address\naddress\nin global or shared memory, computes\n(old\n+\nval)\n, and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns\nold\n.\nThe 32-bit floating-point version of\natomicAdd()\nis only supported by devices of compute capability 2.x and higher.\nThe 64-bit floating-point version of\natomicAdd()\nis only supported by devices of compute capability 6.x and higher.\nThe 32-bit\n__half2\nfloating-point version of\natomicAdd()\nis only supported by devices of compute capability 6.x and higher. The atomicity of the\n__half2\nor\n__nv_bfloat162\nadd operation is guaranteed separately for each of the two\n__half\nor\n__nv_bfloat16\nelements; the entire\n__half2\nor\n__nv_bfloat162\nis not guaranteed to be atomic as a single 32-bit access.\nThe\nfloat2\nand\nfloat4\nfloating-point vector versions of\natomicAdd()\nare only supported by devices of compute capability 9.x and higher. The atomicity of the\nfloat2\nor\nfloat4\nadd operation is guaranteed separately for each of the two or four\nfloat\nelements; the entire\nfloat2\nor\nfloat4\nis not guaranteed to be atomic as a single 64-bit or 128-bit access.\nThe 16-bit\n__half\nfloating-point version of\natomicAdd()\nis only supported by devices of compute capability 7.x and higher.\nThe 16-bit\n__nv_bfloat16\nfloating-point version of\natomicAdd()\nis only supported by devices of compute capability 8.x and higher.\nThe\nfloat2\nand\nfloat4\nfloating-point vector versions of\natomicAdd()\nare only supported by devices of compute capability 9.x and higher.\nThe\nfloat2\nand\nfloat4\nfloating-point vector versions of\natomicAdd()\nare only supported for global memory addresses.\n10.14.1.2.\natomicSub()\nï\nint\natomicSub\n(\nint\n*\naddress\n,\nint\nval\n);\nunsigned\nint\natomicSub\n(\nunsigned\nint\n*\naddress\n,\nunsigned\nint\nval\n);\nreads the 32-bit word\nold\nlocated at the address\naddress\nin global or shared memory, computes\n(old\n-\nval)\n, and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns\nold\n.\n10.14.1.3.\natomicExch()\nï\nint\natomicExch\n(\nint\n*\naddress\n,\nint\nval\n);\nunsigned\nint\natomicExch\n(\nunsigned\nint\n*\naddress\n,\nunsigned\nint\nval\n);\nunsigned\nlong\nlong\nint\natomicExch\n(\nunsigned\nlong\nlong\nint\n*\naddress\n,\nunsigned\nlong\nlong\nint\nval\n);\nfloat\natomicExch\n(\nfloat\n*\naddress\n,\nfloat\nval\n);\nreads the 32-bit or 64-bit word\nold\nlocated at the address\naddress\nin global or shared memory and stores\nval\nback to memory at the same address. These two operations are performed in one atomic transaction. The function returns\nold\n.\ntemplate\n<\ntypename\nT\n>\nT\natomicExch\n(\nT\n*\naddress\n,\nT\nval\n);\nreads the 128-bit word\nold\nlocated at the address\naddress\nin global or shared memory and stores\nval\nback to memory at the same address. These two operations are performed in one atomic transaction. The function returns\nold\n. The type\nT\nmust meet the following requirements:\nsizeof\n(\nT\n)\n==\n16\nalignof\n(\nT\n)\n>=\n16\nstd\n::\nis_trivially_copyable\n<\nT\n>::\nvalue\n==\ntrue\n// for C++03 and older\nstd\n::\nis_default_constructible\n<\nT\n>::\nvalue\n==\ntrue\nSo,\nT\nmust be 128-bit and properly aligned, be trivially copyable, and on C++03 or older, it must also be default constructible.\nThe 128-bit\natomicExch()\nis only supported by devices of compute capability 9.x and higher.\n10.14.1.4.\natomicMin()\nï\nint\natomicMin\n(\nint\n*\naddress\n,\nint\nval\n);\nunsigned\nint\natomicMin\n(\nunsigned\nint\n*\naddress\n,\nunsigned\nint\nval\n);\nunsigned\nlong\nlong\nint\natomicMin\n(\nunsigned\nlong\nlong\nint\n*\naddress\n,\nunsigned\nlong\nlong\nint\nval\n);\nlong\nlong\nint\natomicMin\n(\nlong\nlong\nint\n*\naddress\n,\nlong\nlong\nint\nval\n);\nreads the 32-bit or 64-bit word\nold\nlocated at the address\naddress\nin global or shared memory, computes the minimum of\nold\nand\nval\n, and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns\nold\n.\nThe 64-bit version of\natomicMin()\nis only supported by devices of compute capability 5.0 and higher.\n10.14.1.5.\natomicMax()\nï\nint\natomicMax\n(\nint\n*\naddress\n,\nint\nval\n);\nunsigned\nint\natomicMax\n(\nunsigned\nint\n*\naddress\n,\nunsigned\nint\nval\n);\nunsigned\nlong\nlong\nint\natomicMax\n(\nunsigned\nlong\nlong\nint\n*\naddress\n,\nunsigned\nlong\nlong\nint\nval\n);\nlong\nlong\nint\natomicMax\n(\nlong\nlong\nint\n*\naddress\n,\nlong\nlong\nint\nval\n);\nreads the 32-bit or 64-bit word\nold\nlocated at the address\naddress\nin global or shared memory, computes the maximum of\nold\nand\nval\n, and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns\nold\n.\nThe 64-bit version of\natomicMax()\nis only supported by devices of compute capability 5.0 and higher.\n10.14.1.6.\natomicInc()\nï\nunsigned\nint\natomicInc\n(\nunsigned\nint\n*\naddress\n,\nunsigned\nint\nval\n);\nreads the 32-bit word\nold\nlocated at the address\naddress\nin global or shared memory, computes\n((old\n>=\nval)\n?\n0\n:\n(old+1))\n, and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns\nold\n.\n10.14.1.7.\natomicDec()\nï\nunsigned\nint\natomicDec\n(\nunsigned\nint\n*\naddress\n,\nunsigned\nint\nval\n);\nreads the 32-bit word\nold\nlocated at the address\naddress\nin global or shared memory, computes\n(((old\n==\n0)\n||\n(old\n>\nval))\n?\nval\n:\n(old-1)\n), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns\nold\n.\n10.14.1.8.\natomicCAS()\nï\nint\natomicCAS\n(\nint\n*\naddress\n,\nint\ncompare\n,\nint\nval\n);\nunsigned\nint\natomicCAS\n(\nunsigned\nint\n*\naddress\n,\nunsigned\nint\ncompare\n,\nunsigned\nint\nval\n);\nunsigned\nlong\nlong\nint\natomicCAS\n(\nunsigned\nlong\nlong\nint\n*\naddress\n,\nunsigned\nlong\nlong\nint\ncompare\n,\nunsigned\nlong\nlong\nint\nval\n);\nunsigned\nshort\nint\natomicCAS\n(\nunsigned\nshort\nint\n*\naddress\n,\nunsigned\nshort\nint\ncompare\n,\nunsigned\nshort\nint\nval\n);\nreads the 16-bit, 32-bit or 64-bit word\nold\nlocated at the address\naddress\nin global or shared memory, computes\n(old\n==\ncompare\n?\nval\n:\nold)\n, and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns\nold\n(Compare And Swap).\ntemplate\n<\ntypename\nT\n>\nT\natomicCAS\n(\nT\n*\naddress\n,\nT\ncompare\n,\nT\nval\n);\nreads the 128-bit word\nold\nlocated at the address\naddress\nin global or shared memory, computes\n(old\n==\ncompare\n?\nval\n:\nold)\n, and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns\nold\n(Compare And Swap). The type\nT\nmust meet the following requirements:\nsizeof\n(\nT\n)\n==\n16\nalignof\n(\nT\n)\n>=\n16\nstd\n::\nis_trivially_copyable\n<\nT\n>::\nvalue\n==\ntrue\n// for C++03 and older\nstd\n::\nis_default_constructible\n<\nT\n>::\nvalue\n==\ntrue\nSo,\nT\nmust be 128-bit and properly aligned, be trivially copyable, and on C++03 or older, it must also be default constructible.\nThe 128-bit\natomicCAS()\nis only supported by devices of compute capability 9.x and higher.\n10.14.1.9.\n__nv_atomic_exchange()\nï\n__device__\nvoid\n__nv_atomic_exchange\n(\nT\n*\nptr\n,\nT\n*\nval\n,\nT\n*\nret\n,\nint\norder\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\nThis atomic function is introduced in CUDA 12.8. It reads the value where\nptr\npoints to and stores the value to where\nret\npoints to. And it reads the value where\nval\npoints to and stores the value to where\nptr\npoints to.\nThis is a generic atomic exchange, which means that\nT\ncan be any data type that is size of 4, 8 or 16 bytes.\nThe atomic operation with memory order and thread scope is supported on the architecture\nsm_60\nand higher.\n16-byte data type is supported on the architecture\nsm_90\nand higher.\nThe thread scope of\ncluster\nis supported on the architecture\nsm_90\nand higher.\nThe arguments\norder\nand\nscope\nneed to be integer literals, i.e., the arguments cannot be variables.\n10.14.1.10.\n__nv_atomic_exchange_n()\nï\n__device__\nT\n__nv_atomic_exchange_n\n(\nT\n*\nptr\n,\nT\nval\n,\nint\norder\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\nThis atomic function is introduced in CUDA 12.8. It reads the value where\nptr\npoints to and use this value as the return value. And it stores\nval\nto where\nptr\npoints to.\nThis is a non-generic atomic exchange, which means that\nT\ncan only be an integral type that is size of 4, 8 or 16 bytes.\nThe atomic operation with memory order and thread scope is supported on the architecture\nsm_60\nand higher.\n16-byte data type is supported on the architecture\nsm_90\nand higher.\nThe thread scope of\ncluster\nis supported on the architecture\nsm_90\nand higher.\nThe arguments\norder\nand\nscope\nneed to be integer literals, i.e., the arguments cannot be variables.\n10.14.1.11.\n__nv_atomic_compare_exchange()\nï\n__device__\nbool\n__nv_atomic_compare_exchange\n(\nT\n*\nptr\n,\nT\n*\nexpected\n,\nT\n*\ndesired\n,\nbool\nweak\n,\nint\nsuccess_order\n,\nint\nfailure_order\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\nThis atomic function is introduced in CUDA 12.8. It reads the value where\nptr\npoints to and compare it with the value where\nexpected\npoints to. If they are equal, the return value is\ntrue\nand the value where\ndesired\npoints to is stored to where\nptr\npoints to. Otherwise, it returns\nfalse\nand the value where\nptr\npoints to is stored to where\nexpected\npoints to. The parameter\nweak\nis ignored and it picks the stronger memory order between\nsuccess_order\nand\nfailure_order\nto execute the compare-and-exchange operation.\nThis is a generic atomic compare-and-exchange, which means that\nT\ncan be any data type that is size of 2, 4, 8 or 16 bytes.\nThe atomic operation with memory order and thread scope is supported on the architecture\nsm_60\nand higher.\n16-byte data type is supported on the architecture\nsm_90\nand higher.\n2-byte data type is supported on the architecture\nsm_70\nand higher.\nThe thread scope of\ncluster\nis supported on the architecture\nsm_90\nand higher.\nThe arguments\norder\nand\nscope\nneed to be integer literals, i.e., the arguments cannot be variables.\n10.14.1.12.\n__nv_atomic_compare_exchange_n()\nï\n__device__\nbool\n__nv_atomic_compare_exchange_n\n(\nT\n*\nptr\n,\nT\n*\nexpected\n,\nT\ndesired\n,\nbool\nweak\n,\nint\nsuccess_order\n,\nint\nfailure_order\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\nThis atomic function is introduced in CUDA 12.8. It reads the value where\nptr\npoints to and compare it with the value where\nexpected\npoints to. If they are equal, the return value is\ntrue\nand\ndesired\nis stored to where\nptr\npoints to. Otherwise, it returns\nfalse\nand the value where\nptr\npoints to is stored to where\nexpected\npoints to. The parameter\nweak\nis ignored and it picks the stronger memory order between\nsuccess_order\nand\nfailure_order\nto execute the compare-and-exchange operation.\nThis is a non-generic atomic compare-and-exchange, which means that\nT\ncan only be an integral type that is size of 2, 4, 8 or 16 bytes.\nThe atomic operation with memory order and thread scope is supported on the architecture\nsm_60\nand higher.\n16-byte data type is supported on the architecture\nsm_90\nand higher.\n2-byte data type is supported on the architecture\nsm_70\nand higher.\nThe thread scope of\ncluster\nis supported on the architecture\nsm_90\nand higher.\nThe arguments\norder\nand\nscope\nneed to be integer literals, i.e., the arguments cannot be variables.\n10.14.1.13.\n__nv_atomic_fetch_add() and __nv_atomic_add()\nï\n__device__\nT\n__nv_atomic_fetch_add\n(\nT\n*\nptr\n,\nT\nval\n,\nint\norder\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\n__device__\nvoid\n__nv_atomic_add\n(\nT\n*\nptr\n,\nT\nval\n,\nint\norder\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\nThese two atomic functions are introduced in CUDA 12.8. It reads the value where\nptr\npoints to, adds with\nval\n, and stores the result back to where\nptr\npoints to.\n__nv_atomic_fetch_add\nreturns the old value where\nptr\npoints to.\n__nv_atomic_add\ndoes not have return value.\nT\ncan only be\nunsigned\nint\n,\nint\n,\nunsigned\nlong\nlong\n,\nfloat\nor\ndouble\n.\nThe atomic operation with memory order and thread scope is supported on the architecture\nsm_60\nand higher.\nThe thread scope of\ncluster\nis supported on the architecture\nsm_90\nand higher.\nThe arguments\norder\nand\nscope\nneed to be integer literals, i.e., the arguments cannot be variables.\n10.14.1.14.\n__nv_atomic_fetch_sub() and __nv_atomic_sub()\nï\n__device__\nT\n__nv_atomic_fetch_sub\n(\nT\n*\nptr\n,\nT\nval\n,\nint\norder\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\n__device__\nvoid\n__nv_atomic_sub\n(\nT\n*\nptr\n,\nT\nval\n,\nint\norder\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\nThese two atomic functions are introduced in CUDA 12.8. It reads the value where\nptr\npoints to, subtracts with\nval\n, and stores the result back to where\nptr\npoints to.\n__nv_atomic_fetch_sub\nreturns the old value where\nptr\npoints to.\n__nv_atomic_sub\ndoes not have return value.\nT\ncan only be\nunsigned\nint\n,\nint\n,\nunsigned\nlong\nlong\n,\nfloat\nor\ndouble\n.\nThe atomic operation with memory order and thread scope is supported on the architecture\nsm_60\nand higher.\nThe thread scope of\ncluster\nis supported on the architecture\nsm_90\nand higher.\nThe arguments\norder\nand\nscope\nneed to be integer literals, i.e., the arguments cannot be variables.\n10.14.1.15.\n__nv_atomic_fetch_min() and __nv_atomic_min()\nï\n__device__\nT\n__nv_atomic_fetch_min\n(\nT\n*\nptr\n,\nT\nval\n,\nint\norder\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\n__device__\nvoid\n__nv_atomic_min\n(\nT\n*\nptr\n,\nT\nval\n,\nint\norder\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\nThese two atomic functions are introduced in CUDA 12.8. It reads the value where\nptr\npoints to, compares with\nval\n, and stores the smaller value back to where\nptr\npoints to.\n__nv_atomic_fetch_min\nreturns the old value where\nptr\npoints to.\n__nv_atomic_min\ndoes not have return value.\nT\ncan only be\nunsigned\nint\n,\nint\n,\nunsigned\nlong\nlong\nor\nlong\nlong\n.\nThe atomic operation with memory order and thread scope is supported on the architecture\nsm_60\nand higher.\nThe thread scope of\ncluster\nis supported on the architecture\nsm_90\nand higher.\nThe arguments\norder\nand\nscope\nneed to be integer literals, i.e., the arguments cannot be variables.\n10.14.1.16.\n__nv_atomic_fetch_max() and __nv_atomic_max()\nï\n__device__\nT\n__nv_atomic_fetch_max\n(\nT\n*\nptr\n,\nT\nval\n,\nint\norder\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\n__device__\nvoid\n__nv_atomic_max\n(\nT\n*\nptr\n,\nT\nval\n,\nint\norder\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\nThese two atomic functions are introduced in CUDA 12.8. It reads the value where\nptr\npoints to, compares with\nval\n, and stores the bigger value back to where\nptr\npoints to.\n__nv_atomic_fetch_max\nreturns the old value where\nptr\npoints to.\n__nv_atomic_max\ndoes not have return value.\nT\ncan only be\nunsigned\nint\n,\nint\n,\nunsigned\nlong\nlong\nor\nlong\nlong\n.\nThe atomic operation with memory order and thread scope is supported on the architecture\nsm_60\nand higher.\nThe thread scope of\ncluster\nis supported on the architecture\nsm_90\nand higher.\nThe arguments\norder\nand\nscope\nneed to be integer literals, i.e., the arguments cannot be variables.\n10.14.2.\nBitwise Functions\nï\n10.14.2.1.\natomicAnd()\nï\nint\natomicAnd\n(\nint\n*\naddress\n,\nint\nval\n);\nunsigned\nint\natomicAnd\n(\nunsigned\nint\n*\naddress\n,\nunsigned\nint\nval\n);\nunsigned\nlong\nlong\nint\natomicAnd\n(\nunsigned\nlong\nlong\nint\n*\naddress\n,\nunsigned\nlong\nlong\nint\nval\n);\nreads the 32-bit or 64-bit word\nold\nlocated at the address\naddress\nin global or shared memory, computes\n(old\n&\nval\n), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns\nold\n.\nThe 64-bit version of\natomicAnd()\nis only supported by devices of compute capability 5.0 and higher.\n10.14.2.2.\natomicOr()\nï\nint\natomicOr\n(\nint\n*\naddress\n,\nint\nval\n);\nunsigned\nint\natomicOr\n(\nunsigned\nint\n*\naddress\n,\nunsigned\nint\nval\n);\nunsigned\nlong\nlong\nint\natomicOr\n(\nunsigned\nlong\nlong\nint\n*\naddress\n,\nunsigned\nlong\nlong\nint\nval\n);\nreads the 32-bit or 64-bit word\nold\nlocated at the address\naddress\nin global or shared memory, computes\n(old\n|\nval)\n, and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns\nold\n.\nThe 64-bit version of\natomicOr()\nis only supported by devices of compute capability 5.0 and higher.\n10.14.2.3.\natomicXor()\nï\nint\natomicXor\n(\nint\n*\naddress\n,\nint\nval\n);\nunsigned\nint\natomicXor\n(\nunsigned\nint\n*\naddress\n,\nunsigned\nint\nval\n);\nunsigned\nlong\nlong\nint\natomicXor\n(\nunsigned\nlong\nlong\nint\n*\naddress\n,\nunsigned\nlong\nlong\nint\nval\n);\nreads the 32-bit or 64-bit word\nold\nlocated at the address\naddress\nin global or shared memory, computes\n(old\n^\nval)\n, and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns\nold\n.\nThe 64-bit version of\natomicXor()\nis only supported by devices of compute capability 5.0 and higher.\n10.14.2.4.\n__nv_atomic_fetch_or() and __nv_atomic_or()\nï\n__device__\nT\n__nv_atomic_fetch_or\n(\nT\n*\nptr\n,\nT\nval\n,\nint\norder\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\n__device__\nvoid\n__nv_atomic_or\n(\nT\n*\nptr\n,\nT\nval\n,\nint\norder\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\nThese two atomic functions are introduced in CUDA 12.8. It reads the value where\nptr\npoints to,\nor\nwith\nval\n, and stores the result back to where\nptr\npoints to.\n__nv_atomic_fetch_or\nreturns the old value where\nptr\npoints to.\n__nv_atomic_or\ndoes not have return value.\nT\ncan only be an integral type that is size of 4 or 8 bytes.\nThe atomic operation with memory order and thread scope is supported on the architecture\nsm_60\nand higher.\nThe thread scope of\ncluster\nis supported on the architecture\nsm_90\nand higher.\nThe arguments\norder\nand\nscope\nneed to be integer literals, i.e., the arguments cannot be variables.\n10.14.2.5.\n__nv_atomic_fetch_xor() and __nv_atomic_xor()\nï\n__device__\nT\n__nv_atomic_fetch_xor\n(\nT\n*\nptr\n,\nT\nval\n,\nint\norder\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\n__device__\nvoid\n__nv_atomic_xor\n(\nT\n*\nptr\n,\nT\nval\n,\nint\norder\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\nThese two atomic functions are introduced in CUDA 12.8. It reads the value where\nptr\npoints to,\nxor\nwith\nval\n, and stores the result back to where\nptr\npoints to.\n__nv_atomic_fetch_xor\nreturns the old value where\nptr\npoints to.\n__nv_atomic_xor\ndoes not have return value.\nT\ncan only be an integral type that is size of 4 or 8 bytes.\nThe atomic operation with memory order and thread scope is supported on the architecture\nsm_60\nand higher.\nThe thread scope of\ncluster\nis supported on the architecture\nsm_90\nand higher.\nThe arguments\norder\nand\nscope\nneed to be integer literals, i.e., the arguments cannot be variables.\n10.14.2.6.\n__nv_atomic_fetch_and() and __nv_atomic_and()\nï\n__device__\nT\n__nv_atomic_fetch_and\n(\nT\n*\nptr\n,\nT\nval\n,\nint\norder\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\n__device__\nvoid\n__nv_atomic_and\n(\nT\n*\nptr\n,\nT\nval\n,\nint\norder\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\nThese two atomic functions are introduced in CUDA 12.8. It reads the value where\nptr\npoints to,\nand\nwith\nval\n, and stores the result back to where\nptr\npoints to.\n__nv_atomic_fetch_and\nreturns the old value where\nptr\npoints to.\n__nv_atomic_and\ndoes not have return value.\nT\ncan only be an integral type that is size of 4 or 8 bytes.\nThe atomic operation with memory order and thread scope is supported on the architecture\nsm_60\nand higher.\nThe thread scope of\ncluster\nis supported on the architecture\nsm_90\nand higher.\nThe arguments\norder\nand\nscope\nneed to be integer literals, i.e., the arguments cannot be variables.\n10.14.3.\nOther atomic functions\nï\n10.14.3.1.\n__nv_atomic_load()\nï\n__device__\nvoid\n__nv_atomic_load\n(\nT\n*\nptr\n,\nT\n*\nret\n,\nint\norder\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\nThis atomic function is introduced in CUDA 12.8. It loads the value where\nptr\npoints to and writes the value to where\nret\npoints to.\nThis is a generic atomic load, which means that\nT\ncan be any data type that is size of 1, 2, 4, 8 or 16 bytes.\nThe atomic operation with memory order and thread scope is supported on the architecture\nsm_60\nand higher.\n16-byte data type is supported on the architecture\nsm_70\nand higher.\nThe thread scope of\ncluster\nis supported on the architecture\nsm_90\nand higher.\nThe arguments\norder\nand\nscope\nneed to be integer literals, i.e., the arguments cannot be variables.\norder\ncannot be\n__NV_ATOMIC_RELEASE\nor\n__NV_ATOMIC_ACQ_REL\n.\n10.14.3.2.\n__nv_atomic_load_n()\nï\n__device__\nT\n__nv_atomic_load_n\n(\nT\n*\nptr\n,\nint\norder\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\nThis atomic function is introduced in CUDA 12.8. It loads the value where\nptr\npoints to and returns this value.\nThis is a non-generic atomic load, which means that\nT\ncan only be an integral type that is size of 1, 2, 4, 8 or 16 bytes.\nThe atomic operation with memory order and thread scope is supported on the architecture\nsm_60\nand higher.\n16-byte data type is supported on the architecture\nsm_70\nand higher.\nThe thread scope of\ncluster\nis supported on the architecture\nsm_90\nand higher.\nThe arguments\norder\nand\nscope\nneed to be integer literals, i.e., the arguments cannot be variables.\norder\ncannot be\n__NV_ATOMIC_RELEASE\nor\n__NV_ATOMIC_ACQ_REL\n.\n10.14.3.3.\n__nv_atomic_store()\nï\n__device__\nvoid\n__nv_atomic_store\n(\nT\n*\nptr\n,\nT\n*\nval\n,\nint\norder\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\nThis atomic function is introduced in CUDA 12.8. It reads the value where\nval\npoints to and stores to where\nptr\npoints to.\nThis is a generic atomic load, which means that\nT\ncan be any data type that is size of 1, 2, 4, 8 or 16 bytes.\nThe atomic operation with memory order and thread scope is supported on the architecture\nsm_60\nand higher.\n16-byte data type is supported on the architecture\nsm_70\nand higher.\nThe thread scope of\ncluster\nis supported on the architecture\nsm_90\nand higher.\nThe arguments\norder\nand\nscope\nneed to be integer literals, i.e., the arguments cannot be variables.\norder\ncannot be\n__NV_ATOMIC_CONSUME\n,\n__NV_ATOMIC_ACQUIRE\nor\n__NV_ATOMIC_ACQ_REL\n.\n10.14.3.4.\n__nv_atomic_store_n()\nï\n__device__\nvoid\n__nv_atomic_store_n\n(\nT\n*\nptr\n,\nT\nval\n,\nint\norder\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\nThis atomic function is introduced in CUDA 12.8. It stores\nval\nto where\nptr\npoints to.\nThis is a non-generic atomic load, which means that\nT\ncan only be an integral type that is size of 1, 2, 4, 8 or 16 bytes.\nThe atomic operation with memory order and thread scope is supported on the architecture\nsm_60\nand higher.\n16-byte data type is supported on the architecture\nsm_70\nand higher.\nThe thread scope of\ncluster\nis supported on the architecture\nsm_90\nand higher.\nThe arguments\norder\nand\nscope\nneed to be integer literals, i.e., the arguments cannot be variables.\norder\ncannot be\n__NV_ATOMIC_CONSUME\n,\n__NV_ATOMIC_ACQUIRE\nor\n__NV_ATOMIC_ACQ_REL\n.\n10.14.3.5.\n__nv_atomic_thread_fence()\nï\n__device__\nvoid\n__nv_atomic_thread_fence\n(\nint\norder\n,\nint\nscope\n=\n__NV_THREAD_SCOPE_SYSTEM\n);\nThis atomic function establishes an ordering between memory accesses requested by this thread based on the specified memory order. And the thread scope parameter specifies the set of threads that may observe the ordering effect of this operation.\nThe thread scope of\ncluster\nis supported on the architecture\nsm_90\nand higher.\nThe arguments\norder\nand\nscope\nneed to be integer literals, i.e., the arguments cannot be variables.\n10.15.\nAddress Space Predicate Functions\nï\nThe functions described in this section have unspecified behavior if the argument is a null pointer.\n10.15.1.\n__isGlobal()\nï\n__device__\nunsigned\nint\n__isGlobal\n(\nconst\nvoid\n*\nptr\n);\nReturns 1 if\nptr\ncontains the generic address of an object in global memory space, otherwise returns 0.\n10.15.2.\n__isShared()\nï\n__device__\nunsigned\nint\n__isShared\n(\nconst\nvoid\n*\nptr\n);\nReturns 1 if\nptr\ncontains the generic address of an object in shared memory space, otherwise returns 0.\n10.15.3.\n__isConstant()\nï\n__device__\nunsigned\nint\n__isConstant\n(\nconst\nvoid\n*\nptr\n);\nReturns 1 if\nptr\ncontains the generic address of an object in constant memory space, otherwise returns 0.\n10.15.4.\n__isGridConstant()\nï\n__device__\nunsigned\nint\n__isGridConstant\n(\nconst\nvoid\n*\nptr\n);\nReturns 1 if\nptr\ncontains the generic address of a kernel parameter annotated with\n__grid_constant__\n, otherwise returns 0. Only supported for compute architectures greater than or equal to 7.x or later.\n10.15.5.\n__isLocal()\nï\n__device__\nunsigned\nint\n__isLocal\n(\nconst\nvoid\n*\nptr\n);\nReturns 1 if\nptr\ncontains the generic address of an object in local memory space, otherwise returns 0.\n10.16.\nAddress Space Conversion Functions\nï\n10.16.1.\n__cvta_generic_to_global()\nï\n__device__\nsize_t\n__cvta_generic_to_global\n(\nconst\nvoid\n*\nptr\n);\nReturns the result of executing the\nPTX\ncvta.to.global\ninstruction on the generic address denoted by\nptr\n.\n10.16.2.\n__cvta_generic_to_shared()\nï\n__device__\nsize_t\n__cvta_generic_to_shared\n(\nconst\nvoid\n*\nptr\n);\nReturns the result of executing the\nPTX\ncvta.to.shared\ninstruction on the generic address denoted by\nptr\n.\n10.16.3.\n__cvta_generic_to_constant()\nï\n__device__\nsize_t\n__cvta_generic_to_constant\n(\nconst\nvoid\n*\nptr\n);\nReturns the result of executing the\nPTX\ncvta.to.const\ninstruction on the generic address denoted by\nptr\n.\n10.16.4.\n__cvta_generic_to_local()\nï\n__device__\nsize_t\n__cvta_generic_to_local\n(\nconst\nvoid\n*\nptr\n);\nReturns the result of executing the\nPTX\ncvta.to.local\ninstruction on the generic address denoted by\nptr\n.\n10.16.5.\n__cvta_global_to_generic()\nï\n__device__\nvoid\n*\n__cvta_global_to_generic\n(\nsize_t\nrawbits\n);\nReturns the generic pointer obtained by executing the\nPTX\ncvta.global\ninstruction on the value provided by\nrawbits\n.\n10.16.6.\n__cvta_shared_to_generic()\nï\n__device__\nvoid\n*\n__cvta_shared_to_generic\n(\nsize_t\nrawbits\n);\nReturns the generic pointer obtained by executing the\nPTX\ncvta.shared\ninstruction on the value provided by\nrawbits\n.\n10.16.7.\n__cvta_constant_to_generic()\nï\n__device__\nvoid\n*\n__cvta_constant_to_generic\n(\nsize_t\nrawbits\n);\nReturns the generic pointer obtained by executing the\nPTX\ncvta.const\ninstruction on the value provided by\nrawbits\n.\n10.16.8.\n__cvta_local_to_generic()\nï\n__device__\nvoid\n*\n__cvta_local_to_generic\n(\nsize_t\nrawbits\n);\nReturns the generic pointer obtained by executing the\nPTX\ncvta.local\ninstruction on the value provided by\nrawbits\n.\n10.17.\nAlloca Function\nï\n10.17.1.\nSynopsis\nï\n__host__\n__device__\nvoid\n*\nalloca\n(\nsize_t\nsize\n);\n10.17.2.\nDescription\nï\nThe\nalloca()\nfunction allocates\nsize\nbytes of memory in the stack frame of the caller. The returned value is a pointer to allocated memory, the beginning of the memory is 16 bytes aligned when the function is invoked from device code. The allocated memory is automatically freed when the caller to\nalloca()\nis returned.\nNote\nOn Windows platform,\n<malloc.h>\nmust be included before using\nalloca()\n. Using\nalloca()\nmay cause the stack to overflow, user needs to adjust stack size accordingly.\nIt is supported with compute capability 5.2 or higher.\n10.17.3.\nExample\nï\n__device__\nvoid\nfoo\n(\nunsigned\nint\nnum\n)\n{\nint4\n*\nptr\n=\n(\nint4\n*\n)\nalloca\n(\nnum\n*\nsizeof\n(\nint4\n));\n// use of ptr\n...\n}\n10.18.\nCompiler Optimization Hint Functions\nï\nThe functions described in this section can be used to provide additional information to the compiler optimizer.\n10.18.1.\n__builtin_assume_aligned()\nï\nvoid\n*\n__builtin_assume_aligned\n(\nconst\nvoid\n*\nexp\n,\nsize_t\nalign\n)\nAllows the compiler to assume that the argument pointer is aligned to at least\nalign\nbytes, and returns the argument pointer.\nExample:\nvoid\n*\nres\n=\n__builtin_assume_aligned\n(\nptr\n,\n32\n);\n// compiler can assume 'res' is\n// at least 32-byte aligned\nThree parameter version:\nvoid\n*\n__builtin_assume_aligned\n(\nconst\nvoid\n*\nexp\n,\nsize_t\nalign\n,\n<\nintegral\ntype\n>\noffset\n)\nAllows the compiler to assume that\n(char\n*)exp\n-\noffset\nis aligned to at least\nalign\nbytes, and returns the argument pointer.\nExample:\nvoid\n*\nres\n=\n__builtin_assume_aligned\n(\nptr\n,\n32\n,\n8\n);\n// compiler can assume\n// '(char *)res - 8' is\n// at least 32-byte aligned.\n10.18.2.\n__builtin_assume()\nï\nvoid\n__builtin_assume\n(\nbool\nexp\n)\nAllows the compiler to assume that the Boolean argument is true. If the argument is not true at run time, then the behavior is undefined. Note that if the argument has side effects, the behavior is unspecified.\nExample:\n__device__\nint\nget\n(\nint\n*\nptr\n,\nint\nidx\n)\n{\n__builtin_assume\n(\nidx\n<=\n2\n);\nreturn\nptr\n[\nidx\n];\n}\n10.18.3.\n__assume()\nï\nvoid\n__assume\n(\nbool\nexp\n)\nAllows the compiler to assume that the Boolean argument is true. If the argument is not true at run time, then the behavior is undefined. Note that if the argument has side effects, the behavior is unspecified.\nExample:\n__device__\nint\nget\n(\nint\n*\nptr\n,\nint\nidx\n)\n{\n__assume\n(\nidx\n<=\n2\n);\nreturn\nptr\n[\nidx\n];\n}\n10.18.4.\n__builtin_expect()\nï\nlong\n__builtin_expect\n(\nlong\nexp\n,\nlong\nc\n)\nIndicates to the compiler that it is expected that\nexp\n==\nc\n, and returns the value of\nexp\n. Typically used to indicate branch prediction information to the compiler.\nExample:\n// indicate to the compiler that likely \"var == 0\",\n// so the body of the if-block is unlikely to be\n// executed at run time.\nif\n(\n__builtin_expect\n(\nvar\n,\n0\n))\ndoit\n();\n10.18.5.\n__builtin_unreachable()\nï\nvoid\n__builtin_unreachable\n(\nvoid\n)\nIndicates to the compiler that control flow never reaches the point where this function is being called from. The program has undefined behavior if the control flow does actually reach this point at run time.\nExample:\n// indicates to the compiler that the default case label is never reached.\nswitch\n(\nin\n)\n{\ncase\n1\n:\nreturn\n4\n;\ncase\n2\n:\nreturn\n10\n;\ndefault\n:\n__builtin_unreachable\n();\n}\n10.18.6.\nRestrictions\nï\n__assume()\nis only supported when using\ncl.exe\nhost compiler. The other functions are supported on all platforms, subject to the following restrictions:\nIf the host compiler supports the function, the function can be invoked from anywhere in translation unit.\nOtherwise, the function must be invoked from within the body of a\n__device__\n/\n__global__\nfunction, or only when the\n__CUDA_ARCH__\nmacro is defined\n5\n.\n10.19.\nWarp Vote Functions\nï\nint\n__all_sync\n(\nunsigned\nmask\n,\nint\npredicate\n);\nint\n__any_sync\n(\nunsigned\nmask\n,\nint\npredicate\n);\nunsigned\n__ballot_sync\n(\nunsigned\nmask\n,\nint\npredicate\n);\nunsigned\n__activemask\n();\nDeprecation notice:\n__any\n,\n__all\n, and\n__ballot\nhave been deprecated in CUDA 9.0 for all devices.\nRemoval notice: When targeting devices with compute capability 7.x or higher,\n__any\n,\n__all\n, and\n__ballot\nare no longer available and their sync variants should be used instead.\nThe warp vote functions allow the threads of a given\nwarp\nto perform a reduction-and-broadcast operation. These functions take as input an integer\npredicate\nfrom each thread in the warp and compare those values with zero. The results of the comparisons are combined (reduced) across the\nactive\nthreads of the warp in one of the following ways, broadcasting a single return value to each participating thread:\n__all_sync(unsigned\nmask,\npredicate)\n:\nEvaluate\npredicate\nfor all non-exited threads in\nmask\nand return non-zero if and only if\npredicate\nevaluates to non-zero for all of them.\n__any_sync(unsigned\nmask,\npredicate)\n:\nEvaluate\npredicate\nfor all non-exited threads in\nmask\nand return non-zero if and only if\npredicate\nevaluates to non-zero for any of them.\n__ballot_sync(unsigned\nmask,\npredicate)\n:\nEvaluate\npredicate\nfor all non-exited threads in\nmask\nand return an integer whose Nth bit is set if and only if\npredicate\nevaluates to non-zero for the Nth thread of the warp and the Nth thread is active.\n__activemask()\n:\nReturns a 32-bit integer mask of all currently active threads in the calling warp. The Nth bit is set if the Nth lane in the warp is active when\n__activemask()\nis called.\nInactive\nthreads are represented by 0 bits in the returned mask. Threads which have exited the program are always marked as inactive. Note that threads that are convergent at an\n__activemask()\ncall are not guaranteed to be convergent at subsequent instructions unless those instructions are synchronizing warp-builtin functions.\nFor\n__all_sync\n,\n__any_sync\n, and\n__ballot_sync\n, a mask must be passed that specifies the threads participating in the call. A bit, representing the threadâs lane ID, must be set for each participating thread to ensure they are properly converged before the intrinsic is executed by the hardware. Each calling thread must have its own bit set in the mask and all non-exited threads named in mask must execute the same intrinsic with the same mask, or the result is undefined.\nThese intrinsics do not imply a memory barrier. They do not guarantee any memory ordering.\n10.20.\nWarp Match Functions\nï\n__match_any_sync\nand\n__match_all_sync\nperform a broadcast-and-compare operation of a variable between threads within a\nwarp\n.\nSupported by devices of compute capability 7.x or higher.\n10.20.1.\nSynopsis\nï\nunsigned\nint\n__match_any_sync\n(\nunsigned\nmask\n,\nT\nvalue\n);\nunsigned\nint\n__match_all_sync\n(\nunsigned\nmask\n,\nT\nvalue\n,\nint\n*\npred\n);\nT\ncan be\nint\n,\nunsigned\nint\n,\nlong\n,\nunsigned\nlong\n,\nlong\nlong\n,\nunsigned\nlong\nlong\n,\nfloat\nor\ndouble\n.\n10.20.2.\nDescription\nï\nThe\n__match_sync()\nintrinsics permit a broadcast-and-compare of a value\nvalue\nacross threads in a warp after synchronizing threads named in\nmask\n.\n__match_any_sync\nReturns mask of threads that have same value of\nvalue\nin\nmask\n__match_all_sync\nReturns\nmask\nif all threads in\nmask\nhave the same value for\nvalue\n; otherwise 0 is returned. Predicate\npred\nis set to true if all threads in\nmask\nhave the same value of\nvalue\n; otherwise the predicate is set to false.\nThe new\n*_sync\nmatch intrinsics take in a mask indicating the threads participating in the call. A bit, representing the threadâs lane id, must be set for each participating thread to ensure they are properly converged before the intrinsic is executed by the hardware. Each calling thread must have its own bit set in the mask and all non-exited threads named in mask must execute the same intrinsic with the same mask, or the result is undefined.\nThese intrinsics do not imply a memory barrier. They do not guarantee any memory ordering.\n10.21.\nWarp Reduce Functions\nï\nThe\n__reduce_sync(unsigned\nmask,\nT\nvalue)\nintrinsics perform a reduction operation on the data provided in\nvalue\nafter synchronizing threads named in\nmask\n. T can be unsigned or signed for {add, min, max} and unsigned only for {and, or, xor} operations.\nSupported by devices of compute capability 8.x or higher.\n10.21.1.\nSynopsis\nï\n// add/min/max\nunsigned\n__reduce_add_sync\n(\nunsigned\nmask\n,\nunsigned\nvalue\n);\nunsigned\n__reduce_min_sync\n(\nunsigned\nmask\n,\nunsigned\nvalue\n);\nunsigned\n__reduce_max_sync\n(\nunsigned\nmask\n,\nunsigned\nvalue\n);\nint\n__reduce_add_sync\n(\nunsigned\nmask\n,\nint\nvalue\n);\nint\n__reduce_min_sync\n(\nunsigned\nmask\n,\nint\nvalue\n);\nint\n__reduce_max_sync\n(\nunsigned\nmask\n,\nint\nvalue\n);\n// and/or/xor\nunsigned\n__reduce_and_sync\n(\nunsigned\nmask\n,\nunsigned\nvalue\n);\nunsigned\n__reduce_or_sync\n(\nunsigned\nmask\n,\nunsigned\nvalue\n);\nunsigned\n__reduce_xor_sync\n(\nunsigned\nmask\n,\nunsigned\nvalue\n);\n10.21.2.\nDescription\nï\n__reduce_add_sync\n,\n__reduce_min_sync\n,\n__reduce_max_sync\nReturns the result of applying an arithmetic add, min, or max reduction operation on the values provided in\nvalue\nby each thread named in\nmask\n.\n__reduce_and_sync\n,\n__reduce_or_sync\n,\n__reduce_xor_sync\nReturns the result of applying a logical AND, OR, or XOR reduction operation on the values provided in\nvalue\nby each thread named in\nmask\n.\nThe\nmask\nindicates the threads participating in the call. A bit, representing the threadâs lane id, must be set for each participating thread to ensure they are properly converged before the intrinsic is executed by the hardware. Each calling thread must have its own bit set in the mask and all non-exited threads named in mask must execute the same intrinsic with the same mask, or the result is undefined.\nThese intrinsics do not imply a memory barrier. They do not guarantee any memory ordering.\n10.22.\nWarp Shuffle Functions\nï\n__shfl_sync\n,\n__shfl_up_sync\n,\n__shfl_down_sync\n, and\n__shfl_xor_sync\nexchange a variable between threads within a\nwarp\n.\nSupported by devices of compute capability 5.0 or higher.\nDeprecation Notice:\n__shfl\n,\n__shfl_up\n,\n__shfl_down\n, and\n__shfl_xor\nhave been deprecated in CUDA 9.0 for all devices.\nRemoval Notice: When targeting devices with compute capability 7.x or higher,\n__shfl\n,\n__shfl_up\n,\n__shfl_down\n, and\n__shfl_xor\nare no longer available and their sync variants should be used instead.\n10.22.1.\nSynopsis\nï\nT\n__shfl_sync\n(\nunsigned\nmask\n,\nT\nvar\n,\nint\nsrcLane\n,\nint\nwidth\n=\nwarpSize\n);\nT\n__shfl_up_sync\n(\nunsigned\nmask\n,\nT\nvar\n,\nunsigned\nint\ndelta\n,\nint\nwidth\n=\nwarpSize\n);\nT\n__shfl_down_sync\n(\nunsigned\nmask\n,\nT\nvar\n,\nunsigned\nint\ndelta\n,\nint\nwidth\n=\nwarpSize\n);\nT\n__shfl_xor_sync\n(\nunsigned\nmask\n,\nT\nvar\n,\nint\nlaneMask\n,\nint\nwidth\n=\nwarpSize\n);\nT\ncan be\nint\n,\nunsigned\nint\n,\nlong\n,\nunsigned\nlong\n,\nlong\nlong\n,\nunsigned\nlong\nlong\n,\nfloat\nor\ndouble\n. With the\ncuda_fp16.h\nheader included,\nT\ncan also be\n__half\nor\n__half2\n. Similarly, with the\ncuda_bf16.h\nheader included,\nT\ncan also be\n__nv_bfloat16\nor\n__nv_bfloat162\n.\n10.22.2.\nDescription\nï\nThe\n__shfl_sync()\nintrinsics permit exchanging of a variable between threads within a warp without use of shared memory. The exchange occurs simultaneously for all\nactive\nthreads within the warp (and named in\nmask\n), moving 4 or 8 bytes of data per thread depending on the type.\nThreads within a warp are referred to as\nlanes\n, and may have an index between 0 and\nwarpSize-1\n(inclusive). Four source-lane addressing modes are supported:\n__shfl_sync()\nDirect copy from indexed lane\n__shfl_up_sync()\nCopy from a lane with lower ID relative to caller\n__shfl_down_sync()\nCopy from a lane with higher ID relative to caller\n__shfl_xor_sync()\nCopy from a lane based on bitwise XOR of own lane ID\nThreads may only read data from another thread which is actively participating in the\n__shfl_sync()\ncommand. If the target thread is\ninactive\n, the retrieved value is undefined.\nAll of the\n__shfl_sync()\nintrinsics take an optional\nwidth\nparameter which alters the behavior of the intrinsic.\nwidth\nmust have a value which is a power of two in the range [1, warpSize] (i.e., 1, 2, 4, 8, 16 or 32). Results are undefined for other values.\n__shfl_sync()\nreturns the value of\nvar\nheld by the thread whose ID is given by\nsrcLane\n. If width is less than\nwarpSize\nthen each subsection of the warp behaves as a separate entity with a starting logical lane ID of 0. If\nsrcLane\nis outside the range\n[0:width-1]\n, the value returned corresponds to the value of var held by the\nsrcLane\nmodulo\nwidth\n(i.e. within the same subsection).\n__shfl_up_sync()\ncalculates a source lane ID by subtracting\ndelta\nfrom the callerâs lane ID. The value of\nvar\nheld by the resulting lane ID is returned: in effect,\nvar\nis shifted up the warp by\ndelta\nlanes. If width is less than\nwarpSize\nthen each subsection of the warp behaves as a separate entity with a starting logical lane ID of 0. The source lane index will not wrap around the value of\nwidth\n, so effectively the lower\ndelta\nlanes will be unchanged.\n__shfl_down_sync()\ncalculates a source lane ID by adding\ndelta\nto the callerâs lane ID. The value of\nvar\nheld by the resulting lane ID is returned: this has the effect of shifting\nvar\ndown the warp by\ndelta\nlanes. If width is less than\nwarpSize\nthen each subsection of the warp behaves as a separate entity with a starting logical lane ID of 0. As for\n__shfl_up_sync()\n, the ID number of the source lane will not wrap around the value of width and so the upper\ndelta\nlanes will remain unchanged.\n__shfl_xor_sync()\ncalculates a source line ID by performing a bitwise XOR of the callerâs lane ID with\nlaneMask\n: the value of\nvar\nheld by the resulting lane ID is returned. If\nwidth\nis less than\nwarpSize\nthen each group of\nwidth\nconsecutive threads are able to access elements from earlier groups of threads, however if they attempt to access elements from later groups of threads their own value of\nvar\nwill be returned. This mode implements a butterfly addressing pattern such as is used in tree reduction and broadcast.\nThe new\n*_sync\nshfl intrinsics take in a mask indicating the threads participating in the call. A bit, representing the threadâs lane id, must be set for each participating thread to ensure they are properly converged before the intrinsic is executed by the hardware. Each calling thread must have its own bit set in the mask and all non-exited threads named in mask must execute the same intrinsic with the same mask, or the result is undefined.\nThreads may only read data from another thread which is actively participating in the\n__shfl_sync()\ncommand. If the target thread is inactive, the retrieved value is undefined.\nThese intrinsics do not imply a memory barrier. They do not guarantee any memory ordering.\n10.22.3.\nExamples\nï\n10.22.3.1.\nBroadcast of a single value across a warp\nï\n#include\n<stdio.h>\n__global__\nvoid\nbcast\n(\nint\narg\n)\n{\nint\nlaneId\n=\nthreadIdx\n.\nx\n&\n0x1f\n;\nint\nvalue\n;\nif\n(\nlaneId\n==\n0\n)\n// Note unused variable for\nvalue\n=\narg\n;\n// all threads except lane 0\nvalue\n=\n__shfl_sync\n(\n0xffffffff\n,\nvalue\n,\n0\n);\n// Synchronize all threads in warp, and get \"value\" from lane 0\nif\n(\nvalue\n!=\narg\n)\nprintf\n(\n\"Thread %d failed.\n\\n\n\"\n,\nthreadIdx\n.\nx\n);\n}\nint\nmain\n()\n{\nbcast\n<<<\n1\n,\n32\n>>>\n(\n1234\n);\ncudaDeviceSynchronize\n();\nreturn\n0\n;\n}\n10.22.3.2.\nInclusive plus-scan across sub-partitions of 8 threads\nï\n#include\n<stdio.h>\n__global__\nvoid\nscan4\n()\n{\nint\nlaneId\n=\nthreadIdx\n.\nx\n&\n0x1f\n;\n// Seed sample starting value (inverse of lane ID)\nint\nvalue\n=\n31\n-\nlaneId\n;\n// Loop to accumulate scan within my partition.\n// Scan requires log2(n) == 3 steps for 8 threads\n// It works by an accumulated sum up the warp\n// by 1, 2, 4, 8 etc. steps.\nfor\n(\nint\ni\n=\n1\n;\ni\n<=\n4\n;\ni\n*=\n2\n)\n{\n// We do the __shfl_sync unconditionally so that we\n// can read even from threads which won't do a\n// sum, and then conditionally assign the result.\nint\nn\n=\n__shfl_up_sync\n(\n0xffffffff\n,\nvalue\n,\ni\n,\n8\n);\nif\n((\nlaneId\n&\n7\n)\n>=\ni\n)\nvalue\n+=\nn\n;\n}\nprintf\n(\n\"Thread %d final value = %d\n\\n\n\"\n,\nthreadIdx\n.\nx\n,\nvalue\n);\n}\nint\nmain\n()\n{\nscan4\n<<<\n1\n,\n32\n>>>\n();\ncudaDeviceSynchronize\n();\nreturn\n0\n;\n}\n10.22.3.3.\nReduction across a warp\nï\n#include\n<stdio.h>\n__global__\nvoid\nwarpReduce\n()\n{\nint\nlaneId\n=\nthreadIdx\n.\nx\n&\n0x1f\n;\n// Seed starting value as inverse lane ID\nint\nvalue\n=\n31\n-\nlaneId\n;\n// Use XOR mode to perform butterfly reduction\nfor\n(\nint\ni\n=\n16\n;\ni\n>=\n1\n;\ni\n/=\n2\n)\nvalue\n+=\n__shfl_xor_sync\n(\n0xffffffff\n,\nvalue\n,\ni\n,\n32\n);\n// \"value\" now contains the sum across all threads\nprintf\n(\n\"Thread %d final value = %d\n\\n\n\"\n,\nthreadIdx\n.\nx\n,\nvalue\n);\n}\nint\nmain\n()\n{\nwarpReduce\n<<<\n1\n,\n32\n>>>\n();\ncudaDeviceSynchronize\n();\nreturn\n0\n;\n}\n10.23.\nNanosleep Function\nï\n10.23.1.\nSynopsis\nï\nvoid\n__nanosleep\n(\nunsigned\nns\n);\n10.23.2.\nDescription\nï\n__nanosleep(ns)\nsuspends the thread for a sleep duration of approximately\nns\nnanoseconds.  The maximum sleep duration is approximately 1 millisecond.\nIt is supported with compute capability 7.0 or higher.\n10.23.3.\nExample\nï\nThe following code implements a mutex with exponential back-off.\n__device__\nvoid\nmutex_lock\n(\nunsigned\nint\n*\nmutex\n)\n{\nunsigned\nint\nns\n=\n8\n;\nwhile\n(\natomicCAS\n(\nmutex\n,\n0\n,\n1\n)\n==\n1\n)\n{\n__nanosleep\n(\nns\n);\nif\n(\nns\n<\n256\n)\n{\nns\n*=\n2\n;\n}\n}\n}\n__device__\nvoid\nmutex_unlock\n(\nunsigned\nint\n*\nmutex\n)\n{\natomicExch\n(\nmutex\n,\n0\n);\n}\n10.24.\nWarp Matrix Functions\nï\nC++ warp matrix operations leverage Tensor Cores to accelerate matrix problems of the form\nD=A*B+C\n. These operations are supported on mixed-precision floating point data for devices of compute capability 7.0 or higher. This requires co-operation from all threads in a\nwarp\n. In addition, these operations are allowed in conditional code only if the condition evaluates identically across the entire\nwarp\n, otherwise the code execution is likely to hang.\n10.24.1.\nDescription\nï\nAll following functions and types are defined in the namespace\nnvcuda::wmma\n. Sub-byte operations are considered preview, i.e. the data structures and APIs for them are subject to change and may not be compatible with future releases. This extra functionality is defined in the\nnvcuda::wmma::experimental\nnamespace.\ntemplate\n<\ntypename\nUse\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\ntypename\nT\n,\ntypename\nLayout\n=\nvoid\n>\nclass\nfragment\n;\nvoid\nload_matrix_sync\n(\nfragment\n<\n...\n>\n&\na\n,\nconst\nT\n*\nmptr\n,\nunsigned\nldm\n);\nvoid\nload_matrix_sync\n(\nfragment\n<\n...\n>\n&\na\n,\nconst\nT\n*\nmptr\n,\nunsigned\nldm\n,\nlayout_t\nlayout\n);\nvoid\nstore_matrix_sync\n(\nT\n*\nmptr\n,\nconst\nfragment\n<\n...\n>\n&\na\n,\nunsigned\nldm\n,\nlayout_t\nlayout\n);\nvoid\nfill_fragment\n(\nfragment\n<\n...\n>\n&\na\n,\nconst\nT\n&\nv\n);\nvoid\nmma_sync\n(\nfragment\n<\n...\n>\n&\nd\n,\nconst\nfragment\n<\n...\n>\n&\na\n,\nconst\nfragment\n<\n...\n>\n&\nb\n,\nconst\nfragment\n<\n...\n>\n&\nc\n,\nbool\nsatf\n=\nfalse\n);\nfragment\nAn overloaded class containing a section of a matrix distributed across all threads in the warp. The mapping of matrix elements into\nfragment\ninternal storage is unspecified and subject to change in future architectures.\nOnly certain combinations of template arguments are allowed. The first template parameter specifies how the fragment will participate in the matrix operation. Acceptable values for\nUse\nare:\nmatrix_a\nwhen the fragment is used as the first multiplicand,\nA\n,\nmatrix_b\nwhen the fragment is used as the second multiplicand,\nB\n, or\naccumulator\nwhen the fragment is used as the source or destination accumulators (\nC\nor\nD\n, respectively).\nThe\nm\n,\nn\nand\nk\nsizes describe the shape of the warp-wide matrix tiles participating in the multiply-accumulate operation. The dimension of each tile depends on its role. For\nmatrix_a\nthe tile takes dimension\nm\nx\nk\n; for\nmatrix_b\nthe dimension is\nk\nx\nn\n, and\naccumulator\ntiles are\nm\nx\nn\n.\nThe data type,\nT\n, may be\ndouble\n,\nfloat\n,\n__half\n,\n__nv_bfloat16\n,\nchar\n, or\nunsigned\nchar\nfor multiplicands and\ndouble\n,\nfloat\n,\nint\n, or\n__half\nfor accumulators. As documented in\nElement Types and Matrix Sizes\n, limited combinations of accumulator and multiplicand types are supported. The Layout parameter must be specified for\nmatrix_a\nand\nmatrix_b\nfragments.\nrow_major\nor\ncol_major\nindicate that elements within a matrix row or column are contiguous in memory, respectively. The\nLayout\nparameter for an\naccumulator\nmatrix should retain the default value of\nvoid\n. A row or column layout is specified only when the accumulator is loaded or stored as described below.\nload_matrix_sync\nWaits until all warp lanes have arrived at load_matrix_sync and then loads the matrix fragment a from memory.\nmptr\nmust be a 256-bit aligned pointer pointing to the first element of the matrix in memory.\nldm\ndescribes the stride in elements between consecutive rows (for row major layout) or columns (for column major layout) and must be a multiple of 8 for\n__half\nelement type or multiple of 4 for\nfloat\nelement type. (i.e., multiple of 16 bytes in both cases). If the fragment is an\naccumulator\n, the\nlayout\nargument must be specified as either\nmem_row_major\nor\nmem_col_major\n. For\nmatrix_a\nand\nmatrix_b\nfragments, the layout is inferred from the fragmentâs\nlayout\nparameter. The values of\nmptr\n,\nldm\n,\nlayout\nand all template parameters for\na\nmust be the same for all threads in the warp. This function must be called by all threads in the warp, or the result is undefined.\nstore_matrix_sync\nWaits until all warp lanes have arrived at store_matrix_sync and then stores the matrix fragment a to memory.\nmptr\nmust be a 256-bit aligned pointer pointing to the first element of the matrix in memory.\nldm\ndescribes the stride in elements between consecutive rows (for row major layout) or columns (for column major layout) and must be a multiple of 8 for\n__half\nelement type or multiple of 4 for\nfloat\nelement type. (i.e., multiple of 16 bytes in both cases). The layout of the output matrix must be specified as either\nmem_row_major\nor\nmem_col_major\n. The values of\nmptr\n,\nldm\n,\nlayout\nand all template parameters for a must be the same for all threads in the warp.\nfill_fragment\nFill a matrix fragment with a constant value\nv\n. Because the mapping of matrix elements to each fragment is unspecified, this function is ordinarily called by all threads in the warp with a common value for\nv\n.\nmma_sync\nWaits until all warp lanes have arrived at mma_sync, and then performs the warp-synchronous matrix multiply-accumulate operation\nD=A*B+C\n. The in-place operation,\nC=A*B+C\n, is also supported. The value of\nsatf\nand template parameters for each matrix fragment must be the same for all threads in the warp. Also, the template parameters\nm\n,\nn\nand\nk\nmust match between fragments\nA\n,\nB\n,\nC\nand\nD\n. This function must be called by all threads in the warp, or the result is undefined.\nIf\nsatf\n(saturate to finite value) mode is\ntrue\n, the following additional numerical properties apply for the destination accumulator:\nIf an element result is +Infinity, the corresponding accumulator will contain\n+MAX_NORM\nIf an element result is -Infinity, the corresponding accumulator will contain\n-MAX_NORM\nIf an element result is NaN, the corresponding accumulator will contain\n+0\nBecause the map of matrix elements into each threadâs\nfragment\nis unspecified, individual matrix elements must be accessed from memory (shared or global) after calling\nstore_matrix_sync\n. In the special case where all threads in the warp will apply an element-wise operation uniformly to all fragment elements, direct element access can be implemented using the following\nfragment\nclass members.\nenum\nfragment\n<\nUse\n,\nm\n,\nn\n,\nk\n,\nT\n,\nLayout\n>::\nnum_elements\n;\nT\nfragment\n<\nUse\n,\nm\n,\nn\n,\nk\n,\nT\n,\nLayout\n>::\nx\n[\nnum_elements\n];\nAs an example, the following code scales an\naccumulator\nmatrix tile by half.\nwmma\n::\nfragment\n<\nwmma\n::\naccumulator\n,\n16\n,\n16\n,\n16\n,\nfloat\n>\nfrag\n;\nfloat\nalpha\n=\n0.5f\n;\n// Same value for all threads in warp\n/*...*/\nfor\n(\nint\nt\n=\n0\n;\nt\n<\nfrag\n.\nnum_elements\n;\nt\n++\n)\nfrag\n.\nx\n[\nt\n]\n*=\nalpha\n;\n10.24.2.\nAlternate Floating Point\nï\nTensor Cores support alternate types of floating point operations on devices with compute capability 8.0 and higher.\n__nv_bfloat16\nThis data format is an alternate fp16 format that has the same range as f32 but reduced precision (7 bits). You can use this data format directly with the\n__nv_bfloat16\ntype available in\ncuda_bf16.h\n. Matrix fragments with\n__nv_bfloat16\ndata types are required to be composed with accumulators of\nfloat\ntype. The shapes and operations supported are the same as with\n__half\n.\ntf32\nThis data format is a special floating point format supported by Tensor Cores, with the same range as f32 and reduced precision (>=10 bits). The internal layout of this format is implementation defined. In order to use this floating point format with WMMA operations, the input matrices must be manually converted to tf32 precision.\nTo facilitate conversion, a new intrinsic\n__float_to_tf32\nis provided. While the input and output arguments to the intrinsic are of\nfloat\ntype, the output will be\ntf32\nnumerically. This new precision is intended to be used with Tensor Cores only, and if mixed with other\nfloat\ntype operations, the precision and range of the result will be undefined.\nOnce an input matrix (\nmatrix_a\nor\nmatrix_b\n) is converted to tf32 precision, the combination of a\nfragment\nwith\nprecision::tf32\nprecision, and a data type of\nfloat\nto\nload_matrix_sync\nwill take advantage of this new capability. Both the accumulator fragments must have\nfloat\ndata types. The only supported matrix size is 16x16x8 (m-n-k).\nThe elements of the fragment are represented as\nfloat\n, hence the mapping from\nelement_type<T>\nto\nstorage_element_type<T>\nis:\nprecision\n::\ntf32\n->\nfloat\n10.24.3.\nDouble Precision\nï\nTensor Cores support double-precision floating point operations on devices with compute capability 8.0 and higher. To use this new functionality, a\nfragment\nwith the\ndouble\ntype must be used. The\nmma_sync\noperation will be performed with the .rn (rounds to nearest even) rounding modifier.\n10.24.4.\nSub-byte Operations\nï\nSub-byte WMMA operations provide a way to access the low-precision capabilities of Tensor Cores. They are considered a preview feature i.e. the data structures and APIs for them are subject to change and may not be compatible with future releases. This functionality is available via the\nnvcuda::wmma::experimental\nnamespace:\nnamespace\nexperimental\n{\nnamespace\nprecision\n{\nstruct\nu4\n;\n// 4-bit unsigned\nstruct\ns4\n;\n// 4-bit signed\nstruct\nb1\n;\n// 1-bit\n}\nenum\nbmmaBitOp\n{\nbmmaBitOpXOR\n=\n1\n,\n// compute_75 minimum\nbmmaBitOpAND\n=\n2\n// compute_80 minimum\n};\nenum\nbmmaAccumulateOp\n{\nbmmaAccumulateOpPOPC\n=\n1\n};\n}\nFor 4 bit precision, the APIs available remain the same, but you must specify\nexperimental::precision::u4\nor\nexperimental::precision::s4\nas the fragment data type. Since the elements of the fragment are packed together,\nnum_storage_elements\nwill be smaller than\nnum_elements\nfor that fragment. The\nnum_elements\nvariable for a sub-byte fragment, hence returns the number of elements of sub-byte type\nelement_type<T>\n. This is true for single bit precision as well, in which case, the mapping from\nelement_type<T>\nto\nstorage_element_type<T>\nis as follows:\nexperimental\n::\nprecision\n::\nu4\n->\nunsigned\n(\n8\nelements\nin\n1\nstorage\nelement\n)\nexperimental\n::\nprecision\n::\ns4\n->\nint\n(\n8\nelements\nin\n1\nstorage\nelement\n)\nexperimental\n::\nprecision\n::\nb1\n->\nunsigned\n(\n32\nelements\nin\n1\nstorage\nelement\n)\nT\n->\nT\n//all other types\nThe allowed layouts for sub-byte fragments is always\nrow_major\nfor\nmatrix_a\nand\ncol_major\nfor\nmatrix_b\n.\nFor sub-byte operations the value of\nldm\nin\nload_matrix_sync\nshould be a multiple of 32 for element type\nexperimental::precision::u4\nand\nexperimental::precision::s4\nor a multiple of 128 for element type\nexperimental::precision::b1\n(i.e., multiple of 16 bytes in both cases).\nNote\nSupport for the following variants for MMA instructions is deprecated and will be removed in sm_90:\nexperimental::precision::u4\nexperimental::precision::s4\nexperimental::precision::b1\nwith\nbmmaBitOp\nset to\nbmmaBitOpXOR\nbmma_sync\nWaits until all warp lanes have executed bmma_sync, and then performs the warp-synchronous bit matrix multiply-accumulate operation\nD\n=\n(A\nop\nB)\n+\nC\n, where\nop\nconsists of a logical operation\nbmmaBitOp\nfollowed by the accumulation defined by\nbmmaAccumulateOp\n. The available operations are:\nbmmaBitOpXOR\n, a 128-bit XOR of a row in\nmatrix_a\nwith the 128-bit column of\nmatrix_b\nbmmaBitOpAND\n, a 128-bit AND of a row in\nmatrix_a\nwith the 128-bit column of\nmatrix_b\n, available on devices with compute capability 8.0 and higher.\nThe accumulate op is always\nbmmaAccumulateOpPOPC\nwhich counts the number of set bits.\n10.24.5.\nRestrictions\nï\nThe special format required by tensor cores may be different for each major and minor device architecture. This is further complicated by threads holding only a fragment (opaque architecture-specific ABI data structure) of the overall matrix, with the developer not allowed to make assumptions on how the individual parameters are mapped to the registers participating in the matrix multiply-accumulate.\nSince fragments are architecture-specific, it is unsafe to pass them from function A to function B if the functions have been compiled for different link-compatible architectures and linked together into the same device executable. In this case, the size and layout of the fragment will be specific to one architecture and using WMMA APIs in the other will lead to incorrect results or potentially, corruption.\nAn example of two link-compatible architectures, where the layout of the fragment differs, is sm_70 and sm_75.\nfragA\n.\ncu\n:\nvoid\nfoo\n()\n{\nwmma\n::\nfragment\n<\n...\n>\nmat_a\n;\nbar\n(\n&\nmat_a\n);\n}\nfragB\n.\ncu\n:\nvoid\nbar\n(\nwmma\n::\nfragment\n<\n...\n>\n*\nmat_a\n)\n{\n// operate on mat_a }\n// sm_70 fragment layout\n$\n>\nnvcc\n-\ndc\n-\narch\n=\ncompute_70\n-\ncode\n=\nsm_70\nfragA\n.\ncu\n-\no\nfragA\n.\no\n// sm_75 fragment layout\n$\n>\nnvcc\n-\ndc\n-\narch\n=\ncompute_75\n-\ncode\n=\nsm_75\nfragB\n.\ncu\n-\no\nfragB\n.\no\n// Linking the two together\n$\n>\nnvcc\n-\ndlink\n-\narch\n=\nsm_75\nfragA\n.\no\nfragB\n.\no\n-\no\nfrag\n.\no\nThis undefined behavior might also be undetectable at compilation time and by tools at runtime, so extra care is needed to make sure the layout of the fragments is consistent. This linking hazard is most likely to appear when linking with a legacy library that is both built for a different link-compatible architecture and expecting to be passed a WMMA fragment.\nNote that in the case of weak linkages (for example, a CUDA C++ inline function), the linker may choose any available function definition which may result in implicit passes between compilation units.\nTo avoid these sorts of problems, the matrix should always be stored out to memory for transit through external interfaces (e.g.\nwmma::store_matrix_sync(dst,\nâ¦);\n) and then it can be safely passed to\nbar()\nas a pointer type [e.g.\nfloat\n*dst\n].\nNote that since sm_70 can run on sm_75, the above example sm_75 code can be changed to sm_70 and correctly work on sm_75. However, it is recommended to have sm_75 native code in your application when linking with other sm_75 separately compiled binaries.\n10.24.6.\nElement Types and Matrix Sizes\nï\nTensor Cores support a variety of element types and matrix sizes. The following table presents the various combinations of\nmatrix_a\n,\nmatrix_b\nand\naccumulator\nmatrix supported:\nMatrix A\nMatrix B\nAccumulator\nMatrix Size (m-n-k)\n__half\n__half\nfloat\n16x16x16\n__half\n__half\nfloat\n32x8x16\n__half\n__half\nfloat\n8x32x16\n__half\n__half\n__half\n16x16x16\n__half\n__half\n__half\n32x8x16\n__half\n__half\n__half\n8x32x16\nunsigned char\nunsigned char\nint\n16x16x16\nunsigned char\nunsigned char\nint\n32x8x16\nunsigned char\nunsigned char\nint\n8x32x16\nsigned char\nsigned char\nint\n16x16x16\nsigned char\nsigned char\nint\n32x8x16\nsigned char\nsigned char\nint\n8x32x16\nAlternate Floating Point support:\nMatrix A\nMatrix B\nAccumulator\nMatrix Size (m-n-k)\n__nv_bfloat16\n__nv_bfloat16\nfloat\n16x16x16\n__nv_bfloat16\n__nv_bfloat16\nfloat\n32x8x16\n__nv_bfloat16\n__nv_bfloat16\nfloat\n8x32x16\nprecision::tf32\nprecision::tf32\nfloat\n16x16x8\nDouble Precision Support:\nMatrix A\nMatrix B\nAccumulator\nMatrix Size (m-n-k)\ndouble\ndouble\ndouble\n8x8x4\nExperimental support for sub-byte operations:\nMatrix A\nMatrix B\nAccumulator\nMatrix Size (m-n-k)\nprecision::u4\nprecision::u4\nint\n8x8x32\nprecision::s4\nprecision::s4\nint\n8x8x32\nprecision::b1\nprecision::b1\nint\n8x8x128\n10.24.7.\nExample\nï\nThe following code implements a 16x16x16 matrix multiplication in a single warp.\n#include\n<mma.h>\nusing\nnamespace\nnvcuda\n;\n__global__\nvoid\nwmma_ker\n(\nhalf\n*\na\n,\nhalf\n*\nb\n,\nfloat\n*\nc\n)\n{\n// Declare the fragments\nwmma\n::\nfragment\n<\nwmma\n::\nmatrix_a\n,\n16\n,\n16\n,\n16\n,\nhalf\n,\nwmma\n::\ncol_major\n>\na_frag\n;\nwmma\n::\nfragment\n<\nwmma\n::\nmatrix_b\n,\n16\n,\n16\n,\n16\n,\nhalf\n,\nwmma\n::\nrow_major\n>\nb_frag\n;\nwmma\n::\nfragment\n<\nwmma\n::\naccumulator\n,\n16\n,\n16\n,\n16\n,\nfloat\n>\nc_frag\n;\n// Initialize the output to zero\nwmma\n::\nfill_fragment\n(\nc_frag\n,\n0.0f\n);\n// Load the inputs\nwmma\n::\nload_matrix_sync\n(\na_frag\n,\na\n,\n16\n);\nwmma\n::\nload_matrix_sync\n(\nb_frag\n,\nb\n,\n16\n);\n// Perform the matrix multiplication\nwmma\n::\nmma_sync\n(\nc_frag\n,\na_frag\n,\nb_frag\n,\nc_frag\n);\n// Store the output\nwmma\n::\nstore_matrix_sync\n(\nc\n,\nc_frag\n,\n16\n,\nwmma\n::\nmem_row_major\n);\n}\n10.25.\nDPX\nï\nDPX is a set of functions that enable finding min and max values, as well as fused addition and min/max, for up to three 16 and 32-bit signed or unsigned integer parameters, with optional ReLU (clamping to zero):\nthree parameters:\n__vimax3_s32\n,\n__vimax3_s16x2\n,\n__vimax3_u32\n,\n__vimax3_u16x2\n,\n__vimin3_s32\n,\n__vimin3_s16x2\n,\n__vimin3_u32\n,\n__vimin3_u16x2\ntwo parameters, with ReLU:\n__vimax_s32_relu\n,\n__vimax_s16x2_relu\n,\n__vimin_s32_relu\n,\n__vimin_s16x2_relu\nthree parameters, with ReLU:\n__vimax3_s32_relu\n,\n__vimax3_s16x2_relu\n,\n__vimin3_s32_relu\n,\n__vimin3_s16x2_relu\ntwo parameters, also returning which parameter was smaller/larger:\n__vibmax_s32\n,\n__vibmax_u32\n,\n__vibmin_s32\n,\n__vibmin_u32\n,\n__vibmax_s16x2\n,\n__vibmax_u16x2\n,\n__vibmin_s16x2\n,\n__vibmin_u16x2\nthree parameters, comparing (first + second) with the third:\n__viaddmax_s32\n,\n__viaddmax_s16x2\n,\n__viaddmax_u32\n,\n__viaddmax_u16x2\n,\n__viaddmin_s32\n,\n__viaddmin_s16x2\n,\n__viaddmin_u32\n,\n__viaddmin_u16x2\nthree parameters, with ReLU, comparing (first + second) with the third and a zero:\n__viaddmax_s32_relu\n,\n__viaddmax_s16x2_relu\n,\n__viaddmin_s32_relu\n,\n__viaddmin_s16x2_relu\nThese instructions are hardware-accelerated on devices with compute capability 9 and higher, and software emulation on older devices.\nFull API can be found in\nCUDA Math API documentation\n.\nDPX is exceptionally useful when implementing dynamic programming algorithms, such as Smith-Waterman or NeedlemanâWunsch in genomics and Floyd-Warshall in route optimization.\n10.25.1.\nExamples\nï\nMax value of three signed 32-bit integers, with ReLU\nconst\nint\na\n=\n-15\n;\nconst\nint\nb\n=\n8\n;\nconst\nint\nc\n=\n5\n;\nint\nmax_value_0\n=\n__vimax3_s32_relu\n(\na\n,\nb\n,\nc\n);\n// max(-15, 8, 5, 0) = 8\nconst\nint\nd\n=\n-2\n;\nconst\nint\ne\n=\n-4\n;\nint\nmax_value_1\n=\n__vimax3_s32_relu\n(\na\n,\nd\n,\ne\n);\n// max(-15, -2, -4, 0) = 0\nMin value of the sum of two 32-bit signed integers, another 32-bit signed integer and a zero (ReLU)\nconst\nint\na\n=\n-5\n;\nconst\nint\nb\n=\n6\n;\nconst\nint\nc\n=\n-2\n;\nint\nmax_value_0\n=\n__viaddmax_s32_relu\n(\na\n,\nb\n,\nc\n);\n// max(-5 + 6, -2, 0) = max(1, -2, 0) = 1\nconst\nint\nd\n=\n4\n;\nint\nmax_value_1\n=\n__viaddmax_s32_relu\n(\na\n,\nd\n,\nc\n);\n// max(-5 + 4, -2, 0) = max(-1, -2, 0) = 0\nMin value of two unsigned 32-bit integers and determining which value is smaller\nconst\nunsigned\nint\na\n=\n9\n;\nconst\nunsigned\nint\nb\n=\n6\n;\nbool\nsmaller_value\n;\nunsigned\nint\nmin_value\n=\n__vibmin_u32\n(\na\n,\nb\n,\n&\nsmaller_value\n);\n// min_value is 6, smaller_value is true\nMax values of three pairs of unsigned 16-bit integers\nconst\nunsigned\na\n=\n0x00050002\n;\nconst\nunsigned\nb\n=\n0x00070004\n;\nconst\nunsigned\nc\n=\n0x00020006\n;\nunsigned\nint\nmax_value\n=\n__vimax3_u16x2\n(\na\n,\nb\n,\nc\n);\n// max(5, 7, 2) and max(2, 4, 6), so max_value is 0x00070006\n10.26.\nAsynchronous Barrier\nï\nThe NVIDIA C++ standard library introduces a GPU implementation of\nstd::barrier\n. Along with the implementation of\nstd::barrier\nthe library provides extensions that allow users to specify the scope of barrier objects. The barrier API scopes are documented under\nThread Scopes\n. Devices of compute capability 8.0 or higher provide hardware acceleration for barrier operations and integration of these barriers with the\nmemcpy_async\nfeature. On devices with compute capability below 8.0 but starting 7.0, these barriers are available without hardware acceleration.\nnvcuda::experimental::awbarrier\nis deprecated in favor of\ncuda::barrier\n.\n10.26.1.\nSimple Synchronization Pattern\nï\nWithout the arrive/wait barrier, synchronization is achieved using\n__syncthreads()\n(to synchronize all threads in a block) or\ngroup.sync()\nwhen using\nCooperative Groups\n.\n#include\n<cooperative_groups.h>\n__global__\nvoid\nsimple_sync\n(\nint\niteration_count\n)\n{\nauto\nblock\n=\ncooperative_groups\n::\nthis_thread_block\n();\nfor\n(\nint\ni\n=\n0\n;\ni\n<\niteration_count\n;\n++\ni\n)\n{\n/* code before arrive */\nblock\n.\nsync\n();\n/* wait for all threads to arrive here */\n/* code after wait */\n}\n}\nThreads are blocked at the synchronization point (\nblock.sync()\n) until all threads have reached the synchronization point. In addition, memory updates that happened before the synchronization point are guaranteed to be visible to all threads in the block after the synchronization point, i.e., equivalent to\natomic_thread_fence(memory_order_seq_cst,\nthread_scope_block)\nas well as the\nsync\n.\nThis pattern has three stages:\nCode\nbefore\nsync performs memory updates that will be read\nafter\nthe sync.\nSynchronization point\nCode\nafter\nsync point with visibility of memory updates that happened\nbefore\nsync point.\n10.26.2.\nTemporal Splitting and Five Stages of Synchronization\nï\nThe temporally-split synchronization pattern with the\nstd::barrier\nis as follows.\n#include\n<cuda/barrier>\n#include\n<cooperative_groups.h>\n__device__\nvoid\ncompute\n(\nfloat\n*\ndata\n,\nint\ncurr_iteration\n);\n__global__\nvoid\nsplit_arrive_wait\n(\nint\niteration_count\n,\nfloat\n*\ndata\n)\n{\nusing\nbarrier\n=\ncuda\n::\nbarrier\n<\ncuda\n::\nthread_scope_block\n>\n;\n__shared__\nbarrier\nbar\n;\nauto\nblock\n=\ncooperative_groups\n::\nthis_thread_block\n();\nif\n(\nblock\n.\nthread_rank\n()\n==\n0\n)\n{\ninit\n(\n&\nbar\n,\nblock\n.\nsize\n());\n// Initialize the barrier with expected arrival count\n}\nblock\n.\nsync\n();\nfor\n(\nint\ncurr_iter\n=\n0\n;\ncurr_iter\n<\niteration_count\n;\n++\ncurr_iter\n)\n{\n/* code before arrive */\nbarrier\n::\narrival_token\ntoken\n=\nbar\n.\narrive\n();\n/* this thread arrives. Arrival does not block a thread */\ncompute\n(\ndata\n,\ncurr_iter\n);\nbar\n.\nwait\n(\nstd\n::\nmove\n(\ntoken\n));\n/* wait for all threads participating in the barrier to complete bar.arrive()*/\n/* code after wait */\n}\n}\nIn this pattern, the synchronization point (\nblock.sync()\n) is split into an arrive point (\nbar.arrive()\n) and a wait point (\nbar.wait(std::move(token))\n). A thread begins participating in a\ncuda::barrier\nwith its first call to\nbar.arrive()\n. When a thread calls\nbar.wait(std::move(token))\nit will be blocked until participating threads have completed\nbar.arrive()\nthe expected number of times as specified by the expected arrival count argument passed to\ninit()\n. Memory updates that happen before participating threadsâ call to\nbar.arrive()\nare guaranteed to be visible to participating threads after their call to\nbar.wait(std::move(token))\n. Note that the call to\nbar.arrive()\ndoes not block a thread, it can proceed with other work that does not depend upon memory updates that happen before other participating threadsâ call to\nbar.arrive()\n.\nThe\narrive and then wait\npattern has five stages which may be iteratively repeated:\nCode\nbefore\narrive performs memory updates that will be read\nafter\nthe wait.\nArrive point with implicit memory fence (i.e., equivalent to\natomic_thread_fence(memory_order_seq_cst,\nthread_scope_block)\n).\nCode\nbetween\narrive and wait.\nWait point.\nCode\nafter\nthe wait, with visibility of updates that were performed\nbefore\nthe arrive.\n10.26.3.\nBootstrap Initialization, Expected Arrival Count, and Participation\nï\nInitialization must happen before any thread begins participating in a\ncuda::barrier\n.\n#include\n<cuda/barrier>\n#include\n<cooperative_groups.h>\n__global__\nvoid\ninit_barrier\n()\n{\n__shared__\ncuda\n::\nbarrier\n<\ncuda\n::\nthread_scope_block\n>\nbar\n;\nauto\nblock\n=\ncooperative_groups\n::\nthis_thread_block\n();\nif\n(\nblock\n.\nthread_rank\n()\n==\n0\n)\n{\ninit\n(\n&\nbar\n,\nblock\n.\nsize\n());\n// Single thread initializes the total expected arrival count.\n}\nblock\n.\nsync\n();\n}\nBefore any thread can participate in\ncuda::barrier\n, the barrier must be initialized using\ninit()\nwith an\nexpected arrival count\n,\nblock.size()\nin this example. Initialization must happen before any thread calls\nbar.arrive()\n. This poses a bootstrapping challenge in that threads must synchronize before participating in the\ncuda::barrier\n, but threads are creating a\ncuda::barrier\nin order to synchronize. In this example, threads that will participate are part of a cooperative group and use\nblock.sync()\nto bootstrap initialization. In this example a whole thread block is participating in initialization, hence\n__syncthreads()\ncould also be used.\nThe second parameter of\ninit()\nis the\nexpected arrival count\n, i.e., the number of times\nbar.arrive()\nwill be called by participating threads before a participating thread is unblocked from its call to\nbar.wait(std::move(token))\n. In the prior example the\ncuda::barrier\nis initialized with the number of threads in the thread block i.e.,\ncooperative_groups::this_thread_block().size()\n, and all threads within the thread block participate in the barrier.\nA\ncuda::barrier\nis flexible in specifying how threads participate (split arrive/wait) and which threads participate. In contrast\nthis_thread_block.sync()\nfrom cooperative groups or\n__syncthreads()\nis applicable to whole-thread-block and\n__syncwarp(mask)\nis a specified subset of a warp. If the intention of the user is to synchronize a full thread block or a full warp we recommend using\n__syncthreads()\nand\n__syncwarp(mask)\nrespectively for performance reasons.\n10.26.4.\nA Barrierâs Phase: Arrival, Countdown, Completion, and Reset\nï\nA\ncuda::barrier\ncounts down from the expected arrival count to zero as participating threads call\nbar.arrive()\n. When the countdown reaches zero, a\ncuda::barrier\nis complete for the current phase. When the last call to\nbar.arrive()\ncauses the countdown to reach zero, the countdown is automatically and atomically reset. The reset assigns the countdown to the expected arrival count, and moves the\ncuda::barrier\nto the next phase.\nA\ntoken\nobject of class\ncuda::barrier::arrival_token\n, as returned from\ntoken=bar.arrive()\n, is associated with the current phase of the barrier. A call to\nbar.wait(std::move(token))\nblocks the calling thread while the\ncuda::barrier\nis in the current phase, i.e., while the phase associated with the token matches the phase of the\ncuda::barrier\n. If the phase is advanced (because the countdown reaches zero) before the call to\nbar.wait(std::move(token))\nthen the thread does not block; if the phase is advanced while the thread is blocked in\nbar.wait(std::move(token))\n, the thread is unblocked.\nIt is essential to know when a reset could or could not occur, especially in non-trivial arrive/wait synchronization patterns.\nA threadâs calls to\ntoken=bar.arrive()\nand\nbar.wait(std::move(token))\nmust be sequenced such that\ntoken=bar.arrive()\noccurs during the\ncuda::barrier\nâs current phase, and\nbar.wait(std::move(token))\noccurs during the same or next phase.\nA threadâs call to\nbar.arrive()\nmust occur when the barrierâs counter is non-zero. After barrier initialization, if a threadâs call to\nbar.arrive()\ncauses the countdown to reach zero then a call to\nbar.wait(std::move(token))\nmust happen before the barrier can be reused for a subsequent call to\nbar.arrive()\n.\nbar.wait()\nmust only be called using a\ntoken\nobject of the current phase or the immediately preceding phase. For any other values of the\ntoken\nobject, the behavior is undefined.\nFor simple arrive/wait synchronization patterns, compliance with these usage rules is straightforward.\n10.26.5.\nSpatial Partitioning (also known as Warp Specialization)\nï\nA thread block can be spatially partitioned such that warps are specialized to perform independent computations. Spatial partitioning is used in a producer or consumer pattern, where one subset of threads produces data that is concurrently consumed by the other (disjoint) subset of threads.\nA producer/consumer spatial partitioning pattern requires two one sided synchronizations to manage a data buffer between the producer and consumer.\nProducer\nConsumer\nwait for buffer to be ready to be filled\nsignal buffer is ready to be filled\nproduce data and fill the buffer\nsignal buffer is filled\nwait for buffer to be filled\nconsume data in filled buffer\nProducer threads wait for consumer threads to signal that the buffer is ready to be filled; however, consumer threads do not wait for this signal. Consumer threads wait for producer threads to signal that the buffer is filled; however, producer threads do not wait for this signal. For full producer/consumer concurrency this pattern has (at least) double buffering where each buffer requires two\ncuda::barrier\ns.\n#include\n<cuda/barrier>\n#include\n<cooperative_groups.h>\nusing\nbarrier\n=\ncuda\n::\nbarrier\n<\ncuda\n::\nthread_scope_block\n>\n;\n__device__\nvoid\nproducer\n(\nbarrier\nready\n[],\nbarrier\nfilled\n[],\nfloat\n*\nbuffer\n,\nfloat\n*\nin\n,\nint\nN\n,\nint\nbuffer_len\n)\n{\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n(\nN\n/\nbuffer_len\n);\n++\ni\n)\n{\nready\n[\ni\n%\n2\n].\narrive_and_wait\n();\n/* wait for buffer_(i%2) to be ready to be filled */\n/* produce, i.e., fill in, buffer_(i%2)  */\nbarrier\n::\narrival_token\ntoken\n=\nfilled\n[\ni\n%\n2\n].\narrive\n();\n/* buffer_(i%2) is filled */\n}\n}\n__device__\nvoid\nconsumer\n(\nbarrier\nready\n[],\nbarrier\nfilled\n[],\nfloat\n*\nbuffer\n,\nfloat\n*\nout\n,\nint\nN\n,\nint\nbuffer_len\n)\n{\nbarrier\n::\narrival_token\ntoken1\n=\nready\n[\n0\n].\narrive\n();\n/* buffer_0 is ready for initial fill */\nbarrier\n::\narrival_token\ntoken2\n=\nready\n[\n1\n].\narrive\n();\n/* buffer_1 is ready for initial fill */\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n(\nN\n/\nbuffer_len\n);\n++\ni\n)\n{\nfilled\n[\ni\n%\n2\n].\narrive_and_wait\n();\n/* wait for buffer_(i%2) to be filled */\n/* consume buffer_(i%2) */\nbarrier\n::\narrival_token\ntoken\n=\nready\n[\ni\n%\n2\n].\narrive\n();\n/* buffer_(i%2) is ready to be re-filled */\n}\n}\n//N is the total number of float elements in arrays in and out\n__global__\nvoid\nproducer_consumer_pattern\n(\nint\nN\n,\nint\nbuffer_len\n,\nfloat\n*\nin\n,\nfloat\n*\nout\n)\n{\n// Shared memory buffer declared below is of size 2 * buffer_len\n// so that we can alternatively work between two buffers.\n// buffer_0 = buffer and buffer_1 = buffer + buffer_len\n__shared__\nextern\nfloat\nbuffer\n[];\n// bar[0] and bar[1] track if buffers buffer_0 and buffer_1 are ready to be filled,\n// while bar[2] and bar[3] track if buffers buffer_0 and buffer_1 are filled-in respectively\n__shared__\nbarrier\nbar\n[\n4\n];\nauto\nblock\n=\ncooperative_groups\n::\nthis_thread_block\n();\nif\n(\nblock\n.\nthread_rank\n()\n<\n4\n)\ninit\n(\nbar\n+\nblock\n.\nthread_rank\n(),\nblock\n.\nsize\n());\nblock\n.\nsync\n();\nif\n(\nblock\n.\nthread_rank\n()\n<\nwarpSize\n)\nproducer\n(\nbar\n,\nbar\n+\n2\n,\nbuffer\n,\nin\n,\nN\n,\nbuffer_len\n);\nelse\nconsumer\n(\nbar\n,\nbar\n+\n2\n,\nbuffer\n,\nout\n,\nN\n,\nbuffer_len\n);\n}\nIn this example the first warp is specialized as the producer and the remaining warps are specialized as the consumer. All producer and consumer threads participate (call\nbar.arrive()\nor\nbar.arrive_and_wait()\n) in each of the four\ncuda::barrier\ns so the expected arrival counts are equal to\nblock.size()\n.\nA producer thread waits for the consumer threads to signal that the shared memory buffer can be filled. In order to wait for a\ncuda::barrier\na producer thread must first arrive on that\nready[i%2].arrive()\nto get a token and then\nready[i%2].wait(token)\nwith that token. For simplicity\nready[i%2].arrive_and_wait()\ncombines these operations.\nbar\n.\narrive_and_wait\n();\n/* is equivalent to */\nbar\n.\nwait\n(\nbar\n.\narrive\n());\nProducer threads compute and fill the ready buffer, they then signal that the buffer is filled by arriving on the filled barrier,\nfilled[i%2].arrive()\n. A producer thread does not wait at this point, instead it waits until the next iterationâs buffer (double buffering) is ready to be filled.\nA consumer thread begins by signaling that both buffers are ready to be filled. A consumer thread does not wait at this point, instead it waits for this iterationâs buffer to be filled,\nfilled[i%2].arrive_and_wait()\n. After the consumer threads consume the buffer they signal that the buffer is ready to be filled again,\nready[i%2].arrive()\n, and then wait for the next iterationâs buffer to be filled.\n10.26.6.\nEarly Exit (Dropping out of Participation)\nï\nWhen a thread that is participating in a sequence of synchronizations must exit early from that sequence, that thread must explicitly drop out of participation before exiting. The remaining participating threads can proceed normally with subsequent\ncuda::barrier\narrive and wait operations.\n#include\n<cuda/barrier>\n#include\n<cooperative_groups.h>\n__device__\nbool\ncondition_check\n();\n__global__\nvoid\nearly_exit_kernel\n(\nint\nN\n)\n{\nusing\nbarrier\n=\ncuda\n::\nbarrier\n<\ncuda\n::\nthread_scope_block\n>\n;\n__shared__\nbarrier\nbar\n;\nauto\nblock\n=\ncooperative_groups\n::\nthis_thread_block\n();\nif\n(\nblock\n.\nthread_rank\n()\n==\n0\n)\ninit\n(\n&\nbar\n,\nblock\n.\nsize\n());\nblock\n.\nsync\n();\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nN\n;\n++\ni\n)\n{\nif\n(\ncondition_check\n())\n{\nbar\n.\narrive_and_drop\n();\nreturn\n;\n}\n/* other threads can proceed normally */\nbarrier\n::\narrival_token\ntoken\n=\nbar\n.\narrive\n();\n/* code between arrive and wait */\nbar\n.\nwait\n(\nstd\n::\nmove\n(\ntoken\n));\n/* wait for all threads to arrive */\n/* code after wait */\n}\n}\nThis operation arrives on the\ncuda::barrier\nto fulfill the participating threadâs obligation to arrive in the\ncurrent\nphase, and then decrements the expected arrival count for the\nnext\nphase so that this thread is no longer expected to arrive on the barrier.\n10.26.7.\nCompletion Function\nï\nThe\nCompletionFunction\nof\ncuda::barrier<Scope,\nCompletionFunction>\nis executed once per phase, after the last thread\narrives\nand before any thread is unblocked from the\nwait\n. Memory operations performed by the threads that arrived at the\nbarrier\nduring the phase are visible to the thread executing the\nCompletionFunction\n, and all memory operations performed within the\nCompletionFunction\nare visible to all threads waiting at the\nbarrier\nonce they are unblocked from the\nwait\n.\n#include\n<cuda/barrier>\n#include\n<cooperative_groups.h>\n#include\n<functional>\nnamespace\ncg\n=\ncooperative_groups\n;\n__device__\nint\ndivergent_compute\n(\nint\n*\n,\nint\n);\n__device__\nint\nindependent_computation\n(\nint\n*\n,\nint\n);\n__global__\nvoid\npsum\n(\nint\n*\ndata\n,\nint\nn\n,\nint\n*\nacc\n)\n{\nauto\nblock\n=\ncg\n::\nthis_thread_block\n();\nconstexpr\nint\nBlockSize\n=\n128\n;\n__shared__\nint\nsmem\n[\nBlockSize\n];\nassert\n(\nBlockSize\n==\nblock\n.\nsize\n());\nassert\n(\nn\n%\n128\n==\n0\n);\nauto\ncompletion_fn\n=\n[\n&\n]\n{\nint\nsum\n=\n0\n;\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n128\n;\n++\ni\n)\nsum\n+=\nsmem\n[\ni\n];\n*\nacc\n+=\nsum\n;\n};\n// Barrier storage\n// Note: the barrier is not default-constructible because\n//       completion_fn is not default-constructible due\n//       to the capture.\nusing\ncompletion_fn_t\n=\ndecltype\n(\ncompletion_fn\n);\nusing\nbarrier_t\n=\ncuda\n::\nbarrier\n<\ncuda\n::\nthread_scope_block\n,\ncompletion_fn_t\n>\n;\n__shared__\nstd\n::\naligned_storage\n<\nsizeof\n(\nbarrier_t\n),\nalignof\n(\nbarrier_t\n)\n>\nbar_storage\n;\n// Initialize barrier:\nbarrier_t\n*\nbar\n=\n(\nbarrier_t\n*\n)\n&\nbar_storage\n;\nif\n(\nblock\n.\nthread_rank\n()\n==\n0\n)\n{\nassert\n(\n*\nacc\n==\n0\n);\nassert\n(\nblockDim\n.\nx\n==\nblockDim\n.\ny\n==\nblockDim\n.\ny\n==\n1\n);\nnew\n(\nbar\n)\nbarrier_t\n{\nblock\n.\nsize\n(),\ncompletion_fn\n};\n// equivalent to: init(bar, block.size(), completion_fn);\n}\nblock\n.\nsync\n();\n// Main loop\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nn\n;\ni\n+=\nblock\n.\nsize\n())\n{\nsmem\n[\nblock\n.\nthread_rank\n()]\n=\ndata\n[\ni\n]\n+\n*\nacc\n;\nauto\nt\n=\nbar\n->\narrive\n();\n// We can do independent computation here\nbar\n->\nwait\n(\nstd\n::\nmove\n(\nt\n));\n// shared-memory is safe to re-use in the next iteration\n// since all threads are done with it, including the one\n// that did the reduction\n}\n}\n10.26.8.\nMemory Barrier Primitives Interface\nï\nMemory barrier primitives are C-like interfaces to\ncuda::barrier\nfunctionality. These primitives are available through including the\n<cuda_awbarrier_primitives.h>\nheader.\n10.26.8.1.\nData Types\nï\ntypedef\n/* implementation defined */\n__mbarrier_t\n;\ntypedef\n/* implementation defined */\n__mbarrier_token_t\n;\n10.26.8.2.\nMemory Barrier Primitives API\nï\nuint32_t\n__mbarrier_maximum_count\n();\nvoid\n__mbarrier_init\n(\n__mbarrier_t\n*\nbar\n,\nuint32_t\nexpected_count\n);\nbar\nmust be a pointer to\n__shared__\nmemory.\nexpected_count\n<=\n__mbarrier_maximum_count()\nInitialize\n*bar\nexpected arrival count for the current and next phase to\nexpected_count\n.\nvoid\n__mbarrier_inval\n(\n__mbarrier_t\n*\nbar\n);\nbar\nmust be a pointer to the mbarrier object residing in shared memory.\nInvalidation of\n*bar\nis required before the corresponding shared memory can be repurposed.\n__mbarrier_token_t\n__mbarrier_arrive\n(\n__mbarrier_t\n*\nbar\n);\nInitialization of\n*bar\nmust happen before this call.\nPending count must not be zero.\nAtomically decrement the pending count for the current phase of the barrier.\nReturn an arrival token associated with the barrier state immediately prior to the decrement.\n__mbarrier_token_t\n__mbarrier_arrive_and_drop\n(\n__mbarrier_t\n*\nbar\n);\nInitialization of\n*bar\nmust happen before this call.\nPending count must not be zero.\nAtomically decrement the pending count for the current phase and expected count for the next phase of the barrier.\nReturn an arrival token associated with the barrier state immediately prior to the decrement.\nbool\n__mbarrier_test_wait\n(\n__mbarrier_t\n*\nbar\n,\n__mbarrier_token_t\ntoken\n);\ntoken\nmust be associated with the immediately preceding phase or current phase of\n*this\n.\nReturns\ntrue\nif\ntoken\nis associated with the immediately preceding phase of\n*bar\n, otherwise returns\nfalse\n.\n//Note: This API has been deprecated in CUDA 11.1\nuint32_t\n__mbarrier_pending_count\n(\n__mbarrier_token_t\ntoken\n);\n10.27.\nAsynchronous Data Copies\nï\nCUDA 11 introduces Asynchronous Data operations with\nmemcpy_async\nAPI to allow device code to explicitly manage the asynchronous copying of data. The\nmemcpy_async\nfeature enables CUDA kernels to overlap computation with data movement.\n10.27.1.\nmemcpy_async\nAPI\nï\nThe\nmemcpy_async\nAPIs are provided in the\ncuda/barrier\n,\ncuda/pipeline\n, and\ncooperative_groups/memcpy_async.h\nheader files.\nThe\ncuda::memcpy_async\nAPIs work with\ncuda::barrier\nand\ncuda::pipeline\nsynchronization primitives, while the\ncooperative_groups::memcpy_async\nsynchronizes using\ncooperative_groups::wait\n.\nThese APIs have very similar semantics: copy objects from\nsrc\nto\ndst\nas-if performed by another thread which, on completion of the copy, can be synchronized through\ncuda::pipeline\n,\ncuda::barrier\n, or\ncooperative_groups::wait\n.\nThe complete API documentation of the\ncuda::memcpy_async\noverloads for\ncuda::barrier\nand\ncuda::pipeline\nis provided in the\nlibcudacxx API\ndocumentation along with some examples.\nThe API documentation of\ncooperative_groups::memcpy_async\nis provided in the\nCooperative Groups\nsection.\nThe\nmemcpy_async\nAPIs that use\ncuda::barrier\nand\ncuda::pipeline\nrequire compute capability 7.0 or higher. On devices with compute capability 8.0 or higher,\nmemcpy_async\noperations from global to shared memory can benefit from hardware acceleration.\n10.27.2.\nCopy and Compute Pattern - Staging Data Through Shared Memory\nï\nCUDA applications often employ a\ncopy and compute\npattern that:\nfetches data from global memory,\nstores data to shared memory, and\nperforms computations on shared memory data, and potentially writes results back to global memory.\nThe following sections illustrate how this pattern can be expressed without and with the\nmemcpy_async\nfeature:\nWithout memcpy_async\nintroduces an example that does not overlap computation with data movement and uses an intermediate register to copy data.\nWith memcpy_async\nimproves the previous example by introducing the\nmemcpy_async\nand the\ncuda::memcpy_async\nAPIs to directly copy data from global to shared memory without using intermediate registers.\nAsynchronous Data Copies using cuda::barrier\nshows memcpy with cooperative groups and barrier.\nSingle-Stage Asynchronous Data Copies using cuda::pipeline\nshows memcpy with single stage pipeline.\nMulti-Stage Asynchronous Data Copies using cuda::pipeline\nshows memcpy with multi stage pipeline.\n10.27.3.\nWithout\nmemcpy_async\nï\nWithout\nmemcpy_async\n, the\ncopy\nphase of the\ncopy and compute\npattern is expressed as\nshared[local_idx]\n=\nglobal[global_idx]\n. This global to shared memory copy is expanded to a read from global memory into a register, followed by a write to shared memory from the register.\nWhen this pattern occurs within an iterative algorithm, each thread block needs to synchronize after the\nshared[local_idx]\n=\nglobal[global_idx]\nassignment, to ensure all writes to shared memory have completed before the compute phase can begin. The thread block also needs to synchronize again after the compute phase, to prevent overwriting shared memory before all threads have completed their computations. This pattern is illustrated in the following code snippet.\n#include\n<cooperative_groups.h>\n__device__\nvoid\ncompute\n(\nint\n*\nglobal_out\n,\nint\nconst\n*\nshared_in\n)\n{\n// Computes using all values of current batch from shared memory.\n// Stores this thread's result back to global memory.\n}\n__global__\nvoid\nwithout_memcpy_async\n(\nint\n*\nglobal_out\n,\nint\nconst\n*\nglobal_in\n,\nsize_t\nsize\n,\nsize_t\nbatch_sz\n)\n{\nauto\ngrid\n=\ncooperative_groups\n::\nthis_grid\n();\nauto\nblock\n=\ncooperative_groups\n::\nthis_thread_block\n();\nassert\n(\nsize\n==\nbatch_sz\n*\ngrid\n.\nsize\n());\n// Exposition: input size fits batch_sz * grid_size\nextern\n__shared__\nint\nshared\n[];\n// block.size() * sizeof(int) bytes\nsize_t\nlocal_idx\n=\nblock\n.\nthread_rank\n();\nfor\n(\nsize_t\nbatch\n=\n0\n;\nbatch\n<\nbatch_sz\n;\n++\nbatch\n)\n{\n// Compute the index of the current batch for this block in global memory:\nsize_t\nblock_batch_idx\n=\nblock\n.\ngroup_index\n().\nx\n*\nblock\n.\nsize\n()\n+\ngrid\n.\nsize\n()\n*\nbatch\n;\nsize_t\nglobal_idx\n=\nblock_batch_idx\n+\nthreadIdx\n.\nx\n;\nshared\n[\nlocal_idx\n]\n=\nglobal_in\n[\nglobal_idx\n];\nblock\n.\nsync\n();\n// Wait for all copies to complete\ncompute\n(\nglobal_out\n+\nblock_batch_idx\n,\nshared\n);\n// Compute and write result to global memory\nblock\n.\nsync\n();\n// Wait for compute using shared memory to finish\n}\n}\n10.27.4.\nWith\nmemcpy_async\nï\nWith\nmemcpy_async\n, the assignment of shared memory from global memory\nshared\n[\nlocal_idx\n]\n=\nglobal_in\n[\nglobal_idx\n];\nis replaced with an asynchronous copy operation from\ncooperative groups\ncooperative_groups\n::\nmemcpy_async\n(\ngroup\n,\nshared\n,\nglobal_in\n+\nbatch_idx\n,\nsizeof\n(\nint\n)\n*\nblock\n.\nsize\n());\nThe\ncooperative_groups::memcpy_async\nAPI copies\nsizeof(int)\n*\nblock.size()\nbytes from global memory starting at\nglobal_in\n+\nbatch_idx\nto the\nshared\ndata. This operation happens as-if performed by another thread, which synchronizes with the current threadâs call to\ncooperative_groups::wait\nafter the copy has completed. Until the copy operation completes, modifying the global data or reading or writing the shared data introduces a data race.\nOn devices with compute capability 8.0 or higher,\nmemcpy_async\ntransfers from global to shared memory can benefit from hardware acceleration, which avoids transferring the data through an intermediate register.\n#include\n<cooperative_groups.h>\n#include\n<cooperative_groups/memcpy_async.h>\n__device__\nvoid\ncompute\n(\nint\n*\nglobal_out\n,\nint\nconst\n*\nshared_in\n);\n__global__\nvoid\nwith_memcpy_async\n(\nint\n*\nglobal_out\n,\nint\nconst\n*\nglobal_in\n,\nsize_t\nsize\n,\nsize_t\nbatch_sz\n)\n{\nauto\ngrid\n=\ncooperative_groups\n::\nthis_grid\n();\nauto\nblock\n=\ncooperative_groups\n::\nthis_thread_block\n();\nassert\n(\nsize\n==\nbatch_sz\n*\ngrid\n.\nsize\n());\n// Exposition: input size fits batch_sz * grid_size\nextern\n__shared__\nint\nshared\n[];\n// block.size() * sizeof(int) bytes\nfor\n(\nsize_t\nbatch\n=\n0\n;\nbatch\n<\nbatch_sz\n;\n++\nbatch\n)\n{\nsize_t\nblock_batch_idx\n=\nblock\n.\ngroup_index\n().\nx\n*\nblock\n.\nsize\n()\n+\ngrid\n.\nsize\n()\n*\nbatch\n;\n// Whole thread-group cooperatively copies whole batch to shared memory:\ncooperative_groups\n::\nmemcpy_async\n(\nblock\n,\nshared\n,\nglobal_in\n+\nblock_batch_idx\n,\nsizeof\n(\nint\n)\n*\nblock\n.\nsize\n());\ncooperative_groups\n::\nwait\n(\nblock\n);\n// Joins all threads, waits for all copies to complete\ncompute\n(\nglobal_out\n+\nblock_batch_idx\n,\nshared\n);\nblock\n.\nsync\n();\n}\n}}\n10.27.5.\nAsynchronous Data Copies using\ncuda::barrier\nï\nThe\ncuda::memcpy_async\noverload for\ncuda::barrier\nenables synchronizing asynchronous data transfers using a\nbarrier\n. This overloads executes the copy operation as-if performed by another thread bound to the barrier by: incrementing the expected count of the current phase on creation, and decrementing it on completion of the copy operation, such that the phase of the\nbarrier\nwill only advance when all threads participating in the barrier have arrived, and all\nmemcpy_async\nbound to the current phase of the barrier have completed. The following example uses a block-wide\nbarrier\n, where all block threads participate, and swaps the wait operation with a barrier\narrive_and_wait\n, while providing the same functionality as the previous example:\n#include\n<cooperative_groups.h>\n#include\n<cuda/barrier>\n__device__\nvoid\ncompute\n(\nint\n*\nglobal_out\n,\nint\nconst\n*\nshared_in\n);\n__global__\nvoid\nwith_barrier\n(\nint\n*\nglobal_out\n,\nint\nconst\n*\nglobal_in\n,\nsize_t\nsize\n,\nsize_t\nbatch_sz\n)\n{\nauto\ngrid\n=\ncooperative_groups\n::\nthis_grid\n();\nauto\nblock\n=\ncooperative_groups\n::\nthis_thread_block\n();\nassert\n(\nsize\n==\nbatch_sz\n*\ngrid\n.\nsize\n());\n// Assume input size fits batch_sz * grid_size\nextern\n__shared__\nint\nshared\n[];\n// block.size() * sizeof(int) bytes\n// Create a synchronization object (C++20 barrier)\n__shared__\ncuda\n::\nbarrier\n<\ncuda\n::\nthread_scope\n::\nthread_scope_block\n>\nbarrier\n;\nif\n(\nblock\n.\nthread_rank\n()\n==\n0\n)\n{\ninit\n(\n&\nbarrier\n,\nblock\n.\nsize\n());\n// Friend function initializes barrier\n}\nblock\n.\nsync\n();\nfor\n(\nsize_t\nbatch\n=\n0\n;\nbatch\n<\nbatch_sz\n;\n++\nbatch\n)\n{\nsize_t\nblock_batch_idx\n=\nblock\n.\ngroup_index\n().\nx\n*\nblock\n.\nsize\n()\n+\ngrid\n.\nsize\n()\n*\nbatch\n;\ncuda\n::\nmemcpy_async\n(\nblock\n,\nshared\n,\nglobal_in\n+\nblock_batch_idx\n,\nsizeof\n(\nint\n)\n*\nblock\n.\nsize\n(),\nbarrier\n);\nbarrier\n.\narrive_and_wait\n();\n// Waits for all copies to complete\ncompute\n(\nglobal_out\n+\nblock_batch_idx\n,\nshared\n);\nblock\n.\nsync\n();\n}\n}\n10.27.6.\nPerformance Guidance for\nmemcpy_async\nï\nFor compute capability 8.x, the pipeline mechanism is shared among CUDA threads in the same CUDA warp. This sharing causes batches of\nmemcpy_async\nto be entangled within a warp, which can impact performance under certain circumstances.\nThis section highlights the warp-entanglement effect on\ncommit\n,\nwait\n, and\narrive\noperations. Please refer to\nPipeline Interface\nand the\nPipeline Primitives Interface\nfor an overview of the individual operations.\n10.27.6.1.\nAlignment\nï\nOn devices with compute capability 8.0, the\ncp.async family of instructions\nallows copying data from global to shared memory asynchronously. These instructions support copying 4, 8, and 16 bytes at a time. If the size provided to\nmemcpy_async\nis a multiple of 4, 8, or 16, and both pointers passed to\nmemcpy_async\nare aligned to a 4, 8, or 16 alignment boundary, then\nmemcpy_async\ncan be implemented using exclusively asynchronous memory operations.\nAdditionally for achieving best performance when using\nmemcpy_async\nAPI, an alignment of 128 Bytes for both shared memory and global memory is required.\nFor pointers to values of types with an alignment requirement of 1 or 2, it is often not possible to prove that the pointers are always aligned to a higher alignment boundary. Determining whether the\ncp.async\ninstructions can or cannot be used must be delayed until run-time. Performing such a runtime alignment check increases code-size and adds runtime overhead.\nThe\ncuda::aligned_size_t<size_t Align>(size_t size)\nShape\ncan be used to supply a proof that both pointers passed to\nmemcpy_async\nare aligned to an\nAlign\nalignment boundary and that\nsize\nis a multiple of\nAlign\n, by passing it as an argument where the\nmemcpy_async\nAPIs expect a\nShape\n:\ncuda\n::\nmemcpy_async\n(\ngroup\n,\ndst\n,\nsrc\n,\ncuda\n::\naligned_size_t\n<\n16\n>\n(\nN\n*\nblock\n.\nsize\n()),\npipeline\n);\nIf the proof is incorrect, the behavior is undefined.\n10.27.6.2.\nTrivially copyable\nï\nOn devices with compute capability 8.0, the\ncp.async family of instructions\nallows copying data from global to shared memory asynchronously. If the pointer types passed to\nmemcpy_async\ndo not point to\nTriviallyCopyable\ntypes, the copy constructor of each output element needs to be invoked, and these instructions cannot be used to accelerate\nmemcpy_async\n.\n10.27.6.3.\nWarp Entanglement - Commit\nï\nThe sequence of\nmemcpy_async\nbatches is shared across the warp. The commit operation is coalesced such that the sequence is incremented once for all converged threads that invoke the commit operation. If the warp is fully converged, the sequence is incremented by one; if the warp is fully diverged, the sequence is incremented by 32.\nLet\nPB\nbe the warp-shared pipelineâs\nactual\nsequence of batches.\nPB\n=\n{BP0,\nBP1,\nBP2,\nâ¦,\nBPL}\nLet\nTB\nbe a threadâs\nperceived\nsequence of batches, as if the sequence were only incremented by this threadâs invocation of the commit operation.\nTB\n=\n{BT0,\nBT1,\nBT2,\nâ¦,\nBTL}\nThe\npipeline::producer_commit()\nreturn value is from the threadâs\nperceived\nbatch sequence.\nAn index in a threadâs perceived sequence always aligns to an equal or larger index in the actual warp-shared sequence. The sequences are equal only when all commit operations are invoked from converged threads.\nBTn\nâ¡\nBPm\nwhere\nn\n<=\nm\nFor example, when a warp is fully diverged:\nThe warp-shared pipelineâs actual sequence would be:\nPB\n=\n{0,\n1,\n2,\n3,\n...,\n31}\n(\nPL=31\n).\nThe perceived sequence for each thread of this warp would be:\nThread 0:\nTB\n=\n{0}\n(\nTL=0\n)\nThread 1:\nTB\n=\n{0}\n(\nTL=0\n)\nâ¦\nThread 31:\nTB\n=\n{0}\n(\nTL=0\n)\n10.27.6.4.\nWarp Entanglement - Wait\nï\nA CUDA thread invokes either\npipeline_consumer_wait_prior<N>()\nor\npipeline::consumer_wait()\nto wait for batches in the\nperceived\nsequence\nTB\nto complete. Note that\npipeline::consumer_wait()\nis equivalent to\npipeline_consumer_wait_prior<N>()\n, where\nN\n=\nPL\n.\nThe\npipeline_consumer_wait_prior<N>()\nfunction waits for batches in the\nactual\nsequence at least up to and including\nPL-N\n. Since\nTL\n<=\nPL\n, waiting for batch up to and including\nPL-N\nincludes waiting for batch\nTL-N\n. Thus, when\nTL\n<\nPL\n, the thread will unintentionally wait for additional, more recent batches.\nIn the extreme fully-diverged warp example above, each thread could wait for all 32 batches.\n10.27.6.5.\nWarp Entanglement - Arrive-On\nï\nWarp-divergence affects the number of times an\narrive_on(bar)\noperation updates the barrier. If the invoking warp is fully converged, then the barrier is updated once. If the invoking warp is fully diverged, then 32 individual updates are applied to the barrier.\n10.27.6.6.\nKeep Commit and Arrive-On Operations Converged\nï\nIt is recommended that commit and arrive-on invocations are by converged threads:\nto not over-wait, by keeping threadsâ perceived sequence of batches aligned with the actual sequence, and\nto minimize updates to the barrier object.\nWhen code preceding these operations diverges threads, then the warp should be re-converged, via\n__syncwarp\nbefore invoking commit or arrive-on operations.\n10.28.\nAsynchronous Data Copies using\ncuda::pipeline\nï\nCUDA provides the\ncuda::pipeline\nsynchronization object to manage and overlap asynchronous data movement with computation.\nThe API documentation for\ncuda::pipeline\nis provided in the\nlibcudacxx API\n. A pipeline object is a double-ended N stage queue with a\nhead\nand a\ntail\n, and is used to process work in a first-in first-out (FIFO) order. The pipeline object has following member functions to manage the stages of the pipeline.\nPipeline Class Member Function\nDescription\nproducer_acquire\nAcquires an available stage in the pipeline internal queue.\nproducer_commit\nCommits the asynchronous operations issued after the\nproducer_acquire\ncall on the currently acquired stage of the pipeline.\nconsumer_wait\nWait for completion of all asynchronous operations on the oldest stage of the pipeline.\nconsumer_release\nRelease the oldest stage of the pipeline to the pipeline object for reuse. The released stage can be then acquired by the producer.\n10.28.1.\nSingle-Stage Asynchronous Data Copies using\ncuda::pipeline\nï\nIn previous examples we showed how to use\ncooperative_groups\nand\ncuda::barrier\nto do asynchronous data transfers. In this section, we will use the\ncuda::pipeline\nAPI with a single stage to schedule asynchronous copies. And later we will expand this example to show multi staged overlapped compute and copy.\n#include\n<cooperative_groups/memcpy_async.h>\n#include\n<cuda/pipeline>\n__device__\nvoid\ncompute\n(\nint\n*\nglobal_out\n,\nint\nconst\n*\nshared_in\n);\n__global__\nvoid\nwith_single_stage\n(\nint\n*\nglobal_out\n,\nint\nconst\n*\nglobal_in\n,\nsize_t\nsize\n,\nsize_t\nbatch_sz\n)\n{\nauto\ngrid\n=\ncooperative_groups\n::\nthis_grid\n();\nauto\nblock\n=\ncooperative_groups\n::\nthis_thread_block\n();\nassert\n(\nsize\n==\nbatch_sz\n*\ngrid\n.\nsize\n());\n// Assume input size fits batch_sz * grid_size\nconstexpr\nsize_t\nstages_count\n=\n1\n;\n// Pipeline with one stage\n// One batch must fit in shared memory:\nextern\n__shared__\nint\nshared\n[];\n// block.size() * sizeof(int) bytes\n// Allocate shared storage for a single stage cuda::pipeline:\n__shared__\ncuda\n::\npipeline_shared_state\n<\ncuda\n::\nthread_scope\n::\nthread_scope_block\n,\nstages_count\n>\nshared_state\n;\nauto\npipeline\n=\ncuda\n::\nmake_pipeline\n(\nblock\n,\n&\nshared_state\n);\n// Each thread processes `batch_sz` elements.\n// Compute offset of the batch `batch` of this thread block in global memory:\nauto\nblock_batch\n=\n[\n&\n](\nsize_t\nbatch\n)\n->\nint\n{\nreturn\nblock\n.\ngroup_index\n().\nx\n*\nblock\n.\nsize\n()\n+\ngrid\n.\nsize\n()\n*\nbatch\n;\n};\nfor\n(\nsize_t\nbatch\n=\n0\n;\nbatch\n<\nbatch_sz\n;\n++\nbatch\n)\n{\nsize_t\nglobal_idx\n=\nblock_batch\n(\nbatch\n);\n// Collectively acquire the pipeline head stage from all producer threads:\npipeline\n.\nproducer_acquire\n();\n// Submit async copies to the pipeline's head stage to be\n// computed in the next loop iteration\ncuda\n::\nmemcpy_async\n(\nblock\n,\nshared\n,\nglobal_in\n+\nglobal_idx\n,\nsizeof\n(\nint\n)\n*\nblock\n.\nsize\n(),\npipeline\n);\n// Collectively commit (advance) the pipeline's head stage\npipeline\n.\nproducer_commit\n();\n// Collectively wait for the operations committed to the\n// previous `compute` stage to complete:\npipeline\n.\nconsumer_wait\n();\n// Computation overlapped with the memcpy_async of the \"copy\" stage:\ncompute\n(\nglobal_out\n+\nglobal_idx\n,\nshared\n);\n// Collectively release the stage resources\npipeline\n.\nconsumer_release\n();\n}\n}\n10.28.2.\nMulti-Stage Asynchronous Data Copies using\ncuda::pipeline\nï\nIn the previous examples with\ncooperative_groups::wait\nand\ncuda::barrier\n, the kernel threads immediately wait for the data transfer to shared memory to complete. This avoids data transfers from global memory into registers, but does not\nhide\nthe latency of the\nmemcpy_async\noperation by overlapping computation.\nFor that we use the CUDA\npipeline\nfeature in the following example. It provides a mechanism for managing a sequence of\nmemcpy_async\nbatches, enabling CUDA kernels to overlap memory transfers with computation. The following example implements a two-stage pipeline that overlaps data-transfer with computation. It:\nInitializes the pipeline shared state (more below)\nKickstarts the pipeline by scheduling a\nmemcpy_async\nfor the first batch.\nLoops over all the batches: it schedules\nmemcpy_async\nfor the next batch, blocks all threads on the completion of the\nmemcpy_async\nfor the previous batch, and then overlaps the computation on the previous batch with the asynchronous copy of the memory for the next batch.\nFinally, it drains the pipeline by performing the computation on the last batch.\nNote that, for interoperability with\ncuda::pipeline\n,\ncuda::memcpy_async\nfrom the\ncuda/pipeline\nheader is used here.\n#include\n<cooperative_groups/memcpy_async.h>\n#include\n<cuda/pipeline>\n__device__\nvoid\ncompute\n(\nint\n*\nglobal_out\n,\nint\nconst\n*\nshared_in\n);\n__global__\nvoid\nwith_staging\n(\nint\n*\nglobal_out\n,\nint\nconst\n*\nglobal_in\n,\nsize_t\nsize\n,\nsize_t\nbatch_sz\n)\n{\nauto\ngrid\n=\ncooperative_groups\n::\nthis_grid\n();\nauto\nblock\n=\ncooperative_groups\n::\nthis_thread_block\n();\nassert\n(\nsize\n==\nbatch_sz\n*\ngrid\n.\nsize\n());\n// Assume input size fits batch_sz * grid_size\nconstexpr\nsize_t\nstages_count\n=\n2\n;\n// Pipeline with two stages\n// Two batches must fit in shared memory:\nextern\n__shared__\nint\nshared\n[];\n// stages_count * block.size() * sizeof(int) bytes\nsize_t\nshared_offset\n[\nstages_count\n]\n=\n{\n0\n,\nblock\n.\nsize\n()\n};\n// Offsets to each batch\n// Allocate shared storage for a two-stage cuda::pipeline:\n__shared__\ncuda\n::\npipeline_shared_state\n<\ncuda\n::\nthread_scope\n::\nthread_scope_block\n,\nstages_count\n>\nshared_state\n;\nauto\npipeline\n=\ncuda\n::\nmake_pipeline\n(\nblock\n,\n&\nshared_state\n);\n// Each thread processes `batch_sz` elements.\n// Compute offset of the batch `batch` of this thread block in global memory:\nauto\nblock_batch\n=\n[\n&\n](\nsize_t\nbatch\n)\n->\nint\n{\nreturn\nblock\n.\ngroup_index\n().\nx\n*\nblock\n.\nsize\n()\n+\ngrid\n.\nsize\n()\n*\nbatch\n;\n};\n// Initialize first pipeline stage by submitting a `memcpy_async` to fetch a whole batch for the block:\nif\n(\nbatch_sz\n==\n0\n)\nreturn\n;\npipeline\n.\nproducer_acquire\n();\ncuda\n::\nmemcpy_async\n(\nblock\n,\nshared\n+\nshared_offset\n[\n0\n],\nglobal_in\n+\nblock_batch\n(\n0\n),\nsizeof\n(\nint\n)\n*\nblock\n.\nsize\n(),\npipeline\n);\npipeline\n.\nproducer_commit\n();\n// Pipelined copy/compute:\nfor\n(\nsize_t\nbatch\n=\n1\n;\nbatch\n<\nbatch_sz\n;\n++\nbatch\n)\n{\n// Stage indices for the compute and copy stages:\nsize_t\ncompute_stage_idx\n=\n(\nbatch\n-\n1\n)\n%\n2\n;\nsize_t\ncopy_stage_idx\n=\nbatch\n%\n2\n;\nsize_t\nglobal_idx\n=\nblock_batch\n(\nbatch\n);\n// Collectively acquire the pipeline head stage from all producer threads:\npipeline\n.\nproducer_acquire\n();\n// Submit async copies to the pipeline's head stage to be\n// computed in the next loop iteration\ncuda\n::\nmemcpy_async\n(\nblock\n,\nshared\n+\nshared_offset\n[\ncopy_stage_idx\n],\nglobal_in\n+\nglobal_idx\n,\nsizeof\n(\nint\n)\n*\nblock\n.\nsize\n(),\npipeline\n);\n// Collectively commit (advance) the pipeline's head stage\npipeline\n.\nproducer_commit\n();\n// Collectively wait for the operations committed to the\n// previous `compute` stage to complete:\npipeline\n.\nconsumer_wait\n();\n// Computation overlapped with the memcpy_async of the \"copy\" stage:\ncompute\n(\nglobal_out\n+\nglobal_idx\n,\nshared\n+\nshared_offset\n[\ncompute_stage_idx\n]);\n// Collectively release the stage resources\npipeline\n.\nconsumer_release\n();\n}\n// Compute the data fetch by the last iteration\npipeline\n.\nconsumer_wait\n();\ncompute\n(\nglobal_out\n+\nblock_batch\n(\nbatch_sz\n-1\n),\nshared\n+\nshared_offset\n[(\nbatch_sz\n-\n1\n)\n%\n2\n]);\npipeline\n.\nconsumer_release\n();\n}\nA\npipeline object\nis a double-ended queue with a\nhead\nand a\ntail\n, and is used to process work in a first-in first-out (FIFO) order. Producer threads commit work to the pipelineâs head, while consumer threads pull work from the pipelineâs tail. In the example above, all threads are both producer and consumer threads. The threads first\ncommit\nmemcpy_async\noperations to fetch the\nnext\nbatch while they\nwait\non the\nprevious\nbatch of\nmemcpy_async\noperations to complete.\nCommitting work to a pipeline stage involves:\nCollectively\nacquiring\nthe pipeline\nhead\nfrom a set of producer threads using\npipeline.producer_acquire()\n.\nSubmitting\nmemcpy_async\noperations to the pipeline head.\nCollectively\ncommitting\n(advancing) the pipeline head using\npipeline.producer_commit()\n.\nUsing a previously commited stage involves:\nCollectively waiting for the stage to complete, e.g., using\npipeline.consumer_wait()\nto wait on the tail (oldest) stage.\nCollectively\nreleasing\nthe stage using\npipeline.consumer_release()\n.\ncuda::pipeline_shared_state<scope,\ncount>\nencapsulates the finite resources that allow a pipeline to process up to\ncount\nconcurrent stages. If all resources are in use,\npipeline.producer_acquire()\nblocks producer threads until the resources of the next pipeline stage are released by consumer threads.\nThis example can be written in a more concise manner by merging the prolog and epilog of the loop with the loop itself as follows:\ntemplate\n<\nsize_t\nstages_count\n=\n2\n/* Pipeline with stages_count stages */\n>\n__global__\nvoid\nwith_staging_unified\n(\nint\n*\nglobal_out\n,\nint\nconst\n*\nglobal_in\n,\nsize_t\nsize\n,\nsize_t\nbatch_sz\n)\n{\nauto\ngrid\n=\ncooperative_groups\n::\nthis_grid\n();\nauto\nblock\n=\ncooperative_groups\n::\nthis_thread_block\n();\nassert\n(\nsize\n==\nbatch_sz\n*\ngrid\n.\nsize\n());\n// Assume input size fits batch_sz * grid_size\nextern\n__shared__\nint\nshared\n[];\n// stages_count * block.size() * sizeof(int) bytes\nsize_t\nshared_offset\n[\nstages_count\n];\nfor\n(\nint\ns\n=\n0\n;\ns\n<\nstages_count\n;\n++\ns\n)\nshared_offset\n[\ns\n]\n=\ns\n*\nblock\n.\nsize\n();\n__shared__\ncuda\n::\npipeline_shared_state\n<\ncuda\n::\nthread_scope\n::\nthread_scope_block\n,\nstages_count\n>\nshared_state\n;\nauto\npipeline\n=\ncuda\n::\nmake_pipeline\n(\nblock\n,\n&\nshared_state\n);\nauto\nblock_batch\n=\n[\n&\n](\nsize_t\nbatch\n)\n->\nint\n{\nreturn\nblock\n.\ngroup_index\n().\nx\n*\nblock\n.\nsize\n()\n+\ngrid\n.\nsize\n()\n*\nbatch\n;\n};\n// compute_batch: next batch to process\n// fetch_batch:  next batch to fetch from global memory\nfor\n(\nsize_t\ncompute_batch\n=\n0\n,\nfetch_batch\n=\n0\n;\ncompute_batch\n<\nbatch_sz\n;\n++\ncompute_batch\n)\n{\n// The outer loop iterates over the computation of the batches\nfor\n(;\nfetch_batch\n<\nbatch_sz\n&&\nfetch_batch\n<\n(\ncompute_batch\n+\nstages_count\n);\n++\nfetch_batch\n)\n{\n// This inner loop iterates over the memory transfers, making sure that the pipeline is always full\npipeline\n.\nproducer_acquire\n();\nsize_t\nshared_idx\n=\nfetch_batch\n%\nstages_count\n;\nsize_t\nbatch_idx\n=\nfetch_batch\n;\nsize_t\nblock_batch_idx\n=\nblock_batch\n(\nbatch_idx\n);\ncuda\n::\nmemcpy_async\n(\nblock\n,\nshared\n+\nshared_offset\n[\nshared_idx\n],\nglobal_in\n+\nblock_batch_idx\n,\nsizeof\n(\nint\n)\n*\nblock\n.\nsize\n(),\npipeline\n);\npipeline\n.\nproducer_commit\n();\n}\npipeline\n.\nconsumer_wait\n();\nint\nshared_idx\n=\ncompute_batch\n%\nstages_count\n;\nint\nbatch_idx\n=\ncompute_batch\n;\ncompute\n(\nglobal_out\n+\nblock_batch\n(\nbatch_idx\n),\nshared\n+\nshared_offset\n[\nshared_idx\n]);\npipeline\n.\nconsumer_release\n();\n}\n}\nThe\npipeline<thread_scope_block>\nprimitive used above is very flexible, and supports two features that our examples above are not using: any arbitrary subset of threads in the block can participate in the\npipeline\n, and from the threads that participate, any subsets can be producers, consumers, or both. In the following example, threads with an âevenâ thread rank are producers, while other threads are consumers:\n__device__\nvoid\ncompute\n(\nint\n*\nglobal_out\n,\nint\nshared_in\n);\ntemplate\n<\nsize_t\nstages_count\n=\n2\n>\n__global__\nvoid\nwith_specialized_staging_unified\n(\nint\n*\nglobal_out\n,\nint\nconst\n*\nglobal_in\n,\nsize_t\nsize\n,\nsize_t\nbatch_sz\n)\n{\nauto\ngrid\n=\ncooperative_groups\n::\nthis_grid\n();\nauto\nblock\n=\ncooperative_groups\n::\nthis_thread_block\n();\n// In this example, threads with \"even\" thread rank are producers, while threads with \"odd\" thread rank are consumers:\nconst\ncuda\n::\npipeline_role\nthread_role\n=\nblock\n.\nthread_rank\n()\n%\n2\n==\n0\n?\ncuda\n::\npipeline_role\n::\nproducer\n:\ncuda\n::\npipeline_role\n::\nconsumer\n;\n// Each thread block only has half of its threads as producers:\nauto\nproducer_threads\n=\nblock\n.\nsize\n()\n/\n2\n;\n// Map adjacent even and odd threads to the same id:\nconst\nint\nthread_idx\n=\nblock\n.\nthread_rank\n()\n/\n2\n;\nauto\nelements_per_batch\n=\nsize\n/\nbatch_sz\n;\nauto\nelements_per_batch_per_block\n=\nelements_per_batch\n/\ngrid\n.\ngroup_dim\n().\nx\n;\nextern\n__shared__\nint\nshared\n[];\n// stages_count * elements_per_batch_per_block * sizeof(int) bytes\nsize_t\nshared_offset\n[\nstages_count\n];\nfor\n(\nint\ns\n=\n0\n;\ns\n<\nstages_count\n;\n++\ns\n)\nshared_offset\n[\ns\n]\n=\ns\n*\nelements_per_batch_per_block\n;\n__shared__\ncuda\n::\npipeline_shared_state\n<\ncuda\n::\nthread_scope\n::\nthread_scope_block\n,\nstages_count\n>\nshared_state\n;\ncuda\n::\npipeline\npipeline\n=\ncuda\n::\nmake_pipeline\n(\nblock\n,\n&\nshared_state\n,\nthread_role\n);\n// Each thread block processes `batch_sz` batches.\n// Compute offset of the batch `batch` of this thread block in global memory:\nauto\nblock_batch\n=\n[\n&\n](\nsize_t\nbatch\n)\n->\nint\n{\nreturn\nelements_per_batch\n*\nbatch\n+\nelements_per_batch_per_block\n*\nblockIdx\n.\nx\n;\n};\nfor\n(\nsize_t\ncompute_batch\n=\n0\n,\nfetch_batch\n=\n0\n;\ncompute_batch\n<\nbatch_sz\n;\n++\ncompute_batch\n)\n{\n// The outer loop iterates over the computation of the batches\nfor\n(;\nfetch_batch\n<\nbatch_sz\n&&\nfetch_batch\n<\n(\ncompute_batch\n+\nstages_count\n);\n++\nfetch_batch\n)\n{\n// This inner loop iterates over the memory transfers, making sure that the pipeline is always full\nif\n(\nthread_role\n==\ncuda\n::\npipeline_role\n::\nproducer\n)\n{\n// Only the producer threads schedule asynchronous memcpys:\npipeline\n.\nproducer_acquire\n();\nsize_t\nshared_idx\n=\nfetch_batch\n%\nstages_count\n;\nsize_t\nbatch_idx\n=\nfetch_batch\n;\nsize_t\nglobal_batch_idx\n=\nblock_batch\n(\nbatch_idx\n)\n+\nthread_idx\n;\nsize_t\nshared_batch_idx\n=\nshared_offset\n[\nshared_idx\n]\n+\nthread_idx\n;\ncuda\n::\nmemcpy_async\n(\nshared\n+\nshared_batch_idx\n,\nglobal_in\n+\nglobal_batch_idx\n,\nsizeof\n(\nint\n),\npipeline\n);\npipeline\n.\nproducer_commit\n();\n}\n}\nif\n(\nthread_role\n==\ncuda\n::\npipeline_role\n::\nconsumer\n)\n{\n// Only the consumer threads compute:\npipeline\n.\nconsumer_wait\n();\nsize_t\nshared_idx\n=\ncompute_batch\n%\nstages_count\n;\nsize_t\nglobal_batch_idx\n=\nblock_batch\n(\ncompute_batch\n)\n+\nthread_idx\n;\nsize_t\nshared_batch_idx\n=\nshared_offset\n[\nshared_idx\n]\n+\nthread_idx\n;\ncompute\n(\nglobal_out\n+\nglobal_batch_idx\n,\n*\n(\nshared\n+\nshared_batch_idx\n));\npipeline\n.\nconsumer_release\n();\n}\n}\n}\nThere are some optimizations that\npipeline\nperforms, for example, when all threads are both producers and consumers, but in general, the cost of supporting all these features cannot be fully eliminated. For example,\npipeline\nstores and uses a set of barriers in shared memory for synchronization, which is not really necessary if all threads in the block participate in the pipeline.\nFor the particular case in which all threads in the block participate in the\npipeline\n, we can do better than\npipeline<thread_scope_block>\nby using a\npipeline<thread_scope_thread>\ncombined with\n__syncthreads()\n:\ntemplate\n<\nsize_t\nstages_count\n>\n__global__\nvoid\nwith_staging_scope_thread\n(\nint\n*\nglobal_out\n,\nint\nconst\n*\nglobal_in\n,\nsize_t\nsize\n,\nsize_t\nbatch_sz\n)\n{\nauto\ngrid\n=\ncooperative_groups\n::\nthis_grid\n();\nauto\nblock\n=\ncooperative_groups\n::\nthis_thread_block\n();\nauto\nthread\n=\ncooperative_groups\n::\nthis_thread\n();\nassert\n(\nsize\n==\nbatch_sz\n*\ngrid\n.\nsize\n());\n// Assume input size fits batch_sz * grid_size\nextern\n__shared__\nint\nshared\n[];\n// stages_count * block.size() * sizeof(int) bytes\nsize_t\nshared_offset\n[\nstages_count\n];\nfor\n(\nint\ns\n=\n0\n;\ns\n<\nstages_count\n;\n++\ns\n)\nshared_offset\n[\ns\n]\n=\ns\n*\nblock\n.\nsize\n();\n// No pipeline::shared_state needed\ncuda\n::\npipeline\n<\ncuda\n::\nthread_scope_thread\n>\npipeline\n=\ncuda\n::\nmake_pipeline\n();\nauto\nblock_batch\n=\n[\n&\n](\nsize_t\nbatch\n)\n->\nint\n{\nreturn\nblock\n.\ngroup_index\n().\nx\n*\nblock\n.\nsize\n()\n+\ngrid\n.\nsize\n()\n*\nbatch\n;\n};\nfor\n(\nsize_t\ncompute_batch\n=\n0\n,\nfetch_batch\n=\n0\n;\ncompute_batch\n<\nbatch_sz\n;\n++\ncompute_batch\n)\n{\nfor\n(;\nfetch_batch\n<\nbatch_sz\n&&\nfetch_batch\n<\n(\ncompute_batch\n+\nstages_count\n);\n++\nfetch_batch\n)\n{\npipeline\n.\nproducer_acquire\n();\nsize_t\nshared_idx\n=\nfetch_batch\n%\nstages_count\n;\nsize_t\nbatch_idx\n=\nfetch_batch\n;\n// Each thread fetches its own data:\nsize_t\nthread_batch_idx\n=\nblock_batch\n(\nbatch_idx\n)\n+\nthreadIdx\n.\nx\n;\n// The copy is performed by a single `thread` and the size of the batch is now that of a single element:\ncuda\n::\nmemcpy_async\n(\nthread\n,\nshared\n+\nshared_offset\n[\nshared_idx\n]\n+\nthreadIdx\n.\nx\n,\nglobal_in\n+\nthread_batch_idx\n,\nsizeof\n(\nint\n),\npipeline\n);\npipeline\n.\nproducer_commit\n();\n}\npipeline\n.\nconsumer_wait\n();\nblock\n.\nsync\n();\n// __syncthreads: All memcpy_async of all threads in the block for this stage have completed here\nint\nshared_idx\n=\ncompute_batch\n%\nstages_count\n;\nint\nbatch_idx\n=\ncompute_batch\n;\ncompute\n(\nglobal_out\n+\nblock_batch\n(\nbatch_idx\n),\nshared\n+\nshared_offset\n[\nshared_idx\n]);\npipeline\n.\nconsumer_release\n();\n}\n}\nIf the\ncompute\noperation only reads shared memory written to by other threads in the same warp as the current thread,\n__syncwarp()\nsuffices.\n10.28.3.\nPipeline Interface\nï\nThe complete API documentation for\ncuda::memcpy_async\nis provided in the\nlibcudacxx API\ndocumentation along with some examples.\nThe\npipeline\ninterface requires\nat least CUDA 11.0,\nat least ISO C++ 2011 compatibility, e.g., to be compiled with\n-std=c++11\n, and\n#include\n<cuda/pipeline>\n.\nFor a C-like interface, when compiling without ISO C++ 2011 compatibility, see\nPipeline Primitives Interface\n.\n10.28.4.\nPipeline Primitives Interface\nï\nPipeline primitives are a C-like interface for\nmemcpy_async\nfunctionality. The pipeline primitives interface is available by including the\n<cuda_pipeline.h>\nheader. When compiling without ISO C++ 2011 compatibility, include the\n<cuda_pipeline_primitives.h>\nheader.\n10.28.4.1.\nmemcpy_async\nPrimitive\nï\nvoid\n__pipeline_memcpy_async\n(\nvoid\n*\n__restrict__\ndst_shared\n,\nconst\nvoid\n*\n__restrict__\nsrc_global\n,\nsize_t\nsize_and_align\n,\nsize_t\nzfill\n=\n0\n);\nRequest that the following operation be submitted for asynchronous evaluation:\nsize_t\ni\n=\n0\n;\nfor\n(;\ni\n<\nsize_and_align\n-\nzfill\n;\n++\ni\n)\n((\nchar\n*\n)\ndst_shared\n)[\ni\n]\n=\n((\nchar\n*\n)\nsrc_global\n)[\ni\n];\n/* copy */\nfor\n(;\ni\n<\nsize_and_align\n;\n++\ni\n)\n((\nchar\n*\n)\ndst_shared\n)[\ni\n]\n=\n0\n;\n/* zero-fill */\nRequirements:\ndst_shared\nmust be a pointer to the shared memory destination for the\nmemcpy_async\n.\nsrc_global\nmust be a pointer to the global memory source for the\nmemcpy_async\n.\nsize_and_align\nmust be 4, 8, or 16.\nzfill\n<=\nsize_and_align\n.\nsize_and_align\nmust be the alignment of\ndst_shared\nand\nsrc_global\n.\nIt is a race condition for any thread to modify the source memory or observe the destination memory prior to waiting for the\nmemcpy_async\noperation to complete. Between submitting a\nmemcpy_async\noperation and waiting for its completion, any of the following actions introduces a race condition:\nLoading from\ndst_shared\n.\nStoring to\ndst_shared\nor\nsrc_global\n.\nApplying an atomic update to\ndst_shared\nor\nsrc_global\n.\n10.28.4.2.\nCommit Primitive\nï\nvoid\n__pipeline_commit\n();\nCommit submitted\nmemcpy_async\nto the pipeline as the current batch.\n10.28.4.3.\nWait Primitive\nï\nvoid\n__pipeline_wait_prior\n(\nsize_t\nN\n);\nLet\n{0,\n1,\n2,\n...,\nL}\nbe the sequence of indices associated with invocations of\n__pipeline_commit()\nby a given thread.\nWait for completion of batches\nat least\nup to and including\nL-N\n.\n10.28.4.4.\nArrive On Barrier Primitive\nï\nvoid\n__pipeline_arrive_on\n(\n__mbarrier_t\n*\nbar\n);\nbar\npoints to a barrier in shared memory.\nIncrements the barrier arrival count by one, when all memcpy_async operations sequenced before this call have completed, the arrival count is decremented by one and hence the net effect on the arrival count is zero. It is userâs responsibility to make sure that the increment on the arrival count does not exceed\n__mbarrier_maximum_count()\n.\n10.29.\nAsynchronous Data Copies using the Tensor Memory Accelerator (TMA)\nï\nMany applications require movement of large amounts of data from and to global\nmemory. Often, the data is laid out in global memory as a multi-dimensional\narray with non-sequential data acess patterns. To reduce global memory usage,\nsub-tiles of such arrays are copied to shared memory before use in computations.\nThe loading and storing involves address-calculations that can be error-prone\nand repetitive. To offload these computations, Compute Capability 9.0 introduces the\nTensor Memory Accelerator (TMA). The primary goal of TMA is to provide an efficient\ndata transfer mechanism from global memory to shared memory for\nmulti-dimensional arrays.\nNaming\n. Tensor memory accelerator (TMA) is a broad term used to refer to the\nfeatures described in this section. For the purpose of forward-compatibility and\nto reduce discrepancies with the PTX ISA, the text in this section refers to TMA\noperations as either bulk-asynchronous copies or bulk tensor asynchronous\ncopies, depending on the specific type of copy used. The term âbulkâ is used to\ncontrast these operations with the asynchronous memory operations described in\nthe previous sections.\nDimensions\n. TMA supports copying both one-dimensional and multi-dimensional\narrays (up to 5-dimensional). The programming model for\nbulk-asynchronous\ncopies\nof one-dimensional contiguous arrays is different from the programming\nmodel for\nbulk tensor asynchronous copies\nof multi-dimensional arrays. To\nperform a bulk tensor asynchronous copy of a multi-dimensional array, the\nhardware requires a\ntensor map\n.\nThis object describes the layout of the multi-dimensional array in global and\nshared memory. A tensor map is typically created on the host using the\ncuTensorMapEncode\nAPI\nand then transferred from host to device as a\nconst\nkernel parameter annotated\nwith\n__grid_constant__\n.\nThe tensor map is transferred from host to device as a\nconst\nkernel\nparameter annotated with\n__grid_constant__\n, and can be used on the device to\ncopy a tile of data between shared and global memory. In contrast, performing a\nbulk-asynchronous copy of a contiguous one-dimensional array does not require a\ntensor map: it can be performed on-device with a pointer and size parameter.\nSource and destination\n. The source and destination addresses of bulk-asynchronous copy\noperations can be in shared or global memory. The operations can read data from global to\nshared memory, write data from shared to global memory, and also copy from\nshared memory to\nDistributed Shared Memory\nof another block in the same cluster.\nIn addition, when in a cluster, a bulk-asynchronous operation can be specified as being\nmulticast. In this case, data can be transferred from global memory to the\nshared memory of multiple blocks within the cluster. The multicast feature is\noptimized for target architecture\nsm_90a\nand may have\nsignificantly reduced performance\non\nother targets. Hence, it is advised to be used with\ncompute architecture\nsm_90a\n.\nAsynchronous\n. Data transfers using TMA are\nasynchronous\n. This allows the initiating\nthread to continue computing while the hardware asynchronously copies the data.\nWhether the data transfer occurs asynchronously in practice is up to the hardware implementation and may change in the future\n.\nThere are several\ncompletion mechanisms\nthat bulk-asynchronous operations can use to signal that they have completed.\nWhen the operation reads from global to shared memory, any\nthread in the block can wait for the data to be readable in shared memory by\nwaiting on a\nShared Memory Barrier\n. When the bulk-asynchronous\noperation writes data from shared memory to global or distributed shared memory,\nonly the initiating thread can wait for the operation to have completed.\nThis is accomplished using a\nbulk async-group\nbased completion mechanism. A\ntable describing the completion mechanisms can be found below and in the\nPTX ISA\n.\nTable 8\nAsynchronous copies with possible source and destinations memory spaces and completion mechanisms. An empty cell indicates that a source-destination pair is not supported.\nï\nDirection\nCompletion mechanism\nDestination\nSource\nAsynchronous copy\nBulk-asynchronous copy (TMA)\nGlobal\nGlobal\nGlobal\nShared::cta\nBulk async-group\nShared::cta\nGlobal\nAsync-group, mbarrier\nMbarrier\nShared::cluster\nGlobal\nMbarrier (multicast)\nShared::cta\nShared::cluster\nMbarrier\nShared::cta\nShared::cta\n10.29.1.\nUsing TMA to transfer one-dimensional arrays\nï\nThis section demonstrates how to write a simple kernel that read-modify-writes a\none-dimensional array using TMA. This shows how to how to load and store data\nusing bulk-asynchronous copies, as well as how to synchronize threads of\nexecution with those copies.\nThe code of the kernel is included below. Some functionality requires inline PTX\nassembly that is currently made available through\nlibcu++\n.\nThe availability of these wrappers can be\nchecked with the following code:\n#if defined(__CUDA_MINIMUM_ARCH__) && __CUDA_MINIMUM_ARCH__ < 900\nstatic_assert\n(\nfalse\n,\n\"Device code is being compiled with older architectures that are incompatible with TMA.\"\n);\n#endif\n// __CUDA_MINIMUM_ARCH__\nThe kernel goes through the following stages:\nInitialize shared memory barrier.\nInitiate bulk-asynchronous copy of a block of memory from global to shared memory.\nArrive and wait on the shared memory barrier.\nIncrement the shared memory buffer values.\nWait for shared memory writes to be visible to the subsequent bulk-asynchronous copy, i.e., order the shared memory writes in the\nasync proxy\nbefore the next step.\nInitiate bulk-asynchronous copy of the buffer in shared memory to global memory.\nWait at end of kernel for bulk-asynchronous copy to have finished reading shared memory.\n#include\n<cuda/barrier>\n#include\n<cuda/ptx>\nusing\nbarrier\n=\ncuda\n::\nbarrier\n<\ncuda\n::\nthread_scope_block\n>\n;\nnamespace\nptx\n=\ncuda\n::\nptx\n;\nstatic\nconstexpr\nsize_t\nbuf_len\n=\n1024\n;\n__global__\nvoid\nadd_one_kernel\n(\nint\n*\ndata\n,\nsize_t\noffset\n)\n{\n// Shared memory buffer. The destination shared memory buffer of\n// a bulk operations should be 16 byte aligned.\n__shared__\nalignas\n(\n16\n)\nint\nsmem_data\n[\nbuf_len\n];\n// 1. a) Initialize shared memory barrier with the number of threads participating in the barrier.\n//    b) Make initialized barrier visible in async proxy.\n#pragma nv_diag_suppress static_var_with_dynamic_init\n__shared__\nbarrier\nbar\n;\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\ninit\n(\n&\nbar\n,\nblockDim\n.\nx\n);\n// a)\nptx\n::\nfence_proxy_async\n(\nptx\n::\nspace_shared\n);\n// b)\n}\n__syncthreads\n();\n// 2. Initiate TMA transfer to copy global to shared memory.\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\n// 3a. cuda::memcpy_async arrives on the barrier and communicates\n//     how many bytes are expected to come in (the transaction count)\ncuda\n::\nmemcpy_async\n(\nsmem_data\n,\ndata\n+\noffset\n,\ncuda\n::\naligned_size_t\n<\n16\n>\n(\nsizeof\n(\nsmem_data\n)),\nbar\n);\n}\n// 3b. All threads arrive on the barrier\nbarrier\n::\narrival_token\ntoken\n=\nbar\n.\narrive\n();\n// 3c. Wait for the data to have arrived.\nbar\n.\nwait\n(\nstd\n::\nmove\n(\ntoken\n));\n// 4. Compute saxpy and write back to shared memory\nfor\n(\nint\ni\n=\nthreadIdx\n.\nx\n;\ni\n<\nbuf_len\n;\ni\n+=\nblockDim\n.\nx\n)\n{\nsmem_data\n[\ni\n]\n+=\n1\n;\n}\n// 5. Wait for shared memory writes to be visible to TMA engine.\nptx\n::\nfence_proxy_async\n(\nptx\n::\nspace_shared\n);\n// b)\n__syncthreads\n();\n// After syncthreads, writes by all threads are visible to TMA engine.\n// 6. Initiate TMA transfer to copy shared memory to global memory\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\nptx\n::\ncp_async_bulk\n(\nptx\n::\nspace_global\n,\nptx\n::\nspace_shared\n,\ndata\n+\noffset\n,\nsmem_data\n,\nsizeof\n(\nsmem_data\n));\n// 7. Wait for TMA transfer to have finished reading shared memory.\n// Create a \"bulk async-group\" out of the previous bulk copy operation.\nptx\n::\ncp_async_bulk_commit_group\n();\n// Wait for the group to have completed reading from shared memory.\nptx\n::\ncp_async_bulk_wait_group_read\n(\nptx\n::\nn32_t\n<\n0\n>\n());\n}\n}\nBarrier initialization\n. The barrier is initialized with the number of\nthreads participating in the block. As a result, the barrier will flip only if\nall threads have arrived on this barrier. Shared memory barriers are described\nin more detail in\nAsynchronous Data Copies using cuda::barrier\n.\nTo make the initialized barrier visible to subsequent bulk-asynchronous copies, the\nfence.proxy.async.shared::cta\ninstruction is used. This instruction ensures that\nsubsequent bulk-asynchronous copy operations operate on the initialized barrier.\nTMA read\n. The bulk-asynchronous copy instruction directs the\nhardware to copy a large chunk of data into shared memory, and to update the\ntransaction count\nof the shared memory barrier after completing the read. In general, issuing as\nfew bulk copies with as big a size as possible results in the best performance.\nBecause the copy can be performed asynchronously by the hardware, it is not\nnecessary to split the copy into smaller chunks.\nThe thread that initiates the bulk-asynchronous copy operation arrives at the barrier\nusing\nmbarrier.expect_tx\n. This is automatically performed by\ncuda::memcpy_async\n. This tells the barrier that the thread has\narrived and also how many bytes (tx / transactions) are expected to arrive. Only\na single thread has to update the expected transaction count. If multiple\nthreads update the transaction count, the expected transaction will be the sum\nof the updates. The barrier will only flip once all threads have arrived\nand\nall bytes have arrived. Once the barrier has flipped, the bytes are safe to read\nfrom shared memory, both by the threads as well as by subsequent\nbulk-asynchronous copies. More information about barrier transaction accounting\ncan be found in the\nPTX ISA\n.\nBarrier wait\n. Waiting for the barrier to flip is done using\nmbarrier.try_wait\n. It can either return true, indicating that the wait is\nover, or return false, which may mean that the wait timed out. The while loop\nwaits for completion, and retries on time-out.\nSMEM write and sync\n. The increment of the buffer values reads and writes to shared\nmemory. To make the writes visible to subsequent bulk-asynchronous copies, the\nfence.proxy.async.shared::cta\ninstruction is used. This orders the writes to\nshared memory before subsequent reads from bulk-asynchronous copy operations,\nwhich read through the async proxy. So each thread first orders the writes to\nobjects in shared memory in the async proxy via the\nfence.proxy.async.shared::cta\n, and these operations by all threads are\nordered before the async operation performed in thread 0 using\n__syncthreads()\n.\nTMA write and sync\n. The write from shared to global memory is again\ninitiated by a single thread. The completion of the write is not tracked by a\nshared memory barrier. Instead, a thread-local mechanism is used. Multiple\nwrites can be batched into a so-called\nbulk async-group\n. Afterwards, the\nthread can wait for all operations in this group to have completed reading from\nshared memory (as in the code above) or to have completed writing to global\nmemory, making the writes visible to the initiating thread. For more information,\nrefer to the PTX ISA documentation of\ncp.async.bulk.wait_group\n.\nNote that the bulk-asynchronous and non-bulk asynchronous copy instructions have\ndifferent async-groups: there exist both\ncp.async.wait_group\nand\ncp.async.bulk.wait_group\ninstructions.\nThe bulk-asynchronous instructions have specific alignment requirements on their source and\ndestination addresses. More information can be found in the table below.\nTable 9\nAlignment requirements for one-dimensional bulk-asynchronous operations in Compute Capability 9.0.\nï\nAddress / Size\nAlignment\nGlobal memory address\nMust be 16 byte aligned.\nShared memory address\nMust be 16 byte aligned.\nShared memory barrier address\nMust be 8 byte aligned (this is guaranteed by\ncuda::barrier\n).\nSize of transfer\nMust be a multiple of 16 bytes.\n10.29.2.\nUsing TMA to transfer multi-dimensional arrays\nï\nThe primary difference between the one-dimensional and multi-dimensional case is\nthat a tensor map must be created on the host and passed to the CUDA kernel.\nThis section describes how to create a tensor map using the CUDA driver API, how\nto pass it to device, and how to use it on device.\nDriver API\n. A tensor map is created using the\ncuTensorMapEncodeTiled\ndriver API. This API can be accessed by linking to the driver directly\n(\n-lcuda\n) or by using the\ncudaGetDriverEntryPointByVersion\nAPI. Below, we show how to get a pointer to the\ncuTensorMapEncodeTiled\nAPI.\nFor more information, refer to\nDriver Entry Point Access\n.\n#include\n<cudaTypedefs.h>\n// PFN_cuTensorMapEncodeTiled, CUtensorMap\nPFN_cuTensorMapEncodeTiled_v12000\nget_cuTensorMapEncodeTiled\n()\n{\n// Get pointer to cuTensorMapEncodeTiled\ncudaDriverEntryPointQueryResult\ndriver_status\n;\nvoid\n*\ncuTensorMapEncodeTiled_ptr\n=\nnullptr\n;\nCUDA_CHECK\n(\ncudaGetDriverEntryPointByVersion\n(\n\"cuTensorMapEncodeTiled\"\n,\n&\ncuTensorMapEncodeTiled_ptr\n,\n12000\n,\ncudaEnableDefault\n,\n&\ndriver_status\n));\nassert\n(\ndriver_status\n==\ncudaDriverEntryPointSuccess\n);\nreturn\nreinterpret_cast\n<\nPFN_cuTensorMapEncodeTiled_v12000\n>\n(\ncuTensorMapEncodeTiled_ptr\n);\n}\nCreation\n. Creating a tensor map requires many parameters. Among\nthem are the base pointer to an array in global memory, the size of the array\n(in number of elements), the stride from one row to the next (in bytes), the\nsize of the shared memory buffer (in number of elements). The code below creates\na tensor map to describe a two-dimensional row-major array of size\nGMEM_HEIGHT\nx\nGMEM_WIDTH\n. Note the order of the parameters: the fastest moving dimension\ncomes first.\nCUtensorMap\ntensor_map\n{};\n// rank is the number of dimensions of the array.\nconstexpr\nuint32_t\nrank\n=\n2\n;\nuint64_t\nsize\n[\nrank\n]\n=\n{\nGMEM_WIDTH\n,\nGMEM_HEIGHT\n};\n// The stride is the number of bytes to traverse from the first element of one row to the next.\n// It must be a multiple of 16.\nuint64_t\nstride\n[\nrank\n-\n1\n]\n=\n{\nGMEM_WIDTH\n*\nsizeof\n(\nint\n)};\n// The box_size is the size of the shared memory buffer that is used as the\n// destination of a TMA transfer.\nuint32_t\nbox_size\n[\nrank\n]\n=\n{\nSMEM_WIDTH\n,\nSMEM_HEIGHT\n};\n// The distance between elements in units of sizeof(element). A stride of 2\n// can be used to load only the real component of a complex-valued tensor, for instance.\nuint32_t\nelem_stride\n[\nrank\n]\n=\n{\n1\n,\n1\n};\n// Get a function pointer to the cuTensorMapEncodeTiled driver API.\nauto\ncuTensorMapEncodeTiled\n=\nget_cuTensorMapEncodeTiled\n();\n// Create the tensor descriptor.\nCUresult\nres\n=\ncuTensorMapEncodeTiled\n(\n&\ntensor_map\n,\n// CUtensorMap *tensorMap,\nCUtensorMapDataType\n::\nCU_TENSOR_MAP_DATA_TYPE_INT32\n,\nrank\n,\n// cuuint32_t tensorRank,\ntensor_ptr\n,\n// void *globalAddress,\nsize\n,\n// const cuuint64_t *globalDim,\nstride\n,\n// const cuuint64_t *globalStrides,\nbox_size\n,\n// const cuuint32_t *boxDim,\nelem_stride\n,\n// const cuuint32_t *elementStrides,\n// Interleave patterns can be used to accelerate loading of values that\n// are less than 4 bytes long.\nCUtensorMapInterleave\n::\nCU_TENSOR_MAP_INTERLEAVE_NONE\n,\n// Swizzling can be used to avoid shared memory bank conflicts.\nCUtensorMapSwizzle\n::\nCU_TENSOR_MAP_SWIZZLE_NONE\n,\n// L2 Promotion can be used to widen the effect of a cache-policy to a wider\n// set of L2 cache lines.\nCUtensorMapL2promotion\n::\nCU_TENSOR_MAP_L2_PROMOTION_NONE\n,\n// Any element that is outside of bounds will be set to zero by the TMA transfer.\nCUtensorMapFloatOOBfill\n::\nCU_TENSOR_MAP_FLOAT_OOB_FILL_NONE\n);\nHost-to-device transfer\n. There are three ways to make a tensor map accessible to\ndevice code. The recommended approach is to pass the tensor map as a const\n__grid_constant__\nparameter to a kernel. The other possibilities are copying the tensor map into device\n__constant__\nmemory using\ncudaMemcpyToSymbol\nor accessing it via global memory. When passing the tensor map as a parameter, some versions of the\nGCC C++ compiler issue the warning âthe ABI for passing parameters with 64-byte\nalignment has changed in GCC 4.6â. This warning can be ignored.\n#include\n<cuda.h>\n__global__\nvoid\nkernel\n(\nconst\n__grid_constant__\nCUtensorMap\ntensor_map\n)\n{\n// Use tensor_map here.\n}\nint\nmain\n()\n{\nCUtensorMap\nmap\n;\n// [ ..Initialize map.. ]\nkernel\n<<<\n1\n,\n1\n>>>\n(\nmap\n);\n}\nAs an alternative to the\n__grid_constant__\nkernel parameter, a global\nconstant\nvariable can be used. An example is included\nbelow.\n#include\n<cuda.h>\n__constant__\nCUtensorMap\nglobal_tensor_map\n;\n__global__\nvoid\nkernel\n()\n{\n// Use global_tensor_map here.\n}\nint\nmain\n()\n{\nCUtensorMap\nlocal_tensor_map\n;\n// [ ..Initialize map.. ]\ncudaMemcpyToSymbol\n(\nglobal_tensor_map\n,\n&\nlocal_tensor_map\n,\nsizeof\n(\nCUtensorMap\n));\nkernel\n<<<\n1\n,\n1\n>>>\n();\n}\nFinally, it is possible to copy the tensor map to global memory. Using a pointer to a\ntensor map in global device memory requires a fence in each thread block before any thread\nin the block uses the updated tensor map. Further uses of the tensor map by that thread block\ndo not need to be fenced unless the tensor map is modified again. Note that this mechanism\nmay be slower than the two mechanisms described above.\n#include\n<cuda.h>\n#include\n<cuda/ptx>\nnamespace\nptx\n=\ncuda\n::\nptx\n;\n__device__\nCUtensorMap\nglobal_tensor_map\n;\n__global__\nvoid\nkernel\n(\nCUtensorMap\n*\ntensor_map\n)\n{\n// Fence acquire tensor map:\nptx\n::\nn32_t\n<\n128\n>\nsize_bytes\n;\n// Since the tensor map was modified from the host using cudaMemcpy,\n// the scope should be .sys.\nptx\n::\nfence_proxy_tensormap_generic\n(\nptx\n::\nsem_acquire\n,\nptx\n::\nscope_sys\n,\ntensor_map\n,\nsize_bytes\n);\n// Safe to use tensor_map after fence inside this thread..\n}\nint\nmain\n()\n{\nCUtensorMap\nlocal_tensor_map\n;\n// [ ..Initialize map.. ]\ncudaMemcpy\n(\n&\nglobal_tensor_map\n,\n&\nlocal_tensor_map\n,\nsizeof\n(\nCUtensorMap\n),\ncudaMemcpyHostToDevice\n);\nkernel\n<<<\n1\n,\n1\n>>>\n(\nglobal_tensor_map\n);\n}\nUse\n. The kernel below loads a 2D tile of size\nSMEM_HEIGHT\nx\nSMEM_WIDTH\nfrom a larger 2D array. The top-left corner of the tile is indicated by the\nindices\nx\nand\ny\n. The tile is loaded into shared memory, modified, and\nwritten back to global memory.\n#include\n<cuda.h>\n// CUtensormap\n#include\n<cuda/barrier>\nusing\nbarrier\n=\ncuda\n::\nbarrier\n<\ncuda\n::\nthread_scope_block\n>\n;\nnamespace\ncde\n=\ncuda\n::\ndevice\n::\nexperimental\n;\n__global__\nvoid\nkernel\n(\nconst\n__grid_constant__\nCUtensorMap\ntensor_map\n,\nint\nx\n,\nint\ny\n)\n{\n// The destination shared memory buffer of a bulk tensor operation should be\n// 128 byte aligned.\n__shared__\nalignas\n(\n128\n)\nint\nsmem_buffer\n[\nSMEM_HEIGHT\n][\nSMEM_WIDTH\n];\n// Initialize shared memory barrier with the number of threads participating in the barrier.\n#pragma nv_diag_suppress static_var_with_dynamic_init\n__shared__\nbarrier\nbar\n;\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\n// Initialize barrier. All `blockDim.x` threads in block participate.\ninit\n(\n&\nbar\n,\nblockDim\n.\nx\n);\n// Make initialized barrier visible in async proxy.\ncde\n::\nfence_proxy_async_shared_cta\n();\n}\n// Syncthreads so initialized barrier is visible to all threads.\n__syncthreads\n();\nbarrier\n::\narrival_token\ntoken\n;\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\n// Initiate bulk tensor copy.\ncde\n::\ncp_async_bulk_tensor_2d_global_to_shared\n(\n&\nsmem_buffer\n,\n&\ntensor_map\n,\nx\n,\ny\n,\nbar\n);\n// Arrive on the barrier and tell how many bytes are expected to come in.\ntoken\n=\ncuda\n::\ndevice\n::\nbarrier_arrive_tx\n(\nbar\n,\n1\n,\nsizeof\n(\nsmem_buffer\n));\n}\nelse\n{\n// Other threads just arrive.\ntoken\n=\nbar\n.\narrive\n();\n}\n// Wait for the data to have arrived.\nbar\n.\nwait\n(\nstd\n::\nmove\n(\ntoken\n));\n// Symbolically modify a value in shared memory.\nsmem_buffer\n[\n0\n][\nthreadIdx\n.\nx\n]\n+=\nthreadIdx\n.\nx\n;\n// Wait for shared memory writes to be visible to TMA engine.\ncde\n::\nfence_proxy_async_shared_cta\n();\n__syncthreads\n();\n// After syncthreads, writes by all threads are visible to TMA engine.\n// Initiate TMA transfer to copy shared memory to global memory\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\ncde\n::\ncp_async_bulk_tensor_2d_shared_to_global\n(\n&\ntensor_map\n,\nx\n,\ny\n,\n&\nsmem_buffer\n);\n// Wait for TMA transfer to have finished reading shared memory.\n// Create a \"bulk async-group\" out of the previous bulk copy operation.\ncde\n::\ncp_async_bulk_commit_group\n();\n// Wait for the group to have completed reading from shared memory.\ncde\n::\ncp_async_bulk_wait_group_read\n<\n0\n>\n();\n}\n// Destroy barrier. This invalidates the memory region of the barrier. If\n// further computations were to take place in the kernel, this allows the\n// memory location of the shared memory barrier to be reused.\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\n(\n&\nbar\n)\n->~\nbarrier\n();\n}\n}\nNegative indices and out of bounds\n. When part of the tile that is being\nread\nfrom global to shared memory is out of bounds, the shared memory that\ncorresponds to the out of bounds area is zero-filled. The top-left corner\nindices of the tile may also be negative. When\nwriting\nfrom shared to global\nmemory, parts of the tile may be out of bounds, but the top left corner cannot\nhave any negative indices.\nSize and stride\n. The size of a tensor is the number of elements along one\ndimension. All sizes must be greater than one. The stride is the number of bytes\nbetween elements of the same dimension. For instance, a\n4 x 4\nmatrix of\nintegers has sizes 4 and 4. Since it has 4 bytes per element, the strides are 4\nand 16 bytes. Due to alignment requirements, a\n4 x 3\nrow-major matrix of\nintegers must have strides of 4 and 16 bytes as well. Each row is padded with 4\nextra bytes to ensure that the start of the next row is aligned to 16 bytes. For\nmore information regarding alignment, refer to\nTable 10\n.\nTable 10\nAlignment requirements for multi-dimensional bulk tensor asynchronous copy operations in Compute Capability 9.0.\nï\nAddress / Size\nAlignment\nGlobal memory address\nMust be 16 byte aligned.\nGlobal memory sizes\nMust be greater than or equal to one. Does not have to be a multiple of 16 bytes.\nGlobal memory strides\nMust be multiples of 16 bytes.\nShared memory address\nMust be 128 byte aligned.\nShared memory barrier address\nMust be 8 byte aligned (this is guaranteed by\ncuda::barrier\n).\nSize of transfer\nMust be a multiple of 16 bytes.\n10.29.2.1.\nMulti-dimensional TMA PTX wrappers\nï\nBelow, the PTX instructions are ordered by their use in the example code above.\nThe\ncp.async.bulk.tensor\ninstructions initiate a bulk tensor asynchronous copy between global and shared memory. The\nwrappers below read from global to shared memory and write from shared to global\nmemory.\n// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor\ninline\n__device__\nvoid\ncuda\n::\ndevice\n::\nexperimental\n::\ncp_async_bulk_tensor_1d_global_to_shared\n(\nvoid\n*\ndest\n,\nconst\nCUtensorMap\n*\ntensor_map\n,\nint\nc0\n,\ncuda\n::\nbarrier\n<\ncuda\n::\nthread_scope_block\n>\n&\nbar\n);\n// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor\ninline\n__device__\nvoid\ncuda\n::\ndevice\n::\nexperimental\n::\ncp_async_bulk_tensor_2d_global_to_shared\n(\nvoid\n*\ndest\n,\nconst\nCUtensorMap\n*\ntensor_map\n,\nint\nc0\n,\nint\nc1\n,\ncuda\n::\nbarrier\n<\ncuda\n::\nthread_scope_block\n>\n&\nbar\n);\n// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor\ninline\n__device__\nvoid\ncuda\n::\ndevice\n::\nexperimental\n::\ncp_async_bulk_tensor_3d_global_to_shared\n(\nvoid\n*\ndest\n,\nconst\nCUtensorMap\n*\ntensor_map\n,\nint\nc0\n,\nint\nc1\n,\nint\nc2\n,\ncuda\n::\nbarrier\n<\ncuda\n::\nthread_scope_block\n>\n&\nbar\n);\n// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor\ninline\n__device__\nvoid\ncuda\n::\ndevice\n::\nexperimental\n::\ncp_async_bulk_tensor_4d_global_to_shared\n(\nvoid\n*\ndest\n,\nconst\nCUtensorMap\n*\ntensor_map\n,\nint\nc0\n,\nint\nc1\n,\nint\nc2\n,\nint\nc3\n,\ncuda\n::\nbarrier\n<\ncuda\n::\nthread_scope_block\n>\n&\nbar\n);\n// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor\ninline\n__device__\nvoid\ncuda\n::\ndevice\n::\nexperimental\n::\ncp_async_bulk_tensor_5d_global_to_shared\n(\nvoid\n*\ndest\n,\nconst\nCUtensorMap\n*\ntensor_map\n,\nint\nc0\n,\nint\nc1\n,\nint\nc2\n,\nint\nc3\n,\nint\nc4\n,\ncuda\n::\nbarrier\n<\ncuda\n::\nthread_scope_block\n>\n&\nbar\n);\n// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor\ninline\n__device__\nvoid\ncuda\n::\ndevice\n::\nexperimental\n::\ncp_async_bulk_tensor_1d_shared_to_global\n(\nconst\nCUtensorMap\n*\ntensor_map\n,\nint\nc0\n,\nconst\nvoid\n*\nsrc\n);\n// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor\ninline\n__device__\nvoid\ncuda\n::\ndevice\n::\nexperimental\n::\ncp_async_bulk_tensor_2d_shared_to_global\n(\nconst\nCUtensorMap\n*\ntensor_map\n,\nint\nc0\n,\nint\nc1\n,\nconst\nvoid\n*\nsrc\n);\n// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor\ninline\n__device__\nvoid\ncuda\n::\ndevice\n::\nexperimental\n::\ncp_async_bulk_tensor_3d_shared_to_global\n(\nconst\nCUtensorMap\n*\ntensor_map\n,\nint\nc0\n,\nint\nc1\n,\nint\nc2\n,\nconst\nvoid\n*\nsrc\n);\n// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor\ninline\n__device__\nvoid\ncuda\n::\ndevice\n::\nexperimental\n::\ncp_async_bulk_tensor_4d_shared_to_global\n(\nconst\nCUtensorMap\n*\ntensor_map\n,\nint\nc0\n,\nint\nc1\n,\nint\nc2\n,\nint\nc3\n,\nconst\nvoid\n*\nsrc\n);\n// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor\ninline\n__device__\nvoid\ncuda\n::\ndevice\n::\nexperimental\n::\ncp_async_bulk_tensor_5d_shared_to_global\n(\nconst\nCUtensorMap\n*\ntensor_map\n,\nint\nc0\n,\nint\nc1\n,\nint\nc2\n,\nint\nc3\n,\nint\nc4\n,\nconst\nvoid\n*\nsrc\n);\n10.29.3.\nTMA Swizzle\nï\nBy default, the TMA engine loads data to shared memory in the same order as it is laid out in global memory. However, this\nlayout may not be optimal for certain shared memory access patterns, as it could cause shared memory bank conflicts. To\nimprove performance and reduce bank conflicts, we can change the shared memory layout by applying a âswizzle patternâ.\nShared memory has 32 banks that are organized such that successive 32-bit words map to successive banks. Each bank has a\nbandwidth of 32 bits per clock cycle. When loading and storing shared memory, bank conflicts arise if the same bank is\nused multiple times within a transaction, resulting in reduced bandwidth. See\nShared Memory\n, bank conflicts.\nTo ensure that data is laid out in shared memory in such a way that user code can avoid shared memory bank conflicts,\nthe TMA engine can be instructed to âswizzleâ the data before storing it in shared memory and âunswizzleâ it when copying\nthe data back from shared memory to global memory. The tensor map encodes the âswizzle modeâ indicating which swizzle pattern is used.\n10.29.3.1.\nExample âMatrix Transposeâ\nï\nAn example is the transpose of a matrix where data is mapped from row to column first access. The data is stored row major in\nglobal memory, but we want to also access it column wise in shared memory, which leads to bank conflicts. However, by using\nthe 128 bytes âswizzleâ mode and new shared memory indices, they are eliminated.\nIn the example, we load an 8x8 matrix of type\nint4\n, stored as row major in global memory to shared memory. Then, each set of eight\nthreads loads a row from the shared memory buffer and stores it to a column in a separate transpose shared memory buffer. This\nresults in an eight-way bank conflict when storing. Finally, the transpose buffer is written back to global memory.\nTo avoid bank conflicts, the\nCU_TENSOR_MAP_SWIZZLE_128B\nlayout can be used. This layout matches the 128 bytes row length and\nchanges the shared memory layout in a way that both the column wise and row wise access donât require the same banks per transaction.\nThe two tables,\nFigure 27\nand\nFigure 28\n,  below show the normal and the swizzled shared memory layout of the 8x8 matrix of type\nint4\nand\nits transpose matrix. The colors indicate which of the eight groups of four banks the matrix element is mapped to, and\nthe margin row and margin column list the global memory row and column indices. The entries show the shared memory\nindices of the 16-byte matrix elements.\nFigure 27\nIn the shared memory data layout without swizzle, the shared memory indices are equivalent to the global memory indices.\nPer load instruction, one row is read and stored in a column of the transpose buffer. Since all matrix elements of the\ncolumn in the transpose fall in the same bank, the store must be serialized, resulting in eight store transactions, giving\nan eight-way bank conflict per stored column.\nï\nFigure 28\nThe shared memory data layout with\nCU_TENSOR_MAP_SWIZZLE_128B\nswizzle. One row is stored in a column, each matrix\nelement is from a different bank for both the rows and columns, and so without any bank conflicts.\nï\n__global__\nvoid\nkernel_tma\n(\nconst\n__grid_constant__\nCUtensorMap\ntensor_map\n)\n{\n// The destination shared memory buffer of a bulk tensor operation\n// with the 128-byte swizzle mode, it should be 1024 bytes aligned.\n__shared__\nalignas\n(\n1024\n)\nint4\nsmem_buffer\n[\n8\n][\n8\n];\n__shared__\nalignas\n(\n1024\n)\nint4\nsmem_buffer_tr\n[\n8\n][\n8\n];\n// Initialize shared memory barrier\n#pragma nv_diag_suppress static_var_with_dynamic_init\n__shared__\nbarrier\nbar\n;\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\ninit\n(\n&\nbar\n,\nblockDim\n.\nx\n);\ncde\n::\nfence_proxy_async_shared_cta\n();\n}\n__syncthreads\n();\nbarrier\n::\narrival_token\ntoken\n;\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\n// Initiate bulk tensor copy from global to shared memory,\n// in the same way as without swizzle.\ncde\n::\ncp_async_bulk_tensor_2d_global_to_shared\n(\n&\nsmem_buffer\n,\n&\ntensor_map\n,\n0\n,\n0\n,\nbar\n);\ntoken\n=\ncuda\n::\ndevice\n::\nbarrier_arrive_tx\n(\nbar\n,\n1\n,\nsizeof\n(\nsmem_buffer\n));\n}\nelse\n{\ntoken\n=\nbar\n.\narrive\n();\n}\nbar\n.\nwait\n(\nstd\n::\nmove\n(\ntoken\n));\n/* Matrix transpose\n*  When using the normal shared memory layout, there are eight\n*  8-way shared memory bank conflict when storing to the transpose.\n*  When enabling the 128-byte swizzle pattern and using the according access pattern,\n*  they are eliminated both for load and store. */\nfor\n(\nint\nsidx_j\n=\nthreadIdx\n.\nx\n;\nsidx_j\n<\n8\n;\nsidx_j\n+=\nblockDim\n.\nx\n){\nfor\n(\nint\nsidx_i\n=\n0\n;\nsidx_i\n<\n8\n;\n++\nsidx_i\n){\nconst\nint\nswiz_j_idx\n=\n(\nsidx_i\n%\n8\n)\n^\nsidx_j\n;\nconst\nint\nswiz_i_idx_tr\n=\n(\nsidx_j\n%\n8\n)\n^\nsidx_i\n;\nsmem_buffer_tr\n[\nsidx_j\n][\nswiz_i_idx_tr\n]\n=\nsmem_buffer\n[\nsidx_i\n][\nswiz_j_idx\n];\n}\n}\n// Wait for shared memory writes to be visible to TMA engine.\ncde\n::\nfence_proxy_async_shared_cta\n();\n__syncthreads\n();\n/* Initiate TMA transfer to copy the transposed shared memory buffer back to global memory,\n* it will 'unswizzle' the data. */\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\ncde\n::\ncp_async_bulk_tensor_2d_shared_to_global\n(\n&\ntensor_map\n,\n0\n,\n0\n,\n&\nsmem_buffer_tr\n);\ncde\n::\ncp_async_bulk_commit_group\n();\ncde\n::\ncp_async_bulk_wait_group_read\n<\n0\n>\n();\n}\n// Destroy barrier\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\n(\n&\nbar\n)\n->~\nbarrier\n();\n}\n}\n// --------------------------------- main ----------------------------------------\nint\nmain\n(){\n...\nvoid\n*\ntensor_ptr\n=\nd_data\n;\nCUtensorMap\ntensor_map\n{};\n// rank is the number of dimensions of the array.\nconstexpr\nuint32_t\nrank\n=\n2\n;\n// global memory size\nuint64_t\nsize\n[\nrank\n]\n=\n{\n4\n*\n8\n,\n8\n};\n// global memory stride, must be a multiple of 16.\nuint64_t\nstride\n[\nrank\n-\n1\n]\n=\n{\n8\n*\nsizeof\n(\nint4\n)};\n// The inner shared memory box dimension in bytes, equal to the swizzle span.\nuint32_t\nbox_size\n[\nrank\n]\n=\n{\n4\n*\n8\n,\n8\n};\nuint32_t\nelem_stride\n[\nrank\n]\n=\n{\n1\n,\n1\n};\n// Create the tensor descriptor.\nCUresult\nres\n=\ncuTensorMapEncodeTiled\n(\n&\ntensor_map\n,\n// CUtensorMap *tensorMap,\nCUtensorMapDataType\n::\nCU_TENSOR_MAP_DATA_TYPE_INT32\n,\nrank\n,\n// cuuint32_t tensorRank,\ntensor_ptr\n,\n// void *globalAddress,\nsize\n,\n// const cuuint64_t *globalDim,\nstride\n,\n// const cuuint64_t *globalStrides,\nbox_size\n,\n// const cuuint32_t *boxDim,\nelem_stride\n,\n// const cuuint32_t *elementStrides,\nCUtensorMapInterleave\n::\nCU_TENSOR_MAP_INTERLEAVE_NONE\n,\n// Using a swizzle pattern of 128 bytes.\nCUtensorMapSwizzle\n::\nCU_TENSOR_MAP_SWIZZLE_128B\n,\nCUtensorMapL2promotion\n::\nCU_TENSOR_MAP_L2_PROMOTION_NONE\n,\nCUtensorMapFloatOOBfill\n::\nCU_TENSOR_MAP_FLOAT_OOB_FILL_NONE\n);\nkernel_tma\n<<<\n1\n,\n8\n>>>\n(\ntensor_map\n);\n...\n}\nRemark.\nThis example is supposed to show the use of swizzle and âas-isâ is not performant nor does it scale beyond the given dimensions.\nExplanation.\nDuring data transfer, the TMA engine shuffles the data according to the swizzle pattern, as described in the following\ntables. These swizzle patterns define the mapping of the 16-byte chunks along the swizzle width to subgroups of four banks.\nIt is of type\nCUtensorMapSwizzle\nand has four options: none, 32 bytes, 64 bytes and 128 bytes. Note that the shared memory boxâs\ninner dimension must be less or equal to the span of the swizzle pattern.\n10.29.3.2.\nThe Swizzle Modes\nï\nAs previously mentioned, there are four swizzle modes. The following tables show the different swizzle patterns, including the relation of the new\nshared memory indices. The tables define the mapping of the 16-byte chunks along the 128 bytes to eight subgroups of four banks.\nFigure 29\nAn Overview of TMA Swizzle Patterns\nï\nConsiderations.\nWhen applying a TMA swizzle pattern, it is crucial to adhere to specific memory requirements:\nGlobal memory alignment:\nGlobal memory must be aligned to 128 bytes.\nShared memory alignment:\nFor simplicity shared memory should be aligned according to the number of bytes after which the swizzle pattern repeats. When the shared memory buffer is not aligned by the number of bytes by which the swizzle pattern repeats itself, there is an offset between the swizzle pattern and the shared memory.\nSee\ncomment\n, below.\nInner dimension:\nThe inner dimension of the shared memory block must meet the size requirements specified in\nTable 12\n. If these\nrequirements are not met, the instruction is considered invalid. Additionally, if the swizzle width exceeds the inner dimension,\nensure that the shared memory is allocated to accommodate the full swizzle width.\nGranularity:\nThe granularity of swizzle mapping is fixed at 16 bytes. This means that data is organized and accessed in chunks\nof 16 bytes, which must be considered when planning memory layout and access patterns.\nSwizzle Pattern Pointer Offset Computation\n. Here, we describe how to determine the offset between the swizzle pattern and the shared memory, when the shared memory buffer is not aligned by the number of bytes by which the swizzle pattern repeats itself.\nWhen using TMA, the shared memory is required to be aligned to 128 bytes. To find how many times the shared memory buffer relative to the swizzle pattern is shifted by that, apply the corresponding offset formula.\nTable 11\nSwizzle Pattern Pointer Offset Formula and Index Relation\nï\nSwizzle Mode\nOffset Formula\nIndex Relation\nCU_TENSOR_MAP_SWIZZLE_128B\n(reinterpret_cast\n<uintptr_t>(smem_ptr)/128)%8\nsmem[y][x]\n<->\nsmem[y][((y+offset)%8)^x]\nCU_TENSOR_MAP_SWIZZLE_64B\n(reinterpret_cast\n<uintptr_t>(smem_ptr)/128)%4\nsmem[y][x]\n<->\nsmem[y][((y+offset)%4)^x]\nCU_TENSOR_MAP_SWIZZLE_32B\n(reinterpret_cast\n<uintptr_t>(smem_ptr)/128)%2\nsmem[y][x]\n<->\nsmem[y][((y+offset)%2)^x]\nIn\nFigure 29\n, this offset represents the initial row offset, thus, in the swizzle index calculation, it is added to the row index\ny\n.\nThe following snippet shows how to access the swizzled shared memory in the\nCU_TENSOR_MAP_SWIZZLE_128B\nmode.\ndata_t\n*\nsmem_ptr\n=\n&\nsmem\n[\n0\n][\n0\n];\nint\noffset\n=\n(\nreinterpret_cast\n<\nuintptr_t\n>\n(\nsmem_ptr\n)\n/\n128\n)\n%\n8\n;\nsmem\n[\ny\n][((\ny\n+\noffset\n)\n%\n8\n)\n^\nx\n]\n=\n...\nSummary.\nThe following\nTable 12\nsummarizes the requirements and properties of the different swizzle patterns for Compute Capability 9.\nTable 12\nRequirements and properties of the different swizzle patterns for Compute Capability 9\nï\nPattern\nSwizzle width\nShared boxâs\ninner dimension\nRepeats\nafter\nShared\nmemory\nalignment\nGlobal\nmemory\nalignment\nCU_TENSOR_MAP_SWIZZLE_128B\n128 bytes\n<=128 bytes\n1024 bytes\n128 bytes\n128 bytes\nCU_TENSOR_MAP_SWIZZLE_64B\n64 bytes\n<=64 bytes\n512 bytes\n128 bytes\n128 bytes\nCU_TENSOR_MAP_SWIZZLE_32B\n32 bytes\n<=32 bytes\n256 bytes\n128 bytes\n128 bytes\nCU_TENSOR_MAP_SWIZZLE_NONE\n(default)\n128 bytes\n16 bytes\n10.30.\nEncoding a Tensor Map on Device\nï\nPrevious sections have described how to create a tensor map on the host using the CUDA driver API.\nThis section explains how to encode a tiled-type tensor map on device. This is useful in situations where the typical\nway of transferring the tensor map (using\nconst\n__grid_constant__\nkernel parameters) is undesirable, for instance,\nwhen processing a batch of tensors of various sizes in a single kernel launch.\nThe recommended pattern is as follows:\nCreate a tensor map âtemplateâ,\ntemplate_tensor_map\n, using the Driver API on the host.\nIn a device kernel, copy the\ntemplate_tensor_map\n, modify the copy, store in global memory, and appropriately fence.\nUse the tensor map in a kernel with appropriate fencing.\nThe high-level code structure is as follows:\n// Initialize device context:\nCUDA_CHECK\n(\ncudaDeviceSynchronize\n());\n// Create a tensor map template using the cuTensorMapEncodeTiled driver function\nCUtensorMap\ntemplate_tensor_map\n=\nmake_tensormap_template\n();\n// Allocate tensor map and tensor in global memory\nCUtensorMap\n*\nglobal_tensor_map\n;\nCUDA_CHECK\n(\ncudaMalloc\n(\n&\nglobal_tensor_map\n,\nsizeof\n(\nCUtensorMap\n)));\nchar\n*\nglobal_buf\n;\nCUDA_CHECK\n(\ncudaMalloc\n(\n&\nglobal_buf\n,\n8\n*\n256\n));\n// Fill global buffer with data.\nfill_global_buf\n<<<\n1\n,\n1\n>>>\n(\nglobal_buf\n);\n// Define the parameters of the tensor map that will be created on device.\ntensormap_params\np\n{};\np\n.\nglobal_address\n=\nglobal_buf\n;\np\n.\nrank\n=\n2\n;\np\n.\nbox_dim\n[\n0\n]\n=\n128\n;\n// The box in shared memory has half the width of the full buffer\np\n.\nbox_dim\n[\n1\n]\n=\n4\n;\n// The box in shared memory has half the height of the full buffer\np\n.\nglobal_dim\n[\n0\n]\n=\n256\n;\n//\np\n.\nglobal_dim\n[\n1\n]\n=\n8\n;\n//\np\n.\nglobal_stride\n[\n0\n]\n=\n256\n;\n//\np\n.\nelement_stride\n[\n0\n]\n=\n1\n;\n//\np\n.\nelement_stride\n[\n1\n]\n=\n1\n;\n//\n// Encode global_tensor_map on device:\nencode_tensor_map\n<<<\n1\n,\n32\n>>>\n(\ntemplate_tensor_map\n,\np\n,\nglobal_tensor_map\n);\n// Use it from another kernel:\nconsume_tensor_map\n<<<\n1\n,\n1\n>>>\n(\nglobal_tensor_map\n);\n// Check for errors:\nCUDA_CHECK\n(\ncudaDeviceSynchronize\n());\nThe following sections  describe the high-level steps. Throughout the examples, the following\ntensormap_params\nstruct contains the new values of the fields to be updated. It is included here to reference when reading the examples.\nstruct\ntensormap_params\n{\nvoid\n*\nglobal_address\n;\nint\nrank\n;\nuint32_t\nbox_dim\n[\n5\n];\nuint64_t\nglobal_dim\n[\n5\n];\nsize_t\nglobal_stride\n[\n4\n];\nuint32_t\nelement_stride\n[\n5\n];\n};\n10.30.1.\nDevice-side Encoding and Modification of a Tensor Map\nï\nThe recommended process of encoding a tensor map in global memory proceeds as follows.\nPass an existing tensor map, the\ntemplate_tensor_map\n, to the kernel. In contrast to kernels that use\nthe tensor map in a\ncp.async.bulk.tensor\ninstruction, this may be done in any way: a pointer to global\nmemory, kernel parameter, a\n__const___\nvariable, and so on.\nCopy-initialize a tensor map in shared memory with the template_tensor_map value.\nModify the tensor map in shared memory using the\ncuda::ptx::tensormap_replace\nfunctions. These functions wrap the\ntensormap.replace\nPTX instruction, which can be used to modify any field of a tiled-type tensor map, including the\nbase address, size, stride, and so on.\nUsing the\ncuda::ptx::tensormap_copy_fenceproxy\nfunction, copy the modified tensor map from shared memory to global memory and perform any necessary fencing.\nThe following code contains a kernel that follows these steps. For completeness, it modifies all the fields\nof the tensor map. Typically, a kernel will modify just a few fields.\nIn this kernel,\ntemplate_tensor_map\nis passed as a kernel parameter. This is the preferred way of moving\ntemplate_tensor_map\nfrom the host to the device. If the kernel is intended to update an existing tensor map in device memory, it can take a\npointer to the existing tensor map to modify.\nNote\nThe format of the tensor map may change over time. Therefore, the\ncuda::ptx::tensormap_replace\nfunctions and corresponding\ntensormap.replace.tile\nPTX instructions are marked as specific to sm_90a. To use them, compile using\nnvcc\n-arch\nsm_90a\n....\n.\nTip\nOn sm_90a, a zero-initialized buffer in shared memory may also be used as the initial tensor map value. This\nenables encoding a tensor map purely on device, without using the driver API to encode the\ntemplate_tensor_map\nvalue\n.\nNote\nOn-device modification is only supported for tiled-type tensor maps; other tensor map types cannot be modified on device. For more\ninformation on the tensor map types, refer to the\nDriver API reference\n.\n#include\n<cuda/ptx>\nnamespace\nptx\n=\ncuda\n::\nptx\n;\n// launch with 1 warp.\n__launch_bounds__\n(\n32\n)\n__global__\nvoid\nencode_tensor_map\n(\nconst\n__grid_constant__\nCUtensorMap\ntemplate_tensor_map\n,\ntensormap_params\np\n,\nCUtensorMap\n*\nout\n)\n{\n__shared__\nalignas\n(\n128\n)\nCUtensorMap\nsmem_tmap\n;\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\n// Copy template to shared memory:\nsmem_tmap\n=\ntemplate_tensor_map\n;\nconst\nauto\nspace_shared\n=\nptx\n::\nspace_shared\n;\nptx\n::\ntensormap_replace_global_address\n(\nspace_shared\n,\n&\nsmem_tmap\n,\np\n.\nglobal_address\n);\n// For field .rank, the operand new_val must be ones less than the desired\n// tensor rank as this field uses zero-based numbering.\nptx\n::\ntensormap_replace_rank\n(\nspace_shared\n,\n&\nsmem_tmap\n,\np\n.\nrank\n-\n1\n);\n// Set box dimensions:\nif\n(\n0\n<\np\n.\nrank\n)\n{\nptx\n::\ntensormap_replace_box_dim\n(\nspace_shared\n,\n&\nsmem_tmap\n,\nptx\n::\nn32_t\n<\n0\n>\n{},\np\n.\nbox_dim\n[\n0\n]);\n}\nif\n(\n1\n<\np\n.\nrank\n)\n{\nptx\n::\ntensormap_replace_box_dim\n(\nspace_shared\n,\n&\nsmem_tmap\n,\nptx\n::\nn32_t\n<\n1\n>\n{},\np\n.\nbox_dim\n[\n1\n]);\n}\nif\n(\n2\n<\np\n.\nrank\n)\n{\nptx\n::\ntensormap_replace_box_dim\n(\nspace_shared\n,\n&\nsmem_tmap\n,\nptx\n::\nn32_t\n<\n2\n>\n{},\np\n.\nbox_dim\n[\n2\n]);\n}\nif\n(\n3\n<\np\n.\nrank\n)\n{\nptx\n::\ntensormap_replace_box_dim\n(\nspace_shared\n,\n&\nsmem_tmap\n,\nptx\n::\nn32_t\n<\n3\n>\n{},\np\n.\nbox_dim\n[\n3\n]);\n}\nif\n(\n4\n<\np\n.\nrank\n)\n{\nptx\n::\ntensormap_replace_box_dim\n(\nspace_shared\n,\n&\nsmem_tmap\n,\nptx\n::\nn32_t\n<\n4\n>\n{},\np\n.\nbox_dim\n[\n4\n]);\n}\n// Set global dimensions:\nif\n(\n0\n<\np\n.\nrank\n)\n{\nptx\n::\ntensormap_replace_global_dim\n(\nspace_shared\n,\n&\nsmem_tmap\n,\nptx\n::\nn32_t\n<\n0\n>\n{},\n(\nuint32_t\n)\np\n.\nglobal_dim\n[\n0\n]);\n}\nif\n(\n1\n<\np\n.\nrank\n)\n{\nptx\n::\ntensormap_replace_global_dim\n(\nspace_shared\n,\n&\nsmem_tmap\n,\nptx\n::\nn32_t\n<\n1\n>\n{},\n(\nuint32_t\n)\np\n.\nglobal_dim\n[\n1\n]);\n}\nif\n(\n2\n<\np\n.\nrank\n)\n{\nptx\n::\ntensormap_replace_global_dim\n(\nspace_shared\n,\n&\nsmem_tmap\n,\nptx\n::\nn32_t\n<\n2\n>\n{},\n(\nuint32_t\n)\np\n.\nglobal_dim\n[\n2\n]);\n}\nif\n(\n3\n<\np\n.\nrank\n)\n{\nptx\n::\ntensormap_replace_global_dim\n(\nspace_shared\n,\n&\nsmem_tmap\n,\nptx\n::\nn32_t\n<\n3\n>\n{},\n(\nuint32_t\n)\np\n.\nglobal_dim\n[\n3\n]);\n}\nif\n(\n4\n<\np\n.\nrank\n)\n{\nptx\n::\ntensormap_replace_global_dim\n(\nspace_shared\n,\n&\nsmem_tmap\n,\nptx\n::\nn32_t\n<\n4\n>\n{},\n(\nuint32_t\n)\np\n.\nglobal_dim\n[\n4\n]);\n}\n// Set global stride:\nif\n(\n1\n<\np\n.\nrank\n)\n{\nptx\n::\ntensormap_replace_global_stride\n(\nspace_shared\n,\n&\nsmem_tmap\n,\nptx\n::\nn32_t\n<\n0\n>\n{},\np\n.\nglobal_stride\n[\n0\n]);\n}\nif\n(\n2\n<\np\n.\nrank\n)\n{\nptx\n::\ntensormap_replace_global_stride\n(\nspace_shared\n,\n&\nsmem_tmap\n,\nptx\n::\nn32_t\n<\n1\n>\n{},\np\n.\nglobal_stride\n[\n1\n]);\n}\nif\n(\n3\n<\np\n.\nrank\n)\n{\nptx\n::\ntensormap_replace_global_stride\n(\nspace_shared\n,\n&\nsmem_tmap\n,\nptx\n::\nn32_t\n<\n2\n>\n{},\np\n.\nglobal_stride\n[\n2\n]);\n}\nif\n(\n4\n<\np\n.\nrank\n)\n{\nptx\n::\ntensormap_replace_global_stride\n(\nspace_shared\n,\n&\nsmem_tmap\n,\nptx\n::\nn32_t\n<\n3\n>\n{},\np\n.\nglobal_stride\n[\n3\n]);\n}\n// Set element stride:\nif\n(\n0\n<\np\n.\nrank\n)\n{\nptx\n::\ntensormap_replace_element_size\n(\nspace_shared\n,\n&\nsmem_tmap\n,\nptx\n::\nn32_t\n<\n0\n>\n{},\np\n.\nelement_stride\n[\n0\n]);\n}\nif\n(\n1\n<\np\n.\nrank\n)\n{\nptx\n::\ntensormap_replace_element_size\n(\nspace_shared\n,\n&\nsmem_tmap\n,\nptx\n::\nn32_t\n<\n1\n>\n{},\np\n.\nelement_stride\n[\n1\n]);\n}\nif\n(\n2\n<\np\n.\nrank\n)\n{\nptx\n::\ntensormap_replace_element_size\n(\nspace_shared\n,\n&\nsmem_tmap\n,\nptx\n::\nn32_t\n<\n2\n>\n{},\np\n.\nelement_stride\n[\n2\n]);\n}\nif\n(\n3\n<\np\n.\nrank\n)\n{\nptx\n::\ntensormap_replace_element_size\n(\nspace_shared\n,\n&\nsmem_tmap\n,\nptx\n::\nn32_t\n<\n3\n>\n{},\np\n.\nelement_stride\n[\n3\n]);\n}\nif\n(\n4\n<\np\n.\nrank\n)\n{\nptx\n::\ntensormap_replace_element_size\n(\nspace_shared\n,\n&\nsmem_tmap\n,\nptx\n::\nn32_t\n<\n4\n>\n{},\np\n.\nelement_stride\n[\n4\n]);\n}\n// These constants are documented in this table:\n// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#tensormap-new-val-validity\nauto\nu8_elem_type\n=\nptx\n::\nn32_t\n<\n0\n>\n{};\nptx\n::\ntensormap_replace_elemtype\n(\nspace_shared\n,\n&\nsmem_tmap\n,\nu8_elem_type\n);\nauto\nno_interleave\n=\nptx\n::\nn32_t\n<\n0\n>\n{};\nptx\n::\ntensormap_replace_interleave_layout\n(\nspace_shared\n,\n&\nsmem_tmap\n,\nno_interleave\n);\nauto\nno_swizzle\n=\nptx\n::\nn32_t\n<\n0\n>\n{};\nptx\n::\ntensormap_replace_swizzle_mode\n(\nspace_shared\n,\n&\nsmem_tmap\n,\nno_swizzle\n);\nauto\nzero_fill\n=\nptx\n::\nn32_t\n<\n0\n>\n{};\nptx\n::\ntensormap_replace_fill_mode\n(\nspace_shared\n,\n&\nsmem_tmap\n,\nzero_fill\n);\n}\n// Synchronize the modifications with other threads in warp\n__syncwarp\n();\n// Copy the tensor map to global memory collectively with threads in the warp.\n// In addition: make the updated tensor map visible to other threads on device that\n// for use with cp.async.bulk.\nptx\n::\nn32_t\n<\n128\n>\nbytes_128\n;\nptx\n::\ntensormap_cp_fenceproxy\n(\nptx\n::\nsem_release\n,\nptx\n::\nscope_gpu\n,\nout\n,\n&\nsmem_tmap\n,\nbytes_128\n);\n}\n10.30.2.\nUsage of a Modified Tensor Map\nï\nIn contrast to using a tensor map that is passed as a\nconst\n__grid_constant__\nkernel parameter, using a tensor map in\nglobal memory requires explicitly establishing a release-acquire pattern in the tensor map proxy between the threads\nthat modify the tensor map and the threads that use it.\nThe release part of the pattern was shown in the previous section. It is accomplished using\nthe\ncuda::ptx::tensormap.cp_fenceproxy\nfunction.\nThe acquire part is accomplished using the\ncuda::ptx::fence_proxy_tensormap_generic\nfunction that wraps the\nfence.proxy.tensormap::generic.acquire\ninstruction. If the two threads participating in the release-acquire pattern are on the same device, the\n.gpu\nscope suffices. If the threads are on\ndifferent devices, the\n.sys\nscope must be used. Once a tensor map has been acquired by one thread, it can be used by other threads in the block\nafter sufficient synchronization, for example, using\n__syncthreads()\n. The thread that uses the tensor map and the thread that performs the fence\nmust be in the same block. That is, if the threads are in, for example, two different thread blocks of the same cluster, the same grid, or a\ndifferent kernel, synchronization APIs such as\ncooperative_groups::cluster\nor\ngrid_group::sync()\nor stream-order synchronization do not\nsuffice to establish ordering for tensor map updates, that is, threads in these other thread blocks still need to acquire the tensor map proxy\nat the right scope before using the updated tensor map. If there are no intermediate modifications, the fence does not have to be repeated\nbefore each\ncp.async.bulk.tensor\ninstruction.\nThe\nfence\nand subsequent use of the tensor map is shown in the following example.\n// Consumer of tensor map in global memory:\n__global__\nvoid\nconsume_tensor_map\n(\nCUtensorMap\n*\ntensor_map\n)\n{\n// Fence acquire tensor map:\nptx\n::\nn32_t\n<\n128\n>\nsize_bytes\n;\nptx\n::\nfence_proxy_tensormap_generic\n(\nptx\n::\nsem_acquire\n,\nptx\n::\nscope_sys\n,\ntensor_map\n,\nsize_bytes\n);\n// Safe to use tensor_map after fence..\n__shared__\nuint64_t\nbar\n;\n__shared__\nalignas\n(\n128\n)\nchar\nsmem_buf\n[\n4\n][\n128\n];\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\n// Initialize barrier\nptx\n::\nmbarrier_init\n(\n&\nbar\n,\n1\n);\n// Make barrier init visible in async proxy, i.e., to TMA engine\nptx\n::\nfence_proxy_async\n(\nptx\n::\nspace_shared\n);\n// Issue TMA request\nptx\n::\ncp_async_bulk_tensor\n(\nptx\n::\nspace_cluster\n,\nptx\n::\nspace_global\n,\nsmem_buf\n,\ntensor_map\n,\n{\n0\n,\n0\n},\n&\nbar\n);\n// Arrive on barrier. Expect 4 * 128 bytes.\nptx\n::\nmbarrier_arrive_expect_tx\n(\nptx\n::\nsem_release\n,\nptx\n::\nscope_cta\n,\nptx\n::\nspace_shared\n,\n&\nbar\n,\nsizeof\n(\nsmem_buf\n));\n}\nconst\nint\nparity\n=\n0\n;\n// Wait for load to have completed\nwhile\n(\n!\nptx\n::\nmbarrier_try_wait_parity\n(\n&\nbar\n,\nparity\n))\n{}\n// print items:\nprintf\n(\n\"Got:\n\\n\\n\n\"\n);\nfor\n(\nint\nj\n=\n0\n;\nj\n<\n4\n;\n++\nj\n)\n{\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n128\n;\n++\ni\n)\n{\nprintf\n(\n\"%3d \"\n,\nsmem_buf\n[\nj\n][\ni\n]);\nif\n(\ni\n%\n32\n==\n31\n)\n{\nprintf\n(\n\"\n\\n\n\"\n);\n};\n}\nprintf\n(\n\"\n\\n\n\"\n);\n}\n}\n10.30.3.\nCreating a Template Tensor Map Value Using the Driver API\nï\nThe following code creates a minimal tiled-type tensor map that can be subsequently modified on device.\nCUtensorMap\nmake_tensormap_template\n()\n{\nCUtensorMap\ntemplate_tensor_map\n{};\nauto\ncuTensorMapEncodeTiled\n=\nget_cuTensorMapEncodeTiled\n();\nuint32_t\ndims_32\n=\n16\n;\nuint64_t\ndims_strides_64\n=\n16\n;\nuint32_t\nelem_strides\n=\n1\n;\n// Create the tensor descriptor.\nCUresult\nres\n=\ncuTensorMapEncodeTiled\n(\n&\ntemplate_tensor_map\n,\n// CUtensorMap *tensorMap,\nCUtensorMapDataType\n::\nCU_TENSOR_MAP_DATA_TYPE_UINT8\n,\n1\n,\n// cuuint32_t tensorRank,\nnullptr\n,\n// void *globalAddress,\n&\ndims_strides_64\n,\n// const cuuint64_t *globalDim,\n&\ndims_strides_64\n,\n// const cuuint64_t *globalStrides,\n&\ndims_32\n,\n// const cuuint32_t *boxDim,\n&\nelem_strides\n,\n// const cuuint32_t *elementStrides,\nCUtensorMapInterleave\n::\nCU_TENSOR_MAP_INTERLEAVE_NONE\n,\nCUtensorMapSwizzle\n::\nCU_TENSOR_MAP_SWIZZLE_NONE\n,\nCUtensorMapL2promotion\n::\nCU_TENSOR_MAP_L2_PROMOTION_NONE\n,\nCUtensorMapFloatOOBfill\n::\nCU_TENSOR_MAP_FLOAT_OOB_FILL_NONE\n);\nCU_CHECK\n(\nres\n);\nreturn\ntemplate_tensor_map\n;\n}\n10.31.\nProfiler Counter Function\nï\nEach multiprocessor has a set of sixteen hardware counters that an application can increment with a single instruction by calling the\n__prof_trigger()\nfunction.\nvoid\n__prof_trigger\n(\nint\ncounter\n);\nincrements by one per warp the per-multiprocessor hardware counter of index\ncounter\n. Counters 8 to 15 are reserved and should not be used by applications.\nThe value of counters 0, 1, â¦, 7 can be obtained via\nnvprof\nby\nnvprof\n--events\nprof_trigger_0x\nwhere\nx\nis 0, 1, â¦, 7. All counters are reset before each kernel launch (note that when collecting counters, kernel launches are synchronous as mentioned in\nConcurrent Execution between Host and Device\n).\n10.32.\nAssertion\nï\nAssertion is only supported by devices of compute capability 2.x and higher.\nvoid\nassert\n(\nint\nexpression\n);\nstops the kernel execution if\nexpression\nis equal to zero. If the program is run within a debugger, this triggers a breakpoint and the debugger can be used to inspect the current state of the device. Otherwise, each thread for which\nexpression\nis equal to zero prints a message to\nstderr\nafter synchronization with the host via\ncudaDeviceSynchronize()\n,\ncudaStreamSynchronize()\n, or\ncudaEventSynchronize()\n. The format of this message is as follows:\n<filename>:<line number>:<function>:\nblock: [blockId.x,blockId.x,blockIdx.z],\nthread: [threadIdx.x,threadIdx.y,threadIdx.z]\nAssertion `<expression>` failed.\nAny subsequent host-side synchronization calls made for the same device will return\ncudaErrorAssert\n. No more commands can be sent to this device until\ncudaDeviceReset()\nis called to reinitialize the device.\nIf\nexpression\nis different from zero, the kernel execution is unaffected.\nFor example, the following program from source file\ntest.cu\n#include\n<assert.h>\n__global__\nvoid\ntestAssert\n(\nvoid\n)\n{\nint\nis_one\n=\n1\n;\nint\nshould_be_one\n=\n0\n;\n// This will have no effect\nassert\n(\nis_one\n);\n// This will halt kernel execution\nassert\n(\nshould_be_one\n);\n}\nint\nmain\n(\nint\nargc\n,\nchar\n*\nargv\n[])\n{\ntestAssert\n<<<\n1\n,\n1\n>>>\n();\ncudaDeviceSynchronize\n();\nreturn\n0\n;\n}\nwill output:\ntest.cu:19: void testAssert(): block: [0,0,0], thread: [0,0,0] Assertion `should_be_one` failed.\nAssertions are for debugging purposes. They can affect performance and it is therefore recommended to disable them in production code. They can be disabled at compile time by defining the\nNDEBUG\npreprocessor macro before including\nassert.h\n. Note that\nexpression\nshould not be an expression with side effects (something like\n(++i\n>\n0)\n, for example), otherwise disabling the assertion will affect the functionality of the code.\n10.33.\nTrap function\nï\nA trap operation can be initiated by calling the\n__trap()\nfunction from any device thread.\nvoid\n__trap\n();\nThe execution of the kernel is aborted and an interrupt is raised in the host program.\n10.34.\nBreakpoint Function\nï\nExecution of a kernel function can be suspended by calling the\n__brkpt()\nfunction from any device thread.\nvoid\n__brkpt\n();\n10.35.\nFormatted Output\nï\nFormatted output is only supported by devices of compute capability 2.x and higher.\nint\nprintf\n(\nconst\nchar\n*\nformat\n[,\narg\n,\n...]);\nprints formatted output from a kernel to a host-side output stream.\nThe in-kernel\nprintf()\nfunction behaves in a similar way to the standard C-library\nprintf()\nfunction, and the user is referred to the host systemâs manual pages for a complete description of\nprintf()\nbehavior. In essence, the string passed in as\nformat\nis output to a stream on the host, with substitutions made from the argument list wherever a format specifier is encountered. Supported format specifiers are listed below.\nThe\nprintf()\ncommand is executed as any other device-side function: per-thread, and in the context of the calling thread. From a multi-threaded kernel, this means that a straightforward call to\nprintf()\nwill be executed by every thread, using that threadâs data as specified. Multiple versions of the output string will then appear at the host stream, once for each thread which encountered the\nprintf()\n.\nIt is up to the programmer to limit the output to a single thread if only a single output string is desired (see\nExamples\nfor an illustrative example).\nUnlike the C-standard\nprintf()\n, which returns the number of characters printed, CUDAâs\nprintf()\nreturns the number of arguments parsed. If no arguments follow the format string, 0 is returned. If the format string is NULL, -1 is returned. If an internal error occurs, -2 is returned.\n10.35.1.\nFormat Specifiers\nï\nAs for standard\nprintf()\n, format specifiers take the form:\n%[flags][width][.precision][size]type\nThe following fields are supported (see widely-available documentation for a complete description of all behaviors):\nFlags:\n'#'\n'\n'\n'0'\n'+'\n'-'\nWidth:\n'*'\n'0-9'\nPrecision:\n'0-9'\nSize:\n'h'\n'l'\n'll'\nType:\n\"%cdiouxXpeEfgGaAs\"\nNote that CUDAâs\nprintf()\nwill accept any combination of flag, width, precision, size and type, whether or not overall they form a valid format specifier. In other words, â\n%hd\nâ will be accepted and printf will expect a double-precision variable in the corresponding location in the argument list.\n10.35.2.\nLimitations\nï\nFinal formatting of the\nprintf()\noutput takes place on the host system. This means that the format string must be understood by the host-systemâs compiler and C library. Every effort has been made to ensure that the format specifiers supported by CUDAâs printf function form a universal subset from the most common host compilers, but exact behavior will be host-OS-dependent.\nAs described in\nFormat Specifiers\n,\nprintf()\nwill accept\nall\ncombinations of valid flags and types. This is because it cannot determine what will and will not be valid on the host system where the final output is formatted. The effect of this is that output may be undefined if the program emits a format string which contains invalid combinations.\nThe\nprintf()\ncommand can accept at most 32 arguments in addition to the format string. Additional arguments beyond this will be ignored, and the format specifier output as-is.\nOwing to the differing size of the\nlong\ntype on 64-bit Windows platforms (four bytes on 64-bit Windows platforms, eight bytes on other 64-bit platforms), a kernel which is compiled on a non-Windows 64-bit machine but then run on a win64 machine will see corrupted output for all format strings which include â\n%ld\nâ. It is recommended that the compilation platform matches the execution platform to ensure safety.\nThe output buffer for\nprintf()\nis set to a fixed size before kernel launch (see\nAssociated Host-Side API\n). It is circular and if more output is produced during kernel execution than can fit in the buffer, older output is overwritten. It is flushed only when one of these actions is performed:\nKernel launch via\n<<<>>>\nor\ncuLaunchKernel()\n(at the start of the launch, and if the CUDA_LAUNCH_BLOCKING environment variable is set to 1, at the end of the launch as well),\nSynchronization via\ncudaDeviceSynchronize()\n,\ncuCtxSynchronize()\n,\ncudaStreamSynchronize()\n,\ncuStreamSynchronize()\n,\ncudaEventSynchronize()\n, or\ncuEventSynchronize()\n,\nMemory copies via any blocking version of\ncudaMemcpy*()\nor\ncuMemcpy*()\n,\nModule loading/unloading via\ncuModuleLoad()\nor\ncuModuleUnload()\n,\nContext destruction via\ncudaDeviceReset()\nor\ncuCtxDestroy()\n.\nPrior to executing a stream callback added by\ncudaLaunchHostFunc\nor\ncuLaunchHostFunc\n.\nNote that the buffer is not flushed automatically when the program exits. The user must call\ncudaDeviceReset()\nor\ncuCtxDestroy()\nexplicitly, as shown in the examples below.\nInternally\nprintf()\nuses a shared data structure and so it is possible that calling\nprintf()\nmight change the order of execution of threads. In particular, a thread which calls\nprintf()\nmight take a longer execution path than one which does not call\nprintf()\n, and that path length is dependent upon the parameters of the\nprintf()\n. Note, however, that CUDA makes no guarantees of thread execution order except at explicit\n__syncthreads()\nbarriers, so it is impossible to tell whether execution order has been modified by\nprintf()\nor by other scheduling behavior in the hardware.\n10.35.3.\nAssociated Host-Side API\nï\nThe following API functions get and set the size of the buffer used to transfer the\nprintf()\narguments and internal metadata to the host (default is 1 megabyte):\ncudaDeviceGetLimit(size_t*\nsize,cudaLimitPrintfFifoSize)\ncudaDeviceSetLimit(cudaLimitPrintfFifoSize,\nsize_t\nsize)\n10.35.4.\nExamples\nï\nThe following code sample:\n#include\n<stdio.h>\n__global__\nvoid\nhelloCUDA\n(\nfloat\nf\n)\n{\nprintf\n(\n\"Hello thread %d, f=%f\n\\n\n\"\n,\nthreadIdx\n.\nx\n,\nf\n);\n}\nint\nmain\n()\n{\nhelloCUDA\n<<<\n1\n,\n5\n>>>\n(\n1.2345f\n);\ncudaDeviceSynchronize\n();\nreturn\n0\n;\n}\nwill output:\nHello thread 2, f=1.2345\nHello thread 1, f=1.2345\nHello thread 4, f=1.2345\nHello thread 0, f=1.2345\nHello thread 3, f=1.2345\nNotice how each thread encounters the\nprintf()\ncommand, so there are as many lines of output as there were threads launched in the grid. As expected, global values (i.e.,\nfloat\nf\n) are common between all threads, and local values (i.e.,\nthreadIdx.x\n) are distinct per-thread.\nThe following code sample:\n#include\n<stdio.h>\n__global__\nvoid\nhelloCUDA\n(\nfloat\nf\n)\n{\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\nprintf\n(\n\"Hello thread %d, f=%f\n\\n\n\"\n,\nthreadIdx\n.\nx\n,\nf\n)\n;\n}\nint\nmain\n()\n{\nhelloCUDA\n<<<\n1\n,\n5\n>>>\n(\n1.2345f\n);\ncudaDeviceSynchronize\n();\nreturn\n0\n;\n}\nwill output:\nHello thread 0, f=1.2345\nSelf-evidently, the\nif()\nstatement limits which threads will call\nprintf\n, so that only a single line of output is seen.\n10.36.\nDynamic Global Memory Allocation and Operations\nï\nDynamic global memory allocation and operations are only supported by devices of compute capability 2.x and higher.\n__host__\n__device__\nvoid\n*\nmalloc\n(\nsize_t\nsize\n);\n__device__\nvoid\n*\n__nv_aligned_device_malloc\n(\nsize_t\nsize\n,\nsize_t\nalign\n);\n__host__\n__device__\nvoid\nfree\n(\nvoid\n*\nptr\n);\nallocate and free memory dynamically from a fixed-size heap in global memory.\n__host__\n__device__\nvoid\n*\nmemcpy\n(\nvoid\n*\ndest\n,\nconst\nvoid\n*\nsrc\n,\nsize_t\nsize\n);\ncopy\nsize\nbytes from the memory location pointed by\nsrc\nto the memory location pointed by\ndest\n.\n__host__\n__device__\nvoid\n*\nmemset\n(\nvoid\n*\nptr\n,\nint\nvalue\n,\nsize_t\nsize\n);\nset\nsize\nbytes of memory block pointed by\nptr\nto\nvalue\n(interpreted as an unsigned char).\nThe CUDA in-kernel\nmalloc()\nfunction allocates at least\nsize\nbytes from the device heap and returns a pointer to the allocated memory or NULL if insufficient memory exists to fulfill the request. The returned pointer is guaranteed to be aligned to a 16-byte boundary.\nThe CUDA in-kernel\n__nv_aligned_device_malloc()\nfunction allocates at least\nsize\nbytes from the device heap and returns a pointer to the allocated memory or NULL if insufficient memory exists to fulfill the requested size or alignment. The address of the allocated memory will be a multiple of\nalign\n.\nalign\nmust be a non-zero power of 2.\nThe CUDA in-kernel\nfree()\nfunction deallocates the memory pointed to by\nptr\n, which must have been returned by a previous call to\nmalloc()\nor\n__nv_aligned_device_malloc()\n. If\nptr\nis NULL, the call to\nfree()\nis ignored. Repeated calls to\nfree()\nwith the same\nptr\nhas undefined behavior.\nThe memory allocated by a given CUDA thread via\nmalloc()\nor\n__nv_aligned_device_malloc()\nremains allocated for the lifetime of the CUDA context, or until it is explicitly released by a call to\nfree()\n. It can be used by any other CUDA threads even from subsequent kernel launches. Any CUDA thread may free memory allocated by another thread, but care should be taken to ensure that the same pointer is not freed more than once.\n10.36.1.\nHeap Memory Allocation\nï\nThe device memory heap has a fixed size that must be specified before any program using\nmalloc()\n,\n__nv_aligned_device_malloc()\nor\nfree()\nis loaded into the context. A default heap of eight megabytes is allocated if any program uses\nmalloc()\nor\n__nv_aligned_device_malloc()\nwithout explicitly specifying the heap size.\nThe following API functions get and set the heap size:\ncudaDeviceGetLimit(size_t*\nsize,\ncudaLimitMallocHeapSize)\ncudaDeviceSetLimit(cudaLimitMallocHeapSize,\nsize_t\nsize)\nThe heap size granted will be at least\nsize\nbytes.\ncuCtxGetLimit()\nand\ncudaDeviceGetLimit()\nreturn the currently requested heap size.\nThe actual memory allocation for the heap occurs when a module is loaded into the context, either explicitly via the CUDA driver API (see\nModule\n), or implicitly via the CUDA runtime API (see\nCUDA Runtime\n). If the memory allocation fails, the module load will generate a\nCUDA_ERROR_SHARED_OBJECT_INIT_FAILED\nerror.\nHeap size cannot be changed once a module load has occurred and it does not resize dynamically according to need.\nMemory reserved for the device heap is in addition to memory allocated through host-side CUDA API calls such as\ncudaMalloc()\n.\n10.36.2.\nInteroperability with Host Memory API\nï\nMemory allocated via device\nmalloc()\nor\n__nv_aligned_device_malloc()\ncannot be freed using the runtime (i.e., by calling any of the free memory functions from\nDevice Memory\n).\nSimilarly, memory allocated via the runtime (i.e., by calling any of the memory allocation functions from\nDevice Memory\n) cannot be freed via\nfree()\n.\nIn addition, memory allocated by a call to\nmalloc()\nor\n__nv_aligned_device_malloc()\nin device code cannot be used in any runtime or driver API calls (i.e. cudaMemcpy, cudaMemset, etc).\n10.36.3.\nExamples\nï\n10.36.3.1.\nPer Thread Allocation\nï\nThe following code sample:\n#include\n<stdlib.h>\n#include\n<stdio.h>\n__global__\nvoid\nmallocTest\n()\n{\nsize_t\nsize\n=\n123\n;\nchar\n*\nptr\n=\n(\nchar\n*\n)\nmalloc\n(\nsize\n);\nmemset\n(\nptr\n,\n0\n,\nsize\n);\nprintf\n(\n\"Thread %d got pointer: %p\n\\n\n\"\n,\nthreadIdx\n.\nx\n,\nptr\n);\nfree\n(\nptr\n);\n}\nint\nmain\n()\n{\n// Set a heap size of 128 megabytes. Note that this must\n// be done before any kernel is launched.\ncudaDeviceSetLimit\n(\ncudaLimitMallocHeapSize\n,\n128\n*\n1024\n*\n1024\n);\nmallocTest\n<<<\n1\n,\n5\n>>>\n();\ncudaDeviceSynchronize\n();\nreturn\n0\n;\n}\nwill output:\nThread\n0\ngot\npointer\n:\n00057020\nThread\n1\ngot\npointer\n:\n000570\n8\nc\nThread\n2\ngot\npointer\n:\n000570f\n8\nThread\n3\ngot\npointer\n:\n00057164\nThread\n4\ngot\npointer\n:\n000571\nd0\nNotice how each thread encounters the\nmalloc()\nand\nmemset()\ncommands and so receives and initializes its own allocation. (Exact pointer values will vary: these are illustrative.)\n10.36.3.2.\nPer Thread Block Allocation\nï\n#include\n<stdlib.h>\n__global__\nvoid\nmallocTest\n()\n{\n__shared__\nint\n*\ndata\n;\n// The first thread in the block does the allocation and then\n// shares the pointer with all other threads through shared memory,\n// so that access can easily be coalesced.\n// 64 bytes per thread are allocated.\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\nsize_t\nsize\n=\nblockDim\n.\nx\n*\n64\n;\ndata\n=\n(\nint\n*\n)\nmalloc\n(\nsize\n);\n}\n__syncthreads\n();\n// Check for failure\nif\n(\ndata\n==\nNULL\n)\nreturn\n;\n// Threads index into the memory, ensuring coalescence\nint\n*\nptr\n=\ndata\n;\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n64\n;\n++\ni\n)\nptr\n[\ni\n*\nblockDim\n.\nx\n+\nthreadIdx\n.\nx\n]\n=\nthreadIdx\n.\nx\n;\n// Ensure all threads complete before freeing\n__syncthreads\n();\n// Only one thread may free the memory!\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\nfree\n(\ndata\n);\n}\nint\nmain\n()\n{\ncudaDeviceSetLimit\n(\ncudaLimitMallocHeapSize\n,\n128\n*\n1024\n*\n1024\n);\nmallocTest\n<<<\n10\n,\n128\n>>>\n();\ncudaDeviceSynchronize\n();\nreturn\n0\n;\n}\n10.36.3.3.\nAllocation Persisting Between Kernel Launches\nï\n#include\n<stdlib.h>\n#include\n<stdio.h>\n#define NUM_BLOCKS 20\n__device__\nint\n*\ndataptr\n[\nNUM_BLOCKS\n];\n// Per-block pointer\n__global__\nvoid\nallocmem\n()\n{\n// Only the first thread in the block does the allocation\n// since we want only one allocation per block.\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\ndataptr\n[\nblockIdx\n.\nx\n]\n=\n(\nint\n*\n)\nmalloc\n(\nblockDim\n.\nx\n*\n4\n);\n__syncthreads\n();\n// Check for failure\nif\n(\ndataptr\n[\nblockIdx\n.\nx\n]\n==\nNULL\n)\nreturn\n;\n// Zero the data with all threads in parallel\ndataptr\n[\nblockIdx\n.\nx\n][\nthreadIdx\n.\nx\n]\n=\n0\n;\n}\n// Simple example: store thread ID into each element\n__global__\nvoid\nusemem\n()\n{\nint\n*\nptr\n=\ndataptr\n[\nblockIdx\n.\nx\n];\nif\n(\nptr\n!=\nNULL\n)\nptr\n[\nthreadIdx\n.\nx\n]\n+=\nthreadIdx\n.\nx\n;\n}\n// Print the content of the buffer before freeing it\n__global__\nvoid\nfreemem\n()\n{\nint\n*\nptr\n=\ndataptr\n[\nblockIdx\n.\nx\n];\nif\n(\nptr\n!=\nNULL\n)\nprintf\n(\n\"Block %d, Thread %d: final value = %d\n\\n\n\"\n,\nblockIdx\n.\nx\n,\nthreadIdx\n.\nx\n,\nptr\n[\nthreadIdx\n.\nx\n]);\n// Only free from one thread!\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\nfree\n(\nptr\n);\n}\nint\nmain\n()\n{\ncudaDeviceSetLimit\n(\ncudaLimitMallocHeapSize\n,\n128\n*\n1024\n*\n1024\n);\n// Allocate memory\nallocmem\n<<<\nNUM_BLOCKS\n,\n10\n>>>\n();\n// Use memory\nusemem\n<<<\nNUM_BLOCKS\n,\n10\n>>>\n();\nusemem\n<<<\nNUM_BLOCKS\n,\n10\n>>>\n();\nusemem\n<<<\nNUM_BLOCKS\n,\n10\n>>>\n();\n// Free memory\nfreemem\n<<<\nNUM_BLOCKS\n,\n10\n>>>\n();\ncudaDeviceSynchronize\n();\nreturn\n0\n;\n}\n10.37.\nExecution Configuration\nï\nAny call to a\n__global__\nfunction must specify the\nexecution configuration\nfor that call. The execution configuration defines the dimension of the grid and blocks that will be used to execute the function on the device, as well as the associated stream (see\nCUDA Runtime\nfor a description of streams).\nThe execution configuration is specified by inserting an expression of the form\n<<<\nDg,\nDb,\nNs,\nS\n>>>\nbetween the function name and the parenthesized argument list, where:\nDg\nis of type\ndim3\n(see\ndim3\n) and specifies the dimension and size of the grid, such that\nDg.x\n*\nDg.y\n*\nDg.z\nequals the number of blocks being launched;\nDb\nis of type\ndim3\n(see\ndim3\n) and specifies the dimension and size of each block, such that\nDb.x\n*\nDb.y\n*\nDb.z\nequals the number of threads per block;\nNs\nis of type\nsize_t\nand specifies the number of bytes in shared memory that is dynamically allocated per block for this call in addition to the statically allocated memory; this dynamically allocated memory is used by any of the variables declared as an external array as mentioned in\n__shared__\n;\nNs\nis an optional argument which defaults to 0;\nS\nis of type\ncudaStream_t\nand specifies the associated stream;\nS\nis an optional argument which defaults to 0.\nAs an example, a function declared as\n__global__\nvoid\nFunc\n(\nfloat\n*\nparameter\n);\nmust be called like this:\nFunc\n<<<\nDg\n,\nDb\n,\nNs\n>>>\n(\nparameter\n);\nThe arguments to the execution configuration are evaluated before the actual function arguments.\nThe function call will fail if\nDg\nor\nDb\nare greater than the maximum sizes allowed for the device as specified in\nCompute Capabilities\n, or if\nNs\nis greater than the maximum amount of shared memory available on the device, minus the amount of shared memory required for static allocation.\nCompute capability 9.0 and above allows users to specify compile time thread block cluster dimensions, so that the kernel can use the cluster hierarchy in CUDA. Compile time cluster dimension can be specified using\n__cluster_dims__([x,\n[y,\n[z]]])\n. The example below shows compile time cluster size of 2 in X dimension and 1 in Y and Z dimension.\n__global__\nvoid\n__cluster_dims__\n(\n2\n,\n1\n,\n1\n)\nFunc\n(\nfloat\n*\nparameter\n);\nThe default form of\n__cluster_dims__()\nspecifies that a kernel is to be launched as a cluster grid. By not specifying a cluster dimension, the user is free to specify the dimension at launch time. Not specifying a dimension at launch time will result in a launch time error.\nThread block cluster dimensions can also be specified at runtime and kernel with the cluster can be launched using\ncudaLaunchKernelEx\nAPI. The API takes a configuration argument of type\ncudaLaunchConfig_t\n, kernel function pointer and kernel arguments. Runtime kernel configuration is shown in the example below.\n__global__\nvoid\nFunc\n(\nfloat\n*\nparameter\n);\n// Kernel invocation with runtime cluster size\n{\ncudaLaunchConfig_t\nconfig\n=\n{\n0\n};\n// The grid dimension is not affected by cluster launch, and is still enumerated\n// using number of blocks.\n// The grid dimension should be a multiple of cluster size.\nconfig\n.\ngridDim\n=\nDg\n;\nconfig\n.\nblockDim\n=\nDb\n;\nconfig\n.\ndynamicSmemBytes\n=\nNs\n;\ncudaLaunchAttribute\nattribute\n[\n1\n];\nattribute\n[\n0\n].\nid\n=\ncudaLaunchAttributeClusterDimension\n;\nattribute\n[\n0\n].\nval\n.\nclusterDim\n.\nx\n=\n2\n;\n// Cluster size in X-dimension\nattribute\n[\n0\n].\nval\n.\nclusterDim\n.\ny\n=\n1\n;\nattribute\n[\n0\n].\nval\n.\nclusterDim\n.\nz\n=\n1\n;\nconfig\n.\nattrs\n=\nattribute\n;\nconfig\n.\nnumAttrs\n=\n1\n;\nfloat\n*\nparameter\n;\ncudaLaunchKernelEx\n(\n&\nconfig\n,\nFunc\n,\nparameter\n);\n}\n10.38.\nLaunch Bounds\nï\nAs discussed in detail in\nMultiprocessor Level\n, the fewer registers a kernel uses, the more threads and thread blocks are likely to reside on a multiprocessor, which can improve performance.\nTherefore, the compiler uses heuristics to minimize register usage while keeping register spilling (see\nDevice Memory Accesses\n) and instruction count to a minimum. An application can optionally aid these heuristics by providing additional information to the compiler in the form of launch bounds that are specified using the\n__launch_bounds__()\nqualifier in the definition of a\n__global__\nfunction:\n__global__\nvoid\n__launch_bounds__\n(\nmaxThreadsPerBlock\n,\nminBlocksPerMultiprocessor\n,\nmaxBlocksPerCluster\n)\nMyKernel\n(...)\n{\n...\n}\nmaxThreadsPerBlock\nspecifies the maximum number of threads per block with which the application will ever launch\nMyKernel()\n; it compiles to the\n.maxntid\nPTX\ndirective.\nminBlocksPerMultiprocessor\nis optional and specifies the desired minimum number of resident blocks per multiprocessor; it compiles to the\n.minnctapersm\nPTX\ndirective.\nmaxBlocksPerCluster\nis optional and specifies the desired maximum number thread blocks per cluster with which the application will ever launch\nMyKernel()\n; it compiles to the\n.maxclusterrank\nPTX\ndirective.\nIf launch bounds are specified, the compiler first derives from them the upper limit\nL\non the number of registers the kernel should use to ensure that\nminBlocksPerMultiprocessor\nblocks (or a single block if\nminBlocksPerMultiprocessor\nis not specified) of\nmaxThreadsPerBlock\nthreads can reside on the multiprocessor (see\nHardware Multithreading\nfor the relationship between the number of registers used by a kernel and the number of registers allocated per block). The compiler then optimizes register usage in the following way:\nIf the initial register usage is higher than\nL\n, the compiler reduces it further until it becomes less or equal to\nL\n, usually at the expense of more local memory usage and/or higher number of instructions;\nIf the initial register usage is lower than\nL\nIf\nmaxThreadsPerBlock\nis specified and\nminBlocksPerMultiprocessor\nis not, the compiler uses\nmaxThreadsPerBlock\nto determine the register usage thresholds for the transitions between\nn\nand\nn+1\nresident blocks (i.e., when using one less register makes room for an additional resident block as in the example of\nMultiprocessor Level\n) and then applies similar heuristics as when no launch bounds are specified;\nIf both\nminBlocksPerMultiprocessor\nand\nmaxThreadsPerBlock\nare specified, the compiler may increase register usage as high as\nL\nto reduce the number of instructions and better hide single thread instruction latency.\nA kernel will fail to launch if it is executed with more threads per block than its launch bound\nmaxThreadsPerBlock\n.\nA kernel will fail to launch if it is executed with more thread blocks per cluster than its launch bound\nmaxBlocksPerCluster\n.\nPer thread resources required by a CUDA kernel might limit the maximum block size in an unwanted way. In order to maintain forward compatibility to future hardware and toolkits and to ensure that at least one thread block can run on an SM, developers should include the single argument\n__launch_bounds__(maxThreadsPerBlock)\nwhich specifies the largest block size that the kernel will be launched with. Failure to do so could lead to âtoo many resources requested for launchâ errors. Providing the two argument version of\n__launch_bounds__(maxThreadsPerBlock,minBlocksPerMultiprocessor)\ncan improve performance in some cases. The right value for\nminBlocksPerMultiprocessor\nshould be determined using a detailed per kernel analysis.\nOptimal launch bounds for a given kernel will usually differ across major architecture revisions. The sample code below shows how this is typically handled in device code using the\n__CUDA_ARCH__\nmacro introduced in\nApplication Compatibility\n.\n#define THREADS_PER_BLOCK          256\n#if __CUDA_ARCH__ >= 200\n#define MY_KERNEL_MAX_THREADS  (2 * THREADS_PER_BLOCK)\n#define MY_KERNEL_MIN_BLOCKS   3\n#else\n#define MY_KERNEL_MAX_THREADS  THREADS_PER_BLOCK\n#define MY_KERNEL_MIN_BLOCKS   2\n#endif\n// Device code\n__global__\nvoid\n__launch_bounds__\n(\nMY_KERNEL_MAX_THREADS\n,\nMY_KERNEL_MIN_BLOCKS\n)\nMyKernel\n(...)\n{\n...\n}\nIn the common case where\nMyKernel\nis invoked with the maximum number of threads per block (specified as the first parameter of\n__launch_bounds__()\n), it is tempting to use\nMY_KERNEL_MAX_THREADS\nas the number of threads per block in the execution configuration:\n// Host code\nMyKernel\n<<<\nblocksPerGrid\n,\nMY_KERNEL_MAX_THREADS\n>>>\n(...);\nThis will not work however since\n__CUDA_ARCH__\nis undefined in host code as mentioned in\nApplication Compatibility\n, so\nMyKernel\nwill launch with 256 threads per block even when\n__CUDA_ARCH__\nis greater or equal to 200. Instead the number of threads per block should be determined:\nEither at compile time using a macro that does not depend on\n__CUDA_ARCH__\n, for example\n// Host code\nMyKernel\n<<<\nblocksPerGrid\n,\nTHREADS_PER_BLOCK\n>>>\n(...);\nOr at runtime based on the compute capability\n// Host code\ncudaGetDeviceProperties\n(\n&\ndeviceProp\n,\ndevice\n);\nint\nthreadsPerBlock\n=\n(\ndeviceProp\n.\nmajor\n>=\n2\n?\n2\n*\nTHREADS_PER_BLOCK\n:\nTHREADS_PER_BLOCK\n);\nMyKernel\n<<<\nblocksPerGrid\n,\nthreadsPerBlock\n>>>\n(...);\nRegister usage is reported by the\n--ptxas-options=-v\ncompiler option. The number of resident blocks can be derived from the occupancy reported by the CUDA profiler (see\nDevice Memory Accesses\nfor a definition of occupancy).\n10.39.\nMaximum Number of Registers per Thread\nï\nTo provide a mechanism for low-level performance tuning, CUDA C++ provides the\n__maxnreg__()\nfunction qualifier to pass performance tuning information to the backend optimizing compiler. The\n__maxnreg__()\nqualifier specifies the maximum number of registers to be allocated to a single thread in a thread block. In the definition of a\n__global__\nfunction:\n__global__\nvoid\n__maxnreg__\n(\nmaxNumberRegistersPerThread\n)\nMyKernel\n(...)\n{\n...\n}\nmaxNumberRegistersPerThread\nspecifies the maximum number of registers to be allocated to a single thread in a thread block of the kernel\nMyKernel()\n; it compiles to the\n.maxnreg\nPTX\ndirective.\nThe\n__launch_bounds__()\nand\n__maxnreg__()\nqualifiers cannot be applied to the same kernel.\nRegister usage can also be controlled for all\n__global__\nfunctions in a file using the\nmaxrregcount\ncompiler option. The value of\nmaxrregcount\nis ignored for functions with the\n__maxnreg__\nqualifier.\n10.40.\n#pragma unroll\nï\nBy default, the compiler unrolls small loops with a known trip count. The\n#pragma\nunroll\ndirective however can be used to control unrolling of any given loop. It must be placed immediately before the loop and only applies to that loop. It is optionally followed by an integral constant expression (ICE)\n6\n. If the ICE is absent, the loop will be completely unrolled if its trip count is constant. If the ICE evaluates to 1, the compiler will not unroll the loop. The pragma will be ignored if the ICE evaluates to a non-positive integer or to an integer greater than the maximum value representable by the\nint\ndata type.\nExamples:\nstruct\nS1_t\n{\nstatic\nconst\nint\nvalue\n=\n4\n;\n};\ntemplate\n<\nint\nX\n,\ntypename\nT2\n>\n__device__\nvoid\nfoo\n(\nint\n*\np1\n,\nint\n*\np2\n)\n{\n// no argument specified, loop will be completely unrolled\n#pragma unroll\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n12\n;\n++\ni\n)\np1\n[\ni\n]\n+=\np2\n[\ni\n]\n*\n2\n;\n// unroll value = 8\n#pragma unroll (X+1)\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n12\n;\n++\ni\n)\np1\n[\ni\n]\n+=\np2\n[\ni\n]\n*\n4\n;\n// unroll value = 1, loop unrolling disabled\n#pragma unroll 1\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n12\n;\n++\ni\n)\np1\n[\ni\n]\n+=\np2\n[\ni\n]\n*\n8\n;\n// unroll value = 4\n#pragma unroll (T2::value)\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n12\n;\n++\ni\n)\np1\n[\ni\n]\n+=\np2\n[\ni\n]\n*\n16\n;\n}\n__global__\nvoid\nbar\n(\nint\n*\np1\n,\nint\n*\np2\n)\n{\nfoo\n<\n7\n,\nS1_t\n>\n(\np1\n,\np2\n);\n}\n10.41.\nSIMD Video Instructions\nï\nPTX ISA version 3.0 includes SIMD (Single Instruction, Multiple Data) video instructions which operate on pairs of 16-bit values and quads of 8-bit values. These are available on devices of compute capability 3.0.\nThe SIMD video instructions are:\nvadd2, vadd4\nvsub2, vsub4\nvavrg2, vavrg4\nvabsdiff2, vabsdiff4\nvmin2, vmin4\nvmax2, vmax4\nvset2, vset4\nPTX instructions, such as the SIMD video instructions, can be included in CUDA programs by way of the assembler,\nasm()\n, statement.\nThe basic syntax of an\nasm()\nstatement is:\nasm\n(\n\"template-string\"\n:\n\"constraint\"\n(\noutput\n)\n:\n\"constraint\"\n(\ninput\n)\n\"));\nAn example of using the\nvabsdiff4\nPTX instruction is:\nasm\n(\n\"vabsdiff4.u32.u32.u32.add\"\n\" %0, %1, %2, %3;\"\n:\n\"=r\"\n(\nresult\n)\n:\n\"r\"\n(\nA\n),\n\"r\"\n(\nB\n),\n\"r\"\n(\nC\n));\nThis uses the\nvabsdiff4\ninstruction to compute an integer quad byte SIMD sum of absolute differences. The absolute difference value is computed for each byte of the unsigned integers A and B in SIMD fashion. The optional accumulate operation (\n.add\n) is specified to sum these differences.\nRefer to the document âUsing Inline PTX Assembly in CUDAâ for details on using the assembly statement in your code. Refer to the PTX ISA documentation (âParallel Thread Execution ISA Version 3.0â for example) for details on the PTX instructions for the version of PTX that you are using.\n10.42.\nDiagnostic Pragmas\nï\nThe following pragmas may be used to control the error severity used when a given diagnostic message is issued.\n#pragma nv_diag_suppress\n#pragma nv_diag_warning\n#pragma nv_diag_error\n#pragma nv_diag_default\n#pragma nv_diag_once\nUses of these pragmas have the following form:\n#pragma nv_diag_xxx error_number, error_number ...\nThe diagnostic affected is specified using an error number showed in a warning message. Any diagnostic may be overridden to be an error, but only warnings may have their severity suppressed or be restored to a warning after being promoted to an error. The\nnv_diag_default\npragma is used to return the severity of a diagnostic to the one that was in effect before any pragmas were issued (i.e., the normal severity of the message as modified by any command-line options). The following example suppresses the\n\"declared\nbut\nnever\nreferenced\"\nwarning on the declaration of\nfoo\n:\n#pragma nv_diag_suppress 177\nvoid\nfoo\n()\n{\nint\ni\n=\n0\n;\n}\n#pragma nv_diag_default 177\nvoid\nbar\n()\n{\nint\ni\n=\n0\n;\n}\nThe following pragmas may be used to save and restore the current diagnostic pragma state:\n#pragma nv_diagnostic push\n#pragma nv_diagnostic pop\nExamples:\n#pragma nv_diagnostic push\n#pragma nv_diag_suppress 177\nvoid\nfoo\n()\n{\nint\ni\n=\n0\n;\n}\n#pragma nv_diagnostic pop\nvoid\nbar\n()\n{\nint\ni\n=\n0\n;\n}\nNote that the pragmas only affect the nvcc CUDA frontend compiler; they have no effect on the host compiler.\nRemoval Notice: The support of diagnostic pragmas without\nnv_\nprefix are removed from CUDA 12.0, if the pragmas are inside the device code, warning\nunrecognized\n#pragma\nin\ndevice\ncode\nwill be emitted, otherwise they will be passed to the host compiler. If they are intended for CUDA code, use the pragmas with\nnv_\nprefix instead.\n4\nWhen the enclosing __host__ function is a template, nvcc may currently fail to issue a diagnostic message in some cases; this behavior may change in the future.\n5\nThe intent is to prevent the host compiler from encountering the call to the function if the host compiler does not support it.\n6\n(\n1\n,\n2\n,\n3\n)\nSee the C++ Standard for definition of integral constant expression.\n10.43.\nCustom ABI Pragmas\nï\nThe\n#pragma\nnv_abi\ndirective enables applications compiled in separate compilation mode to achieve performance similar to that of whole program compilation.\nThe syntax for using this pragma is as follows, where ICE refers to any integral constant expression (ICE):\n6\n.\n#pragma nv_abi preserve_n_data(ICE) preserve_n_control(ICE)\nNote, the arguments that follow\n#pragma\nnv_abi\nare optional and can be provided in any order; however, at least one argument is required.\nThe\npreserve_n\narguments set a limit on the number of registers preserved during a function call:\npreserve_n_data(ICE)\nlimits the number of data registers, and\npreserve_n_control(ICE)\nlimits the number of control registers.\n#pragma\nnv_abi\ncan be placed immediately before a device function declaration or definition. Alternatively, it can be placed directly before an indirect function call within a C++ expression statement inside a device function. Note, indirect function calls to free functions are supported, but indirect calls through function argument references or class member functions are not.\nWhen the pragma is applied to a device function declaration or definition, it modifies the custom ABI properties for any calls to that function. When placed at an indirect function call site, the pragma affects the ABI properties for that indirect function call. The key point is that unlike direct function calls, where you can place the pragma before a function declaration or definition,\n#pragma\nnv_abi\nonly affects indirect function calls when the pragma is placed before a call site.\nAs shown in the following example, we have two device functions,\nfoo()\nand\nbar()\n. In this example the pragma is placed before the call site of the function pointer fptr to modify the ABI properties of the indirect function call. Notice that placing the pragma before the direct call does not affect the ABI properties of the call. To alter the ABI properties of a direct function call, the pragma must be placed before the function declaration or definition.\n__device__\nint\nfoo\n()\n{\nint\nvalue\n{\n0\n};\n...\nreturn\nvalue\n;\n}\n__device__\nint\nbar\n()\n{\nint\nvalue\n{\n0\n};\n...\nreturn\nvalue\n;\n}\n__device__\nvoid\nbaz\n()\n{\nint\nresult\n{\n0\n};\nint\n(\n*\nfptr\n)()\n=\nfoo\n;\n// function pointer\n#pragma nv_abi preserve_n_data(16) preserve_n_control(8)\nresult\n=\nfptr\n();\n// The pragma affects the indirect call to foo() via fptr\n#pragma nv_abi preserve_n_data(16) preserve_n_control(8)\nresult\n=\n(\n*\nfptr\n)();\n// Alternate syntax for the indirect call to foo()\n#pragma nv_abi preserve_n_data(16) preserve_n_control(8)\nresult\n+=\nbar\n();\n// The pragma does NOT affect the direct call to bar()\n}\nAs shown in the following example, to modify direct function calls, you must apply the pragma to the function declaration or definition.\n#pragma nv_abi preserve_n_data(16)\n__device__\nvoid\nfoo\n();\nNote that a program is ill-formed if the pragma arguments for a function declaration and its corresponding definition do not match.\n10.44.\nCUDA C++ Memory Model\nï\nThe CUDA C++ Memory Model extends the ISO C++ Memory Model as documented in the\nCUDA C++ Memory Model documentation\n.\n10.45.\nCUDA C++ Execution Model\nï\nThe CUDA C++ Exeuction Model extends the ISO C++ execution model as documented in the\nCUDA C++ Execution Model documentation\n.\n11.\nCooperative Groups\nï\n11.1.\nIntroduction\nï\nCooperative Groups is an extension to the CUDA programming model, introduced in CUDA 9, for organizing groups of communicating threads. Cooperative Groups allows developers to express the granularity at which threads are communicating, helping them to express richer, more efficient parallel decompositions.\nHistorically, the CUDA programming model has provided a single, simple construct for synchronizing cooperating threads: a barrier across all threads of a thread block, as implemented with the\n__syncthreads()\nintrinsic function. However, programmers would like to define and synchronize groups of threads at other granularities to enable greater performance, design flexibility, and software reuse in the form of âcollectiveâ group-wide function interfaces. In an effort to express broader patterns of parallel interaction, many performance-oriented programmers have resorted to writing their own ad hoc and unsafe primitives for synchronizing threads within a single warp, or across sets of thread blocks running on a single GPU. Whilst the performance improvements achieved have often been valuable, this has resulted in an ever-growing collection of brittle code that is expensive to write, tune, and maintain over time and across GPU generations. Cooperative Groups addresses this by providing a safe and future-proof mechanism to enable performant code.\n11.2.\nWhatâs New in Cooperative Groups\nï\n11.2.1.\nCUDA 13.0\nï\nmulti_grid_group\nwas removed.\n11.2.2.\nCUDA 12.2\nï\nbarrier_arrive\nand\nbarrier_wait\nmember functions were added for\ngrid_group\nand\nthread_block\n. Description of the API is available\nhere\n.\n11.2.3.\nCUDA 12.1\nï\ninvoke_one and invoke_one_broadcast\nAPIs were added.\n11.2.4.\nCUDA 12.0\nï\nThe following experimental APIs are now moved to the main namespace:\nasynchronous reduce and scan update added in CUDA 11.7\nthread_block_tile\nlarger than 32 added in CUDA 11.1\nIt is no longer required to provide memory using the\nblock_tile_memory\nobject in order to create these large tiles on Compute Capability 8.0 or higher.\n11.3.\nProgramming Model Concept\nï\nThe Cooperative Groups programming model describes synchronization patterns both within and across CUDA thread blocks. It provides both the means for applications to define their own groups of threads, and the interfaces to synchronize them. It also provides new launch APIs that enforce certain restrictions and therefore can guarantee the synchronization will work. These primitives enable new patterns of cooperative parallelism within CUDA, including producer-consumer parallelism, opportunistic parallelism, and global synchronization across the entire Grid.\nThe Cooperative Groups programming model consists of the following elements:\nData types for representing groups of cooperating threads;\nOperations to obtain implicit groups defined by the CUDA launch API (e.g., thread blocks);\nCollectives for partitioning existing groups into new groups;\nCollective Algorithms for data movement and manipulation (e.g. memcpy_async, reduce, scan);\nAn operation to synchronize all threads within the group;\nOperations to inspect the group properties;\nCollectives that expose low-level, group-specific and often HW accelerated, operations.\nThe main concept in Cooperative Groups is that of objects naming the set of threads that are part of it. This expression of groups as first-class program objects improves software composition, since collective functions can receive an explicit object representing the group of participating threads. This object also makes programmer intent explicit, which eliminates unsound architectural assumptions that result in brittle code, undesirable restrictions upon compiler optimizations, and better compatibility with new GPU generations.\nTo write efficient code, its best to use specialized groups (going generic loses a lot of compile time optimizations), and pass these group objects by reference to functions that intend to use these threads in some cooperative fashion.\nCooperative Groups requires CUDA 9.0 or later. To use Cooperative Groups, include the header file:\n// Primary header is compatible with pre-C++11, collective algorithm headers require C++11\n#include\n<cooperative_groups.h>\n// Optionally include for memcpy_async() collective\n#include\n<cooperative_groups/memcpy_async.h>\n// Optionally include for reduce() collective\n#include\n<cooperative_groups/reduce.h>\n// Optionally include for inclusive_scan() and exclusive_scan() collectives\n#include\n<cooperative_groups/scan.h>\nand use the Cooperative Groups namespace:\nusing\nnamespace\ncooperative_groups\n;\n// Alternatively use an alias to avoid polluting the namespace with collective algorithms\nnamespace\ncg\n=\ncooperative_groups\n;\nThe code can be compiled in a normal way using nvcc, however if you wish to use memcpy_async, reduce or scan functionality and your host compilerâs default dialect is not C++11 or higher, then you must add\n--std=c++11\nto the command line.\n11.3.1.\nComposition Example\nï\nTo illustrate the concept of groups, this example attempts to perform a block-wide sum reduction. Previously, there were hidden constraints on the implementation when writing this code:\n__device__\nint\nsum\n(\nint\n*\nx\n,\nint\nn\n)\n{\n// ...\n__syncthreads\n();\nreturn\ntotal\n;\n}\n__global__\nvoid\nparallel_kernel\n(\nfloat\n*\nx\n)\n{\n// ...\n// Entire thread block must call sum\nsum\n(\nx\n,\nn\n);\n}\nAll threads in the thread block must arrive at the\n__syncthreads()\nbarrier, however, this constraint is hidden from the developer who might want to use\nsum(â¦)\n. With Cooperative Groups, a better way of writing this would be:\n__device__\nint\nsum\n(\nconst\nthread_block\n&\ng\n,\nint\n*\nx\n,\nint\nn\n)\n{\n// ...\ng\n.\nsync\n()\nreturn\ntotal\n;\n}\n__global__\nvoid\nparallel_kernel\n(...)\n{\n// ...\n// Entire thread block must call sum\nthread_block\ntb\n=\nthis_thread_block\n();\nsum\n(\ntb\n,\nx\n,\nn\n);\n// ...\n}\n11.4.\nGroup Types\nï\n11.4.1.\nImplicit Groups\nï\nImplicit groups represent the launch configuration of the kernel. Regardless of how your kernel is written, it always has a set number of threads, blocks and block dimensions, a single grid and grid dimensions. In addition, if the multi-device cooperative launch API is used, it can have multiple grids (single grid per device). These groups provide a starting point for decomposition into finer grained groups which are typically HW accelerated and are more specialized for the problem the developer is solving.\nAlthough you can create an implicit group anywhere in the code, it is dangerous to do so. Creating a handle for an implicit group is a collective operationâall threads in the group must participate. If the group was created in a conditional branch that not all threads reach, this can lead to deadlocks or data corruption. For this reason, it is recommended that you create a handle for the implicit group upfront (as early as possible, before any branching has occurred) and use that handle throughout the kernel. Group handles must be initialized at declaration time (there is no default constructor) for the same reason and copy-constructing them is discouraged.\n11.4.1.1.\nThread Block Group\nï\nAny CUDA programmer is already familiar with a certain group of threads: the thread block. The Cooperative Groups extension introduces a new datatype,\nthread_block\n, to explicitly represent this concept within the kernel.\nclass\nthread_block;\nConstructed via:\nthread_block\ng\n=\nthis_thread_block\n();\nPublic Member Functions:\nstatic\nvoid\nsync()\n: Synchronize the threads named in the group, equivalent to\ng.barrier_wait(g.barrier_arrive())\nthread_block::arrival_token\nbarrier_arrive()\n: Arrive on the thread_block barrier, returns a token that needs to be passed into\nbarrier_wait()\n. More details\nhere\nvoid\nbarrier_wait(thread_block::arrival_token&&\nt)\n: Wait on the\nthread_block\nbarrier, takes arrival token returned from\nbarrier_arrive()\nas an rvalue reference. More details\nhere\nstatic\nunsigned\nint\nthread_rank()\n: Rank of the calling thread within [0, num_threads)\nstatic\ndim3\ngroup_index()\n: 3-Dimensional index of the block within the launched grid\nstatic\ndim3\nthread_index()\n: 3-Dimensional index of the thread within the launched block\nstatic\ndim3\ndim_threads()\n: Dimensions of the launched block in units of threads\nstatic\nunsigned\nint\nnum_threads()\n: Total number of threads in the group\nLegacy member functions (aliases):\nstatic\nunsigned\nint\nsize()\n: Total number of threads in the group (alias of\nnum_threads()\n)\nstatic\ndim3\ngroup_dim()\n: Dimensions of the launched block (alias of\ndim_threads()\n)\nExample:\n/// Loading an integer from global into shared memory\n__global__\nvoid\nkernel\n(\nint\n*\nglobalInput\n)\n{\n__shared__\nint\nx\n;\nthread_block\ng\n=\nthis_thread_block\n();\n// Choose a leader in the thread block\nif\n(\ng\n.\nthread_rank\n()\n==\n0\n)\n{\n// load from global into shared for all threads to work with\nx\n=\n(\n*\nglobalInput\n);\n}\n// After loading data into shared memory, you want to synchronize\n// if all threads in your thread block need to see it\ng\n.\nsync\n();\n// equivalent to __syncthreads();\n}\nNote:\nthat all threads in the group must participate in collective operations, or the behavior is undefined.\nRelated:\nThe\nthread_block\ndatatype is derived from the more generic\nthread_group\ndatatype, which can be used to represent a wider class of groups.\n11.4.1.2.\nCluster Group\nï\nThis group object represents all the threads launched in a single cluster. Refer to\nThread Block Clusters\n. The APIs are available on all hardware with Compute Capability 9.0+. In such cases, when a non-cluster grid is launched, the APIs assume a 1x1x1 cluster.\nclass\ncluster_group;\nConstructed via:\ncluster_group\ng\n=\nthis_cluster\n();\nPublic Member Functions:\nstatic\nvoid\nsync()\n: Synchronize the threads named in the group, equivalent to\ng.barrier_wait(g.barrier_arrive())\nstatic\ncluster_group::arrival_token\nbarrier_arrive()\n: Arrive on the cluster barrier, returns a token that needs to be passed into\nbarrier_wait()\n. More details\nhere\nstatic\nvoid\nbarrier_wait(cluster_group::arrival_token&&\nt)\n: Wait on the cluster barrier, takes arrival token returned from\nbarrier_arrive()\nas a rvalue reference. More details\nhere\nstatic\nunsigned\nint\nthread_rank()\n: Rank of the calling thread within [0, num_threads)\nstatic\nunsigned\nint\nblock_rank()\n: Rank of the calling block within [0, num_blocks)\nstatic\nunsigned\nint\nnum_threads()\n: Total number of threads in the group\nstatic\nunsigned\nint\nnum_blocks()\n: Total number of blocks in the group\nstatic\ndim3\ndim_threads()\n: Dimensions of the launched cluster in units of threads\nstatic\ndim3\ndim_blocks()\n: Dimensions of the launched cluster in units of blocks\nstatic\ndim3\nblock_index()\n: 3-Dimensional index of the calling block within the launched cluster\nstatic\nunsigned\nint\nquery_shared_rank(const\nvoid\n*addr)\n: Obtain the block rank to which a shared memory address belongs\nstatic\nT*\nmap_shared_rank(T\n*addr,\nint\nrank)\n: Obtain the address of a shared memory variable of another block in the cluster\nLegacy member functions (aliases):\nstatic\nunsigned\nint\nsize()\n: Total number of threads in the group (alias of\nnum_threads()\n)\n11.4.1.3.\nGrid Group\nï\nThis group object represents all the threads launched in a single grid. APIs other than\nsync()\nare available at all times, but to be able to synchronize across the grid, you need to use the cooperative launch API.\nclass\ngrid_group;\nConstructed via:\ngrid_group\ng\n=\nthis_grid\n();\nPublic Member Functions:\nbool\nis_valid()\nconst\n: Returns whether the grid_group can synchronize\nvoid\nsync()\nconst\n: Synchronize the threads named in the group, equivalent to\ng.barrier_wait(g.barrier_arrive())\ngrid_group::arrival_token\nbarrier_arrive()\n: Arrive on the grid barrier, returns a token that needs to be passed into\nbarrier_wait()\n. More details\nhere\nvoid\nbarrier_wait(grid_group::arrival_token&&\nt)\n: Wait on the grid barrier, takes arrival token returned from\nbarrier_arrive()\nas a rvalue reference. More details\nhere\nstatic\nunsigned\nlong\nlong\nthread_rank()\n: Rank of the calling thread within [0, num_threads)\nstatic\nunsigned\nlong\nlong\nblock_rank()\n: Rank of the calling block within [0, num_blocks)\nstatic\nunsigned\nlong\nlong\ncluster_rank()\n: Rank of the calling cluster within [0, num_clusters)\nstatic\nunsigned\nlong\nlong\nnum_threads()\n: Total number of threads in the group\nstatic\nunsigned\nlong\nlong\nnum_blocks()\n: Total number of blocks in the group\nstatic\nunsigned\nlong\nlong\nnum_clusters()\n: Total number of clusters in the group\nstatic\ndim3\ndim_blocks()\n: Dimensions of the launched grid in units of blocks\nstatic\ndim3\ndim_clusters()\n: Dimensions of the launched grid in units of clusters\nstatic\ndim3\nblock_index()\n: 3-Dimensional index of the block within the launched grid\nstatic\ndim3\ncluster_index()\n: 3-Dimensional index of the cluster within the launched grid\nLegacy member functions (aliases):\nstatic\nunsigned\nlong\nlong\nsize()\n: Total number of threads in the group (alias of\nnum_threads()\n)\nstatic\ndim3\ngroup_dim()\n: Dimensions of the launched grid (alias of\ndim_blocks()\n)\n11.4.2.\nExplicit Groups\nï\n11.4.2.1.\nThread Block Tile\nï\nA templated version of a tiled group, where a template parameter is used to specify the size of the tile - with this known at compile time there is the potential for more optimal execution.\ntemplate\n<\nunsigned\nint\nSize\n,\ntypename\nParentT\n=\nvoid\n>\nclass\nthread_block_tile\n;\nConstructed via:\ntemplate\n<\nunsigned\nint\nSize\n,\ntypename\nParentT\n>\n_CG_QUALIFIER\nthread_block_tile\n<\nSize\n,\nParentT\n>\ntiled_partition\n(\nconst\nParentT\n&\ng\n)\nSize\nmust be a power of 2 and less than or equal to 1024. Notes section describes extra steps needed to create tiles of size larger than 32 on hardware with Compute Capability 7.5 or lower.\nParentT\nis the parent-type from which this group was partitioned. It is automatically inferred, but a value of void will store this information in the group handle rather than in the type.\nPublic Member Functions:\nvoid\nsync()\nconst\n: Synchronize the threads named in the group\nunsigned\nlong\nlong\nnum_threads()\nconst\n: Total number of threads in the group\nunsigned\nlong\nlong\nthread_rank()\nconst\n: Rank of the calling thread within [0, num_threads)\nunsigned\nlong\nlong\nmeta_group_size()\nconst\n: Returns the number of groups created when the parent group was partitioned.\nunsigned\nlong\nlong\nmeta_group_rank()\nconst\n: Linear rank of the group within the set of tiles partitioned from a parent group (bounded by meta_group_size)\nT\nshfl(T\nvar,\nunsigned\nint\nsrc_rank)\nconst\n: Refer to\nWarp Shuffle Functions\n,\nNote: For sizes larger than 32 all threads in the group have to specify the same src_rank, otherwise the behavior is undefined.\nT\nshfl_up(T\nvar,\nint\ndelta)\nconst\n: Refer to\nWarp Shuffle Functions\n, available only for sizes lower or equal to 32.\nT\nshfl_down(T\nvar,\nint\ndelta)\nconst\n: Refer to\nWarp Shuffle Functions\n, available only for sizes lower or equal to 32.\nT\nshfl_xor(T\nvar,\nint\ndelta)\nconst\n: Refer to\nWarp Shuffle Functions\n, available only for sizes lower or equal to 32.\nint\nany(int\npredicate)\nconst\n: Refer to\nWarp Vote Functions\nint\nall(int\npredicate)\nconst\n: Refer to\nWarp Vote Functions\nunsigned\nint\nballot(int\npredicate)\nconst\n: Refer to\nWarp Vote Functions\n, available only for sizes lower or equal to 32.\nunsigned\nint\nmatch_any(T\nval)\nconst\n: Refer to\nWarp Match Functions\n, available only for sizes lower or equal to 32.\nunsigned\nint\nmatch_all(T\nval,\nint\n&pred)\nconst\n: Refer to\nWarp Match Functions\n, available only for sizes lower or equal to 32.\nLegacy member functions (aliases):\nunsigned\nlong\nlong\nsize()\nconst\n: Total number of threads in the group (alias of\nnum_threads()\n)\nNotes:\nthread_block_tile\ntemplated data structure is being used here, the size of the group is passed to the\ntiled_partition\ncall as a template parameter rather than an argument.\nshfl,\nshfl_up,\nshfl_down,\nand\nshfl_xor\nfunctions accept objects of any type when compiled with C++11 or later. This means itâs possible to shuffle non-integral types as long as they satisfy the below constraints:\nQualifies as trivially copyable i.e.,\nis_trivially_copyable<T>::value\n==\ntrue\nsizeof(T)\n<=\n32\nfor tile sizes lower or equal 32,\nsizeof(T)\n<=\n8\nfor larger tiles\nOn hardware with Compute Capability 7.5 or lower tiles of size larger than 32 need small amount of memory reserved for them. This can be done using\ncooperative_groups::block_tile_memory\nstruct template that has to reside in either shared or global memory.\ntemplate\n<\nunsigned\nint\nMaxBlockSize\n=\n1024\n>\nstruct\nblock_tile_memory\n;\nMaxBlockSize\nSpecifies the maximal number of threads in the current thread block. This parameter can be used to minimize the shared memory usage of\nblock_tile_memory\nin kernels launched only with smaller thread counts.\nThis\nblock_tile_memory\nneeds be then passed into\ncooperative_groups::this_thread_block\n, allowing the resulting\nthread_block\nto be partitioned into tiles of sizes larger than 32. Overload of\nthis_thread_block\naccepting\nblock_tile_memory\nargument is a collective operation and has to be called with all threads in the\nthread_block\n.\nblock_tile_memory\ncan be used on hardware with Compute Capability 8.0 or higher in order to be able to write one source targeting multiple different Compute Capabilities. It should consume no memory when instantiated in shared memory in cases where its not required.\nExamples:\n/// The following code will create two sets of tiled groups, of size 32 and 4 respectively:\n/// The latter has the provenance encoded in the type, while the first stores it in the handle\nthread_block\nblock\n=\nthis_thread_block\n();\nthread_block_tile\n<\n32\n>\ntile32\n=\ntiled_partition\n<\n32\n>\n(\nblock\n);\nthread_block_tile\n<\n4\n,\nthread_block\n>\ntile4\n=\ntiled_partition\n<\n4\n>\n(\nblock\n);\n/// The following code will create tiles of size 128 on all Compute Capabilities.\n/// block_tile_memory can be omitted on Compute Capability 8.0 or higher.\n__global__\nvoid\nkernel\n(...)\n{\n// reserve shared memory for thread_block_tile usage,\n//   specify that block size will be at most 256 threads.\n__shared__\nblock_tile_memory\n<\n256\n>\nshared\n;\nthread_block\nthb\n=\nthis_thread_block\n(\nshared\n);\n// Create tiles with 128 threads.\nauto\ntile\n=\ntiled_partition\n<\n128\n>\n(\nthb\n);\n// ...\n}\n11.4.2.1.1.\nWarp-Synchronous Code Pattern\nï\nDevelopers might have had warp-synchronous codes that they previously made implicit assumptions about the warp size and would code around that number. Now this needs to be specified explicitly.\n__global__\nvoid\ncooperative_kernel\n(...)\n{\n// obtain default \"current thread block\" group\nthread_block\nmy_block\n=\nthis_thread_block\n();\n// subdivide into 32-thread, tiled subgroups\n// Tiled subgroups evenly partition a parent group into\n// adjacent sets of threads - in this case each one warp in size\nauto\nmy_tile\n=\ntiled_partition\n<\n32\n>\n(\nmy_block\n);\n// This operation will be performed by only the\n// first 32-thread tile of each block\nif\n(\nmy_tile\n.\nmeta_group_rank\n()\n==\n0\n)\n{\n// ...\nmy_tile\n.\nsync\n();\n}\n}\n11.4.2.1.2.\nSingle Thread Group\nï\nGroup representing the current thread can be obtained from\nthis_thread\nfunction:\nthread_block_tile\n<\n1\n>\nthis_thread\n();\nThe following\nmemcpy_async\nAPI uses a\nthread_group\n, to copy an int element from source to destination:\n#include\n<cooperative_groups.h>\n#include\n<cooperative_groups/memcpy_async.h>\ncooperative_groups\n::\nmemcpy_async\n(\ncooperative_groups\n::\nthis_thread\n(),\ndest\n,\nsrc\n,\nsizeof\n(\nint\n));\nMore detailed examples of using\nthis_thread\nto perform asynchronous copies can be found in the\nSingle-Stage Asynchronous Data Copies using cuda::pipeline\nand\nMulti-Stage Asynchronous Data Copies using cuda::pipeline\nsections.\n11.4.2.2.\nCoalesced Groups\nï\nIn CUDAâs SIMT architecture, at the hardware level the multiprocessor executes threads in groups of 32 called warps. If there exists a data-dependent conditional branch in the application code such that threads within a warp diverge, then the warp serially executes each branch disabling threads not on that path. The threads that remain active on the path are referred to as coalesced. Cooperative Groups has functionality to discover, and create, a group containing all coalesced threads.\nConstructing the group handle via\ncoalesced_threads()\nis opportunistic. It returns the set of active threads at that point in time, and makes no guarantee about which threads are returned (as long as they are active) or that they will stay coalesced throughout execution (they will be brought back together for the execution of a collective but can diverge again afterwards).\nclass\ncoalesced_group;\nConstructed via:\ncoalesced_group\nactive\n=\ncoalesced_threads\n();\nPublic Member Functions:\nvoid\nsync()\nconst\n: Synchronize the threads named in the group\nunsigned\nlong\nlong\nnum_threads()\nconst\n: Total number of threads in the group\nunsigned\nlong\nlong\nthread_rank()\nconst\n: Rank of the calling thread within [0, num_threads)\nunsigned\nlong\nlong\nmeta_group_size()\nconst\n: Returns the number of groups created when the parent group was partitioned. If this group was created by querying the set of active threads, for example\ncoalesced_threads()\nthe value of\nmeta_group_size()\nwill be 1.\nunsigned\nlong\nlong\nmeta_group_rank()\nconst\n: Linear rank of the group within the set of tiles partitioned from a parent group (bounded by meta_group_size). If this group was created by querying the set of active threads, e.g.\ncoalesced_threads()\nthe value of\nmeta_group_rank()\nwill always be 0.\nT\nshfl(T\nvar,\nunsigned\nint\nsrc_rank)\nconst\n: Refer to\nWarp Shuffle Functions\nT\nshfl_up(T\nvar,\nint\ndelta)\nconst\n: Refer to\nWarp Shuffle Functions\nT\nshfl_down(T\nvar,\nint\ndelta)\nconst\n: Refer to\nWarp Shuffle Functions\nint\nany(int\npredicate)\nconst\n: Refer to\nWarp Vote Functions\nint\nall(int\npredicate)\nconst\n: Refer to\nWarp Vote Functions\nunsigned\nint\nballot(int\npredicate)\nconst\n: Refer to\nWarp Vote Functions\nunsigned\nint\nmatch_any(T\nval)\nconst\n: Refer to\nWarp Match Functions\nunsigned\nint\nmatch_all(T\nval,\nint\n&pred)\nconst\n: Refer to\nWarp Match Functions\nLegacy member functions (aliases):\nunsigned\nlong\nlong\nsize()\nconst\n: Total number of threads in the group (alias of\nnum_threads()\n)\nNotes:\nshfl,\nshfl_up,\nand\nshfl_down\nfunctions accept objects of any type when compiled with C++11 or later. This means itâs possible to shuffle non-integral types as long as they satisfy the below constraints:\nQualifies as trivially copyable i.e.\nis_trivially_copyable<T>::value\n==\ntrue\nsizeof(T)\n<=\n32\nExample:\n/// Consider a situation whereby there is a branch in the\n/// code in which only the 2nd, 4th and 8th threads in each warp are\n/// active. The coalesced_threads() call, placed in that branch, will create (for each\n/// warp) a group, active, that has three threads (with\n/// ranks 0-2 inclusive).\n__global__\nvoid\nkernel\n(\nint\n*\nglobalInput\n)\n{\n// Lets say globalInput says that threads 2, 4, 8 should handle the data\nif\n(\nthreadIdx\n.\nx\n==\n*\nglobalInput\n)\n{\ncoalesced_group\nactive\n=\ncoalesced_threads\n();\n// active contains 0-2 inclusive\nactive\n.\nsync\n();\n}\n}\n11.4.2.2.1.\nDiscovery Pattern\nï\nCommonly developers need to work with the current active set of threads. No assumption is made about the threads that are present, and instead developers work with the threads that happen to be there. This is seen in the following âaggregating atomic increment across threads in a warpâ example (written using the correct CUDA 9.0 set of intrinsics):\n{\nunsigned\nint\nwritemask\n=\n__activemask\n();\nunsigned\nint\ntotal\n=\n__popc\n(\nwritemask\n);\nunsigned\nint\nprefix\n=\n__popc\n(\nwritemask\n&\n__lanemask_lt\n());\n// Find the lowest-numbered active lane\nint\nelected_lane\n=\n__ffs\n(\nwritemask\n)\n-\n1\n;\nint\nbase_offset\n=\n0\n;\nif\n(\nprefix\n==\n0\n)\n{\nbase_offset\n=\natomicAdd\n(\np\n,\ntotal\n);\n}\nbase_offset\n=\n__shfl_sync\n(\nwritemask\n,\nbase_offset\n,\nelected_lane\n);\nint\nthread_offset\n=\nprefix\n+\nbase_offset\n;\nreturn\nthread_offset\n;\n}\nThis can be re-written with Cooperative Groups as follows:\n{\ncg\n::\ncoalesced_group\ng\n=\ncg\n::\ncoalesced_threads\n();\nint\nprev\n;\nif\n(\ng\n.\nthread_rank\n()\n==\n0\n)\n{\nprev\n=\natomicAdd\n(\np\n,\ng\n.\nnum_threads\n());\n}\nprev\n=\ng\n.\nthread_rank\n()\n+\ng\n.\nshfl\n(\nprev\n,\n0\n);\nreturn\nprev\n;\n}\n11.5.\nGroup Partitioning\nï\n11.5.1.\ntiled_partition\nï\ntemplate\n<\nunsigned\nint\nSize\n,\ntypename\nParentT\n>\nthread_block_tile\n<\nSize\n,\nParentT\n>\ntiled_partition\n(\nconst\nParentT\n&\ng\n);\nthread_group\ntiled_partition\n(\nconst\nthread_group\n&\nparent\n,\nunsigned\nint\ntilesz\n);\nThe\ntiled_partition\nmethod is a collective operation that partitions the parent group into a one-dimensional, row-major, tiling of subgroups. A total of ((size(parent)/tilesz) subgroups will be created, therefore the parent group size must be evenly divisible by the\nSize\n. The allowed parent groups are\nthread_block\nor\nthread_block_tile\n.\nThe implementation may cause the calling thread to wait until all the members of the parent group have invoked the operation before resuming execution. Functionality is limited to native hardware sizes, 1/2/4/8/16/32 and the\ncg::size(parent)\nmust be greater than the\nSize\nparameter. The templated version of\ntiled_partition\nsupports 64/128/256/512 sizes as well, but some additional steps are required on Compute Capability 7.5 or lower, refer to\nThread Block Tile\nfor details.\nCodegen Requirements:\nCompute Capability 5.0 minimum, C++11 for sizes larger than 32\nExample:\n/// The following code will create a 32-thread tile\nthread_block\nblock\n=\nthis_thread_block\n();\nthread_block_tile\n<\n32\n>\ntile32\n=\ntiled_partition\n<\n32\n>\n(\nblock\n);\nWe can partition each of these groups into even smaller groups, each of size 4 threads:\nauto\ntile4\n=\ntiled_partition\n<\n4\n>\n(\ntile32\n);\n// or using a general group\n// thread_group tile4 = tiled_partition(tile32, 4);\nIf, for instance, if we were to then include the following line of code:\nif\n(\ntile4\n.\nthread_rank\n()\n==\n0\n)\nprintf\n(\n\"Hello from tile4 rank 0\n\\n\n\"\n);\nthen the statement would be printed by every fourth thread in the block: the threads of rank 0 in each\ntile4\ngroup, which correspond to those threads with ranks 0,4,8,12,etc. in the\nblock\ngroup.\n11.5.2.\nlabeled_partition\nï\ntemplate\n<\ntypename\nLabel\n>\ncoalesced_group\nlabeled_partition\n(\nconst\ncoalesced_group\n&\ng\n,\nLabel\nlabel\n);\ntemplate\n<\nunsigned\nint\nSize\n,\ntypename\nLabel\n>\ncoalesced_group\nlabeled_partition\n(\nconst\nthread_block_tile\n<\nSize\n>&\ng\n,\nLabel\nlabel\n);\nThe\nlabeled_partition\nmethod is a collective operation that partitions the parent group into one-dimensional subgroups within which the threads are coalesced. The implementation will evaluate a condition label and assign threads that have the same value for label into the same group.\nLabel\ncan be any integral type.\nThe implementation may cause the calling thread to wait until all the members of the parent group have invoked the operation before resuming execution.\nNote:\nThis functionality is still being evaluated and may slightly change in the future.\nCodegen Requirements:\nCompute Capability 7.0 minimum, C++11\n11.5.3.\nbinary_partition\nï\ncoalesced_group\nbinary_partition\n(\nconst\ncoalesced_group\n&\ng\n,\nbool\npred\n);\ntemplate\n<\nunsigned\nint\nSize\n>\ncoalesced_group\nbinary_partition\n(\nconst\nthread_block_tile\n<\nSize\n>&\ng\n,\nbool\npred\n);\nThe\nbinary_partition()\nmethod is a collective operation that partitions the parent group into one-dimensional subgroups within which the threads are coalesced. The implementation will evaluate a predicate and assign threads that have the same value into the same group. This is a specialized form of\nlabeled_partition()\n, where the label can only be 0 or 1.\nThe implementation may cause the calling thread to wait until all the members of the parent group have invoked the operation before resuming execution.\nNote:\nThis functionality is still being evaluated and may slightly change in the future.\nCodegen Requirements:\nCompute Capability 7.0 minimum, C++11\nExample:\n/// This example divides a 32-sized tile into a group with odd\n/// numbers and a group with even numbers\n_global__\nvoid\noddEven\n(\nint\n*\ninputArr\n)\n{\nauto\nblock\n=\ncg\n::\nthis_thread_block\n();\nauto\ntile32\n=\ncg\n::\ntiled_partition\n<\n32\n>\n(\nblock\n);\n// inputArr contains random integers\nint\nelem\n=\ninputArr\n[\nblock\n.\nthread_rank\n()];\n// after this, tile32 is split into 2 groups,\n// a subtile where elem&1 is true and one where its false\nauto\nsubtile\n=\ncg\n::\nbinary_partition\n(\ntile32\n,\n(\nelem\n&\n1\n));\n}\n11.6.\nGroup Collectives\nï\nCooperative Groups library provides a set of collective operations that can be performed by a group of threads.\nThese operations require participation of all threads in the specified group in order to complete the operation.\nAll threads in the group need to pass the same values for corresponding arguments to each collective call, unless\ndifferent values are explicitly allowed in the argument description. Otherwise the behavior of the call is undefined.\n11.6.1.\nSynchronization\nï\n11.6.1.1.\nbarrier_arrive\nand\nbarrier_wait\nï\nT\n::\narrival_token\nT::barrier_arrive\n();\nvoid\nT::barrier_wait\n(\nT\n::\narrival_token\n&&\n);\nbarrier_arrive\nand\nbarrier_wait\nmember functions provide a synchronization API similar to\ncuda::barrier\n(read more)\n. Cooperative Groups automatically initializes the group barrier, but arrive and wait operations have an additional restriction resulting from collective nature of those operations: All threads in the group must arrive and wait at the barrier once per phase.\nWhen\nbarrier_arrive\nis called with a group, result of calling any collective operation or another barrier arrival with that group is undefined until completion of the barrier phase is observed with\nbarrier_wait\ncall. Threads blocked on\nbarrier_wait\nmight be released from the synchronization before other threads call\nbarrier_wait\n, but only after all threads in the group called\nbarrier_arrive\n.\nGroup type\nT\ncan be any of the\nimplicit groups\n.This allows threads to do independent work after they arrive and before they wait for the synchronization to resolve, allowing to hide some of the synchronization latency.\nbarrier_arrive\nreturns an\narrival_token\nobject that must be passed into the corresponding\nbarrier_wait\n. Token is consumed this way and can not be used for another\nbarrier_wait\ncall.\nExample of barrier_arrive and barrier_wait used to synchronize initalization of shared memory across the cluster:\n#include\n<cooperative_groups.h>\nusing\nnamespace\ncooperative_groups\n;\nvoid\n__device__\ninit_shared_data\n(\nconst\nthread_block\n&\nblock\n,\nint\n*\ndata\n);\nvoid\n__device__\nlocal_processing\n(\nconst\nthread_block\n&\nblock\n);\nvoid\n__device__\nprocess_shared_data\n(\nconst\nthread_block\n&\nblock\n,\nint\n*\ndata\n);\n__global__\nvoid\ncluster_kernel\n()\n{\nextern\n__shared__\nint\narray\n[];\nauto\ncluster\n=\nthis_cluster\n();\nauto\nblock\n=\nthis_thread_block\n();\n// Use this thread block to initialize some shared state\ninit_shared_data\n(\nblock\n,\n&\narray\n[\n0\n]);\nauto\ntoken\n=\ncluster\n.\nbarrier_arrive\n();\n// Let other blocks know this block is running and data was initialized\n// Do some local processing to hide the synchronization latency\nlocal_processing\n(\nblock\n);\n// Map data in shared memory from the next block in the cluster\nint\n*\ndsmem\n=\ncluster\n.\nmap_shared_rank\n(\n&\narray\n[\n0\n],\n(\ncluster\n.\nblock_rank\n()\n+\n1\n)\n%\ncluster\n.\nnum_blocks\n());\n// Make sure all other blocks in the cluster are running and initialized shared data before accessing dsmem\ncluster\n.\nbarrier_wait\n(\nstd\n::\nmove\n(\ntoken\n));\n// Consume data in distributed shared memory\nprocess_shared_data\n(\nblock\n,\ndsmem\n);\ncluster\n.\nsync\n();\n}\n11.6.1.2.\nsync\nï\nstatic\nvoid\nT::sync\n();\ntemplate\n<\ntypename\nT\n>\nvoid\nsync\n(\nT\n&\ngroup\n);\nsync\nsynchronizes the threads named in the group. Group type\nT\ncan be any of the existing group types, as all of them support synchronization. Its available as a member function in every group type or as a free function taking a group as parameter.\nIf the group is a\ngrid_group\nthe kernel must have been launched using the appropriate cooperative launch APIs. Equivalent to\nT.barrier_wait(T.barrier_arrive())\n.\n11.6.2.\nData Transfer\nï\n11.6.2.1.\nmemcpy_async\nï\nmemcpy_async\nis a group-wide collective memcpy that utilizes hardware accelerated support for non-blocking memory transactions from global to shared memory. Given a set of threads named in the group,\nmemcpy_async\nwill move specified amount of bytes or elements of the input type through a single pipeline stage. Additionally for achieving best performance when using the\nmemcpy_async\nAPI, an alignment of 16 bytes for both shared memory and global memory is required. It is important to note that while this is a memcpy in the general case, it is only asynchronous if the source is global memory and the destination is shared memory and both can be addressed with 16, 8, or 4 byte alignments. Asynchronously copied data should only be read following a call to wait or wait_prior which signals that the corresponding stage has completed moving data to shared memory.\nHaving to wait on all outstanding requests can lose some flexibility (but gain simplicity). In order to efficiently overlap data transfer and execution, its important to be able to kick off an\nN+1\nmemcpy_async\nrequest while waiting on and operating on request\nN\n. To do so, use\nmemcpy_async\nand wait on it using the collective stage-based\nwait_prior\nAPI. See\nwait and wait_prior\nfor more details.\nUsage 1\ntemplate\n<\ntypename\nTyGroup\n,\ntypename\nTyElem\n,\ntypename\nTyShape\n>\nvoid\nmemcpy_async\n(\nconst\nTyGroup\n&\ngroup\n,\nTyElem\n*\n__restrict__\n_dst\n,\nconst\nTyElem\n*\n__restrict__\n_src\n,\nconst\nTyShape\n&\nshape\n);\nPerforms a copy of\n``shape`` bytes\n.\nUsage 2\ntemplate\n<\ntypename\nTyGroup\n,\ntypename\nTyElem\n,\ntypename\nTyDstLayout\n,\ntypename\nTySrcLayout\n>\nvoid\nmemcpy_async\n(\nconst\nTyGroup\n&\ngroup\n,\nTyElem\n*\n__restrict__\ndst\n,\nconst\nTyDstLayout\n&\ndstLayout\n,\nconst\nTyElem\n*\n__restrict__\nsrc\n,\nconst\nTySrcLayout\n&\nsrcLayout\n);\nPerforms a copy of\n``min(dstLayout, srcLayout)`` elements\n. If layouts are of type\ncuda::aligned_size_t<N>\n, both must specify the same alignment.\nErrata\nThe\nmemcpy_async\nAPI introduced in CUDA 11.1 with both src and dst input layouts, expects the layout to be provided in elements rather than bytes. The element type is inferred from\nTyElem\nand has the size\nsizeof(TyElem)\n. If\ncuda::aligned_size_t<N>\ntype is used as the layout, the number of elements specified times\nsizeof(TyElem)\nmust be a multiple of N and it is recommended to use\nstd::byte\nor\nchar\nas the element type.\nIf specified shape or layout of the copy is of type\ncuda::aligned_size_t<N>\n, alignment will be guaranteed to be at least\nmin(16,\nN)\n. In that case both\ndst\nand\nsrc\npointers need to be aligned to N bytes and the number of bytes copied needs to be a multiple of N.\nCodegen Requirements:\nCompute Capability 5.0 minimum, Compute Capability 8.0 for asynchronicity, C++11\ncooperative_groups/memcpy_async.h\nheader needs to be included.\nExample:\n/// This example streams elementsPerThreadBlock worth of data from global memory\n/// into a limited sized shared memory (elementsInShared) block to operate on.\n#include\n<cooperative_groups.h>\n#include\n<cooperative_groups/memcpy_async.h>\nnamespace\ncg\n=\ncooperative_groups\n;\n__global__\nvoid\nkernel\n(\nint\n*\nglobal_data\n)\n{\ncg\n::\nthread_block\ntb\n=\ncg\n::\nthis_thread_block\n();\nconst\nsize_t\nelementsPerThreadBlock\n=\n16\n*\n1024\n;\nconst\nsize_t\nelementsInShared\n=\n128\n;\n__shared__\nint\nlocal_smem\n[\nelementsInShared\n];\nsize_t\ncopy_count\n;\nsize_t\nindex\n=\n0\n;\nwhile\n(\nindex\n<\nelementsPerThreadBlock\n)\n{\ncg\n::\nmemcpy_async\n(\ntb\n,\nlocal_smem\n,\nelementsInShared\n,\nglobal_data\n+\nindex\n,\nelementsPerThreadBlock\n-\nindex\n);\ncopy_count\n=\nmin\n(\nelementsInShared\n,\nelementsPerThreadBlock\n-\nindex\n);\ncg\n::\nwait\n(\ntb\n);\n// Work with local_smem\nindex\n+=\ncopy_count\n;\n}\n}\n11.6.2.2.\nwait\nand\nwait_prior\nï\ntemplate\n<\ntypename\nTyGroup\n>\nvoid\nwait\n(\nTyGroup\n&\ngroup\n);\ntemplate\n<\nunsigned\nint\nNumStages\n,\ntypename\nTyGroup\n>\nvoid\nwait_prior\n(\nTyGroup\n&\ngroup\n);\nwait\nand\nwait_prior\ncollectives allow to wait for memcpy_async copies to complete.\nwait\nblocks calling threads until all previous copies are done.\nwait_prior\nallows that the latest NumStages are still not done and waits for all the previous requests. So with\nN\ntotal copies requested, it waits until the first\nN-NumStages\nare done and the last\nNumStages\nmight still be in progress. Both\nwait\nand\nwait_prior\nwill synchronize the named group.\nCodegen Requirements:\nCompute Capability 5.0 minimum, Compute Capability 8.0 for asynchronicity, C++11\ncooperative_groups/memcpy_async.h\nheader needs to be included.\nExample:\n/// This example streams elementsPerThreadBlock worth of data from global memory\n/// into a limited sized shared memory (elementsInShared) block to operate on in\n/// multiple (two) stages. As stage N is kicked off, we can wait on and operate on stage N-1.\n#include\n<cooperative_groups.h>\n#include\n<cooperative_groups/memcpy_async.h>\nnamespace\ncg\n=\ncooperative_groups\n;\n__global__\nvoid\nkernel\n(\nint\n*\nglobal_data\n)\n{\ncg\n::\nthread_block\ntb\n=\ncg\n::\nthis_thread_block\n();\nconst\nsize_t\nelementsPerThreadBlock\n=\n16\n*\n1024\n+\n64\n;\nconst\nsize_t\nelementsInShared\n=\n128\n;\n__align__\n(\n16\n)\n__shared__\nint\nlocal_smem\n[\n2\n][\nelementsInShared\n];\nint\nstage\n=\n0\n;\n// First kick off an extra request\nsize_t\ncopy_count\n=\nelementsInShared\n;\nsize_t\nindex\n=\ncopy_count\n;\ncg\n::\nmemcpy_async\n(\ntb\n,\nlocal_smem\n[\nstage\n],\nelementsInShared\n,\nglobal_data\n,\nelementsPerThreadBlock\n-\nindex\n);\nwhile\n(\nindex\n<\nelementsPerThreadBlock\n)\n{\n// Now we kick off the next request...\ncg\n::\nmemcpy_async\n(\ntb\n,\nlocal_smem\n[\nstage\n^\n1\n],\nelementsInShared\n,\nglobal_data\n+\nindex\n,\nelementsPerThreadBlock\n-\nindex\n);\n// ... but we wait on the one before it\ncg\n::\nwait_prior\n<\n1\n>\n(\ntb\n);\n// Its now available and we can work with local_smem[stage] here\n// (...)\n//\n// Calculate the amount fo data that was actually copied, for the next iteration.\ncopy_count\n=\nmin\n(\nelementsInShared\n,\nelementsPerThreadBlock\n-\nindex\n);\nindex\n+=\ncopy_count\n;\n// A cg::sync(tb) might be needed here depending on whether\n// the work done with local_smem[stage] can release threads to race ahead or not\n// Wrap to the next stage\nstage\n^=\n1\n;\n}\ncg\n::\nwait\n(\ntb\n);\n// The last local_smem[stage] can be handled here\n}\n11.6.3.\nData Manipulation\nï\n11.6.3.1.\nreduce\nï\ntemplate\n<\ntypename\nTyGroup\n,\ntypename\nTyArg\n,\ntypename\nTyOp\n>\nauto\nreduce\n(\nconst\nTyGroup\n&\ngroup\n,\nTyArg\n&&\nval\n,\nTyOp\n&&\nop\n)\n->\ndecltype\n(\nop\n(\nval\n,\nval\n));\nreduce\nperforms a reduction operation on the data provided by each thread named in the group passed in. This takes advantage of hardware acceleration (on compute 80 and higher devices) for the arithmetic add, min, or max operations and the logical AND, OR, or XOR, as well as providing a software fallback on older generation hardware. Only 4B types are accelerated by hardware.\ngroup\n: Valid group types are\ncoalesced_group\nand\nthread_block_tile\n.\nval\n: Any type that satisfies the below requirements:\nQualifies as trivially copyable i.e.\nis_trivially_copyable<TyArg>::value\n==\ntrue\nsizeof(T)\n<=\n32\nfor\ncoalesced_group\nand tiles of size lower or equal 32,\nsizeof(T)\n<=\n8\nfor larger tiles\nHas suitable arithmetic or comparative operators for the given function object.\nNote:\nDifferent threads in the group can pass different values for this argument.\nop\n: Valid function objects that will provide hardware acceleration with integral types are\nplus(),\nless(),\ngreater(),\nbit_and(),\nbit_xor(),\nbit_or()\n. These must be constructed, hence the TyVal template argument is required, i.e.\nplus<int>()\n. Reduce also supports lambdas and other function objects that can be invoked using\noperator()\nAsynchronous reduce\ntemplate\n<\ntypename\nTyGroup\n,\ntypename\nTyArg\n,\ntypename\nTyAtomic\n,\ntypename\nTyOp\n>\nvoid\nreduce_update_async\n(\nconst\nTyGroup\n&\ngroup\n,\nTyAtomic\n&\natomic\n,\nTyArg\n&&\nval\n,\nTyOp\n&&\nop\n);\ntemplate\n<\ntypename\nTyGroup\n,\ntypename\nTyArg\n,\ntypename\nTyAtomic\n,\ntypename\nTyOp\n>\nvoid\nreduce_store_async\n(\nconst\nTyGroup\n&\ngroup\n,\nTyAtomic\n&\natomic\n,\nTyArg\n&&\nval\n,\nTyOp\n&&\nop\n);\ntemplate\n<\ntypename\nTyGroup\n,\ntypename\nTyArg\n,\ntypename\nTyOp\n>\nvoid\nreduce_store_async\n(\nconst\nTyGroup\n&\ngroup\n,\nTyArg\n*\nptr\n,\nTyArg\n&&\nval\n,\nTyOp\n&&\nop\n);\n*_async\nvariants of the API are asynchronously calculating the result to either store to or update a specified destination by one of the participating threads, instead of returning it by each thread. To observe the effect of these asynchronous calls, calling group of threads or a larger group containing them need to be synchronized.\nIn case of the atomic store or update variant,\natomic\nargument can be either of\ncuda::atomic\nor\ncuda::atomic_ref\navailable in\nCUDA C++ Standard Library\n. This variant of the API is available only on platforms and devices, where these types are supported by the CUDA C++ Standard Library. Result of the reduction is used to atomically update the atomic according to the specified\nop\n, eg. the result is atomically added to the atomic in case of\ncg::plus()\n. Type held by the\natomic\nmust match the type of\nTyArg\n. Scope of the atomic must include all the threads in the group and if multiple groups are using the same atomic concurrently, scope must include all threads in all groups using it. Atomic update is performed with relaxed memory ordering.\nIn case of the pointer store variant, result of the reduction will be weakly stored into the\ndst\npointer.\nCodegen Requirements:\nCompute Capability 5.0 minimum, Compute Capability 8.0 for HW acceleration, C++11.\ncooperative_groups/reduce.h\nheader needs to be included.\nExample of approximate standard deviation for integer vector:\n#include\n<cooperative_groups.h>\n#include\n<cooperative_groups/reduce.h>\nnamespace\ncg\n=\ncooperative_groups\n;\n/// Calculate approximate standard deviation of integers in vec\n__device__\nint\nstd_dev\n(\nconst\ncg\n::\nthread_block_tile\n<\n32\n>&\ntile\n,\nint\n*\nvec\n,\nint\nlength\n)\n{\nint\nthread_sum\n=\n0\n;\n// calculate average first\nfor\n(\nint\ni\n=\ntile\n.\nthread_rank\n();\ni\n<\nlength\n;\ni\n+=\ntile\n.\nnum_threads\n())\n{\nthread_sum\n+=\nvec\n[\ni\n];\n}\n// cg::plus<int> allows cg::reduce() to know it can use hardware acceleration for addition\nint\navg\n=\ncg\n::\nreduce\n(\ntile\n,\nthread_sum\n,\ncg\n::\nplus\n<\nint\n>\n())\n/\nlength\n;\nint\nthread_diffs_sum\n=\n0\n;\nfor\n(\nint\ni\n=\ntile\n.\nthread_rank\n();\ni\n<\nlength\n;\ni\n+=\ntile\n.\nnum_threads\n())\n{\nint\ndiff\n=\nvec\n[\ni\n]\n-\navg\n;\nthread_diffs_sum\n+=\ndiff\n*\ndiff\n;\n}\n// temporarily use floats to calculate the square root\nfloat\ndiff_sum\n=\nstatic_cast\n<\nfloat\n>\n(\ncg\n::\nreduce\n(\ntile\n,\nthread_diffs_sum\n,\ncg\n::\nplus\n<\nint\n>\n()))\n/\nlength\n;\nreturn\nstatic_cast\n<\nint\n>\n(\nsqrtf\n(\ndiff_sum\n));\n}\nExample of block wide reduction:\n#include\n<cooperative_groups.h>\n#include\n<cooperative_groups/reduce.h>\nnamespace\ncg\n=\ncooperative_groups\n;\n/// The following example accepts input in *A and outputs a result into *sum\n/// It spreads the data equally within the block\n__device__\nvoid\nblock_reduce\n(\nconst\nint\n*\nA\n,\nint\ncount\n,\ncuda\n::\natomic\n<\nint\n,\ncuda\n::\nthread_scope_block\n>&\ntotal_sum\n)\n{\nauto\nblock\n=\ncg\n::\nthis_thread_block\n();\nauto\ntile\n=\ncg\n::\ntiled_partition\n<\n32\n>\n(\nblock\n);\nint\nthread_sum\n=\n0\n;\n// Stride loop over all values, each thread accumulates its part of the array.\nfor\n(\nint\ni\n=\nblock\n.\nthread_rank\n();\ni\n<\ncount\n;\ni\n+=\nblock\n.\nsize\n())\n{\nthread_sum\n+=\nA\n[\ni\n];\n}\n// reduce thread sums across the tile, add the result to the atomic\n// cg::plus<int> allows cg::reduce() to know it can use hardware acceleration for addition\ncg\n::\nreduce_update_async\n(\ntile\n,\ntotal_sum\n,\nthread_sum\n,\ncg\n::\nplus\n<\nint\n>\n());\n// synchronize the block, to ensure all async reductions are ready\nblock\n.\nsync\n();\n}\n11.6.3.2.\nReduce\nOperators\nï\nBelow are the prototypes of function objects for some of the basic operations that can be done with\nreduce\nnamespace\ncooperative_groups\n{\ntemplate\n<\ntypename\nTy\n>\nstruct\ncg\n::\nplus\n;\ntemplate\n<\ntypename\nTy\n>\nstruct\ncg\n::\nless\n;\ntemplate\n<\ntypename\nTy\n>\nstruct\ncg\n::\ngreater\n;\ntemplate\n<\ntypename\nTy\n>\nstruct\ncg\n::\nbit_and\n;\ntemplate\n<\ntypename\nTy\n>\nstruct\ncg\n::\nbit_xor\n;\ntemplate\n<\ntypename\nTy\n>\nstruct\ncg\n::\nbit_or\n;\n}\nReduce is limited to the information available to the implementation at compile time. Thus in order to make use of intrinsics introduced in CC 8.0, the\ncg::\nnamespace exposes several functional objects that mirror the hardware. These objects appear similar to those presented in the C++ STL, with the exception of\nless/greater\n. The reason for any difference from the STL is that these function objects are designed to actually mirror the operation of the hardware intrinsics.\nFunctional description:\ncg::plus:\nAccepts two values and returns the sum of both using operator+.\ncg::less:\nAccepts two values and returns the lesser using operator<. This differs in that the\nlower value is returned\nrather than a Boolean.\ncg::greater:\nAccepts two values and returns the greater using operator<. This differs in that the\ngreater value is returned\nrather than a Boolean.\ncg::bit_and:\nAccepts two values and returns the result of operator&.\ncg::bit_xor:\nAccepts two values and returns the result of operator^.\ncg::bit_or:\nAccepts two values and returns the result of operator|.\nExample:\n{\n// cg::plus<int> is specialized within cg::reduce and calls __reduce_add_sync(...) on CC 8.0+\ncg\n::\nreduce\n(\ntile\n,\n(\nint\n)\nval\n,\ncg\n::\nplus\n<\nint\n>\n());\n// cg::plus<float> fails to match with an accelerator and instead performs a standard shuffle based reduction\ncg\n::\nreduce\n(\ntile\n,\n(\nfloat\n)\nval\n,\ncg\n::\nplus\n<\nfloat\n>\n());\n// While individual components of a vector are supported, reduce will not use hardware intrinsics for the following\n// It will also be necessary to define a corresponding operator for vector and any custom types that may be used\nint4\nvec\n=\n{...};\ncg\n::\nreduce\n(\ntile\n,\nvec\n,\ncg\n::\nplus\n<\nint4\n>\n())\n// Finally lambdas and other function objects cannot be inspected for dispatch\n// and will instead perform shuffle based reductions using the provided function object.\ncg\n::\nreduce\n(\ntile\n,\n(\nint\n)\nval\n,\n[](\nint\nl\n,\nint\nr\n)\n->\nint\n{\nreturn\nl\n+\nr\n;});\n}\n11.6.3.3.\ninclusive_scan\nand\nexclusive_scan\nï\ntemplate\n<\ntypename\nTyGroup\n,\ntypename\nTyVal\n,\ntypename\nTyFn\n>\nauto\ninclusive_scan\n(\nconst\nTyGroup\n&\ngroup\n,\nTyVal\n&&\nval\n,\nTyFn\n&&\nop\n)\n->\ndecltype\n(\nop\n(\nval\n,\nval\n));\ntemplate\n<\ntypename\nTyGroup\n,\ntypename\nTyVal\n>\nTyVal\ninclusive_scan\n(\nconst\nTyGroup\n&\ngroup\n,\nTyVal\n&&\nval\n);\ntemplate\n<\ntypename\nTyGroup\n,\ntypename\nTyVal\n,\ntypename\nTyFn\n>\nauto\nexclusive_scan\n(\nconst\nTyGroup\n&\ngroup\n,\nTyVal\n&&\nval\n,\nTyFn\n&&\nop\n)\n->\ndecltype\n(\nop\n(\nval\n,\nval\n));\ntemplate\n<\ntypename\nTyGroup\n,\ntypename\nTyVal\n>\nTyVal\nexclusive_scan\n(\nconst\nTyGroup\n&\ngroup\n,\nTyVal\n&&\nval\n);\ninclusive_scan\nand\nexclusive_scan\nperforms a scan operation on the data provided by each thread named in the group passed in. Result for each thread is a reduction of data from threads with lower\nthread_rank\nthan that thread in case of\nexclusive_scan\n.\ninclusive_scan\nresult also includes the calling thread data in the reduction.\ngroup\n: Valid group types are\ncoalesced_group\nand\nthread_block_tile\n.\nval\n: Any type that satisfies the below requirements:\nQualifies as trivially copyable i.e.\nis_trivially_copyable<TyArg>::value\n==\ntrue\nsizeof(T)\n<=\n32\nfor\ncoalesced_group\nand tiles of size lower or equal 32,\nsizeof(T)\n<=\n8\nfor larger tiles\nHas suitable arithmetic or comparative operators for the given function object.\nNote:\nDifferent threads in the group can pass different values for this argument.\nop\n: Function objects defined for convenience are\nplus(),\nless(),\ngreater(),\nbit_and(),\nbit_xor(),\nbit_or()\ndescribed in\nReduce Operators\n. These must be constructed, hence the TyVal template argument is required, i.e.\nplus<int>()\n.\ninclusive_scan\nand\nexclusive_scan\nalso supports lambdas and other function objects that can be invoked using\noperator()\n. Overloads without this argument use\ncg::plus<TyVal>()\n.\nScan update\ntemplate\n<\ntypename\nTyGroup\n,\ntypename\nTyAtomic\n,\ntypename\nTyVal\n,\ntypename\nTyFn\n>\nauto\ninclusive_scan_update\n(\nconst\nTyGroup\n&\ngroup\n,\nTyAtomic\n&\natomic\n,\nTyVal\n&&\nval\n,\nTyFn\n&&\nop\n)\n->\ndecltype\n(\nop\n(\nval\n,\nval\n));\ntemplate\n<\ntypename\nTyGroup\n,\ntypename\nTyAtomic\n,\ntypename\nTyVal\n>\nTyVal\ninclusive_scan_update\n(\nconst\nTyGroup\n&\ngroup\n,\nTyAtomic\n&\natomic\n,\nTyVal\n&&\nval\n);\ntemplate\n<\ntypename\nTyGroup\n,\ntypename\nTyAtomic\n,\ntypename\nTyVal\n,\ntypename\nTyFn\n>\nauto\nexclusive_scan_update\n(\nconst\nTyGroup\n&\ngroup\n,\nTyAtomic\n&\natomic\n,\nTyVal\n&&\nval\n,\nTyFn\n&&\nop\n)\n->\ndecltype\n(\nop\n(\nval\n,\nval\n));\ntemplate\n<\ntypename\nTyGroup\n,\ntypename\nTyAtomic\n,\ntypename\nTyVal\n>\nTyVal\nexclusive_scan_update\n(\nconst\nTyGroup\n&\ngroup\n,\nTyAtomic\n&\natomic\n,\nTyVal\n&&\nval\n);\n*_scan_update\ncollectives take an additional argument\natomic\nthat can be either of\ncuda::atomic\nor\ncuda::atomic_ref\navailable in\nCUDA C++ Standard Library\n. These variants of the API are available only on platforms and devices, where these types are supported by the CUDA C++ Standard Library. These variants will perform an update to the\natomic\naccording to\nop\nwith value of the sum of input values of all threads in the group. Previous value of the\natomic\nwill be combined with the result of scan by each thread and returned. Type held by the\natomic\nmust match the type of\nTyVal\n. Scope of the atomic must include all the threads in the group and if multiple groups are using the same atomic concurrently, scope must include all threads in all groups using it. Atomic update is performed with relaxed memory ordering.\nFollowing pseudocode illustrates how the update variant of scan works:\n/*\ninclusive_scan_update behaves as the following block,\nexcept both reduce and inclusive_scan is calculated simultaneously.\nauto total = reduce(group, val, op);\nTyVal old;\nif (group.thread_rank() == selected_thread) {\natomically {\nold = atomic.load();\natomic.store(op(old, total));\n}\n}\nold = group.shfl(old, selected_thread);\nreturn op(inclusive_scan(group, val, op), old);\n*/\nCodegen Requirements:\nCompute Capability 5.0 minimum, C++11.\ncooperative_groups/scan.h\nheader needs to be included.\nExample:\n#include\n<stdio.h>\n#include\n<cooperative_groups.h>\n#include\n<cooperative_groups/scan.h>\nnamespace\ncg\n=\ncooperative_groups\n;\n__global__\nvoid\nkernel\n()\n{\nauto\nthread_block\n=\ncg\n::\nthis_thread_block\n();\nauto\ntile\n=\ncg\n::\ntiled_partition\n<\n8\n>\n(\nthread_block\n);\nunsigned\nint\nval\n=\ncg\n::\ninclusive_scan\n(\ntile\n,\ntile\n.\nthread_rank\n());\nprintf\n(\n\"%u: %u\n\\n\n\"\n,\ntile\n.\nthread_rank\n(),\nval\n);\n}\n/*  prints for each group:\n0: 0\n1: 1\n2: 3\n3: 6\n4: 10\n5: 15\n6: 21\n7: 28\n*/\nExample of stream compaction using exclusive_scan:\n#include\n<cooperative_groups.h>\n#include\n<cooperative_groups/scan.h>\nnamespace\ncg\n=\ncooperative_groups\n;\n// put data from input into output only if it passes test_fn predicate\ntemplate\n<\ntypename\nGroup\n,\ntypename\nData\n,\ntypename\nTyFn\n>\n__device__\nint\nstream_compaction\n(\nGroup\n&\ng\n,\nData\n*\ninput\n,\nint\ncount\n,\nTyFn\n&&\ntest_fn\n,\nData\n*\noutput\n)\n{\nint\nper_thread\n=\ncount\n/\ng\n.\nnum_threads\n();\nint\nthread_start\n=\nmin\n(\ng\n.\nthread_rank\n()\n*\nper_thread\n,\ncount\n);\nint\nmy_count\n=\nmin\n(\nper_thread\n,\ncount\n-\nthread_start\n);\n// get all passing items from my part of the input\n//  into a contagious part of the array and count them.\nint\ni\n=\nthread_start\n;\nwhile\n(\ni\n<\nmy_count\n+\nthread_start\n)\n{\nif\n(\ntest_fn\n(\ninput\n[\ni\n]))\n{\ni\n++\n;\n}\nelse\n{\nmy_count\n--\n;\ninput\n[\ni\n]\n=\ninput\n[\nmy_count\n+\nthread_start\n];\n}\n}\n// scan over counts from each thread to calculate my starting\n//  index in the output\nint\nmy_idx\n=\ncg\n::\nexclusive_scan\n(\ng\n,\nmy_count\n);\nfor\n(\ni\n=\n0\n;\ni\n<\nmy_count\n;\n++\ni\n)\n{\noutput\n[\nmy_idx\n+\ni\n]\n=\ninput\n[\nthread_start\n+\ni\n];\n}\n// return the total number of items in the output\nreturn\ng\n.\nshfl\n(\nmy_idx\n+\nmy_count\n,\ng\n.\nnum_threads\n()\n-\n1\n);\n}\nExample of dynamic buffer space allocation using exclusive_scan_update:\n#include\n<cooperative_groups.h>\n#include\n<cooperative_groups/scan.h>\nnamespace\ncg\n=\ncooperative_groups\n;\n// Buffer partitioning is static to make the example easier to follow,\n// but any arbitrary dynamic allocation scheme can be implemented by replacing this function.\n__device__\nint\ncalculate_buffer_space_needed\n(\ncg\n::\nthread_block_tile\n<\n32\n>&\ntile\n)\n{\nreturn\ntile\n.\nthread_rank\n()\n%\n2\n+\n1\n;\n}\n__device__\nint\nmy_thread_data\n(\nint\ni\n)\n{\nreturn\ni\n;\n}\n__global__\nvoid\nkernel\n()\n{\n__shared__\nextern\nint\nbuffer\n[];\n__shared__\ncuda\n::\natomic\n<\nint\n,\ncuda\n::\nthread_scope_block\n>\nbuffer_used\n;\nauto\nblock\n=\ncg\n::\nthis_thread_block\n();\nauto\ntile\n=\ncg\n::\ntiled_partition\n<\n32\n>\n(\nblock\n);\nbuffer_used\n=\n0\n;\nblock\n.\nsync\n();\n// each thread calculates buffer size it needs\nint\nbuf_needed\n=\ncalculate_buffer_space_needed\n(\ntile\n);\n// scan over the needs of each thread, result for each thread is an offset\n// of that threadâs part of the buffer. buffer_used is atomically updated with\n// the sum of all thread's inputs, to correctly offset other tileâs allocations\nint\nbuf_offset\n=\ncg\n::\nexclusive_scan_update\n(\ntile\n,\nbuffer_used\n,\nbuf_needed\n);\n// each thread fills its own part of the buffer with thread specific data\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nbuf_needed\n;\n++\ni\n)\n{\nbuffer\n[\nbuf_offset\n+\ni\n]\n=\nmy_thread_data\n(\ni\n);\n}\nblock\n.\nsync\n();\n// buffer_used now holds total amount of memory allocated\n// buffer is {0, 0, 1, 0, 0, 1 ...};\n}\n11.6.4.\nExecution control\nï\n11.6.4.1.\ninvoke_one\nand\ninvoke_one_broadcast\nï\ntemplate\n<\ntypename\nGroup\n,\ntypename\nFn\n,\ntypename\n...\nArgs\n>\nvoid\ninvoke_one\n(\nconst\nGroup\n&\ngroup\n,\nFn\n&&\nfn\n,\nArgs\n&&\n...\nargs\n);\ntemplate\n<\ntypename\nGroup\n,\ntypename\nFn\n,\ntypename\n...\nArgs\n>\nauto\ninvoke_one_broadcast\n(\nconst\nGroup\n&\ngroup\n,\nFn\n&&\nfn\n,\nArgs\n&&\n...\nargs\n)\n->\ndecltype\n(\nfn\n(\nargs\n...));\ninvoke_one\nselects a single arbitrary thread from the calling\ngroup\nand uses that thread to call the supplied invocable\nfn\nwith the supplied arguments\nargs\n.\nIn case of\ninvoke_one_broadcast\nthe result of the call is also distributed to all threads in the group and returned from this collective.\nCalling group can be synchronized with the selected thread before and/or after it calls the supplied invocable. It means that communication within the calling group\nis not allowed inside the supplied invocable body, otherwise forward progress is not guaranteed. Communication with threads outside of the calling group is allowed in the\nbody of the supplied invocable. Thread selection mechanism is\nnot\nguaranteed to be deterministic.\nOn devices with Compute Capability 9.0 or higher hardware acceleration might be used to select the thread when called with\nexplicit group types\n.\ngroup\n: All group types are valid for\ninvoke_one\n,\ncoalesced_group\nand\nthread_block_tile\nare valid for\ninvoke_one_broadcast\n.\nfn\n: Function or object that can be invoked using\noperator()\n.\nargs\n: Parameter pack of types matching types of parameters of the supplied invocable\nfn\n.\nIn case of\ninvoke_one_broadcast\nthe return type of the supplied invocable\nfn\nmust satisfy the below requirements:\nQualifies as trivially copyable i.e.\nis_trivially_copyable<T>::value\n==\ntrue\nsizeof(T)\n<=\n32\nfor\ncoalesced_group\nand tiles of size lower or equal 32,\nsizeof(T)\n<=\n8\nfor larger tiles\nCodegen Requirements:\nCompute Capability 5.0 minimum, Compute Capability 9.0 for hardware acceleration, C++11.\nAggregated atomic example from\nDiscovery pattern section\nre-written to use invoke_one_broadcast:\n#include\n<cooperative_groups.h>\n#include\n<cuda/atomic>\nnamespace\ncg\n=\ncooperative_groups\n;\ntemplate\n<\ncuda\n::\nthread_scope\nScope\n>\n__device__\nunsigned\nint\natomicAddOneRelaxed\n(\ncuda\n::\natomic\n<\nunsigned\nint\n,\nScope\n>&\natomic\n)\n{\nauto\ng\n=\ncg\n::\ncoalesced_threads\n();\nauto\nprev\n=\ncg\n::\ninvoke_one_broadcast\n(\ng\n,\n[\n&\n]\n()\n{\nreturn\natomic\n.\nfetch_add\n(\ng\n.\nnum_threads\n(),\ncuda\n::\nmemory_order_relaxed\n);\n});\nreturn\nprev\n+\ng\n.\nthread_rank\n();\n}\n11.7.\nGrid Synchronization\nï\nPrior to the introduction of Cooperative Groups, the CUDA programming model only allowed synchronization between thread blocks at a kernel completion boundary. The kernel boundary carries with it an implicit invalidation of state, and with it, potential performance implications.\nFor example, in certain use cases, applications have a large number of small kernels, with each kernel representing a stage in a processing pipeline. The presence of these kernels is required by the current CUDA programming model to ensure that the thread blocks operating on one pipeline stage have produced data before the thread block operating on the next pipeline stage is ready to consume it. In such cases, the ability to provide global inter thread block synchronization would allow the application to be restructured to have persistent thread blocks, which are able to synchronize on the device when a given stage is complete.\nTo synchronize across the grid, from within a kernel, you would simply use the\ngrid.sync()\nfunction:\ngrid_group\ngrid\n=\nthis_grid\n();\ngrid\n.\nsync\n();\nAnd when launching the kernel it is necessary to use, instead of the\n<<<...>>>\nexecution configuration syntax, the\ncudaLaunchCooperativeKernel\nCUDA runtime launch API or the\nCUDA\ndriver\nequivalent\n.\nExample:\nTo guarantee co-residency of the thread blocks on the GPU, the number of blocks launched needs to be carefully considered. For example, as many blocks as there are SMs can be launched as follows:\nint\ndev\n=\n0\n;\ncudaDeviceProp\ndeviceProp\n;\ncudaGetDeviceProperties\n(\n&\ndeviceProp\n,\ndev\n);\n// initialize, then launch\ncudaLaunchCooperativeKernel\n((\nvoid\n*\n)\nmy_kernel\n,\ndeviceProp\n.\nmultiProcessorCount\n,\nnumThreads\n,\nargs\n);\nAlternatively, you can maximize the exposed parallelism by calculating how many blocks can fit simultaneously per-SM using the occupancy calculator as follows:\n/// This will launch a grid that can maximally fill the GPU, on the default stream with kernel arguments\nint\nnumBlocksPerSm\n=\n0\n;\n// Number of threads my_kernel will be launched with\nint\nnumThreads\n=\n128\n;\ncudaDeviceProp\ndeviceProp\n;\ncudaGetDeviceProperties\n(\n&\ndeviceProp\n,\ndev\n);\ncudaOccupancyMaxActiveBlocksPerMultiprocessor\n(\n&\nnumBlocksPerSm\n,\nmy_kernel\n,\nnumThreads\n,\n0\n);\n// launch\nvoid\n*\nkernelArgs\n[]\n=\n{\n/* add kernel args */\n};\ndim3\ndimBlock\n(\nnumThreads\n,\n1\n,\n1\n);\ndim3\ndimGrid\n(\ndeviceProp\n.\nmultiProcessorCount\n*\nnumBlocksPerSm\n,\n1\n,\n1\n);\ncudaLaunchCooperativeKernel\n((\nvoid\n*\n)\nmy_kernel\n,\ndimGrid\n,\ndimBlock\n,\nkernelArgs\n);\nIt is good practice to first ensure the device supports cooperative launches by querying the device attribute\ncudaDevAttrCooperativeLaunch\n:\nint\ndev\n=\n0\n;\nint\nsupportsCoopLaunch\n=\n0\n;\ncudaDeviceGetAttribute\n(\n&\nsupportsCoopLaunch\n,\ncudaDevAttrCooperativeLaunch\n,\ndev\n);\nwhich will set\nsupportsCoopLaunch\nto 1 if the property is supported on device 0. Only devices with compute capability of 6.0 and higher are supported. In addition, you need to be running on either of these:\nThe Linux platform without MPS\nThe Linux platform with MPS and on a device with compute capability 7.0 or higher\nThe latest Windows platform\n12.\nCluster Launch Control\nï\n12.1.\nIntroduction\nï\nCompute Capability 10.0 introduces Cluster Launch Control, a new\nfeature that provides developer with more control over thread block scheduling\nby cancelling thread blocks or thread block clusters.\nWhen dealing with problems of variable size, there are two main\napproaches to determining the number of kernel thread blocks.\nApproach 1: Fixed Work per Thread Block:\nIn this approach, the number of thread blocks is determined by the problem\nsize, while the amount of work done by each thread block remains constant\nor is limited.\nKey advantages of this approach:\nLoad balancing between SMs.\nIn particular, when thread block run-times exhibit variability\nand/or when the number of thread blocks is much larger than what\nthe GPU can execute simultaneously (resulting in a low-tail effect),\nthis approach allows the GPU scheduler to run more thread blocks\non some SMs than others.\nPreemption.\nThe GPU scheduler can start executing a\nhigher-priority kernel\n,\neven if it is launched after the execution of a lower-priority kernel has\nalready begun, by scheduling the higher-priority kernelâs thread blocks\nas the currently running lower-priority kernelâs thread blocks finish.\nIt can then return to the lower-priority kernel once the higher-priority\nkernel has finished.\nApproach 2: Fixed Number of Thread Blocks:\nIn this approach, often implemented as a block-stride or grid-stride loop,\nthe number of thread blocks does not directly depend\non the problem size. Instead, the amount of work done by each thread block\nis a function of the problem size. Typically, the number of thread blocks is\nbased on the number of SMs on the GPU where the kernel is executed\nand the desired occupancy.\nKey advantage of this approach:\nReduced thread block overheads.\nThis approach not only reduces amortized thread block launch latency\nbut also minimizes the computational overhead associated with shared\noperations across all thread blocks.\nThese overheads can be significantly higher than launch latency overheads.\nFor example, in convolution kernels, a prologue for calculating\nconvolution coefficients â independent of the thread block index â\ncan be computed fewer times due to the fixed number of thread blocks,\nthus reducing redundant computations.\nCluster Launch Control Approach:\nCluster Launch Control allows a kernel to request (\ncancel\n)\nthe thread block index of a block that has not yet started execution.\nThis mechanism enables work-stealing among thread blocks:\na thread block attempts to cancel the launch of another thread block\nthat has not started running yet. If cancellation succeeds,\nit âstealsâ the other thread blockâs work by using cancelled block index\nto perform the task.\nThe cancellation will fail if there are no more thread block indices\navailable and may fail for other reasons, such as a higher-priority kernel\nbeing scheduled. In the latter case, if a thread block exits after a\ncancellation failure, the scheduler can start executing the higher-priority\nkernel, after which it will continue scheduling the remaining thread blocks\nof the current kernel for execution.\nThe table below summarizes advantages and disadvantages of the three approaches:\nFixed Work per Thread Block\nFixed Number of Thread Blocks\nCluster Launch Control\nReduced overheads\n\\(\\textcolor{red}{\\textbf{X}}\\)\n\\(\\textcolor{lime}{\\textbf{V}}\\)\n\\(\\textcolor{lime}{\\textbf{V}}\\)\nPreemption\n\\(\\textcolor{lime}{\\textbf{V}}\\)\n\\(\\textcolor{red}{\\textbf{X}}\\)\n\\(\\textcolor{lime}{\\textbf{V}}\\)\nLoad balancing\n\\(\\textcolor{lime}{\\textbf{V}}\\)\n\\(\\textcolor{red}{\\textbf{X}}\\)\n\\(\\textcolor{lime}{\\textbf{V}}\\)\n12.2.\nCluster Launch Control API Details\nï\nCancelling a thread block via the Cluster Launch Control API is done\nasynchronously and synchronized using a memory barrier,\nfollowing a programming pattern similar\nto\nasynchronous data copies\n.\nThe API, currently available through\nlibcu++\n,\nprovides a request instruction that writes the encoded cancellation result\ninto a\n__shared__\nvariable, along with instructions to decode the result\ninto a\nSuccess\n/\nFail\nflag and the index of the cancelled thread block\nin case of\nSuccess\n.\n12.2.1.\nThread block cancellation steps\nï\nThe preferred way to use Cluster Launch Control is from a single thread,\ni.e., one request at a time.\nThe following are the five steps of the thread block cancellation process.\nThe first two steps are declarations and initialization of cancellation result\nand synchronization variables, which are done before the work-stealing.\nThe last three steps are typically executed inside a work-stealing loop\nover thread block indices.\nDeclare variables for thread block cancellation:\n__shared__\nuint4\nresult\n;\n// Request result.\n__shared__\nuint64_t\nbar\n;\n// Synchronization barrier.\nint\nphase\n=\n0\n;\n// Synchronization barrier phase.\nInitialize shared memory barrier with a single arrival count:\nif\n(\ncg\n::\nthread_block\n::\nthread_rank\n()\n==\n0\n)\nptx\n::\nmbarrier_init\n(\n&\nbar\n,\n1\n);\n__syncthreads\n();\nSubmit asynchronous cancellation request by a single thread and\nset transaction count:\nif\n(\ncg\n::\nthread_block\n::\nthread_rank\n()\n==\n0\n)\n{\ncg\n::\ninvoke_one\n(\ncg\n::\ncoalesced_threads\n(),\nptx\n::\nclusterlaunchcontrol_try_cancel\n,\n&\nresult\n,\n&\nbar\n);\nptx\n::\nmbarrier_arrive_expect_tx\n(\nptx\n::\nsem_relaxed\n,\nptx\n::\nscope_cta\n,\nptx\n::\nspace_shared\n,\n&\nbar\n,\nsizeof\n(\nuint4\n));\n}\nNote\nSince thread block cancellation is a uniform instruction,\nit is recommended to submit it inside\ninvoke_one\nthread selector.\nThis allows the compliler to optimize out the peeling loop.\nSynchronize (complete) asynchronous cancellation request:\nwhile\n(\n!\nptx\n::\nmbarrier_try_wait_parity\n(\n&\nbar\n,\nphase\n))\n{}\nphase\n^=\n1\n;\nRetrieve cancellation status and cancelled thread block index:\nbool\nsuccess\n=\nptx\n::\nclusterlaunchcontrol_query_cancel_is_canceled\n(\nresult\n);\nif\n(\nsuccess\n)\n{\n// Don't need all three for 1D/2D thread blocks:\nint\nbx\n=\nptx\n::\nclusterlaunchcontrol_query_cancel_get_first_ctaid_x\n(\nresult\n);\nint\nby\n=\nptx\n::\nclusterlaunchcontrol_query_cancel_get_first_ctaid_y\n(\nresult\n);\nint\nbz\n=\nptx\n::\nclusterlaunchcontrol_query_cancel_get_first_ctaid_z\n(\nresult\n);\n}\nEnsure visibility of shared memory operations between async and generic\nproxies\n,\nand protect against data races between iterations of the work-stealing loop.\n12.2.2.\nThread block cancellation constraints\nï\nThe constraints are related to failed cancellation requests:\nSubmitting another cancellation request after\nobserving\na\npreviously failed request is Undefined Behavior.\nIn the two code examples below, assuming the first cancellation request\nfails, only the first example exhibits undefined behavior.\nThe second example is correct because there is no observation between the\ncancellation requests:\nInvalid code:\n// First request:\nptx\n::\nclusterlaunchcontrol_try_cancel\n(\n&\nresult0\n,\n&\nbar0\n);\n// First request query:\n[\nSynchronize\nbar0\ncode\nhere\n.]\nbool\nsuccess0\n=\nptx\n::\nclusterlaunchcontrol_query_cancel_is_canceled\n(\nresult0\n);\nassert\n(\n!\nsuccess0\n);\n// Observed failure; second cacellation will be invalid.\n// Second request - next line is Undefined Behavior:\nptx\n::\nclusterlaunchcontrol_try_cancel\n(\n&\nresult1\n,\n&\nbar1\n);\nValid code:\n// First request:\nptx\n::\nclusterlaunchcontrol_try_cancel\n(\n&\nresult0\n,\n&\nbar0\n);\n// Second request:\nptx\n::\nclusterlaunchcontrol_try_cancel\n(\n&\nresult1\n,\n&\nbar1\n);\n// First request query:\n[\nSynchronize\nbar0\ncode\nhere\n.]\nbool\nsuccess0\n=\nptx\n::\nclusterlaunchcontrol_query_cancel_is_canceled\n(\nresult0\n);\nassert\n(\n!\nsuccess0\n);\n// Observed failure; second cacellation was valid.\nRetrieving the thread block index of a failed cancellation request\nis Undefined Behavior.\nSubmitting a cancellation request from multiple threads is not recommended.\nIt results in the cancellation of multiple thread blocks\nand requires careful handling,\nsuch as:\nEach submitting thread must proivde a unique\n__shared__\nresult\npointer to avoid data races.\nIf the same barrier is used for synchronization, the arrival and\ntransaction counts must be adjusted accordingly.\n12.2.3.\nKernel Example: Vector-Scalar Multiplication\nï\nThe three kernels below demonstrate the Fixed Work per Thread Block,\nFixed Number of Thread Blocks, and Cluster Launch Control approaches\nfor vector-scalar multiplication\n\\(\\overline{v} := \\alpha \\overline{v}\\)\n.\nFixed Work per Thread Block:\n__global__\nvoid\nkernel_fixed_work\n(\nfloat\n*\ndata\n,\nint\nn\n)\n{\n// Prologue:\nfloat\nalpha\n=\ncompute_scalar\n();\n// Computation:\nint\ni\n=\nblockIdx\n.\nx\n*\nblockDim\n.\nx\n+\nthreadIdx\n.\nx\n;\nif\n(\ni\n<\nn\n)\ndata\n[\ni\n]\n*=\nalpha\n;\n}\n// Launch: kernel_fixed_work<<<1024, (n + 1023) / 1024>>>(data, n);\nFixed Number of Thread Blocks:\n__global__\nvoid\nkernel_fixed_blocks\n(\nfloat\n*\ndata\n,\nint\nn\n)\n{\n// Prologue:\nfloat\nalpha\n=\ncompute_scalar\n();\n// Computation:\nint\ni\n=\nblockIdx\n.\nx\n*\nblockDim\n.\nx\n+\nthreadIdx\n.\nx\n;\nwhile\n(\ni\n<\nn\n)\n{\ndata\n[\ni\n]\n*=\nalpha\n;\ni\n+=\ngridDim\n.\nx\n*\nblockDim\n.\nx\n;\n}\n}\n// Launch: kernel_fixed_blocks<<<1024, SM_COUNT>>>(data, n);\nCluster Launch Control:\n#include\n<cooperative_groups.h>\n#include\n<cuda/ptx>\nnamespace\ncg\n=\ncooperative_groups\n;\nnamespace\nptx\n=\ncuda\n::\nptx\n;\n__global__\nvoid\nkernel_cluster_launch_control\n(\nfloat\n*\ndata\n,\nint\nn\n)\n{\n// Cluster launch control initialization:\n__shared__\nuint4\nresult\n;\n__shared__\nuint64_t\nbar\n;\nint\nphase\n=\n0\n;\nif\n(\ncg\n::\nthread_block\n::\nthread_rank\n()\n==\n0\n)\nptx\n::\nmbarrier_init\n(\n&\nbar\n,\n1\n);\n// Prologue:\nfloat\nalpha\n=\ncompute_scalar\n();\n// Device function not shown in this code snippet.\n// Work-stealing loop:\nint\nbx\n=\nblockIdx\n.\nx\n;\n// Assuming 1D x-axis thread blocks.\nwhile\n(\ntrue\n)\n{\n// Protect result from overwrite in the next iteration,\n// (also ensure barrier initialization at 1st iteration):\n__syncthreads\n();\n// Cancellation request:\nif\n(\ncg\n::\nthread_block\n::\nthread_rank\n()\n==\n0\n)\n{\n// Acquire write of result in the async proxy:\nptx\n::\nfence_proxy_async_generic_sync_restrict\n(\nptx\n::\nsem_acquire\n,\nptx\n::\nspace_cluster\n,\nptx\n::\nscope_cluster\n);\ncg\n::\ninvoke_one\n(\ncg\n::\ncoalesced_threads\n(),\n[\n&\n](){\nptx\n::\nclusterlaunchcontrol_try_cancel\n(\n&\nresult\n,\n&\nbar\n);});\nptx\n::\nmbarrier_arrive_expect_tx\n(\nptx\n::\nsem_relaxed\n,\nptx\n::\nscope_cta\n,\nptx\n::\nspace_shared\n,\n&\nbar\n,\nsizeof\n(\nuint4\n));\n}\n// Computation:\nint\ni\n=\nbx\n*\nblockDim\n.\nx\n+\nthreadIdx\n.\nx\n;\nif\n(\ni\n<\nn\n)\ndata\n[\ni\n]\n*=\nalpha\n;\n// Cancellation request synchronization:\nwhile\n(\n!\nptx\n::\nmbarrier_try_wait_parity\n(\nptx\n::\nsem_acquire\n,\nptx\n::\nscope_cta\n,\n&\nbar\n,\nphase\n))\n{}\nphase\n^=\n1\n;\n// Cancellation request decoding:\nbool\nsuccess\n=\nptx\n::\nclusterlaunchcontrol_query_cancel_is_canceled\n(\nresult\n);\nif\n(\n!\nsuccess\n)\nbreak\n;\nbx\n=\nptx\n::\nclusterlaunchcontrol_query_cancel_get_first_ctaid_x\n<\nint\n>\n(\nresult\n);\n// Release read of result to the async proxy:\nptx\n::\nfence_proxy_async_generic_sync_restrict\n(\nptx\n::\nsem_release\n,\nptx\n::\nspace_shared\n,\nptx\n::\nscope_cluster\n);\n}\n}\n// Launch: kernel_cluster_launch_control<<<1024, (n + 1023) / 1024>>>(data, n);\n12.2.4.\nCluster Launch Control for Thread Block Clusters\nï\nIn the case of a\nthread block clusters\n,\nthe thread block cancellation steps are the same as in a non-cluster setting,\nwith minor adjustments.\nAs in the non-cluster case, submitting a cancellation request from multiple\nthreads\nwithin a cluster\nis not recommended,\nas this will attempt to cancel multiple clusters.\nThe cancellation is submitted by a single cluster thread.\nThe shared memory result of each clusterâs thread block will receive\nthe same (encoded) value of the cancelled thread block index\n(i.e., the result value is multicasted).\nThe result received by all thread blocks corresponds to the local\nblock index\n{0,\n0,\n0}\nwithin a cluster.\nTherefore, thread blocks within the cluster need to add\nthe local block index.\nSynchronization is performed by each clusterâs thread block using\na local\n__shared__\nmemory barrier. Barrier operations must be performed\nwith the\nptx::scope_cluster\nscope.\nCancelling in the cluster case requires all the thread blocks to exist.\nA user can guarantee that all thread blocks are running by using\ncg::cluster_group::sync()\nfrom\nCluster Group\nAPI.\nThe kernel below demonstrates Cluster Launch Control approach\nin a thread block cluster case:\n#include\n<cooperative_groups.h>\n#include\n<cuda/ptx>\nnamespace\ncg\n=\ncooperative_groups\n;\nnamespace\nptx\n=\ncuda\n::\nptx\n;\n__global__\n__cluster_dims__\n(\n2\n,\n1\n,\n1\n)\nvoid\nkernel_cluster_launch_control\n(\nfloat\n*\ndata\n,\nint\nn\n)\n{\n// Cluster launch control initialization:\n__shared__\nuint4\nresult\n;\n__shared__\nuint64_t\nbar\n;\nint\nphase\n=\n0\n;\nif\n(\ncg\n::\nthread_block\n::\nthread_rank\n()\n==\n0\n)\n{\nptx\n::\nmbarrier_init\n(\n&\nbar\n,\n1\n);\nptx\n::\nfence_mbarrier_init\n(\nptx\n::\nsem_release\n,\nptx\n::\nscope_cluster\n);\n// CGA-level fence.\n}\n// Prologue:\nfloat\nalpha\n=\ncompute_scalar\n();\n// Device function not shown in this code snippet.\n// Work-stealing loop:\nint\nbx\n=\nblockIdx\n.\nx\n;\n// Assuming 1D x-axis thread blocks.\nwhile\n(\ntrue\n)\n{\n// Protect result from overwrite in the next iteration,\n// (also ensure all thread blocks have started at 1st iteration):\ncg\n::\ncluster_group\n::\nsync\n();\n// Cancellation request by a single cluster thread:\nif\n(\ncg\n::\ncluster_group\n::\nthread_rank\n()\n==\n0\n)\n{\n// Acquire write of result in the async proxy:\nptx\n::\nfence_proxy_async_generic_sync_restrict\n(\nptx\n::\nsem_acquire\n,\nptx\n::\nspace_cluster\n,\nptx\n::\nscope_cluster\n);\ncg\n::\ninvoke_one\n(\ncg\n::\ncoalesced_threads\n(),\n[\n&\n](){\nptx\n::\nclusterlaunchcontrol_try_cancel_multicast\n(\n&\nresult\n,\n&\nbar\n);});\n}\n// Cancellation completion tracked by each thread block:\nif\n(\ncg\n::\nthread_block\n::\nthread_rank\n()\n==\n0\n)\nptx\n::\nmbarrier_arrive_expect_tx\n(\nptx\n::\nsem_relaxed\n,\nptx\n::\nscope_cluster\n,\nptx\n::\nspace_shared\n,\n&\nbar\n,\nsizeof\n(\nuint4\n));\n// Computation:\nint\ni\n=\nbx\n*\nblockDim\n.\nx\n+\nthreadIdx\n.\nx\n;\nif\n(\ni\n<\nn\n)\ndata\n[\ni\n]\n*=\nalpha\n;\n// Cancellation request synchronization:\nwhile\n(\n!\nptx\n::\nmbarrier_try_wait_parity\n(\nptx\n::\nsem_acquire\n,\nptx\n::\nscope_cluster\n,\n&\nbar\n,\nphase\n))\n{}\nphase\n^=\n1\n;\n// Cancellation request decoding:\nbool\nsuccess\n=\nptx\n::\nclusterlaunchcontrol_query_cancel_is_canceled\n(\nresult\n);\nif\n(\n!\nsuccess\n)\nbreak\n;\nbx\n=\nptx\n::\nclusterlaunchcontrol_query_cancel_get_first_ctaid_x\n<\nint\n>\n(\nresult\n);\nbx\n+=\ncg\n::\ncluster_group\n::\nblock_index\n().\nx\n;\n// Add local offset.\n// Release read of result to the async proxy:\nptx\n::\nfence_proxy_async_generic_sync_restrict\n(\nptx\n::\nsem_release\n,\nptx\n::\nspace_shared\n,\nptx\n::\nscope_cluster\n);\n}\n}\n// Launch: kernel_cluster_launch_control<<<1024, (n + 1023) / 1024>>>(data, n);\n13.\nCUDA Dynamic Parallelism\nï\n13.1.\nIntroduction\nï\n13.1.1.\nOverview\nï\nDynamic Parallelism\nis an extension to the CUDA programming model enabling a CUDA kernel to create and synchronize with new work directly on the GPU. The creation of parallelism dynamically at whichever point in a program that it is needed offers exciting capabilities.\nThe ability to create work directly from the GPU can reduce the need to transfer execution control and data between host and device, as launch configuration decisions can now be made at runtime by threads executing on the device. Additionally, data-dependent parallel work can be generated inline within a kernel at run-time, taking advantage of the GPUâs hardware schedulers and load balancers dynamically and adapting in response to data-driven decisions or workloads. Algorithms and programming patterns that had previously required modifications to eliminate recursion, irregular loop structure, or other constructs that do not fit a flat, single-level of parallelism may more transparently be expressed.\nThis document describes the extended capabilities of CUDA which enable Dynamic Parallelism, including the modifications and additions to the CUDA programming model necessary to take advantage of these, as well as guidelines and best practices for exploiting this added capacity.\nDynamic Parallelism is only supported by devices of compute capability 3.5 and higher.\n13.1.2.\nGlossary\nï\nDefinitions for terms used in this guide.\nGrid\nA Grid is a collection of\nThreads\n. Threads in a Grid execute a\nKernel Function\nand are divided into\nThread Blocks\n.\nThread Block\nA Thread Block is a group of threads which execute on the same multiprocessor (\nSM\n). Threads within a Thread Block have access to shared memory and can be explicitly synchronized.\nKernel Function\nA Kernel Function is an implicitly parallel subroutine that executes under the CUDA execution and memory model for every Thread in a Grid.\nHost\nThe Host refers to the execution environment that initially invoked CUDA. Typically the thread running on a systemâs CPU processor.\nParent\nA\nParent Thread\n, Thread Block, or Grid is one that has launched new grid(s), the\nChild\nGrid(s). The Parent is not considered completed until all of its launched Child Grids have also completed.\nChild\nA Child thread, block, or grid is one that has been launched by a Parent grid. A Child grid must complete before the Parent Thread, Thread Block, or Grid are considered complete.\nThread Block Scope\nObjects with Thread Block Scope have the lifetime of a single Thread Block. They only have defined behavior when operated on by Threads in the Thread Block that created the object and are destroyed when the Thread Block that created them is complete.\nDevice Runtime\nThe Device Runtime refers to the runtime system and APIs available to enable Kernel Functions to use Dynamic Parallelism.\n13.2.\nExecution Environment and Memory Model\nï\n13.2.1.\nExecution Environment\nï\nThe CUDA execution model is based on primitives of threads, thread blocks, and grids, with kernel functions defining the program executed by individual threads within a thread block and grid. When a kernel function is invoked the gridâs properties are described by an execution configuration, which has a special syntax in CUDA. Support for dynamic parallelism in CUDA extends the ability to configure, launch, and implicitly synchronize upon new grids to threads that are running on the device.\n13.2.1.1.\nParent and Child Grids\nï\nA device thread that configures and launches a new grid belongs to the parent grid, and the grid created by the invocation is a child grid.\nThe invocation and completion of child grids is properly nested, meaning that the parent grid is not considered complete until all child grids created by its threads have completed, and the runtime guarantees an implicit synchronization between the parent and child.\nFigure 30\nParent-Child Launch Nesting\nï\n13.2.1.2.\nScope of CUDA Primitives\nï\nOn both host and device, the CUDA runtime offers an API for launching kernels and for tracking dependencies between launches via streams and events. On the host system, the state of launches and the CUDA primitives referencing streams and events are shared by all threads within a process; however processes execute independently and may not share CUDA objects.\nOn the device, launched kernels and CUDA objects are visible to all threads in a grid. This means, for example, that a stream may be created by one thread and used by any other thread in the grid.\n13.2.1.3.\nSynchronization\nï\nWarning\nExplicit synchronization with child kernels from a parent block (i.e. using\ncudaDeviceSynchronize()\nin device code) is deprecated in CUDA 11.6 and removed for compute_90+ compilation. For compute capability < 9.0, compile-time opt-in by specifying\n-DCUDA_FORCE_CDP1_IF_SUPPORTED\nis required to continue using\ncudaDeviceSynchronize()\nin device code. Note that this is slated for full removal in a future CUDA release.\nCUDA runtime operations from any thread, including kernel launches, are visible across all the threads in a grid. This means that an invoking thread in the parent grid may perform synchronization to control the launch order of grids launched by any thread in the grid on streams created by any thread in the grid. Execution of a grid is not considered complete until all launches by all threads in the grid have completed. If all threads in a grid exit before all child launches have completed, an implicit synchronization operation will automatically be triggered.\n13.2.1.4.\nStreams and Events\nï\nCUDA\nStreams\nand\nEvents\nallow control over dependencies between grid launches: grids launched into the same stream execute in-order, and events may be used to create dependencies between streams. Streams and events created on the device serve this exact same purpose.\nStreams and events created within a grid exist within grid scope, but have undefined behavior when used outside of the grid where they were created. As described above, all work launched by a grid is implicitly synchronized when the grid exits; work launched into streams is included in this, with all dependencies resolved appropriately. The behavior of operations on a stream that has been modified outside of grid scope is undefined.\nStreams and events created on the host have undefined behavior when used within any kernel, just as streams and events created by a parent grid have undefined behavior if used within a child grid.\n13.2.1.5.\nOrdering and Concurrency\nï\nThe ordering of kernel launches from the device runtime follows CUDA Stream ordering semantics. Within a grid, all kernel launches into the same stream (with the exception of the fire-and-forget stream discussed later) are executed in-order. With multiple threads in the same grid launching into the same stream, the ordering within the stream is dependent on the thread scheduling within the grid, which may be controlled with synchronization primitives such as\n__syncthreads()\n.\nNote that while named streams are shared by all threads within a grid, the implicit\nNULL\nstream is only shared by all threads within a thread block. If multiple threads in a thread block launch into the implicit stream, then these launches will be executed in-order. If multiple threads in different thread blocks launch into the implicit stream, then these launches may be executed concurrently. If concurrency is desired for launches by multiple threads within a thread block, explicit named streams should be used.\nDynamic Parallelism\nenables concurrency to be expressed more easily within a program; however, the device runtime introduces no new concurrency guarantees within the CUDA execution model. There is no guarantee of concurrent execution between any number of different thread blocks on a device.\nThe lack of concurrency guarantee extends to a parent grid and their child grids. When a parent grid launches a child grid, the child may start to execute once stream dependencies are satisfied and hardware resources are available to host the child, but is not guaranteed to begin execution until the parent grid reaches an implicit synchronization point.\nWhile concurrency will often easily be achieved, it may vary as a function of device configuration, application workload, and runtime scheduling. It is therefore unsafe to depend upon any concurrency between different thread blocks.\n13.2.1.6.\nDevice Management\nï\nThere is no multi-GPU support from the device runtime; the device runtime is only capable of operating on the device upon which it is currently executing. It is permitted, however, to query properties for any CUDA capable device in the system.\n13.2.2.\nMemory Model\nï\nParent and child grids share the same global and constant memory storage, but have distinct local and shared memory.\n13.2.2.1.\nCoherence and Consistency\nï\n13.2.2.1.1.\nGlobal Memory\nï\nParent and child grids have coherent access to global memory, with weak consistency guarantees between child and parent. There is only one point of time in the execution of a child grid when its view of memory is fully consistent with the parent thread: at the point when the child grid is invoked by the parent.\nAll global memory operations in the parent thread prior to the child gridâs invocation are visible to the child grid. With the removal of\ncudaDeviceSynchronize()\n, it is no longer possible to access the modifications made by the threads in the child grid from the parent grid. The only way to access the modifications made by the threads in the child grid before the parent grid exits is via a kernel launched into the\ncudaStreamTailLaunch\nstream.\nIn the following example, the child grid executing\nchild_launch\nis only guaranteed to see the modifications to\ndata\nmade before the child grid was launched. Since thread 0 of the parent is performing the launch, the child will be consistent with the memory seen by thread 0 of the parent. Due to the first\n__syncthreads()\ncall, the child will see\ndata[0]=0\n,\ndata[1]=1\n, â¦,\ndata[255]=255\n(without the\n__syncthreads()\ncall, only\ndata[0]=0\nwould be guaranteed to be seen by the child). The child grid is only guaranteed to return at an implicit synchronization. This means that the modifications made by the threads in the child grid are never guaranteed to become available to the parent grid. To access modifications made by\nchild_launch\n, a\ntail_launch\nkernel is launched into the\ncudaStreamTailLaunch\nstream.\n__global__\nvoid\ntail_launch\n(\nint\n*\ndata\n)\n{\ndata\n[\nthreadIdx\n.\nx\n]\n=\ndata\n[\nthreadIdx\n.\nx\n]\n+\n1\n;\n}\n__global__\nvoid\nchild_launch\n(\nint\n*\ndata\n)\n{\ndata\n[\nthreadIdx\n.\nx\n]\n=\ndata\n[\nthreadIdx\n.\nx\n]\n+\n1\n;\n}\n__global__\nvoid\nparent_launch\n(\nint\n*\ndata\n)\n{\ndata\n[\nthreadIdx\n.\nx\n]\n=\nthreadIdx\n.\nx\n;\n__syncthreads\n();\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\nchild_launch\n<<<\n1\n,\n256\n>>>\n(\ndata\n);\ntail_launch\n<<<\n1\n,\n256\n,\n0\n,\ncudaStreamTailLaunch\n>>>\n(\ndata\n);\n}\n}\nvoid\nhost_launch\n(\nint\n*\ndata\n)\n{\nparent_launch\n<<<\n1\n,\n256\n>>>\n(\ndata\n);\n}\n13.2.2.1.2.\nZero Copy Memory\nï\nZero-copy system memory has identical coherence and consistency guarantees to global memory, and follows the semantics detailed above. A kernel may not allocate or free zero-copy memory, but may use pointers to zero-copy passed in from the host program.\n13.2.2.1.3.\nConstant Memory\nï\nConstants may not be modified from the device. They may only be modified from the host, but the behavior of modifying a constant from the host while there is a concurrent grid that access that constant at any point during its lifetime is undefined.\n13.2.2.1.4.\nShared and Local Memory\nï\nShared and Local memory is private to a thread block or thread, respectively, and is not visible or coherent between parent and child. Behavior is undefined when an object in one of these locations is referenced outside of the scope within which it belongs, and may cause an error.\nThe NVIDIA compiler will attempt to warn if it can detect that a pointer to local or shared memory is being passed as an argument to a kernel launch. At runtime, the programmer may use the\n__isGlobal()\nintrinsic to determine whether a pointer references global memory and so may safely be passed to a child launch.\nNote that calls to\ncudaMemcpy*Async()\nor\ncudaMemset*Async()\nmay invoke new child kernels on the device in order to preserve stream semantics. As such, passing shared or local memory pointers to these APIs is illegal and will return an error.\n13.2.2.1.5.\nLocal Memory\nï\nLocal memory is private storage for an executing thread, and is not visible outside of that thread. It is illegal to pass a pointer to local memory as a launch argument when launching a child kernel. The result of dereferencing such a local memory pointer from a child will be undefined.\nFor example the following is illegal, with undefined behavior if\nx_array\nis accessed by\nchild_launch\n:\nint\nx_array\n[\n10\n];\n// Creates x_array in parent's local memory\nchild_launch\n<<<\n1\n,\n1\n>>>\n(\nx_array\n);\nIt is sometimes difficult for a programmer to be aware of when a variable is placed into local memory by the compiler. As a general rule, all storage passed to a child kernel should be allocated explicitly from the global-memory heap, either with\ncudaMalloc()\n,\nnew()\nor by declaring\n__device__\nstorage at global scope. For example:\n// Correct - \"value\" is global storage\n__device__\nint\nvalue\n;\n__device__\nvoid\nx\n()\n{\nvalue\n=\n5\n;\nchild\n<<<\n1\n,\n1\n>>>\n(\n&\nvalue\n);\n}\n// Invalid - \"value\" is local storage\n__device__\nvoid\ny\n()\n{\nint\nvalue\n=\n5\n;\nchild\n<<<\n1\n,\n1\n>>>\n(\n&\nvalue\n);\n}\n13.2.2.1.6.\nTexture Memory\nï\nWrites to the global memory region over which a texture is mapped are incoherent with respect to texture accesses. Coherence for texture memory is enforced at the invocation of a child grid and when a child grid completes. This means that writes to memory prior to a child kernel launch are reflected in texture memory accesses of the child. Similarly to Global Memory above, writes to memory by a child are never guaranteed to be reflected in the texture memory accesses by a parent. The only way to access the modifications made by the threads in the child grid before the parent grid exits is via a kernel launched into the\ncudaStreamTailLaunch\nstream. Concurrent accesses by parent and child may result in inconsistent data.\n13.3.\nProgramming Interface\nï\n13.3.1.\nCUDA C++ Reference\nï\nThis section describes changes and additions to the CUDA C++ language extensions for supporting\nDynamic Parallelism\n.\nThe language interface and API available to CUDA kernels using CUDA C++ for Dynamic Parallelism, referred to as the\nDevice Runtime\n, is substantially like that of the CUDA Runtime API available on the host. Where possible the syntax and semantics of the CUDA Runtime API have been retained in order to facilitate ease of code reuse for routines that may run in either the host or device environments.\nAs with all code in CUDA C++, the APIs and code outlined here is per-thread code. This enables each thread to make unique, dynamic decisions regarding what kernel or operation to execute next. There are no synchronization requirements between threads within a block to execute any of the provided device runtime APIs, which enables the device runtime API functions to be called in arbitrarily divergent kernel code without deadlock.\n13.3.1.1.\nDevice-Side Kernel Launch\nï\nKernels may be launched from the device using the standard CUDA <<< >>> syntax:\nkernel_name\n<<<\nDg\n,\nDb\n,\nNs\n,\nS\n>>>\n([\nkernel\narguments\n]);\nDg\nis of type\ndim3\nand specifies the dimensions and size of the grid\nDb\nis of type\ndim3\nand specifies the dimensions and size of each thread block\nNs\nis of type\nsize_t\nand specifies the number of bytes of shared memory that is dynamically allocated per thread block for this call in addition to statically allocated memory.\nNs\nis an optional argument that defaults to 0.\nS\nis of type\ncudaStream_t\nand specifies the stream associated with this call. The stream must have been allocated in the same grid where the call is being made.\nS\nis an optional argument that defaults to the NULL stream.\n13.3.1.1.1.\nLaunches are Asynchronous\nï\nIdentical to host-side launches, all device-side kernel launches are asynchronous with respect to the launching thread. That is to say, the\n<<<>>>\nlaunch command will return immediately and the launching thread will continue to execute until it hits an implicit launch-synchronization point (such as at a kernel launched into the\ncudaStreamTailLaunch\nstream).\nThe child grid launch is posted to the device and will execute independently of the parent thread. The child grid may begin execution at any time after launch, but is not guaranteed to begin execution until the launching thread reaches an implicit launch-synchronization point.\n13.3.1.1.2.\nLaunch Environment Configuration\nï\nAll global device configuration settings (for example, shared memory and L1 cache size as returned from\ncudaDeviceGetCacheConfig()\n, and device limits returned from\ncudaDeviceGetLimit()\n) will be inherited from the parent. Likewise, device limits such as stack size will remain as-configured.\nFor host-launched kernels, per-kernel configurations set from the host will take precedence over the global setting. These configurations will be used when the kernel is launched from the device as well. It is not possible to reconfigure a kernelâs environment from the device.\n13.3.1.2.\nStreams\nï\nBoth named and unnamed (NULL) streams are available from the device runtime. Named streams may be used by any thread within a grid, but stream handles may not be passed to other child/parent kernels. In other words, a stream should be treated as private to the grid in which it is created.\nSimilar to host-side launch, work launched into separate streams may run concurrently, but actual concurrency is not guaranteed. Programs that depend upon concurrency between child kernels are not supported by the CUDA programming model and will have undefined behavior.\nThe host-side NULL streamâs cross-stream barrier semantic is not supported on the device (see below for details). In order to retain semantic compatibility with the host runtime, all device streams must be created using the\ncudaStreamCreateWithFlags()\nAPI, passing the\ncudaStreamNonBlocking\nflag. The\ncudaStreamCreate()\ncall is a host-runtime- only API and will fail to compile for the device.\nAs\ncudaStreamSynchronize()\nand\ncudaStreamQuery()\nare unsupported by the device runtime, a kernel launched into the\ncudaStreamTailLaunch\nstream should be used instead when the application needs to know that stream-launched child kernels have completed.\n13.3.1.2.1.\nThe Implicit (NULL) Stream\nï\nWithin a host program, the unnamed (NULL) stream has additional barrier synchronization semantics with other streams (see\nDefault Stream\nfor details). The device runtime offers a single implicit, unnamed stream shared between all threads in a thread block, but as all named streams must be created with the\ncudaStreamNonBlocking\nflag, work launched into the NULL stream will not insert an implicit dependency on pending work in any other streams (including NULL streams of other thread blocks).\n13.3.1.2.2.\nThe Fire-and-Forget Stream\nï\nThe fire-and-forget named stream (\ncudaStreamFireAndForget\n) allows the user to launch fire-and-forget work with less boilerplate and without stream tracking overhead. It is functionally identical to, but faster than, creating a new stream per launch, and launching into that stream.\nFire-and-forget launches are immediately scheduled for launch without any dependency on the completion of previously launched grids. No other grid launches can depend on the completion of a fire-and-forget launch, except through the implicit synchronization at the end of the parent grid. So a tail launch or the next grid in parent gridâs stream wonât launch before a parent gridâs fire-and-forget work has completed.\n// In this example, C2's launch will not wait for C1's completion\n__global__\nvoid\nP\n(\n...\n)\n{\nC1\n<<<\n...\n,\ncudaStreamFireAndForget\n>>>\n(\n...\n);\nC2\n<<<\n...\n,\ncudaStreamFireAndForget\n>>>\n(\n...\n);\n}\nThe fire-and-forget stream cannot be used to record or wait on events. Attempting to do so results in\ncudaErrorInvalidValue\n. The fire-and-forget stream is not supported when compiled with\nCUDA_FORCE_CDP1_IF_SUPPORTED\ndefined. Fire-and-forget stream usage requires compilation to be in 64-bit mode.\n13.3.1.2.3.\nThe Tail Launch Stream\nï\nThe tail launch named stream (\ncudaStreamTailLaunch\n) allows a grid to schedule a new grid for launch after its completion. It should be possible to to use a tail launch to achieve the same functionality as a\ncudaDeviceSynchronize()\nin most cases.\nEach grid has its own tail launch stream. All non-tail launch work launched by a grid is implicitly synchronized before the tail stream is kicked off. I.e. A parent gridâs tail launch does not launch until the parent grid and all work launched by the parent grid to ordinary streams or per-thread or fire-and-forget streams have completed. If two grids are launched to the same gridâs tail launch stream, the later grid does not launch until the earlier grid and all its descendent work has completed.\n// In this example, C2 will only launch after C1 completes.\n__global__\nvoid\nP\n(\n...\n)\n{\nC1\n<<<\n...\n,\ncudaStreamTailLaunch\n>>>\n(\n...\n);\nC2\n<<<\n...\n,\ncudaStreamTailLaunch\n>>>\n(\n...\n);\n}\nGrids launched into the tail launch stream will not launch until the completion of all work by the parent grid, including all other grids (and their descendants) launched by the parent in all non-tail launched streams, including work executed or launched after the tail launch.\n// In this example, C will only launch after all X, F and P complete.\n__global__\nvoid\nP\n(\n...\n)\n{\nC\n<<<\n...\n,\ncudaStreamTailLaunch\n>>>\n(\n...\n);\nX\n<<<\n...\n,\ncudaStreamPerThread\n>>>\n(\n...\n);\nF\n<<<\n...\n,\ncudaStreamFireAndForget\n>>>\n(\n...\n)\n}\nThe next grid in the parent gridâs stream will not be launched before a parent gridâs tail launch work has completed. In other words, the tail launch stream behaves as if it were inserted between its parent grid and the next grid in its parent gridâs stream.\n// In this example, P2 will only launch after C completes.\n__global__\nvoid\nP1\n(\n...\n)\n{\nC\n<<<\n...\n,\ncudaStreamTailLaunch\n>>>\n(\n...\n);\n}\n__global__\nvoid\nP2\n(\n...\n)\n{\n}\nint\nmain\n(\n...\n)\n{\n...\nP1\n<<<\n...\n>>>\n(\n...\n);\nP2\n<<<\n...\n>>>\n(\n...\n);\n...\n}\nEach grid only gets one tail launch stream. To tail launch concurrent grids, it can be done like the example below.\n// In this example,  C1 and C2 will launch concurrently after P's completion\n__global__\nvoid\nT\n(\n...\n)\n{\nC1\n<<<\n...\n,\ncudaStreamFireAndForget\n>>>\n(\n...\n);\nC2\n<<<\n...\n,\ncudaStreamFireAndForget\n>>>\n(\n...\n);\n}\n__global__\nvoid\nP\n(\n...\n)\n{\n...\nT\n<<<\n...\n,\ncudaStreamTailLaunch\n>>>\n(\n...\n);\n}\nThe tail launch stream cannot be used to record or wait on events. Attempting to do so results in\ncudaErrorInvalidValue\n. The tail launch stream is not supported when compiled with\nCUDA_FORCE_CDP1_IF_SUPPORTED\ndefined. Tail launch stream usage requires compilation to be in 64-bit mode.\n13.3.1.3.\nEvents\nï\nOnly the inter-stream synchronization capabilities of CUDA events are supported. This means that\ncudaStreamWaitEvent()\nis supported, but\ncudaEventSynchronize()\n,\ncudaEventElapsedTime()\n, and\ncudaEventQuery()\nare not. As\ncudaEventElapsedTime()\nis not supported, cudaEvents must be created via\ncudaEventCreateWithFlags()\n, passing the\ncudaEventDisableTiming\nflag.\nAs with named streams, event objects may be shared between all threads within the grid which created them but are local to that grid and may not be passed to other kernels. Event handles are not guaranteed to be unique between grids, so using an event handle within a grid that did not create it will result in undefined behavior.\n13.3.1.4.\nSynchronization\nï\nIt is up to the program to perform sufficient inter-thread synchronization, for example via a CUDA Event, if the calling thread is intended to synchronize with child grids invoked from other threads.\nAs it is not possible to explicitly synchronize child work from a parent thread, there is no way to guarantee that changes occurring in child grids are visible to threads within the parent grid.\n13.3.1.5.\nDevice Management\nï\nOnly the device on which a kernel is running will be controllable from that kernel. This means that device APIs such as\ncudaSetDevice()\nare not supported by the device runtime. The active device as seen from the GPU (returned from\ncudaGetDevice()\n) will have the same device number as seen from the host system. The\ncudaDeviceGetAttribute()\ncall may request information about another device as this API allows specification of a device ID as a parameter of the call. Note that the catch-all\ncudaGetDeviceProperties()\nAPI is not offered by the device runtime - properties must be queried individually.\n13.3.1.6.\nMemory Declarations\nï\n13.3.1.6.1.\nDevice and Constant Memory\nï\nMemory declared at file scope with\n__device__\nor\n__constant__\nmemory space specifiers behaves identically when using the device runtime. All kernels may read or write device variables, whether the kernel was initially launched by the host or device runtime. Equivalently, all kernels will have the same view of\n__constant__\ns as declared at the module scope.\n13.3.1.6.2.\nTextures and Surfaces\nï\nCUDA supports dynamically created texture and surface objects\n7\n, where a texture object may be created on the host, passed to a kernel, used by that kernel, and then destroyed from the host. The device runtime does not allow creation or destruction of texture or surface objects from within device code, but texture and surface objects created from the host may be used and passed around freely on the device. Regardless of where they are created, dynamically created texture objects are always valid and may be passed to child kernels from a parent.\nNote\nThe device runtime does not support legacy module-scope (i.e., Fermi-style) textures and surfaces within a kernel launched from the device. Module-scope (legacy) textures may be created from the host and used in device code as for any kernel, but may only be used by a top-level kernel (i.e., the one which is launched from the host).\n13.3.1.6.3.\nShared Memory Variable Declarations\nï\nIn CUDA C++ shared memory can be declared either as a statically sized file-scope or function-scoped variable, or as an\nextern\nvariable with the size determined at runtime by the kernelâs caller via a launch configuration argument. Both types of declarations are valid under the device runtime.\n__global__\nvoid\npermute\n(\nint\nn\n,\nint\n*\ndata\n)\n{\nextern\n__shared__\nint\nsmem\n[];\nif\n(\nn\n<=\n1\n)\nreturn\n;\nsmem\n[\nthreadIdx\n.\nx\n]\n=\ndata\n[\nthreadIdx\n.\nx\n];\n__syncthreads\n();\npermute_data\n(\nsmem\n,\nn\n);\n__syncthreads\n();\n// Write back to GMEM since we can't pass SMEM to children.\ndata\n[\nthreadIdx\n.\nx\n]\n=\nsmem\n[\nthreadIdx\n.\nx\n];\n__syncthreads\n();\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\npermute\n<<<\n1\n,\n256\n,\nn\n/\n2\n*\nsizeof\n(\nint\n)\n>>>\n(\nn\n/\n2\n,\ndata\n);\npermute\n<<<\n1\n,\n256\n,\nn\n/\n2\n*\nsizeof\n(\nint\n)\n>>>\n(\nn\n/\n2\n,\ndata\n+\nn\n/\n2\n);\n}\n}\nvoid\nhost_launch\n(\nint\n*\ndata\n)\n{\npermute\n<<<\n1\n,\n256\n,\n256\n*\nsizeof\n(\nint\n)\n>>>\n(\n256\n,\ndata\n);\n}\n13.3.1.6.4.\nSymbol Addresses\nï\nDevice-side symbols (i.e., those marked\n__device__\n) may be referenced from within a kernel simply via the\n&\noperator, as all global-scope device variables are in the kernelâs visible address space. This also applies to\n__constant__\nsymbols, although in this case the pointer will reference read-only data.\nGiven that device-side symbols can be referenced directly, those CUDA runtime APIs which reference symbols (e.g.,\ncudaMemcpyToSymbol()\nor\ncudaGetSymbolAddress()\n) are redundant and hence not supported by the device runtime. Note this implies that constant data cannot be altered from within a running kernel, even ahead of a child kernel launch, as references to\n__constant__\nspace are read-only.\n13.3.1.7.\nAPI Errors and Launch Failures\nï\nAs usual for the CUDA runtime, any function may return an error code. The last error code returned is recorded and may be retrieved via the\ncudaGetLastError()\ncall. Errors are recorded per-thread, so that each thread can identify the most recent error that it has generated. The error code is of type\ncudaError_t\n.\nSimilar to a host-side launch, device-side launches may fail for many reasons (invalid arguments, etc). The user must call\ncudaGetLastError()\nto determine if a launch generated an error, however lack of an error after launch does not imply the child kernel completed successfully.\nFor device-side exceptions, e.g., access to an invalid address, an error in a child grid will be returned to the host.\n13.3.1.7.1.\nLaunch Setup APIs\nï\nKernel launch is a system-level mechanism exposed through the device runtime library, and as such is available directly from PTX via the underlying\ncudaGetParameterBuffer()\nand\ncudaLaunchDevice()\nAPIs. It is permitted for a CUDA application to call these APIs itself, with the same requirements as for PTX. In both cases, the user is then responsible for correctly populating all necessary data structures in the correct format according to specification. Backwards compatibility is guaranteed in these data structures.\nAs with host-side launch, the device-side operator\n<<<>>>\nmaps to underlying kernel launch APIs. This is so that users targeting PTX will be able to enact a launch, and so that the compiler front-end can translate\n<<<>>>\ninto these calls.\nTable 13\nNew Device-only Launch Implementation Functions\nï\nRuntime API Launch Functions\nDescription of Difference From Host Runtime Behaviour (behavior is identical if no description)\ncudaGetParameterBuffer\nGenerated automatically from\n<<<>>>\n. Note different API to host equivalent.\ncudaLaunchDevice\nGenerated automatically from\n<<<>>>\n. Note different API to host equivalent.\nThe APIs for these launch functions are different to those of the CUDA Runtime API, and are defined as follows:\nextern\ndevice\ncudaError_t\ncudaGetParameterBuffer\n(\nvoid\n**\nparams\n);\nextern\n__device__\ncudaError_t\ncudaLaunchDevice\n(\nvoid\n*\nkernel\n,\nvoid\n*\nparams\n,\ndim3\ngridDim\n,\ndim3\nblockDim\n,\nunsigned\nint\nsharedMemSize\n=\n0\n,\ncudaStream_t\nstream\n=\n0\n);\n13.3.1.8.\nAPI Reference\nï\nThe portions of the CUDA Runtime API supported in the device runtime are detailed here. Host and device runtime APIs have identical syntax; semantics are the same except where indicated. The following table provides an overview of the API relative to the version available from the host.\nTable 14\nSupported API Functions\nï\nRuntime API Functions\nDetails\ncudaDeviceGetCacheConfig\ncudaDeviceGetLimit\ncudaGetLastError\nLast error is per-thread state, not per-block state\ncudaPeekAtLastError\ncudaGetErrorString\ncudaGetDeviceCount\ncudaDeviceGetAttribute\nWill return attributes for any device\ncudaGetDevice\nAlways returns current device ID as would be seen from host\ncudaStreamCreateWithFlags\nMust pass\ncudaStreamNonBlocking\nflag\ncudaStreamDestroy\ncudaStreamWaitEvent\ncudaEventCreateWithFlags\nMust pass\ncudaEventDisableTiming\nflag\ncudaEventRecord\ncudaEventDestroy\ncudaFuncGetAttributes\ncudaMemcpyAsync\nNotes about all\nmemcpy/memset\nfunctions:\nOnly async\nmemcpy/set\nfunctions are supported\nOnly device-to-device\nmemcpy\nis permitted\nMay not pass in local or shared memory pointers\ncudaMemcpy2DAsync\ncudaMemcpy3DAsync\ncudaMemsetAsync\ncudaMemset2DAsync\ncudaMemset3DAsync\ncudaRuntimeGetVersion\ncudaMalloc\nMay not call\ncudaFree\non the device on a pointer created on the host, and vice-versa\ncudaFree\ncudaOccupancyMaxActiveBlocksPerMultiprocessor\ncudaOccupancyMaxPotentialBlockSize\ncudaOccupancyMaxPotentialBlockSizeVariableSMem\n13.3.2.\nDevice-side Launch from PTX\nï\nThis section is for the programming language and compiler implementers who target\nParallel Thread Execution\n(PTX) and plan to support\nDynamic Parallelism\nin their language. It provides the low-level details related to supporting kernel launches at the PTX level.\n13.3.2.1.\nKernel Launch APIs\nï\nDevice-side kernel launches can be implemented using the following two APIs accessible from PTX:\ncudaLaunchDevice()\nand\ncudaGetParameterBuffer()\n.\ncudaLaunchDevice()\nlaunches the specified kernel with the parameter buffer that is obtained by calling\ncudaGetParameterBuffer()\nand filled with the parameters to the launched kernel. The parameter buffer can be NULL, i.e., no need to invoke\ncudaGetParameterBuffer()\n, if the launched kernel does not take any parameters.\n13.3.2.1.1.\ncudaLaunchDevice\nï\nAt the PTX level,\ncudaLaunchDevice()\nneeds to be declared in one of the two forms shown below before it is used.\n// PTX-level Declaration of cudaLaunchDevice() when .address_size is 64\n.\nextern\n.\nfunc\n(.\nparam\n.\nb32\nfunc_retval0\n)\ncudaLaunchDevice\n(\n.\nparam\n.\nb64\nfunc\n,\n.\nparam\n.\nb64\nparameterBuffer\n,\n.\nparam\n.\nalign\n4\n.\nb8\ngridDimension\n[\n12\n],\n.\nparam\n.\nalign\n4\n.\nb8\nblockDimension\n[\n12\n],\n.\nparam\n.\nb32\nsharedMemSize\n,\n.\nparam\n.\nb64\nstream\n)\n;\nThe CUDA-level declaration below is mapped to one of the aforementioned PTX-level declarations and is found in the system header file\ncuda_device_runtime_api.h\n. The function is defined in the\ncudadevrt\nsystem library, which must be linked with a program in order to use device-side kernel launch functionality.\n// CUDA-level declaration of cudaLaunchDevice()\nextern\n\"C\"\n__device__\ncudaError_t\ncudaLaunchDevice\n(\nvoid\n*\nfunc\n,\nvoid\n*\nparameterBuffer\n,\ndim3\ngridDimension\n,\ndim3\nblockDimension\n,\nunsigned\nint\nsharedMemSize\n,\ncudaStream_t\nstream\n);\nThe first parameter is a pointer to the kernel to be is launched, and the second parameter is the parameter buffer that holds the actual parameters to the launched kernel. The layout of the parameter buffer is explained in\nParameter Buffer Layout\n, below. Other parameters specify the launch configuration, i.e., as grid dimension, block dimension, shared memory size, and the stream associated with the launch (please refer to\nExecution Configuration\nfor the detailed description of launch configuration.\n13.3.2.1.2.\ncudaGetParameterBuffer\nï\ncudaGetParameterBuffer()\nneeds to be declared at the PTX level before itâs used. The PTX-level declaration must be in one of the two forms given below, depending on address size:\n// PTX-level Declaration of cudaGetParameterBuffer() when .address_size is 64\n.\nextern\n.\nfunc\n(.\nparam\n.\nb64\nfunc_retval0\n)\ncudaGetParameterBuffer\n(\n.\nparam\n.\nb64\nalignment\n,\n.\nparam\n.\nb64\nsize\n)\n;\nThe following CUDA-level declaration of\ncudaGetParameterBuffer()\nis mapped to the aforementioned PTX-level declaration:\n// CUDA-level Declaration of cudaGetParameterBuffer()\nextern\n\"C\"\n__device__\nvoid\n*\ncudaGetParameterBuffer\n(\nsize_t\nalignment\n,\nsize_t\nsize\n);\nThe first parameter specifies the alignment requirement of the parameter buffer and the second parameter the size requirement in bytes. In the current implementation, the parameter buffer returned by\ncudaGetParameterBuffer()\nis always guaranteed to be 64- byte aligned, and the alignment requirement parameter is ignored. However, it is recommended to pass the correct alignment requirement value - which is the largest alignment of any parameter to be placed in the parameter buffer - to\ncudaGetParameterBuffer()\nto ensure portability in the future.\n13.3.2.2.\nParameter Buffer Layout\nï\nParameter reordering in the parameter buffer is prohibited, and each individual parameter placed in the parameter buffer is required to be aligned. That is, each parameter must be placed at the\nn\nth\nbyte in the parameter buffer, where\nn\nis the smallest multiple of the parameter size that is greater than the offset of the last byte taken by the preceding parameter. The maximum size of the parameter buffer is 4KB.\nFor a more detailed description of PTX code generated by the CUDA compiler, please refer to the PTX-3.5 specification.\n13.3.3.\nToolkit Support for Dynamic Parallelism\nï\n13.3.3.1.\nIncluding Device Runtime API in CUDA Code\nï\nSimilar to the host-side runtime API, prototypes for the CUDA device runtime API are included automatically during program compilation. There is no need to include\ncuda_device_runtime_api.h\nexplicitly.\n13.3.3.2.\nCompiling and Linking\nï\nWhen compiling and linking CUDA programs using dynamic parallelism with\nnvcc\n, the program will automatically link against the static device runtime library\nlibcudadevrt\n.\nThe device runtime is offered as a static library (\ncudadevrt.lib\non Windows,\nlibcudadevrt.a\nunder Linux), against which a GPU application that uses the device runtime must be linked. Linking of device libraries can be accomplished through\nnvcc\nand/or\nnvlink\n. Two simple examples are shown below.\nA device runtime program may be compiled and linked in a single step, if all required source files can be specified from the command line:\n$ nvcc -arch=sm_75 -rdc=true hello_world.cu -o hello -lcudadevrt\nIt is also possible to compile CUDA .cu source files first to object files, and then link these together in a two-stage process:\n$ nvcc -arch=sm_75 -dc hello_world.cu -o hello_world.o\n$ nvcc -arch=sm_75 -rdc=true hello_world.o -o hello -lcudadevrt\nPlease see the Using Separate Compilation section of The CUDA Driver Compiler NVCC guide for more details.\n13.4.\nProgramming Guidelines\nï\n13.4.1.\nBasics\nï\nThe device runtime is a functional subset of the host runtime. API level device management, kernel launching, device memcpy, stream management, and event management are exposed from the device runtime.\nProgramming for the device runtime should be familiar to someone who already has experience with CUDA. Device runtime syntax and semantics are largely the same as that of the host API, with any exceptions detailed earlier in this document.\nThe following example shows a simple\nHello World\nprogram incorporating dynamic parallelism:\n#include\n<stdio.h>\n__global__\nvoid\nchildKernel\n()\n{\nprintf\n(\n\"Hello \"\n);\n}\n__global__\nvoid\ntailKernel\n()\n{\nprintf\n(\n\"World!\n\\n\n\"\n);\n}\n__global__\nvoid\nparentKernel\n()\n{\n// launch child\nchildKernel\n<<<\n1\n,\n1\n>>>\n();\nif\n(\ncudaSuccess\n!=\ncudaGetLastError\n())\n{\nreturn\n;\n}\n// launch tail into cudaStreamTailLaunch stream\n// implicitly synchronizes: waits for child to complete\ntailKernel\n<<<\n1\n,\n1\n,\n0\n,\ncudaStreamTailLaunch\n>>>\n();\n}\nint\nmain\n(\nint\nargc\n,\nchar\n*\nargv\n[])\n{\n// launch parent\nparentKernel\n<<<\n1\n,\n1\n>>>\n();\nif\n(\ncudaSuccess\n!=\ncudaGetLastError\n())\n{\nreturn\n1\n;\n}\n// wait for parent to complete\nif\n(\ncudaSuccess\n!=\ncudaDeviceSynchronize\n())\n{\nreturn\n2\n;\n}\nreturn\n0\n;\n}\nThis program may be built in a single step from the command line as follows:\n$ nvcc -arch=sm_75 -rdc=true hello_world.cu -o hello -lcudadevrt\n13.4.2.\nPerformance\nï\n13.4.2.1.\nDynamic-parallelism-enabled Kernel Overhead\nï\nSystem software which is active when controlling dynamic launches may impose an overhead on any kernel which is running at the time, whether or not it invokes kernel launches of its own. This overhead arises from the device runtimeâs execution tracking and management software and may result in decreased performance. This overhead is, in general, incurred for applications that link against the device runtime library.\n13.4.3.\nImplementation Restrictions and Limitations\nï\nDynamic Parallelism\nguarantees all semantics described in this document, however, certain hardware and software resources are implementation-dependent and limit the scale, performance and other properties of a program which uses the device runtime.\n13.4.3.1.\nRuntime\nï\n13.4.3.1.1.\nMemory Footprint\nï\nThe device runtime system software reserves memory for various management purposes, in particular a reservation for tracking pending grid launches. Configuration controls are available to reduce the size of this reservation in exchange for certain launch limitations. See\nConfiguration Options\n, below, for details.\n13.4.3.1.2.\nPending Kernel Launches\nï\nWhen a kernel is launched, all associated configuration and parameter data is tracked until the kernel completes. This data is stored within a system-managed launch pool.\nThe size of the fixed-size launch pool is configurable by calling\ncudaDeviceSetLimit()\nfrom the host and specifying\ncudaLimitDevRuntimePendingLaunchCount\n.\n13.4.3.1.3.\nConfiguration Options\nï\nResource allocation for the device runtime system software is controlled via the\ncudaDeviceSetLimit()\nAPI from the host program. Limits must be set before any kernel is launched, and may not be changed while the GPU is actively running programs.\nThe following named limits may be set:\nLimit\nBehavior\ncudaLimitDevRuntimePendingLaunchCount\nControls the amount of memory set aside for buffering kernel launches and events which have not yet begun to execute, due either to unresolved dependencies or lack of execution resources. When the buffer is full, an attempt to allocate a launch slot during a device side kernel launch will fail and return\ncudaErrorLaunchOutOfResources\n, while an attempt to allocate an event slot will fail and return\ncudaErrorMemoryAllocation\n. The default number of launch slots is 2048. Applications may increase the number of launch and/or event slots by setting\ncudaLimitDevRuntimePendingLaunchCount\n. The number of event slots allocated is twice the value of that limit.\ncudaLimitStackSize\nControls the stack size in bytes of each GPU thread. The CUDA driver automatically increases the per-thread stack size for each kernel launch as needed. This size isnât reset back to the original value after each launch. To set the per-thread stack size to a different value,\ncudaDeviceSetLimit()\ncan be called to set this limit. The stack will be immediately resized, and if necessary, the device will block until all preceding requested tasks are complete.\ncudaDeviceGetLimit()\ncan be called to get the current per-thread stack size.\n13.4.3.1.4.\nMemory Allocation and Lifetime\nï\ncudaMalloc()\nand\ncudaFree()\nhave distinct semantics between the host and device environments. When invoked from the host,\ncudaMalloc()\nallocates a new region from unused device memory. When invoked from the device runtime these functions map to device-side\nmalloc()\nand\nfree()\n. This implies that within the device environment the total allocatable memory is limited to the device\nmalloc()\nheap size, which may be smaller than the available unused device memory. Also, it is an error to invoke\ncudaFree()\nfrom the host program on a pointer which was allocated by\ncudaMalloc()\non the device or vice-versa.\ncudaMalloc()\non Host\ncudaMalloc()\non Device\ncudaFree()\non Host\nSupported\nNot Supported\ncudaFree()\non Device\nNot Supported\nSupported\nAllocation limit\nFree device memory\ncudaLimitMallocHeapSize\n13.4.3.1.5.\nSM Id and Warp Id\nï\nNote that in PTX\n%smid\nand\n%warpid\nare defined as volatile values. The device runtime may reschedule thread blocks onto different SMs in order to more efficiently manage resources. As such, it is unsafe to rely upon\n%smid\nor\n%warpid\nremaining unchanged across the lifetime of a thread or thread block.\n13.4.3.1.6.\nECC Errors\nï\nNo notification of ECC errors is available to code within a CUDA kernel. ECC errors are reported at the host side once the entire launch tree has completed. Any ECC errors which arise during execution of a nested program will either generate an exception or continue execution (depending upon error and configuration).\n13.5.\nCDP2 vs CDP1\nï\nThis section summarises the differences between, and the compatibility and interoperability of, the new (CDP2) and legacy (CDP1) CUDA Dynamic Parallelism interfaces. It also shows how to opt-out of the CDP2 interface on devices of compute capability less than 9.0.\n13.5.1.\nDifferences Between CDP1 and CDP2\nï\nExplicit device-side synchronization is no longer possible with CDP2 or on devices of compute capability 9.0 or higher. Implicit synchronization (such as tail launches) must be used instead.\nAttempting to query or set\ncudaLimitDevRuntimeSyncDepth\n(or\nCU_LIMIT_DEV_RUNTIME_SYNC_DEPTH\n) with CDP2 or on devices of compute capability 9.0 or higher results in\ncudaErrorUnsupportedLimit\n.\nCDP2 no longer has a virtualized pool for pending launches that donât fit in the fixed-sized pool.\ncudaLimitDevRuntimePendingLaunchCount\nmust be set to be large enough to avoid running out of launch slots.\nFor CDP2, there is a limit to the total number of events existing at once (note that events are destroyed only after a launch completes), equal to twice the pending launch count.\ncudaLimitDevRuntimePendingLaunchCount\nmust be set to be large enough to avoid running out of event slots.\nStreams are tracked per grid with CDP2 or on devices of compute capability 9.0 or higher, not per thread block. This allows work to be launched into a stream created by another thread block. Attempting to do so with the CDP1 results in\ncudaErrorInvalidValue\n.\nCDP2 introduces the tail launch (\ncudaStreamTailLaunch\n) and fire-and-forget (\ncudaStreamFireAndForget\n) named streams.\nCDP2 is supported only under 64-bit compilation mode.\n13.5.2.\nCompatibility and Interoperability\nï\nCDP2 is the default. Functions can be compiled with\n-DCUDA_FORCE_CDP1_IF_SUPPORTED\nto opt-out of using CDP2 on devices of compute capability less than 9.0.\nFunction compiler with CUDA 12.0 and newer (default)\nFunction compiled with pre-CUDA 12.0 or with CUDA 12.0 and newer with\n-DCUDA_FORCE_CDP1_IF_SUPPORTED\nspecified\nCompilation\nCompile error if device code references\ncudaDeviceSynchronize\n.\nCompile error if code references\ncudaStreamTailLaunch\nor\ncudaStreamFireAndForget\n. Compile error if device code references\ncudaDeviceSynchronize\nand code is compiled for sm_90 or newer.\nCompute capability < 9.0\nNew interface is used.\nLegacy interface is used.\nCompute capability 9.0 and higher\nNew interface is used.\nNew interface is used. If function references\ncudaDeviceSynchronize\nin device code, function load returns\ncudaErrorSymbolNotFound\n(this could happen if the code is compiled for devices of compute capability less than 9.0, but run on devices of compute capability 9.0 or higher using JIT).\nFunctions using CDP1 and CDP2 may be loaded and run simultaneously in the same context. The CDP1 functions are able to use CDP1-specific features (e.g.\ncudaDeviceSynchronize\n) and CDP2 functions are able to use CDP2-specific features (e.g. tail launch and fire-and-forget launch).\nA function using CDP1 cannot launch a function using CDP2, and vice versa. If a function that would use CDP1 contains in its call graph a function that would use CDP2, or vice versa,\ncudaErrorCdpVersionMismatch\nwould result during function load.\n13.6.\nLegacy CUDA Dynamic Parallelism (CDP1)\nï\nSee\nCUDA Dynamic Parallelism\n, above, for CDP2 version of document.\n13.6.1.\nExecution Environment and Memory Model (CDP1)\nï\nSee\nExecution Environment and Memory Model\n, above, for CDP2 version of document.\n13.6.1.1.\nExecution Environment (CDP1)\nï\nSee\nExecution Environment\n, above, for CDP2 version of document.\nThe CUDA execution model is based on primitives of threads, thread blocks, and grids, with kernel functions defining the program executed by individual threads within a thread block and grid. When a kernel function is invoked the gridâs properties are described by an execution configuration, which has a special syntax in CUDA. Support for dynamic parallelism in CUDA extends the ability to configure, launch, and synchronize upon new grids to threads that are running on the device.\nWarning\nExplicit synchronization with child kernels from a parent block (i.e. using\ncudaDeviceSynchronize()\nin device code) block is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.\n13.6.1.1.1.\nParent and Child Grids (CDP1)\nï\nSee\nParent and Child Grids\n, above, for CDP2 version of document.\nA device thread that configures and launches a new grid belongs to the parent grid, and the grid created by the invocation is a child grid.\nThe invocation and completion of child grids is properly nested, meaning that the parent grid is not considered complete until all child grids created by its threads have completed. Even if the invoking threads do not explicitly synchronize on the child grids launched, the runtime guarantees an implicit synchronization between the parent and child.\nWarning\nExplicit synchronization with child kernels from a parent block (i.e. using\ncudaDeviceSynchronize()\nin device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.\nFigure 31\nParent-Child Launch Nesting\nï\n13.6.1.1.2.\nScope of CUDA Primitives (CDP1)\nï\nSee\nScope of CUDA Primitives\n, above, for CDP2 version of document.\nOn both host and device, the CUDA runtime offers an API for launching kernels, for waiting for launched work to complete, and for tracking dependencies between launches via streams and events. On the host system, the state of launches and the CUDA primitives referencing streams and events are shared by all threads within a process; however processes execute independently and may not share CUDA objects.\nA similar hierarchy exists on the device: launched kernels and CUDA objects are visible to all threads in a thread block, but are independent between thread blocks. This means for example that a stream may be created by one thread and used by any other thread in the same thread block, but may not be shared with threads in any other thread block.\n13.6.1.1.3.\nSynchronization (CDP1)\nï\nSee\nSynchronization\n, above, for CDP2 version of document.\nWarning\nExplicit synchronization with child kernels from a parent block (i.e. using\ncudaDeviceSynchronize()\nin device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.\nCUDA runtime operations from any thread, including kernel launches, are visible across a thread block. This means that an invoking thread in the parent grid may perform synchronization on the grids launched by that thread, by other threads in the thread block, or on streams created within the same thread block. Execution of a thread block is not considered complete until all launches by all threads in the block have completed. If all threads in a block exit before all child launches have completed, a synchronization operation will automatically be triggered.\n13.6.1.1.4.\nStreams and Events (CDP1)\nï\nSee\nStreams and Events\n, above, for CDP2 version of document.\nCUDA\nStreams\nand\nEvents\nallow control over dependencies between grid launches: grids launched into the same stream execute in-order, and events may be used to create dependencies between streams. Streams and events created on the device serve this exact same purpose.\nStreams and events created within a grid exist within thread block scope but have undefined behavior when used outside of the thread block where they were created. As described above, all work launched by a thread block is implicitly synchronized when the block exits; work launched into streams is included in this, with all dependencies resolved appropriately. The behavior of operations on a stream that has been modified outside of thread block scope is undefined.\nStreams and events created on the host have undefined behavior when used within any kernel, just as streams and events created by a parent grid have undefined behavior if used within a child grid.\n13.6.1.1.5.\nOrdering and Concurrency (CDP1)\nï\nSee\nOrdering and Concurrency\n, above, for CDP2 version of document.\nThe ordering of kernel launches from the device runtime follows CUDA Stream ordering semantics. Within a thread block, all kernel launches into the same stream are executed in-order. With multiple threads in the same thread block launching into the same stream, the ordering within the stream is dependent on the thread scheduling within the block, which may be controlled with synchronization primitives such as\n__syncthreads()\n.\nNote that because streams are shared by all threads within a thread block, the implicit\nNULL\nstream is also shared. If multiple threads in a thread block launch into the implicit stream, then these launches will be executed in-order. If concurrency is desired, explicit named streams should be used.\nDynamic Parallelism\nenables concurrency to be expressed more easily within a program; however, the device runtime introduces no new concurrency guarantees within the CUDA execution model. There is no guarantee of concurrent execution between any number of different thread blocks on a device.\nThe lack of concurrency guarantee extends to parent thread blocks and their child grids. When a parent thread block launches a child grid, the child is not guaranteed to begin execution until the parent thread block reaches an explicit synchronization point (such as\ncudaDeviceSynchronize()\n).\nWarning\nExplicit synchronization with child kernels from a parent block (i.e. using\ncudaDeviceSynchronize()\nin device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.\nWhile concurrency will often easily be achieved, it may vary as a function of deviceconfiguration, application workload, and runtime scheduling. It is therefore unsafe to depend upon any concurrency between different thread blocks.\n13.6.1.1.6.\nDevice Management (CDP1)\nï\nSee\nDevice Management\n, above, for CDP2 version of document.\nThere is no multi-GPU support from the device runtime; the device runtime is only capable of operating on the device upon which it is currently executing. It is permitted, however, to query properties for any CUDA capable device in the system.\n13.6.1.2.\nMemory Model (CDP1)\nï\nSee\nMemory Model\n, above, for CDP2 version of document.\nParent and child grids share the same global and constant memory storage, but have distinct local and shared memory.\n13.6.1.2.1.\nCoherence and Consistency (CDP1)\nï\nSee\nCoherence and Consistency\n, above, for CDP2 version of document.\n13.6.1.2.1.1.\nGlobal Memory (CDP1)\nï\nSee\nGlobal Memory\n, above, for CDP2 version of document.\nParent and child grids have coherent access to global memory, with weak consistency guarantees between child and parent. There are two points in the execution of a child grid when its view of memory is fully consistent with the parent thread: when the child grid is invoked by the parent, and when the child grid completes as signaled by a synchronization API invocation in the parent thread.\nWarning\nExplicit synchronization with child kernels from a parent block (i.e. using\ncudaDeviceSynchronize()\nin device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.\nAll global memory operations in the parent thread prior to the child gridâs invocation are visible to the child grid. All memory operations of the child grid are visible to the parent after the parent has synchronized on the child gridâs completion.\nIn the following example, the child grid executing\nchild_launch\nis only guaranteed to see the modifications to\ndata\nmade before the child grid was launched. Since thread 0 of the parent is performing the launch, the child will be consistent with the memory seen by thread 0 of the parent. Due to the first\n__syncthreads()\ncall, the child will see\ndata[0]=0\n,\ndata[1]=1\n, â¦,\ndata[255]=255\n(without the\n__syncthreads()\ncall, only\ndata[0]\nwould be guaranteed to be seen by the child). When the child grid returns, thread 0 is guaranteed to see modifications made by the threads in its child grid. Those modifications become available to the other threads of the parent grid only after the second\n__syncthreads()\ncall:\n__global__\nvoid\nchild_launch\n(\nint\n*\ndata\n)\n{\ndata\n[\nthreadIdx\n.\nx\n]\n=\ndata\n[\nthreadIdx\n.\nx\n]\n+\n1\n;\n}\n__global__\nvoid\nparent_launch\n(\nint\n*\ndata\n)\n{\ndata\n[\nthreadIdx\n.\nx\n]\n=\nthreadIdx\n.\nx\n;\n__syncthreads\n();\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\nchild_launch\n<<<\n1\n,\n256\n>>>\n(\ndata\n);\ncudaDeviceSynchronize\n();\n}\n__syncthreads\n();\n}\nvoid\nhost_launch\n(\nint\n*\ndata\n)\n{\nparent_launch\n<<<\n1\n,\n256\n>>>\n(\ndata\n);\n}\n13.6.1.2.1.2.\nZero Copy Memory (CDP1)\nï\nSee\nZero Copy Memory\n, above, for CDP2 version of document.\nZero-copy system memory has identical coherence and consistency guarantees to global memory, and follows the semantics detailed above. A kernel may not allocate or free zero-copy memory, but may use pointers to zero-copy passed in from the host program.\n13.6.1.2.1.3.\nConstant Memory (CDP1)\nï\nSee\nConstant Memory\n, above, for CDP2 version of document.\nConstants are immutable and may not be modified from the device, even between parent and child launches. That is to say, the value of all\n__constant__\nvariables must be set from the host prior to launch. Constant memory is inherited automatically by all child kernels from their respective parents.\nTaking the address of a constant memory object from within a kernel thread has the same semantics as for all CUDA programs, and passing that pointer from parent to child or from a child to parent is naturally supported.\n13.6.1.2.1.4.\nShared and Local Memory (CDP1)\nï\nSee\nShared and Local Memory\n, above, for CDP2 version of document.\nShared and Local memory is private to a thread block or thread, respectively, and is not visible or coherent between parent and child. Behavior is undefined when an object in one of these locations is referenced outside of the scope within which it belongs, and may cause an error.\nThe NVIDIA compiler will attempt to warn if it can detect that a pointer to local or shared memory is being passed as an argument to a kernel launch. At runtime, the programmer may use the\n__isGlobal()\nintrinsic to determine whether a pointer references global memory and so may safely be passed to a child launch.\nNote that calls to\ncudaMemcpy*Async()\nor\ncudaMemset*Async()\nmay invoke new child kernels on the device in order to preserve stream semantics. As such, passing shared or local memory pointers to these APIs is illegal and will return an error.\n13.6.1.2.1.5.\nLocal Memory (CDP1)\nï\nSee\nLocal Memory\n, above, for CDP2 version of document.\nLocal memory is private storage for an executing thread, and is not visible outside of that thread. It is illegal to pass a pointer to local memory as a launch argument when launching a child kernel. The result of dereferencing such a local memory pointer from a child will be undefined.\nFor example the following is illegal, with undefined behavior if\nx_array\nis accessed by\nchild_launch\n:\nint\nx_array\n[\n10\n];\n// Creates x_array in parent's local memory\nchild_launch\n<<<\n1\n,\n1\n>>>\n(\nx_array\n);\nIt is sometimes difficult for a programmer to be aware of when a variable is placed into local memory by the compiler. As a general rule, all storage passed to a child kernel should be allocated explicitly from the global-memory heap, either with\ncudaMalloc()\n,\nnew()\nor by declaring\n__device__\nstorage at global scope. For example:\n// Correct - \"value\" is global storage\n__device__\nint\nvalue\n;\n__device__\nvoid\nx\n()\n{\nvalue\n=\n5\n;\nchild\n<<<\n1\n,\n1\n>>>\n(\n&\nvalue\n);\n}\n// Invalid - \"value\" is local storage\n__device__\nvoid\ny\n()\n{\nint\nvalue\n=\n5\n;\nchild\n<<<\n1\n,\n1\n>>>\n(\n&\nvalue\n);\n}\n13.6.1.2.1.6.\nTexture Memory (CDP1)\nï\nSee\nTexture Memory\n, above, for CDP2 version of document.\nWrites to the global memory region over which a texture is mapped are incoherent with respect to texture accesses. Coherence for texture memory is enforced at the invocation of a child grid and when a child grid completes. This means that writes to memory prior to a child kernel launch are reflected in texture memory accesses of the child. Similarly, writes to memory by a child will be reflected in the texture memory accesses by a parent, but only after the parent synchronizes on the childâs completion. Concurrent accesses by parent and child may result in inconsistent data.\nWarning\nExplicit synchronization with child kernels from a parent block (i.e. using\ncudaDeviceSynchronize()\nin device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.\n13.6.2.\nProgramming Interface (CDP1)\nï\nSee\nProgramming Interface\n, above, for CDP2 version of document.\n13.6.2.1.\nCUDA C++ Reference (CDP1)\nï\nSee\nCUDA C++ Reference\n, above, for CDP2 version of document.\nThis section describes changes and additions to the CUDA C++ language extensions for supporting\nDynamic Parallelism\n.\nThe language interface and API available to CUDA kernels using CUDA C++ for Dynamic Parallelism, referred to as the\nDevice Runtime\n, is substantially like that of the CUDA Runtime API available on the host. Where possible the syntax and semantics of the CUDA Runtime API have been retained in order to facilitate ease of code reuse for routines that may run in either the host or device environments.\nAs with all code in CUDA C++, the APIs and code outlined here is per-thread code. This enables each thread to make unique, dynamic decisions regarding what kernel or operation to execute next. There are no synchronization requirements between threads within a block to execute any of the provided device runtime APIs, which enables the device runtime API functions to be called in arbitrarily divergent kernel code without deadlock.\n13.6.2.1.1.\nDevice-Side Kernel Launch (CDP1)\nï\nSee\nKernel Launch APIs\n, above, for CDP2 version of document.\nKernels may be launched from the device using the standard CUDA <<< >>> syntax:\nkernel_name\n<<<\nDg\n,\nDb\n,\nNs\n,\nS\n>>>\n([\nkernel\narguments\n]);\nDg\nis of type\ndim3\nand specifies the dimensions and size of the grid\nDb\nis of type\ndim3\nand specifies the dimensions and size of each thread block\nNs\nis of type\nsize_t\nand specifies the number of bytes of shared memory that is dynamically allocated per thread block for this call and addition to statically allocated memory.\nNs\nis an optional argument that defaults to 0.\nS\nis of type\ncudaStream_t\nand specifies the stream associated with this call. The stream must have been allocated in the same thread block where the call is being made.\nS\nis an optional argument that defaults to 0.\n13.6.2.1.1.1.\nLaunches are Asynchronous (CDP1)\nï\nSee\nLaunches are Asynchronous\n, above, for CDP2 version of document.\nIdentical to host-side launches, all device-side kernel launches are asynchronous with respect to the launching thread. That is to say, the\n<<<>>>\nlaunch command will return immediately and the launching thread will continue to execute until it hits an explicit launch-synchronization point such as\ncudaDeviceSynchronize()\n.\nWarning\nExplicit synchronization with child kernels from a parent block (i.e. using\ncudaDeviceSynchronize()\nin device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.\nThe grid launch is posted to the device and will execute independently of the parent thread. The child grid may begin execution at any time after launch, but is not guaranteed to begin execution until the launching thread reaches an explicit launch-synchronization point.\n13.6.2.1.1.2.\nLaunch Environment Configuration (CDP1)\nï\nSee\nLaunch Environment Configuration\n, above, for CDP2 version of document.\nAll global device configuration settings (for example, shared memory and L1 cache size as returned from\ncudaDeviceGetCacheConfig()\n, and device limits returned from\ncudaDeviceGetLimit()\n) will be inherited from the parent. Likewise, device limits such as stack size will remain as-configured.\nFor host-launched kernels, per-kernel configurations set from the host will take precedence over the global setting. These configurations will be used when the kernel is launched from the device as well. It is not possible to reconfigure a kernelâs environment from the device.\n13.6.2.1.2.\nStreams (CDP1)\nï\nSee\nStreams\n, above, for CDP2 version of document.\nBoth named and unnamed (NULL) streams are available from the device runtime. Named streams may be used by any thread within a thread-block, but stream handles may not be passed to other blocks or child/parent kernels. In other words, a stream should be treated as private to the block in which it is created. Stream handles are not guaranteed to be unique between blocks, so using a stream handle within a block that did not allocate it will result in undefined behavior.\nSimilar to host-side launch, work launched into separate streams may run concurrently, but actual concurrency is not guaranteed. Programs that depend upon concurrency between child kernels are not supported by the CUDA programming model and will have undefined behavior.\nThe host-side NULL streamâs cross-stream barrier semantic is not supported on the device (see below for details). In order to retain semantic compatibility with the host runtime, all device streams must be created using the\ncudaStreamCreateWithFlags()\nAPI, passing the\ncudaStreamNonBlocking\nflag. The\ncudaStreamCreate()\ncall is a host-runtime- only API and will fail to compile for the device.\nAs\ncudaStreamSynchronize()\nand\ncudaStreamQuery()\nare unsupported by the device runtime,\ncudaDeviceSynchronize()\nshould be used instead when the application needs to know that stream-launched child kernels have completed.\nWarning\nExplicit synchronization with child kernels from a parent block (i.e. using\ncudaDeviceSynchronize()\nin device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.\n13.6.2.1.2.1.\nThe Implicit (NULL) Stream (CDP1)\nï\nSee\nThe Implicit (NULL) Stream\n, above, for CDP2 version of document.\nWithin a host program, the unnamed (NULL) stream has additional barrier synchronization semantics with other streams (see\nDefault Stream\nfor details). The device runtime offers a single implicit, unnamed stream shared between all threads in a block, but as all named streams must be created with the\ncudaStreamNonBlocking\nflag, work launched into the NULL stream will not insert an implicit dependency on pending work in any other streams (including NULL streams of other thread blocks).\n13.6.2.1.3.\nEvents (CDP1)\nï\nSee\nEvents\n, above, for CDP2 version of document.\nOnly the inter-stream synchronization capabilities of CUDA events are supported. This means that\ncudaStreamWaitEvent()\nis supported, but\ncudaEventSynchronize()\n,\ncudaEventElapsedTime()\n, and\ncudaEventQuery()\nare not. As\ncudaEventElapsedTime()\nis not supported, cudaEvents must be created via\ncudaEventCreateWithFlags()\n, passing the\ncudaEventDisableTiming\nflag.\nAs for all device runtime objects, event objects may be shared between all threads within the thread-block which created them but are local to that block and may not be passed to other kernels, or between blocks within the same kernel. Event handles are not guaranteed to be unique between blocks, so using an event handle within a block that did not create it will result in undefined behavior.\n13.6.2.1.4.\nSynchronization (CDP1)\nï\nSee\nSynchronization\n, above, for CDP2 version of document.\nWarning\nExplicit synchronization with child kernels from a parent block (i.e. using\ncudaDeviceSynchronize()\nin device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.\nThe\ncudaDeviceSynchronize()\nfunction will synchronize on all work launched by any thread in the thread-block up to the point where\ncudaDeviceSynchronize()\nwas called. Note that\ncudaDeviceSynchronize()\nmay be called from within divergent code (see\nBlock Wide Synchronization (CDP1)\n).\nIt is up to the program to perform sufficient additional inter-thread synchronization, for example via a call to\n__syncthreads()\n, if the calling thread is intended to synchronize with child grids invoked from other threads.\n13.6.2.1.4.1.\nBlock Wide Synchronization (CDP1)\nï\nSee\nCUDA Dynamic Parallelism\n, above, for CDP2 version of document.\nThe\ncudaDeviceSynchronize()\nfunction does not imply intra-block synchronization. In particular, without explicit synchronization via a\n__syncthreads()\ndirective the calling thread can make no assumptions about what work has been launched by any thread other than itself. For example if multiple threads within a block are each launching work and synchronization is desired for all this work at once (perhaps because of event-based dependencies), it is up to the program to guarantee that this work is submitted by all threads before calling\ncudaDeviceSynchronize()\n.\nBecause the implementation is permitted to synchronize on launches from any thread in the block, it is quite possible that simultaneous calls to\ncudaDeviceSynchronize()\nby multiple threads will drain all work in the first call and then have no effect for the later calls.\n13.6.2.1.5.\nDevice Management (CDP1)\nï\nSee\nDevice Management\n, above, for CDP2 version of document.\nOnly the device on which a kernel is running will be controllable from that kernel. This means that device APIs such as\ncudaSetDevice()\nare not supported by the device runtime. The active device as seen from the GPU (returned from\ncudaGetDevice()\n) will have the same device number as seen from the host system. The\ncudaDeviceGetAttribute()\ncall may request information about another device as this API allows specification of a device ID as a parameter of the call. Note that the catch-all\ncudaGetDeviceProperties()\nAPI is not offered by the device runtime - properties must be queried individually.\n13.6.2.1.6.\nMemory Declarations (CDP1)\nï\nSee\nMemory Declarations\n, above, for CDP2 version of document.\n13.6.2.1.6.1.\nDevice and Constant Memory (CDP1)\nï\nSee\nDevice and Constant Memory\n, above, for CDP2 version of document.\nMemory declared at file scope with\n__device__\nor\n__constant__\nmemory space specifiers behaves identically when using the device runtime. All kernels may read or write device variables, whether the kernel was initially launched by the host or device runtime. Equivalently, all kernels will have the same view of\n__constant__\ns as declared at the module scope.\n13.6.2.1.6.2.\nTextures and Surfaces (CDP1)\nï\nSee\nTextures and Surfaces\n, above, for CDP2 version of document.\nCUDA supports dynamically created texture and surface objects\n7\n, where a texture object may be created on the host, passed to a kernel, used by that kernel, and then destroyed from the host. The device runtime does not allow creation or destruction of texture or surface objects from within device code, but texture and surface objects created from the host may be used and passed around freely on the device. Regardless of where they are created, dynamically created texture objects are always valid and may be passed to child kernels from a parent.\nNote\nThe device runtime does not support legacy module-scope (i.e., Fermi-style) textures and surfaces within a kernel launched from the device. Module-scope (legacy) textures may be created from the host and used in device code as for any kernel, but may only be used by a top-level kernel (i.e., the one which is launched from the host).\n13.6.2.1.6.3.\nShared Memory Variable Declarations (CDP1)\nï\nSee\nShared Memory Variable Declarations\n, above, for CDP2 version of document.\nIn CUDA C++ shared memory can be declared either as a statically sized file-scope or function-scoped variable, or as an\nextern\nvariable with the size determined at runtime by the kernelâs caller via a launch configuration argument. Both types of declarations are valid under the device runtime.\n__global__\nvoid\npermute\n(\nint\nn\n,\nint\n*\ndata\n)\n{\nextern\n__shared__\nint\nsmem\n[];\nif\n(\nn\n<=\n1\n)\nreturn\n;\nsmem\n[\nthreadIdx\n.\nx\n]\n=\ndata\n[\nthreadIdx\n.\nx\n];\n__syncthreads\n();\npermute_data\n(\nsmem\n,\nn\n);\n__syncthreads\n();\n// Write back to GMEM since we can't pass SMEM to children.\ndata\n[\nthreadIdx\n.\nx\n]\n=\nsmem\n[\nthreadIdx\n.\nx\n];\n__syncthreads\n();\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\npermute\n<<<\n1\n,\n256\n,\nn\n/\n2\n*\nsizeof\n(\nint\n)\n>>>\n(\nn\n/\n2\n,\ndata\n);\npermute\n<<<\n1\n,\n256\n,\nn\n/\n2\n*\nsizeof\n(\nint\n)\n>>>\n(\nn\n/\n2\n,\ndata\n+\nn\n/\n2\n);\n}\n}\nvoid\nhost_launch\n(\nint\n*\ndata\n)\n{\npermute\n<<<\n1\n,\n256\n,\n256\n*\nsizeof\n(\nint\n)\n>>>\n(\n256\n,\ndata\n);\n}\n13.6.2.1.6.4.\nSymbol Addresses (CDP1)\nï\nSee\nSymbol Addresses\n, above, for CDP2 version of document.\nDevice-side symbols (i.e., those marked\n__device__\n) may be referenced from within a kernel simply via the\n&\noperator, as all global-scope device variables are in the kernelâs visible address space. This also applies to\n__constant__\nsymbols, although in this case the pointer will reference read-only data.\nGiven that device-side symbols can be referenced directly, those CUDA runtime APIs which reference symbols (for example,\ncudaMemcpyToSymbol()\nor\ncudaGetSymbolAddress()\n) are redundant and hence not supported by the device runtime. Note this implies that constant data cannot be altered from within a running kernel, even ahead of a child kernel launch, as references to\n__constant__\nspace are read-only.\n13.6.2.1.7.\nAPI Errors and Launch Failures (CDP1)\nï\nSee\nAPI Errors and Launch Failures\n, above, for CDP2 version of document.\nAs usual for the CUDA runtime, any function may return an error code. The last error code returned is recorded and may be retrieved via the\ncudaGetLastError()\ncall. Errors are recorded per-thread, so that each thread can identify the most recent error that it has generated. The error code is of type\ncudaError_t\n.\nSimilar to a host-side launch, device-side launches may fail for many reasons (invalid arguments, and so on). The user must call\ncudaGetLastError()\nto determine if a launch generated an error, however lack of an error after launch does not imply the child kernel completed successfully.\nFor device-side exceptions, for example, access to an invalid address, an error in a child grid will be returned to the host instead of being returned by the parentâs call to\ncudaDeviceSynchronize()\n.\n13.6.2.1.7.1.\nLaunch Setup APIs (CDP1)\nï\nSee\nLaunch Setup APIs\n, above, for CDP2 version of document.\nKernel launch is a system-level mechanism exposed through the device runtime library, and as such is available directly from PTX via the underlying\ncudaGetParameterBuffer()\nand\ncudaLaunchDevice()\nAPIs. It is permitted for a CUDA application to call these APIs itself, with the same requirements as for PTX. In both cases, the user is then responsible for correctly populating all necessary data structures in the correct format according to specification. Backwards compatibility is guaranteed in these data structures.\nAs with host-side launch, the device-side operator\n<<<>>>\nmaps to underlying kernel launch APIs. This is so that users targeting PTX will be able to enact a launch, and so that the compiler front-end can translate\n<<<>>>\ninto these calls.\nTable 15\nNew Device-only Launch Implementation Functions\nï\nRuntime API Launch Functions\nDescription of Difference From Host Runtime Behaviour (behavior is identical if no description)\ncudaGetParameterBuffer\nGenerated automatically from\n<<<>>>\n. Note different API to host equivalent.\ncudaLaunchDevice\nGenerated automatically from\n<<<>>>\n. Note different API to host equivalent.\nThe APIs for these launch functions are different to those of the CUDA Runtime API, and are defined as follows:\nextern\ndevice\ncudaError_t\ncudaGetParameterBuffer\n(\nvoid\n**\nparams\n);\nextern\n__device__\ncudaError_t\ncudaLaunchDevice\n(\nvoid\n*\nkernel\n,\nvoid\n*\nparams\n,\ndim3\ngridDim\n,\ndim3\nblockDim\n,\nunsigned\nint\nsharedMemSize\n=\n0\n,\ncudaStream_t\nstream\n=\n0\n);\n13.6.2.1.8.\nAPI Reference (CDP1)\nï\nSee\nAPI Reference\n, above, for CDP2 version of document.\nThe portions of the CUDA Runtime API supported in the device runtime are detailed here. Host and device runtime APIs have identical syntax; semantics are the same except where indicated. The table below provides an overview of the API relative to the version available from the host.\nTable 16\nSupported API Functions\nï\nRuntime API Functions\nDetails\ncudaDeviceSynchronize\nSynchronizes on work launched from threadâs own block only.\nWarning: Note that calling this API from device code is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.\ncudaDeviceGetCacheConfig\ncudaDeviceGetLimit\ncudaGetLastError\nLast error is per-thread state, not per-block state\ncudaPeekAtLastError\ncudaGetErrorString\ncudaGetDeviceCount\ncudaDeviceGetAttribute\nWill return attributes for any device\ncudaGetDevice\nAlways returns current device ID as would be seen from host\ncudaStreamCreateWithFlags\nMust pass\ncudaStreamNonBlocking\nflag\ncudaStreamDestroy\ncudaStreamWaitEvent\ncudaEventCreateWithFlags\nMust pass\ncudaEventDisableTiming\nflag\ncudaEventRecord\ncudaEventDestroy\ncudaFuncGetAttributes\ncudaMemcpyAsync\nNotes about all\nmemcpy/memset\nfunctions:\nOnly async\nmemcpy/set\nfunctions are supported\nOnly device-to-device\nmemcpy\nis permitted\nMay not pass in local or shared memory pointers\ncudaMemcpy2DAsync\ncudaMemcpy3DAsync\ncudaMemsetAsync\ncudaMemset2DAsync\ncudaMemset3DAsync\ncudaRuntimeGetVersion\ncudaMalloc\nMay not call\ncudaFree\non the device on a pointer created on the host, and vice-versa\ncudaFree\ncudaOccupancyMaxActiveBlocksPerMultiprocessor\ncudaOccupancyMaxPotentialBlockSize\ncudaOccupancyMaxPotentialBlockSizeVariableSMem\n13.6.2.2.\nDevice-side Launch from PTX (CDP1)\nï\nSee\nDevice-side Launch from PTX\n, above, for CDP2 version of document.\nThis section is for the programming language and compiler implementers who target\nParallel Thread Execution\n(PTX) and plan to support\nDynamic Parallelism\nin their language. It provides the low-level details related to supporting kernel launches at the PTX level.\n13.6.2.2.1.\nKernel Launch APIs (CDP1)\nï\nSee\nKernel Launch APIs\n, above, for CDP2 version of document.\nDevice-side kernel launches can be implemented using the following two APIs accessible from PTX:\ncudaLaunchDevice()\nand\ncudaGetParameterBuffer()\n.\ncudaLaunchDevice()\nlaunches the specified kernel with the parameter buffer that is obtained by calling\ncudaGetParameterBuffer()\nand filled with the parameters to the launched kernel. The parameter buffer can be NULL, i.e., no need to invoke\ncudaGetParameterBuffer()\n, if the launched kernel does not take any parameters.\n13.6.2.2.1.1.\ncudaLaunchDevice (CDP1)\nï\nSee\ncudaLaunchDevice\n, above, for CDP2 version of document.\nAt the PTX level,\ncudaLaunchDevice()\nneeds to be declared in one of the two forms shown below before it is used.\n// PTX-level Declaration of cudaLaunchDevice() when .address_size is 64\n.\nextern\n.\nfunc\n(.\nparam\n.\nb32\nfunc_retval0\n)\ncudaLaunchDevice\n(\n.\nparam\n.\nb64\nfunc\n,\n.\nparam\n.\nb64\nparameterBuffer\n,\n.\nparam\n.\nalign\n4\n.\nb8\ngridDimension\n[\n12\n],\n.\nparam\n.\nalign\n4\n.\nb8\nblockDimension\n[\n12\n],\n.\nparam\n.\nb32\nsharedMemSize\n,\n.\nparam\n.\nb64\nstream\n)\n;\n// PTX-level Declaration of cudaLaunchDevice() when .address_size is 32\n.\nextern\n.\nfunc\n(.\nparam\n.\nb32\nfunc_retval0\n)\ncudaLaunchDevice\n(\n.\nparam\n.\nb32\nfunc\n,\n.\nparam\n.\nb32\nparameterBuffer\n,\n.\nparam\n.\nalign\n4\n.\nb8\ngridDimension\n[\n12\n],\n.\nparam\n.\nalign\n4\n.\nb8\nblockDimension\n[\n12\n],\n.\nparam\n.\nb32\nsharedMemSize\n,\n.\nparam\n.\nb32\nstream\n)\n;\nThe CUDA-level declaration below is mapped to one of the aforementioned PTX-level declarations and is found in the system header file\ncuda_device_runtime_api.h\n. The function is defined in the\ncudadevrt\nsystem library, which must be linked with a program in order to use device-side kernel launch functionality.\n// CUDA-level declaration of cudaLaunchDevice()\nextern\n\"C\"\n__device__\ncudaError_t\ncudaLaunchDevice\n(\nvoid\n*\nfunc\n,\nvoid\n*\nparameterBuffer\n,\ndim3\ngridDimension\n,\ndim3\nblockDimension\n,\nunsigned\nint\nsharedMemSize\n,\ncudaStream_t\nstream\n);\nThe first parameter is a pointer to the kernel to be is launched, and the second parameter is the parameter buffer that holds the actual parameters to the launched kernel. The layout of the parameter buffer is explained in\nParameter Buffer Layout (CDP1)\n, below. Other parameters specify the launch configuration, i.e., as grid dimension, block dimension, shared memory size, and the stream associated with the launch (please refer to\nExecution Configuration\nfor the detailed description of launch configuration.\n13.6.2.2.1.2.\ncudaGetParameterBuffer (CDP1)\nï\nSee\ncudaGetParameterBuffer\n, above, for CDP2 version of document.\ncudaGetParameterBuffer()\nneeds to be declared at the PTX level before itâs used. The PTX-level declaration must be in one of the two forms given below, depending on address size:\n// PTX-level Declaration of cudaGetParameterBuffer() when .address_size is 64\n// When .address_size is 64\n.\nextern\n.\nfunc\n(.\nparam\n.\nb64\nfunc_retval0\n)\ncudaGetParameterBuffer\n(\n.\nparam\n.\nb64\nalignment\n,\n.\nparam\n.\nb64\nsize\n)\n;\n// PTX-level Declaration of cudaGetParameterBuffer() when .address_size is 32\n.\nextern\n.\nfunc\n(.\nparam\n.\nb32\nfunc_retval0\n)\ncudaGetParameterBuffer\n(\n.\nparam\n.\nb32\nalignment\n,\n.\nparam\n.\nb32\nsize\n)\n;\nThe following CUDA-level declaration of\ncudaGetParameterBuffer()\nis mapped to the aforementioned PTX-level declaration:\n// CUDA-level Declaration of cudaGetParameterBuffer()\nextern\n\"C\"\n__device__\nvoid\n*\ncudaGetParameterBuffer\n(\nsize_t\nalignment\n,\nsize_t\nsize\n);\nThe first parameter specifies the alignment requirement of the parameter buffer and the second parameter the size requirement in bytes. In the current implementation, the parameter buffer returned by\ncudaGetParameterBuffer()\nis always guaranteed to be 64- byte aligned, and the alignment requirement parameter is ignored. However, it is recommended to pass the correct alignment requirement value - which is the largest alignment of any parameter to be placed in the parameter buffer - to\ncudaGetParameterBuffer()\nto ensure portability in the future.\n13.6.2.2.2.\nParameter Buffer Layout (CDP1)\nï\nSee\nParameter Buffer Layout\n, above, for CDP2 version of document.\nParameter reordering in the parameter buffer is prohibited, and each individual parameter placed in the parameter buffer is required to be aligned. That is, each parameter must be placed at the\nn\nth\nbyte in the parameter buffer, where\nn\nis the smallest multiple of the parameter size that is greater than the offset of the last byte taken by the preceding parameter. The maximum size of the parameter buffer is 4KB.\nFor a more detailed description of PTX code generated by the CUDA compiler, please refer to the PTX-3.5 specification.\n13.6.2.3.\nToolkit Support for Dynamic Parallelism (CDP1)\nï\nSee\nToolkit Support for Dynamic Parallelism\n, above, for CDP2 version of document.\n13.6.2.3.1.\nIncluding Device Runtime API in CUDA Code (CDP1)\nï\nSee\nIncluding Device Runtime API in CUDA Code\n, above, for CDP2 version of document.\nSimilar to the host-side runtime API, prototypes for the CUDA device runtime API are included automatically during program compilation. There is no need to include\ncuda_device_runtime_api.h\nexplicitly.\n13.6.2.3.2.\nCompiling and Linking (CDP1)\nï\nSee\nCompiling and Linking\n, above, for CDP2 version of document.\nWhen compiling and linking CUDA programs using dynamic parallelism with\nnvcc\n, the program will automatically link against the static device runtime library\nlibcudadevrt\n.\nThe device runtime is offered as a static library (\ncudadevrt.lib\non Windows,\nlibcudadevrt.a\nunder Linux), against which a GPU application that uses the device runtime must be linked. Linking of device libraries can be accomplished through\nnvcc\nand/or\nnvlink\n. Two simple examples are shown below.\nA device runtime program may be compiled and linked in a single step, if all required source files can be specified from the command line:\n$ nvcc -arch=sm_75 -rdc=true hello_world.cu -o hello -lcudadevrt\nIt is also possible to compile CUDA .cu source files first to object files, and then link these together in a two-stage process:\n$ nvcc -arch=sm_75 -dc hello_world.cu -o hello_world.o\n$ nvcc -arch=sm_75 -rdc=true hello_world.o -o hello -lcudadevrt\nPlease see the Using Separate Compilation section of The CUDA Driver Compiler NVCC guide for more details.\n13.6.3.\nProgramming Guidelines (CDP1)\nï\nSee\nProgramming Guidelines\n, above, for CDP2 version of document.\n13.6.3.1.\nBasics (CDP1)\nï\nSee\nBasics\n, above, for CDP2 version of document.\nThe device runtime is a functional subset of the host runtime. API level device management, kernel launching, device memcpy, stream management, and event management are exposed from the device runtime.\nProgramming for the device runtime should be familiar to someone who already has experience with CUDA. Device runtime syntax and semantics are largely the same as that of the host API, with any exceptions detailed earlier in this document.\nWarning\nExplicit synchronization with child kernels from a parent block (i.e. using\ncudaDeviceSynchronize()\nin device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.\nThe following example shows a simple\nHello World\nprogram incorporating dynamic parallelism:\n#include\n<stdio.h>\n__global__\nvoid\nchildKernel\n()\n{\nprintf\n(\n\"Hello \"\n);\n}\n__global__\nvoid\nparentKernel\n()\n{\n// launch child\nchildKernel\n<<<\n1\n,\n1\n>>>\n();\nif\n(\ncudaSuccess\n!=\ncudaGetLastError\n())\n{\nreturn\n;\n}\n// wait for child to complete\nif\n(\ncudaSuccess\n!=\ncudaDeviceSynchronize\n())\n{\nreturn\n;\n}\nprintf\n(\n\"World!\n\\n\n\"\n);\n}\nint\nmain\n(\nint\nargc\n,\nchar\n*\nargv\n[])\n{\n// launch parent\nparentKernel\n<<<\n1\n,\n1\n>>>\n();\nif\n(\ncudaSuccess\n!=\ncudaGetLastError\n())\n{\nreturn\n1\n;\n}\n// wait for parent to complete\nif\n(\ncudaSuccess\n!=\ncudaDeviceSynchronize\n())\n{\nreturn\n2\n;\n}\nreturn\n0\n;\n}\nThis program may be built in a single step from the command line as follows:\n$ nvcc -arch=sm_75 -rdc=true hello_world.cu -o hello -lcudadevrt\n13.6.3.2.\nPerformance (CDP1)\nï\nSee\nPerformance\n, above, for CDP2 version of document.\n13.6.3.2.1.\nSynchronization (CDP1)\nï\nSee\nCUDA Dynamic Parallelism\n, above, for CDP2 version of document.\nWarning\nExplicit synchronization with child kernels from a parent block (such as using\ncudaDeviceSynchronize()\nin device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.\nSynchronization by one thread may impact the performance of other threads in the same\nThread Block\n, even when those other threads do not call\ncudaDeviceSynchronize()\nthemselves. This impact will depend upon the underlying implementation. In general the implicit synchronization of child kernels done when a thread block ends is more efficient compared to calling\ncudaDeviceSynchronize()\nexplicitly. It is therefore recommended to only call\ncudaDeviceSynchronize()\nif it is needed to synchronize with a child kernel before a thread block ends.\n13.6.3.2.2.\nDynamic-parallelism-enabled Kernel Overhead (CDP1)\nï\nSee\nDynamic-parallelism-enabled Kernel Overhead\n, above, for CDP2 version of document.\nSystem software which is active when controlling dynamic launches may impose an overhead on any kernel which is running at the time, whether or not it invokes kernel launches of its own. This overhead arises from the device runtimeâs execution tracking and management software and may result in decreased performance for example, library calls when made from the device compared to from the host side. This overhead is, in general, incurred for applications that link against the device runtime library.\n13.6.3.3.\nImplementation Restrictions and Limitations (CDP1)\nï\nSee\nImplementation Restrictions and Limitations\n, above, for CDP2 version of document.\nDynamic Parallelism\nguarantees all semantics described in this document, however, certain hardware and software resources are implementation-dependent and limit the scale, performance and other properties of a program which uses the device runtime.\n13.6.3.3.1.\nRuntime (CDP1)\nï\nSee\nRuntime\n, above, for CDP2 version of document.\n13.6.3.3.1.1.\nMemory Footprint (CDP1)\nï\nSee\nMemory Footprint\n, above, for CDP2 version of document.\nThe device runtime system software reserves memory for various management purposes, in particular one reservation which is used for saving parent-grid state during synchronization, and a second reservation for tracking pending grid launches. Configuration controls are available to reduce the size of these reservations in exchange for certain launch limitations. See\nConfiguration Options (CDP1)\n, below, for details.\nThe majority of reserved memory is allocated as backing-store for parent kernel state, for use when synchronizing on a child launch. Conservatively, this memory must support storing of state for the maximum number of live threads possible on the device. This means that each parent generation at which\ncudaDeviceSynchronize()\nis callable may require up to 860MB of device memory, depending on the device configuration, which will be unavailable for program use even if it is not all consumed.\n13.6.3.3.1.2.\nNesting and Synchronization Depth (CDP1)\nï\nSee\nCUDA Dynamic Parallelism\n, above, for CDP2 version of document.\nUsing the device runtime, one kernel may launch another kernel, and that kernel may launch another, and so on. Each subordinate launch is considered a new\nnesting level\n, and the total number of levels is the\nnesting depth\nof the program. The\nsynchronization depth\nis defined as the deepest level at which the program will explicitly synchronize on a child launch. Typically this is one less than the nesting depth of the program, but if the program does not need to call\ncudaDeviceSynchronize()\nat all levels then the synchronization depth might be substantially different to the nesting depth.\nWarning\nExplicit synchronization with child kernels from a parent block (i.e. using\ncudaDeviceSynchronize()\nin device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.\nThe overall maximum nesting depth is limited to 24, but practically speaking the real limit will be the amount of memory required by the system for each new level (see\nMemory Footprint (CDP1)\nabove). Any launch which would result in a kernel at a deeper level than the maximum will fail. Note that this may also apply to\ncudaMemcpyAsync()\n, which might itself generate a kernel launch. See\nConfiguration Options (CDP1)\nfor details.\nBy default, sufficient storage is reserved for two levels of synchronization. This maximum synchronization depth (and hence reserved storage) may be controlled by calling\ncudaDeviceSetLimit()\nand specifying\ncudaLimitDevRuntimeSyncDepth\n. The number of levels to be supported must be configured before the top-level kernel is launched from the host, in order to guarantee successful execution of a nested program. Calling\ncudaDeviceSynchronize()\nat a depth greater than the specified maximum synchronization depth will return an error.\nAn optimization is permitted where the system detects that it need not reserve space for the parentâs state in cases where the parent kernel never calls\ncudaDeviceSynchronize()\n. In this case, because explicit parent/child synchronization never occurs, the memory footprint required for a program will be much less than the conservative maximum. Such a program could specify a shallower maximum synchronization depth to avoid over-allocation of backing store.\n13.6.3.3.1.3.\nPending Kernel Launches (CDP1)\nï\nSee\nPending Kernel Launches\n, above, for CDP2 version of document.\nWhen a kernel is launched, all associated configuration and parameter data is tracked until the kernel completes. This data is stored within a system-managed launch pool.\nThe launch pool is divided into a fixed-size pool and a virtualized pool with lower performance. The device runtime system software will try to track launch data in the fixed-size pool first. The virtualized pool will be used to track new launches when the fixed-size pool is full.\nThe size of the fixed-size launch pool is configurable by calling\ncudaDeviceSetLimit()\nfrom the host and specifying\ncudaLimitDevRuntimePendingLaunchCount\n.\n13.6.3.3.1.4.\nConfiguration Options (CDP1)\nï\nSee\nConfiguration Options\n, above, for CDP2 version of document.\nResource allocation for the device runtime system software is controlled via the\ncudaDeviceSetLimit()\nAPI from the host program. Limits must be set before any kernel is launched, and may not be changed while the GPU is actively running programs.\nWarning\nExplicit synchronization with child kernels from a parent block (i.e. using\ncudaDeviceSynchronize()\nin device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.\nThe following named limits may be set:\nLimit\nBehavior\ncudaLimitDevRuntimeSyncDepth\nSets the maximum depth at which\ncudaDeviceSynchronize()\nmay be called. Launches may be performed deeper than this, but explicit synchronization deeper than this limit will return the\ncudaErrorLaunchMaxDepthExceeded\n. The default maximum sync depth is 2.\ncudaLimitDevRuntimePendingLaunchCount\nControls the amount of memory set aside for buffering kernel launches which have not yet begun to execute, due either to unresolved dependencies or lack of execution resources. When the buffer is full, the device runtime system software will attempt to track new pending launches in a lower performance virtualized buffer. If the virtualized buffer is also full, i.e. when all available heap space is consumed, launches will not occur, and the threadâs last error will be set to\ncudaErrorLaunchPendingCountExceeded\n. The default pending launch count is 2048 launches.\ncudaLimitStackSize\nControls the stack size in bytes of each GPU thread. The CUDA driver automatically increases the per-thread stack size for each kernel launch as needed. This size isnât reset back to the original value after each launch. To set the per-thread stack size to a different value,\ncudaDeviceSetLimit()\ncan be called to set this limit. The stack will be immediately resized, and if necessary, the device will block until all preceding requested tasks are complete.\ncudaDeviceGetLimit()\ncan be called to get the current per-thread stack size.\n13.6.3.3.1.5.\nMemory Allocation and Lifetime (CDP1)\nï\nSee\nMemory Allocation and Lifetime\n, above, for CDP2 version of document.\ncudaMalloc()\nand\ncudaFree()\nhave distinct semantics between the host and device environments. When invoked from the host,\ncudaMalloc()\nallocates a new region from unused device memory. When invoked from the device runtime these functions map to device-side\nmalloc()\nand\nfree()\n. This implies that within the device environment the total allocatable memory is limited to the device\nmalloc()\nheap size, which may be smaller than the available unused device memory. Also, it is an error to invoke\ncudaFree()\nfrom the host program on a pointer which was allocated by\ncudaMalloc()\non the device or vice-versa.\ncudaMalloc()\non Host\ncudaMalloc()\non Device\ncudaFree()\non Host\nSupported\nNot Supported\ncudaFree()\non Device\nNot Supported\nSupported\nAllocation limit\nFree device memory\ncudaLimitMallocHeapSize\n13.6.3.3.1.6.\nSM Id and Warp Id (CDP1)\nï\nSee\nSM Id and Warp Id\n, above, for CDP2 version of document.\nNote that in PTX\n%smid\nand\n%warpid\nare defined as volatile values. The device runtime may reschedule thread blocks onto different SMs in order to more efficiently manage resources. As such, it is unsafe to rely upon\n%smid\nor\n%warpid\nremaining unchanged across the lifetime of a thread or thread block.\n13.6.3.3.1.7.\nECC Errors (CDP1)\nï\nSee\nECC Errors\n, above, for CDP2 version of document.\nNo notification of ECC errors is available to code within a CUDA kernel. ECC errors are reported at the host side once the entire launch tree has completed. Any ECC errors which arise during execution of a nested program will either generate an exception or continue execution (depending upon error and configuration).\n7\n(\n1\n,\n2\n,\n3\n)\nDynamically created texture and surface objects are an addition to the CUDA memory model introduced with CUDA 5.0. Please see the\nCUDA Programming Guide\nfor details.\n14.\nVirtual Memory Management\nï\n14.1.\nIntroduction\nï\nThe\nVirtual Memory Management APIs\nprovide a way for the application to directly manage the unified virtual address space that CUDA provides to map physical memory to virtual addresses accessible by the GPU. Introduced in CUDA 10.2, these APIs additionally provide a new way to interop with other processes and graphics APIs like OpenGL and Vulkan, as well as provide newer memory attributes that a user can tune to fit their applications.\nHistorically, memory allocation calls (such as\ncudaMalloc()\n) in the CUDA programming model have returned a memory address that points to the GPU memory. The address thus obtained could be used with any CUDA API or inside a device kernel. However, the memory allocated could not be resized depending on the userâs memory needs. In order to increase an allocationâs size, the user had to explicitly allocate a larger buffer, copy data from the initial allocation, free it and then continue to keep track of the newer allocationâs address. This often leads to lower performance and higher peak memory utilization for applications. Essentially, users had a malloc-like interface for allocating GPU memory, but did not have a corresponding realloc to complement it. The Virtual Memory Management APIs decouple the idea of an address and memory and allow the application to handle them separately. The APIs allow applications to map and unmap memory from a virtual address range as they see fit.\nIn the case of enabling peer device access to memory allocations by using\ncudaEnablePeerAccess\n, all past and future user allocations are mapped to the target peer device. This lead to users unwittingly paying runtime cost of mapping all cudaMalloc allocations to peer devices. However, in most situations applications communicate by sharing only a few allocations with another device and not all allocations are required to be mapped to all the devices. With Virtual Memory Management, applications can specifically choose certain allocations to be accessible from target devices.\nThe CUDA Virtual Memory Management APIs expose fine grained control to the user for managing the GPU memory in applications. It provides APIs that let users:\nPlace memory allocated on different devices into a contiguous VA range.\nPerform interprocess communication for memory sharing using platform-specific mechanisms.\nOpt into newer memory types on the devices that support them.\nIn order to allocate memory, the Virtual Memory Management programming model exposes the following functionality:\nAllocating physical memory.\nReserving a VA range.\nMapping allocated memory to the VA range.\nControlling access rights on the mapped range.\nNote that the suite of APIs described in this section require a system that supports UVA.\n14.2.\nQuery for Support\nï\nBefore attempting to use Virtual Memory Management APIs, applications must ensure that the devices they want to use support CUDA Virtual Memory Management. The following code sample shows querying for Virtual Memory Management support:\nint\ndeviceSupportsVmm\n;\nCUresult\nresult\n=\ncuDeviceGetAttribute\n(\n&\ndeviceSupportsVmm\n,\nCU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED\n,\ndevice\n);\nif\n(\ndeviceSupportsVmm\n!=\n0\n)\n{\n// `device` supports Virtual Memory Management\n}\n14.3.\nAllocating Physical Memory\nï\nThe first step in memory allocation using Virtual Memory Management APIs is to create a physical memory chunk that will provide a backing for the allocation. In order to allocate physical memory, applications must use the\ncuMemCreate\nAPI. The allocation created by this function does not have any device or host mappings. The function argument\nCUmemGenericAllocationHandle\ndescribes the properties of the memory to allocate such as the location of the allocation, if the allocation is going to be shared to another process (or other Graphics APIs), or the physical attributes of the memory to be allocated. Users must ensure the requested allocationâs size must be aligned to appropriate granularity. Information regarding an allocationâs granularity requirements can be queried using\ncuMemGetAllocationGranularity\n. The following code snippet shows allocating physical memory with\ncuMemCreate\n:\nCUmemGenericAllocationHandle\nallocatePhysicalMemory\n(\nint\ndevice\n,\nsize_t\nsize\n)\n{\nCUmemAllocationProp\nprop\n=\n{};\nprop\n.\ntype\n=\nCU_MEM_ALLOCATION_TYPE_PINNED\n;\nprop\n.\nlocation\n.\ntype\n=\nCU_MEM_LOCATION_TYPE_DEVICE\n;\nprop\n.\nlocation\n.\nid\n=\ndevice\n;\nsize_t\ngranularity\n=\n0\n;\ncuMemGetAllocationGranularity\n(\n&\ngranularity\n,\n&\nprop\n,\nCU_MEM_ALLOC_GRANULARITY_MINIMUM\n);\n// Ensure size matches granularity requirements for the allocation\nsize_t\npadded_size\n=\nROUND_UP\n(\nsize\n,\ngranularity\n);\n// Allocate physical memory\nCUmemGenericAllocationHandle\nallocHandle\n;\ncuMemCreate\n(\n&\nallocHandle\n,\npadded_size\n,\n&\nprop\n,\n0\n);\nreturn\nallocHandle\n;\n}\nThe memory allocated by\ncuMemCreate\nis referenced by the\nCUmemGenericAllocationHandle\nit returns. This is a departure from the cudaMalloc-style of allocation, which returns a pointer to the GPU memory, which was directly accessible by CUDA kernel executing on the device. The memory allocated cannot be used for any operations other than querying properties using\ncuMemGetAllocationPropertiesFromHandle\n. In order to make this memory accessible, applications must map this memory into a VA range reserved by\ncuMemAddressReserve\nand provide suitable access rights to it. Applications must free the allocated memory using the\ncuMemRelease\nAPI.\n14.3.1.\nShareable Memory Allocations\nï\nWith\ncuMemCreate\nusers now have the facility to indicate to CUDA, at allocation time, that they have earmarked a particular allocation for Inter process communication and graphics interop purposes. Applications can do this by setting\nCUmemAllocationProp::requestedHandleTypes\nto a platform-specific field. On Windows, when\nCUmemAllocationProp::requestedHandleTypes\nis set to\nCU_MEM_HANDLE_TYPE_WIN32\napplications must also specify an LPSECURITYATTRIBUTES attribute in\nCUmemAllocationProp::win32HandleMetaData\n. This security attribute defines the scope of which exported allocations may be transferred to other processes.\nThe CUDA Virtual Memory Management API functions do not support the legacy interprocess communication functions with their memory. Instead, they expose a new mechanism for interprocess communication that uses OS-specific handles. Applications can obtain these OS-specific handles corresponding to the allocations by using\ncuMemExportToShareableHandle\n. The handles thus obtained can be transferred by using the usual OS native mechanisms for inter process communication. The recipient process should import the allocation by using\ncuMemImportFromShareableHandle\n.\nUsers must ensure they query for support of the requested handle type before attempting to export memory allocated with\ncuMemCreate\n. The following code snippet illustrates query for handle type support in a platform-specific way.\nint\ndeviceSupportsIpcHandle\n;\n#if defined(__linux__)\ncuDeviceGetAttribute\n(\n&\ndeviceSupportsIpcHandle\n,\nCU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED\n,\ndevice\n));\n#else\ncuDeviceGetAttribute\n(\n&\ndeviceSupportsIpcHandle\n,\nCU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED\n,\ndevice\n));\n#endif\nUsers should set the\nCUmemAllocationProp::requestedHandleTypes\nappropriately as shown below:\n#if defined(__linux__)\nprop\n.\nrequestedHandleTypes\n=\nCU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR\n;\n#else\nprop\n.\nrequestedHandleTypes\n=\nCU_MEM_HANDLE_TYPE_WIN32\n;\nprop\n.\nwin32HandleMetaData\n=\n// Windows specific LPSECURITYATTRIBUTES attribute.\n#endif\nThe\nmemMapIpcDrv\nsample can be used as an example for using IPC with Virtual Memory Management allocations.\n14.3.2.\nMemory Type\nï\nBefore CUDA 10.2, applications had no user-controlled way of allocating any special type of memory that certain devices may support. With\ncuMemCreate\n, applications can additionally specify memory type requirements using the\nCUmemAllocationProp::allocFlags\nto opt into any specific memory features. Applications must also ensure that the requested memory type is supported on the device of allocation.\n14.3.2.1.\nCompressible Memory\nï\nCompressible memory can be used to accelerate accesses to data with unstructured sparsity and other compressible data patterns. Compression can save DRAM bandwidth, L2 read bandwidth and L2 capacity depending on the data being operated on. Applications that want to allocate compressible memory on devices that support Compute Data Compression can do so by setting\nCUmemAllocationProp::allocFlags::compressionType\nto\nCU_MEM_ALLOCATION_COMP_GENERIC\n. Users must query if device supports Compute Data Compression by using\nCU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED\n. The following code snippet illustrates querying compressible memory support\ncuDeviceGetAttribute\n.\nint\ncompressionSupported\n=\n0\n;\ncuDeviceGetAttribute\n(\n&\ncompressionSupported\n,\nCU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED\n,\ndevice\n);\nOn devices that support Compute Data Compression, users must opt in at allocation time as shown below:\nprop\n.\nallocFlags\n.\ncompressionType\n=\nCU_MEM_ALLOCATION_COMP_GENERIC\n;\nDue to various reasons such as limited HW resources, the allocation may not have compression attributes, the user is expected to query back the properties of the allocated memory using\ncuMemGetAllocationPropertiesFromHandle\nand check for compression attribute.\nCUmemAllocationProp\nallocationProp\n=\n{};\ncuMemGetAllocationPropertiesFromHandle\n(\n&\nallocationProp\n,\nallocationHandle\n);\nif\n(\nallocationProp\n.\nallocFlags\n.\ncompressionType\n==\nCU_MEM_ALLOCATION_COMP_GENERIC\n)\n{\n// Obtained compressible memory allocation\n}\n14.4.\nReserving a Virtual Address Range\nï\nSince with Virtual Memory Management the notions of address and memory are distinct, applications must carve out an address range that can hold the memory allocations made by\ncuMemCreate\n. The address range reserved must be at least as large as the sum of the sizes of all the physical memory allocations the user plans to place in them.\nApplications can reserve a virtual address range by passing appropriate parameters to\ncuMemAddressReserve\n. The address range obtained will not have any device or host physical memory associated with it. The reserved virtual address range can be mapped to memory chunks belonging to any device in the system, thus providing the application a continuous VA range backed and mapped by memory belonging to different devices. Applications are expected to return the virtual address range back to CUDA using\ncuMemAddressFree\n. Users must ensure that the entire VA range is unmapped before calling\ncuMemAddressFree\n. These functions are conceptually similar to mmap/munmap (on Linux) or VirtualAlloc/VirtualFree (on Windows) functions. The following code snippet illustrates the usage for the function:\nCUdeviceptr\nptr\n;\n// `ptr` holds the returned start of virtual address range reserved.\nCUresult\nresult\n=\ncuMemAddressReserve\n(\n&\nptr\n,\nsize\n,\n0\n,\n0\n,\n0\n);\n// alignment = 0 for default alignment\n14.5.\nVirtual Aliasing Support\nï\nThe Virtual Memory Management APIs provide a way to create multiple virtual memory mappings or âproxiesâ to the same allocation using multiple calls to\ncuMemMap\nwith different virtual addresses, so-called virtual aliasing. Unless otherwise noted in the PTX ISA, writes to one proxy of the allocation are considered inconsistent and incoherent with any other proxy of the same memory until the writing device operation (grid launch, memcpy, memset, and so on) completes. Grids present on the GPU prior to a writing device operation but reading after the writing device operation completes are also considered to have inconsistent and incoherent proxies.\nFor example, the following snippet is considered undefined, assuming device pointers A and B are virtual aliases of the same memory allocation:\n__global__\nvoid\nfoo\n(\nchar\n*\nA\n,\nchar\n*\nB\n)\n{\n*\nA\n=\n0x1\n;\nprintf\n(\n\"%d\n\\n\n\"\n,\n*\nB\n);\n// Undefined behavior!  *B can take on either\n// the previous value or some value in-between.\n}\nThe following is defined behavior, assuming these two kernels are ordered monotonically (by streams or events).\n__global__\nvoid\nfoo1\n(\nchar\n*\nA\n)\n{\n*\nA\n=\n0x1\n;\n}\n__global__\nvoid\nfoo2\n(\nchar\n*\nB\n)\n{\nprintf\n(\n\"%d\n\\n\n\"\n,\n*\nB\n);\n// *B == *A == 0x1 assuming foo2 waits for foo1\n// to complete before launching\n}\ncudaMemcpyAsync\n(\nB\n,\ninput\n,\nsize\n,\nstream1\n);\n// Aliases are allowed at\n// operation boundaries\nfoo1\n<<<\n1\n,\n1\n,\n0\n,\nstream1\n>>>\n(\nA\n);\n// allowing foo1 to access A.\ncudaEventRecord\n(\nevent\n,\nstream1\n);\ncudaStreamWaitEvent\n(\nstream2\n,\nevent\n);\nfoo2\n<<<\n1\n,\n1\n,\n0\n,\nstream2\n>>>\n(\nB\n);\ncudaStreamWaitEvent\n(\nstream3\n,\nevent\n);\ncudaMemcpyAsync\n(\noutput\n,\nB\n,\nsize\n,\nstream3\n);\n// Both launches of foo2 and\n// cudaMemcpy (which both\n// read) wait for foo1 (which writes)\n// to complete before proceeding\nIf accessing same allocation through different âproxiesâ is required in the same kernel a\nfence.proxy.alias\ncan be used between the two accesses. The above example can thus be made legal with inline PTX assembly:\n__global__\nvoid\nfoo\n(\nchar\n*\nA\n,\nchar\n*\nB\n)\n{\n*\nA\n=\n0x1\n;\nasm\nvolatile\n(\n\"fence.proxy.alias;\"\n:::\n\"memory\"\n);\nprintf\n(\n\"%d\n\\n\n\"\n,\n*\nB\n);\n// *B == *A == 0x1\n}\n14.6.\nMapping Memory\nï\nThe allocated physical memory and the carved out virtual address space from the previous two sections represent the memory and address distinction introduced by the Virtual Memory Management APIs. For the allocated memory to be useable, the user must first place the memory in the address space. The address range obtained from\ncuMemAddressReserve\nand the physical allocation obtained from\ncuMemCreate\nor\ncuMemImportFromShareableHandle\nmust be associated with each other by using\ncuMemMap\n.\nUsers can associate allocations from multiple devices to reside in contiguous virtual address ranges as long as they have carved out enough address space. In order to decouple the physical allocation and the address range, users must unmap the address of the mapping by using\ncuMemUnmap\n. Users can map and unmap memory to the same address range as many times as they want, as long as they ensure that they donât attempt to create mappings on VA range reservations that are already mapped. The following code snippet illustrates the usage for the function:\nCUdeviceptr\nptr\n;\n// `ptr`: address in the address range previously reserved by cuMemAddressReserve.\n// `allocHandle`: CUmemGenericAllocationHandle obtained by a previous call to cuMemCreate.\nCUresult\nresult\n=\ncuMemMap\n(\nptr\n,\nsize\n,\n0\n,\nallocHandle\n,\n0\n);\n14.7.\nControlling Access Rights\nï\nThe Virtual Memory Management APIs enable applications to explicitly protect their VA ranges with access control mechanisms. Mapping the allocation to a region of the address range using\ncuMemMap\ndoes not make the address accessible, and would result in a program crash if accessed by a CUDA kernel. Users must specifically select access control using the\ncuMemSetAccess\nfunction, which allows or restricts access for specific devices to a mapped address range. The following code snippet illustrates the usage for the function:\nvoid\nsetAccessOnDevice\n(\nint\ndevice\n,\nCUdeviceptr\nptr\n,\nsize_t\nsize\n)\n{\nCUmemAccessDesc\naccessDesc\n=\n{};\naccessDesc\n.\nlocation\n.\ntype\n=\nCU_MEM_LOCATION_TYPE_DEVICE\n;\naccessDesc\n.\nlocation\n.\nid\n=\ndevice\n;\naccessDesc\n.\nflags\n=\nCU_MEM_ACCESS_FLAGS_PROT_READWRITE\n;\n// Make the address accessible\ncuMemSetAccess\n(\nptr\n,\nsize\n,\n&\naccessDesc\n,\n1\n);\n}\nThe access control mechanism exposed with Virtual Memory Management allows users to be explicit about which allocations they want to share with other peer devices on the system. As specified earlier,\ncudaEnablePeerAccess\nforces all prior and future cudaMallocâd allocations to be mapped to the target peer device. This can be convenient in many cases as user doesnât have to worry about tracking the mapping state of every allocation to every device in the system. But for users concerned with performance of their applications this approach\nhas performance implications\n. With access control at allocation granularity Virtual Memory Management exposes a mechanism to have peer mappings with minimal overhead.\nThe\nvectorAddMMAP\nsample can be used as an example for using the Virtual Memory Management APIs.\n14.8.\nFabric Memory\nï\nCUDA 12.4 introduced a new VMM allocation handle type\nCU_MEM_HANDLE_TYPE_FABRIC\n. On supported platforms and provided the NVIDIA IMEX daemon\nis running this allocation handle type enables sharing allocations not only intra node with any communication mechanism, e.g. MPI, but also inter\nnode. This allows GPUs in a Multi Node NVLINK System to map the memory of all other GPUs part of the same NVLINK fabric even if they are in\ndifferent nodes greatly increasing the scale of multi-GPU Programming with NVLINK.\n14.8.1.\nQuery for Support\nï\nBefore attempting to use Fabric Memory, applications must ensure that the devices they want to use support Fabric Memory. The following code\nsample shows querying for Fabric Memory support:\nint\ndeviceSupportsFabricMem\n;\nCUresult\nresult\n=\ncuDeviceGetAttribute\n(\n&\ndeviceSupportsFabricMem\n,\nCU_DEVICE_ATTRIBUTE_HANDLE_TYPE_FABRIC_SUPPORTED\n,\ndevice\n);\nif\n(\ndeviceSupportsFabricMem\n!=\n0\n)\n{\n// `device` supports Fabric Memory\n}\nAside from using\nCU_MEM_HANDLE_TYPE_FABRIC\nas handle type and not requiring OS native mechanisms for inter process communication to exchange\nsharable handles there is no difference in using Fabric Memory compared to other allocation handle types.\n14.9.\nMulticast Support\nï\nThe\nMulticast Object Management APIs\nprovide a way for the application to create Multicast Objects and in combination with the\nVirtual Memory Management APIs\ndescribed above allow applications to leverage NVLINK SHARP on supported NVLINK connected GPUs if they are connected with NVSWITCH. NVLINK SHARP\nallows CUDA applications to leverage in fabric computing to accelerate operations like broadcast and reductions between GPUs connected with\nNVSWITCH. For this to work multiple NVLINK connected GPUs form a Multicast Team and each GPU from the team backs up a Multicast Object with\nphysical memory. So a Multicast Team of N GPUs has N physical replicas, each local to one participating GPU, of a Multicast Object.\nThe\nmultimem PTX instructions\nusing mappings of Multicast Objects work with all replicas of the Multicast Object.\nTo work with Multicast Objects an application needs to\nQuery Multicast Support\nCreate a Multicast Handle with\ncuMulticastCreate\n.\nShare the Multicast Handle with all processes that control a GPU which should participate in a Multicast Team. This works with\ncuMemExportToShareableHandle\nas described above.\nAdd all GPUs that should participate in the Multicast Team with\ncuMulticastAddDevice\n.\nFor each participating GPU bind physical memory allocated with\ncuMemCreate\nas described above to the Multicast Handle. All devices need to be added to the Multicast Team before binding memory on any device.\nReserve an address range, map the Multicast Handle and set Access Rights as described above for regular Unicast mappings. Unicast and Multicast mappings to the same physical memory are possible. See the\nVirtual Aliasing Support\nsection above how to ensure consistency between multiple mappings to the same physical memory.\nUse the\nmultimem PTX instructions\nwith the multicast mappings.\nThe\nmulti_node_p2p\nexample in the\nMulti GPU Programming Models\nGitHub\nrepository contains a complete example using Fabric Memory including Multicast Objects to leverage NVLINK SHARP. Please note that this example is\nfor developers of libraries like NCCL or NVSHMEM. It shows how higher-level programming models like NVSHMEM work internally within a (multinode)\nNVLINK domain. Application developers generally should use the higher-level MPI, NCCL, or NVSHMEM interfaces instead of this API.\n14.9.1.\nQuery for Support\nï\nBefore attempting to use Multicast Objects, applications must ensure that the devices they want to use support them. The following code sample\nshows querying for Fabric Memory support:\nint\ndeviceSupportsMultiCast\n;\nCUresult\nresult\n=\ncuDeviceGetAttribute\n(\n&\ndeviceSupportsMultiCast\n,\nCU_DEVICE_ATTRIBUTE_MULTICAST_SUPPORTED\n,\ndevice\n);\nif\n(\ndeviceSupportsMultiCast\n!=\n0\n)\n{\n// `device` supports Multicast Objects\n}\n14.9.2.\nAllocating Multicast Objects\nï\nMulticast Objects can be created with\ncuMulticastCreate\n:\nCUmemGenericAllocationHandle\ncreateMCHandle\n(\nint\nnumDevices\n,\nsize_t\nsize\n)\n{\nCUmemAllocationProp\nmcProp\n=\n{};\nmcProp\n.\nnumDevices\n=\nnumDevices\n;\nmcProp\n.\nhandleTypes\n=\nCU_MEM_HANDLE_TYPE_FABRIC\n;\n// or on single node CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR\nsize_t\ngranularity\n=\n0\n;\ncuMulticastGetGranularity\n(\n&\ngranularity\n,\n&\nmcProp\n,\nCU_MEM_ALLOC_GRANULARITY_MINIMUM\n);\n// Ensure size matches granularity requirements for the allocation\nsize_t\npadded_size\n=\nROUND_UP\n(\nsize\n,\ngranularity\n);\nmcProp\n.\nsize\n=\npadded_size\n;\n// Create Multicast Object this has no devices and no physical memory associated yet\nCUmemGenericAllocationHandle\nmcHandle\n;\ncuMulticastCreate\n(\n&\nmcHandle\n,\n&\nmcProp\n);\nreturn\nmcHandle\n;\n}\n14.9.3.\nAdd Devices to Multicast Objects\nï\nDevices can be added to a Multicast Team with\ncuMulticastAddDevice\n:\ncuMulticastAddDevice\n(\n&\nmcHandle\n,\ndevice\n);\nThis step needs to be completed on all processes controlling devices that should participate in a Multicast Team before memory on any device is\nbound to the Multicast Object.\n14.9.4.\nBind Memory to Multicast Objects\nï\nAfter a Multicast Object has been created and all participating devices have been added to the Multicast Object it needs to be backed with\nphysical memory allocated with\ncuMemCreate\nfor each device:\ncuMulticastBindMem\n(\nmcHandle\n,\nmcOffset\n,\nmemHandle\n,\nmemOffset\n,\nsize\n,\n0\n/*flags*/\n);\n14.9.5.\nUse Multicast Mappings\nï\nTo use Multicast Mappings in CUDA C++ it is required to use the\nmultimem PTX instructions\nwith Inline PTX Assembly:\n__global__\nvoid\nall_reduce_norm_barrier_kernel\n(\nfloat\n*\nl2_norm\n,\nfloat\n*\npartial_l2_norm_mc\n,\nunsigned\nint\n*\narrival_counter_uc\n,\nunsigned\nint\n*\narrival_counter_mc\n,\nconst\nunsigned\nint\nexpected_count\n)\n{\nassert\n(\n1\n==\nblockDim\n.\nx\n*\nblockDim\n.\ny\n*\nblockDim\n.\nz\n*\ngridDim\n.\nx\n*\ngridDim\n.\ny\n*\ngridDim\n.\nz\n);\nfloat\nl2_norm_sum\n=\n0.0\n;\n#if __CUDA_ARCH__ >= 900\n// atomic reduction to all replicas\n// this can be conceptually thought of as __threadfence_system(); atomicAdd_system(arrival_counter_mc, 1);\nasm\nvolatile\n(\n\"multimem.red.release.sys.global.add.u32 [%0], %1;\"\n::\n\"l\"\n(\narrival_counter_mc\n),\n\"n\"\n(\n1\n)\n:\n\"memory\"\n);\n// Need a fence between Multicast (mc) and Unicast (uc) access to the same memory `arrival_counter_uc` and `arrival_counter_mc`:\n// - fence.proxy instructions establish an ordering between memory accesses that may happen through different proxies\n// - Value .alias of the .proxykind qualifier refers to memory accesses performed using virtually aliased addresses to the same memory location.\n// from https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-membar\nasm\nvolatile\n(\n\"fence.proxy.alias;\"\n:::\n\"memory\"\n);\n// spin wait with acquire ordering on UC mapping till all peers have arrived in this iteration\n// Note: all ranks need to reach another barrier after this kernel, such that it is not possible for the barrier to be unblocked by an\n// arrival of a rank for the next iteration if some other rank is slow.\ncuda\n::\natomic_ref\n<\nunsigned\nint\n,\ncuda\n::\nthread_scope_system\n>\nac\n(\narrival_counter_uc\n);\nwhile\n(\nexpected_count\n>\nac\n.\nload\n(\ncuda\n::\nmemory_order_acquire\n));\n// Atomic load reduction from all replicas. It does not provide ordering so it can be relaxed.\nasm\nvolatile\n(\n\"multimem.ld_reduce.relaxed.sys.global.add.f32 %0, [%1];\"\n:\n\"=f\"\n(\nl2_norm_sum\n)\n:\n\"l\"\n(\npartial_l2_norm_mc\n)\n:\n\"memory\"\n);\n#else\n#error \"ERROR: multimem instructions require compute capability 9.0 or larger.\"\n#endif\n*\nl2_norm\n=\nstd\n::\nsqrt\n(\nl2_norm_sum\n);\n}\n15.\nStream Ordered Memory Allocator\nï\n15.1.\nIntroduction\nï\nManaging memory allocations using\ncudaMalloc\nand\ncudaFree\ncauses GPU to synchronize across all executing CUDA streams. The Stream Order Memory Allocator enables applications to order memory allocation and deallocation with other work launched into a CUDA stream such as kernel launches and asynchronous copies. This improves application memory use by taking advantage of stream-ordering semantics to reuse memory allocations. The allocator also allows applications to control the allocatorâs memory caching behavior. When set up with an appropriate release threshold, the caching behavior allows the allocator to avoid expensive calls into the OS when the application indicates it is willing to accept a bigger memory footprint. The allocator also supports the easy and secure sharing of allocations between processes.\nFor many applications, the Stream Ordered Memory Allocator reduces the need for custom memory management abstractions, and makes it easier to create high-performance custom memory management for applications that need it. For applications and libraries that already have custom memory allocators, adopting the Stream Ordered Memory Allocator enables multiple libraries to share a common pool of memory managed by the driver, thus reducing excess memory consumption. Additionally, the driver can perform optimizations based on its awareness of the allocator and other stream management APIs. Finally, Nsight Compute and the Next-Gen CUDA debugger is aware of the allocator as part of their CUDA 11.3 toolkit support.\n15.2.\nQuery for Support\nï\nThe user can determine whether or not a device supports the stream ordered memory allocator by calling\ncudaDeviceGetAttribute()\nwith the device attribute\ncudaDevAttrMemoryPoolsSupported\n.\nStarting with CUDA 11.3, IPC memory pool support can be queried with the\ncudaDevAttrMemoryPoolSupportedHandleTypes\ndevice attribute. Previous drivers will return\ncudaErrorInvalidValue\nas those drivers are unaware of the attribute enum.\nint\ndriverVersion\n=\n0\n;\nint\ndeviceSupportsMemoryPools\n=\n0\n;\nint\npoolSupportedHandleTypes\n=\n0\n;\ncudaDriverGetVersion\n(\n&\ndriverVersion\n);\nif\n(\ndriverVersion\n>=\n11020\n)\n{\ncudaDeviceGetAttribute\n(\n&\ndeviceSupportsMemoryPools\n,\ncudaDevAttrMemoryPoolsSupported\n,\ndevice\n);\n}\nif\n(\ndeviceSupportsMemoryPools\n!=\n0\n)\n{\n// `device` supports the Stream Ordered Memory Allocator\n}\nif\n(\ndriverVersion\n>=\n11030\n)\n{\ncudaDeviceGetAttribute\n(\n&\npoolSupportedHandleTypes\n,\ncudaDevAttrMemoryPoolSupportedHandleTypes\n,\ndevice\n);\n}\nif\n(\npoolSupportedHandleTypes\n&\ncudaMemHandleTypePosixFileDescriptor\n)\n{\n// Pools on the specified device can be created with posix file descriptor-based IPC\n}\nPerforming the driver version check before the query avoids hitting a\ncudaErrorInvalidValue\nerror on drivers where the attribute was not yet defined. One can use\ncudaGetLastError\nto clear the error instead of avoiding it.\n15.3.\nAPI Fundamentals (cudaMallocAsync and cudaFreeAsync)\nï\nThe APIs\ncudaMallocAsync\nand\ncudaFreeAsync\nform the core of the allocator.\ncudaMallocAsync\nreturns an allocation and\ncudaFreeAsync\nfrees an allocation. Both APIs accept stream arguments to define when the allocation will become and stop being available for use. The pointer value returned by\ncudaMallocAsync\nis determined synchronously and is available for constructing future work. It is important to note that\ncudaMallocAsync\nignores the current device/context when determining where the allocation will reside. Instead,\ncudaMallocAsync\ndetermines the resident device based on the specified memory pool or the supplied stream. The simplest use pattern is when the memory is allocated, used, and freed back into the same stream.\nvoid\n*\nptr\n;\nsize_t\nsize\n=\n512\n;\ncudaMallocAsync\n(\n&\nptr\n,\nsize\n,\ncudaStreamPerThread\n);\n// do work using the allocation\nkernel\n<<<\n...,\ncudaStreamPerThread\n>>>\n(\nptr\n,\n...);\n// An asynchronous free can be specified without synchronizing the cpu and GPU\ncudaFreeAsync\n(\nptr\n,\ncudaStreamPerThread\n);\nWhen using an allocation in a stream other than the allocating stream, the user must guarantee that the access will happen after the allocation operation, otherwise the behavior is undefined. The user may make this guarantee either by synchronizing the allocating stream, or by using CUDA events to synchronize the producing and consuming streams.\ncudaFreeAsync()\ninserts a free operation into the stream. The user must guarantee that the free operation happens after the allocation operation and any use of the allocation. Also, any use of the allocation after the free operation starts results in undefined behavior. Events and/or stream synchronizing operations should be used to guarantee any access to the allocation on other streams is complete before the freeing stream begins the free operation.\ncudaMallocAsync\n(\n&\nptr\n,\nsize\n,\nstream1\n);\ncudaEventRecord\n(\nevent1\n,\nstream1\n);\n//stream2 must wait for the allocation to be ready before accessing\ncudaStreamWaitEvent\n(\nstream2\n,\nevent1\n);\nkernel\n<<<\n...,\nstream2\n>>>\n(\nptr\n,\n...);\ncudaEventRecord\n(\nevent2\n,\nstream2\n);\n// stream3 must wait for stream2 to finish accessing the allocation before\n// freeing the allocation\ncudaStreamWaitEvent\n(\nstream3\n,\nevent2\n);\ncudaFreeAsync\n(\nptr\n,\nstream3\n);\nThe user can free allocations allocated with\ncudaMalloc()\nwith\ncudaFreeAsync()\n. The user must make the same guarantees about accesses being complete before the free operation begins.\ncudaMalloc\n(\n&\nptr\n,\nsize\n);\nkernel\n<<<\n...,\nstream\n>>>\n(\nptr\n,\n...);\ncudaFreeAsync\n(\nptr\n,\nstream\n);\nThe user can free memory allocated with\ncudaMallocAsync\nwith\ncudaFree()\n. When freeing such allocations through the\ncudaFree()\nAPI, the driver assumes that all accesses to the allocation are complete and performs no further synchronization. The user can use\ncudaStreamQuery\n/\ncudaStreamSynchronize\n/\ncudaEventQuery\n/\ncudaEventSynchronize\n/\ncudaDeviceSynchronize\nto guarantee that the appropriate asynchronous work is complete and that the GPU will not try to access the allocation.\ncudaMallocAsync\n(\n&\nptr\n,\nsize\n,\nstream\n);\nkernel\n<<<\n...,\nstream\n>>>\n(\nptr\n,\n...);\n// synchronize is needed to avoid prematurely freeing the memory\ncudaStreamSynchronize\n(\nstream\n);\ncudaFree\n(\nptr\n);\n15.4.\nMemory Pools and the cudaMemPool_t\nï\nMemory pools encapsulate virtual address and physical memory resources that are allocated and managed according to the pools attributes and properties. The primary aspect of a memory pool is the kind and location of memory it manages.\nAll calls to\ncudaMallocAsync\nuse the resources of a memory pool. In the absence of a specified memory pool,\ncudaMallocAsync\nuses the current memory pool of the supplied streamâs device. The current memory pool for a device may be set with\ncudaDeviceSetMempool\nand queried with\ncudaDeviceGetMempool\n. By default (in the absence of a\ncudaDeviceSetMempool\ncall), the current memory pool is the default memory pool of a device. The API\ncudaMallocFromPoolAsync\nand\nc++ overloads of cudaMallocAsync\nallow a user to specify the pool to be used for an allocation without setting it as the current pool. The APIs\ncudaDeviceGetDefaultMempool\nand\ncudaMemPoolCreate\ngive users handles to memory pools.\nNote\nThe mempool current to a device will be local to that device. So allocating without specifying a memory pool will always yield an allocation local to the streamâs device.\nNote\ncudaMemPoolSetAttribute\nand\ncudaMemPoolGetAttribute\ncontrol the attributes of the memory pools.\n15.5.\nDefault/Implicit Pools\nï\nThe default memory pool of a device may be retrieved with the\ncudaDeviceGetDefaultMempool\nAPI. Allocations from the default memory pool of a device are non-migratable device allocation located on that device. These allocations will always be accessible from that device. The accessibility of the default memory pool may be modified with\ncudaMemPoolSetAccess\nand queried by\ncudaMemPoolGetAccess\n. Since the default pools do not need to be explicitly created, they are sometimes referred to as implicit pools. The default memory pool of a device does not support IPC.\n15.6.\nExplicit Pools\nï\nThe API\ncudaMemPoolCreate\ncreates an explicit pool. This allows applications to request properties for their allocation beyond what is provided by the default/implict pools. These include properties such as IPC capability, maximum pool size, allocations resident on a specific CPU NUMA node on supported platforms etc.\n// create a pool similar to the implicit pool on device 0\nint\ndevice\n=\n0\n;\ncudaMemPoolProps\npoolProps\n=\n{\n};\npoolProps\n.\nallocType\n=\ncudaMemAllocationTypePinned\n;\npoolProps\n.\nlocation\n.\nid\n=\ndevice\n;\npoolProps\n.\nlocation\n.\ntype\n=\ncudaMemLocationTypeDevice\n;\ncudaMemPoolCreate\n(\n&\nmemPool\n,\n&\npoolProps\n));\nThe following code snippet illustrates an example of creating an IPC capable memory pool on a valid CPU NUMA node.\n// create a pool resident on a CPU NUMA node that is capable of IPC sharing (via a file descriptor).\nint\ncpu_numa_id\n=\n0\n;\ncudaMemPoolProps\npoolProps\n=\n{\n};\npoolProps\n.\nallocType\n=\ncudaMemAllocationTypePinned\n;\npoolProps\n.\nlocation\n.\nid\n=\ncpu_numa_id\n;\npoolProps\n.\nlocation\n.\ntype\n=\ncudaMemLocationTypeHostNuma\n;\npoolProps\n.\nhandleType\n=\ncudaMemHandleTypePosixFileDescriptor\n;\ncudaMemPoolCreate\n(\n&\nipcMemPool\n,\n&\npoolProps\n));\n15.7.\nPhysical Page Caching Behavior\nï\nBy default, the allocator tries to minimize the physical memory owned by a pool. To minimize the OS calls to allocate and free physical memory, applications must configure a memory footprint for each pool. Applications can do this with the release threshold attribute (\ncudaMemPoolAttrReleaseThreshold\n).\nThe release threshold is the amount of memory in bytes a pool should hold onto before trying to release memory back to the OS. When more than the release threshold bytes of memory are held by the memory pool, the allocator will try to release memory back to the OS on the next call to stream, event or device synchronize. Setting the release threshold to UINT64_MAX will prevent the driver from attempting to shrink the pool after every synchronization.\nCuuint64_t\nsetVal\n=\nUINT64_MAX\n;\ncudaMemPoolSetAttribute\n(\nmemPool\n,\ncudaMemPoolAttrReleaseThreshold\n,\n&\nsetVal\n);\nApplications that set\ncudaMemPoolAttrReleaseThreshold\nhigh enough to effectively disable memory pool shrinking may wish to explicitly shrink a memory poolâs memory footprint.\ncudaMemPoolTrimTo\nallows such applications to do so. When trimming a memory poolâs footprint, the\nminBytesToKeep\nparameter allows an application to hold onto an amount of memory it expects to need in a subsequent phase of execution.\nCuuint64_t\nsetVal\n=\nUINT64_MAX\n;\ncudaMemPoolSetAttribute\n(\nmemPool\n,\ncudaMemPoolAttrReleaseThreshold\n,\n&\nsetVal\n);\n// application phase needing a lot of memory from the stream ordered allocator\nfor\n(\ni\n=\n0\n;\ni\n<\n10\n;\ni\n++\n)\n{\nfor\n(\nj\n=\n0\n;\nj\n<\n10\n;\nj\n++\n)\n{\ncudaMallocAsync\n(\n&\nptrs\n[\nj\n],\nsize\n[\nj\n],\nstream\n);\n}\nkernel\n<<<\n...,\nstream\n>>>\n(\nptrs\n,...);\nfor\n(\nj\n=\n0\n;\nj\n<\n10\n;\nj\n++\n)\n{\ncudaFreeAsync\n(\nptrs\n[\nj\n],\nstream\n);\n}\n}\n// Process does not need as much memory for the next phase.\n// Synchronize so that the trim operation will know that the allocations are no\n// longer in use.\ncudaStreamSynchronize\n(\nstream\n);\ncudaMemPoolTrimTo\n(\nmempool\n,\n0\n);\n// Some other process/allocation mechanism can now use the physical memory\n// released by the trimming operation.\n15.8.\nResource Usage Statistics\nï\nIn CUDA 11.3, the pool attributes\ncudaMemPoolAttrReservedMemCurrent\n,\ncudaMemPoolAttrReservedMemHigh\n,\ncudaMemPoolAttrUsedMemCurrent\n, and\ncudaMemPoolAttrUsedMemHigh\nwere added to query the memory usage of a pool.\nQuerying the\ncudaMemPoolAttrReservedMemCurrent\nattribute of a pool reports the current total physical GPU memory consumed by the pool. Querying the\ncudaMemPoolAttrUsedMemCurrent\nof a pool returns the total size of all of the memory allocated from the pool and not available for reuse.\nThe\ncudaMemPoolAttr*MemHigh\nattributes are watermarks recording the max value achieved by the respective\ncudaMemPoolAttr*MemCurrent\nattribute since last reset. They can be reset to the current value by using the\ncudaMemPoolSetAttribute\nAPI.\n// sample helper functions for getting the usage statistics in bulk\nstruct\nusageStatistics\n{\ncuuint64_t\nreserved\n;\ncuuint64_t\nreservedHigh\n;\ncuuint64_t\nused\n;\ncuuint64_t\nusedHigh\n;\n};\nvoid\ngetUsageStatistics\n(\ncudaMemoryPool_t\nmemPool\n,\nstruct\nusageStatistics\n*\nstatistics\n)\n{\ncudaMemPoolGetAttribute\n(\nmemPool\n,\ncudaMemPoolAttrReservedMemCurrent\n,\nstatistics\n->\nreserved\n);\ncudaMemPoolGetAttribute\n(\nmemPool\n,\ncudaMemPoolAttrReservedMemHigh\n,\nstatistics\n->\nreservedHigh\n);\ncudaMemPoolGetAttribute\n(\nmemPool\n,\ncudaMemPoolAttrUsedMemCurrent\n,\nstatistics\n->\nused\n);\ncudaMemPoolGetAttribute\n(\nmemPool\n,\ncudaMemPoolAttrUsedMemHigh\n,\nstatistics\n->\nusedHigh\n);\n}\n// resetting the watermarks will make them take on the current value.\nvoid\nresetStatistics\n(\ncudaMemoryPool_t\nmemPool\n)\n{\ncuuint64_t\nvalue\n=\n0\n;\ncudaMemPoolSetAttribute\n(\nmemPool\n,\ncudaMemPoolAttrReservedMemHigh\n,\n&\nvalue\n);\ncudaMemPoolSetAttribute\n(\nmemPool\n,\ncudaMemPoolAttrUsedMemHigh\n,\n&\nvalue\n);\n}\n15.9.\nMemory Reuse Policies\nï\nIn order to service an allocation request, the driver attempts to reuse memory that was previously freed via\ncudaFreeAsync()\nbefore attempting to allocate more memory from the OS. For example, memory freed in a stream can immediately be reused for a subsequent allocation request in the same stream. Similarly, when a stream is synchronized with the CPU, the memory that was previously freed in that stream becomes available for reuse for an allocation in any stream.\nThe stream ordered allocator has a few controllable allocation policies. The pool attributes\ncudaMemPoolReuseFollowEventDependencies\n,\ncudaMemPoolReuseAllowOpportunistic\n, and\ncudaMemPoolReuseAllowInternalDependencies\ncontrol these policies. Upgrading to a newer CUDA driver may change, enhance, augment and/or reorder the reuse policies.\n15.9.1.\ncudaMemPoolReuseFollowEventDependencies\nï\nBefore allocating more physical GPU memory, the allocator examines dependency information established by CUDA events and tries to allocate from memory freed in another stream.\ncudaMallocAsync\n(\n&\nptr\n,\nsize\n,\noriginalStream\n);\nkernel\n<<<\n...,\noriginalStream\n>>>\n(\nptr\n,\n...);\ncudaFreeAsync\n(\nptr\n,\noriginalStream\n);\ncudaEventRecord\n(\nevent\n,\noriginalStream\n);\n// waiting on the event that captures the free in another stream\n// allows the allocator to reuse the memory to satisfy\n// a new allocation request in the other stream when\n// cudaMemPoolReuseFollowEventDependencies is enabled.\ncudaStreamWaitEvent\n(\notherStream\n,\nevent\n);\ncudaMallocAsync\n(\n&\nptr2\n,\nsize\n,\notherStream\n);\n15.9.2.\ncudaMemPoolReuseAllowOpportunistic\nï\nAccording to the\ncudaMemPoolReuseAllowOpportunistic\npolicy, the allocator examines freed allocations to see if the freeâs stream order semantic has been met (such as the stream has passed the point of execution indicated by the free). When this is disabled, the allocator will still reuse memory made available when a stream is synchronized with the CPU. Disabling this policy does not stop the\ncudaMemPoolReuseFollowEventDependencies\nfrom applying.\ncudaMallocAsync\n(\n&\nptr\n,\nsize\n,\noriginalStream\n);\nkernel\n<<<\n...,\noriginalStream\n>>>\n(\nptr\n,\n...);\ncudaFreeAsync\n(\nptr\n,\noriginalStream\n);\n// after some time, the kernel finishes running\nwait\n(\n10\n);\n// When cudaMemPoolReuseAllowOpportunistic is enabled this allocation request\n// can be fulfilled with the prior allocation based on the progress of originalStream.\ncudaMallocAsync\n(\n&\nptr2\n,\nsize\n,\notherStream\n);\n15.9.3.\ncudaMemPoolReuseAllowInternalDependencies\nï\nFailing to allocate and map more physical memory from the OS, the driver will look for memory whose availability depends on another streamâs pending progress. If such memory is found, the driver will insert the required dependency into the allocating stream and reuse the memory.\ncudaMallocAsync\n(\n&\nptr\n,\nsize\n,\noriginalStream\n);\nkernel\n<<<\n...,\noriginalStream\n>>>\n(\nptr\n,\n...);\ncudaFreeAsync\n(\nptr\n,\noriginalStream\n);\n// When cudaMemPoolReuseAllowInternalDependencies is enabled\n// and the driver fails to allocate more physical memory, the driver may\n// effectively perform a cudaStreamWaitEvent in the allocating stream\n// to make sure that future work in âotherStreamâ happens after the work\n// in the original stream that would be allowed to access the original allocation.\ncudaMallocAsync\n(\n&\nptr2\n,\nsize\n,\notherStream\n);\n15.9.4.\nDisabling Reuse Policies\nï\nWhile the controllable reuse policies improve memory reuse, users may want to disable them. Allowing opportunistic reuse (such as\ncudaMemPoolReuseAllowOpportunistic\n) introduces run to run variance in allocation patterns based on the interleaving of CPU and GPU execution. Internal dependency insertion (such as\ncudaMemPoolReuseAllowInternalDependencies\n) can serialize work in unexpected and potentially non-deterministic ways when the user would rather explicitly synchronize an event or stream on allocation failure.\n15.10.\nDevice Accessibility for Multi-GPU Support\nï\nJust like allocation accessibility controlled through the virtual memory management APIs, memory pool allocation accessibility does not follow\ncudaDeviceEnablePeerAccess\nor\ncuCtxEnablePeerAccess\n. Instead, the API\ncudaMemPoolSetAccess\nmodifies what devices can access allocations from a pool. By default, allocations are accessible from the device where the allocations are located. This access cannot be revoked. To enable access from other devices, the accessing device must be peer capable with the memory poolâs device; check with\ncudaDeviceCanAccessPeer\n. If the peer capability is not checked, the set access may fail with\ncudaErrorInvalidDevice\n. If no allocations had been made from the pool, the\ncudaMemPoolSetAccess\ncall may succeed even when the devices are not peer capable; in this case, the next allocation from the pool will fail.\nIt is worth noting that\ncudaMemPoolSetAccess\naffects all allocations from the memory pool, not just future ones. Also the accessibility reported by\ncudaMemPoolGetAccess\napplies to all allocations from the pool, not just future ones. It is recommended that the accessibility settings of a pool for a given GPU not be changed frequently; once a pool is made accessible from a given GPU, it should remain accessible from that GPU for the lifetime of the pool.\n// snippet showing usage of cudaMemPoolSetAccess:\ncudaError_t\nsetAccessOnDevice\n(\ncudaMemPool_t\nmemPool\n,\nint\nresidentDevice\n,\nint\naccessingDevice\n)\n{\ncudaMemAccessDesc\naccessDesc\n=\n{};\naccessDesc\n.\nlocation\n.\ntype\n=\ncudaMemLocationTypeDevice\n;\naccessDesc\n.\nlocation\n.\nid\n=\naccessingDevice\n;\naccessDesc\n.\nflags\n=\ncudaMemAccessFlagsProtReadWrite\n;\nint\ncanAccess\n=\n0\n;\ncudaError_t\nerror\n=\ncudaDeviceCanAccessPeer\n(\n&\ncanAccess\n,\naccessingDevice\n,\nresidentDevice\n);\nif\n(\nerror\n!=\ncudaSuccess\n)\n{\nreturn\nerror\n;\n}\nelse\nif\n(\ncanAccess\n==\n0\n)\n{\nreturn\ncudaErrorPeerAccessUnsupported\n;\n}\n// Make the address accessible\nreturn\ncudaMemPoolSetAccess\n(\nmemPool\n,\n&\naccessDesc\n,\n1\n);\n}\n15.11.\nIPC Memory Pools\nï\nIPC capable memory pools allow easy, efficient and secure sharing of GPU memory between processes. CUDAâs IPC memory pools provide the same security benefits as CUDAâs virtual memory management APIs.\nThere are two phases to sharing memory between processes with memory pools. The processes first need to share access to the pool, then share specific allocations from that pool. The first phase establishes and enforces security. The second phase coordinates what virtual addresses are used in each process and when mappings need to be valid in the importing process.\n15.11.1.\nCreating and Sharing IPC Memory Pools\nï\nSharing access to a pool involves retrieving an OS native handle to the pool (with the\ncudaMemPoolExportToShareableHandle()\nAPI), transferring the handle to the importing process using the usual OS native IPC mechanisms, and creating an imported memory pool (with the\ncudaMemPoolImportFromShareableHandle()\nAPI). For\ncudaMemPoolExportToShareableHandle\nto succeed, the memory pool had to be created with the requested handle type specified in the pool properties structure. Please reference samples for the appropriate IPC mechanisms to transfer the OS native handle between processes. The rest of the procedure can be found in the following code snippets.\n// in exporting process\n// create an exportable IPC capable pool on device 0\ncudaMemPoolProps\npoolProps\n=\n{\n};\npoolProps\n.\nallocType\n=\ncudaMemAllocationTypePinned\n;\npoolProps\n.\nlocation\n.\nid\n=\n0\n;\npoolProps\n.\nlocation\n.\ntype\n=\ncudaMemLocationTypeDevice\n;\n// Setting handleTypes to a non zero value will make the pool exportable (IPC capable)\npoolProps\n.\nhandleTypes\n=\nCU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR\n;\ncudaMemPoolCreate\n(\n&\nmemPool\n,\n&\npoolProps\n));\n// FD based handles are integer types\nint\nfdHandle\n=\n0\n;\n// Retrieve an OS native handle to the pool.\n// Note that a pointer to the handle memory is passed in here.\ncudaMemPoolExportToShareableHandle\n(\n&\nfdHandle\n,\nmemPool\n,\nCU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR\n,\n0\n);\n// The handle must be sent to the importing process with the appropriate\n// OS specific APIs.\n// in importing process\nint\nfdHandle\n;\n// The handle needs to be retrieved from the exporting process with the\n// appropriate OS specific APIs.\n// Create an imported pool from the shareable handle.\n// Note that the handle is passed by value here.\ncudaMemPoolImportFromShareableHandle\n(\n&\nimportedMemPool\n,\n(\nvoid\n*\n)\nfdHandle\n,\nCU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR\n,\n0\n);\n15.11.2.\nSet Access in the Importing Process\nï\nImported memory pools are initially only accessible from their resident device. The imported memory pool does not inherit any accessibility set by the exporting process. The importing process needs to enable access (with\ncudaMemPoolSetAccess\n) from any GPU it plans to access the memory from.\nIf the imported memory pool belongs to a non-visible device in the importing process, the user must use the\ncudaMemPoolSetAccess\nAPI to enable access from the GPUs the allocations will be used on.\n15.11.3.\nCreating and Sharing Allocations from an Exported Pool\nï\nOnce the pool has been shared, allocations made with\ncudaMallocAsync()\nfrom the pool in the exporting process can be shared with other processes that have imported the pool. Since the poolâs security policy is established and verified at the pool level, the OS does not need extra bookkeeping to provide security for specific pool allocations; In other words, the opaque\ncudaMemPoolPtrExportData\nrequired to import a pool allocation may be sent to the importing process using any mechanism.\nWhile allocations may be exported and even imported without synchronizing with the allocating stream in any way, the importing process must follow the same rules as the exporting process when accessing the allocation. Namely, access to the allocation must happen after the stream ordering of the allocation operation in the allocating stream. The two following code snippets show\ncudaMemPoolExportPointer()\nand\ncudaMemPoolImportPointer()\nsharing the allocation with an IPC event used to guarantee that the allocation isnât accessed in the importing process before the allocation is ready.\n// preparing an allocation in the exporting process\ncudaMemPoolPtrExportData\nexportData\n;\ncudaEvent_t\nreadyIpcEvent\n;\ncudaIpcEventHandle_t\nreadyIpcEventHandle\n;\n// ipc event for coordinating between processes\n// cudaEventInterprocess flag makes the event an ipc event\n// cudaEventDisableTiming  is set for performance reasons\ncudaEventCreate\n(\n&\nreadyIpcEvent\n,\ncudaEventDisableTiming\n|\ncudaEventInterprocess\n)\n// allocate from the exporting mem pool\ncudaMallocAsync\n(\n&\nptr\n,\nsize\n,\nexportMemPool\n,\nstream\n);\n// event for sharing when the allocation is ready.\ncudaEventRecord\n(\nreadyIpcEvent\n,\nstream\n);\ncudaMemPoolExportPointer\n(\n&\nexportData\n,\nptr\n);\ncudaIpcGetEventHandle\n(\n&\nreadyIpcEventHandle\n,\nreadyIpcEvent\n);\n// Share IPC event and pointer export data with the importing process using\n//  any mechanism. Here we copy the data into shared memory\nshmem\n->\nptrData\n=\nexportData\n;\nshmem\n->\nreadyIpcEventHandle\n=\nreadyIpcEventHandle\n;\n// signal consumers data is ready\n// Importing an allocation\ncudaMemPoolPtrExportData\n*\nimportData\n=\n&\nshmem\n->\nprtData\n;\ncudaEvent_t\nreadyIpcEvent\n;\ncudaIpcEventHandle_t\n*\nreadyIpcEventHandle\n=\n&\nshmem\n->\nreadyIpcEventHandle\n;\n// Need to retrieve the ipc event handle and the export data from the\n// exporting process using any mechanism.  Here we are using shmem and just\n// need synchronization to make sure the shared memory is filled in.\ncudaIpcOpenEventHandle\n(\n&\nreadyIpcEvent\n,\nreadyIpcEventHandle\n);\n// import the allocation. The operation does not block on the allocation being ready.\ncudaMemPoolImportPointer\n(\n&\nptr\n,\nimportedMemPool\n,\nimportData\n);\n// Wait for the prior stream operations in the allocating stream to complete before\n// using the allocation in the importing process.\ncudaStreamWaitEvent\n(\nstream\n,\nreadyIpcEvent\n);\nkernel\n<<<\n...,\nstream\n>>>\n(\nptr\n,\n...);\nWhen freeing the allocation, the allocation needs to be freed in the importing process before it is freed in the exporting process. The following code snippet demonstrates the use of CUDA IPC events to provide the required synchronization between the\ncudaFreeAsync\noperations in both processes. Access to the allocation from the importing process is obviously restricted by the free operation in the importing process side. It is worth noting that\ncudaFree\ncan be used to free the allocation in both processes and that other stream synchronization APIs may be used instead of CUDA IPC events.\n// The free must happen in importing process before the exporting process\nkernel\n<<<\n...,\nstream\n>>>\n(\nptr\n,\n...);\n// Last access in importing process\ncudaFreeAsync\n(\nptr\n,\nstream\n);\n// Access not allowed in the importing process after the free\ncudaIpcEventRecord\n(\nfinishedIpcEvent\n,\nstream\n);\n// Exporting process\n// The exporting process needs to coordinate its free with the stream order\n// of the importing processâs free.\ncudaStreamWaitEvent\n(\nstream\n,\nfinishedIpcEvent\n);\nkernel\n<<<\n...,\nstream\n>>>\n(\nptrInExportingProcess\n,\n...);\n// The free in the importing process doesnât stop the exporting process\n// from using the allocation.\ncudFreeAsync\n(\nptrInExportingProcess\n,\nstream\n);\n15.11.4.\nIPC Export Pool Limitations\nï\nIPC pools currently do not support releasing physical blocks back to the OS. As a result the\ncudaMemPoolTrimTo\nAPI acts as a no-op and the\ncudaMemPoolAttrReleaseThreshold\neffectively gets ignored. This behavior is controlled by the driver, not the runtime and may change in a future driver update.\n15.11.5.\nIPC Import Pool Limitations\nï\nAllocating from an import pool is not allowed; specifically, import pools cannot be set current and cannot be used in the\ncudaMallocFromPoolAsync\nAPI. As such, the allocation reuse policy attributes are meaningless for these pools.\nIPC pools currently do not support releasing physical blocks back to the OS. As a result the\ncudaMemPoolTrimTo\nAPI acts as a no-op and the\ncudaMemPoolAttrReleaseThreshold\neffectively gets ignored.\nThe resource usage stat attribute queries only reflect the allocations imported into the process and the associated physical memory.\n15.12.\nSynchronization API Actions\nï\nOne of the optimizations that comes with the allocator being part of the CUDA driver is integration with the synchronize APIs. When the user requests that the CUDA driver synchronize, the driver waits for asynchronous work to complete. Before returning, the driver will determine what frees the synchronization guaranteed to be completed. These allocations are made available for allocation regardless of specified stream or disabled allocation policies. The driver also checks\ncudaMemPoolAttrReleaseThreshold\nhere and releases any excess physical memory that it can.\n15.13.\nAddendums\nï\n15.13.1.\ncudaMemcpyAsync Current Context/Device Sensitivity\nï\nIn the current CUDA driver, any async\nmemcpy\ninvolving memory from\ncudaMallocAsync\nshould be done using the specified streamâs context as the calling threadâs current context. This is not necessary for\ncudaMemcpyPeerAsync\n, as the device primary contexts specified in the API are referenced instead of the current context.\n15.13.2.\ncuPointerGetAttribute Query\nï\nInvoking\ncuPointerGetAttribute\non an allocation after invoking\ncudaFreeAsync\non it results in undefined behavior. Specifically, it does not matter if an allocation is still accessible from a given stream: the behavior is still undefined.\n15.13.3.\ncuGraphAddMemsetNode\nï\ncuGraphAddMemsetNode\ndoes not work with memory allocated via the stream ordered allocator. However, memsets of the allocations can be stream captured.\n15.13.4.\nPointer Attributes\nï\nThe\ncuPointerGetAttributes\nquery works on stream ordered allocations. Since stream ordered allocations are not context associated, querying\nCU_POINTER_ATTRIBUTE_CONTEXT\nwill succeed but return NULL in\n*data\n. The attribute\nCU_POINTER_ATTRIBUTE_DEVICE_ORDINAL\ncan be used to determine the location of the allocation: this can be useful when selecting a context for making p2h2p copies using\ncudaMemcpyPeerAsync\n. The attribute\nCU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE\nwas added in CUDA 11.3 and can be useful for debugging and for confirming which pool an allocation comes from before doing IPC.\n15.13.5.\nCPU Virtual Memory\nï\nWhen using CUDA stream-ordered memory allocator APIs, avoid setting VRAM limitations with âulimit -vâ as this is not supported.\n16.\nGraph Memory Nodes\nï\n16.1.\nIntroduction\nï\nGraph memory nodes allow graphs to create and own memory allocations. Graph memory nodes have GPU ordered lifetime semantics, which dictate when memory is allowed to be accessed on the device. These GPU ordered lifetime semantics enable driver-managed memory reuse, and match those of the stream ordered allocation APIs\ncudaMallocAsync\nand\ncudaFreeAsync\n, which may be captured when creating a graph.\nGraph allocations have fixed addresses over the life of a graph including repeated instantiations and launches. This allows the memory to be directly referenced by other operations within the graph without the need of a graph update, even when CUDA changes the backing physical memory. Within a graph, allocations whose graph ordered lifetimes do not overlap may use the same underlying physical memory.\nCUDA may reuse the same physical memory for allocations across multiple graphs, aliasing virtual address mappings according to the GPU ordered lifetime semantics. For example when different graphs are launched into the same stream, CUDA may virtually alias the same physical memory to satisfy the needs of allocations which have single-graph lifetimes.\n16.2.\nSupport and Compatibility\nï\nGraph memory nodes require an 11.4 capable CUDA driver and support for the stream ordered allocator on the GPU. The following snippet shows how to check for support on a given device.\nint\ndriverVersion\n=\n0\n;\nint\ndeviceSupportsMemoryPools\n=\n0\n;\nint\ndeviceSupportsMemoryNodes\n=\n0\n;\ncudaDriverGetVersion\n(\n&\ndriverVersion\n);\nif\n(\ndriverVersion\n>=\n11020\n)\n{\n// avoid invalid value error in cudaDeviceGetAttribute\ncudaDeviceGetAttribute\n(\n&\ndeviceSupportsMemoryPools\n,\ncudaDevAttrMemoryPoolsSupported\n,\ndevice\n);\n}\ndeviceSupportsMemoryNodes\n=\n(\ndriverVersion\n>=\n11040\n)\n&&\n(\ndeviceSupportsMemoryPools\n!=\n0\n);\nDoing the attribute query inside the driver version check avoids an invalid value return code on 11.0 and 11.1 drivers. Be aware that the compute sanitizer emits warnings when it detects CUDA returning error codes, and a version check before reading the attribute will avoid this. Graph memory nodes are only supported on driver versions 11.4 and newer.\n16.3.\nAPI Fundamentals\nï\nGraph memory nodes are graph nodes representing either memory allocation or free actions. As a shorthand, nodes that allocate memory are called allocation nodes. Likewise, nodes that free memory are called free nodes. Allocations created by allocation nodes are called graph allocations. CUDA assigns virtual addresses for the graph allocation at node creation time. While these virtual addresses are fixed for the lifetime of the allocation node, the allocation contents are not persistent past the freeing operation and may be overwritten by accesses referring to a different allocation.\nGraph allocations are considered recreated every time a graph runs. A graph allocationâs lifetime, which differs from the nodeâs lifetime, begins when GPU execution reaches the allocating graph node and ends when one of the following occurs:\nGPU execution reaches the freeing graph node\nGPU execution reaches the freeing\ncudaFreeAsync()\nstream call\nimmediately upon the freeing call to\ncudaFree()\nNote\nGraph destruction does not automatically free any live graph-allocated memory, even though it ends the lifetime of the allocation node. The allocation must subsequently be freed in another graph, or using\ncudaFreeAsync()\n/cudaFree()\n.\nJust like other\nGraph Structure\n, graph memory nodes are ordered within a graph by dependency edges. A program must guarantee that operations accessing graph memory:\nare ordered after the allocation node\nare ordered before the operation freeing the memory\nGraph allocation lifetimes begin and usually end according to GPU execution (as opposed to API invocation). GPU ordering is the order that work runs on the GPU as opposed to the order that the work is enqueued or described. Thus, graph allocations are considered âGPU ordered.â\n16.3.1.\nGraph Node APIs\nï\nGraph memory nodes may be explicitly created with the memory node creation APIs,\ncudaGraphAddMemAllocNode\nand\ncudaGraphAddMemFreeNode\n. The address allocated by\ncudaGraphAddMemAllocNode\nis returned to the user in the\ndptr\nfield of the passed\nCUDA_MEM_ALLOC_NODE_PARAMS\nstructure. All operations using graph allocations inside the allocating graph must be ordered after the allocating node. Similarly, any free nodes must be ordered after all uses of the allocation within the graph.\ncudaGraphAddMemFreeNode\ncreates free nodes.\nIn the following figure, there is an example graph with an alloc and a free node. Kernel nodes\na\n,\nb\n, and\nc\nare ordered after the allocation node and before the free node such that the kernels can access the allocation. Kernel node\ne\nis not ordered after the alloc node and therefore cannot safely access the memory. Kernel node\nd\nis not ordered before the free node, therefore it cannot safely access the memory.\nFigure 32\nKernel Nodes\nï\nThe following code snippet establishes the graph in this figure:\n// Create the graph - it starts out empty\ncudaGraphCreate(&graph, 0);\n// parameters for a basic allocation\ncudaMemAllocNodeParams params = {};\nparams.poolProps.allocType = cudaMemAllocationTypePinned;\nparams.poolProps.location.type = cudaMemLocationTypeDevice;\n// specify device 0 as the resident device\nparams.poolProps.location.id = 0;\nparams.bytesize = size;\ncudaGraphAddMemAllocNode(&allocNode, graph, NULL, 0, &params);\nnodeParams->kernelParams[0] = params.dptr;\ncudaGraphAddKernelNode(&a, graph, &allocNode, 1, &nodeParams);\ncudaGraphAddKernelNode(&b, graph, &a, 1, &nodeParams);\ncudaGraphAddKernelNode(&c, graph, &a, 1, &nodeParams);\ncudaGraphNode_t dependencies[2];\n// kernel nodes b and c are using the graph allocation, so the freeing node must depend on them.  Since the dependency of node b on node a establishes an indirect dependency, the free node does not need to explicitly depend on node a.\ndependencies[0] = b;\ndependencies[1] = c;\ncudaGraphAddMemFreeNode(&freeNode, graph, dependencies, 2, params.dptr);\n// free node does not depend on kernel node d, so it must not access the freed graph allocation.\ncudaGraphAddKernelNode(&d, graph, &c, 1, &nodeParams);\n// node e does not depend on the allocation node, so it must not access the allocation.  This would be true even if the freeNode depended on kernel node e.\ncudaGraphAddKernelNode(&e, graph, NULL, 0, &nodeParams);\n16.3.2.\nStream Capture\nï\nGraph memory nodes can be created by capturing the corresponding stream ordered allocation and free calls\ncudaMallocAsync\nand\ncudaFreeAsync\n. In this case, the virtual addresses returned by the captured allocation API can be used by other operations inside the graph. Since the stream ordered dependencies will be captured into the graph, the ordering requirements of the stream ordered allocation APIs guarantee that the graph memory nodes will be properly ordered with respect to the captured stream operations (for correctly written stream code).\nIgnoring kernel nodes\nd\nand\ne\n, for clarity, the following code snippet shows how to use stream capture to create the graph from the previous figure:\ncudaMallocAsync(&dptr, size, stream1);\nkernel_A<<< ..., stream1 >>>(dptr, ...);\n// Fork into stream2\ncudaEventRecord(event1, stream1);\ncudaStreamWaitEvent(stream2, event1);\nkernel_B<<< ..., stream1 >>>(dptr, ...);\n// event dependencies translated into graph dependencies, so the kernel node created by the capture of kernel C will depend on the allocation node created by capturing the cudaMallocAsync call.\nkernel_C<<< ..., stream2 >>>(dptr, ...);\n// Join stream2 back to origin stream (stream1)\ncudaEventRecord(event2, stream2);\ncudaStreamWaitEvent(stream1, event2);\n// Free depends on all work accessing the memory.\ncudaFreeAsync(dptr, stream1);\n// End capture in the origin stream\ncudaStreamEndCapture(stream1, &graph);\n16.3.3.\nAccessing and Freeing Graph Memory Outside of the Allocating Graph\nï\nGraph allocations do not have to be freed by the allocating graph. When a graph does not free an allocation, that allocation persists beyond the execution of the graph and can be accessed by subsequent CUDA operations. These allocations may be accessed in another graph or directly using a stream operation as long as the accessing operation is ordered after the allocation through CUDA events and other stream ordering mechanisms. An allocation may subsequently be freed by regular calls to\ncudaFree\n,\ncudaFreeAsync\n, or by the launch of another graph with a corresponding free node, or a subsequent launch of the allocating graph (if it was instantiated with the\ncudaGraphInstantiateFlagAutoFreeOnLaunch\nflag). It is illegal to access memory after it has been freed - the free operation must be ordered after all operations accessing the memory using graph dependencies, CUDA events, and other stream ordering mechanisms.\nNote\nBecause graph allocations may share underlying physical memory with each other, the\nVirtual Aliasing Support\nrules relating to consistency and coherency must be considered. Simply put, the free operation must be ordered after the full device operation (for example, compute kernel / memcpy) completes. Specifically, out of band synchronization - for example a handshake through memory as part of a compute kernel that accesses the graph-allocated memory - is not sufficient for providing ordering guarantees between the memory writes to graph memory and the free operation of that graph memory.\nThe following code snippets demonstrate accessing graph allocations outside of the allocating graph with ordering properly established by: using a single stream, using events between streams, and using events baked into the allocating and freeing graph.\nOrdering established by using a single stream:\nvoid *dptr;\ncudaGraphAddMemAllocNode(&allocNode, allocGraph, NULL, 0, &params);\ndptr = params.dptr;\ncudaGraphInstantiate(&allocGraphExec, allocGraph, NULL, NULL, 0);\ncudaGraphLaunch(allocGraphExec, stream);\nkernel<<< â¦, stream >>>(dptr, â¦);\ncudaFreeAsync(dptr, stream);\nOrdering established by recording and waiting on CUDA events:\nvoid *dptr;\n// Contents of allocating graph\ncudaGraphAddMemAllocNode(&allocNode, allocGraph, NULL, 0, &params);\ndptr = params.dptr;\n// contents of consuming/freeing graph\nnodeParams->kernelParams[0] = params.dptr;\ncudaGraphAddKernelNode(&a, graph, NULL, 0, &nodeParams);\ncudaGraphAddMemFreeNode(&freeNode, freeGraph, &a, 1, dptr);\ncudaGraphInstantiate(&allocGraphExec, allocGraph, NULL, NULL, 0);\ncudaGraphInstantiate(&freeGraphExec, freeGraph, NULL, NULL, 0);\ncudaGraphLaunch(allocGraphExec, allocStream);\n// establish the dependency of stream2 on the allocation node\n// note: the dependency could also have been established with a stream synchronize operation\ncudaEventRecord(allocEvent, allocStream)\ncudaStreamWaitEvent(stream2, allocEvent);\nkernel<<< â¦, stream2 >>> (dptr, â¦);\n// establish the dependency between the stream 3 and the allocation use\ncudaStreamRecordEvent(streamUseDoneEvent, stream2);\ncudaStreamWaitEvent(stream3, streamUseDoneEvent);\n// it is now safe to launch the freeing graph, which may also access the memory\ncudaGraphLaunch(freeGraphExec, stream3);\nOrdering established by using graph external event nodes:\nvoid *dptr;\ncudaEvent_t allocEvent; // event indicating when the allocation will be ready for use.\ncudaEvent_t streamUseDoneEvent; // event indicating when the stream operations are done with the allocation.\n// Contents of allocating graph with event record node\ncudaGraphAddMemAllocNode(&allocNode, allocGraph, NULL, 0, &params);\ndptr = params.dptr;\n// note: this event record node depends on the alloc node\ncudaGraphAddEventRecordNode(&recordNode, allocGraph, &allocNode, 1, allocEvent);\ncudaGraphInstantiate(&allocGraphExec, allocGraph, NULL, NULL, 0);\n// contents of consuming/freeing graph with event wait nodes\ncudaGraphAddEventWaitNode(&streamUseDoneEventNode, waitAndFreeGraph, NULL, 0, streamUseDoneEvent);\ncudaGraphAddEventWaitNode(&allocReadyEventNode, waitAndFreeGraph, NULL, 0, allocEvent);\nnodeParams->kernelParams[0] = params.dptr;\n// The allocReadyEventNode provides ordering with the alloc node for use in a consuming graph.\ncudaGraphAddKernelNode(&kernelNode, waitAndFreeGraph, &allocReadyEventNode, 1, &nodeParams);\n// The free node has to be ordered after both external and internal users.\n// Thus the node must depend on both the kernelNode and the\n// streamUseDoneEventNode.\ndependencies[0] = kernelNode;\ndependencies[1] = streamUseDoneEventNode;\ncudaGraphAddMemFreeNode(&freeNode, waitAndFreeGraph, &dependencies, 2, dptr);\ncudaGraphInstantiate(&waitAndFreeGraphExec, waitAndFreeGraph, NULL, NULL, 0);\ncudaGraphLaunch(allocGraphExec, allocStream);\n// establish the dependency of stream2 on the event node satisfies the ordering requirement\ncudaStreamWaitEvent(stream2, allocEvent);\nkernel<<< â¦, stream2 >>> (dptr, â¦);\ncudaStreamRecordEvent(streamUseDoneEvent, stream2);\n// the event wait node in the waitAndFreeGraphExec establishes the dependency on the âreadyForFreeEventâ that is needed to prevent the kernel running in stream two from accessing the allocation after the free node in execution order.\ncudaGraphLaunch(waitAndFreeGraphExec, stream3);\n16.3.4.\ncudaGraphInstantiateFlagAutoFreeOnLaunch\nï\nUnder normal circumstances, CUDA will prevent a graph from being relaunched if it has unfreed memory allocations because multiple allocations at the same address will leak memory. Instantiating a graph with the\ncudaGraphInstantiateFlagAutoFreeOnLaunch\nflag allows the graph to be relaunched while it still has unfreed allocations. In this case, the launch automatically inserts an asynchronous free of the unfreed allocations.\nAuto free on launch is useful for single-producer multiple-consumer algorithms. At each iteration, a producer graph creates several allocations, and, depending on runtime conditions, a varying set of consumers accesses those allocations. This type of variable execution sequence means that consumers cannot free the allocations because a subsequent consumer may require access. Auto free on launch means that the launch loop does not need to track the producerâs allocations - instead, that information remains isolated to the producerâs creation and destruction logic. In general, auto free on launch simplifies an algorithm which would otherwise need to free all the allocations owned by a graph before each relaunch.\nNote\nThe\ncudaGraphInstantiateFlagAutoFreeOnLaunch\nflag does not change the behavior of graph destruction. The application must explicitly free the unfreed memory in order to avoid memory leaks, even for graphs instantiated with the flag.\nThe following code shows the use of\ncudaGraphInstantiateFlagAutoFreeOnLaunch\nto simplify a single-producer / multiple-consumer algorithm:\n// Create producer graph which allocates memory and populates it with data\ncudaStreamBeginCapture\n(\ncudaStreamPerThread\n,\ncudaStreamCaptureModeGlobal\n);\ncudaMallocAsync\n(\n&\ndata1\n,\nblocks\n*\nthreads\n,\ncudaStreamPerThread\n);\ncudaMallocAsync\n(\n&\ndata2\n,\nblocks\n*\nthreads\n,\ncudaStreamPerThread\n);\nproduce\n<<<\nblocks\n,\nthreads\n,\n0\n,\ncudaStreamPerThread\n>>>\n(\ndata1\n,\ndata2\n);\n...\ncudaStreamEndCapture\n(\ncudaStreamPerThread\n,\n&\ngraph\n);\ncudaGraphInstantiateWithFlags\n(\n&\nproducer\n,\ngraph\n,\ncudaGraphInstantiateFlagAutoFreeOnLaunch\n);\ncudaGraphDestroy\n(\ngraph\n);\n// Create first consumer graph by capturing an asynchronous library call\ncudaStreamBeginCapture\n(\ncudaStreamPerThread\n,\ncudaStreamCaptureModeGlobal\n);\nconsumerFromLibrary\n(\ndata1\n,\ncudaStreamPerThread\n);\ncudaStreamEndCapture\n(\ncudaStreamPerThread\n,\n&\ngraph\n);\ncudaGraphInstantiateWithFlags\n(\n&\nconsumer1\n,\ngraph\n,\n0\n);\n//regular instantiation\ncudaGraphDestroy\n(\ngraph\n);\n// Create second consumer graph\ncudaStreamBeginCapture\n(\ncudaStreamPerThread\n,\ncudaStreamCaptureModeGlobal\n);\nconsume2\n<<<\nblocks\n,\nthreads\n,\n0\n,\ncudaStreamPerThread\n>>>\n(\ndata2\n);\n...\ncudaStreamEndCapture\n(\ncudaStreamPerThread\n,\n&\ngraph\n);\ncudaGraphInstantiateWithFlags\n(\n&\nconsumer2\n,\ngraph\n,\n0\n);\ncudaGraphDestroy\n(\ngraph\n);\n// Launch in a loop\nbool\nlaunchConsumer2\n=\nfalse\n;\ndo\n{\ncudaGraphLaunch\n(\nproducer\n,\nmyStream\n);\ncudaGraphLaunch\n(\nconsumer1\n,\nmyStream\n);\nif\n(\nlaunchConsumer2\n)\n{\ncudaGraphLaunch\n(\nconsumer2\n,\nmyStream\n);\n}\n}\nwhile\n(\ndetermineAction\n(\n&\nlaunchConsumer2\n));\ncudaFreeAsync\n(\ndata1\n,\nmyStream\n);\ncudaFreeAsync\n(\ndata2\n,\nmyStream\n);\ncudaGraphExecDestroy\n(\nproducer\n);\ncudaGraphExecDestroy\n(\nconsumer1\n);\ncudaGraphExecDestroy\n(\nconsumer2\n);\n16.4.\nOptimized Memory Reuse\nï\nCUDA reuses memory in two ways:\nVirtual and physical memory reuse within a graph is based on virtual address assignment, like in the stream ordered allocator.\nPhysical memory reuse between graphs is done with virtual aliasing: different graphs can map the same physical memory to their unique virtual addresses.\n16.4.1.\nAddress Reuse within a Graph\nï\nCUDA may reuse memory within a graph by assigning the same virtual address ranges to different allocations whose lifetimes do not overlap. Since virtual addresses may be reused, pointers to different allocations with disjoint lifetimes are not guaranteed to be unique.\nThe following figure shows adding a new allocation node (2) that can reuse the address freed by a dependent node (1).\nFigure 33\nAdding New Alloc Node 2\nï\nThe following figure shows adding a new alloc node (4). The new alloc node is not dependent on the free node (2) so cannot reuse the address from the associated alloc node (2). If the alloc node (2) used the address freed by free node (1), the new alloc node 3 would need a new address.\nFigure 34\nAdding New Alloc Node 3\nï\n16.4.2.\nPhysical Memory Management and Sharing\nï\nCUDA is responsible for mapping physical memory to the virtual address before the allocating node is reached in GPU order. As an optimization for memory footprint and mapping overhead, multiple graphs may use the same physical memory for distinct allocations if they will not run simultaneously; however, physical pages cannot be reused if they are bound to more than one executing graph at the same time, or to a graph allocation which remains unfreed.\nCUDA may update physical memory mappings at any time during graph instantiation, launch, or execution. CUDA may also introduce synchronization between future graph launches in order to prevent live graph allocations from referring to the same physical memory. As for any allocate-free-allocate pattern, if a program accesses a pointer outside of an allocationâs lifetime, the erroneous access may silently read or write live data owned by another allocation (even if the virtual address of the allocation is unique). Use of compute sanitizer tools can catch this error.\nThe following figure shows graphs sequentially launched in the same stream. In this example, each graph frees all the memory it allocates. Since the graphs in the same stream never run concurrently, CUDA can and should use the same physical memory to satisfy all the allocations.\nFigure 35\nSequentially Launched Graphs\nï\n16.5.\nPerformance Considerations\nï\nWhen multiple graphs are launched into the same stream, CUDA attempts to allocate the same physical memory to them because the execution of these graphs cannot overlap. Physical mappings for a graph are retained between launches as an optimization to avoid the cost of remapping. If, at a later time, one of the graphs is launched such that its execution may overlap with the others (for example if it is launched into a different stream) then CUDA must perform some remapping because concurrent graphs require distinct memory to avoid data corruption.\nIn general, remapping of graph memory in CUDA is likely caused by these operations:\nChanging the stream into which a graph is launched\nA trim operation on the graph memory pool, which explicitly frees unused memory (discussed in\nPhysical Memory Footprint\n)\nRelaunching a graph while an unfreed allocation from another graph is mapped to the same memory will cause a remap of memory before relaunch\nRemapping must happen in execution order, but after any previous execution of that graph is complete (otherwise memory that is still in use could be unmapped). Due to this ordering dependency, as well as because mapping operations are OS calls, mapping operations can be relatively expensive. Applications can avoid this cost by launching graphs containing allocation memory nodes consistently into the same stream.\n16.5.1.\nFirst Launch / cudaGraphUpload\nï\nPhysical memory cannot be allocated or mapped during graph instantiation because the stream in which the graph will execute is unknown. Mapping is done instead during graph launch. Calling\ncudaGraphUpload\ncan separate out the cost of allocation from the launch by performing all mappings for that graph immediately and associating the graph with the upload stream. If the graph is then launched into the same stream, it will launch without any additional remapping.\nUsing different streams for graph upload and graph launch behaves similarly to switching streams, likely resulting in remap operations. In addition, unrelated memory pool management is permitted to pull memory from an idle stream, which could negate the impact of the uploads.\n16.6.\nPhysical Memory Footprint\nï\nThe pool-management behavior of asynchronous allocation means that destroying a graph which contains memory nodes (even if their allocations are free) will not immediately return physical memory to the OS for use by other processes. To explicitly release memory back to the OS, an application should use the\ncudaDeviceGraphMemTrim\nAPI.\ncudaDeviceGraphMemTrim\nwill unmap and release any physical memory reserved by graph memory nodes that is not actively in use. Allocations that have not been freed and graphs that are scheduled or running are considered to be actively using the physical memory and will not be impacted. Use of the trim API will make physical memory available to other allocation APIs and other applications or processes, but will cause CUDA to reallocate and remap memory when the trimmed graphs are next launched. Note that\ncudaDeviceGraphMemTrim\noperates on a different pool from\ncudaMemPoolTrimTo()\n. The graph memory pool is not exposed to the steam ordered memory allocator. CUDA allows applications to query their graph memory footprint through the\ncudaDeviceGetGraphMemAttribute\nAPI. Querying the attribute\ncudaGraphMemAttrReservedMemCurrent\nreturns the amount of physical memory reserved by the driver for graph allocations in the current process. Querying\ncudaGraphMemAttrUsedMemCurrent\nreturns the amount of physical memory currently mapped by at least one graph. Either of these attributes can be used to track when new physical memory is acquired by CUDA for the sake of an allocating graph. Both of these attributes are useful for examining how much memory is saved by the sharing mechanism.\n16.7.\nPeer Access\nï\nGraph allocations can be configured for access from multiple GPUs, in which case CUDA will map the allocations onto the peer GPUs as required. CUDA allows graph allocations requiring different mappings to reuse the same virtual address. When this occurs, the address range is mapped onto all GPUs required by the different allocations. This means an allocation may sometimes allow more peer access than was requested during its creation; however, relying on these extra mappings is still an error.\n16.7.1.\nPeer Access with Graph Node APIs\nï\nThe\ncudaGraphAddMemAllocNode\nAPI accepts mapping requests in the\naccessDescs\narray field of the node parameters structures. The\npoolProps.location\nembedded structure specifies the resident device for the allocation. Access from the allocating GPU is assumed to be needed, thus the application does not need to specify an entry for the resident device in the\naccessDescs\narray.\ncudaMemAllocNodeParams params = {};\nparams.poolProps.allocType = cudaMemAllocationTypePinned;\nparams.poolProps.location.type = cudaMemLocationTypeDevice;\n// specify device 1 as the resident device\nparams.poolProps.location.id = 1;\nparams.bytesize = size;\n// allocate an allocation resident on device 1 accessible from device 1\ncudaGraphAddMemAllocNode(&allocNode, graph, NULL, 0, &params);\naccessDescs[2];\n// boilerplate for the access descs (only ReadWrite and Device access supported by the add node api)\naccessDescs[0].flags = cudaMemAccessFlagsProtReadWrite;\naccessDescs[0].location.type = cudaMemLocationTypeDevice;\naccessDescs[1].flags = cudaMemAccessFlagsProtReadWrite;\naccessDescs[1].location.type = cudaMemLocationTypeDevice;\n// access being requested for device 0 & 2.  Device 1 access requirement left implicit.\naccessDescs[0].location.id = 0;\naccessDescs[1].location.id = 2;\n// access request array has 2 entries.\nparams.accessDescCount = 2;\nparams.accessDescs = accessDescs;\n// allocate an allocation resident on device 1 accessible from devices 0, 1 and 2. (0 & 2 from the descriptors, 1 from it being the resident device).\ncudaGraphAddMemAllocNode(&allocNode, graph, NULL, 0, &params);\n16.7.2.\nPeer Access with Stream Capture\nï\nFor stream capture, the allocation node records the peer accessibility of the allocating pool at the time of the capture. Altering the peer accessibility of the allocating pool after a\ncudaMallocFromPoolAsync\ncall is captured does not affect the mappings that the graph will make for the allocation.\n// boilerplate for the access descs (only ReadWrite and Device access supported by the add node api)\naccessDesc.flags = cudaMemAccessFlagsProtReadWrite;\naccessDesc.location.type = cudaMemLocationTypeDevice;\naccessDesc.location.id = 1;\n// let memPool be resident and accessible on device 0\ncudaStreamBeginCapture(stream);\ncudaMallocAsync(&dptr1, size, memPool, stream);\ncudaStreamEndCapture(stream, &graph1);\ncudaMemPoolSetAccess(memPool, &accessDesc, 1);\ncudaStreamBeginCapture(stream);\ncudaMallocAsync(&dptr2, size, memPool, stream);\ncudaStreamEndCapture(stream, &graph2);\n//The graph node allocating dptr1 would only have the device 0 accessibility even though memPool now has device 1 accessibility.\n//The graph node allocating dptr2 will have device 0 and device 1 accessibility, since that was the pool accessibility at the time of the cudaMallocAsync call.\n16.8.\nMemory Nodes in Child Graphs\nï\nCUDA 12.9 introduces the ability to move child graph ownership to a parent graph. Child graphs which are moved to the parent are allowed to contain memory allocation and free nodes. This allows a child graph containing allocation or free nodes to be independently constructed prior to its addition in a parent graph.\nThe following restrictions apply to child graphs after they have been moved:\nCannot be independently instantiated or destroyed.\nCannot be added as a child graph of a separate parent graph.\nCannot be used as an argument to cuGraphExecUpdate.\nCannot have additional memory allocation or free nodes added.\n// Create the child graph\ncudaGraphCreate(&child, 0);\n// parameters for a basic allocation\ncudaMemAllocNodeParams params = {};\nparams.poolProps.allocType = cudaMemAllocationTypePinned;\nparams.poolProps.location.type = cudaMemLocationTypeDevice;\n// specify device 0 as the resident device\nparams.poolProps.location.id = 0;\nparams.bytesize = size;\ncudaGraphAddMemAllocNode(&allocNode, graph, NULL, 0, &params);\n// Additional nodes using the allocation could be added here\ncudaGraphAddMemFreeNode(&freeNode, graph, &allocNode, 1, params.dptr);\n// Create the parent graph\ncudaGraphCreate(&parent, 0);\n// Move the child graph to the parent graph\ncudaGraphNodeParams childNodeParams = { cudaGraphNodeTypeGraph };\nchildNodeParams.graph.graph = child;\nchildNodeParams.graph.ownership = cudaGraphChildGraphOwnershipMove;\ncudaGraphAddNode(&parentNode, parent, NULL, NULL, 0, &childNodeParams);\n17.\nMathematical Functions\nï\nThe reference manual lists, along with their description, all the functions of the C/C++ standard library mathematical functions that are supported in device code, as well as all intrinsic functions (that are only supported in device code).\nThis section provides accuracy information for some of these functions when applicable. It uses ULP for quantification. For further information on the definition of the Unit in the Last Place (ULP), please see Jean-Michel Mullerâs paper\nOn the definition of ulp(x)\n, RR-5504, LIP RR-2005-09, INRIA, LIP. 2005, pp.16 at\nhttps://hal.inria.fr/inria-00070503/document\n.\nMathematical functions supported in device code do not set the global\nerrno\nvariable, nor report any floating-point exceptions to indicate errors; thus, if error diagnostic mechanisms are required, the user should implement additional screening for inputs and outputs of the functions. The user is responsible for the validity of pointer arguments. The user must not pass uninitialized parameters to the Mathematical functions as this may result in undefined behavior: functions are inlined in the user program and thus are subject to compiler optimizations.\n17.1.\nStandard Functions\nï\nThe functions from this section can be used in both host and device code.\nThis section specifies the error bounds of each function when executed on the device and also when executed on the host in the case where the host does not supply the function.\nThe error bounds are generated from extensive but not exhaustive tests, so they are not guaranteed bounds.\nSingle-Precision Floating-Point Functions\nAddition and multiplication are IEEE-compliant, so have a maximum error of 0.5 ulp.\nThe recommended way to round a single-precision floating-point operand to an integer, with the result being a single-precision floating-point number is\nrintf()\n, not\nroundf()\n. The reason is that\nroundf()\nmaps to a 4-instruction sequence on the device, whereas\nrintf()\nmaps to a single instruction.\ntruncf()\n,\nceilf()\n, and\nfloorf()\neach map to a single instruction as well.\nTable 17\nSingle-Precision Mathematical Standard Library Functions with Maximum ULP Error. The maximum error is stated as the absolute value of the difference in ulps between the result returned by the CUDA library function and a correctly rounded single-precision result obtained according to the round-to-nearest ties-to-even rounding mode.\nï\nFunction\nMaximum ulp error\nx+y\n0 (IEEE-754 round-to-nearest-even)\nx*y\n0 (IEEE-754 round-to-nearest-even)\nx/y\n0 for compute capability\n\\(\\ge 2\\)\nwhen compiled with\n-prec-div=true\n2 (full range), otherwise\n1/x\n0 for compute capability\n\\(\\ge 2\\)\nwhen compiled with\n-prec-div=true\n1 (full range), otherwise\nrsqrtf(x)\n1/sqrtf(x)\n2 (full range)\nApplies to\n1/sqrtf(x)\nonly when it is converted to\nrsqrtf(x)\nby the compiler.\nsqrtf(x)\n0 when compiled with\n-prec-sqrt=true\nOtherwise 1 for compute capability\n\\(\\ge 5.2\\)\nand 3 for older architectures\ncbrtf(x)\n1 (full range)\nrcbrtf(x)\n1 (full range)\nhypotf(x,y)\n3 (full range)\nrhypotf(x,y)\n2 (full range)\nnorm3df(x,y,z)\n3 (full range)\nrnorm3df(x,y,z)\n2 (full range)\nnorm4df(x,y,z,t)\n3 (full range)\nrnorm4df(x,y,z,t)\n2 (full range)\nnormf(dim,arr)\nAn error bound cannot be provided because a fast algorithm is used with accuracy loss due to round-off. .\nrnormf(dim,arr)\nAn error bound cannot be provided because a fast algorithm is used with accuracy loss due to round-off. .\nexpf(x)\n2 (full range)\nexp2f(x)\n2 (full range)\nexp10f(x)\n2 (full range)\nexpm1f(x)\n1 (full range)\nlogf(x)\n1 (full range)\nlog2f(x)\n1 (full range)\nlog10f(x)\n2 (full range)\nlog1pf(x)\n1 (full range)\nsinf(x)\n2 (full range)\ncosf(x)\n2 (full range)\ntanf(x)\n4 (full range)\nsincosf(x,sptr,cptr)\n2 (full range)\nsinpif(x)\n1 (full range)\ncospif(x)\n1 (full range)\nsincospif(x,sptr,cptr)\n1 (full range)\nasinf(x)\n2 (full range)\nacosf(x)\n2 (full range)\natanf(x)\n2 (full range)\natan2f(y,x)\n3 (full range)\nsinhf(x)\n3 (full range)\ncoshf(x)\n2 (full range)\ntanhf(x)\n2 (full range)\nasinhf(x)\n3 (full range)\nacoshf(x)\n4 (full range)\natanhf(x)\n3 (full range)\npowf(x,y)\n4 (full range)\nerff(x)\n2 (full range)\nerfcf(x)\n4 (full range)\nerfinvf(x)\n2 (full range)\nerfcinvf(x)\n4 (full range)\nerfcxf(x)\n4 (full range)\nnormcdff(x)\n5 (full range)\nnormcdfinvf(x)\n5 (full range)\nlgammaf(x)\n6 (outside interval -10.001 â¦ -2.264; larger inside)\ntgammaf(x)\n5 (full range)\nfmaf(x,y,z)\n0 (full range)\nfrexpf(x,exp)\n0 (full range)\nldexpf(x,exp)\n0 (full range)\nscalbnf(x,n)\n0 (full range)\nscalblnf(x,l)\n0 (full range)\nlogbf(x)\n0 (full range)\nilogbf(x)\n0 (full range)\nj0f(x)\n9 for |x| < 8\notherwise, the maximum absolute error is 2.2 x 10\n-6\nj1f(x)\n9 for |x| < 8\notherwise, the maximum absolute error is 2.2 x 10\n-6\njnf(n,x)\nFor n = 128, the maximum absolute error is 2.2 x 10\n-6\ny0f(x)\n9 for |x| < 8\notherwise, the maximum absolute error is 2.2 x 10\n-6\ny1f(x)\n9 for |x| < 8\notherwise, the maximum absolute error is 2.2 x 10\n-6\nynf(n,x)\nceil(2 + 2.5n) for |x| < n\notherwise, the maximum absolute error is 2.2 x 10\n-6\ncyl_bessel_i0f(x)\n6 (full range)\ncyl_bessel_i1f(x)\n6 (full range)\nfmodf(x,y)\n0 (full range)\nremainderf(x,y)\n0 (full range)\nremquof(x,y,iptr)\n0 (full range)\nmodff(x,iptr)\n0 (full range)\nfdimf(x,y)\n0 (full range)\ntruncf(x)\n0 (full range)\nroundf(x)\n0 (full range)\nrintf(x)\n0 (full range)\nnearbyintf(x)\n0 (full range)\nceilf(x)\n0 (full range)\nfloorf(x)\n0 (full range)\nlrintf(x)\n0 (full range)\nlroundf(x)\n0 (full range)\nllrintf(x)\n0 (full range)\nllroundf(x)\n0 (full range)\nDouble-Precision Floating-Point Functions\nThe recommended way to round a double-precision floating-point operand to an integer, with the result being a double-precision floating-point number is\nrint()\n, not\nround()\n. The reason is that\nround()\nmaps to a 5-instruction sequence on the device, whereas\nrint()\nmaps to a single instruction.\ntrunc()\n,\nceil()\n, and\nfloor()\neach map to a single instruction as well.\nTable 18\nDouble-Precision Mathematical Standard Library Functions with Maximum ULP Error. The maximum error is stated as the absolute value of the difference in ulps between the result returned by the CUDA library function and a correctly rounded double-precision result obtained according to the round-to-nearest ties-to-even rounding mode.\nï\nFunction\nMaximum ulp error\nx+y\n0 (IEEE-754 round-to-nearest-even)\nx*y\n0 (IEEE-754 round-to-nearest-even)\nx/y\n0 (IEEE-754 round-to-nearest-even)\n1/x\n0 (IEEE-754 round-to-nearest-even)\nsqrt(x)\n0 (IEEE-754 round-to-nearest-even)\nrsqrt(x)\n1 (full range)\ncbrt(x)\n1 (full range)\nrcbrt(x)\n1 (full range)\nhypot(x,y)\n2 (full range)\nrhypot(x,y)\n1 (full range)\nnorm3d(x,y,z)\n2 (full range)\nrnorm3d(x,y,z)\n1 (full range)\nnorm4d(x,y,z,t)\n2 (full range)\nrnorm4d(x,y,z,t)\n1 (full range)\nnorm(dim,arr)\nAn error bound cannot be provided because a fast algorithm is used with accuracy loss due to round-off.\nrnorm(dim,arr)\nAn error bound cannot be provided because a fast algorithm is used with accuracy loss due to round-off.\nexp(x)\n1 (full range)\nexp2(x)\n1 (full range)\nexp10(x)\n1 (full range)\nexpm1(x)\n1 (full range)\nlog(x)\n1 (full range)\nlog2(x)\n1 (full range)\nlog10(x)\n1 (full range)\nlog1p(x)\n1 (full range)\nsin(x)\n2 (full range)\ncos(x)\n2 (full range)\ntan(x)\n2 (full range)\nsincos(x,sptr,cptr)\n2 (full range)\nsinpi(x)\n2 (full range)\ncospi(x)\n2 (full range)\nsincospi(x,sptr,cptr)\n2 (full range)\nasin(x)\n2 (full range)\nacos(x)\n2 (full range)\natan(x)\n2 (full range)\natan2(y,x)\n2 (full range)\nsinh(x)\n2 (full range)\ncosh(x)\n1 (full range)\ntanh(x)\n1 (full range)\nasinh(x)\n3 (full range)\nacosh(x)\n3 (full range)\natanh(x)\n2 (full range)\npow(x,y)\n2 (full range)\nerf(x)\n2 (full range)\nerfc(x)\n5 (full range)\nerfinv(x)\n5 (full range)\nerfcinv(x)\n6 (full range)\nerfcx(x)\n4 (full range)\nnormcdf(x)\n5 (full range)\nnormcdfinv(x)\n8 (full range)\nlgamma(x)\n4 (outside interval -23.0001 â¦ -2.2637; larger inside)\ntgamma(x)\n10 (full range)\nfma(x,y,z)\n0 (IEEE-754 round-to-nearest-even)\nfrexp(x,exp)\n0 (full range)\nldexp(x,exp)\n0 (full range)\nscalbn(x,n)\n0 (full range)\nscalbln(x,l)\n0 (full range)\nlogb(x)\n0 (full range)\nilogb(x)\n0 (full range)\nj0(x)\n7 for |x| < 8\notherwise, the maximum absolute error is 5 x 10\n-12\nj1(x)\n7 for |x| < 8\notherwise, the maximum absolute error is 5 x 10\n-12\njn(n,x)\nFor n = 128, the maximum absolute error is 5 x 10\n-12\ny0(x)\n7 for |x| < 8\notherwise, the maximum absolute error is 5 x 10\n-12\ny1(x)\n7 for |x| < 8\notherwise, the maximum absolute error is 5 x 10\n-12\nyn(n,x)\nFor |x| > 1.5n, the maximum absolute error is 5 x 10\n-12\ncyl_bessel_i0(x)\n6 (full range)\ncyl_bessel_i1(x)\n6 (full range)\nfmod(x,y)\n0 (full range)\nremainder(x,y)\n0 (full range)\nremquo(x,y,iptr)\n0 (full range)\nmodf(x,iptr)\n0 (full range)\nfdim(x,y)\n0 (full range)\ntrunc(x)\n0 (full range)\nround(x)\n0 (full range)\nrint(x)\n0 (full range)\nnearbyint(x)\n0 (full range)\nceil(x)\n0 (full range)\nfloor(x)\n0 (full range)\nlrint(x)\n0 (full range)\nlround(x)\n0 (full range)\nllrint(x)\n0 (full range)\nllround(x)\n0 (full range)\nQuad-Precision Floating-Point Functions\nNote that the quad-precision mathematical functions are currently only available to devices with compute capability 10.0 and later.\nDue to the specifics of implementation, the support of\n__float128\nand\n_Float128\ntypes in device code is also limited to select combinations of host platforms, see also\nHost Compiler Extensions\n.\nTable 19\nQuad-Precision Mathematical Standard Library Functions with Maximum ULP Error. The maximum error is stated as the absolute value of the difference in ulps between the result returned by the CUDA library function and a correctly rounded quad-precision result obtained according to the round-to-nearest ties-to-even rounding mode.\nï\nFunction\nMaximum ulp error\nx+y\n__nv_fp128_add(x,\ny)\n0 (IEEE-754 round-to-nearest-even)\nx-y\n__nv_fp128_sub(x,\ny)\n0 (IEEE-754 round-to-nearest-even)\nx*y\n__nv_fp128_mul(x,\ny)\n0 (IEEE-754 round-to-nearest-even)\nx/y\n__nv_fp128_div(x,\ny)\n0 (IEEE-754 round-to-nearest-even)\n__nv_fp128_sqrt(x)\n0 (IEEE-754 round-to-nearest-even)\n__nv_fp128_fma(x,\ny,\nz)\n0 (IEEE-754 round-to-nearest-even)\n__nv_fp128_sin(x)\n1 (full range)\n__nv_fp128_cos(x)\n1 (full range)\n__nv_fp128_tan(x)\n1 (full range)\n__nv_fp128_asin(x)\n1 (full range)\n__nv_fp128_acos(x)\n1 (full range)\n__nv_fp128_atan(x)\n1 (full range)\n__nv_fp128_exp(x)\n1 (full range)\n__nv_fp128_exp2(x)\n1 (full range)\n__nv_fp128_exp10(x)\n1 (full range)\n__nv_fp128_expm1(x)\n1 (full range)\n__nv_fp128_log(x)\n1 (full range)\n__nv_fp128_log2(x)\n1 (full range)\n__nv_fp128_log10(x)\n1 (full range)\n__nv_fp128_log1p(x)\n1 (full range)\n__nv_fp128_pow(x,\ny)\n1 (full range)\n__nv_fp128_sinh(x)\n1 (full range)\n__nv_fp128_cosh(x)\n1 (full range)\n__nv_fp128_tanh(x)\n1 (full range)\n__nv_fp128_asinh(x)\n1 (full range)\n__nv_fp128_acosh(x)\n1 (full range)\n__nv_fp128_atanh(x)\n1 (full range)\n__nv_fp128_hypot(x,\ny)\n1 (full range)\n__nv_fp128_ceil(x)\n0 (full range)\n__nv_fp128_trunc(x)\n0 (full range)\n__nv_fp128_floor(x)\n0 (full range)\n__nv_fp128_round(x)\n0 (full range)\n__nv_fp128_rint(x)\n0 (full range)\n__nv_fp128_fabs(x)\n0 (full range)\n__nv_fp128_copysign(x,\ny)\n0 (full range)\n__nv_fp128_fmax(x,\ny)\n0 (full range)\n__nv_fp128_fmin(x,\ny)\n0 (full range)\n__nv_fp128_fdim(x,\ny)\n0 (full range)\n__nv_fp128_fmod(x,\ny)\n0 (full range)\n__nv_fp128_remainder(x,\ny)\n0 (full range)\n__nv_fp128_frexp(x,\nnptr)\n0 (full range)\n__nv_fp128_modf(x,\niptr)\n0 (full range)\n__nv_fp128_ldexp(x,\nexp)\n0 (full range)\n__nv_fp128_ilogb(x)\n0 (full range)\n17.2.\nIntrinsic Functions\nï\nThe functions from this section can only be used in device code.\nAmong these functions are the less accurate, but faster versions of some of the functions of\nStandard Functions\n.\nThey have the same name prefixed with\n__\n(such as\n__sinf(x)\n).\nThey are faster as they map to fewer native instructions.\nThe compiler has an option (\n-use_fast_math\n) that forces each function in\nTable 20\nto compile to its intrinsic counterpart. In addition to reducing the accuracy of the affected functions,\nit may also cause some differences in special case handling. A more robust approach is to selectively replace\nmathematical function calls by calls to intrinsic functions only where it is merited by the performance gains\nand where changed properties such as reduced accuracy and different special case handling can be tolerated.\nTable 20\nFunctions Affected by -use_fast_math\nï\nOperator/Function\nDevice Function\nx/y\n__fdividef(x,y)\nsinf(x)\n__sinf(x)\ncosf(x)\n__cosf(x)\ntanf(x)\n__tanf(x)\nsincosf(x,sptr,cptr)\n__sincosf(x,sptr,cptr)\nlogf(x)\n__logf(x)\nlog2f(x)\n__log2f(x)\nlog10f(x)\n__log10f(x)\nexpf(x)\n__expf(x)\nexp10f(x)\n__exp10f(x)\npowf(x,y)\n__powf(x,y)\ntanhf(x)\n__tanhf(x)\nSingle-Precision Floating-Point Functions\n__fadd_[rn,rz,ru,rd]()\nand\n__fmul_[rn,rz,ru,rd]()\nmap to addition and multiplication operations that the compiler never merges into FMADs. By contrast, additions and multiplications generated from the â*â and â+â operators will frequently be combined into FMADs.\nFunctions suffixed with\n_rn\noperate using the round to nearest even rounding mode.\nFunctions suffixed with\n_rz\noperate using the round towards zero rounding mode.\nFunctions suffixed with\n_ru\noperate using the round up (to positive infinity) rounding mode.\nFunctions suffixed with\n_rd\noperate using the round down (to negative infinity) rounding mode.\nThe accuracy of floating-point division varies depending on whether the code is compiled with\n-prec-div=false\nor\n-prec-div=true\n. When the code is compiled with\n-prec-div=false\n, both the regular division\n/\noperator and\n__fdividef(x,y)\nhave the same accuracy, but for 2\n126\n<\n|y|\n< 2\n128\n,\n__fdividef(x,y)\ndelivers a result of zero, whereas the\n/\noperator delivers the correct result to\nwithin the accuracy stated in\nTable 21\n.\nAlso, for 2\n126\n<\n|y|\n< 2\n128\n, if\nx\nis infinity,\n__fdividef(x,y)\ndelivers\na\nNaN\n(as a result of multiplying infinity by zero), while the\n/\noperator returns infinity.\nOn the other hand, the\n/\noperator is IEEE-compliant when the code is compiled with\n-prec-div=true\nor without any\n-prec-div\noption at all since its default value is true.\nTable 21\nSingle-Precision Floating-Point Intrinsic Functions. (Supported by the CUDA Runtime Library with Respective Error Bounds)\nï\nFunction\nError bounds\n__fadd_[rn,rz,ru,rd](x,y)\nIEEE-compliant.\n__fsub_[rn,rz,ru,rd](x,y)\nIEEE-compliant.\n__fmul_[rn,rz,ru,rd](x,y)\nIEEE-compliant.\n__fmaf_[rn,rz,ru,rd](x,y,z)\nIEEE-compliant.\n__frcp_[rn,rz,ru,rd](x)\nIEEE-compliant.\n__fsqrt_[rn,rz,ru,rd](x)\nIEEE-compliant.\n__frsqrt_rn(x)\nIEEE-compliant.\n__fdiv_[rn,rz,ru,rd](x,y)\nIEEE-compliant.\n__fdividef(x,y)\nFor\n|y|\nin [\n\\(2^{-126}, 2^{126}\\)\n], the maximum ulp error is 2.\n__expf(x)\nThe maximum ulp error is\n2\n+\nfloor(abs(1.173\n*\nx))\n.\n__exp10f(x)\nThe maximum ulp error is\n2\n+\nfloor(abs(2.97\n*\nx))\n.\n__logf(x)\nFor\nx\nin [0.5, 2], the maximum absolute error is\n\\(2^{-21.41}\\)\n, otherwise, the maximum ulp error is 3.\n__log2f(x)\nFor\nx\nin [0.5, 2], the maximum absolute error is\n\\(2^{-22}\\)\n, otherwise, the maximum ulp error is 2.\n__log10f(x)\nFor\nx\nin [0.5, 2], the maximum absolute error is\n\\(2^{-24}\\)\n, otherwise, the maximum ulp error is 3.\n__sinf(x)\nFor\nx\nin [\n\\(-\\pi, \\pi\\)\n], the maximum absolute error is\n\\(2^{-21.41}\\)\n, and larger otherwise.\n__cosf(x)\nFor\nx\nin [\n\\(-\\pi, \\pi\\)\n], the maximum absolute error is\n\\(2^{-21.19}\\)\n, and larger otherwise.\n__sincosf(x,sptr,cptr)\nSame as\n__sinf(x)\nand\n__cosf(x)\n.\n__tanf(x)\nDerived from its implementation as\n__sinf(x)\n*\n(1/__cosf(x))\n.\n__powf(x,\ny)\nDerived from its implementation as\nexp2f(y\n*\n__log2f(x))\n.\n__tanhf(x)\nThe maximum relative error of the current implementation is\n\\(2^{-11}\\)\n.\nSubnormal results of this fast intrinsic are not flushed to zero even under\n-ftz=true\ncompiler setting.\nAvailable for devices with compute capability of at least 7.5;\nand defaults to regular\ntanhf()\nfunction behavior on other devices.\nDouble-Precision Floating-Point Functions\n__dadd_rn()\nand\n__dmul_rn()\nmap to addition and multiplication operations that the compiler never merges into FMADs. By contrast, additions and multiplications generated from the â*â and â+â operators will frequently be combined into FMADs.\nTable 22\nDouble-Precision Floating-Point Intrinsic Functions. (Supported by the CUDA Runtime Library with Respective Error Bounds)\nï\nFunction\nError bounds\n__dadd_[rn,rz,ru,rd](x,y)\nIEEE-compliant.\n__dsub_[rn,rz,ru,rd](x,y)\nIEEE-compliant.\n__dmul_[rn,rz,ru,rd](x,y)\nIEEE-compliant.\n__fma_[rn,rz,ru,rd](x,y,z)\nIEEE-compliant.\n__ddiv_[rn,rz,ru,rd](x,y)(x,y)\nIEEE-compliant.\nRequires compute capability\n>\n2.\n__drcp_[rn,rz,ru,rd](x)\nIEEE-compliant.\nRequires compute capability\n>\n2.\n__dsqrt_[rn,rz,ru,rd](x)\nIEEE-compliant.\nRequires compute capability\n>\n2.\n18.\nC++ Language Support\nï\nAs described in\nCompilation with NVCC\n, CUDA source files compiled with\nnvcc\ncan include a mix of host code and device code. The CUDA front-end compiler aims to emulate the host compiler behavior with respect to C++ input code. The input source code is processed according to the C++ ISO/IEC 14882:2003, C++ ISO/IEC 14882:2011, C++ ISO/IEC 14882:2014 or C++ ISO/IEC 14882:2017 specifications, and the CUDA front-end compiler aims to emulate any host compiler divergences from the ISO specification. In addition, the supported language is extended with CUDA-specific constructs described in this document\n6\n, and is subject to the restrictions described below.\nC++11 Language Features\n,\nC++14 Language Features\nand\nC++17 Language Features\nprovide support matrices for the C++11, C++14, C++17 and C++20 features, respectively.\nRestrictions\nlists the language restrictions.\nPolymorphic Function Wrappers\nand\nExtended Lambdas\ndescribe additional features.\nCode Samples\ngives code samples.\n18.1.\nC++11 Language Features\nï\nThe following table lists new language features that have been accepted into the C++11 standard. The âProposalâ column provides a link to the ISO C++ committee proposal that describes the feature, while the âAvailable in nvcc (device code)â column indicates the first version of nvcc that contains an implementation of this feature (if it has been implemented) for device code.\nTable 23\nC++11 Language Features\nï\nLanguage Feature\nC++11 Proposal\nAvailable in nvcc (device code)\nRvalue references\nN2118\n7.0\nÂ  Rvalue references for\n*this\nN2439\n7.0\nInitialization of class objects by rvalues\nN1610\n7.0\nNon-static data member initializers\nN2756\n7.0\nVariadic templates\nN2242\n7.0\nÂ  Extending variadic template template parameters\nN2555\n7.0\nInitializer lists\nN2672\n7.0\nStatic assertions\nN1720\n7.0\nauto\n-typed variables\nN1984\n7.0\nÂ  Â  Â  Â  Multi-declarator\nauto\nN1737\n7.0\nÂ  Â  Â  Â  Removal of auto as a storage-class specifier\nN2546\n7.0\nÂ  Â  Â  Â  New function declarator syntax\nN2541\n7.0\nLambda expressions\nN2927\n7.0\nDeclared type of an expression\nN2343\n7.0\nÂ  Â  Â  Â  Incomplete return types\nN3276\n7.0\nRight angle brackets\nN1757\n7.0\nDefault template arguments for function templates\nDR226\n7.0\nSolving the SFINAE problem for expressions\nDR339\n7.0\nAlias templates\nN2258\n7.0\nExtern templates\nN1987\n7.0\nNull pointer constant\nN2431\n7.0\nStrongly-typed enums\nN2347\n7.0\nForward declarations for enums\nN2764\nDR1206\n7.0\nStandardized attribute syntax\nN2761\n7.0\nGeneralized constant expressions\nN2235\n7.0\nAlignment support\nN2341\n7.0\nConditionally-support behavior\nN1627\n7.0\nChanging undefined behavior into diagnosable errors\nN1727\n7.0\nDelegating constructors\nN1986\n7.0\nInheriting constructors\nN2540\n7.0\nExplicit conversion operators\nN2437\n7.0\nNew character types\nN2249\n7.0\nUnicode string literals\nN2442\n7.0\nRaw string literals\nN2442\n7.0\nUniversal character names in literals\nN2170\n7.0\nUser-defined literals\nN2765\n7.0\nStandard Layout Types\nN2342\n7.0\nDefaulted functions\nN2346\n7.0\nDeleted functions\nN2346\n7.0\nExtended friend declarations\nN1791\n7.0\nExtending\nsizeof\nN2253\nDR850\n7.0\nInline namespaces\nN2535\n7.0\nUnrestricted unions\nN2544\n7.0\nLocal and unnamed types as template arguments\nN2657\n7.0\nRange-based for\nN2930\n7.0\nExplicit virtual overrides\nN2928\nN3206\nN3272\n7.0\nMinimal support for garbage collection and reachability-based leak detection\nN2670\nN/A (see\nRestrictions\n)\nAllowing move constructors to throw [noexcept]\nN3050\n7.0\nDefining move special member functions\nN3053\n7.0\nConcurrency\nSequence points\nN2239\nAtomic operations\nN2427\nStrong Compare and Exchange\nN2748\nBidirectional Fences\nN2752\nMemory model\nN2429\nData-dependency ordering: atomics and memory model\nN2664\nPropagating exceptions\nN2179\nAllow atomics use in signal handlers\nN2547\nThread-local storage\nN2659\nDynamic initialization and destruction with concurrency\nN2660\nC99 Features in C++11\n__func__\npredefined identifier\nN2340\n7.0\nC99 preprocessor\nN1653\n7.0\nlong\nlong\nN1811\n7.0\nExtended integral types\nN1988\n18.2.\nC++14 Language Features\nï\nThe following table lists new language features that have been accepted into the C++14 standard.\nTable 24\nC++14 Language Features\nï\nLanguage Feature\nC++14 Proposal\nAvailable in nvcc (device code)\nTweak to certain C++ contextual conversions\nN3323\n9.0\nBinary literals\nN3472\n9.0\nFunctions with deduced return type\nN3638\n9.0\nGeneralized lambda capture (init-capture)\nN3648\n9.0\nGeneric (polymorphic) lambda expressions\nN3649\n9.0\nVariable templates\nN3651\n9.0\nRelaxing requirements on constexpr functions\nN3652\n9.0\nMember initializers and aggregates\nN3653\n9.0\nClarifying memory allocation\nN3664\nSized deallocation\nN3778\n[[deprecated]]\nattribute\nN3760\n9.0\nSingle-quotation-mark as a digit separator\nN3781\n9.0\n18.3.\nC++17 Language Features\nï\nAll C++17 language features are supported in nvcc version 11.0 and later, subject to restrictions described\nhere\n.\n18.4.\nC++20 Language Features\nï\nAll C++20 language features are supported in nvcc version 12.0 and later, subject to restrictions described\nhere\n.\n18.5.\nRestrictions\nï\n18.5.1.\nHost Compiler Extensions\nï\nHost compiler specific language extensions are not supported in device code.\n__Complex\ntypes are only supported in host code.\n__int128\ntype is supported in device code when compiled in conjunction with a host compiler that supports it.\n__float128\ntype is supported for devices with compute capability 10.0 and later, when compiled in conjunction with a host compiler that supports the type. A constant expression of\n__float128\ntype may be processed by the compiler in a floating point representation with lower precision.\n18.5.2.\nPreprocessor Symbols\nï\n18.5.2.1.\n__CUDA_ARCH__\nï\nThe type signature of the following entities shall not depend on whether\n__CUDA_ARCH__\nis defined or not, or on a particular value of\n__CUDA_ARCH__\n:\n__global__\nfunctions and function templates\n__device__\nand\n__constant__\nvariables\ntextures and surfaces\nExample:\n#if !defined(__CUDA_ARCH__)\ntypedef\nint\nmytype\n;\n#else\ntypedef\ndouble\nmytype\n;\n#endif\n__device__\nmytype\nxxx\n;\n// error: xxx's type depends on __CUDA_ARCH__\n__global__\nvoid\nfoo\n(\nmytype\nin\n,\n// error: foo's type depends on __CUDA_ARCH__\nmytype\n*\nptr\n)\n{\n*\nptr\n=\nin\n;\n}\nIf a\n__global__\nfunction template is instantiated and launched from the host, then the function template must be instantiated with the same template arguments irrespective of whether\n__CUDA_ARCH__\nis defined and regardless of the value of\n__CUDA_ARCH__\n.\nExample:\n__device__\nint\nresult\n;\ntemplate\n<\ntypename\nT\n>\n__global__\nvoid\nkern\n(\nT\nin\n)\n{\nresult\n=\nin\n;\n}\n__host__\n__device__\nvoid\nfoo\n(\nvoid\n)\n{\n#if !defined(__CUDA_ARCH__)\nkern\n<<<\n1\n,\n1\n>>>\n(\n1\n);\n// error: \"kern<int>\" instantiation only\n// when __CUDA_ARCH__ is undefined!\n#endif\n}\nint\nmain\n(\nvoid\n)\n{\nfoo\n();\ncudaDeviceSynchronize\n();\nreturn\n0\n;\n}\nIn separate compilation mode, the presence or absence of a definition of a function or variable with external linkage shall not depend on whether\n__CUDA_ARCH__\nis defined or on a particular value of\n__CUDA_ARCH__\n7\n.\nExample:\n#if !defined(__CUDA_ARCH__)\nvoid\nfoo\n(\nvoid\n)\n{\n}\n// error: The definition of foo()\n// is only present when __CUDA_ARCH__\n// is undefined\n#endif\nIn separate compilation,\n__CUDA_ARCH__\nmust not be used in headers such that different objects could contain different behavior. Or, it must be guaranteed that all objects will compile for the same compute_arch. If a weak function or template function is defined in a header and its behavior depends on\n__CUDA_ARCH__\n, then the instances of that function in the objects could conflict if the objects are compiled for different compute arch.\nFor example, if an a.h contains:\ntemplate\n<\ntypename\nT\n>\n__device__\nT\n*\ngetptr\n(\nvoid\n)\n{\n#if __CUDA_ARCH__ == 700\nreturn\nNULL\n;\n/* no address */\n#else\n__shared__\nT\narr\n[\n256\n];\nreturn\narr\n;\n#endif\n}\nThen if\na.cu\nand\nb.cu\nboth include\na.h\nand instantiate\ngetptr\nfor the same type, and\nb.cu\nexpects a non-NULL address, and compile with:\nnvcc âarch=compute_70 âdc a.cu\nnvcc âarch=compute_80 âdc b.cu\nnvcc âarch=sm_80 a.o b.o\nAt link time only one version of the\ngetptr\nis used, so the behavior would depend on which version is chosen. To avoid this, either\na.cu\nand\nb.cu\nmust be compiled for the same compute arch, or\n__CUDA_ARCH__\nshould not be used in the shared header function.\nThe compiler does not guarantee that a diagnostic will be generated for the unsupported uses of\n__CUDA_ARCH__\ndescribed above.\n18.5.3.\nQualifiers\nï\n18.5.3.1.\nDevice Memory Space Specifiers\nï\nThe\n__device__\n,\n__shared__\n,\n__managed__\nand\n__constant__\nmemory space specifiers are not allowed on:\nclass\n,\nstruct\n, and\nunion\ndata members,\nformal parameters,\nnon-extern variable declarations within a function that executes on the host.\nThe\n__device__\n,\n__constant__\nand\n__managed__\nmemory space specifiers are not allowed on variable declarations that are neither extern nor static within a function that executes on the device.\nA\n__device__\n,\n__constant__\n,\n__managed__\nor\n__shared__\nvariable definition cannot have a class type with a non-empty constructor or a non-empty destructor. A constructor for a class type is considered empty at a point in the translation unit, if it is either a trivial constructor or it satisfies all of the following conditions:\nThe constructor function has been defined.\nThe constructor function has no parameters, the initializer list is empty and the function body is an empty compound statement.\nIts class has no virtual functions, no virtual base classes and no non-static data member initializers.\nThe default constructors of all base classes of its class can be considered empty.\nFor all the nonstatic data members of its class that are of class type (or array thereof), the default constructors can be considered empty.\nA destructor for a class is considered empty at a point in the translation unit, if it is either a trivial destructor or it satisfies all of the following conditions:\nThe destructor function has been defined.\nThe destructor function body is an empty compound statement.\nIts class has no virtual functions and no virtual base classes.\nThe destructors of all base classes of its class can be considered empty.\nFor all the nonstatic data members of its class that are of class type (or array thereof), the destructor can be considered empty.\nWhen compiling in the whole program compilation mode (see the nvcc user manual for a description of this mode),\n__device__\n,\n__shared__\n,\n__managed__\nand\n__constant__\nvariables cannot be defined as external using the\nextern\nkeyword. The only exception is for dynamically allocated\n__shared__\nvariables as described in\n__shared__\n.\nWhen compiling in the separate compilation mode (see the nvcc user manual for a description of this mode),\n__device__\n,\n__shared__\n,\n__managed__\nand\n__constant__\nvariables can be defined as external using the\nextern\nkeyword.\nnvlink\nwill generate an error when it cannot find a definition for an external variable (unless it is a dynamically allocated\n__shared__\nvariable).\n18.5.3.2.\n__managed__ Memory Space Specifier\nï\nVariables marked with the\n__managed__\nmemory space specifier (âmanagedâ variables) have the following restrictions:\nThe address of a managed variable is not a constant expression.\nA managed variable shall not have a const qualified type.\nA managed variable shall not have a reference type.\nThe address or value of a managed variable shall not be used when the CUDA runtime may not be in a valid state, including the following cases:\nIn static/dynamic initialization or destruction of an object with static or thread local storage duration.\nIn code that executes after exit() has been called (for example, a function marked with gccâs â\n__attribute__((destructor))\nâ).\nIn code that executes when CUDA runtime may not be initialized (for example, a function marked with gccâs â\n__attribute__((constructor))\nâ).\nA managed variable cannot be used as an unparenthesized id-expression argument to a\ndecltype()\nexpression.\nManaged variables have the same coherence and consistency behavior as specified for dynamically allocated managed memory.\nWhen a CUDA program containing managed variables is run on an execution platform with multiple GPUs, the variables are allocated only once, and not per GPU.\nA managed variable declaration without the extern linkage is not allowed within a function that executes on the host.\nA managed variable declaration without the extern or static linkage is not allowed within a function that executes on the device.\nHere are examples of legal and illegal uses of managed variables:\n__device__\n__managed__\nint\nxxx\n=\n10\n;\n// OK\nint\n*\nptr\n=\n&\nxxx\n;\n// error: use of managed variable\n// (xxx) in static initialization\nstruct\nS1_t\n{\nint\nfield\n;\nS1_t\n(\nvoid\n)\n:\nfield\n(\nxxx\n)\n{\n};\n};\nstruct\nS2_t\n{\n~\nS2_t\n(\nvoid\n)\n{\nxxx\n=\n10\n;\n}\n};\nS1_t\ntemp1\n;\n// error: use of managed variable\n// (xxx) in dynamic initialization\nS2_t\ntemp2\n;\n// error: use of managed variable\n// (xxx) in the destructor of\n// object with static storage\n// duration\n__device__\n__managed__\nconst\nint\nyyy\n=\n10\n;\n// error: const qualified type\n__device__\n__managed__\nint\n&\nzzz\n=\nxxx\n;\n// error: reference type\ntemplate\n<\nint\n*\naddr\n>\nstruct\nS3_t\n{\n};\nS3_t\n<&\nxxx\n>\ntemp\n;\n// error: address of managed\n// variable(xxx) not a\n// constant expression\n__global__\nvoid\nkern\n(\nint\n*\nptr\n)\n{\nassert\n(\nptr\n==\n&\nxxx\n);\n// OK\nxxx\n=\n20\n;\n// OK\n}\nint\nmain\n(\nvoid\n)\n{\nint\n*\nptr\n=\n&\nxxx\n;\n// OK\nkern\n<<<\n1\n,\n1\n>>>\n(\nptr\n);\ncudaDeviceSynchronize\n();\nxxx\n++\n;\n// OK\ndecltype\n(\nxxx\n)\nqqq\n;\n// error: managed variable(xxx) used\n// as unparenthized argument to\n// decltype\ndecltype\n((\nxxx\n))\nzzz\n=\nyyy\n;\n// OK\n}\n18.5.3.3.\nVolatile Qualifier\nï\nNote\nThe\nvolatile\nkeyword is supported to maintain compatibility with ISO C++; however, few if any of its\nremaining non-deprecated uses\napply to GPUs.\nReads and writes to volatile qualified objects are not atomic, and are compiled to one or more\n.volatile instructions\nwhich do NOT guarantee:\nordering of memory operations, or\nthat the number of memory operations performed by the HW matches the number of PTX instructions.\nThat is, CUDA C++ volatile is not suitable for:\nInter-Thread Synchronization\n: use atomic operations via\ncuda::atomic_ref\n,\ncuda::atomic\n, or\nAtomic Functions\ninstead.\nAtomic memory operations provide inter-thread synchronization guarantees and deliver much better performance than volatile operations.\nCUDA C++ volatile operations do not provide any inter-thread synchronization guarantees and are therefore not correct for inter-thread synchronization.\nThe following example shows how to pass a message across two threads using atomic operations.\ncuda::atomic_ref\n__global__\nvoid\nkernel\n(\nint\n*\nflag\n,\nint\n*\ndata\n)\n{\ncuda\n::\natomic_ref\n<\nint\n,\ncuda\n::\nthread_scope_device\n>\nf\n{\n*\nflag\n};\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\n// Consumer: blocks until flag is set by producer, then reads data\nwhile\n(\nf\n.\nload\n(\ncuda\n::\nmemory_order_acquire\n)\n==\n0\n);\nif\n(\n*\ndata\n!=\n42\n)\n__trap\n();\n// Errors if wrong data read\n}\nelse\nif\n(\nthreadIdx\n.\nx\n==\n1\n)\n{\n// Producer: writes data then sets flag\n*\ndata\n=\n42\n;\nf\n.\nstore\n(\n1\n,\ncuda\n::\nmemory_order_release\n);\n}\n}\ncuda::atomic\n__global__\nvoid\nkernel\n(\ncuda\n::\natomic\n<\nint\n,\ncuda\n::\nthread_scope_device\n>*\nflag\n,\nint\n*\ndata\n)\n{\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\n// Consumer: blocks until flag is set by producer, then reads data\nwhile\n(\nflag\n->\nload\n(\ncuda\n::\nmemory_order_acquire\n)\n==\n0\n);\nif\n(\n*\ndata\n!=\n42\n)\n__trap\n();\n// Errors if wrong data read\n}\nelse\nif\n(\nthreadIdx\n.\nx\n==\n1\n)\n{\n// Producer: writes data then sets flag\n*\ndata\n=\n42\n;\nflag\n->\nstore\n(\n1\n,\ncuda\n::\nmemory_order_release\n);\n}\n}\nAtomic Functions (\natomicAdd\nand\natomicExch\n)\n__global__\nvoid\nkernel\n(\nint\n*\nflag\n,\nint\n*\ndata\n)\n{\nif\n(\nthreadIdx\n.\nx\n==\n0\n)\n{\n// Consumer: blocks until flag is set by producer, then reads data\nwhile\n(\natomicAdd\n(\nflag\n,\n0\n)\n==\n0\n);\n// Load with Relaxed Read-Modify-Write\n__threadfence\n();\n// SequentiallyConsistent fence\nif\n(\n*\ndata\n!=\n42\n)\n__trap\n();\n// Errors if wrong data read\n}\nelse\nif\n(\nthreadIdx\n.\nx\n==\n1\n)\n{\n// Producer: writes data then sets flag\n*\ndata\n=\n42\n;\n__threadfence\n();\n// SequentiallyConsistent fence\natomicExch\n(\nflag\n,\n1\n);\n// Store with Relaxed Read-Modify-Write\n}\n}\nMemory Mapped IO\n(MMIO): use\nPTX MMIO operations\nvia inline PTX instead.\nPTX MMIO operations strictly preserve the number of memory accesses performed.\nCUDA C++\nvolatile\noperations do not preserve the number of memory accesses performed, and may perform more or less accesses than requested in a non-deterministic way, making them incorrect for MMIO.\nThe following example shows how to read and write from a register using PTX mmio operations.\n__global__\nvoid\nkernel\n(\nint\n*\nmmio_reg0\n,\nint\n*\nmmio_reg1\n)\n{\n// Write to MMIO register:\nint\nvalue\n=\n13\n;\nasm\nvolatile\n(\n\"st.relaxed.mmio.sys.u32 [%0], %1;\"\n::\n\"l\"\n(\nmmio_reg0\n),\n\"r\"\n(\nvalue\n)\n:\n\"memory\"\n);\n// Read MMIO register:\nasm\nvolatile\n(\n\"ld.relaxed.mmio.sys.u32 %0, [%1];\"\n:\n\"=r\"\n(\nvalue\n)\n:\n\"l\"\n(\nmmio_reg1\n)\n:\n\"memory\"\n);\nif\n(\nvalue\n!=\n42\n)\n__trap\n();\n// Errors if wrong data read\n}\n18.5.4.\nPointers\nï\nDereferencing a pointer either to global or shared memory in code that is executed on the host, or to host memory in code that is executed on the device results in an undefined behavior, most often in a segmentation fault and application termination.\nThe address obtained by taking the address of a\n__device__\n,\n__shared__\nor\n__constant__\nvariable can only be used in device code. The address of a\n__device__\nor\n__constant__\nvariable obtained through\ncudaGetSymbolAddress()\nas described in\nDevice Memory\ncan only be used in host code.\n18.5.5.\nOperators\nï\n18.5.5.1.\nAssignment Operator\nï\n__constant__\nvariables can only be assigned from the host code through runtime functions (\nDevice Memory\n); they cannot be assigned from the device code.\n__shared__\nvariables cannot have an initialization as part of their declaration.\nIt is not allowed to assign values to any of the built-in variables defined in\nBuilt-in Variables\n.\n18.5.5.2.\nAddress Operator\nï\nIt is not allowed to take the address of any of the built-in variables defined in\nBuilt-in Variables\n.\n18.5.6.\nRun Time Type Information (RTTI)\nï\nThe following RTTI-related features are supported in host code, but not in device code.\ntypeid\noperator\nstd::type_info\ndynamic_cast\noperator\n18.5.7.\nException Handling\nï\nException handling is only supported in host code, but not in device code.\nException specification is not supported for\n__global__\nfunctions.\n18.5.8.\nStandard Library\nï\nStandard libraries are only supported in host code, but not in device code, unless specified otherwise.\n18.5.9.\nNamespace Reservations\nï\nUnless an exception is otherwise noted, it is undefined behavior to add any declarations or definitions to\ncuda::\n,\nnv::\n,\ncooperative_groups::\nor any namespace nested within.\nExamples:\nnamespace\ncuda\n{\n// Bad: class declaration added to namespace cuda\nstruct\nfoo\n{};\n// Bad: function definition added to namespace cuda\ncudaStream_t\nmake_stream\n(){\ncudaStream_t\ns\n;\ncudaStreamCreate\n(\n&\ns\n);\nreturn\ns\n;\n}\n}\n// namespace cuda\nnamespace\ncuda\n{\nnamespace\nutils\n{\n// Bad: function definition added to namespace nested within cuda\ncudaStream_t\nmake_stream\n(){\ncudaStream_t\ns\n;\ncudaStreamCreate\n(\n&\ns\n);\nreturn\ns\n;\n}\n}\n// namespace utils\n}\n// namespace cuda\nnamespace\nutils\n{\nnamespace\ncuda\n{\n// Okay: namespace cuda may be used nested within a non-reserved namespace\ncudaStream_t\nmake_stream\n(){\ncudaStream_t\ns\n;\ncudaStreamCreate\n(\n&\ns\n);\nreturn\ns\n;\n}\n}\n// namespace cuda\n}\n// namespace utils\n// Bad: Equivalent to adding symbols to namespace cuda at global scope\nusing\nnamespace\nutils\n;\n18.5.10.\nFunctions\nï\n18.5.10.1.\nExternal Linkage\nï\nA call within some device code of a function declared with the extern qualifier is only allowed if the function is defined within the same compilation unit as the device code, i.e., a single file or several files linked together with relocatable device code and nvlink.\n18.5.10.2.\nImplicitly-declared and non-virtual explicitly-defaulted functions\nï\nLet\nF\ndenote a function that is either implicitly-declared or is a non-virtual function that is explicitly-defaulted on its first declaration. The execution space specifiers (\n__host__\n,\n__device__\n) for\nF\nare the union of the execution space specifiers of all the functions that invoke it (note that a\n__global__\ncaller will be treated as a\n__device__\ncaller for this analysis). For example:\nclass\nBase\n{\nint\nx\n;\npublic\n:\n__host__\n__device__\nBase\n(\nvoid\n)\n:\nx\n(\n10\n)\n{}\n};\nclass\nDerived\n:\npublic\nBase\n{\nint\ny\n;\n};\nclass\nOther\n:\npublic\nBase\n{\nint\nz\n;\n};\n__device__\nvoid\nfoo\n(\nvoid\n)\n{\nDerived\nD1\n;\nOther\nD2\n;\n}\n__host__\nvoid\nbar\n(\nvoid\n)\n{\nOther\nD3\n;\n}\nHere, the implicitly-declared constructor function âDerived::Derivedâ will be treated as a\n__device__\nfunction, since it is invoked only from the\n__device__\nfunction âfooâ. The implicitly-declared constructor function âOther::Otherâ will be treated as a\n__host__\n__device__\nfunction, since it is invoked both from a\n__device__\nfunction âfooâ and a\n__host__\nfunction âbarâ.\nIn addition, if\nF\nis an implicitly declared virtual function (e.g.,a virtual destructor), then the execution spaces of each virtual function\nD\noverridden by\nF\nare added to the set of execution spaces for\nF\n, if\nD\nis not implicitly declared.\nFor example:\nstruct\nBase1\n{\nvirtual\n__host__\n__device__\n~\nBase1\n()\n{\n}\n};\nstruct\nDerived1\n:\nBase1\n{\n};\n// implicitly-declared virtual destructor\n// ~Derived1 has __host__ __device__\n// execution space specifiers\nstruct\nBase2\n{\nvirtual\n__device__\n~\nBase2\n()\n=\ndefault\n;\n};\nstruct\nDerived2\n:\nBase2\n{\n};\n// implicitly-declared virtual destructor\n// ~Derived2 has __device__ execution\n// space specifiers\n18.5.10.3.\nFunction Parameters\nï\n__global__\nfunction parameters are passed to the device via constant memory and are limited to 32,764 bytes starting with Volta, and 4 KB on older architectures.\n__global__\nfunctions cannot have a variable number of arguments.\n__global__\nfunction parameters cannot be pass-by-reference.\nIn separate compilation mode, if a\n__device__\nor\n__global__\nfunction is ODR-used in a particular translation unit, then the parameter and return types of the function must be complete in that translation unit.\nExample:\n//first.cu:\nstruct\nS\n;\n__device__\nvoid\nfoo\n(\nS\n);\n// error: type 'S' is incomplete\n__device__\nauto\n*\nptr\n=\nfoo\n;\nint\nmain\n()\n{\n}\n//second.cu:\nstruct\nS\n{\nint\nx\n;\n};\n__device__\nvoid\nfoo\n(\nS\n)\n{\n}\n//compiler invocation\n$nvcc -std=c++14 -rdc=true first.cu second.cu -o first\nnvlink error   : Prototype doesn't match for '_Z3foo1S' in '/tmp/tmpxft_00005c8c_00000000-18_second.o', first defined in '/tmp/tmpxft_00005c8c_00000000-18_second.o'\nnvlink fatal   : merge_elf failed\n18.5.10.3.1.\n__global__\nFunction Argument Processing\nï\nWhen a\n__global__\nfunction is launched from device code, each argument must be trivially copyable and trivially destructible.\nWhen a\n__global__\nfunction is launched from host code, each argument type is allowed to be non-trivially copyable or non-trivially-destructible, but the processing for such types does not follow the standard C++ model, as described below. User code must ensure that this workflow does not affect program correctness. The workflow diverges from standard C++ in two areas:\nMemcpy instead of copy constructor invocation\nWhen lowering a\n__global__\nfunction launch from host code, the compiler generates stub functions that copy the parameters one or more times by value, before eventually using\nmemcpy\nto copy the arguments to the\n__global__\nfunctionâs parameter memory on the device. This occurs even if an argument was non-trivially-copyable, and therefore may break programs where the copy constructor has side effects.\nExample:\n#include\n<cassert>\nstruct\nS\n{\nint\nx\n;\nint\n*\nptr\n;\n__host__\n__device__\nS\n()\n{\n}\n__host__\n__device__\nS\n(\nconst\nS\n&\n)\n{\nptr\n=\n&\nx\n;\n}\n};\n__global__\nvoid\nfoo\n(\nS\nin\n)\n{\n// this assert may fail, because the compiler\n// generated code will memcpy the contents of \"in\"\n// from host to kernel parameter memory, so the\n// \"in.ptr\" is not initialized to \"&in.x\" because\n// the copy constructor is skipped.\nassert\n(\nin\n.\nptr\n==\n&\nin\n.\nx\n);\n}\nint\nmain\n()\n{\nS\ntmp\n;\nfoo\n<<<\n1\n,\n1\n>>>\n(\ntmp\n);\ncudaDeviceSynchronize\n();\n}\nExample:\n#include\n<cassert>\n__managed__\nint\ncounter\n;\nstruct\nS1\n{\nS1\n()\n{\n}\nS1\n(\nconst\nS1\n&\n)\n{\n++\ncounter\n;\n}\n};\n__global__\nvoid\nfoo\n(\nS1\n)\n{\n/* this assertion may fail, because\nthe compiler generates stub\nfunctions on the host for a kernel\nlaunch, and they may copy the\nargument by value more than once.\n*/\nassert\n(\ncounter\n==\n1\n);\n}\nint\nmain\n()\n{\nS1\nV\n;\nfoo\n<<<\n1\n,\n1\n>>>\n(\nV\n);\ncudaDeviceSynchronize\n();\n}\nDestructor may be invoked before the ``__global__`` function has finished\nKernel launches are asynchronous with host execution. As a result, if a\n__global__\nfunction argument has a non-trivial destructor, the destructor may execute in host code even before the\n__global__\nfunction has finished execution. This may break programs where the destructor has side effects.\nExample:\nstruct\nS\n{\nint\n*\nptr\n;\nS\n()\n:\nptr\n(\nnullptr\n)\n{\n}\nS\n(\nconst\nS\n&\n)\n{\ncudaMallocManaged\n(\n&\nptr\n,\nsizeof\n(\nint\n));\n}\n~\nS\n()\n{\ncudaFree\n(\nptr\n);\n}\n};\n__global__\nvoid\nfoo\n(\nS\nin\n)\n{\n//error: This store may write to memory that has already been\n//       freed (see below).\n*\n(\nin\n.\nptr\n)\n=\n4\n;\n}\nint\nmain\n()\n{\nS\nV\n;\n/* The object 'V' is first copied by value to a compiler-generated\n* stub function that does the kernel launch, and the stub function\n* bitwise copies the contents of the argument to kernel parameter\n* memory.\n* However, GPU kernel execution is asynchronous with host\n* execution.\n* As a result, S::~S() will execute when the stub function   returns, releasing allocated memory, even though the kernel may not have finished execution.\n*/\nfoo\n<<<\n1\n,\n1\n>>>\n(\nV\n);\ncudaDeviceSynchronize\n();\n}\n18.5.10.3.2.\nToolkit and Driver Compatibility\nï\nDevelopers must use the 12.1 Toolkit and r530 driver or higher to compile, launch, and debug kernels that accept parameters larger than 4KB. If such kernels are launched on older drivers, CUDA will issue the error\nCUDA_ERROR_NOT_SUPPORTED\n.\n18.5.10.3.3.\nLink Compatibility across Toolkit Revisions\nï\nWhen linking device objects, if at least one device object contains a kernel with a parameter larger than 4KB, the developer must recompile all objects from their respective device sources with the 12.1 toolkit or higher before linking them together. Failure to do so will result in a linker error.\n18.5.10.4.\nStatic Variables within Function\nï\nVariable memory space specifiers are allowed in the declaration of a static variable\nV\nwithin the immediate or nested block scope of a function\nF\nwhere:\nF\nis a\n__global__\nor\n__device__\n-only function.\nF\nis a\n__host__\n__device__\nfunction and\n__CUDA_ARCH__\nis defined\n11\n.\nIf no explicit memory space specifier is present in the declaration of\nV\n, an implicit\n__device__\nspecifier is assumed during device compilation.\nV\nhas the same initialization restrictions as a variable with the same memory space specifiers declared in namespace scope for example a\n__device__\nvariable cannot have a ânon-emptyâ constructor (see\nDevice Memory Space Specifiers\n).\nExamples of legal and illegal uses of function-scope static variables are shown below.\nstruct\nS1_t\n{\nint\nx\n;\n};\nstruct\nS2_t\n{\nint\nx\n;\n__device__\nS2_t\n(\nvoid\n)\n{\nx\n=\n10\n;\n}\n};\nstruct\nS3_t\n{\nint\nx\n;\n__device__\nS3_t\n(\nint\np\n)\n:\nx\n(\np\n)\n{\n}\n};\n__device__\nvoid\nf1\n()\n{\nstatic\nint\ni1\n;\n// OK, implicit __device__ memory space specifier\nstatic\nint\ni2\n=\n11\n;\n// OK, implicit __device__ memory space specifier\nstatic\n__managed__\nint\nm1\n;\n// OK\nstatic\n__device__\nint\nd1\n;\n// OK\nstatic\n__constant__\nint\nc1\n;\n// OK\nstatic\nS1_t\ni3\n;\n// OK, implicit __device__ memory space specifier\nstatic\nS1_t\ni4\n=\n{\n22\n};\n// OK, implicit __device__ memory space specifier\nstatic\n__shared__\nint\ni5\n;\n// OK\nint\nx\n=\n33\n;\nstatic\nint\ni6\n=\nx\n;\n// error: dynamic initialization is not allowed\nstatic\nS1_t\ni7\n=\n{\nx\n};\n// error: dynamic initialization is not allowed\nstatic\nS2_t\ni8\n;\n// error: dynamic initialization is not allowed\nstatic\nS3_t\ni9\n(\n44\n);\n// error: dynamic initialization is not allowed\n}\n__host__\n__device__\nvoid\nf2\n()\n{\nstatic\nint\ni1\n;\n// OK, implicit __device__ memory space specifier\n// during device compilation.\n#ifdef __CUDA_ARCH__\nstatic\n__device__\nint\nd1\n;\n// OK, declaration is only visible during device\n// compilation  (__CUDA_ARCH__ is defined)\n#else\nstatic\nint\nd0\n;\n// OK, declaration is only visible during host\n// compilation (__CUDA_ARCH__ is not defined)\n#endif\nstatic\n__device__\nint\nd2\n;\n// error: __device__ variable inside\n// a host function during host compilation\n// i.e. when __CUDA_ARCH__ is not defined\nstatic\n__shared__\nint\ni2\n;\n// error: __shared__ variable inside\n// a host function during host compilation\n// i.e. when __CUDA_ARCH__ is not defined\n}\n18.5.10.5.\nFunction Pointers\nï\nThe address of a\n__global__\nfunction taken in host code cannot be used in device code (e.g. to launch the kernel). Similarly, the address of a\n__global__\nfunction taken in device code cannot be used in host code.\nIt is not allowed to take the address of a\n__device__\nfunction in host code.\n18.5.10.6.\nFunction Recursion\nï\n__global__\nfunctions do not support recursion.\n18.5.10.7.\nFriend Functions\nï\nA\n__global__\nfunction or function template cannot be defined in a friend declaration.\nExample:\nstruct\nS1_t\n{\nfriend\n__global__\nvoid\nfoo1\n(\nvoid\n);\n// OK: not a definition\ntemplate\n<\ntypename\nT\n>\nfriend\n__global__\nvoid\nfoo2\n(\nvoid\n);\n// OK: not a definition\nfriend\n__global__\nvoid\nfoo3\n(\nvoid\n)\n{\n}\n// error: definition in friend declaration\ntemplate\n<\ntypename\nT\n>\nfriend\n__global__\nvoid\nfoo4\n(\nvoid\n)\n{\n}\n// error: definition in friend declaration\n};\n18.5.10.8.\nOperator Function\nï\nAn operator function cannot be a\n__global__\nfunction.\n18.5.10.9.\nAllocation and Deallocation Functions\nï\nA user-defined\noperator\nnew\n,\noperator\nnew[]\n,\noperator\ndelete\n, or\noperator\ndelete[]\ncannot be used to replace the corresponding\n__host__\nor\n__device__\nbuiltins provided by the compiler.\n18.5.11.\nClasses\nï\n18.5.11.1.\nData Members\nï\nStatic data members are not supported except for those that are also const-qualified (see\nConst-qualified variables\n).\n18.5.11.2.\nFunction Members\nï\nStatic member functions cannot be\n__global__\nfunctions.\n18.5.11.3.\nVirtual Functions\nï\nWhen a function in a derived class overrides a virtual function in a base class, the execution space specifiers (i.e.,\n__host__\n,\n__device__\n) on the overridden and overriding functions must match.\nIt is not allowed to pass as an argument to a\n__global__\nfunction an object of a class with virtual functions.\nIf an object is created in host code, invoking a virtual function for that object in device code has undefined behavior.\nIf an object is created in device code, invoking a virtual function for that object in host code has undefined behavior.\nSee\nWindows-Specific\nfor additional constraints when using the Microsoft host compiler.\nExample:\nstruct\nS1\n{\nvirtual\n__host__\n__device__\nvoid\nfoo\n()\n{\n}\n};\n__managed__\nS1\n*\nptr1\n,\n*\nptr2\n;\n__managed__\n__align__\n(\n16\n)\nchar\nbuf1\n[\n128\n];\n__global__\nvoid\nkern\n()\n{\nptr1\n->\nfoo\n();\n// error: virtual function call on a object\n//        created in host code.\nptr2\n=\nnew\n(\nbuf1\n)\nS1\n();\n}\nint\nmain\n(\nvoid\n)\n{\nvoid\n*\nbuf\n;\ncudaMallocManaged\n(\n&\nbuf\n,\nsizeof\n(\nS1\n),\ncudaMemAttachGlobal\n);\nptr1\n=\nnew\n(\nbuf\n)\nS1\n();\nkern\n<<<\n1\n,\n1\n>>>\n();\ncudaDeviceSynchronize\n();\nptr2\n->\nfoo\n();\n// error: virtual function call on an object\n//        created in device code.\n}\n18.5.11.4.\nVirtual Base Classes\nï\nIt is not allowed to pass as an argument to a\n__global__\nfunction an object of a class derived from virtual base classes.\nSee\nWindows-Specific\nfor additional constraints when using the Microsoft host compiler.\n18.5.11.5.\nAnonymous Unions\nï\nMember variables of a namespace scope anonymous union cannot be referenced in a\n__global__\nor\n__device__\nfunction.\n18.5.11.6.\nWindows-Specific\nï\nThe CUDA compiler follows the IA64 ABI for class layout, while the Microsoft host compiler does not. Let\nT\ndenote a pointer to member type, or a class type that satisfies any of the following conditions:\nT\nhas virtual functions.\nT\nhas a virtual base class.\nT\nhas multiple inheritance with more than one direct or indirect empty base class.\nAll direct and indirect base classes\nB\nof\nT\nare empty and the type of the first field\nF\nof\nT\nuses\nB\nin its definition, such that\nB\nis laid out at offset 0 in the definition of\nF\n.\nLet\nC\ndenote\nT\nor a class type that has\nT\nas a field type or as a base class type. The CUDA compiler may compute the class layout and size differently than the Microsoft host compiler for the type\nC\n.\nAs long as the type\nC\nis used exclusively in host or device code, the program should work correctly.\nPassing an object of type\nC\nbetween host and device code has undefined behavior, for example, as an argument to a\n__global__\nfunction or through\ncudaMemcpy*()\ncalls.\nAccessing an object of type\nC\nor any subobject in device code, or invoking a member function in device code, has undefined behavior if the object is created in host code.\nAccessing an object of type\nC\nor any subobject in host code, or invoking a member function in host code, has undefined behavior if the object is created in device code\n12\n.\n18.5.12.\nTemplates\nï\nA type or template cannot be used in the type, non-type or template template argument of a\n__global__\nfunction template instantiation or a\n__device__/__constant__\nvariable instantiation if either:\nThe type or template is defined within a\n__host__\nor\n__host__\n__device__\n.\nThe type or template is a class member with\nprivate\nor\nprotected\naccess and its parent class is not defined within a\n__device__\nor\n__global__\nfunction.\nThe type is unnamed.\nThe type is compounded from any of the types above.\nExample:\ntemplate\n<\ntypename\nT\n>\n__global__\nvoid\nmyKernel\n(\nvoid\n)\n{\n}\nclass\nmyClass\n{\nprivate\n:\nstruct\ninner_t\n{\n};\npublic\n:\nstatic\nvoid\nlaunch\n(\nvoid\n)\n{\n// error: inner_t is used in template argument\n// but it is private\nmyKernel\n<\ninner_t\n><<<\n1\n,\n1\n>>>\n();\n}\n};\n// C++14 only\ntemplate\n<\ntypename\nT\n>\n__device__\nT\nd1\n;\ntemplate\n<\ntypename\nT1\n,\ntypename\nT2\n>\n__device__\nT1\nd2\n;\nvoid\nfn\n()\n{\nstruct\nS1_t\n{\n};\n// error (C++14 only): S1_t is local to the function fn\nd1\n<\nS1_t\n>\n=\n{};\nauto\nlam1\n=\n[]\n{\n};\n// error (C++14 only): a closure type cannot be used for\n// instantiating a variable template\nd2\n<\nint\n,\ndecltype\n(\nlam1\n)\n>\n=\n10\n;\n}\n18.5.13.\nTrigraphs and Digraphs\nï\nTrigraphs are not supported on any platform. Digraphs are not supported on Windows.\n18.5.14.\nConst-qualified variables\nï\nLet âVâ denote a namespace scope variable or a class static member variable that has const qualified type and does not have execution space annotations (for example,\n__device__,\n__constant__,\n__shared__\n). V is considered to be a host code variable.\nThe value of V may be directly used in device code, if\nV has been initialized with a constant expression before the point of use,\nthe type of V is not volatile-qualified, and\nit has one of the following types:\nbuilt-in floating point type except when the Microsoft compiler is used as the host compiler,\nbuilt-in integral type.\nDevice source code cannot contain a reference to V or take the address of V.\nExample:\nconst\nint\nxxx\n=\n10\n;\nstruct\nS1_t\n{\nstatic\nconst\nint\nyyy\n=\n20\n;\n};\nextern\nconst\nint\nzzz\n;\nconst\nfloat\nwww\n=\n5.0\n;\n__device__\nvoid\nfoo\n(\nvoid\n)\n{\nint\nlocal1\n[\nxxx\n];\n// OK\nint\nlocal2\n[\nS1_t\n::\nyyy\n];\n// OK\nint\nval1\n=\nxxx\n;\n// OK\nint\nval2\n=\nS1_t\n::\nyyy\n;\n// OK\nint\nval3\n=\nzzz\n;\n// error: zzz not initialized with constant\n// expression at the point of use.\nconst\nint\n&\nval3\n=\nxxx\n;\n// error: reference to host variable\nconst\nint\n*\nval4\n=\n&\nxxx\n;\n// error: address of host variable\nconst\nfloat\nval5\n=\nwww\n;\n// OK except when the Microsoft compiler is used as\n// the host compiler.\n}\nconst\nint\nzzz\n=\n20\n;\n18.5.15.\nLong Double\nï\nThe use of\nlong\ndouble\ntype is not supported in device code.\n18.5.16.\nDeprecation Annotation\nï\nnvcc supports the use of\ndeprecated\nattribute when using\ngcc\n,\nclang\n,\nxlC\n,\nicc\nor\npgcc\nhost compilers, and the use of\ndeprecated\ndeclspec when using the\ncl.exe\nhost compiler. It also supports the\n[[deprecated]]\nstandard attribute when the C++14 dialect has been enabled. The CUDA frontend compiler will generate a deprecation diagnostic for a reference to a deprecated entity from within the body of a\n__device__\n,\n__global__\nor\n__host__\n__device__\nfunction when\n__CUDA_ARCH__\nis defined (i.e., during device compilation phase). Other references to deprecated entities will be handled by the host compiler, e.g., a reference from within a\n__host__\nfunction.\nThe CUDA frontend compiler does not support the\n#pragma\ngcc\ndiagnostic\nor\n#pragma\nwarning\nmechanisms supported by various host compilers. Therefore, deprecation diagnostics generated by the CUDA frontend compiler are not affected by these pragmas, but diagnostics generated by the host compiler will be affected. To suppress the warning for device-code, user can use NVIDIA specific pragma\n#pragma nv_diag_suppress\n. The\nnvcc\nflag\n-Wno-deprecated-declarations\ncan be used to suppress all deprecation warnings, and the flag\n-Werror=deprecated-declarations\ncan be used to turn deprecation warnings into errors.\n18.5.17.\nNoreturn Annotation\nï\nnvcc supports the use of\nnoreturn\nattribute when using\ngcc\n,\nclang\n,\nxlC\n,\nicc\nor\npgcc\nhost compilers, and the use of\nnoreturn\ndeclspec when using the\ncl.exe\nhost compiler. It also supports the\n[[noreturn]]\nstandard attribute when the C++11 dialect has been enabled.\nThe attribute/declspec can be used in both host and device code.\n18.5.18.\n[[likely]] / [[unlikely]] Standard Attributes\nï\nThese attributes are accepted in all configurations that support the C++ standard attribute syntax. The attributes can be used to hint to the device compiler optimizer whether a statement is more or less likely to be executed compared to any alternative path that does not include the statement.\nExample:\n__device__\nint\nfoo\n(\nint\nx\n)\n{\nif\n(\ni\n<\n10\n)\n[[\nlikely\n]]\n{\n// the 'if' block will likely be entered\nreturn\n4\n;\n}\nif\n(\ni\n<\n20\n)\n[[\nunlikely\n]]\n{\n// the 'if' block will not likely be entered\nreturn\n1\n;\n}\nreturn\n0\n;\n}\nIf these attributes are used in host code when\n__CUDA_ARCH__\nis undefined, then they will be present in the code parsed by the host compiler, which may generate a warning if the attributes are not supported. For example,\nclang\n11 host compiler will generate an âunknown attributeâ warning.\n18.5.19.\nconst and pure GNU Attributes\nï\nThese attributes are supported for both host and device functions, when using a language dialect and host compiler that also supports these attributes e.g. with g++ host compiler.\nFor a device function annotated with the\npure\nattribute, the device code optimizer assumes that the function does not change any mutable state visible to caller functions (e.g. memory).\nFor a device function annotated with the\nconst\nattribute, the device code optimizer assumes that the function does not access or change any mutable state visible to caller functions (e.g. memory).\nExample:\n__attribute__\n((\nconst\n))\n__device__\nint\nget\n(\nint\nin\n);\n__device__\nint\ndoit\n(\nint\nin\n)\n{\nint\nsum\n=\n0\n;\n//because 'get' is marked with 'const' attribute\n//device code optimizer can recognize that the\n//second call to get() can be commoned out.\nsum\n=\nget\n(\nin\n);\nsum\n+=\nget\n(\nin\n);\nreturn\nsum\n;\n}\n18.5.20.\n__nv_pure__ Attribute\nï\nThe\n__nv_pure__\nattributed is supported for both host and device functions. For host functions, when using a language dialect that supports the\npure\nGNU attribute, the\n__nv_pure__\nattribute is translated to the\npure\nGNU attribute. Similarly when using MSVC as the host compiler, the attribute is translated to the MSVC\nnoalias\nattribute.\nWhen a device function is annotated with the\n__nv_pure__\nattribute, the device code optimizer assumes that the function does not change any mutable state visible to caller functions (e.g. memory).\n18.5.21.\nIntel Host Compiler Specific\nï\nThe CUDA frontend compiler parser does not recognize some of the intrinsic functions supported by the Intel compiler (e.g.\nicc\n). When using the Intel compiler as a host compiler,\nnvcc\nwill therefore enable the macro\n__INTEL_COMPILER_USE_INTRINSIC_PROTOTYPES\nduring preprocessing. This macro enables explicit declarations of the Intel compiler intrinsic functions in the associated header files, allowing\nnvcc\nto support use of such functions in host code\n13\n.\n18.5.22.\nC++11 Features\nï\nC++11 features that are enabled by default by the host compiler are also supported by nvcc, subject to the restrictions described in this document. In addition, invoking nvcc with\n-std=c++11\nflag turns on all C++11 features and also invokes the host preprocessor, compiler and linker with the corresponding C++11 dialect option\n14\n.\n18.5.22.1.\nLambda Expressions\nï\nThe execution space specifiers for all member functions\n15\nof the closure class associated with a lambda expression are derived by the compiler as follows. As described in the C++11 standard, the compiler creates a closure type in the smallest block scope, class scope or namespace scope that contains the lambda expression. The innermost function scope enclosing the closure type is computed, and the corresponding functionâs execution space specifiers are assigned to the closure class member functions. If there is no enclosing function scope, the execution space specifier is\n__host__\n.\nExamples of lambda expressions and computed execution space specifiers are shown below (in comments).\nauto\nglobalVar\n=\n[]\n{\nreturn\n0\n;\n};\n// __host__\nvoid\nf1\n(\nvoid\n)\n{\nauto\nl1\n=\n[]\n{\nreturn\n1\n;\n};\n// __host__\n}\n__device__\nvoid\nf2\n(\nvoid\n)\n{\nauto\nl2\n=\n[]\n{\nreturn\n2\n;\n};\n// __device__\n}\n__host__\n__device__\nvoid\nf3\n(\nvoid\n)\n{\nauto\nl3\n=\n[]\n{\nreturn\n3\n;\n};\n// __host__ __device__\n}\n__device__\nvoid\nf4\n(\nint\n(\n*\nfp\n)()\n=\n[]\n{\nreturn\n4\n;\n}\n/* __host__ */\n)\n{\n}\n__global__\nvoid\nf5\n(\nvoid\n)\n{\nauto\nl5\n=\n[]\n{\nreturn\n5\n;\n};\n// __device__\n}\n__device__\nvoid\nf6\n(\nvoid\n)\n{\nstruct\nS1_t\n{\nstatic\nvoid\nhelper\n(\nint\n(\n*\nfp\n)()\n=\n[]\n{\nreturn\n6\n;\n}\n/* __device__ */\n)\n{\n}\n};\n}\nThe closure type of a lambda expression cannot be used in the type or non-type argument of a\n__global__\nfunction template instantiation, unless the lambda is defined within a\n__device__\nor\n__global__\nfunction.\nExample:\ntemplate\n<\ntypename\nT\n>\n__global__\nvoid\nfoo\n(\nT\nin\n)\n{\n};\ntemplate\n<\ntypename\nT\n>\nstruct\nS1_t\n{\n};\nvoid\nbar\n(\nvoid\n)\n{\nauto\ntemp1\n=\n[]\n{\n};\nfoo\n<<<\n1\n,\n1\n>>>\n(\ntemp1\n);\n// error: lambda closure type used in\n// template type argument\nfoo\n<<<\n1\n,\n1\n>>>\n(\nS1_t\n<\ndecltype\n(\ntemp1\n)\n>\n());\n// error: lambda closure type used in\n// template type argument\n}\n18.5.22.2.\nstd::initializer_list\nï\nBy default, the CUDA compiler will implicitly consider the member functions of\nstd::initializer_list\nto have\n__host__\n__device__\nexecution space specifiers, and therefore they can be invoked directly from device code. The nvcc flag\n--no-host-device-initializer-list\nwill disable this behavior; member functions of\nstd::initializer_list\nwill then be considered as\n__host__\nfunctions and will not be directly invokable from device code.\nExample:\n#include\n<initializer_list>\n__device__\nint\nfoo\n(\nstd\n::\ninitializer_list\n<\nint\n>\nin\n);\n__device__\nvoid\nbar\n(\nvoid\n)\n{\nfoo\n({\n4\n,\n5\n,\n6\n});\n// (a) initializer list containing only\n// constant expressions.\nint\ni\n=\n4\n;\nfoo\n({\ni\n,\n5\n,\n6\n});\n// (b) initializer list with at least one\n// non-constant element.\n// This form may have better performance than (a).\n}\n18.5.22.3.\nRvalue references\nï\nBy default, the CUDA compiler will implicitly consider\nstd::move\nand\nstd::forward\nfunction templates to have\n__host__\n__device__\nexecution space specifiers, and therefore they can be invoked directly from device code. The nvcc flag\n--no-host-device-move-forward\nwill disable this behavior;\nstd::move\nand\nstd::forward\nwill then be considered as\n__host__\nfunctions and will not be directly invokable from device code.\n18.5.22.4.\nConstexpr functions and function templates\nï\nBy default, a constexpr function cannot be called from a function with incompatible execution space\n16\n. The experimental nvcc flag\n--expt-relaxed-constexpr\nremoves this restriction\n17\n. When this flag is specified, host code can invoke a\n__device__\nconstexpr function and device code can invoke a\n__host__\nconstexpr function. nvcc will define the macro\n__CUDACC_RELAXED_CONSTEXPR__\nwhen\n--expt-relaxed-constexpr\nhas been specified. Note that a function template instantiation may not be a constexpr function even if the corresponding template is marked with the keyword\nconstexpr\n(C++11 Standard Section\n[dcl.constexpr.p6]\n).\n18.5.22.5.\nConstexpr variables\nï\nLet âVâ denote a namespace scope variable or a class static member variable that has been marked constexpr and that does not have execution space annotations (e.g.,\n__device__,\n__constant__,\n__shared__\n). V is considered to be a host code variable.\nIf V is of scalar type\n18\nother than\nlong\ndouble\nand the type is not volatile-qualified, the value of V can be directly used in device code. In addition, if V is of a non-scalar type then scalar elements of V can be used inside a constexpr\n__device__\nor\n__host__\n__device__\nfunction, if the call to the function is a constant expression\n19\n. Device source code cannot contain a reference to V or take the address of V.\nExample:\nconstexpr\nint\nxxx\n=\n10\n;\nconstexpr\nint\nyyy\n=\nxxx\n+\n4\n;\nstruct\nS1_t\n{\nstatic\nconstexpr\nint\nqqq\n=\n100\n;\n};\nconstexpr\nint\nhost_arr\n[]\n=\n{\n1\n,\n2\n,\n3\n};\nconstexpr\n__device__\nint\nget\n(\nint\nidx\n)\n{\nreturn\nhost_arr\n[\nidx\n];\n}\n__device__\nint\nfoo\n(\nint\nidx\n)\n{\nint\nv1\n=\nxxx\n+\nyyy\n+\nS1_t\n::\nqqq\n;\n// OK\nconst\nint\n&\nv2\n=\nxxx\n;\n// error: reference to host constexpr\n// variable\nconst\nint\n*\nv3\n=\n&\nxxx\n;\n// error: address of host constexpr\n// variable\nconst\nint\n&\nv4\n=\nS1_t\n::\nqqq\n;\n// error: reference to host constexpr\n// variable\nconst\nint\n*\nv5\n=\n&\nS1_t\n::\nqqq\n;\n// error: address of host constexpr\n// variable\nv1\n+=\nget\n(\n2\n);\n// OK: 'get(2)' is a constant\n// expression.\nv1\n+=\nget\n(\nidx\n);\n// error: 'get(idx)' is not a constant\n// expression\nv1\n+=\nhost_arr\n[\n2\n];\n// error: 'host_arr' does not have\n// scalar type.\nreturn\nv1\n;\n}\n18.5.22.6.\nInline namespaces\nï\nFor an input CUDA translation unit, the CUDA compiler may invoke the host compiler for compiling the host code within the translation unit. In the code passed to the host compiler, the CUDA compiler will inject additional compiler generated code, if the input CUDA translation unit contained a definition of any of the following entities:\n__global__\nfunction or function template instantiation\n__device__\n,\n__constant__\nvariables with surface or texture type\nThe compiler generated code contains a reference to the defined entity. If the entity is defined within an inline namespace and another entity of the same name and type signature is defined in an enclosing namespace, this reference may be considered ambiguous by the host compiler and host compilation will fail.\nThis limitation can be avoided by using unique names for such entities defined within an inline namespace.\nExample:\n__device__\nint\nGvar\n;\ninline\nnamespace\nN1\n{\n__device__\nint\nGvar\n;\n}\n// <-- CUDA compiler inserts a reference to \"Gvar\" at this point in the\n// translation unit. This reference will be considered ambiguous by the\n// host compiler and compilation will fail.\nExample:\ninline\nnamespace\nN1\n{\nnamespace\nN2\n{\n__device__\nint\nGvar\n;\n}\n}\nnamespace\nN2\n{\n__device__\nint\nGvar\n;\n}\n// <-- CUDA compiler inserts reference to \"::N2::Gvar\" at this point in\n// the translation unit. This reference will be considered ambiguous by\n// the host compiler and compilation will fail.\n18.5.22.6.1.\nInline unnamed namespaces\nï\nThe following entities cannot be declared in namespace scope within an inline unnamed namespace:\n__managed__\n,\n__device__\n,\n__shared__\nand\n__constant__\nvariables\n__global__\nfunction and function templates\nvariables with surface or texture type\nExample:\ninline\nnamespace\n{\nnamespace\nN2\n{\ntemplate\n<\ntypename\nT\n>\n__global__\nvoid\nfoo\n(\nvoid\n);\n// error\n__global__\nvoid\nbar\n(\nvoid\n)\n{\n}\n// error\ntemplate\n<>\n__global__\nvoid\nfoo\n<\nint\n>\n(\nvoid\n)\n{\n}\n// error\n__device__\nint\nx1b\n;\n// error\n__constant__\nint\nx2b\n;\n// error\n__shared__\nint\nx3b\n;\n// error\ntexture\n<\nint\n>\nq2\n;\n// error\nsurface\n<\nint\n>\ns2\n;\n// error\n}\n};\n18.5.22.7.\nthread_local\nï\nThe\nthread_local\nstorage specifier is not allowed in device code.\n18.5.22.8.\n__global__ functions and function templates\nï\nIf the closure type associated with a lambda expression is used in a template argument of a\n__global__\nfunction template instantiation, the lambda expression must either be defined in the immediate or nested block scope of a\n__device__\nor\n__global__\nfunction, or must be an\nextended lambda\n.\nExample:\ntemplate\n<\ntypename\nT\n>\n__global__\nvoid\nkernel\n(\nT\nin\n)\n{\n}\n__device__\nvoid\nfoo_device\n(\nvoid\n)\n{\n// All kernel instantiations in this function\n// are valid, since the lambdas are defined inside\n// a __device__ function.\nkernel\n<<<\n1\n,\n1\n>>>\n(\n[]\n__device__\n{\n}\n);\nkernel\n<<<\n1\n,\n1\n>>>\n(\n[]\n__host__\n__device__\n{\n}\n);\nkernel\n<<<\n1\n,\n1\n>>>\n(\n[]\n{\n}\n);\n}\nauto\nlam1\n=\n[]\n{\n};\nauto\nlam2\n=\n[]\n__host__\n__device__\n{\n};\nvoid\nfoo_host\n(\nvoid\n)\n{\n// OK: instantiated with closure type of an extended __device__ lambda\nkernel\n<<<\n1\n,\n1\n>>>\n(\n[]\n__device__\n{\n}\n);\n// OK: instantiated with closure type of an extended __host__ __device__\n// lambda\nkernel\n<<<\n1\n,\n1\n>>>\n(\n[]\n__host__\n__device__\n{\n}\n);\n// error: unsupported: instantiated with closure type of a lambda\n// that is not an extended lambda\nkernel\n<<<\n1\n,\n1\n>>>\n(\n[]\n{\n}\n);\n// error: unsupported: instantiated with closure type of a lambda\n// that is not an extended lambda\nkernel\n<<<\n1\n,\n1\n>>>\n(\nlam1\n);\n// error: unsupported: instantiated with closure type of a lambda\n// that is not an extended lambda\nkernel\n<<<\n1\n,\n1\n>>>\n(\nlam2\n);\n}\nA\n__global__\nfunction or function template cannot be declared as\nconstexpr\n.\nA\n__global__\nfunction or function template cannot have a parameter of type\nstd::initializer_list\nor\nva_list\n.\nA\n__global__\nfunction cannot have a parameter of rvalue reference type.\nA variadic\n__global__\nfunction template has the following restrictions:\nOnly a single pack parameter is allowed.\nThe pack parameter must be listed last in the template parameter list.\nExample:\n// ok\ntemplate\n<\ntemplate\n<\ntypename\n...\n>\nclass\nWrapper\n,\ntypename\n...\nPack\n>\n__global__\nvoid\nfoo1\n(\nWrapper\n<\nPack\n...\n>\n);\n// error: pack parameter is not last in parameter list\ntemplate\n<\ntypename\n...\nPack\n,\ntemplate\n<\ntypename\n...\n>\nclass\nWrapper\n>\n__global__\nvoid\nfoo2\n(\nWrapper\n<\nPack\n...\n>\n);\n// error: multiple parameter packs\ntemplate\n<\ntypename\n...\nPack1\n,\nint\n...\nPack2\n,\ntemplate\n<\ntypename\n...\n>\nclass\nWrapper1\n,\ntemplate\n<\nint\n...\n>\nclass\nWrapper2\n>\n__global__\nvoid\nfoo3\n(\nWrapper1\n<\nPack1\n...\n>\n,\nWrapper2\n<\nPack2\n...\n>\n);\n18.5.22.9.\n__managed__ and __shared__ variables\nï\n`__managed__\nand\n__shared__\nvariables cannot be marked with the keyword\nconstexpr\n.\n18.5.22.10.\nDefaulted functions\nï\nExecution space specifiers on a non-virtual function that is explicitly-defaulted on its first declaration are ignored by the CUDA compiler. Instead, the CUDA compiler will infer the execution space specifiers as described in\nImplicitly-declared and non-virtual explicitly-defaulted functions\n.\nExecution space specifiers are not ignored if the function is either:\nExplicitly-defaulted but not on its first declaration.\nExplicitly-defaulted and virtual.\nExample:\nstruct\nS1\n{\n// warning: __host__ annotation is ignored on a non-virtual function that\n//          is explicitly-defaulted on its first declaration\n__host__\nS1\n()\n=\ndefault\n;\n};\n__device__\nvoid\nfoo1\n()\n{\n//note: __device__ execution space is derived for S1::S1\n//       based on implicit call from within __device__ function\n//       foo1\nS1\ns1\n;\n}\nstruct\nS2\n{\n__host__\nS2\n();\n};\n//note: S2::S2 is not defaulted on its first declaration, and\n//      its execution space is fixed to __host__  based on its\n//      first declaration.\nS2\n::\nS2\n()\n=\ndefault\n;\n__device__\nvoid\nfoo2\n()\n{\n// error: call from __device__ function 'foo2' to\n//        __host__ function 'S2::S2'\nS2\ns2\n;\n}\nstruct\nS3\n{\n//note: S3::~S3 has __host__ execution space\nvirtual\n__host__\n~\nS3\n()\n=\ndefault\n;\n};\n__device__\nvoid\nfoo3\n()\n{\nS3\nqqq\n;\n}\n/*(implicit destructor call for 'qqq'):\nerror: call from a __device__ fuction 'foo3' to a\n__host__ function 'S3::~S3' */\n18.5.23.\nC++14 Features\nï\nC++14 features enabled by default by the host compiler are also supported by nvcc. Passing nvcc\n-std=c++14\nflag turns on all C++14 features and also invokes the host preprocessor, compiler and linker with the corresponding C++14 dialect option\n20\n. This section describes the restrictions on the supported C++14 features.\n18.5.23.1.\nFunctions with deduced return type\nï\nA\n__global__\nfunction cannot have a deduced return type.\nIf a\n__device__\nfunction has deduced return type, the CUDA frontend compiler will change the function declaration to have a\nvoid\nreturn type, before invoking the host compiler. This may cause issues for introspecting the deduced return type of the\n__device__\nfunction in host code. Thus, the CUDA compiler will issue compile-time errors for referencing such deduced return type outside device function bodies, except if the reference is absent when\n__CUDA_ARCH__\nis undefined.\nExamples:\n__device__\nauto\nfn1\n(\nint\nx\n)\n{\nreturn\nx\n;\n}\n__device__\ndecltype\n(\nauto\n)\nfn2\n(\nint\nx\n)\n{\nreturn\nx\n;\n}\n__device__\nvoid\ndevice_fn1\n()\n{\n// OK\nint\n(\n*\np1\n)(\nint\n)\n=\nfn1\n;\n}\n// error: referenced outside device function bodies\ndecltype\n(\nfn1\n(\n10\n))\ng1\n;\nvoid\nhost_fn1\n()\n{\n// error: referenced outside device function bodies\nint\n(\n*\np1\n)(\nint\n)\n=\nfn1\n;\nstruct\nS_local_t\n{\n// error: referenced outside device function bodies\ndecltype\n(\nfn2\n(\n10\n))\nm1\n;\nS_local_t\n()\n:\nm1\n(\n10\n)\n{\n}\n};\n}\n// error: referenced outside device function bodies\ntemplate\n<\ntypename\nT\n=\ndecltype\n(\nfn2\n)\n>\nvoid\nhost_fn2\n()\n{\n}\ntemplate\n<\ntypename\nT\n>\nstruct\nS1_t\n{\n};\n// error: referenced outside device function bodies\nstruct\nS1_derived_t\n:\nS1_t\n<\ndecltype\n(\nfn1\n)\n>\n{\n};\n18.5.23.2.\nVariable templates\nï\nA\n__device__/__constant__\nvariable template cannot have a const qualified type when using the Microsoft host compiler.\nExamples:\n// error: a __device__ variable template cannot\n// have a const qualified type on Windows\ntemplate\n<\ntypename\nT\n>\n__device__\nconst\nT\nd1\n(\n2\n);\nint\n*\nconst\nx\n=\nnullptr\n;\n// error: a __device__ variable template cannot\n// have a const qualified type on Windows\ntemplate\n<\ntypename\nT\n>\n__device__\nT\n*\nconst\nd2\n(\nx\n);\n// OK\ntemplate\n<\ntypename\nT\n>\n__device__\nconst\nT\n*\nd3\n;\n__device__\nvoid\nfn\n()\n{\nint\nt1\n=\nd1\n<\nint\n>\n;\nint\n*\nconst\nt2\n=\nd2\n<\nint\n>\n;\nconst\nint\n*\nt3\n=\nd3\n<\nint\n>\n;\n}\n18.5.24.\nC++17 Features\nï\nC++17 features enabled by default by the host compiler are also supported by nvcc. Passing nvcc\n-std=c++17\nflag turns on all C++17 features and also invokes the host preprocessor, compiler and linker with the corresponding C++17 dialect option\n21\n. This section describes the restrictions on the supported C++17 features.\n18.5.24.1.\nInline Variable\nï\nA namespace scope inline variable declared with\n__device__\nor\n__constant__\nor\n__managed__\nmemory space specifier must have internal linkage, if the code is compiled with nvcc in whole program compilation mode.\nExamples:\ninline\n__device__\nint\nxxx\n;\n//error when compiled with nvcc in\n//whole program compilation mode.\n//ok when compiled with nvcc in\n//separate compilation mode.\ninline\n__shared__\nint\nyyy0\n;\n// ok.\nstatic\ninline\n__device__\nint\nyyy\n;\n// ok: internal linkage\nnamespace\n{\ninline\n__device__\nint\nzzz\n;\n// ok: internal linkage\n}\nWhen using g++ host compiler, an inline variable declared with\n__managed__\nmemory space specifier may not be visible to the debugger.\n18.5.24.2.\nStructured Binding\nï\nA structured binding cannot be declared with a variable memory space specifier.\nExample:\nstruct\nS\n{\nint\nx\n;\nint\ny\n;\n};\n__device__\nauto\n[\na1\n,\nb1\n]\n=\nS\n{\n4\n,\n5\n};\n// error\n18.5.25.\nC++20 Features\nï\nC++20 features enabled by default by the host compiler are also supported by nvcc. Passing nvcc\n-std=c++20\nflag turns on all C++20 features and also invokes the host preprocessor, compiler and linker with the corresponding C++20 dialect option\n22\n. This section describes the restrictions on the supported C++20 features.\n18.5.25.1.\nModule support\nï\nModules are not supported in CUDA C++, in either host or device code. Uses of the\nmodule\n,\nexport\nand\nimport\nkeywords are diagnosed as errors.\n18.5.25.2.\nCoroutine support\nï\nCoroutines are not supported in device code. Uses of the\nco_await\n,\nco_yield\nand\nco_return\nkeywords in the scope of a device function are diagnosed as error during device compilation.\n18.5.25.3.\nThree-way comparison operator\nï\nThe three-way comparison operator is supported in both host and device code, but some uses implicitly rely on functionality from the Standard Template Library provided by the host implementation. Uses of those operators may require specifying the flag\n--expt-relaxed-constexpr\nto silence warnings and the functionality requires that the host implementation satisfies the requirements of device code.\nExample:\n#include\n<compare>\nstruct\nS\n{\nint\nx\n,\ny\n,\nz\n;\nauto\noperator\n<=>\n(\nconst\nS\n&\nrhs\n)\nconst\n=\ndefault\n;\n__host__\n__device__\nbool\noperator\n<=>\n(\nint\nrhs\n)\nconst\n{\nreturn\nfalse\n;\n}\n};\n__host__\n__device__\nbool\nf\n(\nS\na\n,\nS\nb\n)\n{\nif\n(\na\n<=>\n1\n)\n// ok, calls a user-defined host-device overload\nreturn\ntrue\n;\nreturn\na\n<\nb\n;\n// call to an implicitly-declared function and requires\n// a device-compatible std::strong_ordering implementation\n}\n18.5.25.4.\nConsteval functions\nï\nOrdinarily, cross execution space calls are not allowed, and cause a compiler diagnostic (warning or error). This restriction does not apply when the called function is declared with the\nconsteval\nspecifier. Thus, a\n__device__\nor\n__global__\nfunction can call a\n__host__\nconsteval\nfunction, and a\n__host__\nfunction can call a\n__device__\nconsteval\nfunction.\nExample:\nnamespace\nN1\n{\n//consteval host function\nconsteval\nint\nhcallee\n()\n{\nreturn\n10\n;\n}\n__device__\nint\ndfunc\n()\n{\nreturn\nhcallee\n();\n/* OK */\n}\n__global__\nvoid\ngfunc\n()\n{\n(\nvoid\n)\nhcallee\n();\n/* OK */\n}\n__host__\n__device__\nint\nhdfunc\n()\n{\nreturn\nhcallee\n();\n/* OK */\n}\nint\nhfunc\n()\n{\nreturn\nhcallee\n();\n/* OK */\n}\n}\n// namespace N1\nnamespace\nN2\n{\n//consteval device function\nconsteval\n__device__\nint\ndcallee\n()\n{\nreturn\n10\n;\n}\n__device__\nint\ndfunc\n()\n{\nreturn\ndcallee\n();\n/* OK */\n}\n__global__\nvoid\ngfunc\n()\n{\n(\nvoid\n)\ndcallee\n();\n/* OK */\n}\n__host__\n__device__\nint\nhdfunc\n()\n{\nreturn\ndcallee\n();\n/* OK */\n}\nint\nhfunc\n()\n{\nreturn\ndcallee\n();\n/* OK */\n}\n}\n18.6.\nPolymorphic Function Wrappers\nï\nA polymorphic function wrapper class template\nnvstd::function\nis provided in the\nnvfunctional\nheader. Instances of this class template can be used to store, copy and invoke any callable target, e.g., lambda expressions.\nnvstd::function\ncan be used in both host and device code.\nExample:\n#include\n<nvfunctional>\n__device__\nint\nfoo_d\n()\n{\nreturn\n1\n;\n}\n__host__\n__device__\nint\nfoo_hd\n()\n{\nreturn\n2\n;\n}\n__host__\nint\nfoo_h\n()\n{\nreturn\n3\n;\n}\n__global__\nvoid\nkernel\n(\nint\n*\nresult\n)\n{\nnvstd\n::\nfunction\n<\nint\n()\n>\nfn1\n=\nfoo_d\n;\nnvstd\n::\nfunction\n<\nint\n()\n>\nfn2\n=\nfoo_hd\n;\nnvstd\n::\nfunction\n<\nint\n()\n>\nfn3\n=\n[]()\n{\nreturn\n10\n;\n};\n*\nresult\n=\nfn1\n()\n+\nfn2\n()\n+\nfn3\n();\n}\n__host__\n__device__\nvoid\nhostdevice_func\n(\nint\n*\nresult\n)\n{\nnvstd\n::\nfunction\n<\nint\n()\n>\nfn1\n=\nfoo_hd\n;\nnvstd\n::\nfunction\n<\nint\n()\n>\nfn2\n=\n[]()\n{\nreturn\n10\n;\n};\n*\nresult\n=\nfn1\n()\n+\nfn2\n();\n}\n__host__\nvoid\nhost_func\n(\nint\n*\nresult\n)\n{\nnvstd\n::\nfunction\n<\nint\n()\n>\nfn1\n=\nfoo_h\n;\nnvstd\n::\nfunction\n<\nint\n()\n>\nfn2\n=\nfoo_hd\n;\nnvstd\n::\nfunction\n<\nint\n()\n>\nfn3\n=\n[]()\n{\nreturn\n10\n;\n};\n*\nresult\n=\nfn1\n()\n+\nfn2\n()\n+\nfn3\n();\n}\nInstances of\nnvstd::function\nin host code cannot be initialized with the address of a\n__device__\nfunction or with a functor whose\noperator()\nis a\n__device__\nfunction. Instances of\nnvstd::function\nin device code cannot be initialized with the address of a\n__host__\nfunction or with a functor whose\noperator()\nis a\n__host__\nfunction.\nnvstd::function\ninstances cannot be passed from host code to device code (and vice versa) at run time.\nnvstd::function\ncannot be used in the parameter type of a\n__global__\nfunction, if the\n__global__\nfunction is launched from host code.\nExample:\n#include\n<nvfunctional>\n__device__\nint\nfoo_d\n()\n{\nreturn\n1\n;\n}\n__host__\nint\nfoo_h\n()\n{\nreturn\n3\n;\n}\nauto\nlam_h\n=\n[]\n{\nreturn\n0\n;\n};\n__global__\nvoid\nk\n(\nvoid\n)\n{\n// error: initialized with address of __host__ function\nnvstd\n::\nfunction\n<\nint\n()\n>\nfn1\n=\nfoo_h\n;\n// error: initialized with address of functor with\n// __host__ operator() function\nnvstd\n::\nfunction\n<\nint\n()\n>\nfn2\n=\nlam_h\n;\n}\n__global__\nvoid\nkern\n(\nnvstd\n::\nfunction\n<\nint\n()\n>\nf1\n)\n{\n}\nvoid\nfoo\n(\nvoid\n)\n{\n// error: initialized with address of __device__ function\nnvstd\n::\nfunction\n<\nint\n()\n>\nfn1\n=\nfoo_d\n;\nauto\nlam_d\n=\n[\n=\n]\n__device__\n{\nreturn\n1\n;\n};\n// error: initialized with address of functor with\n// __device__ operator() function\nnvstd\n::\nfunction\n<\nint\n()\n>\nfn2\n=\nlam_d\n;\n// error: passing nvstd::function from host to device\nkern\n<<<\n1\n,\n1\n>>>\n(\nfn2\n);\n}\nnvstd::function\nis defined in the\nnvfunctional\nheader as follows:\nnamespace\nnvstd\n{\ntemplate\n<\nclass\n_RetType\n,\nclass\n...\n_ArgTypes\n>\nclass\nfunction\n<\n_RetType\n(\n_ArgTypes\n...)\n>\n{\npublic\n:\n// constructors\n__device__\n__host__\nfunction\n()\nnoexcept\n;\n__device__\n__host__\nfunction\n(\nnullptr_t\n)\nnoexcept\n;\n__device__\n__host__\nfunction\n(\nconst\nfunction\n&\n);\n__device__\n__host__\nfunction\n(\nfunction\n&&\n);\ntemplate\n<\nclass\n_F\n>\n__device__\n__host__\nfunction\n(\n_F\n);\n// destructor\n__device__\n__host__\n~\nfunction\n();\n// assignment operators\n__device__\n__host__\nfunction\n&\noperator\n=\n(\nconst\nfunction\n&\n);\n__device__\n__host__\nfunction\n&\noperator\n=\n(\nfunction\n&&\n);\n__device__\n__host__\nfunction\n&\noperator\n=\n(\nnullptr_t\n);\n__device__\n__host__\nfunction\n&\noperator\n=\n(\n_F\n&&\n);\n// swap\n__device__\n__host__\nvoid\nswap\n(\nfunction\n&\n)\nnoexcept\n;\n// function capacity\n__device__\n__host__\nexplicit\noperator\nbool\n()\nconst\nnoexcept\n;\n// function invocation\n__device__\n_RetType\noperator\n()(\n_ArgTypes\n...)\nconst\n;\n};\n// null pointer comparisons\ntemplate\n<\nclass\n_R\n,\nclass\n...\n_ArgTypes\n>\n__device__\n__host__\nbool\noperator\n==\n(\nconst\nfunction\n<\n_R\n(\n_ArgTypes\n...)\n>&\n,\nnullptr_t\n)\nnoexcept\n;\ntemplate\n<\nclass\n_R\n,\nclass\n...\n_ArgTypes\n>\n__device__\n__host__\nbool\noperator\n==\n(\nnullptr_t\n,\nconst\nfunction\n<\n_R\n(\n_ArgTypes\n...)\n>&\n)\nnoexcept\n;\ntemplate\n<\nclass\n_R\n,\nclass\n...\n_ArgTypes\n>\n__device__\n__host__\nbool\noperator\n!=\n(\nconst\nfunction\n<\n_R\n(\n_ArgTypes\n...)\n>&\n,\nnullptr_t\n)\nnoexcept\n;\ntemplate\n<\nclass\n_R\n,\nclass\n...\n_ArgTypes\n>\n__device__\n__host__\nbool\noperator\n!=\n(\nnullptr_t\n,\nconst\nfunction\n<\n_R\n(\n_ArgTypes\n...)\n>&\n)\nnoexcept\n;\n// specialized algorithms\ntemplate\n<\nclass\n_R\n,\nclass\n...\n_ArgTypes\n>\n__device__\n__host__\nvoid\nswap\n(\nfunction\n<\n_R\n(\n_ArgTypes\n...)\n>&\n,\nfunction\n<\n_R\n(\n_ArgTypes\n...)\n>&\n);\n}\n18.7.\nExtended Lambdas\nï\nThe nvcc flag\n'--extended-lambda'\nallows explicit execution space annotations in a lambda expression\n23\n. The execution space annotations should be present after the âlambda-introducerâ and before the optional âlambda-declaratorâ. nvcc will define the macro\n__CUDACC_EXTENDED_LAMBDA__\nwhen the\n'--extended-lambda'\nflag has been specified.\nAn âextended\n__device__\nlambdaâ is a lambda expression that is annotated explicitly with â\n__device__\nâ, and is defined within the immediate or nested block scope of a\n__host__\nor\n__host__\n__device__\nfunction.\nAn âextended\n__host__\n__device__\nlambdaâ is a lambda expression that is annotated explicitly with both â\n__host__\nâ and â\n__device__\nâ, and is defined within the immediate or nested block scope of a\n__host__\nor\n__host__\n__device__\nfunction.\nAn âextended lambdaâ denotes either an extended\n__device__\nlambda or an extended\n__host__\n__device__\nlambda. Extended lambdas can be used in the type arguments of\n__global__ function template instantiation\n.\nIf the execution space annotations are not explicitly specified, they are computed based on the scopes enclosing the closure class associated with the lambda, as described in the section on C++11 support. The execution space annotations are applied to all methods of the closure class associated with the lambda.\nExample:\nvoid\nfoo_host\n(\nvoid\n)\n{\n// not an extended lambda: no explicit execution space annotations\nauto\nlam1\n=\n[]\n{\n};\n// extended __device__ lambda\nauto\nlam2\n=\n[]\n__device__\n{\n};\n// extended __host__ __device__ lambda\nauto\nlam3\n=\n[]\n__host__\n__device__\n{\n};\n// not an extended lambda: explicitly annotated with only '__host__'\nauto\nlam4\n=\n[]\n__host__\n{\n};\n}\n__host__\n__device__\nvoid\nfoo_host_device\n(\nvoid\n)\n{\n// not an extended lambda: no explicit execution space annotations\nauto\nlam1\n=\n[]\n{\n};\n// extended __device__ lambda\nauto\nlam2\n=\n[]\n__device__\n{\n};\n// extended __host__ __device__ lambda\nauto\nlam3\n=\n[]\n__host__\n__device__\n{\n};\n// not an extended lambda: explicitly annotated with only '__host__'\nauto\nlam4\n=\n[]\n__host__\n{\n};\n}\n__device__\nvoid\nfoo_device\n(\nvoid\n)\n{\n// none of the lambdas within this function are extended lambdas,\n// because the enclosing function is not a __host__ or __host__ __device__\n// function.\nauto\nlam1\n=\n[]\n{\n};\nauto\nlam2\n=\n[]\n__device__\n{\n};\nauto\nlam3\n=\n[]\n__host__\n__device__\n{\n};\nauto\nlam4\n=\n[]\n__host__\n{\n};\n}\n// lam1 and lam2 are not extended lambdas because they are not defined\n// within a __host__ or __host__ __device__ function.\nauto\nlam1\n=\n[]\n{\n};\nauto\nlam2\n=\n[]\n__host__\n__device__\n{\n};\n18.7.1.\nExtended Lambda Type Traits\nï\nThe compiler provides type traits to detect closure types for extended lambdas at compile time:\n__nv_is_extended_device_lambda_closure_type(type)\n: If âtypeâ is the closure class created for an extended\n__device__\nlambda, then the trait is true, otherwise it is false.\n__nv_is_extended_device_lambda_with_preserved_return_type(type)\n: If âtypeâ is the closure class created for an extended\n__device__\nlambda and the lambda is defined with trailing return type (with restriction), then the trait is true, otherwise it is false. If the trailing return type definition refers to any lambda parameter name, the return type is not preserved.\n__nv_is_extended_host_device_lambda_closure_type(type)\n: If âtypeâ is the closure class created for an extended\n__host__\n__device__\nlambda, then the trait is true, otherwise it is false.\nThese traits can be used in all compilation modes, irrespective of whether lambdas or extended lambdas are enabled\n24\n.\nExample:\n#define IS_D_LAMBDA(X) __nv_is_extended_device_lambda_closure_type(X)\n#define IS_DPRT_LAMBDA(X) __nv_is_extended_device_lambda_with_preserved_return_type(X)\n#define IS_HD_LAMBDA(X) __nv_is_extended_host_device_lambda_closure_type(X)\nauto\nlam0\n=\n[]\n__host__\n__device__\n{\n};\nvoid\nfoo\n(\nvoid\n)\n{\nauto\nlam1\n=\n[]\n{\n};\nauto\nlam2\n=\n[]\n__device__\n{\n};\nauto\nlam3\n=\n[]\n__host__\n__device__\n{\n};\nauto\nlam4\n=\n[]\n__device__\n()\n-->\ndouble\n{\nreturn\n3.14\n;\n}\nauto\nlam5\n=\n[]\n__device__\n(\nint\nx\n)\n-->\ndecltype\n(\n&\nx\n)\n{\nreturn\n0\n;\n}\n// lam0 is not an extended lambda (since defined outside function scope)\nstatic_assert\n(\n!\nIS_D_LAMBDA\n(\ndecltype\n(\nlam0\n)),\n\"\"\n);\nstatic_assert\n(\n!\nIS_DPRT_LAMBDA\n(\ndecltype\n(\nlam0\n)),\n\"\"\n);\nstatic_assert\n(\n!\nIS_HD_LAMBDA\n(\ndecltype\n(\nlam0\n)),\n\"\"\n);\n// lam1 is not an extended lambda (since no execution space annotations)\nstatic_assert\n(\n!\nIS_D_LAMBDA\n(\ndecltype\n(\nlam1\n)),\n\"\"\n);\nstatic_assert\n(\n!\nIS_DPRT_LAMBDA\n(\ndecltype\n(\nlam1\n)),\n\"\"\n);\nstatic_assert\n(\n!\nIS_HD_LAMBDA\n(\ndecltype\n(\nlam1\n)),\n\"\"\n);\n// lam2 is an extended __device__ lambda\nstatic_assert\n(\nIS_D_LAMBDA\n(\ndecltype\n(\nlam2\n)),\n\"\"\n);\nstatic_assert\n(\n!\nIS_DPRT_LAMBDA\n(\ndecltype\n(\nlam2\n)),\n\"\"\n);\nstatic_assert\n(\n!\nIS_HD_LAMBDA\n(\ndecltype\n(\nlam2\n)),\n\"\"\n);\n// lam3 is an extended __host__ __device__ lambda\nstatic_assert\n(\n!\nIS_D_LAMBDA\n(\ndecltype\n(\nlam3\n)),\n\"\"\n);\nstatic_assert\n(\n!\nIS_DPRT_LAMBDA\n(\ndecltype\n(\nlam3\n)),\n\"\"\n);\nstatic_assert\n(\nIS_HD_LAMBDA\n(\ndecltype\n(\nlam3\n)),\n\"\"\n);\n// lam4 is an extended __device__ lambda with preserved return type\nstatic_assert\n(\nIS_D_LAMBDA\n(\ndecltype\n(\nlam4\n)),\n\"\"\n);\nstatic_assert\n(\nIS_DPRT_LAMBDA\n(\ndecltype\n(\nlam4\n)),\n\"\"\n);\nstatic_assert\n(\n!\nIS_HD_LAMBDA\n(\ndecltype\n(\nlam4\n)),\n\"\"\n);\n// lam5 is not an extended __device__ lambda with preserved return type\n// because it references the operator()'s parameter types in the trailing return type.\nstatic_assert\n(\nIS_D_LAMBDA\n(\ndecltype\n(\nlam5\n)),\n\"\"\n);\nstatic_assert\n(\n!\nIS_DPRT_LAMBDA\n(\ndecltype\n(\nlam5\n)),\n\"\"\n);\nstatic_assert\n(\n!\nIS_HD_LAMBDA\n(\ndecltype\n(\nlam5\n)),\n\"\"\n);\n}\n18.7.2.\nExtended Lambda Restrictions\nï\nThe CUDA compiler will replace an extended lambda expression with an instance of a placeholder type defined in namespace scope, before invoking the host compiler. The template argument of the placeholder type requires taking the address of a function enclosing the original extended lambda expression. This is required for the correct execution of any\n__global__\nfunction template whose template argument involves the closure type of an extended lambda. The\nenclosing function\nis computed as follows.\nBy definition, the extended lambda is present within the immediate or nested block scope of a\n__host__\nor\n__host__\n__device__\nfunction. If this function is not the\noperator()\nof a lambda expression, then it is considered the enclosing function for the extended lambda. Otherwise, the extended lambda is defined within the immediate or nested block scope of the\noperator()\nof one or more enclosing lambda expressions. If the outermost such lambda expression is defined in the immediate or nested block scope of a function\nF\n, then\nF\nis the computed enclosing function, else the enclosing function does not exist.\nExample:\nvoid\nfoo\n(\nvoid\n)\n{\n// enclosing function for lam1 is \"foo\"\nauto\nlam1\n=\n[]\n__device__\n{\n};\nauto\nlam2\n=\n[]\n{\nauto\nlam3\n=\n[]\n{\n// enclosing function for lam4 is \"foo\"\nauto\nlam4\n=\n[]\n__host__\n__device__\n{\n};\n};\n};\n}\nauto\nlam6\n=\n[]\n{\n// enclosing function for lam7 does not exist\nauto\nlam7\n=\n[]\n__host__\n__device__\n{\n};\n};\nHere are the restrictions on extended lambdas:\nAn extended lambda cannot be defined inside another extended lambda expression.\nExample:\nvoid\nfoo\n(\nvoid\n)\n{\nauto\nlam1\n=\n[]\n__host__\n__device__\n{\n// error: extended lambda defined within another extended lambda\nauto\nlam2\n=\n[]\n__host__\n__device__\n{\n};\n};\n}\nAn extended lambda cannot be defined inside a generic lambda expression.\nExample:\nvoid\nfoo\n(\nvoid\n)\n{\nauto\nlam1\n=\n[]\n(\nauto\n)\n{\n// error: extended lambda defined within a generic lambda\nauto\nlam2\n=\n[]\n__host__\n__device__\n{\n};\n};\n}\nIf an extended lambda is defined within the immediate or nested block scope of one or more nested lambda expression, the outermost such lambda expression must be defined inside the immediate or nested block scope of a function.\nExample:\nauto\nlam1\n=\n[]\n{\n// error: outer enclosing lambda is not defined within a\n// non-lambda-operator() function.\nauto\nlam2\n=\n[]\n__host__\n__device__\n{\n};\n};\nThe enclosing function for the extended lambda must be named and its address can be taken. If the enclosing function is a class member, then the following conditions must be satisfied:\nAll classes enclosing the member function must have a name.\nThe member function must not have private or protected access within its parent class.\nAll enclosing classes must not have private or protected access within their respective parent classes.\nExample:\nvoid\nfoo\n(\nvoid\n)\n{\n// OK\nauto\nlam1\n=\n[]\n__device__\n{\nreturn\n0\n;\n};\n{\n// OK\nauto\nlam2\n=\n[]\n__device__\n{\nreturn\n0\n;\n};\n// OK\nauto\nlam3\n=\n[]\n__device__\n__host__\n{\nreturn\n0\n;\n};\n}\n}\nstruct\nS1_t\n{\nS1_t\n(\nvoid\n)\n{\n// Error: cannot take address of enclosing function\nauto\nlam4\n=\n[]\n__device__\n{\nreturn\n0\n;\n};\n}\n};\nclass\nC0_t\n{\nvoid\nfoo\n(\nvoid\n)\n{\n// Error: enclosing function has private access in parent class\nauto\ntemp1\n=\n[]\n__device__\n{\nreturn\n10\n;\n};\n}\nstruct\nS2_t\n{\nvoid\nfoo\n(\nvoid\n)\n{\n// Error: enclosing class S2_t has private access in its\n// parent class\nauto\ntemp1\n=\n[]\n__device__\n{\nreturn\n10\n;\n};\n}\n};\n};\nIt must be possible to take the address of the enclosing routine unambiguously, at the point where the extended lambda has been defined. This may not be feasible in some cases e.g. when a class typedef shadows a template type argument of the same name.\nExample:\ntemplate\n<\ntypename\n>\nstruct\nA\n{\ntypedef\nvoid\nBar\n;\nvoid\ntest\n();\n};\ntemplate\n<>\nstruct\nA\n<\nvoid\n>\n{\n};\ntemplate\n<\ntypename\nBar\n>\nvoid\nA\n<\nBar\n>::\ntest\n()\n{\n/* In code sent to host compiler, nvcc will inject an\naddress expression here, of the form:\n(void (A< Bar> ::*)(void))(&A::test))\nHowever, the class typedef 'Bar' (to void) shadows the\ntemplate argument 'Bar', causing the address\nexpression in A<int>::test to actually refer to:\n(void (A< void> ::*)(void))(&A::test))\n..which doesn't take the address of the enclosing\nroutine 'A<int>::test' correctly.\n*/\nauto\nlam1\n=\n[]\n__host__\n__device__\n{\nreturn\n4\n;\n};\n}\nint\nmain\n()\n{\nA\n<\nint\n>\nxxx\n;\nxxx\n.\ntest\n();\n}\nAn extended lambda cannot be defined in a class that is local to a function.\nExample:\nvoid\nfoo\n(\nvoid\n)\n{\nstruct\nS1_t\n{\nvoid\nbar\n(\nvoid\n)\n{\n// Error: bar is member of a class that is local to a function.\nauto\nlam4\n=\n[]\n__host__\n__device__\n{\nreturn\n0\n;\n};\n}\n};\n}\nThe enclosing function for an extended lambda cannot have deduced return type.\nExample:\nauto\nfoo\n(\nvoid\n)\n{\n// Error: the return type of foo is deduced.\nauto\nlam1\n=\n[]\n__host__\n__device__\n{\nreturn\n0\n;\n};\n}\n__host__ __device__ extended lambdas cannot be generic lambdas.\nExample:\nvoid\nfoo\n(\nvoid\n)\n{\n// Error: __host__ __device__ extended lambdas cannot be\n// generic lambdas.\nauto\nlam1\n=\n[]\n__host__\n__device__\n(\nauto\ni\n)\n{\nreturn\ni\n;\n};\n// Error: __host__ __device__ extended lambdas cannot be\n// generic lambdas.\nauto\nlam2\n=\n[]\n__host__\n__device__\n(\nauto\n...\ni\n)\n{\nreturn\nsizeof\n...(\ni\n);\n};\n}\nIf the enclosing function is an instantiation of a function template or a member function template, and/or the function is a member of a class template, the template(s) must satisfy the following constraints:\nThe template must have at most one variadic parameter, and it must be listed last in the template parameter list.\nThe template parameters must be named.\nThe template instantiation argument types cannot involve types that are either local to a function (except for closure types for extended lambdas), or are private or protected class members.\nExample:\ntemplate\n<\ntypename\nT\n>\n__global__\nvoid\nkern\n(\nT\nin\n)\n{\nin\n();\n}\ntemplate\n<\ntypename\n...\nT\n>\nstruct\nfoo\n{};\ntemplate\n<\ntemplate\n<\ntypename\n...\n>\nclass\nT\n,\ntypename\n...\nP1\n,\ntypename\n...\nP2\n>\nvoid\nbar1\n(\nconst\nT\n<\nP1\n...\n>\n,\nconst\nT\n<\nP2\n...\n>\n)\n{\n// Error: enclosing function has multiple parameter packs\nauto\nlam1\n=\n[]\n__device__\n{\nreturn\n10\n;\n};\n}\ntemplate\n<\ntemplate\n<\ntypename\n...\n>\nclass\nT\n,\ntypename\n...\nP1\n,\ntypename\nT2\n>\nvoid\nbar2\n(\nconst\nT\n<\nP1\n...\n>\n,\nT2\n)\n{\n// Error: for enclosing function, the\n// parameter pack is not last in the template parameter list.\nauto\nlam1\n=\n[]\n__device__\n{\nreturn\n10\n;\n};\n}\ntemplate\n<\ntypename\nT\n,\nT\n>\nvoid\nbar3\n(\nvoid\n)\n{\n// Error: for enclosing function, the second template\n// parameter is not named.\nauto\nlam1\n=\n[]\n__device__\n{\nreturn\n10\n;\n};\n}\nint\nmain\n()\n{\nfoo\n<\nchar\n,\nint\n,\nfloat\n>\nf1\n;\nfoo\n<\nchar\n,\nint\n>\nf2\n;\nbar1\n(\nf1\n,\nf2\n);\nbar2\n(\nf1\n,\n10\n);\nbar3\n<\nint\n,\n10\n>\n();\n}\nExample:\ntemplate\n<\ntypename\nT\n>\n__global__\nvoid\nkern\n(\nT\nin\n)\n{\nin\n();\n}\ntemplate\n<\ntypename\nT\n>\nvoid\nbar4\n(\nvoid\n)\n{\nauto\nlam1\n=\n[]\n__device__\n{\nreturn\n10\n;\n};\nkern\n<<<\n1\n,\n1\n>>>\n(\nlam1\n);\n}\nstruct\nC1_t\n{\nstruct\nS1_t\n{\n};\nfriend\nint\nmain\n(\nvoid\n);\n};\nint\nmain\n()\n{\nstruct\nS1_t\n{\n};\n// Error: enclosing function for device lambda in bar4\n// is instantiated with a type local to main.\nbar4\n<\nS1_t\n>\n();\n// Error: enclosing function for device lambda in bar4\n// is instantiated with a type that is a private member\n// of a class.\nbar4\n<\nC1_t\n::\nS1_t\n>\n();\n}\nWith Visual Studio host compilers, the enclosing function must have external linkage. The restriction is present because this host compiler does not support using the address of non-extern linkage functions as template arguments, which is needed by the CUDA compiler transformations to support extended lambdas.\nWith Visual Studio host compilers, an extended lambda shall not be defined within the body of an âif-constexprâ block.\nAn extended lambda has the following restrictions on captured variables:\nIn the code sent to the host compiler, the variable may be passed by value to a sequence of helper functions before being used to direct-initialize the field of the class type used to represent the closure type for the extended lambda\n25\n.\nA variable can only be captured by value.\nA variable of array type cannot be captured if the number of array dimensions is greater than 7.\nFor a variable of array type, in the code sent to the host compiler, the closure typeâs array field is first default-initialized, and then each element of the array field is copy-assigned from the corresponding element of the captured array variable. Therefore, the array element type must be default-constructible and copy-assignable in host code.\nA function parameter that is an element of a variadic argument pack cannot be captured.\nThe type of the captured variable cannot involve types that are either local to a function (except for closure types of extended lambdas), or are private or protected class members.\nFor a __host__ __device__ extended lambda, the types used in the return or parameter types of the lambda expressionâs\noperator()\ncannot involve types that are either local to a function (except for closure types of extended lambdas), or are private or protected class members.\nInit-capture is not supported for __host__ __device__ extended lambdas. Init-capture is supported for __device__ extended lambdas, except when the init-capture is of array type or of type\nstd::initializer_list\n.\nThe function call operator for an extended lambda is not constexpr. The closure type for an extended lambda is not a literal type. The constexpr and consteval specifier cannot be used in the declaration of an extended lambda.\nA variable cannot be implicitly captured inside an if-constexpr block lexically nested inside an extended lambda, unless it has already been implicitly captured earlier outside the if-constexpr block or appears in the explicit capture list for the extended lambda (see example below).\nExample\nvoid\nfoo\n(\nvoid\n)\n{\n// OK: an init-capture is allowed for an\n// extended __device__ lambda.\nauto\nlam1\n=\n[\nx\n=\n1\n]\n__device__\n()\n{\nreturn\nx\n;\n};\n// Error: an init-capture is not allowed for\n// an extended __host__ __device__ lambda.\nauto\nlam2\n=\n[\nx\n=\n1\n]\n__host__\n__device__\n()\n{\nreturn\nx\n;\n};\nint\na\n=\n1\n;\n// Error: an extended __device__ lambda cannot capture\n// variables by reference.\nauto\nlam3\n=\n[\n&\na\n]\n__device__\n()\n{\nreturn\na\n;\n};\n// Error: by-reference capture is not allowed\n// for an extended __device__ lambda.\nauto\nlam4\n=\n[\n&\nx\n=\na\n]\n__device__\n()\n{\nreturn\nx\n;\n};\nstruct\nS1_t\n{\n};\nS1_t\ns1\n;\n// Error: a type local to a function cannot be used in the type\n// of a captured variable.\nauto\nlam6\n=\n[\ns1\n]\n__device__\n()\n{\n};\n// Error: an init-capture cannot be of type std::initializer_list.\nauto\nlam7\n=\n[\nx\n=\n{\n11\n}]\n__device__\n()\n{\n};\nstd\n::\ninitializer_list\n<\nint\n>\nb\n=\n{\n11\n,\n22\n,\n33\n};\n// Error: an init-capture cannot be of type std::initializer_list.\nauto\nlam8\n=\n[\nx\n=\nb\n]\n__device__\n()\n{\n};\n// Error scenario (lam9) and supported scenarios (lam10, lam11)\n// for capture within 'if-constexpr' block\nint\nyyy\n=\n4\n;\nauto\nlam9\n=\n[\n=\n]\n__device__\n{\nint\nresult\n=\n0\n;\nif\nconstexpr\n(\nfalse\n)\n{\n//Error: An extended __device__ lambda cannot first-capture\n//      'yyy' in constexpr-if context\nresult\n+=\nyyy\n;\n}\nreturn\nresult\n;\n};\nauto\nlam10\n=\n[\nyyy\n]\n__device__\n{\nint\nresult\n=\n0\n;\nif\nconstexpr\n(\nfalse\n)\n{\n//OK: 'yyy' already listed in explicit capture list for the extended lambda\nresult\n+=\nyyy\n;\n}\nreturn\nresult\n;\n};\nauto\nlam11\n=\n[\n=\n]\n__device__\n{\nint\nresult\n=\nyyy\n;\nif\nconstexpr\n(\nfalse\n)\n{\n//OK: 'yyy' already implicit captured outside the 'if-constexpr' block\nresult\n+=\nyyy\n;\n}\nreturn\nresult\n;\n};\n}\nWhen parsing a function, the CUDA compiler assigns a counter value to each extended lambda within that function. This counter value is used in the substituted named type passed to the host compiler. Hence, whether or not an extended lambda is defined within a function should not depend on a particular value of\n__CUDA_ARCH__\n, or on\n__CUDA_ARCH__\nbeing undefined.\nExample\ntemplate\n<\ntypename\nT\n>\n__global__\nvoid\nkernel\n(\nT\nin\n)\n{\nin\n();\n}\n__host__\n__device__\nvoid\nfoo\n(\nvoid\n)\n{\n// Error: the number and relative declaration\n// order of extended lambdas depends on\n// __CUDA_ARCH__\n#if defined(__CUDA_ARCH__)\nauto\nlam1\n=\n[]\n__device__\n{\nreturn\n0\n;\n};\nauto\nlam1b\n=\n[]\n__host___\n__device__\n{\nreturn\n10\n;\n};\n#endif\nauto\nlam2\n=\n[]\n__device__\n{\nreturn\n4\n;\n};\nkernel\n<<<\n1\n,\n1\n>>>\n(\nlam2\n);\n}\nAs described above, the CUDA compiler replaces a\n__device__\nextended lambda defined in a host function with a placeholder type defined in namespace scope. Unless the trait\n__nv_is_extended_device_lambda_with_preserved_return_type()\nreturns true for the closure type of the extended lambda, the placeholder type does not define a\noperator()\nfunction equivalent to the original lambda declaration. An attempt to determine the return type or parameter types of the\noperator()\nfunction of such a lambda may therefore work incorrectly in host code, as the code processed by the host compiler will be semantically different than the input code processed by the CUDA compiler. However, it is OK to introspect the return type or parameter types of the\noperator()\nfunction within device code. Note that this restriction does not apply to\n__host__\n__device__\nextended lambdas, or to\n__device__\nextended lambdas for which the trait\n__nv_is_extended_device_lambda_with_preserved_return_type()\nreturns true.\nExample\n#include\n<type_traits>\nconst\nchar\n&\ngetRef\n(\nconst\nchar\n*\np\n)\n{\nreturn\n*\np\n;\n}\nvoid\nfoo\n(\nvoid\n)\n{\nauto\nlam1\n=\n[]\n__device__\n{\nreturn\n\"10\"\n;\n};\n// Error: attempt to extract the return type\n// of a __device__ lambda in host code\nstd\n::\nresult_of\n<\ndecltype\n(\nlam1\n)()\n>::\ntype\nxx1\n=\n\"abc\"\n;\nauto\nlam2\n=\n[]\n__host__\n__device__\n{\nreturn\n\"10\"\n;\n};\n// OK : lam2 represents a __host__ __device__ extended lambda\nstd\n::\nresult_of\n<\ndecltype\n(\nlam2\n)()\n>::\ntype\nxx2\n=\n\"abc\"\n;\nauto\nlam3\n=\n[]\n__device__\n()\n->\nconst\nchar\n*\n{\nreturn\n\"10\"\n;\n};\n// OK : lam3 represents a __device__ extended lambda with preserved return type\nstd\n::\nresult_of\n<\ndecltype\n(\nlam3\n)()\n>::\ntype\nxx2\n=\n\"abc\"\n;\nstatic_assert\n(\nstd\n::\nis_same_v\n<\nstd\n::\nresult_of\n<\ndecltype\n(\nlam3\n)()\n>::\ntype\n,\nconst\nchar\n*>\n);\nauto\nlam4\n=\n[]\n__device__\n(\nchar\nx\n)\n->\ndecltype\n(\ngetRef\n(\n&\nx\n))\n{\nreturn\n0\n;\n};\n// lam4's return type is not preserved because it references the operator()'s\n// parameter types in the trailing return type.\nstatic_assert\n(\n!\n__nv_is_extended_device_lambda_with_preserved_return_type\n(\ndecltype\n(\nlam4\n)),\n\"\"\n);\n}\nFor an extended device lambda:\n-  Introspecting the parameter type of operator() is only supported in device code.\n-  Introspecting the return type of operator() is supported only in device code, unless the trait function __nv_is_extended_device_lambda_with_preserved_return_type() returns true.\nIf the functor object represented by an extended lambda is passed from host to device code (e.g., as the argument of a\n__global__\nfunction), then any expression in the body of the lambda expression that captures variables must be remain unchanged irrespective of whether the\n__CUDA_ARCH__\nmacro is defined, and whether the macro has a particular value. This restriction arises because the lambdaâs closure class layout depends on the order in which captured variables are encountered when the compiler processes the lambda expression; the program may execute incorrectly if the closure class layout differs in device and host compilation.\nExample\n__device__\nint\nresult\n;\ntemplate\n<\ntypename\nT\n>\n__global__\nvoid\nkernel\n(\nT\nin\n)\n{\nresult\n=\nin\n();\n}\nvoid\nfoo\n(\nvoid\n)\n{\nint\nx1\n=\n1\n;\nauto\nlam1\n=\n[\n=\n]\n__host__\n__device__\n{\n// Error: \"x1\" is only captured when __CUDA_ARCH__ is defined.\n#ifdef __CUDA_ARCH__\nreturn\nx1\n+\n1\n;\n#else\nreturn\n10\n;\n#endif\n};\nkernel\n<<<\n1\n,\n1\n>>>\n(\nlam1\n);\n}\nAs described previously, the CUDA compiler replaces an extended\n__device__\nlambda expression with an instance of a placeholder type in the code sent to the host compiler. This placeholder type does not define a pointer-to-function conversion operator in host code, however the conversion operator is provided in device code. Note that this restriction does not apply to\n__host__\n__device__\nextended lambdas.\nExample\ntemplate\n<\ntypename\nT\n>\n__global__\nvoid\nkern\n(\nT\nin\n)\n{\nint\n(\n*\nfp\n)(\ndouble\n)\n=\nin\n;\n// OK: conversion in device code is supported\nfp\n(\n0\n);\nauto\nlam1\n=\n[](\ndouble\n)\n{\nreturn\n1\n;\n};\n// OK: conversion in device code is supported\nfp\n=\nlam1\n;\nfp\n(\n0\n);\n}\nvoid\nfoo\n(\nvoid\n)\n{\nauto\nlam_d\n=\n[]\n__device__\n(\ndouble\n)\n{\nreturn\n1\n;\n};\nauto\nlam_hd\n=\n[]\n__host__\n__device__\n(\ndouble\n)\n{\nreturn\n1\n;\n};\nkern\n<<<\n1\n,\n1\n>>>\n(\nlam_d\n);\nkern\n<<<\n1\n,\n1\n>>>\n(\nlam_hd\n);\n// OK : conversion for __host__ __device__ lambda is supported\n// in host code\nint\n(\n*\nfp\n)(\ndouble\n)\n=\nlam_hd\n;\n// Error: conversion for __device__ lambda is not supported in\n// host code.\nint\n(\n*\nfp2\n)(\ndouble\n)\n=\nlam_d\n;\n}\nAs described previously, the CUDA compiler replaces an extended\n__device__\nor\n__host__\n__device__\nlambda expression with an instance of a placeholder type in the code sent to the host compiler. This placeholder type may define C++ special member functions (e.g. constructor, destructor). As a result, some standard C++ type traits may return different results for the closure type of the extended lambda, in the CUDA frontend compiler versus the host compiler. The following type traits are affected:\nstd::is_trivially_copyable\n,\nstd::is_trivially_constructible\n,\nstd::is_trivially_copy_constructible\n,\nstd::is_trivially_move_constructible\n,\nstd::is_trivially_destructible\n.\nCare must be taken that the results of these type traits are not used in\n__global__\nfunction template instantiation or in\n__device__\n/\n__constant__\n/\n__managed__\nvariable template instantiation.\nExample\ntemplate\n<\nbool\nb\n>\nvoid\n__global__\nfoo\n()\n{\nprintf\n(\n\"hi\"\n);\n}\ntemplate\n<\ntypename\nT\n>\nvoid\ndolaunch\n()\n{\n// ERROR: this kernel launch may fail, because CUDA frontend compiler\n// and host compiler may disagree on the result of\n// std::is_trivially_copyable() trait on the closure type of the\n// extended lambda\nfoo\n<\nstd\n::\nis_trivially_copyable\n<\nT\n>::\nvalue\n><<<\n1\n,\n1\n>>>\n();\ncudaDeviceSynchronize\n();\n}\nint\nmain\n()\n{\nint\nx\n=\n0\n;\nauto\nlam1\n=\n[\n=\n]\n__host__\n__device__\n()\n{\nreturn\nx\n;\n};\ndolaunch\n<\ndecltype\n(\nlam1\n)\n>\n();\n}\nThe CUDA compiler will generate compiler diagnostics for a subset of cases described in 1-12; no diagnostic will be generated for cases 13-17, but the host compiler may fail to compile the generated code.\n18.7.3.\nNotes on __host__ __device__ lambdas\nï\nUnlike\n__device__\nlambdas,\n__host__\n__device__\nlambdas can be called from host code. As described earlier, the CUDA compiler replaces an extended lambda expression defined in host code with an instance of a named placeholder type. The placeholder type for an extended\n__host__\n__device__\nlambda invokes the original lambdaâs\noperator()\nwith an indirect function call\n24\n.\nThe presence of the indirect function call may cause an extended\n__host__\n__device__\nlambda to be less optimized by the host compiler than lambdas that are implicitly or explicitly\n__host__\nonly. In the latter case, the host compiler can easily inline the body of the lambda into the calling context. But in case of an extended\n__host__\n__device__\nlambda, the host compiler encounters the indirect function call and may not be able to easily inline the original\n__host__\n__device__\nlambda body.\n18.7.4.\n*this Capture By Value\nï\nWhen a lambda is defined within a non-static class member function, and the body of the lambda refers to a class member variable, C++11/C++14 rules require that the\nthis\npointer of the class is captured by value, instead of the referenced member variable. If the lambda is an extended\n__device__\nor\n__host__\n__device__\nlambda defined in a host function, and the lambda is executed on the GPU, accessing the referenced member variable on the GPU will cause a run time error if the\nthis\npointer points to host memory.\nExample:\n#include\n<cstdio>\ntemplate\n<\ntypename\nT\n>\n__global__\nvoid\nfoo\n(\nT\nin\n)\n{\nprintf\n(\n\"\n\\n\nvalue = %d\"\n,\nin\n());\n}\nstruct\nS1_t\n{\nint\nxxx\n;\n__host__\n__device__\nS1_t\n(\nvoid\n)\n:\nxxx\n(\n10\n)\n{\n};\nvoid\ndoit\n(\nvoid\n)\n{\nauto\nlam1\n=\n[\n=\n]\n__device__\n{\n// reference to \"xxx\" causes\n// the 'this' pointer (S1_t*) to be captured by value\nreturn\nxxx\n+\n1\n;\n};\n// Kernel launch fails at run time because 'this->xxx'\n// is not accessible from the GPU\nfoo\n<<<\n1\n,\n1\n>>>\n(\nlam1\n);\ncudaDeviceSynchronize\n();\n}\n};\nint\nmain\n(\nvoid\n)\n{\nS1_t\ns1\n;\ns1\n.\ndoit\n();\n}\nC++17 solves this problem by adding a new â*thisâ capture mode. In this mode, the compiler makes a copy of the object denoted by â*thisâ instead of capturing the pointer\nthis\nby value. The â*thisâ capture mode is described in more detail here:\nhttp://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0018r3.html\n.\nThe CUDA compiler supports the â*thisâ capture mode for lambdas defined within\n__device__\nand\n__global__\nfunctions and for extended\n__device__\nlambdas defined in host code, when the\n--extended-lambda\nnvcc flag is used.\nHereâs the above example modified to use â*thisâ capture mode:\n#include\n<cstdio>\ntemplate\n<\ntypename\nT\n>\n__global__\nvoid\nfoo\n(\nT\nin\n)\n{\nprintf\n(\n\"\n\\n\nvalue = %d\"\n,\nin\n());\n}\nstruct\nS1_t\n{\nint\nxxx\n;\n__host__\n__device__\nS1_t\n(\nvoid\n)\n:\nxxx\n(\n10\n)\n{\n};\nvoid\ndoit\n(\nvoid\n)\n{\n// note the \"*this\" capture specification\nauto\nlam1\n=\n[\n=\n,\n*\nthis\n]\n__device__\n{\n// reference to \"xxx\" causes\n// the object denoted by '*this' to be captured by\n// value, and the GPU code will access copy_of_star_this->xxx\nreturn\nxxx\n+\n1\n;\n};\n// Kernel launch succeeds\nfoo\n<<<\n1\n,\n1\n>>>\n(\nlam1\n);\ncudaDeviceSynchronize\n();\n}\n};\nint\nmain\n(\nvoid\n)\n{\nS1_t\ns1\n;\ns1\n.\ndoit\n();\n}\nâ*thisâ capture mode is not allowed for unannotated lambdas defined in host code, or for extended\n__host__\n__device__\nlambdas, unless â*thisâ capture is enabled by the selected language dialect. Examples of supported and unsupported usage:\nstruct\nS1_t\n{\nint\nxxx\n;\n__host__\n__device__\nS1_t\n(\nvoid\n)\n:\nxxx\n(\n10\n)\n{\n};\nvoid\nhost_func\n(\nvoid\n)\n{\n// OK: use in an extended __device__ lambda\nauto\nlam1\n=\n[\n=\n,\n*\nthis\n]\n__device__\n{\nreturn\nxxx\n;\n};\n// Use in an extended __host__ __device__ lambda\n// Error if *this capture not enabled by language dialect\nauto\nlam2\n=\n[\n=\n,\n*\nthis\n]\n__host__\n__device__\n{\nreturn\nxxx\n;\n};\n// Use in an unannotated lambda in host function\n// Error if *this capture not enabled by language dialect\nauto\nlam3\n=\n[\n=\n,\n*\nthis\n]\n{\nreturn\nxxx\n;\n};\n}\n__device__\nvoid\ndevice_func\n(\nvoid\n)\n{\n// OK: use in a lambda defined in a __device__ function\nauto\nlam1\n=\n[\n=\n,\n*\nthis\n]\n__device__\n{\nreturn\nxxx\n;\n};\n// OK: use in a lambda defined in a __device__ function\nauto\nlam2\n=\n[\n=\n,\n*\nthis\n]\n__host__\n__device__\n{\nreturn\nxxx\n;\n};\n// OK: use in a lambda defined in a __device__ function\nauto\nlam3\n=\n[\n=\n,\n*\nthis\n]\n{\nreturn\nxxx\n;\n};\n}\n__host__\n__device__\nvoid\nhost_device_func\n(\nvoid\n)\n{\n// OK: use in an extended __device__ lambda\nauto\nlam1\n=\n[\n=\n,\n*\nthis\n]\n__device__\n{\nreturn\nxxx\n;\n};\n// Use in an extended __host__ __device__ lambda\n// Error if *this capture not enabled by language dialect\nauto\nlam2\n=\n[\n=\n,\n*\nthis\n]\n__host__\n__device__\n{\nreturn\nxxx\n;\n};\n// Use in an unannotated lambda in a __host__ __device__ function\n// Error if *this capture not enabled by language dialect\nauto\nlam3\n=\n[\n=\n,\n*\nthis\n]\n{\nreturn\nxxx\n;\n};\n}\n};\n18.7.5.\nAdditional Notes\nï\nADL\nLookup\n: As described earlier, the CUDA compiler will replace an extended lambda expression with an instance of a placeholder type, before invoking the host compiler. One template argument of the placeholder type uses the address of the function enclosing the original lambda expression. This may cause additional namespaces to participate in argument dependent lookup (ADL), for any host function call whose argument types involve the closure type of the extended lambda expression. This may cause an incorrect function to be selected by the host compiler.\nExample:\nnamespace\nN1\n{\nstruct\nS1_t\n{\n};\ntemplate\n<\ntypename\nT\n>\nvoid\nfoo\n(\nT\n);\n};\nnamespace\nN2\n{\ntemplate\n<\ntypename\nT\n>\nint\nfoo\n(\nT\n);\ntemplate\n<\ntypename\nT\n>\nvoid\ndoit\n(\nT\nin\n)\n{\nfoo\n(\nin\n);\n}\n}\nvoid\nbar\n(\nN1\n::\nS1_t\nin\n)\n{\n/* extended __device__ lambda. In the code sent to the host compiler, this\nis replaced with the placeholder type instantiation expression\n' __nv_dl_wrapper_t< __nv_dl_tag<void (*)(N1::S1_t in),(&bar),1> > { }'\nAs a result, the namespace 'N1' participates in ADL lookup of the\ncall to \"foo\" in the body of N2::doit, causing ambiguity.\n*/\nauto\nlam1\n=\n[\n=\n]\n__device__\n{\n};\nN2\n::\ndoit\n(\nlam1\n);\n}\nIn the example above, the CUDA compiler replaced the extended lambda with a placeholder type that involves the\nN1\nnamespace. As a result, the namespace\nN1\nparticipates in the ADL lookup for\nfoo(in)\nin the body of\nN2::doit\n, and host compilation fails because multiple overload candidates\nN1::foo\nand\nN2::foo\nare found.\n18.8.\nRelaxed Constexpr (-expt-relaxed-constexpr)\nï\nBy default, the following cross-execution space calls are not supported:\nCalling a\n__device__\n-only\nconstexpr\nfunction from a\n__host__\nfunction during host code generation phase (i.e, when\n__CUDA_ARCH__\nmacro is undefined). Example:\nconstexpr\n__device__\nint\nD\n()\n{\nreturn\n0\n;\n}\nint\nmain\n()\n{\nint\nx\n=\nD\n();\n//ERROR: calling a __device__-only constexpr function from host code\n}\nCalling a\n__host__\n-only\nconstexpr\nfunction from a\n__device__\nor\n__global__\nfunction, during device code generation phase (i.e. when\n__CUDA_ARCH__\nmacro is defined). Example:\nconstexpr\nint\nH\n()\n{\nreturn\n0\n;\n}\n__device__\nvoid\ndmain\n()\n{\nint\nx\n=\nH\n();\n//ERROR: calling a __host__-only constexpr function from device code\n}\nThe experimental flag\n-expt-relaxed-constexpr\ncan be used to relax this constraint. When this flag is specified, the compiler will support cross execution space calls described above, as follows:\nA cross-execution space call to a constexpr function is supported if it occurs in a context that requires constant evaluation, e.g., in the initializer of a constexpr variable. Example:\nconstexpr\n__host__\nint\nH\n(\nint\nx\n)\n{\nreturn\nx\n+\n1\n;\n};\n__global__\nvoid\ndoit\n()\n{\nconstexpr\nint\nval\n=\nH\n(\n1\n);\n// OK: call is in a context that\n// requires constant evaluation.\n}\nconstexpr\n__device__\nint\nD\n(\nint\nx\n)\n{\nreturn\nx\n+\n1\n;\n}\nint\nmain\n()\n{\nconstexpr\nint\nval\n=\nD\n(\n1\n);\n// OK: call is in a context that\n// requires constant evaluation.\n}\nOtherwise:\nDuring device code generation, device code is generated for the body of a\n__host__\n-only constexpr function\nH\n, unless\nH\nis not used or is only called in a constexpr context. Example:\n// NOTE: \"H\" is emitted in generated device code because it is\n// called from device code in a non-constexpr context\nconstexpr\n__host__\nint\nH\n(\nint\nx\n)\n{\nreturn\nx\n+\n1\n;\n}\n__device__\nint\ndoit\n(\nint\nin\n)\n{\nin\n=\nH\n(\nin\n);\n// OK, even though argument is not a constant expression\nreturn\nin\n;\n}\nAll code restrictions applicable to a ``__device__``  function are also applicable to the ``constexpr host``-only function ``H`` that is called from device code. However, compiler may not emit any build time diagnostics for ``H`` for these restrictions\n8\n.\nFor example, the following code patterns are unsupported in the body of\nH\n(as with any\n__device__\nfunction), but no compiler diagnostic may be generated:\nODR-use of a host variable or\n__host__\n-only non-constexpr function. Example:\nint\nqqq\n,\nwww\n;\nconstexpr\n__host__\nint\n*\nH\n(\nbool\nb\n)\n{\nreturn\nb\n?\n&\nqqq\n:\n&\nwww\n;\n};\n__device__\nint\ndoit\n(\nbool\nflag\n)\n{\nint\n*\nptr\n;\nptr\n=\nH\n(\nflag\n);\n// ERROR: H() attempts to refer to host variables 'qqq' and 'www'.\n// code will compile, but will NOT execute correctly.\nreturn\n*\nptr\n;\n}\nUse of exceptions (\nthrow/catch\n) and RTTI (\ntypeid,\ndynamic_cast\n). Example:\nstruct\nBase\n{\n};\nstruct\nDerived\n:\npublic\nBase\n{\n};\n// NOTE: \"H\" is emitted in generated device code\nconstexpr\nint\nH\n(\nbool\nb\n,\nBase\n*\nptr\n)\n{\nif\n(\nb\n)\n{\nreturn\n1\n;\n}\nelse\nif\n(\ntypeid\n(\nptr\n)\n==\ntypeid\n(\nDerived\n))\n{\n// ERROR: use of typeid in code executing on the GPU\nreturn\n2\n;\n}\nelse\n{\nthrow\nint\n{\n4\n};\n// ERROR: use of throw in code executing on the GPU\n}\n}\n__device__\nvoid\ndoit\n(\nbool\nflag\n)\n{\nint\nval\n;\nDerived\nd\n;\nval\n=\nH\n(\nflag\n,\n&\nd\n);\n//ERROR: H() attempts use typeid and throw(), which are not allowed in code that executes on the GPU\n}\nDuring host code generation, the body of a\n__device__\n-only constexpr function\nD\nis preserved in the code sent to the host compiler. If the body of\nD\nattempts to ODR-use a namespace scope device variable or a\n__device__\n-only non-constexpr function, then the call to\nD\nfrom host code is not supported (code may build without compiler diagnostics, but may behave incorrectly at run time). Example:\n__device__\nint\nqqq\n,\nwww\n;\nconstexpr\n__device__\nint\n*\nD\n(\nbool\nb\n)\n{\nreturn\nb\n?\n&\nqqq\n:\n&\nwww\n;\n};\nint\ndoit\n(\nbool\nflag\n)\n{\nint\n*\nptr\n;\nptr\n=\nD\n(\nflag\n);\n// ERROR: D() attempts to refer to device variables 'qqq' and 'www'\n// code will compile, but will NOT execute correctly.\nreturn\n*\nptr\n;\n}\nNote: Given above restrictions and lack of compiler diagnostics for incorrect usage, be careful when calling a constexpr __host__ function in the standard C++ headers from device code\n, since the implementation of the function will vary depending on the host platform, e.g., based on the\nlibstdc++\nversion for gcc host compiler. Such code may break silently when being ported to a different platform or host compiler version (if the target C++ library implementation odr-uses a host code variable or function, as described earlier).\nExample:\n__device__\nint\nget\n(\nint\nin\n)\n{\nint\nval\n=\nstd\n::\nfoo\n(\nin\n);\n// \"std::foo\" is constexpr function defined in the host compiler's standard library header\n// WARNING: if std::foo implementation ODR-uses host variables or functions,\n// code will not work correctly\n}\n8\nDiagnostics are usually generated during parsing, but the host-only function\nH\nmay already have been parsed before the call to\nH\nfrom device code is encountered later in the translation unit.\n18.9.\nCode Samples\nï\n18.9.1.\nData Aggregation Class\nï\nclass\nPixelRGBA\n{\npublic\n:\n__device__\nPixelRGBA\n()\n:\nr_\n(\n0\n),\ng_\n(\n0\n),\nb_\n(\n0\n),\na_\n(\n0\n)\n{\n}\n__device__\nPixelRGBA\n(\nunsigned\nchar\nr\n,\nunsigned\nchar\ng\n,\nunsigned\nchar\nb\n,\nunsigned\nchar\na\n=\n255\n)\n:\nr_\n(\nr\n),\ng_\n(\ng\n),\nb_\n(\nb\n),\na_\n(\na\n)\n{\n}\nprivate\n:\nunsigned\nchar\nr_\n,\ng_\n,\nb_\n,\na_\n;\nfriend\nPixelRGBA\noperator\n+\n(\nconst\nPixelRGBA\n&\n,\nconst\nPixelRGBA\n&\n);\n};\n__device__\nPixelRGBA\noperator\n+\n(\nconst\nPixelRGBA\n&\np1\n,\nconst\nPixelRGBA\n&\np2\n)\n{\nreturn\nPixelRGBA\n(\np1\n.\nr_\n+\np2\n.\nr_\n,\np1\n.\ng_\n+\np2\n.\ng_\n,\np1\n.\nb_\n+\np2\n.\nb_\n,\np1\n.\na_\n+\np2\n.\na_\n);\n}\n__device__\nvoid\nfunc\n(\nvoid\n)\n{\nPixelRGBA\np1\n,\np2\n;\n// ...      // Initialization of p1 and p2 here\nPixelRGBA\np3\n=\np1\n+\np2\n;\n}\n18.9.2.\nDerived Class\nï\n__device__\nvoid\n*\noperator\nnew\n(\nsize_t\nbytes\n,\nMemoryPool\n&\np\n);\n__device__\nvoid\noperator\ndelete\n(\nvoid\n*\n,\nMemoryPool\n&\np\n);\nclass\nShape\n{\npublic\n:\n__device__\nShape\n(\nvoid\n)\n{\n}\n__device__\nvoid\nputThis\n(\nPrintBuffer\n*\np\n)\nconst\n;\n__device__\nvirtual\nvoid\nDraw\n(\nPrintBuffer\n*\np\n)\nconst\n{\np\n->\nput\n(\n\"Shapeless\"\n);\n}\n__device__\nvirtual\n~\nShape\n()\n{}\n};\nclass\nPoint\n:\npublic\nShape\n{\npublic\n:\n__device__\nPoint\n()\n:\nx\n(\n0\n),\ny\n(\n0\n)\n{}\n__device__\nPoint\n(\nint\nix\n,\nint\niy\n)\n:\nx\n(\nix\n),\ny\n(\niy\n)\n{\n}\n__device__\nvoid\nPutCoord\n(\nPrintBuffer\n*\np\n)\nconst\n;\n__device__\nvoid\nDraw\n(\nPrintBuffer\n*\np\n)\nconst\n;\n__device__\n~\nPoint\n()\n{}\nprivate\n:\nint\nx\n,\ny\n;\n};\n__device__\nShape\n*\nGetPointObj\n(\nMemoryPool\n&\npool\n)\n{\nShape\n*\nshape\n=\nnew\n(\npool\n)\nPoint\n(\nrand\n(\n-20\n,\n10\n),\nrand\n(\n-100\n,\n-20\n));\nreturn\nshape\n;\n}\n18.9.3.\nClass Template\nï\ntemplate\n<\nclass\nT\n>\nclass\nmyValues\n{\nT\nvalues\n[\nMAX_VALUES\n];\npublic\n:\n__device__\nmyValues\n(\nT\nclear\n)\n{\n...\n}\n__device__\nvoid\nsetValue\n(\nint\nIdx\n,\nT\nvalue\n)\n{\n...\n}\n__device__\nvoid\nputToMemory\n(\nT\n*\nvalueLocation\n)\n{\n...\n}\n};\ntemplate\n<\nclass\nT\n>\nvoid\n__global__\nuseValues\n(\nT\n*\nmemoryBuffer\n)\n{\nmyValues\n<\nT\n>\nmyLocation\n(\n0\n);\n...\n}\n__device__\nvoid\n*\nbuffer\n;\nint\nmain\n()\n{\n...\nuseValues\n<\nint\n><<<\nblocks\n,\nthreads\n>>>\n(\nbuffer\n);\n...\n}\n18.9.4.\nFunction Template\nï\ntemplate\n<\ntypename\nT\n>\n__device__\nbool\nfunc\n(\nT\nx\n)\n{\n...\nreturn\n(...);\n}\ntemplate\n<>\n__device__\nbool\nfunc\n<\nint\n>\n(\nT\nx\n)\n// Specialization\n{\nreturn\ntrue\n;\n}\n// Explicit argument specification\nbool\nresult\n=\nfunc\n<\ndouble\n>\n(\n0.5\n);\n// Implicit argument deduction\nint\nx\n=\n1\n;\nbool\nresult\n=\nfunc\n(\nx\n);\n18.9.5.\nFunctor Class\nï\nclass\nAdd\n{\npublic\n:\n__device__\nfloat\noperator\n()\n(\nfloat\na\n,\nfloat\nb\n)\nconst\n{\nreturn\na\n+\nb\n;\n}\n};\nclass\nSub\n{\npublic\n:\n__device__\nfloat\noperator\n()\n(\nfloat\na\n,\nfloat\nb\n)\nconst\n{\nreturn\na\n-\nb\n;\n}\n};\n// Device code\ntemplate\n<\nclass\nO\n>\n__global__\nvoid\nVectorOperation\n(\nconst\nfloat\n*\nA\n,\nconst\nfloat\n*\nB\n,\nfloat\n*\nC\n,\nunsigned\nint\nN\n,\nO\nop\n)\n{\nunsigned\nint\niElement\n=\nblockDim\n.\nx\n*\nblockIdx\n.\nx\n+\nthreadIdx\n.\nx\n;\nif\n(\niElement\n<\nN\n)\nC\n[\niElement\n]\n=\nop\n(\nA\n[\niElement\n],\nB\n[\niElement\n]);\n}\n// Host code\nint\nmain\n()\n{\n...\nVectorOperation\n<<<\nblocks\n,\nthreads\n>>>\n(\nv1\n,\nv2\n,\nv3\n,\nN\n,\nAdd\n());\n...\n}\n9\ne.g., the\n<<<...>>>\nsyntax for launching kernels.\n10\nThis does not apply to entities that may be defined in more than one translation unit, such as compiler generated template instantiations.\n11\nThe intent is to allow variable memory space specifiers for static variables in a\n__host__\n__device__\nfunction during device compilation, but disallow it during host compilation\n12\nOne way to debug suspected layout mismatch of a type\nC\nis to use\nprintf\nto output the values of\nsizeof(C)\nand\noffsetof(C,\nfield)\nin host and device code.\n13\nNote that this may negatively impact compile time due to presence of extra declarations.\n14\nAt present, the\n-std=c++11\nflag is supported only for the following host compilers : gcc version >= 4.7, clang, icc >= 15, and xlc >= 13.1\n15\nincluding\noperator()\n16\nThe restrictions are the same as with a non-constexpr callee function.\n17\nNote that the behavior of experimental flags may change in future compiler releases.\n18\nC++ Standard Section\n[basic.types]\n19\nC++ Standard Section\n[expr.const]\n20\nAt present, the\n-std=c++14\nflag is supported only for the following host compilers : gcc version >= 5.1, clang version >= 3.7 and icc version >= 17\n21\nAt present, the\n-std=c++17\nflag is supported only for the following host compilers : gcc version >= 7.0, clang version >= 8.0, Visual Studio version >= 2017, pgi compiler version >= 19.0, icc compiler version >= 19.0\n22\nAt present, the\n-std=c++20\nflag is supported only for the following host compilers : gcc version >= 10.0,  clang version >= 10.0, Visual Studio Version >= 2022 and nvc++ version >= 20.7.\n23\nWhen using the icc host compiler, this flag is only supported for icc >= 1800.\n24\n(\n1\n,\n2\n)\nThe traits will always return false if extended lambda mode is not active.\n25\nIn contrast, the C++ standard specifies that the captured variable is used to direct-initialize the field of the closure type.\n19.\nTexture Fetching\nï\nThis section gives the formula used to compute the value returned by the texture functions of\nTexture Functions\ndepending on the various attributes of the texture object (see\nTexture and Surface Memory\n).\nThe texture bound to the texture object is represented as an array\nT\nof\nN\ntexels for a one-dimensional texture,\nN x M\ntexels for a two-dimensional texture,\nN x M x L\ntexels for a three-dimensional texture.\nIt is fetched using non-normalized texture coordinates\nx\n,\ny\n, and\nz\n, or the normalized texture coordinates\nx/N\n,\ny/M\n, and\nz/L\nas described in\nTexture Memory\n. In this section, the coordinates are assumed to be in the valid range.\nTexture Memory\nexplained how out-of-range coordinates are remapped to the valid range based on the addressing mode.\n19.1.\nNearest-Point Sampling\nï\nIn this filtering mode, the value returned by the texture fetch is\ntex(x)=T[i]\nfor a one-dimensional texture,\ntex(x,y)=T[i,j]\nfor a two-dimensional texture,\ntex(x,y,z)=T[i,j,k]\nfor a three-dimensional texture,\nwhere\ni=floor(x)\n,\nj=floor(y)\n, and\nk=floor(z)\n.\nFigure 36\nillustrates nearest-point sampling for a one-dimensional texture with\nN=4\n.\nFigure 36\nNearest-Point Sampling Filtering Mode\nï\nFor integer textures, the value returned by the texture fetch can be optionally remapped to [0.0, 1.0] (see\nTexture Memory\n).\n19.2.\nLinear Filtering\nï\nIn this filtering mode, which is only available for floating-point textures, the value returned by the texture fetch is\n\\(tex(x)=(1-\\alpha)T[i]+{\\alpha}T[i+1]\\)\nfor a one-dimensional texture,\n\\(tex(x)=(1-\\alpha)T[i]+{\\alpha}T[i+1]\\)\nfor a one-dimensional texture,\n\\(tex(x,y)=(1-\\alpha)(1-\\beta)T[i,j]+\\alpha(1-\\beta)T[i+1,j]+(1-\\alpha){\\beta}T[i,j+1]+\\alpha{\\beta}T[i+1,j+1]\\)\nfor a two-dimensional texture,\n\\(tex(x,y,z)\\)\n=\n\\((1-\\alpha)(1-\\beta)(1-\\gamma)T[i,j,k]+\\alpha(1-\\beta)(1-\\gamma)T[i+1,j,k]+\\)\n\\((1-\\alpha)\\beta(1-\\gamma)T[i,j+1,k]+\\alpha\\beta(1-\\gamma)T[i+1,j+1,k]+\\)\n\\((1-\\alpha)(1-\\beta){\\gamma}T[i,j,k+1]+\\alpha(1-\\beta){\\gamma}T[i+1,j,k+1]+\\)\n\\((1-\\alpha)\\beta{\\gamma}T[i,j+1,k+1]+\\alpha\\beta{\\gamma}T[i+1,j+1,k+1]\\)\nfor a three-dimensional texture,\nwhere:\n\\(i=floor(x\\ B)*, \\alpha=frac(x\\ B)*, *x\\ B\\ =x-0.5,\\)\n\\(j=floor(y\\ B)*, \\beta=frac(y\\ B)*, *y\\ B\\ =y-0.5,\\)\n\\(k=floor(z\\ B)*, \\gamma=frac(z\\ B)*, *z\\ B\\ = z-0.5,\\)\n\\(\\alpha\\)\n,\n\\(\\beta\\)\n, and\n\\(\\gamma\\)\nare stored in 9-bit fixed point format with 8 bits of fractional value (so 1.0 is exactly represented).\nFigure 37\nillustrates linear filtering of a one-dimensional texture with\nN=4\n.\nFigure 37\nLinear Filtering Mode\nï\n19.3.\nTable Lookup\nï\nA table lookup\nTL(x)\nwhere\nx\nspans the interval\n[0,R]\ncan be implemented as\nTL(x)=tex((N-1)/R)x+0.5)\nin order to ensure that\nTL(0)=T[0]\nand\nTL(R)=T[N-1]\n.\nFigure 38\nillustrates the use of texture filtering to implement a table lookup with\nR=4\nor\nR=1\nfrom a one-dimensional texture with\nN=4\n.\nFigure 38\nOne-Dimensional Table Lookup Using Linear Filtering\nï\n20.\nCompute Capabilities\nï\nThe general specifications and features of a compute device depend on its compute capability (see\nCompute Capability\n).\nTable 26\nand\nTable 27\nshow the features and technical specifications associated with each compute capability that is currently supported.\nSection\nFloating-Point Standard\nreviews compliance with the IEEE floating-point standard.\nSections\nCompute Capability 5.x\n,\nCompute Capability 6.x\n,\nCompute Capability 7.x\n,\nCompute Capability 8.x\n,\nCompute Capability 9.0\n,\nCompute Capability 10.0\n, and\nCompute Capability 12.0\ngive more details on the architecture of devices with these respective compute capabilities.\n20.1.\nFeature Availability\nï\nMost compute features introduced with a compute architecture are intended to be available on all subsequent architectures. This is shown in\nTable 26\nby the âyesâ for availability of a feature on compute capabilities subsequent to its introduction.\n20.1.1.\nArchitecture-Specific Features\nï\nBeginning with devices of Compute Capability 9.0, specialized compute features that are introduced with an architecture may not be guaranteed to be available on all subsequent compute capabilities. These features are called\narchitecture-specific\nfeatures and target acceleration of specialized operations, such as Tensor Core operations, which are not intended for all classes of compute capabilities or may significantly change on future generations.  Code must be compiled with an architecture-specific compiler target (see\nFeature Set Compiler Targets\n) to enable architecture-specific features. Code compiled with an architecture-specific compiler target can only be run on the exact compute capability it was compiled for.\n20.1.2.\nFamily-Specific Features\nï\nBeginning with devices of Compute Capability 10.0, some architecture-specific features are common to devices of more than one compute capability.  The devices that contain these features are part of the same family and these features can also be called\nfamily-specific\nfeatures.  Family-specific features are guaranteed to be available on all devices in the same family. A family-specific compiler target is required to enable family-specific features. See\nSection 20.1.3\n. Code compiled for a family-specific target can only be run on GPUs which are members of that family.\n20.1.3.\nFeature Set Compiler Targets\nï\nThere are three sets of compute features which the compiler can target:\nBaseline Feature Set\n: The predominant set of compute features that are introduced with the intent to be available for subsequent compute architectures.  These features and their availability are summarized in\nTable 26\n.\nArchitecture-Specific Feature Set\n: A small and highly specialized set of features called architecture-specific, that are introduced to accelerate specialized operations, which are not guaranteed to be available or might change significantly on subsequent compute architectures.  These features are summarized in the respective âCompute Capability #.#â subsections.  The architecture-specific feature set is a superset of the family-specific feature set.  Architecture-specific compiler targets were introduced with Compute Capability 9.0 devices and are selected by using an\na\nsuffix in the compilation target, for example by specifying\ncompute_100a\nor\ncompute_120a\nas the compute target.\nFamily-Specific Feature Set\n: Some architecture-specific features are common to GPUs of more than one compute capability. These features are summarized in the respective âCompute Capability #.#â subsections. With a few exceptions, later generation devices with the same major compute capability are in the same family.\nTable 25\nindicates the compatibility of family-specific targets with device compute capability, including exceptions. The family-specific feature set is a superset of the baseline feature set.  Family-specific compiler targets were introduced with Compute Capability 10.0 devices and are selected by using a\nf\nsuffix in the compilation target, for example by specifying\ncompute_100f\nor\ncompute_120f\nas the compute target.\nAll devices starting from compute capability 9.0 have a set of features that are architecture-specific. To utilize the complete set of these features on a specific GPU, the architecture-specific compiler target with the suffix\na\nmust be used. Additionally, starting from compute capability 10.0, there are sets of features that appear in multiple devices with different minor compute capability. These sets of instructions are called family-specific features, and the devices which share these features are said to be part of the same family. The family-specific features are a subset of the architecture-specific features that are shared by all members of that GPU family. The family-specific compiler target with the suffix\nf\nallows the compiler to generate code which uses this common subset of architecture-specific features.\nFor example:\nThe\ncompute_100\ncompilation target does not allow use of architecture-specific features.  This target will be compatible with all devices of compute capability 10.0 and later.\nThe\ncompute_100f\nfamily-specific\ncompilation target allows the use of the subset of architecture-specific features that are common across the GPU family. This target will only be compatible with devices that are part of the GPU family. In this example it is compatible with devices of Compute Capability 10.0 and Compute Capability 10.3. The features available in the family-specific\ncompute_100f\ntarget is a superset of the features available in the baseline\ncompute_100\ntarget.\nThe\ncompute_100a\narchitecture-specific\ncompilation target allows use of the complete set of architecture-specific features in Compute Capability 10.0 devices. This target will only be compatible with devices of Compute Capability 10.0 and no others. The features available in the\ncompute_100a\ntarget form a superset of the features available in the\ncompute_100f\ntarget.\nTable 25\nFamily-Specific Compatibility\nï\nCompilation Target\nCompatible with Compute Capability\ncompute_100f\n10.0\n10.3\ncompute_103f\n10.3\n26\ncompute_110f\n11.0\n26\ncompute_120f\n12.0\n12.1\ncompute_121f\n12.1\n26\n26\n(\n1\n,\n2\n,\n3\n)\nSome families only contain a single member when they are created. They may be expanded in the future to include more devices.\n20.2.\nFeatures and Technical Specifications\nï\nTable 26\nFeature Support per Compute Capability\nï\nFeature Support\nCompute Capability\n(Unlisted features are supported for all compute capabilities)\n7.x\n8.x\n9.0\n10.0\n11.0\n12.0\nAtomic functions operating on 128-bit integer values in global memory (\nAtomic Functions\n)\nNo\nYes\nAtomic functions operating on 128-bit integer values in shared memory (\nAtomic Functions\n)\nNo\nYes\nAtomic addition operating on float2 and float4 floating point vectors in global memory (\natomicAdd()\n)\nNo\nYes\nBfloat16-precision floating-point operations: addition, subtraction, multiplication, comparison, warp shuffle functions, conversion\nNo\nYes\nHardware-accelerated\nmemcpy_async\n(\nAsynchronous Data Copies using cuda::pipeline\n)\nNo\nYes\nHardware-accelerated Split Arrive/Wait Barrier (\nAsynchronous Barrier\n)\nNo\nYes\nL2 Cache Residency Management (\nDevice Memory L2 Access Management\n)\nNo\nYes\nDPX Instructions for Accelerated Dynamic Programming\nNo\nYes\nDistributed Shared Memory\nNo\nYes\nThread Block Cluster\nNo\nYes\nTensor Memory Accelerator (TMA) unit\nNo\nYes\nNote that the KB and K units used in the following table correspond to 1024 bytes (i.e., a KiB) and 1024 respectively.\nTable 27\nTechnical Specifications per Compute Capability\nï\nCompute Capability\nTechnical Specifications\n7.5\n8.0\n8.6\n8.7\n8.9\n9.0\n10.0\n11.0\n12.0\nMaximum number of\nresident grids per device\n(Concurrent Kernel\nExecution)\n128\nMaximum dimensionality of\ngrid of thread blocks\n3\nMaximum x -dimension of a\ngrid of thread blocks\n2\n31\n-1\nMaximum y- or z-dimension\nof a grid of thread\nblocks\n65535\nMaximum dimensionality of\nthread block\n3\nMaximum x- or\ny-dimensionality of a\nblock\n1024\nMaximum z-dimension\nof a block\n64\nMaximum number of\nthreads per block\n1024\nWarp size\n32\nMaximum number of\nresident blocks per SM\n16\n32\n16\n24\n32\n24\nMaximum number of\nresident warps per SM\n32\n64\n48\n64\n48\nMaximum number of\nresident threads per SM\n1024\n2048\n1536\n2048\n1536\nNumber of 32-bit\nregisters per SM\n64 K\nMaximum number of 32-bit\nregisters per thread\nblock\n64 K\nMaximum number of 32-bit\nregisters per thread\n255\nMaximum amount of shared\nmemory per SM\n64 KB\n164\nKB\n100\nKB\n164\nKB\n100\nKB\n228\nKB\n100\nKB\nMaximum amount of shared\nmemory per thread block\n27\n64 KB\n163\nKB\n99 KB\n163\nKB\n99 KB\n227\nKB\n99 KB\nNumber of shared\nmemory banks\n32\nMaximum amount of local\nmemory per thread\n512 KB\nConstant memory size\n64 KB\nCache working set per SM\nfor constant memory\n8 KB\nCache  working set per SM\nfor texture memory\n32 or\n64 KB\n28 KB\n~ 192\nKB\n28 KB\n~ 128\nKB\n28 KB\n~ 192\nKB\n28 KB\n~ 128\nKB\n28 KB\n~ 256\nKB\n28 KB\n~ 128\nKB\nMaximum width for a 1D\ntexture object using\na CUDA array\n131072\nMaximum width for a 1D\ntexture object using\nlinear memory\n2\n28\nMaximum width and number\nof layers for a 1D\nlayered texture object\n32768\nx\n2048\nMaximum width and height\nfor a 2D texture\nobject using a CUDA\narray\n131072\nx\n65536\nMaximum width and height\nfor a 2D texture\nobject using\nlinear memory\n131072\nx\n65000\nMaximum width and height\nfor a 2D texture\nobject using a CUDA\narray supporting texture\ngather\n32768\nx\n32768\nMaximum width, height,\nand number of layers for\na 2D layered texture\nobject\n32768 x 32768 x 2048\nMaximum width, height,\nand depth for a 3D\ntexture object using\nto a CUDA array\n16384 x 16384 x 16384\nMaximum width (and\nheight) for a cubemap\ntexture object\n32768\nMaximum width (and\nheight) and number of\nlayers for a cubemap\nlayered texture object\n32768\nx\n2046\nMaximum number of\ntextures that can be\nbound to a kernel\n256\nMaximum width for a 1D\nsurface object using\na CUDA array\n32768\nMaximum width and number\nof layers for a 1D\nlayered surface object\n32768\nx\n2048\nMaximum width and height\nfor a 2D surface\nobject using a\nCUDA array\n131072\nx\n65536\nMaximum width, height,\nand number of layers for\na 2D layered surface\nobject\n32768\nx\n32768 x 1048\nMaximum width, height,\nand depth for a 3D\nsurface object using\na CUDA array\n16384\nx\n16384 x 16384\nMaximum width (and\nheight) for a cubemap\nsurface object using\na CUDA array\n32768\nMaximum width (and\nheight) and number of\nlayers for a cubemap\nlayered surface object\n32768\nx\n2046\nMaximum number of\nsurfaces that can use\na kernel\n32\n20.3.\nFloating-Point Standard\nï\nAll compute devices follow the IEEE 754-2008 standard for binary floating-point arithmetic with the following deviations:\nThere is no dynamically configurable rounding mode; however, most of the operations support multiple IEEE rounding modes, exposed via device intrinsics.\nThere is no mechanism for detecting that a floating-point exception has occurred and all operations behave as if the IEEE-754 exceptions are always masked, and deliver the masked response as defined by IEEE-754 if there is an exceptional event. For the same reason, while SNaN encodings are supported, they are not signaling and are handled as quiet.\nThe result of a single-precision floating-point operation involving one or more input NaNs is the quiet NaN of bit pattern 0x7fffffff.\nDouble-precision floating-point absolute value and negation are not compliant with IEEE-754 with respect to NaNs; these are passed through unchanged.\nCode must be compiled with\n-ftz=false\n,\n-prec-div=true\n, and\n-prec-sqrt=true\nto ensure IEEE compliance (this is the default setting; see the\nnvcc\nuser manual for description of these compilation flags).\nRegardless of the setting of the compiler flag\n-ftz\n,\natomic single-precision floating-point adds on global memory always operate in flush-to-zero mode, i.e., behave equivalent to\nFADD.F32.FTZ.RN\n,\natomic single-precision floating-point adds on shared memory always operate with denormal support, i.e., behave equivalent to\nFADD.F32.RN\n.\nIn accordance to the IEEE-754R standard, if one of the input parameters to\nfminf()\n,\nfmin()\n,\nfmaxf()\n, or\nfmax()\nis NaN, but not the other, the result is the non-NaN parameter.\nThe conversion of a floating-point value to an integer value in the case where the floating-point value falls outside the range of the integer format is left undefined by IEEE-754. For compute devices, the behavior is to clamp to the end of the supported range. This is unlike the x86 architecture behavior.\nThe behavior of integer division by zero and integer overflow is left undefined by IEEE-754. For compute devices, there is no mechanism for detecting that such integer operation exceptions have occurred. Integer division by zero yields an unspecified, machine-specific value.\nhttps://developer.nvidia.com/content/precision-performance-floating-point-and-ieee-754-compliance-nvidia-gpus\nincludes more information on the floating point accuracy and compliance of NVIDIA GPUs.\n20.4.\nCompute Capability 5.x\nï\n20.4.1.\nArchitecture\nï\nAn SM consists of:\n128 CUDA cores for arithmetic operations (see\nCUDA C++ Best Practices Guide\nfor throughputs of arithmetic operations),\n32 special function units for single-precision floating-point transcendental functions,\n4 warp schedulers.\nWhen an SM is given warps to execute, it first distributes them among the four schedulers. Then, at every instruction issue time, each scheduler issues one instruction for one of its assigned warps that is ready to execute, if any.\nAn SM has:\na read-only constant cache that is shared by all functional units and speeds up reads from the constant memory space, which resides in device memory,\na unified L1/texture cache of 24 KB used to cache reads from global memory,\n64 KB of shared memory for devices of compute capability 5.0 or 96 KB of shared memory for devices of compute capability 5.2.\nThe unified L1/texture cache is also used by the texture unit that implements the various addressing modes and data filtering mentioned in\nTexture and Surface Memory\n.\nThere is also an L2 cache shared by all SMs that is used to cache accesses to local or global memory, including temporary register spills. Applications may query the L2 cache size by checking the\nl2CacheSize\ndevice property (see\nDevice Enumeration\n).\nThe cache behavior (e.g., whether reads are cached in both the unified L1/texture cache and L2 or in L2 only) can be partially configured on a per-access basis using modifiers to the load instruction.\n20.4.2.\nGlobal Memory\nï\nGlobal memory accesses are always cached in L2.\nData that is read-only for the entire lifetime of the kernel can also be cached in the unified L1/texture cache described in the previous section by reading it using the\n__ldg()\nfunction (see\nRead-Only Data Cache Load Function\n). When the compiler detects that the read-only condition is satisfied for some data, it will use\n__ldg()\nto read it. The compiler might not always be able to detect that the read-only condition is satisfied for some data. Marking pointers used for loading such data with both the\nconst\nand\n__restrict__\nqualifiers increases the likelihood that the compiler will detect the read-only condition.\nData that is not read-only for the entire lifetime of the kernel cannot be cached in the unified L1/texture cache for devices of compute capability 5.0. For devices of compute capability 5.2, it is, by default, not cached in the unified L1/texture cache, but caching may be enabled using the following mechanisms:\nPerform the read using inline assembly with the appropriate modifier as described in the PTX reference manual;\nCompile with the\n-Xptxas\n-dlcm=ca\ncompilation flag, in which case all reads are cached, except reads that are performed using inline assembly with a modifier that disables caching;\nCompile with the\n-Xptxas\n-fscm=ca\ncompilation flag, in which case all reads are cached, including reads that are performed using inline assembly regardless of the modifier used.\nWhen caching is enabled using one of the three mechanisms listed above, devices of compute capability 5.2 will cache global memory reads in the unified L1/texture cache for all kernel launches except for the kernel launches for which thread blocks consume too much of the SMâs register file. These exceptions are reported by the profiler.\n20.4.3.\nShared Memory\nï\nShared memory has 32 banks that are organized such that successive 32-bit words map to successive banks. Each bank has a bandwidth of 32 bits per clock cycle.\nA shared memory request for a warp does not generate a bank conflict between two threads that access any address within the same 32-bit word (even though the two addresses fall in the same bank). In that case, for read accesses, the word is broadcast to the requesting threads and for write accesses, each address is written by only one of the threads (which thread performs the write is undefined).\nFigure 39\nshows some examples of strided access.\nFigure 40\nshows some examples of memory read accesses that involve the broadcast mechanism.\nFigure 39\nStrided Shared Memory Accesses in 32 bit bank size mode.\nï\nLeft\nLinear addressing with a stride of one 32-bit word (no bank conflict).\nMiddle\nLinear addressing with a stride of two 32-bit words (two-way bank conflict).\nRight\nLinear addressing with a stride of three 32-bit words (no bank conflict).\nFigure 40\nIrregular Shared Memory Accesses.\nï\nLeft\nConflict-free access via random permutation.\nMiddle\nConflict-free access since threads 3, 4, 6, 7, and 9 access the same word within bank 5.\nRight\nConflict-free broadcast access (threads access the same word within a bank).\n20.5.\nCompute Capability 6.x\nï\n20.5.1.\nArchitecture\nï\nAn SM consists of:\n64 (compute capability 6.0) or 128 (6.1 and 6.2) CUDA cores for arithmetic operations,\n16 (6.0) or 32 (6.1 and 6.2) special function units for single-precision floating-point transcendental functions,\n2 (6.0) or 4 (6.1 and 6.2) warp schedulers.\nWhen an SM is given warps to execute, it first distributes them among its schedulers. Then, at every instruction issue time, each scheduler issues one instruction for one of its assigned warps that is ready to execute, if any.\nAn SM has:\na read-only constant cache that is shared by all functional units and speeds up reads from the constant memory space, which resides in device memory,\na unified L1/texture cache for reads from global memory of size 24 KB (6.0 and 6.2) or 48 KB (6.1),\na shared memory of size 64 KB (6.0 and 6.2) or 96 KB (6.1).\nThe unified L1/texture cache is also used by the texture unit that implements the various addressing modes and data filtering mentioned in\nTexture and Surface Memory\n.\nThere is also an L2 cache shared by all SMs that is used to cache accesses to local or global memory, including temporary register spills. Applications may query the L2 cache size by checking the\nl2CacheSize\ndevice property (see\nDevice Enumeration\n).\nThe cache behavior (for example, whether reads are cached in both the unified L1/texture cache and L2 or in L2 only) can be partially configured on a per-access basis using modifiers to the load instruction.\n20.5.2.\nGlobal Memory\nï\nGlobal memory behaves the same way as in devices of compute capability 5.x (See\nGlobal Memory\n).\n20.5.3.\nShared Memory\nï\nShared memory behaves the same way as in devices of compute capability 5.x (See\nShared Memory\n).\n20.6.\nCompute Capability 7.x\nï\n20.6.1.\nArchitecture\nï\nAn SM consists of:\n64 FP32 cores for single-precision arithmetic operations,\n32 FP64 cores for double-precision arithmetic operations,\n28\n64 INT32 cores for integer math,\n8 mixed-precision Tensor Cores for deep learning matrix arithmetic\n16 special function units for single-precision floating-point transcendental functions,\n4 warp schedulers.\nAn SM statically distributes its warps among its schedulers. Then, at every instruction issue time, each scheduler issues one instruction for one of its assigned warps that is ready to execute, if any.\nAn SM has:\na read-only constant cache that is shared by all functional units and speeds up reads from the constant memory space, which resides in device memory,\na unified data cache and shared memory with a total size of 128 KB (\nVolta\n) or 96 KB (\nTuring\n).\nShared memory is partitioned out of unified data cache, and can be configured to various sizes (See\nShared Memory\n.) The remaining data cache serves as an L1 cache and is also used by the texture unit that implements the various addressing and data filtering modes mentioned in\nTexture and Surface Memory\n.\n20.6.2.\nIndependent Thread Scheduling\nï\nThe\nNVIDIA Volta GPU Architecture\nintroduces\nIndependent Thread Scheduling\namong threads in a warp, enabling intra-warp synchronization patterns previously unavailable and simplifying code changes when porting CPU code. However, this can lead to a rather different set of threads participating in the executed code than intended if the developer made assumptions about warp-synchronicity of previous hardware architectures.\nBelow are code patterns of concern and suggested corrective actions for Volta-safe code.\nFor applications using warp intrinsics (\n__shfl*\n,\n__any\n,\n__all\n,\n__ballot\n), it is necessary that developers port their code to the new, safe, synchronizing counterpart, with the\n*_sync\nsuffix. The new warp intrinsics take in a mask of threads that explicitly define which lanes (threads of a warp) must participate in the warp intrinsic. See\nWarp Vote Functions\nand\nWarp Shuffle Functions\nfor details.\nSince the intrinsics are available with CUDA 9.0+, (if necessary) code can be executed conditionally with the following preprocessor macro:\n#if defined(CUDART_VERSION) && CUDART_VERSION >= 9000\n// *_sync intrinsic\n#endif\nThese intrinsics are available on all architectures, not just\nNVIDIA Volta GPU Architecture\nor\nNVIDIA Turing GPU Architecture\n, and in most cases a single code-base will suffice for all architectures. Note, however, that for\nPascal\nand earlier architectures, all threads in mask must execute the same warp intrinsic instruction in convergence, and the union of all values in mask must be equal to the warpâs active mask. The following code pattern is valid on\nNVIDIA Volta GPU Architecture\n, but not on\nPascal\nor earlier architectures.\nif\n(\ntid\n%\nwarpSize\n<\n16\n)\n{\n...\nfloat\nswapped\n=\n__shfl_xor_sync\n(\n0xffffffff\n,\nval\n,\n16\n);\n...\n}\nelse\n{\n...\nfloat\nswapped\n=\n__shfl_xor_sync\n(\n0xffffffff\n,\nval\n,\n16\n);\n...\n}\nThe replacement for\n__ballot(1)\nis\n__activemask()\n. Note that threads within a warp can diverge even within a single code path. As a result,\n__activemask()\nand\n__ballot(1)\nmay return only a subset of the threads on the current code path. The following invalid code example sets bit\ni\nof\noutput\nto 1 when\ndata[i]\nis greater than\nthreshold\n.\n__activemask()\nis used in an attempt to enable cases where\ndataLen\nis not a multiple of 32.\n// Sets bit in output[] to 1 if the correspond element in data[i]\n// is greater than 'threshold', using 32 threads in a warp.\nfor\n(\nint\ni\n=\nwarpLane\n;\ni\n<\ndataLen\n;\ni\n+=\nwarpSize\n)\n{\nunsigned\nactive\n=\n__activemask\n();\nunsigned\nbitPack\n=\n__ballot_sync\n(\nactive\n,\ndata\n[\ni\n]\n>\nthreshold\n);\nif\n(\nwarpLane\n==\n0\n)\n{\noutput\n[\ni\n/\n32\n]\n=\nbitPack\n;\n}\n}\nThis code is invalid because CUDA does not guarantee that the warp will diverge ONLY at the loop condition. When divergence happens for other reasons, conflicting results will be computed for the same 32-bit output element by different subsets of threads in the warp. A correct code might use a non-divergent loop condition together with\n__ballot_sync()\nto safely enumerate the set of threads in the warp participating in the threshold calculation as follows.\nfor\n(\nint\ni\n=\nwarpLane\n;\ni\n-\nwarpLane\n<\ndataLen\n;\ni\n+=\nwarpSize\n)\n{\nunsigned\nactive\n=\n__ballot_sync\n(\n0xFFFFFFFF\n,\ni\n<\ndataLen\n);\nif\n(\ni\n<\ndataLen\n)\n{\nunsigned\nbitPack\n=\n__ballot_sync\n(\nactive\n,\ndata\n[\ni\n]\n>\nthreshold\n);\nif\n(\nwarpLane\n==\n0\n)\n{\noutput\n[\ni\n/\n32\n]\n=\nbitPack\n;\n}\n}\n}\nDiscovery Pattern\ndemonstrates a valid use case for\n__activemask()\n.\nIf applications have warp-synchronous codes, they will need to insert the new\n__syncwarp()\nwarp-wide barrier synchronization instruction between any steps where data is exchanged between threads via global or shared memory. Assumptions that code is executed in lockstep or that reads/writes from separate threads are visible across a warp without synchronization are invalid.\n__shared__\nfloat\ns_buff\n[\nBLOCK_SIZE\n];\ns_buff\n[\ntid\n]\n=\nval\n;\n__syncthreads\n();\n// Inter-warp reduction\nfor\n(\nint\ni\n=\nBLOCK_SIZE\n/\n2\n;\ni\n>=\n32\n;\ni\n/=\n2\n)\n{\nif\n(\ntid\n<\ni\n)\n{\ns_buff\n[\ntid\n]\n+=\ns_buff\n[\ntid\n+\ni\n];\n}\n__syncthreads\n();\n}\n// Intra-warp reduction\n// Butterfly reduction simplifies syncwarp mask\nif\n(\ntid\n<\n32\n)\n{\nfloat\ntemp\n;\ntemp\n=\ns_buff\n[\ntid\n^\n16\n];\n__syncwarp\n();\ns_buff\n[\ntid\n]\n+=\ntemp\n;\n__syncwarp\n();\ntemp\n=\ns_buff\n[\ntid\n^\n8\n];\n__syncwarp\n();\ns_buff\n[\ntid\n]\n+=\ntemp\n;\n__syncwarp\n();\ntemp\n=\ns_buff\n[\ntid\n^\n4\n];\n__syncwarp\n();\ns_buff\n[\ntid\n]\n+=\ntemp\n;\n__syncwarp\n();\ntemp\n=\ns_buff\n[\ntid\n^\n2\n];\n__syncwarp\n();\ns_buff\n[\ntid\n]\n+=\ntemp\n;\n__syncwarp\n();\n}\nif\n(\ntid\n==\n0\n)\n{\n*\noutput\n=\ns_buff\n[\n0\n]\n+\ns_buff\n[\n1\n];\n}\n__syncthreads\n();\nAlthough\n__syncthreads()\nhas been consistently documented as synchronizing all threads in the thread block,\nPascal\nand prior architectures could only enforce synchronization at the warp level. In certain cases, this allowed a barrier to succeed without being executed by every thread as long as at least some thread in every warp reached the barrier. Starting with\nNVIDIA Volta GPU Architecture\n, the CUDA built-in\n__syncthreads()\nand PTX instruction\nbar.sync\n(and their derivatives) are enforced per thread and thus will not succeed until reached by all non-exited threads in the block. Code exploiting the previous behavior will likely deadlock and must be modified to ensure that all non-exited threads reach the barrier.\nThe\nracecheck\nand\nsynccheck\ntools provided by\ncompute-saniter\ncan help with locating violations.\nTo aid migration while implementing the above-mentioned corrective actions, developers can opt-in to the Pascal scheduling model that does not support independent thread scheduling. See\nApplication Compatibility\nfor details.\n20.6.3.\nGlobal Memory\nï\nGlobal memory behaves the same way as in devices of compute capability 5.x (See\nGlobal Memory\n).\n20.6.4.\nShared Memory\nï\nThe amount of the unified data cache reserved for shared memory is configurable on a per kernel basis. For the\nVolta\narchitecture (compute capability 7.0), the unified data cache has a size of 128 KB, and the shared memory capacity can be set to 0, 8, 16, 32, 64 or 96 KB. For the\nTuring\narchitecture (compute capability 7.5), the unified data cache has a size of 96 KB, and the shared memory capacity can be set to either 32 KB or 64 KB. Unlike Kepler, the driver automatically configures the shared memory capacity for each kernel to avoid shared memory occupancy bottlenecks while also allowing concurrent execution with already launched kernels where possible. In most cases, the driverâs default behavior should provide optimal performance.\nBecause the driver is not always aware of the full workload, it is sometimes useful for applications to provide additional hints regarding the desired shared memory configuration. For example, a kernel with little or no shared memory use may request a larger carveout in order to encourage concurrent execution with later kernels that require more shared memory. The new\ncudaFuncSetAttribute()\nAPI allows applications to set a preferred shared memory capacity, or\ncarveout\n, as a percentage of the maximum supported shared memory capacity (96 KB for\nVolta\n, and 64 KB for\nTuring\n).\ncudaFuncSetAttribute()\nrelaxes enforcement of the preferred shared capacity compared to the legacy\ncudaFuncSetCacheConfig()\nAPI introduced with Kepler. The legacy API treated shared memory capacities as hard requirements for kernel launch. As a result, interleaving kernels with different shared memory configurations would needlessly serialize launches behind shared memory reconfigurations. With the new API, the carveout is treated as a hint. The driver may choose a different configuration if required to execute the function or to avoid thrashing.\n// Device code\n__global__\nvoid\nMyKernel\n(...)\n{\n__shared__\nfloat\nbuffer\n[\nBLOCK_DIM\n];\n...\n}\n// Host code\nint\ncarveout\n=\n50\n;\n// prefer shared memory capacity 50% of maximum\n// Named Carveout Values:\n// carveout = cudaSharedmemCarveoutDefault;   //  (-1)\n// carveout = cudaSharedmemCarveoutMaxL1;     //   (0)\n// carveout = cudaSharedmemCarveoutMaxShared; // (100)\ncudaFuncSetAttribute\n(\nMyKernel\n,\ncudaFuncAttributePreferredSharedMemoryCarveout\n,\ncarveout\n);\nMyKernel\n<<<\ngridDim\n,\nBLOCK_DIM\n>>>\n(...);\nIn addition to an integer percentage, several convenience enums are provided as listed in the code comments above. Where a chosen integer percentage does not map exactly to a supported capacity (SM 7.0 devices support shared capacities of 0, 8, 16, 32, 64, or 96 KB), the next larger capacity is used. For instance, in the example above, 50% of the 96 KB maximum is 48 KB, which is not a supported shared memory capacity. Thus, the preference is rounded up to 64 KB.\nCompute capability 7.x devices allow a single thread block to address the full capacity of shared memory: 96 KB on\nVolta\n, 64 KB on\nTuring\n. Kernels relying on shared memory allocations over 48 KB per block are architecture-specific, as such they must use dynamic shared memory (rather than statically sized arrays) and require an explicit opt-in using\ncudaFuncSetAttribute()\nas follows.\n// Device code\n__global__\nvoid\nMyKernel\n(...)\n{\nextern\n__shared__\nfloat\nbuffer\n[];\n...\n}\n// Host code\nint\nmaxbytes\n=\n98304\n;\n// 96 KB\ncudaFuncSetAttribute\n(\nMyKernel\n,\ncudaFuncAttributeMaxDynamicSharedMemorySize\n,\nmaxbytes\n);\nMyKernel\n<<<\ngridDim\n,\nblockDim\n,\nmaxbytes\n>>>\n(...);\nOtherwise, shared memory behaves the same way as for devices of compute capability 5.x (See\nShared Memory\n).\n20.7.\nCompute Capability 8.x\nï\n20.7.1.\nArchitecture\nï\nA Streaming Multiprocessor (SM) consists of:\n64 FP32 cores for single-precision arithmetic operations in devices of compute capability 8.0 and 128 FP32 cores in devices of compute capability 8.6, 8.7 and 8.9,\n32 FP64 cores for double-precision arithmetic operations in devices of compute capability 8.0 and 2 FP64 cores in devices of compute capability 8.6, 8.7 and 8.9\n64 INT32 cores for integer math,\n4 mixed-precision Third-Generation Tensor Cores supporting half-precision (fp16),\n__nv_bfloat16\n,\ntf32\n, sub-byte and double precision (fp64) matrix arithmetic for compute capabilities 8.0, 8.6 and 8.7 (see\nWarp Matrix Functions\nfor details),\n4 mixed-precision Fourth-Generation Tensor Cores supporting\nfp8\n,\nfp16\n,\n__nv_bfloat16\n,\ntf32\n, sub-byte and\nfp64\nfor compute capability 8.9 (see\nWarp Matrix Functions\nfor details),\n16 special function units for single-precision floating-point transcendental functions,\n4 warp schedulers.\nAn SM statically distributes its warps among its schedulers. Then, at every instruction issue time, each scheduler issues one instruction for one of its assigned warps that is ready to execute, if any.\nAn SM has:\na read-only constant cache that is shared by all functional units and speeds up reads from the constant memory space, which resides in device memory,\na unified data cache and shared memory with a total size of 192 KB for devices of compute capability 8.0 and 8.7 (1.5x\nVolta\nâs 128 KB capacity) and 128 KB for devices of compute capabilities 8.6 and 8.9.\nShared memory is partitioned out of the unified data cache, and can be configured to various sizes (see\nShared Memory\n). The remaining data cache serves as an L1 cache and is also used by the texture unit that implements the various addressing and data filtering modes mentioned in\nTexture and Surface Memory\n.\n20.7.2.\nGlobal Memory\nï\nGlobal memory behaves the same way as for devices of compute capability 5.x (See\nGlobal Memory\n).\n20.7.3.\nShared Memory\nï\nSimilar to the\nVolta architecture\n, the amount of the unified data cache reserved for shared memory is configurable on a per kernel basis. For the\nNVIDIA Ampere GPU Architecture\n, the unified data cache has a size of 192 KB for devices of compute capability 8.0 and 8.7 and 128 KB for devices of compute capabilities 8.6 and 8.9. The shared memory capacity can be set to 0, 8, 16, 32, 64, 100, 132 or 164 KB for devices of compute capability 8.0 and 8.7, and to 0, 8, 16, 32, 64 or 100 KB for devices of compute capabilities 8.6 and 8.9.\nAn application can set the\ncarveout\n, i.e., the preferred shared memory capacity, with the\ncudaFuncSetAttribute()\n.\ncudaFuncSetAttribute\n(\nkernel_name\n,\ncudaFuncAttributePreferredSharedMemoryCarveout\n,\ncarveout\n);\nThe API can specify the carveout either as an integer percentage of the maximum supported shared memory capacity of 164 KB for devices of compute capability 8.0 and 8.7 and 100 KB for devices of compute capabilities 8.6 and 8.9 respectively, or as one of the following values:\n{cudaSharedmemCarveoutDefault\n,\ncudaSharedmemCarveoutMaxL1\n, or\ncudaSharedmemCarveoutMaxShared\n. When using a percentage, the carveout is rounded up to the nearest supported shared memory capacity. For example, for devices of compute capability 8.0, 50% will map to a 100 KB carveout instead of an 82 KB one. Setting the\ncudaFuncAttributePreferredSharedMemoryCarveout\nis considered a hint by the driver; the driver may choose a different configuration, if needed.\nDevices of compute capability 8.0 and 8.7 allow a single thread block to address up to 163 KB of shared memory, while devices of compute capabilities 8.6 and 8.9 allow up to 99 KB of shared memory. Kernels relying on shared memory allocations over 48 KB per block are architecture-specific, and must use dynamic shared memory rather than statically sized shared memory arrays. These kernels require an explicit opt-in by using\ncudaFuncSetAttribute()\nto set the\ncudaFuncAttributeMaxDynamicSharedMemorySize\n; see\nShared Memory\nfor the\nNVIDIA Volta GPU Architecture\n.\nNote that the maximum amount of shared memory per thread block is smaller than the maximum shared memory partition available per SM. The 1 KB of shared memory not made available to a thread block is reserved for system use.\n20.8.\nCompute Capability 9.0\nï\n20.8.1.\nArchitecture\nï\nA Streaming Multiprocessor (SM) consists of:\n128 FP32 cores for single-precision arithmetic operations,\n64 FP64 cores for double-precision arithmetic operations,\n64 INT32 cores for integer math,\n4 mixed-precision fourth-generation Tensor Cores supporting the new\nFP8\ninput type in either\nE4M3\nor\nE5M2\nfor exponent (E) and mantissa (M), half-precision (fp16),\n__nv_bfloat16\n,\ntf32\n, INT8 and double precision (fp64) matrix arithmetic (see\nWarp Matrix Functions\nfor details) with sparsity support,\n16 special function units for single-precision floating-point transcendental functions,\n4 warp schedulers.\nAn SM statically distributes its warps among its schedulers. Then, at every instruction issue time, each scheduler issues one instruction for one of its assigned warps that is ready to execute, if any.\nAn SM has:\na read-only constant cache that is shared by all functional units and speeds up reads from the constant memory space, which resides in device memory,\na unified data cache and shared memory with a total size of 256 KB for devices of compute capability 9.0 (1.33x\nNVIDIA Ampere GPU Architectureâs\n192 KB capacity).\nShared memory is partitioned out of the unified data cache, and can be configured to various sizes (see\nShared Memory\n). The remaining data cache serves as an L1 cache and is also used by the texture unit that implements the various addressing and data filtering modes mentioned in\nTexture and Surface Memory\n.\n20.8.2.\nGlobal Memory\nï\nGlobal memory behaves the same way as for devices of compute capability 5.x (See\nGlobal Memory\n).\n20.8.3.\nShared Memory\nï\nSimilar to the\nNVIDIA Ampere GPU architecture\n, the amount of the unified data cache reserved for shared memory is configurable on a per kernel basis. For the\nNVIDIA H100 Tensor Core GPU architecture\n, the unified data cache has a size of 256 KB for devices of compute capability 9.0. The shared memory capacity can be set to 0, 8, 16, 32, 64, 100, 132, 164, 196 or 228 KB.\nAs with the\nNVIDIA Ampere GPU architecture\n, an application can configure its preferred shared memory capacity, i.e., the\ncarveout\n. Devices of compute capability 9.0 allow a single thread block to address up to 227 KB of shared memory. Kernels relying on shared memory allocations over 48 KB per block are architecture-specific, and must use dynamic shared memory rather than statically sized shared memory arrays. These kernels require an explicit opt-in by using\ncudaFuncSetAttribute()\nto set the\ncudaFuncAttributeMaxDynamicSharedMemorySize\n; see\nShared Memory\nfor the\nNVIDIA Volta GPU Architecture\n.\nNote that the maximum amount of shared memory per thread block is smaller than the maximum shared memory partition available per SM. The 1 KB of shared memory not made available to a thread block is reserved for system use.\n20.8.4.\nFeatures Accelerating Specialized Computations\nï\nThe NVIDIA Hopper GPU architecture includes features to accelerate matrix multiply-accumulate (MMA) computations with:\nasynchronous execution of MMA instructions\nMMA instructions acting on large matrices spanning a warp-group\ndynamic reassignment of register capacity among warp-groups to support even larger matrices, and\noperand matrices accessed directly from shared memory\nSee the\nPTX ISA\nfor more details.\nThis feature set is only available within the CUDA compilation toolchain through inline PTX.\nIt is strongly recommended that applications utilize this complex feature set through CUDA-X libraries such as cuBLAS, cuDNN, or cuFFT.\nIt is strongly recommended that device kernels utilize this complex feature set through\nCUTLASS\n, a collection of CUDA C++ template abstractions for implementing high-performance matrix-multiplication (GEMM) and related computations at all levels and scales within CUDA.\n20.9.\nCompute Capability 10.0\nï\n20.9.1.\nArchitecture\nï\nA Streaming Multiprocessor (SM) consists of:\n128 FP32 cores for single-precision arithmetic operations,\n64 FP64 cores for double-precision arithmetic operations,\n64 INT32 cores for integer math,\n4 mixed-precision fifth-generation Tensor Cores supporting\nFP8\ninput type in either\nE4M3\nor\nE5M2\nfor exponent (E) and mantissa (M), half-precision (fp16),\n__nv_bfloat16\n,\ntf32\n, INT8 and double precision (fp64) matrix arithmetic (see\nWarp Matrix Functions\nfor details) with sparsity support,\n16 special function units for single-precision floating-point transcendental functions,\n4 warp schedulers.\nAn SM statically distributes its warps among its schedulers. Then, at every instruction issue time, each scheduler issues one instruction for one of its assigned warps that is ready to execute, if any.\nAn SM has:\na read-only constant cache that is shared by all functional units and speeds up reads from the constant memory space, which resides in device memory,\na unified data cache and shared memory with a total size of 256 KB for devices of compute capability 10.0\nShared memory is partitioned out of the unified data cache, and can be configured to various sizes (see\nShared Memory\n). The remaining data cache serves as an L1 cache and is also used by the texture unit that implements the various addressing and data filtering modes mentioned in\nTexture and Surface Memory\n.\n20.9.2.\nGlobal Memory\nï\nGlobal memory behaves the same way as for devices of compute capability 5.x (See\nGlobal Memory\n).\n20.9.3.\nShared Memory\nï\nThe amount of the unified data cache reserved for shared memory is configurable on a per kernel basis and is identical to\ncompute capability 9.0\n. The unified data cache has a size of 256 KB for devices of compute capability 10.0. The shared memory capacity can be set to 0, 8, 16, 32, 64, 100, 132, 164, 196 or 228 KB.\nAs with the\nNVIDIA Ampere GPU architecture\n, an application can configure its preferred shared memory capacity, i.e., the\ncarveout\n. Devices of compute capability 10.0 allow a single thread block to address up to 227 KB of shared memory. Kernels relying on shared memory allocations over 48 KB per block are architecture-specific, and must use dynamic shared memory rather than statically sized shared memory arrays. These kernels require an explicit opt-in by using\ncudaFuncSetAttribute()\nto set the\ncudaFuncAttributeMaxDynamicSharedMemorySize\n; see\nShared Memory\nfor the Volta architecture.\nNote that the maximum amount of shared memory per thread block is smaller than the maximum shared memory partition available per SM. The 1 KB of shared memory not made available to a thread block is reserved for system use.\n20.9.4.\nFeatures Accelerating Specialized Computations\nï\nThe NVIDIA Blackwell GPU architecture extends features to accelerate matrix multiply-accumulate (MMA) from the NVIDIA Hopper GPU architecture.\nSee the\nPTX ISA\nfor more details.\nThis feature set is only available within the CUDA compilation toolchain through inline PTX.\nIt is strongly recommended that applications utilize this complex feature set through CUDA-X libraries such as cuBLAS, cuDNN, or cuFFT.\nIt is strongly recommended that device kernels utilize this complex feature set through\nCUTLASS\n, a collection of CUDA C++ template abstractions for implementing high-performance matrix-multiplication (GEMM) and related computations at all levels and scales within CUDA.\n20.10.\nCompute Capability 12.0\nï\n20.10.1.\nArchitecture\nï\nA Streaming Multiprocessor (SM) consists of:\n128 FP32 cores for single-precision arithmetic operations,\n2 FP64 cores for double-precision arithmetic operations,\n64 INT32 cores for integer math,\nMixed-precision fifth-generation Tensor Core(s) supporting\nFP8\ninput type in either\nE4M3\nor\nE5M2\nfor exponent (E) and mantissa (M), half-precision (fp16),\n__nv_bfloat16\n,\ntf32\n, INT8 and double precision (fp64) matrix arithmetic (see\nWarp Matrix Functions\nfor details) with sparsity support,\n16 special function units for single-precision floating-point transcendental functions,\n4 warp schedulers.\nAn SM statically distributes its warps among its schedulers. Then, at every instruction issue time, each scheduler issues one instruction for one of its assigned warps that is ready to execute, if any.\nAn SM has:\na read-only constant cache that is shared by all functional units and speeds up reads from the constant memory space, which resides in device memory,\na unified data cache and shared memory with a total size of 100 KB for devices of compute capability 12.0\nShared memory is partitioned out of the unified data cache, and can be configured to various sizes (see\nShared Memory\n). The remaining data cache serves as an L1 cache and is also used by the texture unit that implements the various addressing and data filtering modes mentioned in\nTexture and Surface Memory\n.\n20.10.2.\nGlobal Memory\nï\nGlobal memory behaves the same way as for devices of compute capability 5.x (See\nGlobal Memory\n).\n20.10.3.\nShared Memory\nï\nThe amount of the unified data cache reserved for shared memory is configurable on a per kernel basis and is identical to\ncompute capability 9.0\n. The unified data cache has a size of 100 KB for devices of compute capability 12.0. The shared memory capacity can be set to 0, 8, 16, 32, 64, or 100 KB.\nAs with the\nNVIDIA Ampere GPU architecture\n, an application can configure its preferred shared memory capacity, i.e., the\ncarveout\n. Devices of compute capability 12.0 allow a single thread block to address up to 99 KB of shared memory. Kernels relying on shared memory allocations over 48 KB per block are architecture-specific, and must use dynamic shared memory rather than statically sized shared memory arrays. These kernels require an explicit opt-in by using\ncudaFuncSetAttribute()\nto set the\ncudaFuncAttributeMaxDynamicSharedMemorySize\n; see\nShared Memory\nfor the Volta architecture.\nNote that the maximum amount of shared memory per thread block is smaller than the maximum shared memory partition available per SM. The 1 KB of shared memory not made available to a thread block is reserved for system use.\n20.10.4.\nFeatures Accelerating Specialized Computations\nï\nThe NVIDIA Blackwell GPU architecture extends features to accelerate matrix multiply-accumulate (MMA) from the NVIDIA Hopper GPU architecture.\nSee the\nPTX ISA\nfor more details.\nThis feature set is only available within the CUDA compilation toolchain through inline PTX.\nIt is strongly recommended that applications utilize this complex feature set through CUDA-X libraries such as cuBLAS, cuDNN, or cuFFT.\nIt is strongly recommended that device kernels utilize this complex feature set through\nCUTLASS\n, a collection of CUDA C++ template abstractions for implementing high-performance matrix-multiplication (GEMM) and related computations at all levels and scales within CUDA.\n27\nabove 48 KB requires dynamic shared memory\n28\n2 FP64 cores for double-precision arithmetic operations for devices of compute capabilities 7.5\n21.\nDriver API\nï\nThis section assumes knowledge of the concepts described in\nCUDA Runtime\n.\nThe driver API is implemented in the\ncuda\ndynamic library (\ncuda.dll\nor\ncuda.so\n) which is copied on the system during the installation of the device driver. All its entry points are prefixed with cu.\nIt is a handle-based, imperative API: Most objects are referenced by opaque handles that may be specified to functions to manipulate the objects.\nThe objects available in the driver API are summarized in\nTable 28\n.\nTable 28\nObjects Available in the CUDA Driver API\nï\nObject\nHandle\nDescription\nDevice\nCUdevice\nCUDA-enabled device\nContext\nCUcontext\nRoughly equivalent to a CPU process\nModule\nCUmodule\nRoughly equivalent to a dynamic library\nFunction\nCUfunction\nKernel\nHeap memory\nCUdeviceptr\nPointer to device memory\nCUDA array\nCUarray\nOpaque container for one-dimensional or two-dimensional data on the device, readable via texture or surface references\nTexture object\nCUtexref\nObject that describes how to interpret texture memory data\nSurface reference\nCUsurfref\nObject that describes how to read or write CUDA arrays\nStream\nCUstream\nObject that describes a CUDA stream\nEvent\nCUevent\nObject that describes a CUDA event\nThe driver API must be initialized with\ncuInit()\nbefore any function from the driver API is called. A CUDA context must then be created that is attached to a specific device and made current to the calling host thread as detailed in\nContext\n.\nWithin a CUDA context, kernels are explicitly loaded as PTX or binary objects by the host code as described in\nModule\n. Kernels written in C++ must therefore be compiled separately into\nPTX\nor binary objects. Kernels are launched using API entry points as described in\nKernel Execution\n.\nAny application that wants to run on future device architectures must load\nPTX\n, not binary code. This is because binary code is architecture-specific and therefore incompatible with future architectures, whereas\nPTX\ncode is compiled to binary code at load time by the device driver.\nHere is the host code of the sample from\nKernels\nwritten using the driver API:\nint\nmain\n()\n{\nint\nN\n=\n...;\nsize_t\nsize\n=\nN\n*\nsizeof\n(\nfloat\n);\n// Allocate input vectors h_A and h_B in host memory\nfloat\n*\nh_A\n=\n(\nfloat\n*\n)\nmalloc\n(\nsize\n);\nfloat\n*\nh_B\n=\n(\nfloat\n*\n)\nmalloc\n(\nsize\n);\n// Initialize input vectors\n...\n// Initialize\ncuInit\n(\n0\n);\n// Get number of devices supporting CUDA\nint\ndeviceCount\n=\n0\n;\ncuDeviceGetCount\n(\n&\ndeviceCount\n);\nif\n(\ndeviceCount\n==\n0\n)\n{\nprintf\n(\n\"There is no device supporting CUDA.\n\\n\n\"\n);\nexit\n(\n0\n);\n}\n// Get handle for device 0\nCUdevice\ncuDevice\n;\ncuDeviceGet\n(\n&\ncuDevice\n,\n0\n);\n// Create context\nCUcontext\ncuContext\n;\ncuCtxCreate\n(\n&\ncuContext\n,\nNULL\n,\n0\n,\ncuDevice\n);\n// Create module from binary file\nCUmodule\ncuModule\n;\ncuModuleLoad\n(\n&\ncuModule\n,\n\"VecAdd.ptx\"\n);\n// Allocate vectors in device memory\nCUdeviceptr\nd_A\n;\ncuMemAlloc\n(\n&\nd_A\n,\nsize\n);\nCUdeviceptr\nd_B\n;\ncuMemAlloc\n(\n&\nd_B\n,\nsize\n);\nCUdeviceptr\nd_C\n;\ncuMemAlloc\n(\n&\nd_C\n,\nsize\n);\n// Copy vectors from host memory to device memory\ncuMemcpyHtoD\n(\nd_A\n,\nh_A\n,\nsize\n);\ncuMemcpyHtoD\n(\nd_B\n,\nh_B\n,\nsize\n);\n// Get function handle from module\nCUfunction\nvecAdd\n;\ncuModuleGetFunction\n(\n&\nvecAdd\n,\ncuModule\n,\n\"VecAdd\"\n);\n// Invoke kernel\nint\nthreadsPerBlock\n=\n256\n;\nint\nblocksPerGrid\n=\n(\nN\n+\nthreadsPerBlock\n-\n1\n)\n/\nthreadsPerBlock\n;\nvoid\n*\nargs\n[]\n=\n{\n&\nd_A\n,\n&\nd_B\n,\n&\nd_C\n,\n&\nN\n};\ncuLaunchKernel\n(\nvecAdd\n,\nblocksPerGrid\n,\n1\n,\n1\n,\nthreadsPerBlock\n,\n1\n,\n1\n,\n0\n,\n0\n,\nargs\n,\n0\n);\n...\n}\nFull code can be found in the\nvectorAddDrv\nCUDA sample.\n21.1.\nContext\nï\nA CUDA context is analogous to a CPU process. All resources and actions performed within the driver API are encapsulated inside a CUDA context, and the system automatically cleans up these resources when the context is destroyed. Besides objects such as modules and texture or surface references, each context has its own distinct address space. As a result,\nCUdeviceptr\nvalues from different contexts reference different memory locations.\nA host thread may have only one device context current at a time. When a context is created with\ncuCtxCreate()\n, it is made current to the calling host thread. CUDA functions that operate in a context (most functions that do not involve device enumeration or context management) will return\nCUDA_ERROR_INVALID_CONTEXT\nif a valid context is not current to the thread.\nEach host thread has a stack of current contexts.\ncuCtxCreate()\npushes the new context onto the top of the stack.\ncuCtxPopCurrent()\nmay be called to detach the context from the host thread. The context is then âfloatingâ and may be pushed as the current context for any host thread.\ncuCtxPopCurrent()\nalso restores the previous current context, if any.\nA usage count is also maintained for each context.\ncuCtxCreate()\ncreates a context with a usage count of 1.\ncuCtxAttach()\nincrements the usage count and\ncuCtxDetach()\ndecrements it. A context is destroyed when the usage count goes to 0 when calling\ncuCtxDetach()\nor\ncuCtxDestroy()\n.\nThe driver API is interoperable with the runtime and it is possible to access the\nprimary context\n(see\nInitialization\n) managed by the runtime from the driver API via\ncuDevicePrimaryCtxRetain()\n.\nUsage count facilitates interoperability between third party authored code operating in the same context. For example, if three libraries are loaded to use the same context, each library would call\ncuCtxAttach()\nto increment the usage count and\ncuCtxDetach()\nto decrement the usage count when the library is done using the context. For most libraries, it is expected that the application will have created a context before loading or initializing the library; that way, the application can create the context using its own heuristics, and the library simply operates on the context handed to it. Libraries that wish to create their own contexts - unbeknownst to their API clients who may or may not have created contexts of their own - would use\ncuCtxPushCurrent()\nand\ncuCtxPopCurrent()\nas illustrated in the following figure.\nFigure 41\nLibrary Context Management\nï\n21.2.\nModule\nï\nModules are dynamically loadable packages of device code and data, akin to DLLs in Windows, that are output by nvcc (see\nCompilation with NVCC\n). The names for all symbols, including functions, global variables, and texture or surface references, are maintained at module scope so that modules written by independent third parties may interoperate in the same CUDA context.\nThis code sample loads a module and retrieves a handle to some kernel:\nCUmodule\ncuModule\n;\ncuModuleLoad\n(\n&\ncuModule\n,\n\"myModule.ptx\"\n);\nCUfunction\nmyKernel\n;\ncuModuleGetFunction\n(\n&\nmyKernel\n,\ncuModule\n,\n\"MyKernel\"\n);\nThis code sample compiles and loads a new module from PTX code and parses compilation errors:\n#define BUFFER_SIZE 8192\nCUmodule\ncuModule\n;\nCUjit_option\noptions\n[\n3\n];\nvoid\n*\nvalues\n[\n3\n];\nchar\n*\nPTXCode\n=\n\"some PTX code\"\n;\nchar\nerror_log\n[\nBUFFER_SIZE\n];\nint\nerr\n;\noptions\n[\n0\n]\n=\nCU_JIT_ERROR_LOG_BUFFER\n;\nvalues\n[\n0\n]\n=\n(\nvoid\n*\n)\nerror_log\n;\noptions\n[\n1\n]\n=\nCU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES\n;\nvalues\n[\n1\n]\n=\n(\nvoid\n*\n)\nBUFFER_SIZE\n;\noptions\n[\n2\n]\n=\nCU_JIT_TARGET_FROM_CUCONTEXT\n;\nvalues\n[\n2\n]\n=\n0\n;\nerr\n=\ncuModuleLoadDataEx\n(\n&\ncuModule\n,\nPTXCode\n,\n3\n,\noptions\n,\nvalues\n);\nif\n(\nerr\n!=\nCUDA_SUCCESS\n)\nprintf\n(\n\"Link error:\n\\n\n%s\n\\n\n\"\n,\nerror_log\n);\nThis code sample compiles, links, and loads a new module from multiple PTX codes and parses link and compilation errors:\n#define BUFFER_SIZE 8192\nCUmodule\ncuModule\n;\nCUjit_option\noptions\n[\n6\n];\nvoid\n*\nvalues\n[\n6\n];\nfloat\nwalltime\n;\nchar\nerror_log\n[\nBUFFER_SIZE\n],\ninfo_log\n[\nBUFFER_SIZE\n];\nchar\n*\nPTXCode0\n=\n\"some PTX code\"\n;\nchar\n*\nPTXCode1\n=\n\"some other PTX code\"\n;\nCUlinkState\nlinkState\n;\nint\nerr\n;\nvoid\n*\ncubin\n;\nsize_t\ncubinSize\n;\noptions\n[\n0\n]\n=\nCU_JIT_WALL_TIME\n;\nvalues\n[\n0\n]\n=\n(\nvoid\n*\n)\n&\nwalltime\n;\noptions\n[\n1\n]\n=\nCU_JIT_INFO_LOG_BUFFER\n;\nvalues\n[\n1\n]\n=\n(\nvoid\n*\n)\ninfo_log\n;\noptions\n[\n2\n]\n=\nCU_JIT_INFO_LOG_BUFFER_SIZE_BYTES\n;\nvalues\n[\n2\n]\n=\n(\nvoid\n*\n)\nBUFFER_SIZE\n;\noptions\n[\n3\n]\n=\nCU_JIT_ERROR_LOG_BUFFER\n;\nvalues\n[\n3\n]\n=\n(\nvoid\n*\n)\nerror_log\n;\noptions\n[\n4\n]\n=\nCU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES\n;\nvalues\n[\n4\n]\n=\n(\nvoid\n*\n)\nBUFFER_SIZE\n;\noptions\n[\n5\n]\n=\nCU_JIT_LOG_VERBOSE\n;\nvalues\n[\n5\n]\n=\n(\nvoid\n*\n)\n1\n;\ncuLinkCreate\n(\n6\n,\noptions\n,\nvalues\n,\n&\nlinkState\n);\nerr\n=\ncuLinkAddData\n(\nlinkState\n,\nCU_JIT_INPUT_PTX\n,\n(\nvoid\n*\n)\nPTXCode0\n,\nstrlen\n(\nPTXCode0\n)\n+\n1\n,\n0\n,\n0\n,\n0\n,\n0\n);\nif\n(\nerr\n!=\nCUDA_SUCCESS\n)\nprintf\n(\n\"Link error:\n\\n\n%s\n\\n\n\"\n,\nerror_log\n);\nerr\n=\ncuLinkAddData\n(\nlinkState\n,\nCU_JIT_INPUT_PTX\n,\n(\nvoid\n*\n)\nPTXCode1\n,\nstrlen\n(\nPTXCode1\n)\n+\n1\n,\n0\n,\n0\n,\n0\n,\n0\n);\nif\n(\nerr\n!=\nCUDA_SUCCESS\n)\nprintf\n(\n\"Link error:\n\\n\n%s\n\\n\n\"\n,\nerror_log\n);\ncuLinkComplete\n(\nlinkState\n,\n&\ncubin\n,\n&\ncubinSize\n);\nprintf\n(\n\"Link completed in %fms. Linker Output:\n\\n\n%s\n\\n\n\"\n,\nwalltime\n,\ninfo_log\n);\ncuModuleLoadData\n(\ncuModule\n,\ncubin\n);\ncuLinkDestroy\n(\nlinkState\n);\nFull code can be found in the\nptxjit\nCUDA sample.\n21.3.\nKernel Execution\nï\ncuLaunchKernel()\nlaunches a kernel with a given execution configuration.\nParameters are passed either as an array of pointers (next to last parameter of\ncuLaunchKernel()\n) where the nth pointer corresponds to the nth parameter and points to a region of memory from which the parameter is copied, or as one of the extra options (last parameter of\ncuLaunchKernel()\n).\nWhen parameters are passed as an extra option (the\nCU_LAUNCH_PARAM_BUFFER_POINTER\noption), they are passed as a pointer to a single buffer where parameters are assumed to be properly offset with respect to each other by matching the alignment requirement for each parameter type in device code.\nAlignment requirements in device code for the built-in vector types are listed in\nTable 7\n. For all other basic types, the alignment requirement in device code matches the alignment requirement in host code and can therefore be obtained using\n__alignof()\n. The only exception is when the host compiler aligns\ndouble\nand\nlong\nlong\n(and\nlong\non a 64-bit system) on a one-word boundary instead of a two-word boundary (for example, using\ngcc\nâs compilation flag\n-mno-align-double\n) since in device code these types are always aligned on a two-word boundary.\nCUdeviceptr\nis an integer, but represents a pointer, so its alignment requirement is\n__alignof(void*)\n.\nThe following code sample uses a macro (\nALIGN_UP()\n) to adjust the offset of each parameter to meet its alignment requirement and another macro (\nADD_TO_PARAM_BUFFER()\n) to add each parameter to the parameter buffer passed to the\nCU_LAUNCH_PARAM_BUFFER_POINTER\noption.\n#define ALIGN_UP(offset, alignment) \\\n(offset) = ((offset) + (alignment) - 1) & ~((alignment) - 1)\nchar\nparamBuffer\n[\n1024\n];\nsize_t\nparamBufferSize\n=\n0\n;\n#define ADD_TO_PARAM_BUFFER(value, alignment)                   \\\ndo {                                                        \\\nparamBufferSize = ALIGN_UP(paramBufferSize, alignment); \\\nmemcpy(paramBuffer + paramBufferSize,                   \\\n&(value), sizeof(value));                        \\\nparamBufferSize += sizeof(value);                       \\\n} while (0)\nint\ni\n;\nADD_TO_PARAM_BUFFER\n(\ni\n,\n__alignof\n(\ni\n));\nfloat4\nf4\n;\nADD_TO_PARAM_BUFFER\n(\nf4\n,\n16\n);\n// float4's alignment is 16\nchar\nc\n;\nADD_TO_PARAM_BUFFER\n(\nc\n,\n__alignof\n(\nc\n));\nfloat\nf\n;\nADD_TO_PARAM_BUFFER\n(\nf\n,\n__alignof\n(\nf\n));\nCUdeviceptr\ndevPtr\n;\nADD_TO_PARAM_BUFFER\n(\ndevPtr\n,\n__alignof\n(\ndevPtr\n));\nfloat2\nf2\n;\nADD_TO_PARAM_BUFFER\n(\nf2\n,\n8\n);\n// float2's alignment is 8\nvoid\n*\nextra\n[]\n=\n{\nCU_LAUNCH_PARAM_BUFFER_POINTER\n,\nparamBuffer\n,\nCU_LAUNCH_PARAM_BUFFER_SIZE\n,\n&\nparamBufferSize\n,\nCU_LAUNCH_PARAM_END\n};\ncuLaunchKernel\n(\ncuFunction\n,\nblockWidth\n,\nblockHeight\n,\nblockDepth\n,\ngridWidth\n,\ngridHeight\n,\ngridDepth\n,\n0\n,\n0\n,\n0\n,\nextra\n);\nThe alignment requirement of a structure is equal to the maximum of the alignment requirements of its fields. The alignment requirement of a structure that contains built-in vector types,\nCUdeviceptr\n, or non-aligned\ndouble\nand\nlong\nlong\n, might therefore differ between device code and host code. Such a structure might also be padded differently. The following structure, for example, is not padded at all in host code, but it is padded in device code with 12 bytes after field\nf\nsince the alignment requirement for field\nf4\nis 16.\ntypedef\nstruct\n{\nfloat\nf\n;\nfloat4\nf4\n;\n}\nmyStruct\n;\n21.4.\nInteroperability between Runtime and Driver APIs\nï\nAn application can mix runtime API code with driver API code.\nIf a context is created and made current via the driver API, subsequent runtime calls will pick up this context instead of creating a new one.\nIf the runtime is initialized (implicitly as mentioned in\nCUDA Runtime\n),\ncuCtxGetCurrent()\ncan be used to retrieve the context created during initialization. This context can be used by subsequent driver API calls.\nThe implicitly created context from the runtime is called the\nprimary context\n(see\nInitialization\n). It can be managed from the driver API with the\nPrimary Context Management\nfunctions.\nDevice memory can be allocated and freed using either API.\nCUdeviceptr\ncan be cast to regular pointers and vice-versa:\nCUdeviceptr\ndevPtr\n;\nfloat\n*\nd_data\n;\n// Allocation using driver API\ncuMemAlloc\n(\n&\ndevPtr\n,\nsize\n);\nd_data\n=\n(\nfloat\n*\n)\ndevPtr\n;\n// Allocation using runtime API\ncudaMalloc\n(\n&\nd_data\n,\nsize\n);\ndevPtr\n=\n(\nCUdeviceptr\n)\nd_data\n;\nIn particular, this means that applications written using the driver API can invoke libraries written using the runtime API (such as cuFFT, cuBLAS, â¦).\nAll functions from the device and version management sections of the reference manual can be used interchangeably.\n21.5.\nDriver Entry Point Access\nï\n21.5.1.\nIntroduction\nï\nThe\nDriver\nEntry\nPoint\nAccess\nAPIs\nprovide a way to retrieve the address of a CUDA driver function. Starting from CUDA 11.3, users can call into available CUDA driver APIs using function pointers obtained from these APIs.\nThese APIs provide functionality similar to their counterparts, dlsym on POSIX platforms and GetProcAddress on Windows. The provided APIs will let users:\nRetrieve the address of a driver function using the\nCUDA\nDriver\nAPI.\nRetrieve the address of a driver function using the\nCUDA\nRuntime\nAPI.\nRequest\nper-thread default stream\nversion of a CUDA driver function. For more details, see\nRetrieve Per-thread Default Stream Versions\n.\nAccess new CUDA features on older toolkits but with a newer driver.\n21.5.2.\nDriver Function Typedefs\nï\nTo help retrieve the CUDA Driver API entry points, the CUDA Toolkit provides access to headers containing the function pointer definitions for all CUDA driver APIs. These headers are installed with the CUDA Toolkit and are made available in the toolkitâs\ninclude/\ndirectory. The table below summarizes the header files containing the\ntypedefs\nfor each CUDA API header file.\nTable 29\nTypedefs header files for CUDA driver APIs\nï\nAPI header file\nAPI Typedef header file\ncuda.h\ncudaTypedefs.h\ncudaGL.h\ncudaGLTypedefs.h\ncudaProfiler.h\ncudaProfilerTypedefs.h\ncudaVDPAU.h\ncudaVDPAUTypedefs.h\ncudaEGL.h\ncudaEGLTypedefs.h\ncudaD3D9.h\ncudaD3D9Typedefs.h\ncudaD3D10.h\ncudaD3D10Typedefs.h\ncudaD3D11.h\ncudaD3D11Typedefs.h\nThe above headers do not define actual function pointers themselves; they define the typedefs for function pointers. For example,\ncudaTypedefs.h\nhas the below typedefs for the driver API\ncuMemAlloc\n:\ntypedef\nCUresult\n(\nCUDAAPI\n*\nPFN_cuMemAlloc_v3020\n)(\nCUdeviceptr_v2\n*\ndptr\n,\nsize_t\nbytesize\n);\ntypedef\nCUresult\n(\nCUDAAPI\n*\nPFN_cuMemAlloc_v2000\n)(\nCUdeviceptr_v1\n*\ndptr\n,\nunsigned\nint\nbytesize\n);\nCUDA driver symbols have a version based naming scheme with a\n_v*\nextension in its name except for the first version. When the signature or the semantics of a specific CUDA driver API changes, we increment the version number of the corresponding driver symbol. In the case of the\ncuMemAlloc\ndriver API, the first driver symbol name is\ncuMemAlloc\nand the next symbol name is\ncuMemAlloc_v2\n. The typedef for the first version which was introduced in CUDA 2.0 (2000) is\nPFN_cuMemAlloc_v2000\n. The typedef for the next version which was introduced in CUDA 3.2 (3020) is\nPFN_cuMemAlloc_v3020\n.\nThe\ntypedefs\ncan be used to more easily define a function pointer of the appropriate type in code:\nPFN_cuMemAlloc_v3020\npfn_cuMemAlloc_v2\n;\nPFN_cuMemAlloc_v2000\npfn_cuMemAlloc_v1\n;\n21.5.3.\nDriver Function Retrieval\nï\nUsing the Driver Entry Point Access APIs and the appropriate typedef, we can get the function pointer to any CUDA driver API.\n21.5.3.1.\nUsing the Driver API\nï\nThe driver API requires CUDA version as an argument to get the ABI compatible version for the requested driver symbol. CUDA Driver APIs have a per-function ABI denoted with a\n_v*\nextension. For example, consider the versions of\ncuStreamBeginCapture\nand their corresponding\ntypedefs\nfrom\ncudaTypedefs.h\n:\n// cuda.h\nCUresult\nCUDAAPI\ncuStreamBeginCapture\n(\nCUstream\nhStream\n);\nCUresult\nCUDAAPI\ncuStreamBeginCapture_v2\n(\nCUstream\nhStream\n,\nCUstreamCaptureMode\nmode\n);\n// cudaTypedefs.h\ntypedef\nCUresult\n(\nCUDAAPI\n*\nPFN_cuStreamBeginCapture_v10000\n)(\nCUstream\nhStream\n);\ntypedef\nCUresult\n(\nCUDAAPI\n*\nPFN_cuStreamBeginCapture_v10010\n)(\nCUstream\nhStream\n,\nCUstreamCaptureMode\nmode\n);\nFrom the above\ntypedefs\nin the code snippet, version suffixes\n_v10000\nand\n_v10010\nindicate that the above APIs were introduced in CUDA 10.0 and CUDA 10.1 respectively.\n#include\n<cudaTypedefs.h>\n// Declare the entry points for cuStreamBeginCapture\nPFN_cuStreamBeginCapture_v10000\npfn_cuStreamBeginCapture_v1\n;\nPFN_cuStreamBeginCapture_v10010\npfn_cuStreamBeginCapture_v2\n;\n// Get the function pointer to the cuStreamBeginCapture driver symbol\ncuGetProcAddress\n(\n\"cuStreamBeginCapture\"\n,\n&\npfn_cuStreamBeginCapture_v1\n,\n10000\n,\nCU_GET_PROC_ADDRESS_DEFAULT\n,\n&\ndriverStatus\n);\n// Get the function pointer to the cuStreamBeginCapture_v2 driver symbol\ncuGetProcAddress\n(\n\"cuStreamBeginCapture\"\n,\n&\npfn_cuStreamBeginCapture_v2\n,\n10010\n,\nCU_GET_PROC_ADDRESS_DEFAULT\n,\n&\ndriverStatus\n);\nReferring to the code snippet above, to retrieve the address to the\n_v1\nversion of the driver API\ncuStreamBeginCapture\n, the CUDA version argument should be exactly 10.0 (10000). Similarly, the CUDA version for retrieving the address to the\n_v2\nversion of the API should be 10.1 (10010). Specifying a higher CUDA version for retrieving a specific version of a driver API might not always be portable. For example, using 11030 here would still return the\n_v2\nsymbol, but if a hypothetical\n_v3\nversion is released in CUDA 11.3, the\ncuGetProcAddress\nAPI would start returning the newer\n_v3\nsymbol instead when paired with a CUDA 11.3 driver. Since the ABI and function signatures of the\n_v2\nand\n_v3\nsymbols might differ, calling the\n_v3\nfunction using the\n_v10010\ntypedef intended for the\n_v2\nsymbol would exhibit undefined behavior.\nNote that requesting a driver API with an invalid CUDA version will return an error\nCUDA_ERROR_NOT_FOUND\n. In the above code examples, passing in a version less than 10000 (CUDA 10.0) would be invalid.\n21.5.3.2.\nUsing the Runtime API\nï\nThe runtime API\ncudaGetDriverEntryPointByVersion\nuses the provided CUDA version to get the ABI compatible version for the requested driver symbol in the same way\ncuGetProcAddress\ndoes. In the below code snippet, the minimum CUDA version required would be CUDA 11.2 as\ncuMemAllocAsync\nwas introduced then.\n#include\n<cudaTypedefs.h>\nint\ncudaVersion\n;\n// Ensure a CUDA driver >= 11.2 is installed or we will get an error from cuGetProcAddress\nstatus\n=\ncuDriverGetVersion\n(\n&\ncudaVersion\n);\nif\n(\ncudaVersion\n>=\n11020\n)\n{\n// Declare the entry point\nPFN_cuMemAllocAsync_v11020\npfn_cuMemAllocAsync\n;\n// Intialize the entry point\ncudaGetDriverEntryPointByVersion\n(\n\"cuMemAllocAsync\"\n,\n&\npfn_cuMemAllocAsync\n,\n11020\n,\ncudaEnableDefault\n,\n&\ndriverStatus\n);\n// Call the entry point\nif\n(\ndriverStatus\n==\ncudaDriverEntryPointSuccess\n&&\npfn_cuMemAllocAsync\n)\n{\npfn_cuMemAllocAsync\n(...);\n}\n}\n21.5.3.3.\nRetrieve Per-thread Default Stream Versions\nï\nSome CUDA driver APIs can be configured to have\ndefault stream\nor\nper-thread default stream\nsemantics. Driver APIs having\nper-thread default stream\nsemantics are suffixed with\n_ptsz\nor\n_ptds\nin their name. For example,\ncuLaunchKernel\nhas a\nper-thread default stream\nvariant named\ncuLaunchKernel_ptsz\n. With the Driver Entry Point Access APIs, users can request for the\nper-thread default stream\nversion of the driver API\ncuLaunchKernel\ninstead of the\ndefault stream\nversion. Configuring the CUDA driver APIs for\ndefault stream\nor\nper-thread default stream\nsemantics affects the synchronization behavior. More details can be found\nhere\n.\nThe\ndefault stream\nor\nper-thread default stream\nversions of a driver API can be obtained by one of the following ways:\nUse the compilation flag\n--default-stream\nper-thread\nor define the macro\nCUDA_API_PER_THREAD_DEFAULT_STREAM\nto get\nper-thread default stream\nbehavior.\nForce\ndefault stream\nor\nper-thread default stream\nbehavior using the flags\nCU_GET_PROC_ADDRESS_LEGACY_STREAM/cudaEnableLegacyStream\nor\nCU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM/cudaEnablePerThreadDefaultStream\nrespectively.\n21.5.3.4.\nAccess New CUDA features\nï\nIt is always recommended to install the latest CUDA toolkit to access new CUDA driver features, but if for some reason, a user does not want to update or does not have access to the latest toolkit, the API can be used to access new CUDA features with only an updated CUDA driver. For discussion, let us assume the user is on CUDA 12.3 and wants to use a new driver API\ncuFoo\navailable in the CUDA 12.5 driver. The below code snippet illustrates this use-case:\nint\nmain\n()\n{\n// Manually define the prototype as cudaTypedefs.h in CUDA 12.3 does not have the cuFoo typedef\ntypedef\nCUresult\n(\nCUDAAPI\n*\nPFN_cuFoo_v12050\n)(...);\nPFN_cuFoo_v12050\npfn_cuFoo\n=\nNULL\n;\nCUdriverProcAddressQueryResult\ndriverStatus\n;\nint\ncudaVersion\n;\n// Ensure a CUDA driver >= 12.5 is installed or we will get an error from cuGetProcAddress\nstatus\n=\ncuDriverGetVersion\n(\n&\ncudaVersion\n);\nif\n(\ncudaVersion\n>=\n12050\n)\n{\n// Get the address for cuFoo API using cuGetProcAddress. Specify CUDA version as\n// 12050 since cuFoo was introduced then\nCUresult\nstatus\n=\ncuGetProcAddress\n(\n\"cuFoo\"\n,\n&\npfn_cuFoo\n,\n12050\n,\nCU_GET_PROC_ADDRESS_DEFAULT\n,\n&\ndriverStatus\n);\nif\n(\nstatus\n==\nCUDA_SUCCESS\n&&\npfn_cuFoo\n)\n{\npfn_cuFoo\n(...);\n}\nelse\n{\nprintf\n(\n\"Cannot retrieve the address to cuFoo - driverStatus = %d\n\\n\n\"\n,\ndriverStatus\n);\nassert\n(\n0\n);\n}\n}\n// rest of code here\n}\nIn the next example, we discuss how to get a new version of an API released in a minor version of the CUDA Toolkit. Note that in the cuda.h header the version macro that would bump\ncuDeviceGetUuid\nto _v2 is not done until a major boundary. So during the 11.4+ releases the following example illustrates how to get the _v2 version.\nNote in this case the original (not the _v2 version) typedef looks like:\ntypedef\nCUresult\n(\nCUDAAPI\n*\nPFN_cuDeviceGetUuid_v9020\n)(\nCUuuid\n*\nuuid\n,\nCUdevice_v1\ndev\n);\nBut the _v2 version typedef looks like:\ntypedef\nCUresult\n(\nCUDAAPI\n*\nPFN_cuDeviceGetUuid_v11040\n)(\nCUuuid\n*\nuuid\n,\nCUdevice_v1\ndev\n);\n#include\n<cudaTypedefs.h>\nCUuuid\nuuid\n;\nCUdevice\ndev\n;\nCUresult\nstatus\n;\nint\ncudaVersion\n;\nCUdriverProcAddressQueryResult\ndriverStatus\n;\nstatus\n=\ncuDeviceGet\n(\n&\ndev\n,\n0\n);\n// Get device 0\n// handle status\nstatus\n=\ncuDriverGetVersion\n(\n&\ncudaVersion\n);\n// handle status\n// Ensure a CUDA driver >= 11.4 is installed or we will get an error from cuGetProcAddress\nstatus\n=\ncuDriverGetVersion\n(\n&\ncudaVersion\n);\nif\n(\ncudaVersion\n>=\n11040\n)\n{\nPFN_cuDeviceGetUuid_v11040\npfn_cuDeviceGetUuid\n;\nstatus\n=\ncuGetProcAddress\n(\n\"cuDeviceGetUuid\"\n,\n&\npfn_cuDeviceGetUuid\n,\n11040\n,\nCU_GET_PROC_ADDRESS_DEFAULT\n,\n&\ndriverStatus\n);\nif\n(\nCUDA_SUCCESS\n==\nstatus\n&&\npfn_cuDeviceGetUuid\n)\n{\npfn_cuDeviceGetUuid\n(\n&\nuuid\n,\ndev\n);\n}\n}\n21.5.4.\nGuidelines for cuGetProcAddress\nï\nBelow are guidelines to keep in mind when using\ncuGetProcAddress\n.\nCode the CUDA version passed to\ncuGetProcAddress\nto match the typedef version (do not use a compile time constant such as\nCUDA_VERSION\nor a dynamic version such as returned from\ncuDriverGetVersion\n)\nCheck the current driver version (such as from\ncuDriverGetVersion\n) is sufficient before calling\ncuGetProcAddress\nor an error is expected or an unexpected symbol may be returned\n21.5.4.1.\nGuidelines for Runtime API Usage\nï\nUnless specified otherwise, the CUDA runtime API\ncudaGetDriverEntryPointByVersion\nwill have similar guidelines as the driver entry point\ncuGetProcAddress\nsince it allows for the user to request a specific CUDA driver version.\n21.5.5.\nDetermining cuGetProcAddress Failure Reasons\nï\nThere are two types of errors with cuGetProcAddress. Those are (1) API/usage errors and (2) inability to find the driver API requested. The first error type will return error codes from the API via the CUresult return value. Things like passing NULL as the\npfn\nvariable or passing invalid\nflags\n.\nThe second error type encodes in the\nCUdriverProcAddressQueryResult\n*symbolStatus\nand can be used to help distinguish potential issues with the driver not being able to find the symbol requested. Take the following example:\n// cuDeviceGetExecAffinitySupport was introduced in release CUDA 11.4\n#include\n<cuda.h>\nCUdriverProcAddressQueryResult\ndriverStatus\n;\ncudaVersion\n=\n...;\nstatus\n=\ncuGetProcAddress\n(\n\"cuDeviceGetExecAffinitySupport\"\n,\n&\npfn\n,\ncudaVersion\n,\n0\n,\n&\ndriverStatus\n);\nif\n(\nCUDA_SUCCESS\n==\nstatus\n)\n{\nif\n(\nCU_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT\n==\ndriverStatus\n)\n{\nprintf\n(\n\"We can use the new feature when you upgrade cudaVersion to 11.4, but CUDA driver is good to go!\n\\n\n\"\n);\n// Indicating cudaVersion was < 11.4 but run against a CUDA driver >= 11.4\n}\nelse\nif\n(\nCU_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND\n==\ndriverStatus\n)\n{\nprintf\n(\n\"Please update both CUDA driver and cudaVersion to at least 11.4 to use the new feature!\n\\n\n\"\n);\n// Indicating driver is < 11.4 since string not found, doesn't matter what cudaVersion was\n}\nelse\nif\n(\nCU_GET_PROC_ADDRESS_SUCCESS\n==\ndriverStatus\n&&\npfn\n)\n{\nprintf\n(\n\"You're using cudaVersion and CUDA driver >= 11.4, using new feature!\n\\n\n\"\n);\npfn\n();\n}\n}\nThe first case with the return code\nCU_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT\nindicates that the\nsymbol\nwas found when searching in the CUDA driver but it was added later than the\ncudaVersion\nsupplied. In the example, specifying\ncudaVersion\nas anything 11030 or less and when running against a CUDA driver >= CUDA 11.4 would give this result of\nCU_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT\n. This is because\ncuDeviceGetExecAffinitySupport\nwas added in CUDA 11.4 (11040).\nThe second case with the return code\nCU_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND\nindicates that the\nsymbol\nwas not found when searching in the CUDA driver. This can be due to a few reasons such as unsupported CUDA function due to older driver as well as just having a typo. In the latter, similar to the last example if the user had put\nsymbol\nas CUDeviceGetExecAffinitySupport - notice the capital CU to start the string -\ncuGetProcAddress\nwould not be able to find the API because the string doesnât match. In the former case an example might be the user developing an application against a CUDA driver supporting the new API, and deploying the application against an older CUDA driver. Using the last example, if the developer developed against CUDA 11.4 or later but was deployed against a CUDA 11.3 driver, during their development they may have had a succesful\ncuGetProcAddress\n, but when deploying an application running against a CUDA 11.3 driver the call would no longer work with the\nCU_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND\nreturned in\ndriverStatus\n.\n22.\nCUDA Environment Variables\nï\nThe following table lists the CUDA environment variables. Environment variables related to the Multi-Process Service are documented in the Multi-Process Service section of the GPU Deployment and Management guide.\nTable 30\nCUDA Environment Variables\nï\nVariable\nValues\nDescription\nDevice Enumeration and Properties\nCUDA_VISIBLE_DEVICES\nA comma-separated sequence of GPU identifiers\nMIG support:\nMIG-<GPU-UUID>/<GPU\ninstance\nID>/<compute\ninstance\nID>\nGPU identifiers are given as integer indices or as UUID strings. GPU UUID strings should follow the same format as given by\nnvidia-smi\n, such as GPU-8932f937-d72c-4106-c12f-20bd9faed9f6. However, for convenience, abbreviated forms are allowed; simply specify enough digits from the beginning of the GPU UUID to uniquely identify that GPU in the target system. For example, CUDA_VISIBLE_DEVICES=GPU-8932f937 may be a valid way to refer to the above GPU UUID, assuming no other GPU in the system shares this prefix.\nOnly the devices whose index is present in the sequence are visible to CUDA applications and they are enumerated in the order of the sequence. If one of the indices is invalid, only the devices whose index precedes the invalid index are visible to CUDA applications. For example, setting CUDA_VISIBLE_DEVICES to 2,1 causes device 0 to be invisible and device 2 to be enumerated before device 1. Setting CUDA_VISIBLE_DEVICES to 0,2,-1,1 causes devices 0 and 2 to be visible and device 1 to be invisible.\nMIG format starts with MIG keyword and GPU UUID should follow the same format as given by\nnvidia-smi\n. For example, MIG-GPU-8932f937-d72c-4106-c12f-20bd9faed9f6/1/2. Only single MIG instance enumeration is supported.\nCUDA_MANAGED_FORCE_DEVICE_ALLOC\n0 or 1 (default is 0)\nForces the driver to place all managed allocations in device memory.\nCUDA_DEVICE_ORDER\nFASTEST_FIRST, PCI_BUS_ID, (default is FASTEST_FIRST)\nFASTEST_FIRST causes CUDA to enumerate the available devices in fastest to slowest order using a simple heuristic. PCI_BUS_ID orders devices by PCI bus ID in ascending order.\nCompilation\nCUDA_CACHE_DISABLE\n0 or 1 (default is 0)\nDisables caching (when set to 1) or enables caching (when set to 0) for just-in-time-compilation. When disabled, no binary code is added to or retrieved from the cache.\nCUDA_CACHE_PATH\nfilepath\nSpecifies the folder where the just-in-time compiler caches binary codes; the default values are:\non Windows,\n%APPDATA%\\NVIDIA\\ComputeCache\non Linux,\n~/.nv/ComputeCache\nCUDA_CACHE_MAXSIZE\ninteger (default is 1073741824 (1 GiB) for desktop/server platforms and 268435456 (256 MiB) for embedded platforms and the maximum is 4294967296 (4 GiB))\nSpecifies the size in bytes of the cache used by the just-in-time compiler. Binary codes whose size exceeds the cache size are not cached. Older binary codes are evicted from the cache to make room for newer binary codes if needed.\nCUDA_FORCE_PTX_JIT\n0 or 1 (default is 0)\nWhen set to 1, forces the device driver to ignore any binary code embedded in an application (see\nApplication Compatibility\n) and to just-in-time compile embedded PTX code instead. If a kernel does not have embedded PTX code, it will fail to load. This environment variable can be used to validate that PTX code is embedded in an application and that its just-in-time compilation works as expected to guarantee application forward compatibility with future architectures (see\nJust-in-Time Compilation\n).\nCUDA_DISABLE_PTX_JIT\n0 or 1 (default is 0)\nWhen set to 1, disables the just-in-time compilation of embedded PTX code and use the compatible binary code embedded in an application (see\nApplication Compatibility\n). If a kernel does not have embedded binary code or the embedded binary was compiled for an incompatible architecture, then it will fail to load. This environment variable can be used to validate that an application has the compatible\nSASS\ncode generated for each kernel.(see\nBinary Compatibility\n).\nCUDA_FORCE_JIT\n0 or 1 (default is 0)\nWhen set to 1, forces the device driver to ignore any binary code embedded in an application (see\nApplication Compatibility\n) and to just-in-time compile embedded PTX code instead. If a kernel does not have embedded PTX code, it will fail to load. This environment variable can be used to validate that PTX code is embedded in an application and that its just-in-time compilation works as expected to guarantee application forward compatibility with future architectures (see\nJust-in-Time Compilation\n). The behavior can be overridden for embedded PTX by setting\nCUDA_FORCE_PTX_JIT=0\n.\nCUDA_DISABLE_JIT\n0 or 1 (default is 0)\nWhen set to 1, disables the just-in-time compilation of embedded PTX code and use the compatible binary code embedded in an application (see\nApplication Compatibility\n). If a kernel does not have embedded binary code or the embedded binary was compiled for an incompatible architecture, then it will fail to load. This environment variable can be used to validate that an application has the compatible SASS code generated for each kernel.(see\nBinary Compatibility\n). The behavior can be overridden for embedded PTX by setting\nCUDA_DISABLE_PTX_JIT=0\n.\nExecution\nCUDA_LAUNCH_BLOCKING\n0 or 1 (default is 0)\nDisables (when set to 1) or enables (when set to 0) asynchronous kernel launches.\nCUDA_DEVICE_MAX_CONNECTIONS\n1 to 32 (default is 8)\nSets the number of compute and copy engine concurrent connections (work queues) from the host to each device of compute capability 3.5 and above.\nCUDA_DEVICE_MAX_COPY_CONNECTIONS\n1 to 32 (default is 8)\nSets the number of copy engine concurrent connections (work queues) per async copy engine from the host to each device of compute capability 8.0 and above. When both CUDA_DEVICE_MAX_CONNECTIONS and CUDA_DEVICE_MAX_COPY_CONNECTIONS are set,  only the number of copy connections set by CUDA_DEVICE_MAX_CONNECTIONS will be overwritten.\nCUDA_AUTO_BOOST\n0 or 1\nOverrides the autoboost behavior set by the âauto-boost-default option of nvidia-smi. If an application requests via this environment variable a behavior that is different from nvidia-smiâs, its request is honored if there is no other application currently running on the same GPU that successfully requested a different behavior, otherwise it is ignored.\nCUDA_SCALE_LAUNCH_QUEUES\nâ0.25xâ, â0.5xâ, â2xâ or â4xâ\nScales the size of the queues available for launching work by a fixed multiplier.\ncuda-gdb (on Linux platform)\nCUDA_DEVICE_WAITS_ON_EXCEPTION\n0 or 1 (default is 0)\nWhen set to 1, a CUDA application will halt when a device exception occurs, allowing a debugger to be attached for further debugging.\nMPS service (on Linux platform)\nCUDA_DEVICE_DEFAULT_PERSISTING_L2_CACHE_PERCENTAGE_LIMIT\nPercentage value (between 0 - 100, default is 0)\nDevices of compute capability 8.x allow, a portion of L2 cache to be set-aside for persisting data accesses to global memory. When using CUDA MPS service, the set-aside size can only be controlled using this environment variable, before starting CUDA MPS control daemon. I.e., the environment variable should be set before running the command\nnvidia-cuda-mps-control\n-d\n.\nModule loading\nCUDA_MODULE_LOADING\nDEFAULT, LAZY, EAGER (default is LAZY)\nSpecifies the module loading mode for the application. When set to EAGER, all kernels and data from a cubin, fatbin or a PTX file are fully loaded upon corresponding\ncuModuleLoad*\nand\ncuLibraryLoad*\nAPI call. When set to LAZY, loading of specific kernels is delayed to the point a CUfunc handle is extracted with\ncuModuleGetFunction\nor\ncuKernelGetFunction\nAPI calls and data from the cubin is loaded at load of first kernel in the cubin or at first access of variables in the cubin. Default behavior may change in future CUDA releases.\nCUDA_MODULE_DATA_LOADING\nDEFAULT, LAZY, EAGER (default is LAZY)\nSpecifies the data loading mode for the application. When set to EAGER, all data from a cubin, fatbin or a PTX file are fully loaded to memory upon corresponding\ncuLibraryLoad*\n. This doesnât affect the LAZY or EAGER loading of kernels. When set to LAZY, loading of data is delayed to the point at which a handle is required. Default behavior may change in future CUDA releases. Data loading behavior is inherited from\nCUDA_MODULE_LOADING\nif this environment variable is not set.\nPre-loading dependent libraries\nCUDA_FORCE_PRELOAD_LIBRARIES\n0 or 1 (default is 0)\nWhen set to 1, forces the driver to preload the libraries required for NVVM and PTX just-in-time compilation during driver initialization. This will increase the memory footprint and the time taken for CUDA driver initialization. This environment variable needs to be set to avoid certain deadlock situations involving multiple CUDA threads.\nCUDA Graphs\nCUDA_GRAPHS_USE_NODE_PRIORITY\n0 or 1\nOverrides the cudaGraphInstantiateFlagUseNodePriority flag on graph instantiation. When set to 1, the flag will be set for all graphs and when set to 0, the flag will be cleared for all graphs.\nCUDA Error Log Management\nCUDA_LOG_FILE\nstdout, stderr, or valid file path\nProvides a location for printing error logs as they occur. See the\nError\nLog\nManagement\nsection for more details.\n23.\nError Log Management\nï\nThe\nError Log Management\nmechanism allows for CUDA API errors to be reported\nto developers in a plain-English format that describes the cause of the issue.\n23.1.\nBackground\nï\nTraditionally, the only indication of a failed CUDA API call is the return of a non-zero code.\nAs of CUDA Toolkit 12.9, the CUDA Runtime defines over 100 different return codes\nfor error conditions, but many of them are generic and give the developer no assistance with debugging the cause.\n23.2.\nActivation\nï\nSet the\nCUDA_LOG_FILE\nenvironment variable. Acceptable values are\nstdout\n,\nstderr\n, or a valid path on the system to write a file.\nThe log buffer can be dumped via API even if\nCUDA_LOG_FILE\nwas not set before program execution.\nNOTE: An error-free execution may not print any logs.\n23.3.\nOutput\nï\nLogs are output in the following format:\n[\nTime\n][\nTID\n][\nSource\n][\nSeverity\n][\nAPI\nEntry\nPoint\n]\nMessage\nThe following line is an actual error message that is generated if the developer tries to dump the Error Log Management logs to an unallocated buffer:\n[\n22\n:\n21\n:\n32.099\n][\n25642\n][\nCUDA\n][\nE\n][\ncuLogsDumpToMemory\n]\nbuffer\ncannot\nbe\nNULL\nWhere before, all the developer would have gotten is\nCUDA_ERROR_INVALID_VALUE\nin the return code and possibly âinvalid argumentâ if\ncuGetErrorString\nis called.\n23.4.\nAPI Description\nï\nThe CUDA Driver provides APIs in two categories for interacting with the Error Log Management feature.\nThis feature allows developers to register callback functions to be used whenever an error log is generated, where the callback signature is:\nvoid\ncallbackFunc\n(\nvoid\n*\ndata\n,\nCUlogLevel\nlogLevel\n,\nchar\n*\nmessage\n,\nsize_t\nlength\n)\nCallbacks are registered with this API:\nCUresult\ncuLogsRegisterCallback\n(\nCUlogsCallback\ncallbackFunc\n,\nvoid\n*\nuserData\n,\nCUlogsCallbackHandle\n*\ncallback_out\n)\nWhere\nuserData\nis passed to the callback function without modifications.\ncallback_out\nshould be stored by the caller for use in\ncuLogsUnregisterCallback\n.\nCUresult\ncuLogsUnregisterCallback\n(\nCUlogsCallbackHandle\ncallback\n)\nThe other set of API functions are for managing the output of logs. An important concept is the log iterator, which points to the current end of the buffer:\nCUresult\ncuLogsCurrent\n(\nCUlogIterator\n*\niterator_out\n,\nunsigned\nint\nflags\n)\nThe iterator position can be kept by the calling software in situations where a dump of the entire log buffer is not desired. Currently, the flags parameter must be 0, with additional options reserved for future CUDA releases.\nAt any time, the error log buffer can be dumped to either a file or memory with these functions:\nCUresult\ncuLogsDumpToFile\n(\nCUlogIterator\n*\niterator\n,\nconst\nchar\n*\npathToFile\n,\nunsigned\nint\nflags\n)\nCUresult\ncuLogsDumpToMemory\n(\nCUlogIterator\n*\niterator\n,\nchar\n*\nbuffer\n,\nsize_t\n*\nsize\n,\nunsigned\nint\nflags\n)\nIf\niterator\nis NULL, the entire buffer will be dumped, up to the maximum of 100 entries. If\niterator\nis not NULL, logs will be dumped starting from that entry and the value of\niterator\nwill be updated to the current end of the logs, as if\ncuLogsCurrent\nhad been called. If there have been more than 100 log entries into the buffer, a note will be added at the start of the dump noting this.\nThe flags parameter must be 0, with additional options reserved for future CUDA releases.\nThe\ncuLogsDumpToMemory\nfunction has additional considerations:\nThe buffer itself will be null-terminated, but each individual log entry will only be separated by a newline (n) character.\nThe maximum size of the buffer is 25600 bytes.\nIf the value provided in\nsize\nis not sufficient to store all desired logs, a note will be added as the first entry and the oldest entries that do not fit will not be dumped.\nAfter returning,\nsize\nwill contain the actual number of bytes written to the provided buffer.\n23.5.\nLimitations and Known Issues\nï\nThe log buffer is limited to 100 entries. After this limit is reached, the oldest entries will be replaced and log dumps will contain a line noting the rollover.\nNot all CUDA APIs are covered yet. This is an ongoing project to provide better usage error reporting for all APIs.\nThe Error Log Management log location (if given) will not be tested for validity until/unless a log is generated.\nThe Error Log Management APIs are currently only available via the CUDA Driver. Equivalent APIs will be added to the CUDA Runtime in a future release.\nThe log messages are not localized to any language and all provided logs are in US English.\n24.\nUnified Memory Programming\nï\nNote\nThis chapter applies to devices with compute capability 5.0 or higher unless stated otherwise.\nFor devices with compute capability lower than 5.0, refer to the CUDA toolkit documentation for CUDA 11.8.\nThis documentation on Unified Memory is divided into 3 parts:\nGeneral description of unified memory\nUnified Memory on devices with full CUDA Unified Memory support\nUnified Memory on devices without full CUDA Unified Memory support\n24.1.\nUnified Memory Introduction\nï\nCUDA Unified Memory provides all processors with:\nA single\nunified\nmemory pool, that is,\na single pointer value enables all processors in the system\n(all CPUs, all GPUs, etc.)\nto access this memory with all of their native memory operations\n(pointer dereferences, atomics, etc.).\nConcurrent access to the unified memory pool from all processors in the system.\nUnified Memory improves GPU programming in several ways:\nProductivity\n: GPU programs may access Unified Memory from GPU and CPU threads\nconcurrently without needing to create separate allocations (\ncudaMalloc()\n) and\ncopy memory manually back and forth (\ncudaMemcpy*()\n).\nPerformance\n:\nData access speed may be maximized by migrating data towards processors that access it most frequently.\nApplications can trigger manual migration of data and may use hints to control migration heuristics.\nTotal system memory usage may be reduced by avoiding duplicating memory on both CPUs and GPUs.\nFunctionality\n: It enables GPU programs to work on data that exceeds the GPU memoryâs capacity.\nWith CUDA Unified Memory, data movement still takes place, and hints may improve performance.\nThese hints are not required for correctness or functionality, that is, programmers may focus on parallelizing\ntheir applications across GPUs and CPUs first, and worry about data-movement later in the development cycle as a performance optimization.\nNote that the physical location of data is invisible to a program and may be changed at any time,\nbut accesses to the dataâs virtual address will remain valid and coherent from any processor regardless of locality.\nThere are two main ways to obtain CUDA Unified Memory:\nSystem-Allocated Memory\n: memory allocated on the host with system APIs:\nstack variables, global-/file-scope variables,\nmalloc()\n/\nmmap()\n(see\nSystem-Allocated Memory: in-depth examples\nfor in-depth examples), thread locals, etc.\nCUDA APIs that explicitly allocate Unified Memory\n: memory allocated with, for example,\ncudaMallocManaged()\n,\nare available on more systems and may perform better than System-Allocated Memory.\n24.1.1.\nSystem Requirements for Unified Memory\nï\nThe following table shows the different levels of support for CUDA Unified Memory,\nthe device properties required to detect these levels of support\nand links to the documentation specific to each level of support:\nTable 31\nOverview of levels of unified memory support\nï\nUnified Memory Support Level\nSystem device properties\nFurther documentation\nFull CUDA Unified Memory: all memory has full support. This includes System-Allocated and CUDA Managed Memory.\nSet to 1:\npageableMemoryAccess\nSystems with hardware acceleration\nalso have the following properties set to 1:\nhostNativeAtomicSupported\n,\npageableMemoryAccessUsesHostPageTables\n,\ndirectManagedMemAccessFromHost\nUnified Memory on devices with full CUDA Unified Memory support\nOnly CUDA Managed Memory has full support.\nSet to 1:\nconcurrentManagedAccess\nSet to 0:\npageableMemoryAccess\nUnified Memory on devices with only CUDA Managed Memory support\nCUDA Managed Memory without full support: unified addressing but no concurrent access.\nSet to 1:\nmanagedMemory\nSet to 0:\nconcurrentManagedAccess\nUnified Memory on Windows or devices with compute capability 5.x\nCUDA for Tegra Memory Management\nUnified Memory on Tegra\nNo Unified Memory support.\nSet to 0:\nmanagedMemory\nCUDA for Tegra Memory Management\nThe behavior of an application that attempts to use Unified Memory on a system that does not support it is undefined.\nThe following properties enable CUDA applications to check the level of system support for Unified Memory, and\nto be portable between systems with different levels of support:\npageableMemoryAccess\n: This property is set to 1 on systems with CUDA Unified Memory support where\nall threads may access System-Allocated Memory and CUDA Managed Memory.\nThese systems include NVIDIA Grace Hopper, IBM Power9 + Volta, and modern Linux systems with HMM enabled (see next bullet), among others.\nLinux HMM requires Linux kernel version 6.1.24+, 6.2.11+ or 6.3+,\ndevices with compute capability 7.5 or higher and\na CUDA driver version 535+ installed with\nOpen Kernel Modules\n.\nconcurrentManagedAccess\n: This property is set to 1 on systems with full CUDA Managed Memory support.\nWhen this property is set to 0, there is only partial support for Unified Memory in CUDA Managed Memory.\nFor Tegra support of Unified Memory, see\nCUDA for Tegra Memory Management\n.\nA program may query the level of GPU support for CUDA Unified Memory, by querying the attributes in\nTable 31\nusing\ncudaGetDeviceProperties()\n.\n24.1.2.\nProgramming Model\nï\nWith CUDA Unified Memory, separate allocations between host and device, and explicit memory transfers between them, are no longer required.\nPrograms may allocate Unified Memory in the following ways:\nSystem-Allocation APIs\n: on\nsystems with full CUDA Unified Memory support\nvia\nany system allocation of the host process (Câs\nmalloc()\n, C++âs\nnew\noperator, POSIXâs\nmmap\nand so on).\nCUDA Managed Memory Allocation APIs\n: via the\ncudaMallocManaged()\nAPI which is syntactically similar to\ncudaMalloc()\n.\nCUDA Managed Variables\n: variables declared with\n__managed__\n, which are semantically similar to a\n__device__\nvariable.\nMost examples in this chapter provide at least two versions, one using CUDA Managed Memory and one using System-Allocated Memory.\nTabs allow you to choose between them. The following samples illustrate how Unified Memory simplifies CUDA programs:\nSystem (\nmalloc()\n)\n__global__\nvoid\nwrite_value\n(\nint\n*\nptr\n,\nint\nv\n)\n{\n*\nptr\n=\nv\n;\n}\nint\nmain\n()\n{\nint\n*\nd_ptr\n=\nnullptr\n;\n// Does not require any unified memory support\ncudaMalloc\n(\n&\nd_ptr\n,\nsizeof\n(\nint\n));\nwrite_value\n<<<\n1\n,\n1\n>>>\n(\nd_ptr\n,\n1\n);\nint\nh_value\n;\n// Copy memory back to the host and synchronize\ncudaMemcpy\n(\n&\nh_value\n,\nd_ptr\n,\nsizeof\n(\nint\n),\ncudaMemcpyDefault\n);\nprintf\n(\n\"value = %d\n\\n\n\"\n,\nh_value\n);\ncudaFree\n(\nd_ptr\n);\nreturn\n0\n;\n}\n__global__\nvoid\nwrite_value\n(\nint\n*\nptr\n,\nint\nv\n)\n{\n*\nptr\n=\nv\n;\n}\nint\nmain\n()\n{\n// Requires System-Allocated Memory support\nint\n*\nptr\n=\n(\nint\n*\n)\nmalloc\n(\nsizeof\n(\nint\n));\nwrite_value\n<<<\n1\n,\n1\n>>>\n(\nptr\n,\n1\n);\n// Synchronize required\n// (before, cudaMemcpy was synchronizing)\ncudaDeviceSynchronize\n();\nprintf\n(\n\"value = %d\n\\n\n\"\n,\n*\nptr\n);\nfree\n(\nptr\n);\nreturn\n0\n;\n}\nSystem (Stack)\n__global__\nvoid\nwrite_value\n(\nint\n*\nptr\n,\nint\nv\n)\n{\n*\nptr\n=\nv\n;\n}\nint\nmain\n()\n{\nint\n*\nd_ptr\n=\nnullptr\n;\n// Does not require any unified memory support\ncudaMalloc\n(\n&\nd_ptr\n,\nsizeof\n(\nint\n));\nwrite_value\n<<<\n1\n,\n1\n>>>\n(\nd_ptr\n,\n1\n);\nint\nh_value\n;\n// Copy memory back to the host and synchronize\ncudaMemcpy\n(\n&\nh_value\n,\nd_ptr\n,\nsizeof\n(\nint\n),\ncudaMemcpyDefault\n);\nprintf\n(\n\"value = %d\n\\n\n\"\n,\nh_value\n);\ncudaFree\n(\nd_ptr\n);\nreturn\n0\n;\n}\n__global__\nvoid\nwrite_value\n(\nint\n*\nptr\n,\nint\nv\n)\n{\n*\nptr\n=\nv\n;\n}\nint\nmain\n()\n{\n// Requires System-Allocated Memory support\nint\nvalue\n;\nwrite_value\n<<<\n1\n,\n1\n>>>\n(\n&\nvalue\n,\n1\n);\n// Synchronize required\n// (before, cudaMemcpy was synchronizing)\ncudaDeviceSynchronize\n();\nprintf\n(\n\"value = %d\n\\n\n\"\n,\nvalue\n);\nreturn\n0\n;\n}\nManaged (\ncudaMallocManaged()\n)\n__global__\nvoid\nwrite_value\n(\nint\n*\nptr\n,\nint\nv\n)\n{\n*\nptr\n=\nv\n;\n}\nint\nmain\n()\n{\nint\n*\nd_ptr\n=\nnullptr\n;\n// Does not require any unified memory support\ncudaMalloc\n(\n&\nd_ptr\n,\nsizeof\n(\nint\n));\nwrite_value\n<<<\n1\n,\n1\n>>>\n(\nd_ptr\n,\n1\n);\nint\nh_value\n;\n// Copy memory back to the host and synchronize\ncudaMemcpy\n(\n&\nh_value\n,\nd_ptr\n,\nsizeof\n(\nint\n),\ncudaMemcpyDefault\n);\nprintf\n(\n\"value = %d\n\\n\n\"\n,\nh_value\n);\ncudaFree\n(\nd_ptr\n);\nreturn\n0\n;\n}\n__global__\nvoid\nwrite_value\n(\nint\n*\nptr\n,\nint\nv\n)\n{\n*\nptr\n=\nv\n;\n}\nint\nmain\n()\n{\nint\n*\nptr\n=\nnullptr\n;\n// Requires CUDA Managed Memory support\ncudaMallocManaged\n(\n&\nptr\n,\nsizeof\n(\nint\n));\nwrite_value\n<<<\n1\n,\n1\n>>>\n(\nptr\n,\n1\n);\n// Synchronize required\n// (before, cudaMemcpy was synchronizing)\ncudaDeviceSynchronize\n();\nprintf\n(\n\"value = %d\n\\n\n\"\n,\n*\nptr\n);\ncudaFree\n(\nptr\n);\nreturn\n0\n;\n}\nManaged (\n__managed__\n)\n__global__\nvoid\nwrite_value\n(\nint\n*\nptr\n,\nint\nv\n)\n{\n*\nptr\n=\nv\n;\n}\nint\nmain\n()\n{\nint\n*\nd_ptr\n=\nnullptr\n;\n// Does not require any unified memory support\ncudaMalloc\n(\n&\nd_ptr\n,\nsizeof\n(\nint\n));\nwrite_value\n<<<\n1\n,\n1\n>>>\n(\nd_ptr\n,\n1\n);\nint\nh_value\n;\n// Copy memory back to the host and synchronize\ncudaMemcpy\n(\n&\nh_value\n,\nd_ptr\n,\nsizeof\n(\nint\n),\ncudaMemcpyDefault\n);\nprintf\n(\n\"value = %d\n\\n\n\"\n,\nh_value\n);\ncudaFree\n(\nd_ptr\n);\nreturn\n0\n;\n}\n__global__\nvoid\nwrite_value\n(\nint\n*\nptr\n,\nint\nv\n)\n{\n*\nptr\n=\nv\n;\n}\n// Requires CUDA Managed Memory support\n__managed__\nint\nvalue\n;\nint\nmain\n()\n{\nwrite_value\n<<<\n1\n,\n1\n>>>\n(\n&\nvalue\n,\n1\n);\n// Synchronize required\n// (before, cudaMemcpy was synchronizing)\ncudaDeviceSynchronize\n();\nprintf\n(\n\"value = %d\n\\n\n\"\n,\nvalue\n);\nreturn\n0\n;\n}\nIn the example above, the device writes a value which is then read by the host:\nWithout Unified Memory\n: both host- and device-side storage for the written value is required (\nh_value\nand\nd_ptr\nin the example),\nas is an explicit copy between the two using\ncudaMemcpy()\n.\nWith Unified Memory\n: device accesses data directly from the host.\nptr\n/\nvalue\nmay be used without a separate\nh_value\n/\nd_ptr\nallocation and no copy routine is required, greatly simplifying and reducing the size of the program. With:\nSystem Allocated\n: no other changes required.\nManaged Memory\n: data allocation changed to use\ncudaMallocManaged()\n, which returns a pointer valid from both host and device code.\n24.1.2.1.\nAllocation APIs for System-Allocated Memory\nï\nOn\nsystems with full CUDA Unified Memory support\n, all memory is unified memory.\nThis includes memory allocated with system allocation APIs, such as\nmalloc()\n,\nmmap()\n, C++\nnew()\noperator,\nand also automatic variables on CPU thread stacks, thread locals, global variables, and so on.\nSystem-Allocated Memory may be populated on first touch, depending on the API and system settings used.\nFirst touch means that:\nThe allocation APIs allocate virtual memory and return immediately, and\nphysical memory is populated when a thread accesses the memory for the first time.\nUsually, the physical memory will be chosen âcloseâ to the processor that thread is running on. For example,\nGPU thread accesses it first: physical GPU memory of GPU that thread runs on is chosen.\nCPU thread accesses it first: physical CPU memory in the memory NUMA node of the CPU core that thread runs on is chosen.\nCUDA Unified Memory Hint and Prefetch APIs,\ncudaMemAdvise\nand\ncudaMemPreftchAsync\n, may be used on System-Allocated Memory.\nThese APIs are covered below in the\nData Usage Hints\nsection.\n__global__\nvoid\nprintme\n(\nchar\n*\nstr\n)\n{\nprintf\n(\nstr\n);\n}\nint\nmain\n()\n{\n// Allocate 100 bytes of memory, accessible to both Host and Device code\nchar\n*\ns\n=\n(\nchar\n*\n)\nmalloc\n(\n100\n);\n// Physical allocation placed in CPU memory because host accesses \"s\" first\nstrncpy\n(\ns\n,\n\"Hello Unified Memory\n\\n\n\"\n,\n99\n);\n// Here we pass \"s\" to a kernel without explicitly copying\nprintme\n<<<\n1\n,\n1\n>>>\n(\ns\n);\ncudaDeviceSynchronize\n();\n// Free as for normal CUDA allocations\ncudaFree\n(\ns\n);\nreturn\n0\n;\n}\n24.1.2.2.\nAllocation API for CUDA Managed Memory:\ncudaMallocManaged()\nï\nOn systems with CUDA Managed Memory support, unified memory may be allocated using:\n__host__\ncudaError_t\ncudaMallocManaged\n(\nvoid\n**\ndevPtr\n,\nsize_t\nsize\n);\nThis API is syntactically identical to\ncudaMalloc()\n: it allocates\nsize\nbytes of managed memory and\nsets\ndevPtr\nto refer to the allocation.\nCUDA Managed Memory is also deallocated with\ncudaFree()\n.\nOn\nsystems with full CUDA Managed Memory support\n, managed memory allocations\nmay be accessed concurrently by all CPUs and GPUs in the system.\nReplacing host calls to\ncudaMalloc()\nwith\ncudaMallocManaged()\ndoes not impact program semantics on these systems;\ndevice code is not able to call\ncudaMallocManaged()\n.\nThe following example shows the use of\ncudaMallocManaged()\n:\n__global__\nvoid\nprintme\n(\nchar\n*\nstr\n)\n{\nprintf\n(\nstr\n);\n}\nint\nmain\n()\n{\n// Allocate 100 bytes of memory, accessible to both Host and Device code\nchar\n*\ns\n;\ncudaMallocManaged\n(\n&\ns\n,\n100\n);\n// Note direct Host-code use of \"s\"\nstrncpy\n(\ns\n,\n\"Hello Unified Memory\n\\n\n\"\n,\n99\n);\n// Here we pass \"s\" to a kernel without explicitly copying\nprintme\n<<<\n1\n,\n1\n>>>\n(\ns\n);\ncudaDeviceSynchronize\n();\n// Free as for normal CUDA allocations\ncudaFree\n(\ns\n);\nreturn\n0\n;\n}\nNote\nFor systems that support CUDA Managed Memory allocations, but do not provide full support,\nsee\nCoherency and Concurrency\n.\nImplementation details (may change any time):\nDevices of compute capability 5.x allocate CUDA Managed Memory on the GPU.\nDevices of compute capability 6.x and greater populate the memory on first touch, just like System-Allocated Memory APIs.\n24.1.2.3.\nGlobal-Scope Managed Variables Using\n__managed__\nï\nCUDA\n__managed__\nvariables behave as if they were allocated via\ncudaMallocManaged()\n(see\nAllocation API for CUDA Managed Memory: cudaMallocManaged()\n).\nThey simplify programs with global variables, making it particularly easy to exchange data between host and device\nwithout manual allocations or copying.\nOn\nsystems with full CUDA Unified Memory support\n,\nfile-scope or global-scope variables cannot be directly accessed by device code.\nBut a pointer to these variables may be passed to the kernel as an argument,\nsee\nSystem-Allocated Memory: in-depth examples\nfor examples.\nSystem Allocator\n__global__\nvoid\nwrite_value\n(\nint\n*\nptr\n,\nint\nv\n)\n{\n*\nptr\n=\nv\n;\n}\nint\nmain\n()\n{\n// Requires System-Allocated Memory support\nint\nvalue\n;\nwrite_value\n<<<\n1\n,\n1\n>>>\n(\n&\nvalue\n,\n1\n);\n// Synchronize required\n// (before, cudaMemcpy was synchronizing)\ncudaDeviceSynchronize\n();\nprintf\n(\n\"value = %d\n\\n\n\"\n,\nvalue\n);\nreturn\n0\n;\n}\nManaged\n__global__\nvoid\nwrite_value\n(\nint\n*\nptr\n,\nint\nv\n)\n{\n*\nptr\n=\nv\n;\n}\n// Requires CUDA Managed Memory support\n__managed__\nint\nvalue\n;\nint\nmain\n()\n{\nwrite_value\n<<<\n1\n,\n1\n>>>\n(\n&\nvalue\n,\n1\n);\n// Synchronize required\n// (before, cudaMemcpy was synchronizing)\ncudaDeviceSynchronize\n();\nprintf\n(\n\"value = %d\n\\n\n\"\n,\nvalue\n);\nreturn\n0\n;\n}\nNote the absence of explicit\ncudaMemcpy()\ncommands and the fact that the written value\nvalue\nis visible on both CPU and GPU.\nCUDA\n__managed__\nvariable implies\n__device__\nand is equivalent to\n__managed__\n__device__\n, which is also allowed.\nVariables marked\n__constant__\nmay not be marked as\n__managed__\n.\nA valid CUDA context is necessary for the correct operation of\n__managed__\nvariables.\nAccessing\n__managed__\nvariables can trigger CUDA context creation if a context for the current device hasnât already been created.\nIn the example above, accessing\nvalue\nbefore the kernel launch triggers context creation on the default device.\nIn the absence of that access, the kernel launch would have triggered context creation.\nC++ objects declared as\n__managed__\nare subject to certain specific constraints, particularly where static initializers are concerned.\nPlease refer to\nC++ Language Support\nfor a list of these constraints.\nNote\nFor\ndevices with CUDA Managed Memory without full support\n,\nvisibility of\n__managed__\nvariables for asynchronous operations executing in CUDA streams\nis discussed in the section on\nManaging Data Visibility and Concurrent CPU + GPU Access with Streams\n.\n24.1.2.4.\nDifference between Unified Memory and Mapped Memory\nï\nThe main difference between Unified Memory and\nMapped Memory\nis that\nCUDA Mapped Memory does not guarantee that all kinds of memory accesses (for example atomics) are supported on all systems,\nwhile Unified Memory does. The limited set of memory operations that are guaranteed to be portably supported by CUDA Mapped Memory\nis available on more systems than Unified Memory.\n24.1.2.5.\nPointer Attributes\nï\nCUDA Programs may check whether a pointer addresses a CUDA Managed Memory allocation by calling\ncudaPointerGetAttributes()\nand\ntesting whether the pointer attribute\nvalue\nis\ncudaMemoryTypeManaged\n.\nThis API returns\ncudaMemoryTypeHost\nfor System-Allocated Memory that has been registered with\ncudaHostRegister()\nand\ncudaMemoryTypeUnregistered\nfor System-Allocated Memory that CUDA is unaware of.\nPointer attributes do not state where the memory resides, they state how the memory was allocated or registered.\nThe following example shows how to detect the type of pointer at runtime:\nchar\nconst\n*\nkind\n(\ncudaPointerAttributes\na\n,\nbool\npma\n,\nbool\ncma\n)\n{\nswitch\n(\na\n.\ntype\n)\n{\ncase\ncudaMemoryTypeHost\n:\nreturn\npma\n?\n\"Unified: CUDA Host or Registered Memory\"\n:\n\"Not Unified: CUDA Host or Registered Memory\"\n;\ncase\ncudaMemoryTypeDevice\n:\nreturn\n\"Not Unified: CUDA Device Memory\"\n;\ncase\ncudaMemoryTypeManaged\n:\nreturn\ncma\n?\n\"Unified: CUDA Managed Memory\"\n:\n\"Not Unified: CUDA Managed Memory\"\n;\ncase\ncudaMemoryTypeUnregistered\n:\nreturn\npma\n?\n\"Unified: System-Allocated Memory\"\n:\n\"Not Unified: System-Allocated Memory\"\n;\ndefault\n:\nreturn\n\"unknown\"\n;\n}\n}\nvoid\ncheck_pointer\n(\nint\ni\n,\nvoid\n*\nptr\n)\n{\ncudaPointerAttributes\nattr\n;\ncudaPointerGetAttributes\n(\n&\nattr\n,\nptr\n);\nint\npma\n=\n0\n,\ncma\n=\n0\n,\ndevice\n=\n0\n;\ncudaGetDevice\n(\n&\ndevice\n);\ncudaDeviceGetAttribute\n(\n&\npma\n,\ncudaDevAttrPageableMemoryAccess\n,\ndevice\n);\ncudaDeviceGetAttribute\n(\n&\ncma\n,\ncudaDevAttrConcurrentManagedAccess\n,\ndevice\n);\nprintf\n(\n\"Pointer %d: memory is %s\n\\n\n\"\n,\ni\n,\nkind\n(\nattr\n,\npma\n,\ncma\n));\n}\n__managed__\nint\nmanaged_var\n=\n5\n;\nint\nmain\n()\n{\nint\n*\nptr\n[\n5\n];\nptr\n[\n0\n]\n=\n(\nint\n*\n)\nmalloc\n(\nsizeof\n(\nint\n));\ncudaMallocManaged\n(\n&\nptr\n[\n1\n],\nsizeof\n(\nint\n));\ncudaMallocHost\n(\n&\nptr\n[\n2\n],\nsizeof\n(\nint\n));\ncudaMalloc\n(\n&\nptr\n[\n3\n],\nsizeof\n(\nint\n));\nptr\n[\n4\n]\n=\n&\nmanaged_var\n;\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n5\n;\n++\ni\n)\ncheck_pointer\n(\ni\n,\nptr\n[\ni\n]);\ncudaFree\n(\nptr\n[\n3\n]);\ncudaFreeHost\n(\nptr\n[\n2\n]);\ncudaFree\n(\nptr\n[\n1\n]);\nfree\n(\nptr\n[\n0\n]);\nreturn\n0\n;\n}\n24.1.2.6.\nRuntime detection of Unified Memory Support Level\nï\nThe following example shows how to detect the Unified Memory support level at runtime:\nint\nmain\n()\n{\nint\nd\n;\ncudaGetDevice\n(\n&\nd\n);\nint\npma\n=\n0\n;\ncudaDeviceGetAttribute\n(\n&\npma\n,\ncudaDevAttrPageableMemoryAccess\n,\nd\n);\nprintf\n(\n\"Full Unified Memory Support: %s\n\\n\n\"\n,\npma\n==\n1\n?\n\"YES\"\n:\n\"NO\"\n);\nint\ncma\n=\n0\n;\ncudaDeviceGetAttribute\n(\n&\ncma\n,\ncudaDevAttrConcurrentManagedAccess\n,\nd\n);\nprintf\n(\n\"CUDA Managed Memory with full support: %s\n\\n\n\"\n,\ncma\n==\n1\n?\n\"YES\"\n:\n\"NO\"\n);\nreturn\n0\n;\n}\n24.1.2.7.\nGPU Memory Oversubscription\nï\nUnified Memory enables applications to\noversubscribe\nthe memory of any individual processor:\nin other words they can allocate and share arrays larger than\nthe memory capacity of any individual processor in the system,\nenabling among others out-of-core processing of datasets that do not fit within\na single GPU, without adding significant complexity to the programming model.\n24.1.2.8.\nPerformance Hints\nï\nThe following sections describes the available unified memory performance hints,\nwhich may be used on all Unified Memory, for example, CUDA Managed memory or,\non\nsystems with full CUDA Unified Memory support\n,\nalso all System-Allocated Memory.\nThese APIs are hints, that is, they do not impact the semantics of applications, only their peformance.\nThat is, they can be added or removed anywhere on any application without impacting its results.\nCUDA Unified Memory may not always have all the information necessary to make\nthe best performance decisions related to unified memory.\nThese performance hints enable the application to provide CUDA with more information.\nNote that applications should only use these hints if they improve their performance.\n24.1.2.8.1.\nData Prefetching\nï\nThe\ncudaMemPrefetchAsync\nAPI is an asynchronous stream-ordered API that may migrate data to reside closer to the specified processor.\nThe data may be accessed while it is being prefetched.\nThe migration does not begin until all prior operations in the stream have completed,\nand completes before any subsequent operation in the stream.\ncudaError_t\ncudaMemPrefetchAsync\n(\nconst\nvoid\n*\ndevPtr\n,\nsize_t\ncount\n,\nstruct\ncudaMemLocation\nlocation\n,\nunsigned\nint\nflags\n,\ncudaStream_t\nstream\n);\nA memory region containing\n[devPtr,\ndevPtr\n+\ncount)\nmay be migrated to\nthe destination device\nlocation.id\nif\nlocation.type\nis\ncudaMemLocationTypeDevice\n- or CPU if\nlocation.type\nis\ncudaMemLocationTypeHost\n-\nwhen the prefetch task is executed in the given\nstream\n.\nFor details on\nflags\n, see the current\nCUDA Runtime API documentation\n.\nConsider a simple code example below:\nSystem Allocator\nvoid\ntest_prefetch_sam\n(\ncudaStream_t\ns\n)\n{\nchar\n*\ndata\n=\n(\nchar\n*\n)\nmalloc\n(\nN\n);\ninit_data\n(\ndata\n,\nN\n);\n// execute on CPU\ncudaMemLocation\nlocation\n=\n{.\ntype\n=\ncudaMemLocationTypeDevice\n,\n.\nid\n=\nmyGpuId\n};\ncudaMemPrefetchAsync\n(\ndata\n,\nN\n,\nlocation\n,\ns\n,\n0\n/* flags */\n);\n// prefetch to GPU\nmykernel\n<<<\n(\nN\n+\nTPB\n-\n1\n)\n/\nTPB\n,\nTPB\n,\n0\n,\ns\n>>>\n(\ndata\n,\nN\n);\n// execute on GPU\nlocation\n=\n{.\ntype\n=\ncudaMemLocationTypeHost\n};\ncudaMemPrefetchAsync\n(\ndata\n,\nN\n,\nlocation\n,\ns\n,\n0\n/* flags */\n);\n// prefetch to CPU\ncudaStreamSynchronize\n(\ns\n);\nuse_data\n(\ndata\n,\nN\n);\nfree\n(\ndata\n);\n}\nManaged\nvoid\ntest_prefetch_managed\n(\ncudaStream_t\ns\n)\n{\nchar\n*\ndata\n;\ncudaMallocManaged\n(\n&\ndata\n,\nN\n);\ninit_data\n(\ndata\n,\nN\n);\n// execute on CPU\ncudaMemLocation\nlocation\n=\n{.\ntype\n=\ncudaMemLocationTypeDevice\n,\n.\nid\n=\nmyGpuId\n};\ncudaMemPrefetchAsync\n(\ndata\n,\nN\n,\nlocation\n,\ns\n,\n0\n/* flags */\n);\n// prefetch to GPU\nmykernel\n<<<\n(\nN\n+\nTPB\n-\n1\n)\n/\nTPB\n,\nTPB\n,\n0\n,\ns\n>>>\n(\ndata\n,\nN\n);\n// execute on GPU\nlocation\n=\n{.\ntype\n=\ncudaMemLocationTypeHost\n};\ncudaMemPrefetchAsync\n(\ndata\n,\nN\n,\nlocation\n,\ns\n,\n0\n/* flags */\n);\n// prefetch to CPU\ncudaStreamSynchronize\n(\ns\n);\nuse_data\n(\ndata\n,\nN\n);\ncudaFree\n(\ndata\n);\n}\n24.1.2.8.2.\nData Usage Hints\nï\nWhen multiple processors simultaneously access the same data,\ncudaMemAdvise\nmay be used to hint how the data at\n[devPtr,\ndevPtr\n+\ncount)\nwill be accessed:\ncudaError_t\ncudaMemAdvise\n(\nconst\nvoid\n*\ndevPtr\n,\nsize_t\ncount\n,\nenum\ncudaMemoryAdvise\nadvice\n,\nstruct\ncudaMemLocation\nlocation\n);\nWhere\nadvice\nmay take the following values:\ncudaMemAdviseSetReadMostly\n:\nThis implies that the data is mostly going to be read from and only occasionally written to.\nIn general, it allows trading off read bandwidth for write bandwidth on this region.\nExample:\nvoid\ntest_advise_managed\n(\ncudaStream_t\nstream\n)\n{\nchar\n*\ndataPtr\n;\nsize_t\ndataSize\n=\n64\n*\nTPB\n;\n// 16 KiB\n// Allocate memory using cudaMallocManaged\n// (malloc may be used on systems with full CUDA Unified memory support)\ncudaMallocManaged\n(\n&\ndataPtr\n,\ndataSize\n);\n// Set the advice on the memory region\ncudaMemLocation\nloc\n=\n{.\ntype\n=\ncudaMemLocationTypeDevice\n,\n.\nid\n=\nmyGpuId\n};\ncudaMemAdvise\n(\ndataPtr\n,\ndataSize\n,\ncudaMemAdviseSetReadMostly\n,\nloc\n);\nint\nouterLoopIter\n=\n0\n;\nwhile\n(\nouterLoopIter\n<\nmaxOuterLoopIter\n)\n{\n// The data is written to in the outer loop on the CPU\ninit_data\n(\ndataPtr\n,\ndataSize\n);\n// The data is made available to all GPUs by prefetching.\n// Prefetching here causes read duplication of data instead\n// of data migration\ncudaMemLocation\nlocation\n;\nlocation\n.\ntype\n=\ncudaMemLocationTypeDevice\n;\nfor\n(\nint\ndevice\n=\n0\n;\ndevice\n<\nmaxDevices\n;\ndevice\n++\n)\n{\nlocation\n.\nid\n=\ndevice\n;\ncudaMemPrefetchAsync\n(\ndataPtr\n,\ndataSize\n,\nlocation\n,\n0\n/* flags */\n,\nstream\n);\n}\n// The kernel only reads this data in the inner loop\nint\ninnerLoopIter\n=\n0\n;\nwhile\n(\ninnerLoopIter\n<\nmaxInnerLoopIter\n)\n{\nmykernel\n<<<\n32\n,\nTPB\n,\n0\n,\nstream\n>>>\n((\nconst\nchar\n*\n)\ndataPtr\n,\ndataSize\n);\ninnerLoopIter\n++\n;\n}\nouterLoopIter\n++\n;\n}\ncudaFree\n(\ndataPtr\n);\n}\ncudaMemAdviseSetPreferredLocation\n:\nIn general, any memory may be migrated at any time to any location, for example,\nwhen a given processor is running out of physical memory.\nThis hint tells the system that migrating this memory region away from\nits preferred location is undesired, by setting the preferred location for\nthe data to be the physical memory belonging to device.\nPassing in a value of\ncudaMemLocationTypeHost\nfor location.type sets the preferred location as CPU memory.\nOther hints, like\ncudaMemPrefetchAsync\n, may override this hint,\nleading the memory to be migrated away from its preferred location.\ncudaMemAdviseSetAccessedBy\n:\nIn some systems, it may be beneficial for performance to establish a\nmapping into memory before accessing the data from a given processor.\nThis hint tells the system that the data will be frequently accessed by\nlocation.id\nwhen\nlocation.type\nis\ncudaMemLocationTypeDevice\n,\nenabling the system to assume that creating these mappings pays off.\nThis hint does not imply where the data should reside,\nbut it can be combined with\ncudaMemAdviseSetPreferredLocation\nto specify that.\nEach advice can be also unset by using one of the following values:\ncudaMemAdviseUnsetReadMostly\n,\ncudaMemAdviseUnsetPreferredLocation\nand\ncudaMemAdviseUnsetAccessedBy\n.\n24.1.2.8.3.\nQuerying Data Usage Attributes on Managed Memory\nï\nA program can query memory range attributes assigned through\ncudaMemAdvise\nor\ncudaMemPrefetchAsync\non CUDA Managed Memory by using the following API:\ncudaMemRangeGetAttribute\n(\nvoid\n*\ndata\n,\nsize_t\ndataSize\n,\nenum\ncudaMemRangeAttribute\nattribute\n,\nconst\nvoid\n*\ndevPtr\n,\nsize_t\ncount\n);\nThis function queries an attribute of the memory range starting at\ndevPtr\nwith a size of\ncount\nbytes.\nThe memory range must refer to managed memory allocated via\ncudaMallocManaged\nor\ndeclared via\n__managed__\nvariables. It is possible to query the following attributes:\ncudaMemRangeAttributeReadMostly\n:\nthe result returned will be 1 if the entire memory range has the\ncudaMemAdviseSetReadMostly\nattribute set, or 0 otherwise.\ncudaMemRangeAttributePreferredLocation\n:\nthe result returned will be a GPU device id or\ncudaCpuDeviceId\nif the entire\nmemory range has the corresponding processor as preferred location,\notherwise\ncudaInvalidDeviceId\nwill be returned.\nAn application can use this query API to make decision about staging data through\nCPU or GPU depending on the preferred location attribute of the managed pointer.\nNote that the actual location of the memory range at the time\nof the query may be different from the preferred location.\ncudaMemRangeAttributeAccessedBy\n:\nwill return the list of devices that have that advise set for that memory range.\ncudaMemRangeAttributeLastPrefetchLocation\n:\nwill return the last location to which the memory range was prefetched\nexplicitly using\ncudaMemPrefetchAsync\n.\nNote that this simply returns the last location that the application requested to prefetch the memory range to.\nIt gives no indication as to whether the prefetch operation to that location has completed or even begun.\ncudaMemRangeAttributePreferredLocationType\n:\nwill return the location type of the preferred location which will be\ncudaMemLocationTypeDevice\nif all pages\nin the memory range have the same GPU as their preferred location, or will be\ncudaMemLocationTypeHost\nif all\npages in the memory range have the CPU as their preferred location, or it will be\ncudaMemLocationTypeHostNuma\nif all the pages in the memory range have the same host NUMA node ID as their preferred location or it will be\ncudaMemLocationTypeInvalid\nif either all the pages donât have the same preferred location or some of the pages\ndonât have a preferred location at all.\ncudaMemRangeAttributePreferredLocationId\n:\nIf the\ncudaMemRangeAttributePreferredLocationType\nquery for the same address range returns\ncudaMemLocationTypeDevice\n,\nit will be a valid device ordinal or if it returns\ncudaMemLocationTypeHostNuma\n, it will be a valid host NUMA node ID\nor if it returns any other location type, the id should be ignored.\ncudaMemRangeAttributeLastPrefetchLocationType\n:\nwill be the last location type to which all pages in the memory range were prefetched explicitly via\ncudaMemPrefetchAsync\nwhich will be\ncudaMemLocationTypeDevice\nif all pages in the memory range were prefetched to the same GPU,\nor will be\ncudaMemLocationTypeHost\nif all pages in the memory range were prefetched to the CPU or it will be\ncudaMemLocationTypeHostNuma\nif all the pages in the memory range were prefetched to the same host NUMA node ID\nor it will be\ncudaMemLocationTypeInvalid\nif either all the pages were not prefetched to the same location or some\nof the pages were never prefetched at all.\ncudaMemRangeAttributeLastPrefetchLocationId\n:\nIf the\ncudaMemRangeAttributeLastPrefetchLocationType\nquery for the same address range returns\ncudaMemLocationTypeDevice\n,\nit will be a valid device ordinal or if it returns\ncudaMemLocationTypeHostNuma\n, it will be a valid host NUMA node ID\nor if it returns any other location type, the id should be ignored.\nAdditionally, multiple attributes can be queried by using corresponding\ncudaMemRangeGetAttributes\nfunction.\n24.2.\nUnified memory on devices with full CUDA Unified Memory support\nï\n24.2.1.\nSystem-Allocated Memory: in-depth examples\nï\nSystems with full CUDA Unified Memory support\nallow the device to access any memory owned by the host process interacting with the device.\nThis section shows a few advanced use-cases, using a kernel that simply prints\nthe first 8 characters of an input character array to the standard output stream:\n__global__\nvoid\nkernel\n(\nconst\nchar\n*\ntype\n,\nconst\nchar\n*\ndata\n)\n{\nstatic\nconst\nint\nn_char\n=\n8\n;\nprintf\n(\n\"%s - first %d characters: '\"\n,\ntype\n,\nn_char\n);\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nn_char\n;\n++\ni\n)\nprintf\n(\n\"%c\"\n,\ndata\n[\ni\n]);\nprintf\n(\n\"'\n\\n\n\"\n);\n}\nThe following tabs show various ways of how this kernel may be called:\nMalloc\nvoid\ntest_malloc\n()\n{\nconst\nchar\ntest_string\n[]\n=\n\"Hello World\"\n;\nchar\n*\nheap_data\n=\n(\nchar\n*\n)\nmalloc\n(\nsizeof\n(\ntest_string\n));\nstrncpy\n(\nheap_data\n,\ntest_string\n,\nsizeof\n(\ntest_string\n));\nkernel\n<<<\n1\n,\n1\n>>>\n(\n\"malloc\"\n,\nheap_data\n);\nASSERT\n(\ncudaDeviceSynchronize\n()\n==\ncudaSuccess\n,\n\"CUDA failed with '%s'\"\n,\ncudaGetErrorString\n(\ncudaGetLastError\n()));\nfree\n(\nheap_data\n);\n}\nManaged\nvoid\ntest_managed\n()\n{\nconst\nchar\ntest_string\n[]\n=\n\"Hello World\"\n;\nchar\n*\ndata\n;\ncudaMallocManaged\n(\n&\ndata\n,\nsizeof\n(\ntest_string\n));\nstrncpy\n(\ndata\n,\ntest_string\n,\nsizeof\n(\ntest_string\n));\nkernel\n<<<\n1\n,\n1\n>>>\n(\n\"managed\"\n,\ndata\n);\nASSERT\n(\ncudaDeviceSynchronize\n()\n==\ncudaSuccess\n,\n\"CUDA failed with '%s'\"\n,\ncudaGetErrorString\n(\ncudaGetLastError\n()));\ncudaFree\n(\ndata\n);\n}\nStack variable\nvoid\ntest_stack\n()\n{\nconst\nchar\ntest_string\n[]\n=\n\"Hello World\"\n;\nkernel\n<<<\n1\n,\n1\n>>>\n(\n\"stack\"\n,\ntest_string\n);\nASSERT\n(\ncudaDeviceSynchronize\n()\n==\ncudaSuccess\n,\n\"CUDA failed with '%s'\"\n,\ncudaGetErrorString\n(\ncudaGetLastError\n()));\n}\nFile-scope static variable\nvoid\ntest../_static\n()\n{\nstatic\nconst\nchar\ntest_string\n[]\n=\n\"Hello World\"\n;\nkernel\n<<<\n1\n,\n1\n>>>\n(\n\"static\"\n,\ntest_string\n);\nASSERT\n(\ncudaDeviceSynchronize\n()\n==\ncudaSuccess\n,\n\"CUDA failed with '%s'\"\n,\ncudaGetErrorString\n(\ncudaGetLastError\n()));\n}\nGlobal-scope variable\nconst\nchar\nglobal_string\n[]\n=\n\"Hello World\"\n;\nvoid\ntest_global\n()\n{\nkernel\n<<<\n1\n,\n1\n>>>\n(\n\"global\"\n,\nglobal_string\n);\nASSERT\n(\ncudaDeviceSynchronize\n()\n==\ncudaSuccess\n,\n\"CUDA failed with '%s'\"\n,\ncudaGetErrorString\n(\ncudaGetLastError\n()));\n}\nGlobal-scope extern variable\n// declared in separate file, see below\nextern\nchar\n*\next_data\n;\nvoid\ntest_extern\n()\n{\nkernel\n<<<\n1\n,\n1\n>>>\n(\n\"extern\"\n,\next_data\n);\nASSERT\n(\ncudaDeviceSynchronize\n()\n==\ncudaSuccess\n,\n\"CUDA failed with '%s'\"\n,\ncudaGetErrorString\n(\ncudaGetLastError\n()));\n}\n/** This may be a non-CUDA file */\nchar\n*\next_data\n;\nstatic\nconst\nchar\nglobal_string\n[]\n=\n\"Hello World\"\n;\nvoid\n__attribute__\n((\nconstructor\n))\nsetup\n(\nvoid\n)\n{\next_data\n=\n(\nchar\n*\n)\nmalloc\n(\nsizeof\n(\nglobal_string\n));\nstrncpy\n(\next_data\n,\nglobal_string\n,\nsizeof\n(\nglobal_string\n));\n}\nvoid\n__attribute__\n((\ndestructor\n))\ntear_down\n(\nvoid\n)\n{\nfree\n(\next_data\n);\n}\nThe first three tabs above show the example as already detailed in the\nProgramming Model section\n.\nThe next three tabs show various ways a file-scope or global-scope variable can\nbe accessed from the device.\nNote that for the extern variable, it could be declared and its memory\nowned and managed by a third-party library, which does not interact with CUDA at all.\nAlso note that stack variables as well as file-scope and global-scope variables can\nonly be accessed through a pointer by the GPU. In this specific example, this is\nconvenient because the character array is already declared as a pointer:\nconst\nchar*\n.\nHowever, consider the following example with a global-scope integer:\n// this variable is declared at global scope\nint\nglobal_variable\n;\n__global__\nvoid\nkernel_uncompilable\n()\n{\n// this causes a compilation error: global (__host__) variables must not\n// be accessed from __device__ / __global__ code\nprintf\n(\n\"%d\n\\n\n\"\n,\nglobal_variable\n);\n}\n// On systems with pageableMemoryAccess set to 1, we can access the address\n// of a global variable. The below kernel takes that address as an argument\n__global__\nvoid\nkernel\n(\nint\n*\nglobal_variable_addr\n)\n{\nprintf\n(\n\"%d\n\\n\n\"\n,\n*\nglobal_variable_addr\n);\n}\nint\nmain\n()\n{\nkernel\n<<<\n1\n,\n1\n>>>\n(\n&\nglobal_variable\n);\n...\nreturn\n0\n;\n}\nIn the example above, we need to ensure to pass a\npointer\nto the global variable\nto the kernel instead of directly accessing the global variable in the kernel.\nThis is because global variables without the\n__managed__\nspecifier are declared\nas\n__host__\n-only by default, thus most compilers wonât allow using these\nvariables directly in device code as of now.\n24.2.1.1.\nFile-backed Unified Memory\nï\nSince\nsystems with full CUDA Unified Memory support\nallow the device to access any memory owned by the host process,\nthey can directly access file-backed memory.\nHere, we show a modified version of the initial example shown in the previous section to use\nfile-backed memory in order to print a string from the GPU, read directly from an input file.\nIn the following example, the memory is backed by a physical file, but the example\napplies to memory-backed files, too, as detailed in the section on\nInter-Process Communication (IPC) with Unified Memory\n.\n__global__\nvoid\nkernel\n(\nconst\nchar\n*\ntype\n,\nconst\nchar\n*\ndata\n)\n{\nstatic\nconst\nint\nn_char\n=\n8\n;\nprintf\n(\n\"%s - first %d characters: '\"\n,\ntype\n,\nn_char\n);\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nn_char\n;\n++\ni\n)\nprintf\n(\n\"%c\"\n,\ndata\n[\ni\n]);\nprintf\n(\n\"'\n\\n\n\"\n);\n}\nvoid\ntest_file_backed\n()\n{\nint\nfd\n=\nopen\n(\nINPUT_FILE_NAME\n,\nO_RDONLY\n);\nASSERT\n(\nfd\n>=\n0\n,\n\"Invalid file handle\"\n);\nstruct\nstat\nfile_stat\n;\nint\nstatus\n=\nfstat\n(\nfd\n,\n&\nfile_stat\n);\nASSERT\n(\nstatus\n>=\n0\n,\n\"Invalid file stats\"\n);\nchar\n*\nmapped\n=\n(\nchar\n*\n)\nmmap\n(\n0\n,\nfile_stat\n.\nst_size\n,\nPROT_READ\n,\nMAP_PRIVATE\n,\nfd\n,\n0\n);\nASSERT\n(\nmapped\n!=\nMAP_FAILED\n,\n\"Cannot map file into memory\"\n);\nkernel\n<<<\n1\n,\n1\n>>>\n(\n\"file-backed\"\n,\nmapped\n);\nASSERT\n(\ncudaDeviceSynchronize\n()\n==\ncudaSuccess\n,\n\"CUDA failed with '%s'\"\n,\ncudaGetErrorString\n(\ncudaGetLastError\n()));\nASSERT\n(\nmunmap\n(\nmapped\n,\nfile_stat\n.\nst_size\n)\n==\n0\n,\n\"Cannot unmap file\"\n);\nASSERT\n(\nclose\n(\nfd\n)\n==\n0\n,\n\"Cannot close file\"\n);\n}\nNote that on systems without the\nhostNativeAtomicSupported\nproperty, including\nsystems with Linux HMM enabled\n,\natomic accesses to file-backed memory are not supported.\n24.2.1.2.\nInter-Process Communication (IPC) with Unified Memory\nï\nNote\nAs of now, using IPC with Unified Memory can have significant performance implications.\nMany applications prefer to manage one GPU per process, but still need to use Unified Memory,\nfor example for over-subscription, and access it from multiple GPUs.\nCUDA IPC (see\nInterprocess Communication\n)\ndoes not support Managed Memory: handles to this type of memory may not be shared through\nany of the mechanisms discussed in this section.\nOn\nsystems with full CUDA Unified Memory support\n,\nSystem-Allocated Memory is Inter-Process Communication (IPC) capable.\nOnce access to System-Allocated Memory has been shared with other processes,\nthe same\nProgramming Model\napplies,\nsimilar to\nFile-backed Unified Memory\n.\nSee the following references for more information on various ways of creating\nIPC-capable System-Allocated Memory under Linux:\nmmap with MAP_SHARED\nPOSIX IPC APIs\nLinux memfd_create\nNote that it is not possible to share memory between different hosts and their devices using this technique.\n24.2.2.\nPerformance Tuning\nï\nIn order to achieve good performance with Unified Memory, it is important to:\nUnderstand how paging works on your system, and how to avoid unnecessary page faults.\nUnderstand the various mechanisms allowing you to keep data local to the accessing processor.\nConsider tuning your application for the granularity of memory transfers of your system.\nAs general advice,\nPerformance Hints\nmight provide improved performance, but using them incorrectly might degrade performance\ncompared to the default behavior.\nAlso note that any hint has a performance cost associated with it on the host,\nthus useful hints must at the very least improve performance enough to overcome this cost.\n24.2.2.1.\nMemory Paging and Page Sizes\nï\nMany of the sections for unified memory performance tuning assume prior knowledge on virtual addressing,\nmemory pages and page sizes.\nThis section attempts to define all necessary terms and explain why paging matters for performance.\nAll currently supported systems for Unified Memory use a virtual address space:\nthis means that memory addresses used by an application represent a\nvirtual\nlocation\nwhich might be\nmapped\nto a physical location where the memory actually resides.\nAll currently supported processors, including both CPUs and GPUs, additionally use\nmemory\npaging\n. Because all systems use a virtual address space, there are two types\nof memory pages:\nVirtual pages: this represents a fixed-size contiguous chunk of virtual memory\nper process tracked by the operating system, which can be\nmapped\ninto physical memory.\nNote that the virtual page is linked to the\nmapping\n: for example, a single\nvirtual address might be mapped into physical memory using different page sizes.\nPhysical pages: this represents a fixed-size contiguous chunk of memory\nthe processorâs main Memory Management Unit (MMU) supports and into which\na virtual page can be mapped.\nCurrently, all x86_64 CPUs use 4KiB physical pages.\nArm CPUs support multiple physical page sizes - 4KiB, 16KiB, 32KiB and 64KiB - depending on the exact CPU.\nFinally, NVIDIA GPUs support multiple physical page sizes, but prefer 2MiB physical pages or larger.\nNote that these sizes are subject to change in future hardware.\nThe default page size of virtual pages usually corresponds to the physical page size,\nbut an application may use different page sizes as long as they are supported by the\noperating system and the hardware. Typically, supported virtual page sizes must be\npowers of 2 and multiples of the physical page size.\nThe logical entity tracking the mapping of virtual pages into physical pages will be referred to as a\npage table\n,\nand each mapping of a given virtual page with a given virtual size to physical pages is called a\npage table entry (PTE)\n.\nAll supported processors provide specific caches for the page table to speed up the translation of\nvirtual addresses to physical addresses. These caches are called\ntranslation lookaside buffers (TLBs)\n.\nThere are two important aspects for performance tuning of applications:\nthe choice of virtual page size,\nwhether the system offers a combined page table used by both CPUs and GPUs,\nor separate page tables for each CPU and GPU individually.\n24.2.2.1.1.\nChoosing the right page size\nï\nIn general, small page sizes lead to less (virtual) memory fragmentation but more TLB misses,\nwhereas larger page sizes lead to more memory fragmentation but less TLB misses.\nAdditionally, memory migration is generally more expensive with larger page sizes compared to\nsmaller page sizes, because we typically migrate full memory pages. This can cause\nlarger latency spikes in an application using large page sizes. See also the next section\nfor more details on page faults.\nOne important aspect for performance tuning is that TLB misses are generally\nsignificantly more expensive on the GPU compared to the CPU. This means that\nif a GPU thread frequently accesses random locations of Unified Memory mapped\nusing a small enough page size, it might be significantly slower compared to\nthe same accesses to Unified Memory mapped using a large enough page size.\nWhile a similar effect might occur for a CPU thread randomly accessing a large\narea of memory mapped using a small page size, the slowdown is less pronounced,\nmeaning that the application might want to trade-off this slowdown with\nhaving less memory fragmentation.\nNote that in general, applications should not tune their performance to the\nphysical page size of a given processor, since physical page sizes are subject\nto change depending on the hardware. The advice above only applies to virtual\npage sizes.\n24.2.2.1.2.\nCPU and GPU page tables: hardware coherency vs. software coherency\nï\nNote\nIn the remainder of the performance tuning documentation, we will refer\nto systems with a combined page table for both CPUs and GPUs as\nhardware\ncoherent\nsystems. Systems with separate page tables for CPUs and GPUs are\nreferred to as\nsoftware coherent\n.\nHardware coherent systems such as NVIDIA Grace Hopper offer a logically combined\npage table for both CPUs and GPUs.\nThis is important because in order to access\nSystem-Allocated Memory from the GPU\n,\nthe GPU uses whichever page table entry was created by the CPU for the requested memory.\nIf that page table entry uses the default CPU page size of 4KiB or 64KiB,\naccesses to large virtual memory areas will cause significant TLB misses,\nthus significant slowdowns.\nSee the section on\nconfiguring huge pages\nfor examples on how to ensure\nSystem-Allocated Memory uses large enough page sizes to avoid this type of issue.\nOn the other hand, on systems where the CPUs and GPUs each have their own logical\npage table, different performance tuning aspects should be considered:\nin order to\nguarantee coherency\n, these systems\nusually use\npage faults\nin case a processor accesses a memory address mapped\ninto the physical memory of a different processor. Such a page fault means that:\nit needs to be ensured that the currently owning processor (where the physical page currently resides)\ncannot access this page anymore, either by deleting the page table entry or updating it.\nit needs to be ensured that the processor requesting access can access this page,\neither by creating a new page table entry or updating and existing entry, such that\nit becomes valid/active.\nthe physical page backing this virtual page must be moved/migrated to the processor\nrequesting access: this can be an expensive operation, and the amount of work\nis proportional to the page size.\nOverall, hardware coherent systems provide significant performance benefits\ncompared to software coherent systems in cases where frequent concurrent accesses\nto the same memory page are made by both CPU and GPU threads:\nless page-faults: these systems do not need to use page-faults for emulating coherency or migrating memory,\nless contention: these systems are coherent at cache-line granularity instead of page-size granularity, that is,\nwhen there is contention from multiple processors within a cache line, only the cache line is exchanged which is much smaller than the smallest page-size,\nand when the different processors access different cache-lines within a page, then there is no contention.\nThis impacts the performance of the following scenarios:\nAtomic updates to the same address concurrently from both CPUs and GPUs.\nSignaling a GPU thread from a CPU thread or vice-versa.\n24.2.2.2.\nDirect Unified Memory Access from host\nï\nSome devices have hardware support for coherent reads, stores and atomic accesses\nfrom the host on GPU-resident unified memory.\nThese devices have the attribute\ncudaDevAttrDirectManagedMemAccessFromHost\nset to 1.\nNote that all\nhardware coherent systems\nhave\nthis attribute set for NVLink-connected devices.\nOn these systems, the host has direct access to GPU-resident memory without page faults and\ndata migration (see\nData Usage Hints\nfor more details on memory usage hints). Note that with CUDA Managed Memory,\nthe\ncudaMemAdviseSetAccessedBy\nhint with location type\ncudaMemLocationTypeHost\nis necessary\nto enable this direct access without page faults.\nConsider an example code below:\nSystem Allocator\n__global__\nvoid\nwrite\n(\nint\n*\nret\n,\nint\na\n,\nint\nb\n)\n{\nret\n[\nthreadIdx\n.\nx\n]\n=\na\n+\nb\n+\nthreadIdx\n.\nx\n;\n}\n__global__\nvoid\nappend\n(\nint\n*\nret\n,\nint\na\n,\nint\nb\n)\n{\nret\n[\nthreadIdx\n.\nx\n]\n+=\na\n+\nb\n+\nthreadIdx\n.\nx\n;\n}\nvoid\ntest_malloc\n()\n{\nint\n*\nret\n=\n(\nint\n*\n)\nmalloc\n(\n1000\n*\nsizeof\n(\nint\n));\n// for shared page table systems, the following hint is not necesary\ncudaMemLocation\nlocation\n=\n{.\ntype\n=\ncudaMemLocationTypeHost\n};\ncudaMemAdvise\n(\nret\n,\n1000\n*\nsizeof\n(\nint\n),\ncudaMemAdviseSetAccessedBy\n,\nlocation\n);\nwrite\n<<<\n1\n,\n1000\n>>>\n(\nret\n,\n10\n,\n100\n);\n// pages populated in GPU memory\ncudaDeviceSynchronize\n();\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n1000\n;\ni\n++\n)\nprintf\n(\n\"%d: A+B = %d\n\\n\n\"\n,\ni\n,\nret\n[\ni\n]);\n// directManagedMemAccessFromHost=1: CPU accesses GPU memory directly without migrations\n// directManagedMemAccessFromHost=0: CPU faults and triggers device-to-host migrations\nappend\n<<<\n1\n,\n1000\n>>>\n(\nret\n,\n10\n,\n100\n);\n// directManagedMemAccessFromHost=1: GPU accesses GPU memory without migrations\ncudaDeviceSynchronize\n();\n// directManagedMemAccessFromHost=0: GPU faults and triggers host-to-device migrations\nfree\n(\nret\n);\n}\nManaged\n__global__\nvoid\nwrite\n(\nint\n*\nret\n,\nint\na\n,\nint\nb\n)\n{\nret\n[\nthreadIdx\n.\nx\n]\n=\na\n+\nb\n+\nthreadIdx\n.\nx\n;\n}\n__global__\nvoid\nappend\n(\nint\n*\nret\n,\nint\na\n,\nint\nb\n)\n{\nret\n[\nthreadIdx\n.\nx\n]\n+=\na\n+\nb\n+\nthreadIdx\n.\nx\n;\n}\nvoid\ntest_managed\n()\n{\nint\n*\nret\n;\ncudaMallocManaged\n(\n&\nret\n,\n1000\n*\nsizeof\n(\nint\n));\ncudaMemLocation\nlocation\n=\n{.\ntype\n=\ncudaMemLocationTypeHost\n};\ncudaMemAdvise\n(\nret\n,\n1000\n*\nsizeof\n(\nint\n),\ncudaMemAdviseSetAccessedBy\n,\nlocation\n);\n// set direct access hint\nwrite\n<<<\n1\n,\n1000\n>>>\n(\nret\n,\n10\n,\n100\n);\n// pages populated in GPU memory\ncudaDeviceSynchronize\n();\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n1000\n;\ni\n++\n)\nprintf\n(\n\"%d: A+B = %d\n\\n\n\"\n,\ni\n,\nret\n[\ni\n]);\n// directManagedMemAccessFromHost=1: CPU accesses GPU memory directly without migrations\n// directManagedMemAccessFromHost=0: CPU faults and triggers device-to-host migrations\nappend\n<<<\n1\n,\n1000\n>>>\n(\nret\n,\n10\n,\n100\n);\n// directManagedMemAccessFromHost=1: GPU accesses GPU memory without migrations\ncudaDeviceSynchronize\n();\n// directManagedMemAccessFromHost=0: GPU faults and triggers host-to-device migrations\ncudaFree\n(\nret\n);\n}\nAfter\nwrite\nkernel is completed,\nret\nwill be created and initialized in GPU memory.\nNext, the CPU will access\nret\nfollowed by\nappend\nkernel using the same\nret\nmemory again.\nThis code will show different behavior depending on the system architecture and support of hardware coherency:\nOn systems with\ndirectManagedMemAccessFromHost=1\n:\nCPU accesses to the managed buffer will not trigger any migrations;\nthe data will remain resident in GPU memory and any subsequent GPU kernels\ncan continue to access it directly without inflicting faults or migrations.\nOn systems with\ndirectManagedMemAccessFromHost=0\n:\nCPU accesses to the managed buffer will page fault and initiate data migration;\nany GPU kernel trying to access the same data first time will page fault and\nmigrate pages back to GPU memory.\n24.2.2.3.\nHost Native Atomics\nï\nSome devices, including NVLink-connected devices in\nhardware coherent systems\n, support hardware-accelerated\natomic accesses to CPU-resident memory. This implies that atomic accesses to host memory\ndo not have to be emulated with a page fault.\nFor these devices, the attribute\ncudaDevAttrHostNativeAtomicSupported\nis set to 1.\n24.2.2.4.\nAtomic accesses & synchronization primitives\nï\nCUDA Unified Memory supports all atomic operations available to host and device threads,\nenabling all threads to cooperate by concurrently accessing the same shared memory location.\nThe\nCUDA C++ standard library\nprovides many heterogeneous synchronization primitives tuned for concurrent use between host and device threads,\nincluding\ncuda::atomic\n,\ncuda::atomic_ref\n,\ncuda::barrier\n,\ncuda::semaphore\n, among many others.\nOn systems without\nCPU and GPU page tables: hardware coherency vs. software coherency\n,\natomic accesses from the device to file-backed host memory are not supported.\nThe following example code is valid on systems with\nCPU and GPU page tables: hardware coherency vs. software coherency\nbut exhibits undefined behavior on other systems:\n#include\n<cuda/atomic>\n#include\n<cstdio>\n#include\n<fcntl.h>\n#include\n<sys/mman.h>\n#define ERR(msg, ...) { fprintf(stderr, msg, ##__VA_ARGS__); return EXIT_FAILURE; }\n__global__\nvoid\nkernel\n(\nint\n*\nptr\n)\n{\ncuda\n::\natomic_ref\n{\n*\nptr\n}.\nstore\n(\n2\n);\n}\nint\nmain\n()\n{\n// this will be closed/deleted by default on exit\nFILE\n*\ntmp_file\n=\ntmpfile64\n();\n// need to allcate space in the file, we do this with posix_fallocate here\nint\nstatus\n=\nposix_fallocate\n(\nfileno\n(\ntmp_file\n),\n0\n,\n4096\n);\nif\n(\nstatus\n!=\n0\n)\nERR\n(\n\"Failed to allocate space in temp file\n\\n\n\"\n);\nint\n*\nptr\n=\n(\nint\n*\n)\nmmap\n(\nNULL\n,\n4096\n,\nPROT_READ\n|\nPROT_WRITE\n,\nMAP_PRIVATE\n,\nfileno\n(\ntmp_file\n),\n0\n);\nif\n(\nptr\n==\nMAP_FAILED\n)\nERR\n(\n\"Failed to map temp file\n\\n\n\"\n);\n// initialize the value in our file-backed memory\n*\nptr\n=\n1\n;\nprintf\n(\n\"Atom value: %d\n\\n\n\"\n,\n*\nptr\n);\n// device and host thread access ptr concurrently, using cuda::atomic_ref\nkernel\n<<<\n1\n,\n1\n>>>\n(\nptr\n);\nwhile\n(\ncuda\n::\natomic_ref\n{\n*\nptr\n}.\nload\n()\n!=\n2\n);\n// this will always be 2\nprintf\n(\n\"Atom value: %d\n\\n\n\"\n,\n*\nptr\n);\nreturn\nEXIT_SUCCESS\n;\n}\nOn systems without\nCPU and GPU page tables: hardware coherency vs. software coherency\n,\natomic accesses to unified memory may incur page faults which can lead to significant latencies.\nNote that this is not the case for all GPU atomics to CPU memory on these systems:\noperations listed by\nnvidia-smi\n-q\n|\ngrep\n\"Atomic\nCaps\nOutbound\"\nmay avoid page faults.\nOn systems with\nCPU and GPU page tables: hardware coherency vs. software coherency\n,\natomics between host and device do not require page faults,\nbut may still fault for other reasons that any memory access can fault for.\n24.2.2.5.\nMemcpy()/Memset() Behavior With Unified Memory\nï\ncudaMemcpy*()\nand\ncudaMemset*()\naccept any unified memory pointer as arguments.\nFor\ncudaMemcpy*()\n, the direction specified as\ncudaMemcpyKind\nis a performance hint,\nwhich can have a higher performance impact if any of the arguments is a unified memory pointer.\nThus, it is recommended to follow the following performance advice:\nWhen the physical location of unified memory is known, use an accurate\ncudaMemcpyKind\nhint.\nPrefer\ncudaMemcpyDefault\nover an inaccurate\ncudaMemcpyKind\nhint.\nAlways use populated (initialized) buffers: avoid using these APIs to initialize memory.\nAvoid using\ncudaMemcpy*()\nif both pointers point to System-Allocated Memory:\nlaunch a kernel or use a CPU memory copy algorithm such as\nstd::memcpy\ninstead.\n24.3.\nUnified memory on devices without full CUDA Unified Memory support\nï\n24.3.1.\nUnified memory on devices with only CUDA Managed Memory support\nï\nFor devices with compute capability 6.x or higher but without\npageable memory access\n,\nCUDA Managed Memory is fully supported and coherent.\nThe programming model and performance tuning of unified memory is largely similar\nto the model as described in\nUnified memory on devices with full CUDA Unified Memory support\n,\nwith the notable exception that system allocators cannot be used to allocate memory.\nThus, the following list of sub-sections do not apply:\nSystem-Allocated Memory: in-depth examples\nHardware/Software Coherency\n24.3.2.\nUnified memory on Windows or devices with compute capability 5.x\nï\nDevices with compute capability lower than 6.0 or Windows platforms support CUDA Managed Memory v1.0 with limited support for data migration and coherency as well as memory oversubscription. The following sub-sections describe in more detail how to use and optimize Managed Memory on these platforms.\n24.3.2.1.\nData Migration and Coherency\nï\nGPU architectures of compute capability lower than 6.0 do not support fine-grained movement of the managed data to GPU on-demand. Whenever a GPU kernel is launched all managed memory generally has to be transferred to GPU memory to avoid faulting on memory access. With compute capability 6.x a new GPU page faulting mechanism is introduced that provides more seamless Unified Memory functionality. Combined with the system-wide virtual address space, page faulting provides several benefits. First, page faulting means that the CUDA system software doesnât need to synchronize all managed memory allocations to the GPU before each kernel launch. If a kernel running on the GPU accesses a page that is not resident in its memory, it faults, allowing the page to be automatically migrated to the GPU memory on-demand. Alternatively, the page may be mapped into the GPU address space for access over the PCIe or NVLink interconnects (mapping on access can sometimes be faster than migration). Note that Unified Memory is system-wide: GPUs (and CPUs) can fault on and migrate memory pages either from CPU memory or from the memory of other GPUs in the system.\n24.3.2.2.\nGPU Memory Oversubscription\nï\nDevices of compute capability lower than 6.0 cannot allocate more managed memory than the physical size of GPU memory.\n24.3.2.3.\nMulti-GPU\nï\nOn systems with devices of compute capabilities lower than 6.0 managed allocations are automatically visible to all GPUs in a system via the peer-to-peer capabilities of the GPUs. Managed memory allocations behave similar to unmanaged memory allocated using\ncudaMalloc()\n: the current active device is the home for the physical allocation but other GPUs in the system will access the memory at reduced bandwidth over the PCIe bus.\nOn Linux the managed memory is allocated in GPU memory as long as all GPUs that are actively being used by a program have the peer-to-peer support. If at any time the application starts using a GPU that doesnât have peer-to-peer support with any of the other GPUs that have managed allocations on them, then the driver will migrate all managed allocations to system memory. In this case, all GPUs experience PCIe bandwidth restrictions.\nOn Windows, if peer mappings are not available (for example, between GPUs of different architectures), then the system will automatically fall back to using zero-copy memory, regardless of whether both GPUs are actually used by a program. If only one GPU is actually going to be used, it is necessary to set the\nCUDA_VISIBLE_DEVICES\nenvironment variable before launching the program. This constrains which GPUs are visible and allows managed memory to be allocated in GPU memory.\nAlternatively, on Windows users can also set\nCUDA_MANAGED_FORCE_DEVICE_ALLOC\nto a non-zero value to force the driver to always use device memory for physical storage. When this environment variable is set to a non-zero value, all devices used in that process that support managed memory have to be peer-to-peer compatible with each other. The error\n::cudaErrorInvalidDevice\nwill be returned if a device that supports managed memory is used and it is not peer-to-peer compatible with any of the other managed memory supporting devices that were previously used in that process, even if\n::cudaDeviceReset\nhas been called on those devices. These environment variables are described in\nCUDA Environment Variables\n. Note that starting from CUDA 8.0\nCUDA_MANAGED_FORCE_DEVICE_ALLOC\nhas no effect on Linux operating systems.\n24.3.2.4.\nCoherency and Concurrency\nï\nSimultaneous access to managed memory on devices of compute capability lower than 6.0 is not possible, because coherence could not be guaranteed if the CPU accessed a Unified Memory allocation while a GPU kernel was active.\n24.3.2.4.1.\nGPU Exclusive Access To Managed Memory\nï\nTo ensure coherency on pre-6.x GPU architectures, the Unified Memory programming model puts constraints on data accesses while both the CPU and GPU are executing concurrently. In effect, the GPU has exclusive access to all managed data while any kernel operation is executing, regardless of whether the specific kernel is actively using the data. When managed data is used with\ncudaMemcpy*()\nor\ncudaMemset*()\n, the system may choose to access the source or destination from the host or the device, which will put constraints on concurrent CPU access to that data while the\ncudaMemcpy*()\nor\ncudaMemset*()\nis executing. See\nMemcpy()/Memset() Behavior With Unified Memory\nfor further details.\nIt is not permitted for the CPU to access any managed allocations or variables while the GPU is active for devices with\nconcurrentManagedAccess\nproperty set to 0. On these systems concurrent CPU/GPU accesses, even to different managed memory allocations, will cause a segmentation fault because the page is considered inaccessible to the CPU.\n__device__\n__managed__\nint\nx\n,\ny\n=\n2\n;\n__global__\nvoid\nkernel\n()\n{\nx\n=\n10\n;\n}\nint\nmain\n()\n{\nkernel\n<<<\n1\n,\n1\n>>>\n();\ny\n=\n20\n;\n// Error on GPUs not supporting concurrent access\ncudaDeviceSynchronize\n();\nreturn\n0\n;\n}\nIn example above, the GPU program\nkernel\nis still active when the CPU touches\ny\n. (Note how it occurs before\ncudaDeviceSynchronize()\n.) The code runs successfully on devices of compute capability 6.x due to the GPU page faulting capability which lifts all restrictions on simultaneous access. However, such memory access is invalid on pre-6.x architectures even though the CPU is accessing different data than the GPU. The program must explicitly synchronize with the GPU before accessing\ny\n:\n__device__\n__managed__\nint\nx\n,\ny\n=\n2\n;\n__global__\nvoid\nkernel\n()\n{\nx\n=\n10\n;\n}\nint\nmain\n()\n{\nkernel\n<<<\n1\n,\n1\n>>>\n();\ncudaDeviceSynchronize\n();\ny\n=\n20\n;\n//  Success on GPUs not supporing concurrent access\nreturn\n0\n;\n}\nAs this example shows, on systems with pre-6.x GPU architectures, a CPU thread may not access any managed data in between performing a kernel launch and a subsequent synchronization call, regardless of whether the GPU kernel actually touches that same data (or any managed data at all). The mere potential for concurrent CPU and GPU access is sufficient for a process-level exception to be raised.\nNote that if memory is dynamically allocated with\ncudaMallocManaged()\nor\ncuMemAllocManaged()\nwhile the GPU is active, the behavior of the memory is unspecified until additional work is launched or the GPU is synchronized. Attempting to access the memory on the CPU during this time may or may not cause a segmentation fault. This does not apply to memory allocated using the flag\ncudaMemAttachHost\nor\nCU_MEM_ATTACH_HOST\n.\n24.3.2.4.2.\nExplicit Synchronization and Logical GPU Activity\nï\nNote that explicit synchronization is required even if\nkernel\nruns quickly and finishes before the CPU touches\ny\nin the above example. Unified Memory uses logical activity to determine whether the GPU is idle. This aligns with the CUDA programming model, which specifies that a kernel can run at any time following a launch and is not guaranteed to have finished until the host issues a synchronization call.\nAny function call that logically guarantees the GPU completes its work is valid. This includes\ncudaDeviceSynchronize()\n;\ncudaStreamSynchronize()\nand\ncudaStreamQuery()\n(provided it returns\ncudaSuccess\nand not\ncudaErrorNotReady\n) where the specified stream is the only stream still executing on the GPU;\ncudaEventSynchronize()\nand\ncudaEventQuery()\nin cases where the specified event is not followed by any device work; as well as uses of\ncudaMemcpy()\nand\ncudaMemset()\nthat are documented as being fully synchronous with respect to the host.\nDependencies created between streams will be followed to infer completion of other streams by synchronizing on a stream or event. Dependencies can be created via\ncudaStreamWaitEvent()\nor implicitly when using the default (NULL) stream.\nIt is legal for the CPU to access managed data from within a stream callback, provided no other stream that could potentially be accessing managed data is active on the GPU. In addition, a callback that is not followed by any device work can be used for synchronization: for example, by signaling a condition variable from inside the callback; otherwise, CPU access is valid only for the duration of the callback(s).\nThere are several important points of note:\nIt is always permitted for the CPU to access non-managed zero-copy data while the GPU is active.\nThe GPU is considered active when it is running any kernel, even if that kernel does not make use of managed data. If a kernel might use data, then access is forbidden, unless device property\nconcurrentManagedAccess\nis 1.\nThere are no constraints on concurrent inter-GPU access of managed memory, other than those that apply to multi-GPU access of non-managed memory.\nThere are no constraints on concurrent GPU kernels accessing managed data.\nNote how the last point allows for races between GPU kernels, as is currently the case for non-managed GPU memory. As mentioned previously, managed memory functions identically to non-managed memory from the perspective of the GPU. The following code example illustrates these points:\nint\nmain\n()\n{\ncudaStream_t\nstream1\n,\nstream2\n;\ncudaStreamCreate\n(\n&\nstream1\n);\ncudaStreamCreate\n(\n&\nstream2\n);\nint\n*\nnon_managed\n,\n*\nmanaged\n,\n*\nalso_managed\n;\ncudaMallocHost\n(\n&\nnon_managed\n,\n4\n);\n// Non-managed, CPU-accessible memory\ncudaMallocManaged\n(\n&\nmanaged\n,\n4\n);\ncudaMallocManaged\n(\n&\nalso_managed\n,\n4\n);\n// Point 1: CPU can access non-managed data.\nkernel\n<<<\n1\n,\n1\n,\n0\n,\nstream1\n>>>\n(\nmanaged\n);\n*\nnon_managed\n=\n1\n;\n// Point 2: CPU cannot access any managed data while GPU is busy,\n//          unless concurrentManagedAccess = 1\n// Note we have not yet synchronized, so \"kernel\" is still active.\n*\nalso_managed\n=\n2\n;\n// Will issue segmentation fault\n// Point 3: Concurrent GPU kernels can access the same data.\nkernel\n<<<\n1\n,\n1\n,\n0\n,\nstream2\n>>>\n(\nmanaged\n);\n// Point 4: Multi-GPU concurrent access is also permitted.\ncudaSetDevice\n(\n1\n);\nkernel\n<<<\n1\n,\n1\n>>>\n(\nmanaged\n);\nreturn\n0\n;\n}\n24.3.2.4.3.\nManaging Data Visibility and Concurrent CPU + GPU Access with Streams\nï\nUntil now it was assumed that for SM architectures before 6.x: 1) any active kernel may use any managed memory, and 2) it was invalid to use managed memory from the CPU while a kernel is active. Here we present a system for finer-grained control of managed memory designed to work on all devices supporting managed memory, including older architectures with\nconcurrentManagedAccess\nequal to 0.\nThe CUDA programming model provides streams as a mechanism for programs to indicate dependence and independence among kernel launches. Kernels launched into the same stream are guaranteed to execute consecutively, while kernels launched into different streams are permitted to execute concurrently. Streams describe independence between work items and hence allow potentially greater efficiency through concurrency.\nUnified Memory builds upon the stream-independence model by allowing a CUDA program to explicitly associate managed allocations with a CUDA stream. In this way, the programmer indicates the use of data by kernels based on whether they are launched into a specified stream or not. This enables opportunities for concurrency based on program-specific data access patterns. The function to control this behavior is:\ncudaError_t\ncudaStreamAttachMemAsync\n(\ncudaStream_t\nstream\n,\nvoid\n*\nptr\n,\nsize_t\nlength\n=\n0\n,\nunsigned\nint\nflags\n=\n0\n);\nThe\ncudaStreamAttachMemAsync()\nfunction associates\nlength\nbytes of memory starting from\nptr\nwith the specified\nstream\n. (Currently,\nlength\nmust always be 0 to indicate that the entire region should be attached.) Because of this association, the Unified Memory system allows CPU access to this memory region so long as all operations in\nstream\nhave completed, regardless of whether other streams are active. In effect, this constrains exclusive ownership of the managed memory region by an active GPU to per-stream activity instead of whole-GPU activity.\nMost importantly, if an allocation is not associated with a specific stream, it is visible to all running kernels regardless of their stream. This is the default visibility for a\ncudaMallocManaged()\nallocation or a\n__managed__\nvariable; hence, the simple-case rule that the CPU may not touch the data while any kernel is running.\nBy associating an allocation with a specific stream, the program makes a guarantee that only kernels launched into that stream will touch that data. No error checking is performed by the Unified Memory system: it is the programmerâs responsibility to ensure that guarantee is honored.\nIn addition to allowing greater concurrency, the use of\ncudaStreamAttachMemAsync()\ncan (and typically does) enable data transfer optimizations within the Unified Memory system that may affect latencies and other overhead.\n24.3.2.4.4.\nStream Association Examples\nï\nAssociating data with a stream allows fine-grained control over CPU + GPU concurrency, but what data is visible to which streams must be kept in mind when using devices of compute capability lower than 6.0. Looking at the earlier synchronization example:\n__device__\n__managed__\nint\nx\n,\ny\n=\n2\n;\n__global__\nvoid\nkernel\n()\n{\nx\n=\n10\n;\n}\nint\nmain\n()\n{\ncudaStream_t\nstream1\n;\ncudaStreamCreate\n(\n&\nstream1\n);\ncudaStreamAttachMemAsync\n(\nstream1\n,\n&\ny\n,\n0\n,\ncudaMemAttachHost\n);\ncudaDeviceSynchronize\n();\n// Wait for Host attachment to occur.\nkernel\n<<<\n1\n,\n1\n,\n0\n,\nstream1\n>>>\n();\n// Note: Launches into stream1.\ny\n=\n20\n;\n// Success â a kernel is running but âyâ\n// has been associated with no stream.\nreturn\n0\n;\n}\nHere we explicitly associate\ny\nwith host accessibility, thus enabling access at all times from the CPU. (As before, note the absence of\ncudaDeviceSynchronize()\nbefore the access.) Accesses to\ny\nby the GPU running\nkernel\nwill now produce undefined results.\nNote that associating a variable with a stream does not change the associating of any other variable. For example, associating\nx\nwith\nstream1\ndoes not ensure that only\nx\nis accessed by kernels launched in\nstream1\n, thus an error is caused by this code:\n__device__\n__managed__\nint\nx\n,\ny\n=\n2\n;\n__global__\nvoid\nkernel\n()\n{\nx\n=\n10\n;\n}\nint\nmain\n()\n{\ncudaStream_t\nstream1\n;\ncudaStreamCreate\n(\n&\nstream1\n);\ncudaStreamAttachMemAsync\n(\nstream1\n,\n&\nx\n);\n// Associate âxâ with stream1.\ncudaDeviceSynchronize\n();\n// Wait for âxâ attachment to occur.\nkernel\n<<<\n1\n,\n1\n,\n0\n,\nstream1\n>>>\n();\n// Note: Launches into stream1.\ny\n=\n20\n;\n// ERROR: âyâ is still associated globally\n// with all streams by default\nreturn\n0\n;\n}\nNote how the access to\ny\nwill cause an error because, even though\nx\nhas been associated with a stream, we have told the system nothing about who can see\ny\n. The system therefore conservatively assumes that\nkernel\nmight access it and prevents the CPU from doing so.\n24.3.2.4.5.\nStream Attach With Multithreaded Host Programs\nï\nThe primary use for\ncudaStreamAttachMemAsync()\nis to enable independent task parallelism using CPU threads. Typically in such a program, a CPU thread creates its own stream for all work that it generates because using CUDAâs NULL stream would cause dependencies between threads.\nThe default global visibility of managed data to any GPU stream can make it difficult to avoid interactions between CPU threads in a multi-threaded program. Function\ncudaStreamAttachMemAsync()\nis therefore used to associate a threadâs managed allocations with that threadâs own stream, and the association is typically not changed for the life of the thread.\nSuch a program would simply add a single call to\ncudaStreamAttachMemAsync()\nto use unified memory for its data accesses:\n// This function performs some task, in its own private stream.\nvoid\nrun_task\n(\nint\n*\nin\n,\nint\n*\nout\n,\nint\nlength\n)\n{\n// Create a stream for us to use.\ncudaStream_t\nstream\n;\ncudaStreamCreate\n(\n&\nstream\n);\n// Allocate some managed data and associate with our stream.\n// Note the use of the host-attach flag to cudaMallocManaged();\n// we then associate the allocation with our stream so that\n// our GPU kernel launches can access it.\nint\n*\ndata\n;\ncudaMallocManaged\n((\nvoid\n**\n)\n&\ndata\n,\nlength\n,\ncudaMemAttachHost\n);\ncudaStreamAttachMemAsync\n(\nstream\n,\ndata\n);\ncudaStreamSynchronize\n(\nstream\n);\n// Iterate on the data in some way, using both Host & Device.\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nN\n;\ni\n++\n)\n{\ntransform\n<<<\n100\n,\n256\n,\n0\n,\nstream\n>>>\n(\nin\n,\ndata\n,\nlength\n);\ncudaStreamSynchronize\n(\nstream\n);\nhost_process\n(\ndata\n,\nlength\n);\n// CPU uses managed data.\nconvert\n<<<\n100\n,\n256\n,\n0\n,\nstream\n>>>\n(\nout\n,\ndata\n,\nlength\n);\n}\ncudaStreamSynchronize\n(\nstream\n);\ncudaStreamDestroy\n(\nstream\n);\ncudaFree\n(\ndata\n);\n}\nIn this example, the allocation-stream association is established just once, and then\ndata\nis used repeatedly by both the host and device. The result is much simpler code than occurs with explicitly copying data between host and device, although the result is the same.\n24.3.2.4.6.\nAdvanced Topic: Modular Programs and Data Access Constraints\nï\nIn the previous example\ncudaMallocManaged()\nspecifies the\ncudaMemAttachHost\nflag, which creates an allocation that is initially invisible to device-side execution. (The default allocation would be visible to all GPU kernels on all streams.) This ensures that there is no accidental interaction with another threadâs execution in the interval between the data allocation and when the data is acquired for a specific stream.\nWithout this flag, a new allocation would be considered in-use on the GPU if a kernel launched by another thread happens to be running. This might impact the threadâs ability to access the newly allocated data from the CPU (for example, within a base-class constructor) before it is able to explicitly attach it to a private stream. To enable safe independence between threads, therefore, allocations should be made specifying this flag.\nNote\nAn alternative would be to place a process-wide barrier across all threads after the allocation has been attached to the stream. This would ensure that all threads complete their data/stream associations before any kernels are launched, avoiding the hazard. A second barrier would be needed before the stream is destroyed because stream destruction causes allocations to revert to their default visibility. The\ncudaMemAttachHost\nflag exists both to simplify this process, and because it is not always possible to insert global barriers where required.\n24.3.2.4.7.\nMemcpy()/Memset() Behavior With Stream-associated Unified Memory\nï\nSee\nMemcpy()/Memset() Behavior With Unified Memory\nfor a general overview of\ncudaMemcpy*\n/\ncudaMemset*\nbehavior on devices with\nconcurrentManagedAccess\nset. On devices where\nconcurrentManagedAccess\nis not set, the following rules apply:\nIf\ncudaMemcpyHostTo*\nis specified and the source data is unified memory, then it will be accessed from the host if it is coherently accessible from the host in the copy stream\n(1)\n; otherwise it will be accessed from the device. Similar rules apply to the destination when\ncudaMemcpy*ToHost\nis specified and the destination is unified memory.\nIf\ncudaMemcpyDeviceTo*\nis specified and the source data is unified memory, then it will be accessed from the device. The source must be coherently accessible from the device in the copy stream\n(2)\n; otherwise, an error is returned. Similar rules apply to the destination when\ncudaMemcpy*ToDevice\nis specified and the destination is unified memory.\nIf\ncudaMemcpyDefault\nis specified, then unified memory will be accessed from the host either if it cannot be coherently accessed from the device in the copy stream\n(2)\nor if the preferred location for the data is\ncudaCpuDeviceId\nand it can be coherently accessed from the host in the copy stream\n(1)\n; otherwise, it will be accessed from the device.\nWhen using\ncudaMemset*()\nwith unified memory, the data must be coherently accessible from the device in the stream being used for the\ncudaMemset()\noperation\n(2)\n; otherwise, an error is returned.\nWhen data is accessed from the device either by\ncudaMemcpy*\nor\ncudaMemset*\n, the stream of operation is considered to be active on the GPU. During this time, any CPU access of data that is associated with that stream or data that has global visibility, will result in a segmentation fault if the GPU has a zero value for the device attribute\nconcurrentManagedAccess\n. The program must synchronize appropriately to ensure the operation has completed before accessing any associated data from the CPU.\nCoherently accessible from the host in a given stream means that the memory neither has global visibility nor is it associated with the given stream.\nCoherently accessible from the device in a given stream means that the memory either has global visibility or is associated with the given stream.\n25.\nLazy Loading\nï\n25.1.\nWhat is Lazy Loading?\nï\nLazy Loading delays loading of CUDA modules and kernels from program initialization closer to kernels execution.\nIf a program does not use every single kernel it has included, then some kernels will be loaded unneccessarily.\nThis is very common, especially if you include any libraries.\nMost of the time, programs only use a small amount of kernels from libraries they include.\nThanks to Lazy Loading, programs are able to only load kernels they are actually going to use, saving time on initialization.\nThis reduces memory overhead, both on GPU memory and host memory.\nLazy Loading is enabled by setting the\nCUDA_MODULE_LOADING\nenvironment variable to\nLAZY\n.\nFirstly, CUDA Runtime will no longer load all modules during program initialization, with the exception of modules containing managed variables.\nEach module will be loaded on first usage of a variable or a kernel from that module.\nThis optimization is only relevant to CUDA Runtime users, CUDA Driver users who use\ncuModuleLoad\nare unaffected. This optimization shipped in CUDA 11.8.\nThe behavior for CUDA Driver users who use\ncuLibraryLoad\nto load module data into memory can be changed by\nsetting the\nCUDA_MODULE_DATA_LOADING\nenvironment variable.\nSecondly, loading a module (\ncuModuleLoad*()\nfamily of functions) will not be loading kernels immediately,\ninstead it will delay loading of a kernel until\ncuModuleGetFunction()\nis called.\nThere are certain exceptions here, some kernels have to be loaded during\ncuModuleLoad*()\n,\nsuch as kernels of which pointers are stored in global variables.\nThis optimization is relevant to both CUDA Runtime and CUDA Driver users.\nCUDA Runtime will only call\ncuModuleGetFunction()\nwhen a kernel is used/referenced for the first time.\nThis optimization shipped in CUDA 11.7.\nBoth of these optimizations are designed to be invisible to the user, assuming CUDA Programming Model is followed.\n25.2.\nLazy Loading version support\nï\nLazy Loading is a CUDA Runtime and CUDA Driver feature. Upgrades to both might be necessary to utilize the feature.\n25.2.1.\nDriver\nï\nLazy Loading requires R515+ user-mode library, but it supports Forward Compatibility, meaning it can run on top of older kernel mode drivers.\nWithout R515+ user-mode library, Lazy Loading is not available in any shape or form, even if toolkit version is 11.7+.\n25.2.2.\nToolkit\nï\nLazy Loading was introduced in CUDA 11.7, and received a significant upgrade in CUDA 11.8.\nIf your application uses CUDA Runtime, then in order to see benefits from Lazy Loading your application must use 11.7+ CUDA Runtime.\nAs CUDA Runtime is usually linked statically into programs and libraries,\nthis means that you have to recompile your program with CUDA 11.7+ toolkit and use CUDA 11.7+ libraries.\nOtherwise you will not see the benefits of Lazy Loading, even if your driver version supports it.\nIf only some of your libraries are 11.7+, you will only see benefits of Lazy Loading in those libraries.\nOther libraries will still load everything eagerly.\n25.2.3.\nCompiler\nï\nLazy Loading does not require any compiler support. Both SASS and PTX compiled with pre-11.7 compilers can be loaded with Lazy Loading enabled,\nand will see full benefits of the feature. However, 11.7+ CUDA Runtime is still required, as described above.\n25.3.\nTriggering loading of kernels in lazy mode\nï\nLoading kernels and variables happens automatically, without any need for explicit loading.\nSimply launching a kernel or referencing a variable or a kernel will automatically load relevant modules and kernels.\nHowever, if for any reason you wish to load a kernel without executing it or modifying it in any way, we recommend the following.\n25.3.1.\nCUDA Driver API\nï\nLoading of kernels happens during\ncuModuleGetFunction()\ncall.\nThis call is necessary even without Lazy Loading, as it is the only way to obtain a kernel handle.\nHowever, you can also use this API to control with finer granularity when kernels are loaded.\n25.3.2.\nCUDA Runtime API\nï\nCUDA Runtime API manages module management automatically,\nso we recommend simply using\ncudaFuncGetAttributes()\nto reference the kernel.\nThis will ensure that the kernel is loaded without changing the state.\n25.4.\nQuerying whether Lazy Loading is Turned On\nï\nIn order to check whether user enabled Lazy Loading,\nCUresult\ncuModuleGetLoadingMode\n(\nCUmoduleLoadingMode*\nmode\n)\ncan be used.\nItâs important to note that CUDA must be initialized before running this function. Sample usage can be seen in the snippet below.\n#include\n\"cuda.h\"\n#include\n\"assert.h\"\n#include\n\"iostream\"\nint\nmain\n()\n{\nCUmoduleLoadingMode\nmode\n;\nassert\n(\nCUDA_SUCCESS\n==\ncuInit\n(\n0\n));\nassert\n(\nCUDA_SUCCESS\n==\ncuModuleGetLoadingMode\n(\n&\nmode\n));\nstd\n::\ncout\n<<\n\"CUDA Module Loading Mode is \"\n<<\n((\nmode\n==\nCU_MODULE_LAZY_LOADING\n)\n?\n\"lazy\"\n:\n\"eager\"\n)\n<<\nstd\n::\nendl\n;\nreturn\n0\n;\n}\n25.5.\nPossible Issues when Adopting Lazy Loading\nï\nLazy Loading is designed so that it should not require any modifications to applications to use it.\nThat said, there are some caveats, especially when applications are not fully compliant with CUDA Programming Model.\n25.5.1.\nConcurrent Execution\nï\nLoading kernels might require context synchronization.\nSome programs incorrectly treat the possibility of concurrent execution of kernels as a guarantee.\nIn such cases, if program assumes that two kernels will be able to execute concurrently,\nand one of the kernels will not return without the other kernel executing, there is a possibility of a deadlock.\nIf kernel A will be spinning in an infinite loop until kernel B is executing.\nIn such case launching kernel B will trigger lazy loading of kernel B. If this loading will require context synchronization,\nthen we have a deadlock: kernel A is waiting for kernel B, but loading kernel B is stuck waiting for kernel A to finish to synchronize the context.\nSuch program is an anti-pattern, but if for any reason you want to keep it you can do the following:\npreload all kernels that you hope to execute concurrently prior to launching them\nrun application with\nCUDA_MODULE_DATA_LOADING=EAGER\nto force loading data eagerly without forcing each function to load eagerly\n25.5.2.\nAllocators\nï\nLazy Loading delays loading code from initialization phase of the program closer to execution phase.\nLoading code onto the GPU requires memory allocation.\nIf your application tries to allocate the entire VRAM on startup, for example, to use it for its own allocator,\nthen it might turn out that there will be no more memory left to load the kernels.\nThis is despite the fact that overall Lazy Loading frees up more memory for the user.\nCUDA will need to allocate some memory to load each kernel, which usually happens at first launch time of each kernel.\nIf your application allocator greedily allocated everything, CUDA will fail to allocate memory.\nPossible solutions:\nuse\ncudaMallocAsync()\ninstead of an allocator that allocates the entire VRAM on startup\nadd some buffer to compensate for the delayed loading of kernels\npreload all kernels that will be used in the program before trying to initialize your allocator\n25.5.3.\nAutotuning\nï\nSome applications launch several kernels implementing the same functionality to determine which one is the fastest.\nWhile it is overall advisable to run at least one warmup iteration, it becomes especially important with Lazy Loading.\nAfter all, including time taken to load the kernel will skew your results.\nPossible solutions:\ndo at least one warmup interaction prior to measurement\npreload the benchmarked kernel prior to launching it\n26.\nExtended GPU Memory\nï\nThe Extended GPU Memory (EGM) feature, utilizing the high-bandwidth\nNVLink-C2C, facilitates efficient access to all system memory by GPUs,\nin a single-node system.\nEGM applies to integrated CPU-GPU NVIDIA systems by allowing physical memory\nallocation that can be accessed from any GPU\nthread within the setup. EGM ensures that all GPUs can access\nits resources at the speed of either GPU-GPU NVLink or NVLink-C2C.\nIn this setup, memory accesses occur via the local high-bandwidth\nNVLink-C2C. For remote memory accesses,\nGPU NVLink and, in some cases, NVLink-C2C are used. With EGM, GPU\nthreads gain the capability to access all available memory resources,\nincluding CPU attached memory and HBM3, over the NVSwitch fabric.\n26.1.\nPreliminaries\nï\nBefore diving into API changes for EGM functionalities, we are going to\ncover currently supported topologies, identifier assignment,\nprerequisites for virtual memory management, and CUDA types for EGM.\n26.1.1.\nEGM Platforms: System topology\nï\nCurrently, EGM can be enabled in three platforms:\n(1) Single-Node, Single-GPU\n:\nConsists of an Arm-based CPU, CPU attached memory, and a GPU. Between the CPU\nand the GPU there is a high bandwidth C2C (Chip-to-Chip) interconnect.\n(2) Single-Node, Multi-GPU\n: Consists of fully connected four\nsingle-node, single-GPU platforms.\n(3) Multi-Node, Single-GPU\n:\nTwo or more single-node multi-socket systems.\nNote\nUsing\ncgroups\nto limit available devices will block routing over EGM\nand cause performance issues. Use\nCUDA_VISIBLE_DEVICES\ninstead.\n26.1.2.\nSocket Identifiers: What are they? How to access them?\nï\nNUMA (Non-Uniform Memory Access) is a memory architecture used in\nmulti-processor computer systems such that the memory is divided into\nmultiple nodes. Each node has its own processors and memory. In such a\nsystem, NUMA divides the system into nodes and assigns a unique\nidentifier (\nnumaID\n) to every node.\nEGM uses the NUMA node identifier which is assigned by the operating\nsystem. Note that, this identifier is different from the ordinal of a\ndevice and it is associated with the closest host node. In addition to\nthe existing methods, the user can obtain the identifier of the host\nnode (\nnumaID\n) by calling\ncuDeviceGetAttribute\nwith\nCU_DEVICE_ATTRIBUTE_HOST_NUMA_ID\nattribute type as follows:\nint\nnumaId\n;\ncuDeviceGetAttribute\n(\n&\nnumaId\n,\nCU_DEVICE_ATTRIBUTE_HOST_NUMA_ID\n,\ndeviceOrdinal\n);\n26.1.3.\nAllocators and EGM support\nï\nMapping system memory as EGM does not cause any performance issues. In\nfact, accessing a remote socketâs system memory mapped as EGM is going\nto be faster. Because, with EGM traffic is guaranteed to be routed over\nNVLinks. Currently,\ncuMemCreate\nand\ncudaMemPoolCreate\nallocators are\nsupported with appropriate location type and NUMA identifiers.\n26.1.4.\nMemory management extensions to current APIs\nï\nCurrently, EGM memory can be mapped with Virtual Memory (\ncuMemCreate\n) Â or\nStream Ordered Memory (\ncudaMemPoolCreate\n) allocators. The user is\nresponsible for allocating physical memory and mapping it to a virtual\nmemory address space on all sockets.\nNote\nMulti-node, single-GPU platforms require interprocess\ncommunication. Therefore we encourage the reader to see\nChapter 3\nNote\nWe encourage readers to read CUDA Programming Guideâs\nChapter 10\nand\nChapter 11\nfor a better understanding.\nNew CUDA property types have been added to APIs for allowing those\napproaches to understand allocation locations using NUMA-like node\nidentifiers:\nCUDA Type\nUsed with\nCU_MEM_LOCATION_TYPE_HOST_NUMA\nCUmemAllocationProp\nfor\ncuMemCreate\ncudaMemLocationTypeHostNuma\ncudaMemPoolProps\nfor\ncudaMemPoolCreate\nNote\nPlease see\nCUDA Driver API\nand\nCUDA Runtime Data Types\nto find more about NUMA specific CUDA types.\n26.2.\nUsing the EGM Interface\nï\n26.2.1.\nSingle-Node, Single-GPU\nï\nAny of the existing CUDA host allocators as well as system allocated\nmemory can be used to benefit from high-bandwidth C2C. To the user,\nlocal access is what a host allocation is today.\nNote\nRefer to the tuning guide for more information about memory allocators and page sizes.\n26.2.2.\nSingle-Node, Multi-GPU\nï\nIn a multi-GPU system, the user has to provide host information for\nthe placement. As we mentioned, a natural way to express that\ninformation would be by using NUMA node IDs and EGM follows this\napproach. Therefore, using the\ncuDeviceGetAttribute\nfunction the\nuser should be able to learn the closest NUMA node id. (See\nSocket Identifiers: What are they? How to access them?\n).\nThen the user can allocate and manage EGM memory using VMM (Virtual\nMemory Management) API or CUDA Memory Pool.\n26.2.2.1.\nUsing VMM APIs\nï\nThe first step in memory allocation using Virtual Memory Management APIs\nis to create a physical memory chunk that will provide a backing for the\nallocation. See CUDA Programming Guideâs\nVirtual Memory Management section\nfor more details. In EGM allocations the user has to explicitly provide\nCU_MEM_LOCATION_TYPE_HOST_NUMA\nÂ as the location type and\nnumaID\nas the location identifier. Also in EGM, allocationsÂ must\nbe aligned to appropriate granularity of the platform. The following\ncode snippet shows allocating physical memory with\ncuMemCreate\n:\nCUmemAllocationProp\nprop\n{};\nprop\n.\ntype\n=\nCU_MEM_ALLOCATION_TYPE_PINNED\n;\nprop\n.\nlocation\n.\ntype\n=\nCU_MEM_LOCATION_TYPE_HOST_NUMA\n;\nprop\n.\nlocation\n.\nid\n=\nnumaId\n;\nsize_t\ngranularity\n=\n0\n;\ncuMemGetAllocationGranularity\n(\n&\ngranularity\n,\n&\nprop\n,\nMEM_ALLOC_GRANULARITY_MINIMUM\n);\nsize_t\npadded_size\n=\nROUND_UP\n(\nsize\n,\ngranularity\n);\nCUmemGenericAllocationHandle\nallocHandle\n;\ncuMemCreate\n(\n&\nallocHandle\n,\npadded_size\n,\n&\nprop\n,\n0\n);\nAfter physical memory allocation, we have to reserve an address space\nand map it to a pointer. These procedures do not have EGM-specific\nchanges:\nCUdeviceptr\ndptr\n;\ncuMemAddressReserve\n(\n&\ndptr\n,\npadded_size\n,\n0\n,\n0\n,\n0\n);\ncuMemMap\n(\ndptr\n,\npadded_size\n,\n0\n,\nallocHandle\n,\n0\n);\nFinally, the user has to explicitly protect mapped virtual address\nranges. Otherwise access to the mapped space would result in a crash.\nSimilar to the memory allocation, the user has to provide\nCU_MEM_LOCATION_TYPE_HOST_NUMA\nas the location type and\nnumaId\nas the location identifier. Following code snippet create\nan access descriptors for the host node and the GPU to give read and\nwrite access for the mapped memory to both of them:\nCUmemAccessDesc\naccessDesc\n[\n2\n]{{}};\naccessDesc\n[\n0\n].\nlocation\n.\ntype\n=\nCU_MEM_LOCATION_TYPE_HOST_NUMA\n;\naccessDesc\n[\n0\n].\nlocation\n.\nid\n=\nnumaId\n;\naccessDesc\n[\n0\n].\nflags\n=\nCU_MEM_ACCESS_FLAGS_PROT_READWRITE\n;\naccessDesc\n[\n1\n].\nlocation\n.\ntype\n=\nCU_MEM_LOCATION_TYPE_DEVICE\n;\naccessDesc\n[\n1\n].\nlocation\n.\nid\n=\ncurrentDev\n;\naccessDesc\n[\n1\n].\nflags\n=\nCU_MEM_ACCESS_FLAGS_PROT_READWRITE\n;\ncuMemSetAccess\n(\ndptr\n,\nsize\n,\naccessDesc\n,\n2\n);\n26.2.2.2.\nUsing CUDA Memory Pool\nï\nTo define EGM, the user can create a memory pool on a node and give\naccess to peers. In this case, the user has to explicitly define\ncudaMemLocationTypeHostNuma\nas the location type and\nnumaId\nas the location identifier. The following code snippet shows creating a\nmemory pool\ncudaMemPoolCreate\n:\ncudaSetDevice\n(\nhomeDevice\n);\ncudaMemPoolProps\nprops\n{};\nprops\n.\nallocType\n=\ncudaMemAllocationTypePinned\n;\nprops\n.\nlocation\n.\ntype\n=\ncudaMemLocationTypeHostNuma\n;\nprops\n.\nlocation\n.\nid\n=\nnumaId\n;\ncudaMemPoolCreate\n(\n&\nmemPool\n,\n&\nprops\n);\nAdditionally, for direct connect peer access, it is also possible to use\nthe existing peer access API,\ncudaMemPoolSetAccess\n. An example\nfor an\naccessingDevice\nis shown in the following code snippet:\ncudaMemAccessDesc\ndesc\n{};\ndesc\n.\nflags\n=\ncudaMemAccessFlagsProtReadWrite\n;\ndesc\n.\nlocation\n.\ntype\n=\ncudaMemLocationTypeDevice\n;\ndesc\n.\nlocation\n.\nid\n=\naccessingDevice\n;\ncudaMemPoolSetAccess\n(\nmemPool\n,\n&\ndesc\n,\n1\n);\nWhen the memory pool is created, and accesses are given, the user can\nset created memory pool to the\nresidentDevice\nand start allocating\nmemory using\ncudaMallocAsync\n:\ncudaDeviceSetMemPool\n(\nresidentDevice\n,\nmemPool\n);\ncudaMallocAsync\n(\n&\nptr\n,\nsize\n,\nmemPool\n,\nstream\n);\nNote\nEGM is mapped with 2MB pages. Therefore, users may encounter more TLB\nmisses when accessing very large allocations.\n26.2.3.\nMulti-Node, Single-GPU\nï\nBeyond memory allocation, remote peer access does not have EGM-specific\nmodification and it follows CUDA inter process (IPC) protocol. See\nCUDA Programming Guide\nfor more details in IPC.\nThe user should allocate memory using\ncuMemCreate\nand again the\nuser has to explicitly provide\nCU_MEM_LOCATION_TYPE_HOST_NUMA\nas\nthe location type and\nnumaID\nas the location identifier. In\naddition\nCU_MEM_HANDLE_TYPE_FABRIC\nshould be defined as the\nrequested handle type. The following code snippet shows allocating\nphysical memory onÂ Node A:\nCUmemAllocationProp\nprop\n{};\nprop\n.\ntype\n=\nCU_MEM_ALLOCATION_TYPE_PINNED\n;\nprop\n.\nrequestedHandleTypes\n=\nCU_MEM_HANDLE_TYPE_FABRIC\n;\nprop\n.\nlocation\n.\ntype\n=\nCU_MEM_LOCATION_TYPE_HOST_NUMA\n;\nprop\n.\nlocation\n.\nid\n=\nnumaId\n;\nsize_t\ngranularity\n=\n0\n;\ncuMemGetAllocationGranularity\n(\n&\ngranularity\n,\n&\nprop\n,\nMEM_ALLOC_GRANULARITY_MINIMUM\n);\nsize_t\npadded_size\n=\nROUND_UP\n(\nsize\n,\ngranularity\n);\nsize_t\npage_size\n=\n...;\nassert\n(\npadded_size\n%\npage_size\n==\n0\n);\nCUmemGenericAllocationHandle\nallocHandle\n;\ncuMemCreate\n(\n&\nallocHandle\n,\npadded_size\n,\n&\nprop\n,\n0\n);\nAfter creating allocation handle using\ncuMemCreate\nthe user can\nexport that handle to the other node, Node B, calling\ncuMemExportToShareableHandle\n:\ncuMemExportToShareableHandle\n(\n&\nfabricHandle\n,\nallocHandle\n,\nCU_MEM_HANDLE_TYPE_FABRIC\n,\n0\n);\n// At this point, fabricHandle should be sent to Node B via TCP/IP.\nOn Node B, the handle can be imported using\ncuMemImportFromShareableHandle\nand treated as any other fabric\nhandle\n// At this point, fabricHandle should be received from Node A via TCP/IP.\nCUmemGenericAllocationHandle\nallocHandle\n;\ncuMemImportFromShareableHandle\n(\n&\nallocHandle\n,\n&\nfabricHandle\n,\nCU_MEM_HANDLE_TYPE_FABRIC\n);\nWhen handle is imported at Node B, then the user can reserve an address\nspace and map it locally in a regular fashion:\nsize_t\ngranularity\n=\n0\n;\ncuMemGetAllocationGranularity\n(\n&\ngranularity\n,\n&\nprop\n,\nMEM_ALLOC_GRANULARITY_MINIMUM\n);\nsize_t\npadded_size\n=\nROUND_UP\n(\nsize\n,\ngranularity\n);\nsize_t\npage_size\n=\n...;\nassert\n(\npadded_size\n%\npage_size\n==\n0\n);\nCUdeviceptr\ndptr\n;\ncuMemAddressReserve\n(\n&\ndptr\n,\npadded_size\n,\n0\n,\n0\n,\n0\n);\ncuMemMap\n(\ndptr\n,\npadded_size\n,\n0\n,\nallocHandle\n,\n0\n);\nAs the final step, the user should give appropriate accesses to each of\nthe local GPUs at Node B. An example code snippet that gives read and\nwrite access to eight local GPUs:\n// Give all 8 local Â GPUS access to exported EGM memory located on Node A.                                                               |\nCUmemAccessDesc\naccessDesc\n[\n8\n];\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n8\n;\ni\n++\n)\n{\naccessDesc\n[\ni\n].\nlocation\n.\ntype\n=\nCU_MEM_LOCATION_TYPE_DEVICE\n;\naccessDesc\n[\ni\n].\nlocation\n.\nid\n=\ni\n;\naccessDesc\n[\ni\n].\nflags\n=\nCU_MEM_ACCESS_FLAGS_PROT_READWRITE\n;\n}\ncuMemSetAccess\n(\ndptr\n,\nsize\n,\naccessDesc\n,\n8\n);\n27.\nNotices\nï\n27.1.\nNotice\nï\nThis document is provided for information purposes only and shall not be regarded as a warranty of a certain functionality, condition, or quality of a product. NVIDIA Corporation (âNVIDIAâ) makes no representations or warranties, expressed or implied, as to the accuracy or completeness of the information contained in this document and assumes no responsibility for any errors contained herein. NVIDIA shall have no liability for the consequences or use of such information or for any infringement of patents or other rights of third parties that may result from its use. This document is not a commitment to develop, release, or deliver any Material (defined below), code, or functionality.\nNVIDIA reserves the right to make corrections, modifications, enhancements, improvements, and any other changes to this document, at any time without notice.\nCustomer should obtain the latest relevant information before placing orders and should verify that such information is current and complete.\nNVIDIA products are sold subject to the NVIDIA standard terms and conditions of sale supplied at the time of order acknowledgement, unless otherwise agreed in an individual sales agreement signed by authorized representatives of NVIDIA and customer (âTerms of Saleâ). NVIDIA hereby expressly objects to applying any customer general terms and conditions with regards to the purchase of the NVIDIA product referenced in this document. No contractual obligations are formed either directly or indirectly by this document.\nNVIDIA products are not designed, authorized, or warranted to be suitable for use in medical, military, aircraft, space, or life support equipment, nor in applications where failure or malfunction of the NVIDIA product can reasonably be expected to result in personal injury, death, or property or environmental damage. NVIDIA accepts no liability for inclusion and/or use of NVIDIA products in such equipment or applications and therefore such inclusion and/or use is at customerâs own risk.\nNVIDIA makes no representation or warranty that products based on this document will be suitable for any specified use. Testing of all parameters of each product is not necessarily performed by NVIDIA. It is customerâs sole responsibility to evaluate and determine the applicability of any information contained in this document, ensure the product is suitable and fit for the application planned by customer, and perform the necessary testing for the application in order to avoid a default of the application or the product. Weaknesses in customerâs product designs may affect the quality and reliability of the NVIDIA product and may result in additional or different conditions and/or requirements beyond those contained in this document. NVIDIA accepts no liability related to any default, damage, costs, or problem which may be based on or attributable to: (i) the use of the NVIDIA product in any manner that is contrary to this document or (ii) customer product designs.\nNo license, either expressed or implied, is granted under any NVIDIA patent right, copyright, or other NVIDIA intellectual property right under this document. Information published by NVIDIA regarding third-party products or services does not constitute a license from NVIDIA to use such products or services or a warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual property rights of the third party, or a license from NVIDIA under the patents or other intellectual property rights of NVIDIA.\nReproduction of information in this document is permissible only if approved in advance by NVIDIA in writing, reproduced without alteration and in full compliance with all applicable export laws and regulations, and accompanied by all associated conditions, limitations, and notices.\nTHIS DOCUMENT AND ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, âMATERIALSâ) ARE BEING PROVIDED âAS IS.â NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL NVIDIA BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Notwithstanding any damages that customer might incur for any reason whatsoever, NVIDIAâs aggregate and cumulative liability towards customer for the products described herein shall be limited in accordance with the Terms of Sale for the product.\n27.2.\nOpenCL\nï\nOpenCL is a trademark of Apple Inc. used under license to the Khronos Group Inc.\n27.3.\nTrademarks\nï\nNVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated.", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html"}}
{"text": "CUDA C++ Best Practices Guide — CUDA C++ Best Practices Guide 13.0 documentation\n»\nCUDA C++ Best Practices Guide\nv13.0 |\nPDF\n|\nArchive\nCUDA C++ Best Practices Guide\n1.\nOverview\n\nThe CUDA C++ Best Practices Guide provides practical guidelines for writing high-performance CUDA applications. It covers optimization strategies across memory usage, parallel execution, and instruction-level efficiency. The guide helps developers identify performance bottlenecks, leverage GPU architecture effectively, and apply profiling tools to fine-tune applications. It’s an essential resource for maximizing throughput and achieving scalable, efficient CUDA programs.\n2.\nPreface\n\nThis Best Practices Guide is a manual to help developers obtain the best performance from NVIDIA\n®\nCUDA\n®\nGPUs. It presents established parallelization and optimization techniques and explains coding metaphors and idioms that can greatly simplify programming for CUDA-capable GPU architectures.\nWhile the contents can be used as a reference manual, you should be aware that some topics are revisited in different contexts as various programming and configuration topics are explored. As a result, it is recommended that first-time readers proceed through the guide sequentially. This approach will greatly improve your understanding of effective programming practices and enable you to better use the guide for reference later.\n2.1.\nWho Should Read This Guide?\n\nThe discussions in this guide all use the C++ programming language, so you should be comfortable reading C++ code.\nThis guide refers to and relies on several other documents that you should have at your disposal for reference, all of which are available at no cost from the CUDA website\nhttps://docs.nvidia.com/cuda/\n. The following documents are especially important resources:\nCUDA Installation Guide\nCUDA C++ Programming Guide\nCUDA Toolkit Reference Manual\nIn particular, the optimization section of this guide assumes that you have already successfully downloaded and installed the CUDA Toolkit (if not, please refer to the relevant CUDA Installation Guide for your platform) and that you have a basic familiarity with the CUDA C++ programming language and environment (if not, please refer to the CUDA C++ Programming Guide).\n2.2.\nAssess, Parallelize, Optimize, Deploy\n\nThis guide introduces the\nAssess, Parallelize, Optimize, Deploy(APOD)\ndesign cycle for applications with the goal of helping application developers to rapidly identify the portions of their code that would most readily benefit from GPU acceleration, rapidly realize that benefit, and begin leveraging the resulting speedups in production as early as possible.\nAPOD is a cyclical process: initial speedups can be achieved, tested, and deployed with only minimal initial investment of time, at which point the cycle can begin again by identifying further optimization opportunities, seeing additional speedups, and then deploying the even faster versions of the application into production.\n2.2.1.\nAssess\n\nFor an existing project, the first step is to assess the application to locate the parts of the code that are responsible for the bulk of the execution time. Armed with this knowledge, the developer can evaluate these bottlenecks for parallelization and start to investigate GPU acceleration.\nBy understanding the end-user’s requirements and constraints and by applying Amdahl’s and Gustafson’s laws, the developer can determine the upper bound of performance improvement from acceleration of the identified portions of the application.\n2.2.2.\nParallelize\n\nHaving identified the hotspots and having done the basic exercises to set goals and expectations, the developer needs to parallelize the code. Depending on the original code, this can be as simple as calling into an existing GPU-optimized library such as\ncuBLAS\n,\ncuFFT\n, or\nThrust\n, or it could be as simple as adding a few preprocessor directives as hints to a parallelizing compiler.\nOn the other hand, some applications’ designs will require some amount of refactoring to expose their inherent parallelism. As even CPU architectures will require exposing parallelism in order to improve or simply maintain the performance of sequential applications, the CUDA family of parallel programming languages (CUDA C++, CUDA Fortran, etc.) aims to make the expression of this parallelism as simple as possible, while simultaneously enabling operation on CUDA-capable GPUs designed for maximum parallel throughput.\n2.2.3.\nOptimize\n\nAfter each round of application parallelization is complete, the developer can move to optimizing the implementation to improve performance. Since there are many possible optimizations that can be considered, having a good understanding of the needs of the application can help to make the process as smooth as possible. However, as with APOD as a whole, program optimization is an iterative process (identify an opportunity for optimization, apply and test the optimization, verify the speedup achieved, and repeat), meaning that it is not necessary for a programmer to spend large amounts of time memorizing the bulk of all possible optimization strategies prior to seeing good speedups. Instead, strategies can be applied incrementally as they are learned.\nOptimizations can be applied at various levels, from overlapping data transfers with computation all the way down to fine-tuning floating-point operation sequences. The available profiling tools are invaluable for guiding this process, as they can help suggest a next-best course of action for the developer’s optimization efforts and provide references into the relevant portions of the optimization section of this guide.\n2.2.4.\nDeploy\n\nHaving completed the GPU acceleration of one or more components of the application it is possible to compare the outcome with the original expectation. Recall that the initial\nassess\nstep allowed the developer to determine an upper bound for the potential speedup attainable by accelerating given hotspots.\nBefore tackling other hotspots to improve the total speedup, the developer should consider taking the partially parallelized implementation and carry it through to production. This is important for a number of reasons; for example, it allows the user to profit from their investment as early as possible (the speedup may be partial but is still valuable), and it minimizes risk for the developer and the user by providing an evolutionary rather than revolutionary set of changes to the application.\n2.3.\nRecommendations and Best Practices\n\nThroughout this guide, specific recommendations are made regarding the design and implementation of CUDA C++ code. These recommendations are categorized by priority, which is a blend of the effect of the recommendation and its scope. Actions that present substantial improvements for most CUDA applications have the highest priority, while small optimizations that affect only very specific situations are given a lower priority.\nBefore implementing lower priority recommendations, it is good practice to make sure all higher priority recommendations that are relevant have already been applied. This approach will tend to provide the best results for the time invested and will avoid the trap of premature optimization.\nThe criteria of benefit and scope for establishing priority will vary depending on the nature of the program. In this guide, they represent a typical case. Your code might reflect different priority factors. Regardless of this possibility, it is good practice to verify that no higher-priority recommendations have been overlooked before undertaking lower-priority items.\nNote\nCode samples throughout the guide omit error checking for conciseness. Production code should, however, systematically check the error code returned by each API call and check for failures in kernel launches by calling\ncudaGetLastError()\n.\n2.4.\nAssessing Your Application\n\nFrom supercomputers to mobile phones, modern processors increasingly rely on parallelism to provide performance. The core computational unit, which includes control, arithmetic, registers and typically some cache, is replicated some number of times and connected to memory via a network. As a result, all modern processors require parallel code in order to achieve good utilization of their computational power.\nWhile processors are evolving to expose more fine-grained parallelism to the programmer, many existing applications have evolved either as serial codes or as coarse-grained parallel codes (for example, where the data is decomposed into regions processed in parallel, with sub-regions shared using MPI). In order to profit from any modern processor architecture, GPUs included, the first steps are to assess the application to identify the hotspots, determine whether they can be parallelized, and understand the relevant workloads both now and in the future.\n3.\nHeterogeneous Computing\n\nCUDA programming involves running code on two different platforms concurrently: a\nhost\nsystem with one or more CPUs and one or more CUDA-enabled NVIDIA GPU\ndevices\n.\nWhile NVIDIA GPUs are frequently associated with graphics, they are also powerful arithmetic engines capable of running thousands of lightweight threads in parallel. This capability makes them well suited to computations that can leverage parallel execution.\nHowever, the device is based on a distinctly different design from the host system, and it’s important to understand those differences and how they determine the performance of CUDA applications in order to use CUDA effectively.\n3.1.\nDifferences between Host and Device\n\nThe primary differences are in threading model and in separate physical memories:\nThreading resources\nExecution pipelines on host systems can support a limited number of concurrent threads. For example, servers that have two 32 core processors can run only 64 threads concurrently (or small multiple of that if the CPUs support simultaneous multithreading). By comparison, the\nsmallest\nexecutable unit of parallelism on a CUDA device comprises 32 threads (termed a\nwarp\nof threads). Modern NVIDIA GPUs can support up to 2048 active threads concurrently per multiprocessor (see Features and Specifications of the CUDA C++ Programming Guide) On GPUs with 80 multiprocessors, this leads to more than 160,000 concurrently active threads.\nThreads\nThreads on a CPU are generally heavyweight entities. The operating system must swap threads on and off CPU execution channels to provide multithreading capability. Context switches (when two threads are swapped) are therefore slow and expensive. By comparison, threads on GPUs are extremely lightweight. In a typical system, thousands of threads are queued up for work (in warps of 32 threads each). If the GPU must wait on one warp of threads, it simply begins executing work on another. Because separate registers are allocated to all active threads, no swapping of registers or other state need occur when switching among GPU threads. Resources stay allocated to each thread until it completes its execution. In short, CPU cores are designed to\nminimize latency\nfor a small number of threads at a time each, whereas GPUs are designed to handle a large number of concurrent, lightweight threads in order to\nmaximize throughput\n.\nRAM\nThe host system and the device each have their own distinct attached physical memories\n1\n. As the host and device memories are separated, items in the host memory must occasionally be communicated between device memory and host memory as described in\nWhat Runs on a CUDA-Enabled Device?\n.\nThese are the primary hardware differences between CPU hosts and GPU devices with respect to parallel programming. Other differences are discussed as they arise elsewhere in this document. Applications composed with these differences in mind can treat the host and device together as a cohesive heterogeneous system wherein each processing unit is leveraged to do the kind of work it does best: sequential work on the host and parallel work on the device.\n3.2.\nWhat Runs on a CUDA-Enabled Device?\n\nThe following issues should be considered when determining what parts of an application to run on the device:\nThe device is ideally suited for computations that can be run on numerous data elements simultaneously in parallel. This typically involves arithmetic on large data sets (such as matrices) where the same operation can be performed across thousands, if not millions, of elements at the same time. This is a requirement for good performance on CUDA: the software must use a large number (generally thousands or tens of thousands) of concurrent threads. The support for running numerous threads in parallel derives from CUDA’s use of a lightweight threading model described above.\nTo use CUDA, data values must be transferred from the host to the device. These transfers are costly in terms of performance and should be minimized. (See\nData Transfer Between Host and Device\n.) This cost has several ramifications:\nThe complexity of operations should justify the cost of moving data to and from the device. Code that transfers data for brief use by a small number of threads will see little or no performance benefit. The ideal scenario is one in which many threads perform a substantial amount of work.\nFor example, transferring two matrices to the device to perform a matrix addition and then transferring the results back to the host will not realize much performance benefit. The issue here is the number of operations performed per data element transferred. For the preceding procedure, assuming matrices of size NxN, there are N\n2\noperations (additions) and 3N\n2\nelements transferred, so the ratio of operations to elements transferred is 1:3 or O(1). Performance benefits can be more readily achieved when this ratio is higher. For example, a matrix multiplication of the same matrices requires N\n3\noperations (multiply-add), so the ratio of operations to elements transferred is O(N), in which case the larger the matrix the greater the performance benefit. The types of operations are an additional factor, as additions have different complexity profiles than, for example, trigonometric functions. It is important to include the overhead of transferring data to and from the device in determining whether operations should be performed on the host or on the device.\nData should be kept on the device as long as possible. Because transfers should be minimized, programs that run multiple kernels on the same data should favor leaving the data on the device between kernel calls, rather than transferring intermediate results to the host and then sending them back to the device for subsequent calculations. So, in the previous example, had the two matrices to be added already been on the device as a result of some previous calculation, or if the results of the addition would be used in some subsequent calculation, the matrix addition should be performed locally on the device. This approach should be used even if one of the steps in a sequence of calculations could be performed faster on the host. Even a relatively slow kernel may be advantageous if it avoids one or more transfers between host and device memory.\nData Transfer Between Host and Device\nprovides further details, including the measurements of bandwidth between the host and the device versus within the device proper.\nFor best performance, there should be some coherence in memory access by adjacent threads running on the device. Certain memory access patterns enable the hardware to coalesce groups of reads or writes of multiple data items into one operation. Data that cannot be laid out so as to enable\ncoalescing\n, or that doesn’t have enough locality to use the L1 or texture caches effectively, will tend to see lesser speedups when used in computations on GPUs. A noteworthy exception to this are completely random memory access patterns. In general, they should be avoided, because compared to peak capabilities any architecture processes these memory access patterns at a low efficiency. However, compared to cache based architectures, like CPUs, latency hiding architectures, like GPUs, tend to cope better with completely random memory access patterns.\n1\nOn Systems on a Chip with integrated GPUs, such as NVIDIA® Tegra®, host and device memory are physically the same, but there is still a logical distinction between host and device memory. See the\nApplication Note on CUDA for Tegra\nfor details.\n4.\nApplication Profiling\n\n4.1.\nProfile\n\nMany codes accomplish a significant portion of the work with a relatively small amount of code. Using a profiler, the developer can identify such hotspots and start to compile a list of candidates for parallelization.\n4.1.1.\nCreating the Profile\n\nThere are many possible approaches to profiling the code, but in all cases the objective is the same: to identify the function or functions in which the application is spending most of its execution time.\nNote\nHigh Priority:\nTo maximize developer productivity, profile the application to determine hotspots and bottlenecks.\nThe most important consideration with any profiling activity is to ensure that the workload is realistic - i.e., that information gained from the test and decisions based upon that information are relevant to real data. Using unrealistic workloads can lead to sub-optimal results and wasted effort both by causing developers to optimize for unrealistic problem sizes and by causing developers to concentrate on the wrong functions.\nThere are a number of tools that can be used to generate the profile. The following example is based on\ngprof\n, which is an open-source profiler for Linux platforms from the GNU Binutils collection.\n$ gcc -O2 -g -pg myprog.c\n$ gprof ./a.out > profile.txt\nEach sample counts as 0.01 seconds.\n%   cumulative   self              self     total\ntime   seconds   seconds    calls  ms/call  ms/call  name\n33.34      0.02     0.02     7208     0.00     0.00  genTimeStep\n16.67      0.03     0.01      240     0.04     0.12  calcStats\n16.67      0.04     0.01        8     1.25     1.25  calcSummaryData\n16.67      0.05     0.01        7     1.43     1.43  write\n16.67      0.06     0.01                             mcount\n0.00      0.06     0.00      236     0.00     0.00  tzset\n0.00      0.06     0.00      192     0.00     0.00  tolower\n0.00      0.06     0.00       47     0.00     0.00  strlen\n0.00      0.06     0.00       45     0.00     0.00  strchr\n0.00      0.06     0.00        1     0.00    50.00  main\n0.00      0.06     0.00        1     0.00     0.00  memcpy\n0.00      0.06     0.00        1     0.00    10.11  print\n0.00      0.06     0.00        1     0.00     0.00  profil\n0.00      0.06     0.00        1     0.00    50.00  report\n4.1.2.\nIdentifying Hotspots\n\nIn the example above, we can clearly see that the function\ngenTimeStep()\ntakes one-third of the total running time of the application. This should be our first candidate function for parallelization.\nUnderstanding Scaling\ndiscusses the potential benefit we might expect from such parallelization.\nIt is worth noting that several of the other functions in the above example also take up a significant portion of the overall running time, such as\ncalcStats()\nand\ncalcSummaryData()\n. Parallelizing these functions as well should increase our speedup potential. However, since APOD is a cyclical process, we might opt to parallelize these functions in a subsequent APOD pass, thereby limiting the scope of our work in any given pass to a smaller set of incremental changes.\n4.1.3.\nUnderstanding Scaling\n\nThe amount of performance benefit an application will realize by running on CUDA depends entirely on the extent to which it can be parallelized. Code that cannot be sufficiently parallelized should run on the host, unless doing so would result in excessive transfers between the host and the device.\nNote\nHigh Priority:\nTo get the maximum benefit from CUDA, focus first on finding ways to parallelize sequential code.\nBy understanding how applications can scale it is possible to set expectations and plan an incremental parallelization strategy.\nStrong Scaling and Amdahl’s Law\ndescribes strong scaling, which allows us to set an upper bound for the speedup with a fixed problem size.\nWeak Scaling and Gustafson’s Law\ndescribes weak scaling, where the speedup is attained by growing the problem size. In many applications, a combination of strong and weak scaling is desirable.\n4.1.3.1.\nStrong Scaling and Amdahl’s Law\n\nStrong scaling is a measure of how, for a fixed overall problem size, the time to solution decreases as more processors are added to a system. An application that exhibits linear strong scaling has a speedup equal to the number of processors used.\nStrong scaling is usually equated with Amdahl’s Law, which specifies the maximum speedup that can be expected by parallelizing portions of a serial program. Essentially, it states that the maximum speedup\nS\nof a program is:\n\\(S = \\frac{1}{(1 - P) + \\frac{P}{N}}\\)\nHere\nP\nis the fraction of the total serial execution time taken by the portion of code that can be parallelized and\nN\nis the number of processors over which the parallel portion of the code runs.\nThe larger\nN\nis(that is, the greater the number of processors), the smaller the\nP/N\nfraction. It can be simpler to view\nN\nas a very large number, which essentially transforms the equation into\n\\(S = 1/(1 - P)\\)\n. Now, if 3/4 of the running time of a sequential program is parallelized, the maximum speedup over serial code is 1 / (1 - 3/4) = 4.\nIn reality, most applications do not exhibit perfectly linear strong scaling, even if they do exhibit some degree of strong scaling. For most purposes, the key point is that the larger the parallelizable portion\nP\nis, the greater the potential speedup. Conversely, if\nP\nis a small number (meaning that the application is not substantially parallelizable), increasing the number of processors\nN\ndoes little to improve performance. Therefore, to get the largest speedup for a fixed problem size, it is worthwhile to spend effort on increasing\nP\n, maximizing the amount of code that can be parallelized.\n4.1.3.2.\nWeak Scaling and Gustafson’s Law\n\nWeak scaling is a measure of how the time to solution changes as more processors are added to a system with a fixed problem size\nper processor\n; i.e., where the overall problem size increases as the number of processors is increased.\nWeak scaling is often equated with Gustafson’s Law, which states that in practice, the problem size scales with the number of processors. Because of this, the maximum speedup\nS\nof a program is:\n\\(S = N + (1 - P)(1 - N)\\)\nHere\nP\nis the fraction of the total serial execution time taken by the portion of code that can be parallelized and\nN\nis the number of processors over which the parallel portion of the code runs.\nAnother way of looking at Gustafson’s Law is that it is not the problem size that remains constant as we scale up the system but rather the execution time. Note that Gustafson’s Law assumes that the ratio of serial to parallel execution remains constant, reflecting additional cost in setting up and handling the larger problem.\n4.1.3.3.\nApplying Strong and Weak Scaling\n\nUnderstanding which type of scaling is most applicable to an application is an important part of estimating speedup. For some applications the problem size will remain constant and hence only strong scaling is applicable. An example would be modeling how two molecules interact with each other, where the molecule sizes are fixed.\nFor other applications, the problem size will grow to fill the available processors. Examples include modeling fluids or structures as meshes or grids and some Monte Carlo simulations, where increasing the problem size provides increased accuracy.\nHaving understood the application profile, the developer should understand how the problem size would change if the computational performance changes and then apply either Amdahl’s or Gustafson’s Law to determine an upper bound for the speedup.\n5.\nParallelizing Your Application\n\nHaving identified the hotspots and having done the basic exercises to set goals and expectations, the developer needs to parallelize the code. Depending on the original code, this can be as simple as calling into an existing GPU-optimized library such as\ncuBLAS\n,\ncuFFT\n, or\nThrust\n, or it could be as simple as adding a few preprocessor directives as hints to a parallelizing compiler.\nOn the other hand, some applications’ designs will require some amount of refactoring to expose their inherent parallelism. As even CPU architectures require exposing this parallelism in order to improve or simply maintain the performance of sequential applications, the CUDA family of parallel programming languages (CUDA C++, CUDA Fortran, etc.) aims to make the expression of this parallelism as simple as possible, while simultaneously enabling operation on CUDA-capable GPUs designed for maximum parallel throughput.\n6.\nGetting Started\n\nThere are several key strategies for parallelizing sequential code. While the details of how to apply these strategies to a particular application is a complex and problem-specific topic, the general themes listed here apply regardless of whether we are parallelizing code to run on for multicore CPUs or for use on CUDA GPUs.\n6.1.\nParallel Libraries\n\nThe most straightforward approach to parallelizing an application is to leverage existing libraries that take advantage of parallel architectures on our behalf. The CUDA Toolkit includes a number of such libraries that have been fine-tuned for NVIDIA CUDA GPUs, such as\ncuBLAS\n,\ncuFFT\n, and so on.\nThe key here is that libraries are most useful when they match well with the needs of the application. Applications already using other BLAS libraries can often quite easily switch to\ncuBLAS\n, for example, whereas applications that do little to no linear algebra will have little use for\ncuBLAS\n. The same goes for other CUDA Toolkit libraries:\ncuFFT\nhas an interface similar to that of\nFFTW\n, etc.\nAlso of note is the Thrust library, which is a parallel C++ template library similar to the C++ Standard Template Library. Thrust provides a rich collection of data parallel primitives such as scan, sort, and reduce, which can be composed together to implement complex algorithms with concise, readable source code. By describing your computation in terms of these high-level abstractions you provide Thrust with the freedom to select the most efficient implementation automatically. As a result, Thrust can be utilized in rapid prototyping of CUDA applications, where programmer productivity matters most, as well as in production, where robustness and absolute performance are crucial.\n6.2.\nParallelizing Compilers\n\nAnother common approach to parallelization of sequential codes is to make use of parallelizing compilers. Often this means the use of directives-based approaches, where the programmer uses a pragma or other similar notation to provide hints to the compiler about where parallelism can be found without needing to modify or adapt the underlying code itself. By exposing parallelism to the compiler, directives allow the compiler to do the detailed work of mapping the computation onto the parallel architecture.\nThe OpenACC standard provides a set of compiler directives to specify loops and regions of code in standard C, C++ and Fortran that should be offloaded from a host CPU to an attached accelerator such as a CUDA GPU. The details of managing the accelerator device are handled implicitly by an OpenACC-enabled compiler and runtime.\nSee\nhttp://www.openacc.org/\nfor details.\n6.3.\nCoding to Expose Parallelism\n\nFor applications that need additional functionality or performance beyond what existing parallel libraries or parallelizing compilers can provide, parallel programming languages such as CUDA C++ that integrate seamlessly with existing sequential code are essential.\nOnce we have located a hotspot in our application’s profile assessment and determined that custom code is the best approach, we can use CUDA C++ to expose the parallelism in that portion of our code as a CUDA kernel. We can then launch this kernel onto the GPU and retrieve the results without requiring major rewrites to the rest of our application.\nThis approach is most straightforward when the majority of the total running time of our application is spent in a few relatively isolated portions of the code. More difficult to parallelize are applications with a very flat profile - i.e., applications where the time spent is spread out relatively evenly across a wide portion of the code base. For the latter variety of application, some degree of code refactoring to expose the inherent parallelism in the application might be necessary, but keep in mind that this refactoring work will tend to benefit all future architectures, CPU and GPU alike, so it is well worth the effort should it become necessary.\n7.\nGetting the Right Answer\n\nObtaining the right answer is clearly the principal goal of all computation. On parallel systems, it is possible to run into difficulties not typically found in traditional serial-oriented programming. These include threading issues, unexpected values due to the way floating-point values are computed, and challenges arising from differences in the way CPU and GPU processors operate. This chapter examines issues that can affect the correctness of returned data and points to appropriate solutions.\n7.1.\nVerification\n\n7.1.1.\nReference Comparison\n\nA key aspect of correctness verification for modifications to any existing program is to establish some mechanism whereby previous known-good reference outputs from representative inputs can be compared to new results. After each change is made, ensure that the results match using whatever criteria apply to the particular algorithm. Some will expect bitwise identical results, which is not always possible, especially where floating-point arithmetic is concerned; see\nNumerical Accuracy and Precision\nregarding numerical accuracy. For other algorithms, implementations may be considered correct if they match the reference within some small epsilon.\nNote that the process used for validating numerical results can easily be extended to validate performance results as well. We want to ensure that each change we make is correct\nand\nthat it improves performance (and by how much). Checking these things frequently as an integral part of our cyclical APOD process will help ensure that we achieve the desired results as rapidly as possible.\n7.1.2.\nUnit Testing\n\nA useful counterpart to the reference comparisons described above is to structure the code itself in such a way that is readily verifiable at the unit level. For example, we can write our CUDA kernels as a collection of many short\n__device__\nfunctions rather than one large monolithic\n__global__\nfunction; each device function can be tested independently before hooking them all together.\nFor example, many kernels have complex addressing logic for accessing memory in addition to their actual computation. If we validate our addressing logic separately prior to introducing the bulk of the computation, then this will simplify any later debugging efforts. (Note that the CUDA compiler considers any device code that does not contribute to a write to global memory as dead code subject to elimination, so we must at least write\nsomething\nout to global memory as a result of our addressing logic in order to successfully apply this strategy.)\nGoing a step further, if most functions are defined as\n__host__\n__device__\nrather than just\n__device__\nfunctions, then these functions can be tested on both the CPU and the GPU, thereby increasing our confidence that the function is correct and that there will not be any unexpected differences in the results. If there\nare\ndifferences, then those differences will be seen early and can be understood in the context of a simple function.\nAs a useful side effect, this strategy will allow us a means to reduce code duplication should we wish to include both CPU and GPU execution paths in our application: if the bulk of the work of our CUDA kernels is done in\n__host__\n__device__\nfunctions, we can easily call those functions from both the host code\nand\nthe device code without duplication.\n7.2.\nDebugging\n\nCUDA-GDB is a port of the GNU Debugger that runs on Linux and Mac; see:\nhttps://developer.nvidia.com/cuda-gdb\n.\nThe NVIDIA Nsight Visual Studio Edition is available as a free plugin for Microsoft Visual Studio; see:\nhttps://developer.nvidia.com/nsight-visual-studio-edition\n.\nSeveral third-party debuggers support CUDA debugging as well; see:\nhttps://developer.nvidia.com/debugging-solutions\nfor more details.\n7.3.\nNumerical Accuracy and Precision\n\nIncorrect or unexpected results arise principally from issues of floating-point accuracy due to the way floating-point values are computed and stored. The following sections explain the principal items of interest. Other peculiarities of floating-point arithmetic are presented in Features and Technical Specifications of the CUDA C++ Programming Guide as well as in a whitepaper and accompanying webinar on floating-point precision and performance available from\nhttps://developer.nvidia.com/content/precision-performance-floating-point-and-ieee-754-compliance-nvidia-gpus\n.\n7.3.1.\nSingle vs. Double Precision\n\nDevices of\nCUDA Compute Capability\n1.3 and higher provide native support for double-precision floating-point values (that is, values 64 bits wide). Results obtained using double-precision arithmetic will frequently differ from the same operation performed via single-precision arithmetic due to the greater precision of the former and due to rounding issues. Therefore, it is important to be sure to compare values of like precision and to express the results within a certain tolerance rather than expecting them to be exact.\n7.3.2.\nFloating Point Math Is Not Associative\n\nEach floating-point arithmetic operation involves a certain amount of rounding. Consequently, the order in which arithmetic operations are performed is important. If A, B, and C are floating-point values, (A+B)+C is not guaranteed to equal A+(B+C) as it is in symbolic math. When you parallelize computations, you potentially change the order of operations and therefore the parallel results might not match sequential results. This limitation is not specific to CUDA, but an inherent part of parallel computation on floating-point values.\n7.3.3.\nIEEE 754 Compliance\n\nAll CUDA compute devices follow the IEEE 754 standard for binary floating-point representation, with some small exceptions. These exceptions, which are detailed in Features and Technical Specifications of the CUDA C++ Programming Guide, can lead to results that differ from IEEE 754 values computed on the host system.\nOne of the key differences is the fused multiply-add (FMA) instruction, which combines multiply-add operations into a single instruction execution. Its result will often differ slightly from results obtained by doing the two operations separately.\n7.3.4.\nx86 80-bit Computations\n\nx86 processors can use an 80-bit\ndouble extended precision\nmath when performing floating-point calculations. The results of these calculations can frequently differ from pure 64-bit operations performed on the CUDA device. To get a closer match between values, set the x86 host processor to use regular double or single precision (64 bits and 32 bits, respectively). This is done with the\nFLDCW\nx86 assembly instruction or the equivalent operating system API.\n8.\nOptimizing CUDA Applications\n\nAfter each round of application parallelization is complete, the developer can move to optimizing the implementation to improve performance. Since there are many possible optimizations that can be considered, having a good understanding of the needs of the application can help to make the process as smooth as possible. However, as with APOD as a whole, program optimization is an iterative process (identify an opportunity for optimization, apply and test the optimization, verify the speedup achieved, and repeat), meaning that it is not necessary for a programmer to spend large amounts of time memorizing the bulk of all possible optimization strategies prior to seeing good speedups. Instead, strategies can be applied incrementally as they are learned.\nOptimizations can be applied at various levels, from overlapping data transfers with computation all the way down to fine-tuning floating-point operation sequences. The available profiling tools are invaluable for guiding this process, as they can help suggest a next-best course of action for the developer’s optimization efforts and provide references into the relevant portions of the optimization section of this guide.\n9.\nPerformance Metrics\n\nWhen attempting to optimize CUDA code, it pays to know how to measure performance accurately and to understand the role that bandwidth plays in performance measurement. This chapter discusses how to correctly measure performance using CPU timers and CUDA events. It then explores how bandwidth affects performance metrics and how to mitigate some of the challenges it poses.\n9.1.\nTiming\n\nCUDA calls and kernel executions can be timed using either CPU or GPU timers. This section examines the functionality, advantages, and pitfalls of both approaches.\n9.1.1.\nUsing CPU Timers\n\nAny CPU timer can be used to measure the elapsed time of a CUDA call or kernel execution. The details of various CPU timing approaches are outside the scope of this document, but developers should always be aware of the resolution their timing calls provide.\nWhen using CPU timers, it is critical to remember that many CUDA API functions are asynchronous; that is, they return control back to the calling CPU thread prior to completing their work. All kernel launches are asynchronous, as are memory-copy functions with the\nAsync\nsuffix on their names. Therefore, to accurately measure the elapsed time for a particular call or sequence of CUDA calls, it is necessary to synchronize the CPU thread with the GPU by calling\ncudaDeviceSynchronize()\nimmediately before starting and stopping the CPU timer.\ncudaDeviceSynchronize()\nblocks the calling CPU thread until all CUDA calls previously issued by the thread are completed.\nAlthough it is also possible to synchronize the CPU thread with a particular stream or event on the GPU, these synchronization functions are not suitable for timing code in streams other than the default stream.\ncudaStreamSynchronize()\nblocks the CPU thread until all CUDA calls previously issued into the given stream have completed.\ncudaEventSynchronize()\nblocks until a given event in a particular stream has been recorded by the GPU. Because the driver may interleave execution of CUDA calls from other non-default streams, calls in other streams may be included in the timing.\nBecause the default stream, stream 0, exhibits serializing behavior for work on the device (an operation in the default stream can begin only after all preceding calls in any stream have completed; and no subsequent operation in any stream can begin until it finishes), these functions can be used reliably for timing in the default stream.\nBe aware that CPU-to-GPU synchronization points such as those mentioned in this section imply a stall in the GPU’s processing pipeline and should thus be used sparingly to minimize their performance impact.\n9.1.2.\nUsing CUDA GPU Timers\n\nThe CUDA event API provides calls that create and destroy events, record events (including a timestamp), and convert timestamp differences into a floating-point value in milliseconds.\nHow to time code using CUDA events\nillustrates their use.\nHow to time code using CUDA events\ncudaEvent_t\nstart\n,\nstop\n;\nfloat\ntime\n;\ncudaEventCreate\n(\n&\nstart\n);\ncudaEventCreate\n(\n&\nstop\n);\ncudaEventRecord\n(\nstart\n,\n0\n);\nkernel\n<<<\ngrid\n,\nthreads\n>>>\n(\nd_odata\n,\nd_idata\n,\nsize_x\n,\nsize_y\n,\nNUM_REPS\n);\ncudaEventRecord\n(\nstop\n,\n0\n);\ncudaEventSynchronize\n(\nstop\n);\ncudaEventElapsedTime\n(\n&\ntime\n,\nstart\n,\nstop\n);\ncudaEventDestroy\n(\nstart\n);\ncudaEventDestroy\n(\nstop\n);\nHere\ncudaEventRecord()\nis used to place the\nstart\nand\nstop\nevents into the default stream, stream 0. The device will record a timestamp for the event when it reaches that event in the stream. The\ncudaEventElapsedTime()\nfunction returns the time elapsed between the recording of the\nstart\nand\nstop\nevents. This value is expressed in milliseconds and has a resolution of approximately half a microsecond. Like the other calls in this listing, their specific operation, parameters, and return values are described in the\nCUDA Toolkit Reference Manual\n. Note that the timings are measured on the GPU clock, so the timing resolution is operating-system-independent.\n9.2.\nBandwidth\n\nBandwidth - the rate at which data can be transferred - is one of the most important gating factors for performance. Almost all changes to code should be made in the context of how they affect bandwidth. As described in\nMemory Optimizations\nof this guide, bandwidth can be dramatically affected by the choice of memory in which data is stored, how the data is laid out and the order in which it is accessed, as well as other factors.\nTo measure performance accurately, it is useful to calculate theoretical and effective bandwidth. When the latter is much lower than the former, design or implementation details are likely to reduce bandwidth, and it should be the primary goal of subsequent optimization efforts to increase it.\nNote\nHigh Priority:\nUse the effective bandwidth of your computation as a metric when measuring performance and optimization benefits.\n9.2.1.\nTheoretical Bandwidth Calculation\n\nTheoretical bandwidth can be calculated using hardware specifications available in the product literature. For example, the NVIDIA Tesla V100 uses HBM2 (double data rate) RAM with a memory clock rate of 877 MHz and a 4096-bit-wide memory interface.\nUsing these data items, the peak theoretical memory bandwidth of the NVIDIA Tesla V100 is 898 GB/s:\n\\(\\left. \\left( 0.877 \\times 10^{9} \\right. \\times (4096/8) \\times 2 \\right) \\div 10^{9} = 898\\text{GB/s}\\)\nIn this calculation, the memory clock rate is converted in to Hz, multiplied by the interface width (divided by 8, to convert bits to bytes) and multiplied by 2 due to the double data rate. Finally, this product is divided by 10\n9\nto convert the result to GB/s.\nNote\nSome calculations use 1024\n3\ninstead of 10\n9\nfor the final calculation. In such a case, the bandwidth would be 836.4 GiB/s. It is important to use the same divisor when calculating theoretical and effective bandwidth so that the comparison is valid.\nNote\nOn GPUs with GDDR memory with ECC enabled the available DRAM is reduced by 6.25% to allow for the storage of ECC bits. Fetching ECC bits for each memory transaction also reduced the effective bandwidth by approximately 20% compared to the same GPU with ECC disabled, though the exact impact of ECC on bandwidth can be higher and depends on the memory access pattern. HBM2 memories, on the other hand, provide dedicated ECC resources, allowing overhead-free ECC protection.\n2\n9.2.2.\nEffective Bandwidth Calculation\n\nEffective bandwidth is calculated by timing specific program activities and by knowing how data is accessed by the program. To do so, use this equation:\n\\(\\text{Effective\\ bandwidth} = \\left( {\\left( B_{r} + B_{w} \\right) \\div 10^{9}} \\right) \\div \\text{time}\\)\nHere, the effective bandwidth is in units of GB/s, B\nr\nis the number of bytes read per kernel, B\nw\nis the number of bytes written per kernel, and time is given in seconds.\nFor example, to compute the effective bandwidth of a 2048 x 2048 matrix copy, the following formula could be used:\n\\(\\text{Effective\\ bandwidth} = \\left( {\\left( 2048^{2} \\times 4 \\times 2 \\right) \\div 10^{9}} \\right) \\div \\text{time}\\)\nThe number of elements is multiplied by the size of each element (4 bytes for a float), multiplied by 2 (because of the read\nand\nwrite), divided by 10\n9\n(or 1,024\n3\n) to obtain GB of memory transferred. This number is divided by the time in seconds to obtain GB/s.\n9.2.3.\nThroughput Reported by Visual Profiler\n\nFor devices with\ncompute capability\nof 2.0 or greater, the Visual Profiler can be used to collect several different memory throughput measures. The following throughput metrics can be displayed in the Details or Detail Graphs view:\nRequested Global Load Throughput\nRequested Global Store Throughput\nGlobal Load Throughput\nGlobal Store Throughput\nDRAM Read Throughput\nDRAM Write Throughput\nThe Requested Global Load Throughput and Requested Global Store Throughput values indicate the global memory throughput requested by the kernel and therefore correspond to the effective bandwidth obtained by the calculation shown under\nEffective Bandwidth Calculation\n.\nBecause the minimum memory transaction size is larger than most word sizes, the actual memory throughput required for a kernel can include the transfer of data not used by the kernel. For global memory accesses, this actual throughput is reported by the Global Load Throughput and Global Store Throughput values.\nIt’s important to note that both numbers are useful. The actual memory throughput shows how close the code is to the hardware limit, and a comparison of the effective or requested bandwidth to the actual bandwidth presents a good estimate of how much bandwidth is wasted by suboptimal coalescing of memory accesses (see\nCoalesced Access to Global Memory\n). For global memory accesses, this comparison of requested memory bandwidth to actual memory bandwidth is reported by the Global Memory Load Efficiency and Global Memory Store Efficiency metrics.\n2\nAs an exception, scattered writes to HBM2 see some overhead from ECC but much less than the overhead with similar access patterns on ECC-protected GDDR5 memory.\n10.\nMemory Optimizations\n\nMemory optimizations are the most important area for performance. The goal is to maximize the use of the hardware by maximizing bandwidth. Bandwidth is best served by using as much fast memory and as little slow-access memory as possible. This chapter discusses the various kinds of memory on the host and device and how best to set up data items to use the memory effectively.\n10.1.\nData Transfer Between Host and Device\n\nThe peak theoretical bandwidth between the device memory and the GPU is much higher (898 GB/s on the NVIDIA Tesla V100, for example) than the peak theoretical bandwidth between host memory and device memory (16 GB/s on the PCIe x16 Gen3). Hence, for best overall application performance, it is important to minimize data transfer between the host and the device, even if that means running kernels on the GPU that do not demonstrate any speedup compared with running them on the host CPU.\nNote\nHigh Priority:\nMinimize data transfer between the host and the device, even if it means running some kernels on the device that do not show performance gains when compared with running them on the host CPU.\nIntermediate data structures should be created in device memory, operated on by the device, and destroyed without ever being mapped by the host or copied to host memory.\nAlso, because of the overhead associated with each transfer, batching many small transfers into one larger transfer performs significantly better than making each transfer separately, even if doing so requires packing non-contiguous regions of memory into a contiguous buffer and then unpacking after the transfer.\nFinally, higher bandwidth between the host and the device is achieved when using\npage-locked\n(or\npinned\n) memory, as discussed in the CUDA C++ Programming Guide and the\nPinned Memory\nsection of this document.\n10.1.1.\nPinned Memory\n\nPage-locked or pinned memory transfers attain the highest bandwidth between the host and the device. On PCIe x16 Gen3 cards, for example, pinned memory can attain roughly 12 GB/s transfer rates.\nPinned memory is allocated using the\ncudaHostAlloc()\nfunctions in the Runtime API. The\nbandwidthTest\nCUDA Sample shows how to use these functions as well as how to measure memory transfer performance.\nFor regions of system memory that have already been pre-allocated,\ncudaHostRegister()\ncan be used to pin the memory on-the-fly without the need to allocate a separate buffer and copy the data into it.\nPinned memory should not be overused. Excessive use can reduce overall system performance because pinned memory is a scarce resource, but how much is too much is difficult to know in advance. Furthermore, the pinning of system memory is a heavyweight operation compared to most normal system memory allocations, so as with all optimizations, test the application and the systems it runs on for optimal performance parameters.\n10.1.2.\nAsynchronous and Overlapping Transfers with Computation\n\nData transfers between the host and the device using\ncudaMemcpy()\nare blocking transfers; that is, control is returned to the host thread only after the data transfer is complete. The\ncudaMemcpyAsync()\nfunction is a non-blocking variant of\ncudaMemcpy()\nin which control is returned immediately to the host thread. In contrast with\ncudaMemcpy()\n, the asynchronous transfer version\nrequires\npinned host memory (see\nPinned Memory\n), and it contains an additional argument, a stream ID. A\nstream\nis simply a sequence of operations that are performed in order on the device. Operations in different streams can be interleaved and in some cases overlapped - a property that can be used to hide data transfers between the host and the device.\nAsynchronous transfers enable overlap of data transfers with computation in two different ways. On all CUDA-enabled devices, it is possible to overlap host computation with asynchronous data transfers and with device computations. For example,\nAsynchronous and Overlapping Transfers with Computation\ndemonstrates how host computation in the routine\ncpuFunction()\nis performed while data is transferred to the device and a kernel using the device is executed.\nOverlapping computation and data transfers\ncudaMemcpyAsync\n(\na_d\n,\na_h\n,\nsize\n,\ncudaMemcpyHostToDevice\n,\n0\n);\nkernel\n<<<\ngrid\n,\nblock\n>>>\n(\na_d\n);\ncpuFunction\n();\nThe last argument to the\ncudaMemcpyAsync()\nfunction is the stream ID, which in this case uses the default stream, stream 0. The kernel also uses the default stream, and it will not begin execution until the memory copy completes; therefore, no explicit synchronization is needed. Because the memory copy and the kernel both return control to the host immediately, the host function\ncpuFunction()\noverlaps their execution.\nIn\nAsynchronous and Overlapping Transfers with Computation\n, the memory copy and kernel execution occur sequentially. On devices that are capable of concurrent copy and compute, it is possible to overlap kernel execution on the device with data transfers between the host and the device. Whether a device has this capability is indicated by the\nasyncEngineCount\nfield of the\ncudaDeviceProp\nstructure (or listed in the output of the\ndeviceQuery\nCUDA Sample). On devices that have this capability, the overlap once again requires pinned host memory, and, in addition, the data transfer and kernel must use different, non-default streams (streams with non-zero stream IDs). Non-default streams are required for this overlap because memory copy, memory set functions, and kernel calls that use the default stream begin only after all preceding calls on the device (in any stream) have completed, and no operation on the device (in any stream) commences until they are finished.\nAsynchronous and Overlapping Transfers with Computation\nillustrates the basic technique.\nConcurrent copy and execute\ncudaStreamCreate\n(\n&\nstream1\n);\ncudaStreamCreate\n(\n&\nstream2\n);\ncudaMemcpyAsync\n(\na_d\n,\na_h\n,\nsize\n,\ncudaMemcpyHostToDevice\n,\nstream1\n);\nkernel\n<<<\ngrid\n,\nblock\n,\n0\n,\nstream2\n>>>\n(\notherData_d\n);\nIn this code, two streams are created and used in the data transfer and kernel executions as specified in the last arguments of the\ncudaMemcpyAsync\ncall and the kernel’s execution configuration.\nAsynchronous and Overlapping Transfers with Computation\ndemonstrates how to overlap kernel execution with asynchronous data transfer. This technique could be used when the data dependency is such that the data can be broken into chunks and transferred in multiple stages, launching multiple kernels to operate on each chunk as it arrives.\nSequential copy and execute\nand\nStaged concurrent copy and execute\ndemonstrate this. They produce equivalent results. The first segment shows the reference sequential implementation, which transfers and operates on an array of\nN\nfloats (where\nN\nis assumed to be evenly divisible by nThreads).\nSequential copy and execute\ncudaMemcpy\n(\na_d\n,\na_h\n,\nN\n*\nsizeof\n(\nfloat\n),\ndir\n);\nkernel\n<<<\nN\n/\nnThreads\n,\nnThreads\n>>>\n(\na_d\n);\nStaged concurrent copy and execute\nshows how the transfer and kernel execution can be broken up into nStreams stages. This approach permits some overlapping of the data transfer and execution.\nStaged concurrent copy and execute\nsize\n=\nN\n*\nsizeof\n(\nfloat\n)\n/\nnStreams\n;\nfor\n(\ni\n=\n0\n;\ni\n<\nnStreams\n;\ni\n++\n)\n{\noffset\n=\ni\n*\nN\n/\nnStreams\n;\ncudaMemcpyAsync\n(\na_d\n+\noffset\n,\na_h\n+\noffset\n,\nsize\n,\ndir\n,\nstream\n[\ni\n]);\nkernel\n<<<\nN\n/\n(\nnThreads\n*\nnStreams\n),\nnThreads\n,\n0\n,\nstream\n[\ni\n]\n>>>\n(\na_d\n+\noffset\n);\n}\n(In\nStaged concurrent copy and execute\n, it is assumed that\nN\nis evenly divisible by\nnThreads*nStreams\n.) Because execution within\na stream occurs sequentially, none of the kernels will launch until the data transfers in their respective streams complete. Current GPUs can\nsimultaneously process asynchronous data transfers and execute kernels. GPUs with a single copy engine can perform one asynchronous data\ntransfer and execute kernels whereas GPUs with two copy engines can simultaneously perform one asynchronous data transfer from the host to\nthe device, one asynchronous data transfer from the device to the host, and execute kernels. The number of copy engines on a GPU is given\nby the\nasyncEngineCount\nfield of the\ncudaDeviceProp\nstructure, which is also listed in the output of the\ndeviceQuery\nCUDA\nSample. (It should be mentioned that it is not possible to overlap a blocking transfer with an asynchronous transfer, because the blocking\ntransfer occurs in the default stream, so it will not begin until all previous CUDA calls complete. It will not allow any other CUDA call\nto begin until it has completed.) A diagram depicting the timeline of execution for the two code segments is shown\nin\nFigure 1\n, and\nnStreams\nis equal to 4\nfor\nStaged concurrent copy and execute\nin the bottom half of the figure.\nFigure 1\nTimeline comparison for copy and kernel execution\n\nTop\nSequential\nBottom\nConcurrent\nFor this example, it is assumed that the data transfer and kernel execution times are comparable. In such cases, and when the execution time (\ntE\n) exceeds the transfer time (\ntT\n), a rough estimate for the overall time is\ntE + tT/nStreams\nfor the staged version versus\ntE + tT\nfor the sequential version. If the transfer time exceeds the execution time, a rough estimate for the overall time is\ntT + tE/nStreams\n.\n10.1.3.\nZero Copy\n\nZero copy\nis a feature that was added in version 2.2 of the CUDA Toolkit. It enables GPU threads to directly access host memory. For this purpose, it requires mapped pinned (non-pageable) memory. On integrated GPUs (i.e., GPUs with the integrated field of the CUDA device properties structure set to 1), mapped pinned memory is always a performance gain because it avoids superfluous copies as integrated GPU and CPU memory are physically the same. On discrete GPUs, mapped pinned memory is advantageous only in certain cases. Because the data is not cached on the GPU, mapped pinned memory should be read or written only once, and the global loads and stores that read and write the memory should be coalesced. Zero copy can be used in place of streams because kernel-originated data transfers automatically overlap kernel execution without the overhead of setting up and determining the optimal number of streams.\nNote\nLow Priority:\nUse zero-copy operations on integrated GPUs for CUDA Toolkit version 2.2 and later.\nThe host code in\nZero-copy host code\nshows how zero copy is typically set up.\nZero-copy host code\nfloat\n*\na_h\n,\n*\na_map\n;\n...\ncudaGetDeviceProperties\n(\n&\nprop\n,\n0\n);\nif\n(\n!\nprop\n.\ncanMapHostMemory\n)\nexit\n(\n0\n);\ncudaSetDeviceFlags\n(\ncudaDeviceMapHost\n);\ncudaHostAlloc\n(\n&\na_h\n,\nnBytes\n,\ncudaHostAllocMapped\n);\ncudaHostGetDevicePointer\n(\n&\na_map\n,\na_h\n,\n0\n);\nkernel\n<<<\ngridSize\n,\nblockSize\n>>>\n(\na_map\n);\nIn this code, the\ncanMapHostMemory\nfield of the structure returned by\ncudaGetDeviceProperties()\nis used to check that the device\nsupports mapping host memory to the device’s address space. Page-locked memory mapping is enabled by calling\ncudaSetDeviceFlags()\nwith\ncudaDeviceMapHost\n. Note that\ncudaSetDeviceFlags()\nmust be called prior to setting a device or making a CUDA call that\nrequires state (that is, essentially, before a context is created). Page-locked mapped host memory is allocated using\ncudaHostAlloc()\n,\nand the pointer to the mapped device address space is obtained via the function\ncudaHostGetDevicePointer()\n. In the code\nin\nZero-copy host code\n,\nkernel()\ncan reference the mapped pinned host memory using the pointer\na_map\nin exactly the\nsame was as it would if a_map referred to a location in device memory.\nNote\nMapped pinned host memory allows you to overlap CPU-GPU memory transfers with computation while avoiding the use of CUDA streams. But since any repeated access to such memory areas causes repeated CPU-GPU transfers, consider creating a second area in device memory to manually cache the previously read host memory data.\n10.1.4.\nUnified Virtual Addressing\n\nDevices of\ncompute capability\n2.0 and later support a special addressing mode called\nUnified Virtual Addressing\n(UVA) on 64-bit Linux and Windows. With UVA, the host memory and the device memories of all installed supported devices share a single virtual address space.\nPrior to UVA, an application had to keep track of which pointers referred to device memory (and for which device) and which referred to host memory as a separate bit of metadata (or as hard-coded information in the program) for each pointer. Using UVA, on the other hand, the physical memory space to which a pointer points can be determined simply by inspecting the value of the pointer using\ncudaPointerGetAttributes()\n.\nUnder UVA, pinned host memory allocated with\ncudaHostAlloc()\nwill have identical host and device pointers, so it is not necessary to call\ncudaHostGetDevicePointer()\nfor such allocations. Host memory allocations pinned after-the-fact via\ncudaHostRegister()\n, however, will continue to have different device pointers than their host pointers, so\ncudaHostGetDevicePointer()\nremains necessary in that case.\nUVA is also a necessary precondition for enabling peer-to-peer (P2P) transfer of data directly across the PCIe bus or NVLink for supported GPUs in supported configurations, bypassing host memory.\nSee the CUDA C++ Programming Guide for further explanations and software requirements for UVA and P2P.\n10.2.\nDevice Memory Spaces\n\nCUDA devices use several memory spaces, which have different characteristics that reflect their distinct usages in CUDA applications. These\nmemory spaces include global, local, shared, texture, and registers, as shown in\nFigure 2\n.\nFigure 2\nMemory spaces on a CUDA device\n\nOf these different memory spaces, global memory is the most plentiful; see Features and Technical Specifications of the CUDA C++ Programming Guide for the amounts of memory available in each memory space at each\ncompute capability\nlevel. Global, local, and texture memory have the greatest access latency, followed by constant memory, shared memory, and the register file.\nThe various principal traits of the memory types are shown in\nTable 1\n.\nTable 1\nSalient Features of Device Memory\n\nMemory\nLocation on/off chip\nCached\nAccess\nScope\nLifetime\nRegister\nOn\nn/a\nR/W\n1 thread\nThread\nLocal\nOff\nYes††\nR/W\n1 thread\nThread\nShared\nOn\nn/a\nR/W\nAll threads in block\nBlock\nGlobal\nOff\n†\nR/W\nAll threads + host\nHost allocation\nConstant\nOff\nYes\nR\nAll threads + host\nHost allocation\nTexture\nOff\nYes\nR\nAll threads + host\nHost allocation\n†\nCached in L1 and L2 by default on devices of compute capability 6.0 and 7.x; cached only in L2 by default on devices of lower compute capabilities, though some allow opt-in to caching in L1 as well via compilation flags.\n††\nCached in L1 and L2 by default except on devices of compute capability 5.x; devices of compute capability 5.x cache locals only in L2.\nIn the case of texture access, if a texture reference is bound to a linear array in global memory, then the device code can write to the underlying array. Texture references that are bound to CUDA arrays can be written to via surface-write operations by binding a surface to the same underlying CUDA array storage). Reading from a texture while writing to its underlying global memory array in the same kernel launch should be avoided because the texture caches are read-only and are not invalidated when the associated global memory is modified.\n10.2.1.\nCoalesced Access to Global Memory\n\nA very important performance consideration in programming for CUDA-capable GPU architectures is the coalescing of global memory accesses. Global memory loads and stores by threads of a warp are coalesced by the device into as few as possible transactions.\nNote\nHigh Priority:\nEnsure global memory accesses are coalesced whenever possible.\nThe access requirements for coalescing depend on the compute capability of the device and are documented in the CUDA C++ Programming Guide.\nFor devices of compute capability 6.0 or higher, the requirements can be summarized quite easily: the concurrent accesses of the threads of a warp will coalesce into a number of transactions equal to the number of 32-byte transactions necessary to service all of the threads of the warp.\nFor certain devices of compute capability 5.2, L1-caching of accesses to global memory can be optionally enabled. If L1-caching is enabled on these devices, the number of required transactions is equal to the number of required 128-byte aligned segments.\nNote\nOn devices of compute capability 6.0 or higher, L1-caching is the default, however the data access unit is 32-byte regardless of whether global loads are cached in L1 or not.\nOn devices with GDDR memory, accessing memory in a coalesced way is even more important when ECC is turned on. Scattered accesses increase ECC memory transfer overhead, especially when writing data to global memory.\nCoalescing concepts are illustrated in the following simple examples. These examples assume compute capability 6.0 or higher and that accesses are for 4-byte words, unless otherwise noted.\n10.2.1.1.\nA Simple Access Pattern\n\nThe first and simplest case of coalescing can be achieved by any CUDA-enabled device of compute capability 6.0 or higher: the\nk\n-th thread accesses the\nk\n-th word in a 32-byte aligned array. Not all threads need to participate.\nFor example, if the threads of a warp access adjacent 4-byte words (e.g., adjacent\nfloat\nvalues), four coalesced 32-byte\ntransactions will service that memory access. Such a pattern is shown in\nFigure 3 <coalesced-access-figure>\n.\nFigure 3\nCoalesced access\n\nThis access pattern results in four 32-byte transactions, indicated by the red rectangles.\nIf from any of the four 32-byte segments only a subset of the words are requested (e.g. if several threads had accessed the\nsame word or if some threads did not participate in the access), the full segment is fetched anyway. Furthermore, if accesses\nby the threads of the warp had been permuted within or accross the four segments, still only four 32-byte transactions would\nhave been performed by a device with\ncompute capability\n6.0 or higher.\n10.2.1.2.\nA Sequential but Misaligned Access Pattern\n\nIf sequential threads in a warp access memory that is sequential but not aligned with a 32-byte segment, five 32-byte segments\nwill be requested, as shown in\nFigure 4\n.\nFigure 4\nMisaligned sequential addresses that fall within five 32-byte segments\n\nMemory allocated through the CUDA Runtime API, such as via\ncudaMalloc()\n, is guaranteed to be aligned to at least 256 bytes. Therefore, choosing sensible thread block sizes, such as multiples of the warp size (i.e., 32 on current GPUs), facilitates memory accesses by warps that are properly aligned. (Consider what would happen to the memory addresses accessed by the second, third, and subsequent thread blocks if the thread block size was not a multiple of warp size, for example.)\n10.2.1.3.\nEffects of Misaligned Accesses\n\nIt is easy and informative to explore the ramifications of misaligned accesses using a simple copy kernel, such as the one\nin\nA copy kernel that illustrates misaligned accesses\n.\nA copy kernel that illustrates misaligned accesses\n__global__\nvoid\noffsetCopy\n(\nfloat\n*\nodata\n,\nfloat\n*\nidata\n,\nint\noffset\n)\n{\nint\nxid\n=\nblockIdx\n.\nx\n*\nblockDim\n.\nx\n+\nthreadIdx\n.\nx\n+\noffset\n;\nodata\n[\nxid\n]\n=\nidata\n[\nxid\n];\n}\nIn\nA copy kernel that illustrates misaligned accesses\n, data is copied from the input array\nidata\nto the output array, both\nof which exist in global memory. The kernel is executed within a loop in host code that varies the parameter\noffset\nfrom 0 to 32\n(for example,\nFigure 4\ncorresponds to this misalignments).\nThe effective bandwidth for the copy with various offsets on an NVIDIA Tesla V100 (\ncompute capability\n7.0)\nis shown in\nFigure 5\n.\nFigure 5\nPerformance of offsetCopy kernel\n\nFor the NVIDIA Tesla V100, global memory accesses with no offset or with offsets that are multiples of 8 words result in four 32-byte transactions. The achieved bandwidth is approximately 790 GB/s. Otherwise, five 32-byte segments are loaded per warp, and we would expect approximately 4/5\nth\nof the memory throughput achieved with no offsets.\nIn this particular example, the offset memory throughput achieved is, however, approximately 9/10\nth\n, because adjacent warps reuse the cache lines their neighbors fetched. So while the impact is still evident it is not as large as we might have expected. It would have been more so if adjacent warps had not exhibited such a high degree of reuse of the over-fetched cache lines.\n10.2.1.4.\nStrided Accesses\n\nAs seen above, in the case of misaligned sequential accesses, caches help to alleviate the performance impact. It may be different with non-unit-strided accesses, however, and this is a pattern that occurs frequently when dealing with multidimensional data or matrices. For this reason, ensuring that as much as possible of the data in each cache line fetched is actually used is an important part of performance optimization of memory accesses on these devices.\nTo illustrate the effect of strided access on effective bandwidth, see the kernel\nstrideCopy()\nin\nA kernel to illustrate non-unit stride data copy\n, which copies data with a stride of stride elements between threads from\nidata\nto\nodata\n.\nA kernel to illustrate non-unit stride data copy\n__global__\nvoid\nstrideCopy\n(\nfloat\n*\nodata\n,\nfloat\n*\nidata\n,\nint\nstride\n)\n{\nint\nxid\n=\n(\nblockIdx\n.\nx\n*\nblockDim\n.\nx\n+\nthreadIdx\n.\nx\n)\n*\nstride\n;\nodata\n[\nxid\n]\n=\nidata\n[\nxid\n];\n}\nFigure 6\nillustrates such a situation; in this case, threads within a warp access words in memory with a stride of 2. This action leads to a load of eight L2 cache segments per warp on the Tesla V100 (compute capability 7.0).\nFigure 6\nAdjacent threads accessing memory with a stride of 2\n\nA stride of 2 results in a 50% of load/store efficiency since half the elements in the transaction are not used and represent\nwasted bandwidth. As the stride increases, the effective bandwidth decreases until the point where 32 32-byte segments are loaded\nfor the 32 threads in a warp, as indicated in\nFigure 7\n.\nFigure 7\nPerformance of strideCopy kernel\n\nAs illustrated in\nFigure 7\n, non-unit-stride global memory accesses should be avoided whenever possible. One method for doing so utilizes shared memory, which is discussed in the next section.\n10.2.2.\nL2 Cache\n\nStarting with CUDA 11.0, devices of compute capability 8.0 and above have the capability to influence persistence of data in the L2 cache. Because L2 cache is on-chip, it potentially provides higher bandwidth and lower latency accesses to global memory.\nFor more details refer to the L2 Access Management section in the\nCUDA C++ Programming Guide\n.\n10.2.2.1.\nL2 Cache Access Window\n\nWhen a CUDA kernel accesses a data region in the global memory repeatedly, such data accesses can be considered to be\npersisting\n. On the other hand, if the data is only accessed once, such data accesses can be considered to be\nstreaming\n. A portion of the L2 cache can be set aside for persistent accesses to a data region in global memory. If this set-aside portion is not used by persistent accesses, then streaming or normal data accesses can use it.\nThe L2 cache set-aside size for persisting accesses may be adjusted, within limits:\ncudaGetDeviceProperties\n(\n&\nprop\n,\ndevice_id\n);\ncudaDeviceSetLimit\n(\ncudaLimitPersistingL2CacheSize\n,\nprop\n.\npersistingL2CacheMaxSize\n);\n/* Set aside max possible size of L2 cache for persisting accesses */\nMapping of user data to L2 set-aside portion can be controlled using an access policy window on a CUDA stream or CUDA graph kernel node. The example below shows how to use the access policy window on a CUDA stream.\ncudaStreamAttrValue\nstream_attribute\n;\n// Stream level attributes data structure\nstream_attribute\n.\naccessPolicyWindow\n.\nbase_ptr\n=\nreinterpret_cast\n<\nvoid\n*>\n(\nptr\n);\n// Global Memory data pointer\nstream_attribute\n.\naccessPolicyWindow\n.\nnum_bytes\n=\nnum_bytes\n;\n// Number of bytes for persisting accesses.\n// (Must be less than cudaDeviceProp::accessPolicyMaxWindowSize)\nstream_attribute\n.\naccessPolicyWindow\n.\nhitRatio\n=\n1.0\n;\n// Hint for L2 cache hit ratio for persisting accesses in the num_bytes region\nstream_attribute\n.\naccessPolicyWindow\n.\nhitProp\n=\ncudaAccessPropertyPersisting\n;\n// Type of access property on cache hit\nstream_attribute\n.\naccessPolicyWindow\n.\nmissProp\n=\ncudaAccessPropertyStreaming\n;\n// Type of access property on cache miss.\n//Set the attributes to a CUDA stream of type cudaStream_t\ncudaStreamSetAttribute\n(\nstream\n,\ncudaStreamAttributeAccessPolicyWindow\n,\n&\nstream_attribute\n);\nThe access policy window requires a value for\nhitRatio\nand\nnum_bytes\n. Depending on the value of the\nnum_bytes\nparameter and the size of L2 cache, one may need to tune the value of\nhitRatio\nto avoid thrashing of L2 cache lines.\n10.2.2.2.\nTuning the Access Window Hit-Ratio\n\nThe\nhitRatio\nparameter can be used to specify the fraction of accesses that receive the\nhitProp\nproperty. For example, if the\nhitRatio\nvalue is 0.6, 60% of the memory accesses in the global memory region [ptr..ptr+num_bytes) have the persisting property and 40% of the memory accesses have the streaming property. To understand the effect of\nhitRatio\nand\nnum_bytes\n, we use a sliding window micro benchmark.\nThis microbenchmark uses a 1024 MB region in GPU global memory. First, we set aside 30 MB of the L2 cache for persisting accesses using\ncudaDeviceSetLimit()\n, as discussed above. Then, as shown in the figure below, we specify that the accesses to the first\nfreqSize\n*\nsizeof(int)\nbytes of the memory region are persistent. This data will thus use the L2 set-aside portion. In our experiment, we vary the size of this persistent data region from 10 MB to 60 MB to model various scenarios where data fits in or exceeds the available L2 set-aside portion of 30 MB. Note that the NVIDIA Tesla A100 GPU has 40 MB of total L2 cache capacity. Accesses to the remaining data of the memory region (i.e., streaming data) are considered normal or streaming accesses and will thus use the remaining 10 MB of the non set-aside L2 portion (unless part of the L2 set-aside portion is unused).\nFigure 8\nMapping Persistent data accesses to set-aside L2 in sliding window experiment\n\nConsider the following kernel code and access window parameters, as the implementation of the sliding window experiment.\n__global__\nvoid\nkernel\n(\nint\n*\ndata_persistent\n,\nint\n*\ndata_streaming\n,\nint\ndataSize\n,\nint\nfreqSize\n)\n{\nint\ntid\n=\nblockIdx\n.\nx\n*\nblockDim\n.\nx\n+\nthreadIdx\n.\nx\n;\n/*Each CUDA thread accesses one element in the persistent data section\nand one element in the streaming data section.\nBecause the size of the persistent memory region (freqSize * sizeof(int) bytes) is much\nsmaller than the size of the streaming memory region (dataSize * sizeof(int) bytes), data\nin the persistent region is accessed more frequently*/\ndata_persistent\n[\ntid\n%\nfreqSize\n]\n=\n2\n*\ndata_persistent\n[\ntid\n%\nfreqSize\n];\ndata_streaming\n[\ntid\n%\ndataSize\n]\n=\n2\n*\ndata_streaming\n[\ntid\n%\ndataSize\n];\n}\nstream_attribute\n.\naccessPolicyWindow\n.\nbase_ptr\n=\nreinterpret_cast\n<\nvoid\n*>\n(\ndata_persistent\n);\nstream_attribute\n.\naccessPolicyWindow\n.\nnum_bytes\n=\nfreqSize\n*\nsizeof\n(\nint\n);\n//Number of bytes for persisting accesses in range 10-60 MB\nstream_attribute\n.\naccessPolicyWindow\n.\nhitRatio\n=\n1.0\n;\n//Hint for cache hit ratio. Fixed value 1.0\nThe performance of the above kernel is shown in the chart below. When the persistent data region fits well into the 30 MB set-aside portion of the L2 cache, a performance increase of as much as 50% is observed. However, once the size of this persistent data region exceeds the size of the L2 set-aside cache portion, approximately 10% performance drop is observed due to thrashing of L2 cache lines.\nFigure 9\nThe performance of the sliding-window benchmark with fixed hit-ratio of 1.0\n\nIn order to optimize the performance, when the size of the persistent data is more than the size of the set-aside L2 cache portion, we tune the\nnum_bytes\nand\nhitRatio\nparameters in the access window as below.\nstream_attribute\n.\naccessPolicyWindow\n.\nbase_ptr\n=\nreinterpret_cast\n<\nvoid\n*>\n(\ndata_persistent\n);\nstream_attribute\n.\naccessPolicyWindow\n.\nnum_bytes\n=\n20\n*\n1024\n*\n1024\n;\n//20 MB\nstream_attribute\n.\naccessPolicyWindow\n.\nhitRatio\n=\n(\n20\n*\n1024\n*\n1024\n)\n/\n((\nfloat\n)\nfreqSize\n*\nsizeof\n(\nint\n));\n//Such that up to 20MB of data is resident.\nWe fix the\nnum_bytes\nin the access window to 20 MB and tune the\nhitRatio\nsuch that a random 20 MB of the total persistent data is resident in the L2 set-aside cache portion. The remaining portion of this persistent data will be accessed using the streaming property. This helps in reducing cache thrashing. The results are shown in the chart below, where we see good performance regardless of whether the persistent data fits in the L2 set-aside or not.\nFigure 10\nThe performance of the sliding-window benchmark with tuned hit-ratio\n\n10.2.3.\nShared Memory\n\nBecause it is on-chip, shared memory has much higher bandwidth and lower latency than local and global memory - provided there are no bank conflicts between the threads, as detailed in the following section.\n10.2.3.1.\nShared Memory and Memory Banks\n\nTo achieve high memory bandwidth for concurrent accesses, shared memory is divided into equally sized memory modules (\nbanks\n) that can be accessed simultaneously. Therefore, any memory load or store of\nn\naddresses that spans\nn\ndistinct memory banks can be serviced simultaneously, yielding an effective bandwidth that is\nn\ntimes as high as the bandwidth of a single bank.\nHowever, if multiple addresses of a memory request map to the same memory bank, the accesses are serialized. The hardware splits a memory request that has bank conflicts into as many separate conflict-free requests as necessary, decreasing the effective bandwidth by a factor equal to the number of separate memory requests. The one exception here is when multiple threads in a warp address the same shared memory location, resulting in a broadcast. In this case, multiple broadcasts from different banks are coalesced into a single multicast from the requested shared memory locations to the threads.\nTo minimize bank conflicts, it is important to understand how memory addresses map to memory banks and how to optimally schedule memory requests.\nOn devices of compute capability 5.x or newer, each bank has a bandwidth of 32 bits every clock cycle, and successive 32-bit words are assigned to successive banks. The warp size is 32 threads and the number of banks is also 32, so bank conflicts can occur between any threads in the warp. See\nCompute Capability 5.x\nfor further details.\n10.2.3.2.\nShared Memory in Matrix Multiplication (C=AB)\n\nShared memory enables cooperation between threads in a block. When multiple threads in a block use the same data from global memory, shared memory can be used to access the data from global memory only once. Shared memory can also be used to avoid uncoalesced memory accesses by loading and storing data in a coalesced pattern from global memory and then reordering it in shared memory. Aside from memory bank conflicts, there is no penalty for non-sequential or unaligned accesses by a warp in shared memory.\nThe use of shared memory is illustrated via the simple example of a matrix multiplication C = AB for the case with A of dimension Mxw, B of dimension wxN, and C of dimension MxN. To keep the kernels simple, M and N are multiples of 32, since the warp size (w) is 32 for current devices.\nA natural decomposition of the problem is to use a block and tile size of wxw threads. Therefore, in terms of wxw tiles, A is a column matrix, B is a row matrix, and C is their outer product; see\nFigure 11\n. A grid of N/w by M/w blocks is launched, where each thread block calculates the elements of a different tile in C from a single tile of A and a single tile of B.\nFigure 11\nBlock-column matrix multiplied by block-row matrix. Block-column matrix (A) multiplied by block-row matrix (B) with resulting product matrix (C).\n\nTo do this, the\nsimpleMultiply\nkernel (\nUnoptimized matrix multiplication\n) calculates the output elements of a tile of matrix C.\nUnoptimized matrix multiplication\n__global__\nvoid\nsimpleMultiply\n(\nfloat\n*\na\n,\nfloat\n*\nb\n,\nfloat\n*\nc\n,\nint\nN\n)\n{\nint\nrow\n=\nblockIdx\n.\ny\n*\nblockDim\n.\ny\n+\nthreadIdx\n.\ny\n;\nint\ncol\n=\nblockIdx\n.\nx\n*\nblockDim\n.\nx\n+\nthreadIdx\n.\nx\n;\nfloat\nsum\n=\n0.0f\n;\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nTILE_DIM\n;\ni\n++\n)\n{\nsum\n+=\na\n[\nrow\n*\nTILE_DIM\n+\ni\n]\n*\nb\n[\ni\n*\nN\n+\ncol\n];\n}\nc\n[\nrow\n*\nN\n+\ncol\n]\n=\nsum\n;\n}\nIn\nUnoptimized matrix multiplication\n,\na\n,\nb\n, and\nc\nare pointers to global memory for the matrices A, B, and C, respectively;\nblockDim.x\n,\nblockDim.y\n, and\nTILE_DIM\nare all equal to w. Each thread in the wxw-thread block calculates one element in a tile of C.\nrow\nand\ncol\nare the row and column of the element in C being calculated by a particular thread. The\nfor\nloop over\ni\nmultiplies a row of A by a column of B, which is then written to C.\nThe effective bandwidth of this kernel is 119.9 GB/s on an NVIDIA Tesla V100. To analyze performance, it is necessary to consider how warps access global memory in the\nfor\nloop. Each warp of threads calculates one row of a tile of C, which depends on a single row of A and an entire tile of B as illustrated in\nFigure 12\n.\nFigure 12\nComputing a row of a tile. Computing a row of a tile in C using one row of A and an entire tile of B.\n\nFor each iteration\ni\nof the\nfor\nloop, the threads in a warp read a row of the B tile, which is a sequential and coalesced access for all compute capabilities.\nHowever, for each iteration\ni\n, all threads in a warp read the same value from global memory for matrix A, as the index\nrow*TILE_DIM+i\nis constant within a warp. Even though such an access requires only 1 transaction on devices of compute capability 2.0 or higher, there is wasted bandwidth in the transaction, because only one 4-byte word out of 8 words in a 32-byte cache segment is used. We can reuse this cache line in subsequent iterations of the loop, and we would eventually utilize all 8 words; however, when many warps execute on the same multiprocessor simultaneously, as is generally the case, the cache line may easily be evicted from the cache between iterations\ni\nand\ni+1\n.\nThe performance on a device of any compute capability can be improved by reading a tile of A into shared memory as shown\nin\nUsing shared memory to improve the global memory load efficiency in matrix multiplication\n.\nUsing shared memory to improve the global memory load efficiency in matrix multiplication\n__global__\nvoid\ncoalescedMultiply\n(\nfloat\n*\na\n,\nfloat\n*\nb\n,\nfloat\n*\nc\n,\nint\nN\n)\n{\n__shared__\nfloat\naTile\n[\nTILE_DIM\n][\nTILE_DIM\n];\nint\nrow\n=\nblockIdx\n.\ny\n*\nblockDim\n.\ny\n+\nthreadIdx\n.\ny\n;\nint\ncol\n=\nblockIdx\n.\nx\n*\nblockDim\n.\nx\n+\nthreadIdx\n.\nx\n;\nfloat\nsum\n=\n0.0f\n;\naTile\n[\nthreadIdx\n.\ny\n][\nthreadIdx\n.\nx\n]\n=\na\n[\nrow\n*\nTILE_DIM\n+\nthreadIdx\n.\nx\n];\n__syncwarp\n();\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nTILE_DIM\n;\ni\n++\n)\n{\nsum\n+=\naTile\n[\nthreadIdx\n.\ny\n][\ni\n]\n*\nb\n[\ni\n*\nN\n+\ncol\n];\n}\nc\n[\nrow\n*\nN\n+\ncol\n]\n=\nsum\n;\n}\nIn\nUsing shared memory to improve the global memory load efficiency in matrix multiplication\n, each element in a tile of A is read from global memory only once, in a fully coalesced fashion (with no wasted bandwidth), to shared memory. Within each iteration of the\nfor\nloop, a value in shared memory is broadcast to all threads in a warp. Instead of a\n__syncthreads()\nsynchronization barrier call, a\n__syncwarp()\nis sufficient after reading the tile of A into shared memory because only threads within the warp that write the data into shared memory read this data. This kernel has an effective bandwidth of 144.4 GB/s on an NVIDIA Tesla V100. This illustrates the use of the shared memory as a\nuser-managed cache\nwhen the hardware L1 cache eviction policy does not match up well with the needs of the application or when L1 cache is not used for reads from global memory.\nA further improvement can be made to how\nUsing shared memory to improve the global memory load efficiency in matrix multiplication\ndeals with matrix B. In calculating each of the rows of a tile of matrix C, the entire tile of B is read. The repeated reading of the B tile can be eliminated by reading it into shared memory once (\nImprovement by reading additional data into shared memory\n).\nImprovement by reading additional data into shared memory\n__global__\nvoid\nsharedABMultiply\n(\nfloat\n*\na\n,\nfloat\n*\nb\n,\nfloat\n*\nc\n,\nint\nN\n)\n{\n__shared__\nfloat\naTile\n[\nTILE_DIM\n][\nTILE_DIM\n],\nbTile\n[\nTILE_DIM\n][\nTILE_DIM\n];\nint\nrow\n=\nblockIdx\n.\ny\n*\nblockDim\n.\ny\n+\nthreadIdx\n.\ny\n;\nint\ncol\n=\nblockIdx\n.\nx\n*\nblockDim\n.\nx\n+\nthreadIdx\n.\nx\n;\nfloat\nsum\n=\n0.0f\n;\naTile\n[\nthreadIdx\n.\ny\n][\nthreadIdx\n.\nx\n]\n=\na\n[\nrow\n*\nTILE_DIM\n+\nthreadIdx\n.\nx\n];\nbTile\n[\nthreadIdx\n.\ny\n][\nthreadIdx\n.\nx\n]\n=\nb\n[\nthreadIdx\n.\ny\n*\nN\n+\ncol\n];\n__syncthreads\n();\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nTILE_DIM\n;\ni\n++\n)\n{\nsum\n+=\naTile\n[\nthreadIdx\n.\ny\n][\ni\n]\n*\nbTile\n[\ni\n][\nthreadIdx\n.\nx\n];\n}\nc\n[\nrow\n*\nN\n+\ncol\n]\n=\nsum\n;\n}\nNote that in\nImprovement by reading additional data into shared memory\n, a\n__syncthreads()\ncall is required after reading the B tile because a warp reads data from shared memory that were written to shared memory by different warps. The effective bandwidth of this routine is 195.5 GB/s on an NVIDIA Tesla V100. Note that the performance improvement is not due to improved coalescing in either case, but to avoiding redundant transfers from global memory.\nThe results of the various optimizations are summarized in\nTable 2\n.\nTable 2\nPerformance Improvements Optimizing C = AB Matrix Multiply\n\nOptimization\nNVIDIA Tesla V100\nNo optimization\n119.9 GB/s\nCoalesced using shared memory to store a tile of A\n144.4 GB/s\nUsing shared memory to eliminate redundant reads of a tile of B\n195.5 GB/s\nNote\nMedium Priority:\nUse shared memory to avoid redundant transfers from global memory.\n10.2.3.3.\nShared Memory in Matrix Multiplication (C=AAT)\n\nA variant of the previous matrix multiplication can be used to illustrate how strided accesses to global memory, as well as shared memory bank conflicts, are handled. This variant simply uses the transpose of A in place of B, so C = AA\nT\n.\nA simple implementation for C = AA\nT\nis shown in\nUnoptimized handling of strided accesses to global memory\n.\nUnoptimized handling of strided accesses to global memory\n__global__\nvoid\nsimpleMultiply\n(\nfloat\n*\na\n,\nfloat\n*\nc\n,\nint\nM\n)\n{\nint\nrow\n=\nblockIdx\n.\ny\n*\nblockDim\n.\ny\n+\nthreadIdx\n.\ny\n;\nint\ncol\n=\nblockIdx\n.\nx\n*\nblockDim\n.\nx\n+\nthreadIdx\n.\nx\n;\nfloat\nsum\n=\n0.0f\n;\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nTILE_DIM\n;\ni\n++\n)\n{\nsum\n+=\na\n[\nrow\n*\nTILE_DIM\n+\ni\n]\n*\na\n[\ncol\n*\nTILE_DIM\n+\ni\n];\n}\nc\n[\nrow\n*\nM\n+\ncol\n]\n=\nsum\n;\n}\nIn the example above, the\nrow\n-th,\ncol\n-th element of C is obtained by taking the dot product of the\nrow\n-th and\ncol\n-th rows of A. The effective bandwidth for this kernel is 12.8 GB/s on an NVIDIA Tesla V100. These results are substantially lower than the corresponding measurements for the C = AB kernel. The difference is in how threads in a half warp access elements of A in the second term,\na[col*TILE_DIM+i]\n, for each iteration\ni\n. For a warp of threads,\ncol\nrepresents sequential columns of the transpose of A, and therefore\ncol*TILE_DIM\nrepresents a strided access of global memory with a stride of w, resulting in plenty of wasted bandwidth.\nThe way to avoid strided access is to use shared memory as before, except in this case a warp reads a row of A into a column of a shared memory tile, as\nshown in\nAn optimized handling of strided accesses using coalesced reads from global memory\n.\nAn optimized handling of strided accesses using coalesced reads from global memory\n__global__\nvoid\ncoalescedMultiply\n(\nfloat\n*\na\n,\nfloat\n*\nc\n,\nint\nM\n)\n{\n__shared__\nfloat\naTile\n[\nTILE_DIM\n][\nTILE_DIM\n],\ntransposedTile\n[\nTILE_DIM\n][\nTILE_DIM\n];\nint\nrow\n=\nblockIdx\n.\ny\n*\nblockDim\n.\ny\n+\nthreadIdx\n.\ny\n;\nint\ncol\n=\nblockIdx\n.\nx\n*\nblockDim\n.\nx\n+\nthreadIdx\n.\nx\n;\nfloat\nsum\n=\n0.0f\n;\naTile\n[\nthreadIdx\n.\ny\n][\nthreadIdx\n.\nx\n]\n=\na\n[\nrow\n*\nTILE_DIM\n+\nthreadIdx\n.\nx\n];\ntransposedTile\n[\nthreadIdx\n.\nx\n][\nthreadIdx\n.\ny\n]\n=\na\n[(\nblockIdx\n.\nx\n*\nblockDim\n.\nx\n+\nthreadIdx\n.\ny\n)\n*\nTILE_DIM\n+\nthreadIdx\n.\nx\n];\n__syncthreads\n();\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nTILE_DIM\n;\ni\n++\n)\n{\nsum\n+=\naTile\n[\nthreadIdx\n.\ny\n][\ni\n]\n*\ntransposedTile\n[\ni\n][\nthreadIdx\n.\nx\n];\n}\nc\n[\nrow\n*\nM\n+\ncol\n]\n=\nsum\n;\n}\nAn optimized handling of strided accesses using coalesced reads from global memory\nuses the shared\ntransposedTile\nto avoid uncoalesced accesses in the second term in the dot product and the shared\naTile\ntechnique from the previous example to avoid uncoalesced accesses in the first term. The effective bandwidth of this kernel is 140.2 GB/s on an NVIDIA Tesla V100.These results are lower than those obtained by the final kernel for C = AB. The cause of the difference is shared memory bank conflicts.\nThe reads of elements in\ntransposedTile\nwithin the for loop are free of conflicts, because threads of each half warp read across rows of the tile, resulting in unit stride across the banks. However, bank conflicts occur when copying the tile from global memory into shared memory. To enable the loads from global memory to be coalesced, data are read from global memory sequentially. However, this requires writing to shared memory in columns, and because of the use of wxw tiles in shared memory, this results in a stride between threads of w banks - every thread of the warp hits the same bank (Recall that w is selected as 32). These many-way bank conflicts are very expensive. The simple remedy is to pad the shared memory array so that it has an extra column, as in the following line of code.\n__shared__\nfloat\ntransposedTile\n[\nTILE_DIM\n][\nTILE_DIM\n+\n1\n];\nThis padding eliminates the conflicts entirely, because now the stride between threads is w+1 banks (i.e., 33 for current devices), which, due to modulo arithmetic used to compute bank indices, is equivalent to a unit stride. After this change, the effective bandwidth is 199.4 GB/s on an NVIDIA Tesla V100, which is comparable to the results from the last C = AB kernel.\nThe results of these optimizations are summarized in\nTable 3\n.\nTable 3\nPerformance Improvements Optimizing C = AA\nT\nMatrix Multiplication\n\nOptimization\nNVIDIA Tesla V100\nNo optimization\n12.8 GB/s\nUsing shared memory to coalesce global reads\n140.2 GB/s\nRemoving bank conflicts\n199.4 GB/s\nThese results should be compared with those in\nTable 2\n. As can be seen from these tables, judicious use of shared memory can dramatically improve performance.\nThe examples in this section have illustrated three reasons to use shared memory:\nTo enable coalesced accesses to global memory, especially to avoid large strides (for general matrices, strides are much larger than 32)\nTo eliminate (or reduce) redundant loads from global memory\nTo avoid wasted bandwidth\n10.2.3.4.\nAsynchronous Copy from Global Memory to Shared Memory\n\nCUDA 11.0 introduces an\nasync-copy\nfeature that can be used within device code to explicitly manage the asynchronous copying of data from global memory to shared memory. This feature enables CUDA kernels to overlap copying data from global to shared memory with computation. It also avoids an intermediary register file access traditionally present between the global memory read and the shared memory write.\nFor more details refer to the\nmemcpy_async\nsection in the\nCUDA C++ Programming Guide\n.\nTo understand the performance difference between synchronous copy and asynchronous copy of data from global memory to shared memory, consider the following micro benchmark CUDA kernels for demonstrating the synchronous and asynchronous approaches. Asynchronous copies are hardware accelerated for NVIDIA A100 GPU.\ntemplate\n<\ntypename\nT\n>\n__global__\nvoid\npipeline_kernel_sync\n(\nT\n*\nglobal\n,\nuint64_t\n*\nclock\n,\nsize_t\ncopy_count\n)\n{\nextern\n__shared__\nchar\ns\n[];\nT\n*\nshared\n=\nreinterpret_cast\n<\nT\n*>\n(\ns\n);\nuint64_t\nclock_start\n=\nclock64\n();\nfor\n(\nsize_t\ni\n=\n0\n;\ni\n<\ncopy_count\n;\n++\ni\n)\n{\nshared\n[\nblockDim\n.\nx\n*\ni\n+\nthreadIdx\n.\nx\n]\n=\nglobal\n[\nblockDim\n.\nx\n*\ni\n+\nthreadIdx\n.\nx\n];\n}\nuint64_t\nclock_end\n=\nclock64\n();\natomicAdd\n(\nreinterpret_cast\n<\nunsigned\nlong\nlong\n*>\n(\nclock\n),\nclock_end\n-\nclock_start\n);\n}\ntemplate\n<\ntypename\nT\n>\n__global__\nvoid\npipeline_kernel_async\n(\nT\n*\nglobal\n,\nuint64_t\n*\nclock\n,\nsize_t\ncopy_count\n)\n{\nextern\n__shared__\nchar\ns\n[];\nT\n*\nshared\n=\nreinterpret_cast\n<\nT\n*>\n(\ns\n);\nuint64_t\nclock_start\n=\nclock64\n();\n//pipeline pipe;\nfor\n(\nsize_t\ni\n=\n0\n;\ni\n<\ncopy_count\n;\n++\ni\n)\n{\n__pipeline_memcpy_async\n(\n&\nshared\n[\nblockDim\n.\nx\n*\ni\n+\nthreadIdx\n.\nx\n],\n&\nglobal\n[\nblockDim\n.\nx\n*\ni\n+\nthreadIdx\n.\nx\n],\nsizeof\n(\nT\n));\n}\n__pipeline_commit\n();\n__pipeline_wait_prior\n(\n0\n);\nuint64_t\nclock_end\n=\nclock64\n();\natomicAdd\n(\nreinterpret_cast\n<\nunsigned\nlong\nlong\n*>\n(\nclock\n),\nclock_end\n-\nclock_start\n);\n}\nThe synchronous version for the kernel loads an element from global memory to an intermediate register and then stores the intermediate register value to shared memory. In the asynchronous version of the kernel, instructions to load from global memory and store directly into shared memory are issued as soon as\n__pipeline_memcpy_async()\nfunction is called. The\n__pipeline_wait_prior(0)\nwill wait until all the instructions in the pipe object have been executed. Using asynchronous copies does not use any intermediate register. Not using intermediate registers can help reduce register pressure and can increase kernel occupancy. Data copied from global memory to shared memory using asynchronous copy instructions can be cached in the L1 cache or the L1 cache can be optionally bypassed. If individual CUDA threads are copying elements of 16 bytes, the L1 cache can be bypassed. This difference is illustrated in\nFigure 13\n.\nFigure 13\nComparing Synchronous vs Asynchronous Copy from Global Memory to Shared Memory\n\nWe evaluate the performance of both kernels using elements of size 4B, 8B and 16B per thread i.e., using\nint\n,\nint2\nand\nint4\nfor the template parameter. We adjust the\ncopy_count\nin the kernels such that each thread block copies from 512 bytes up to 48 MB. The performance of the kernels is shown in\nFigure 14\n.\nFigure 14\nComparing Performance of Synchronous vs Asynchronous Copy from Global Memory to Shared Memory\n\nFrom the performance chart, the following observations can be made for this experiment.\nBest performance with synchronous copy is achieved when the\ncopy_count\nparameter is a multiple of 4 for all three element sizes. The compiler can optimize groups of 4 load and store instructions. This is evident from the saw tooth curves.\nAsynchronous copy achieves better performance in nearly all cases.\nThe async-copy does not require the\ncopy_count\nparameter to be a multiple of 4, to maximize performance through compiler optimizations.\nOverall, best performance is achieved when using asynchronous copies with an element of size 8 or 16 bytes.\n10.2.4.\nLocal Memory\n\nLocal memory is so named because its scope is local to the thread, not because of its physical location. In fact, local memory is off-chip. Hence, access to local memory is as expensive as access to global memory. In other words, the term\nlocal\nin the name does not imply faster access.\nLocal memory is used only to hold automatic variables. This is done by the\nnvcc\ncompiler when it determines that there is insufficient register space to hold the variable. Automatic variables that are likely to be placed in local memory are large structures or arrays that would consume too much register space and arrays that the compiler determines may be indexed dynamically.\nInspection of the PTX assembly code (obtained by compiling with\n-ptx\nor\n-keep\ncommand-line options to\nnvcc\n) reveals whether a variable has been placed in local memory during the first compilation phases. If it has, it will be declared using the\n.local\nmnemonic and accessed using the\nld.local\nand\nst.local\nmnemonics. If it has not, subsequent compilation phases might still decide otherwise, if they find the variable consumes too much register space for the targeted architecture. There is no way to check this for a specific variable, but the compiler reports total local memory usage per kernel (lmem) when run with the\n--ptxas-options=-v\noption.\n10.2.5.\nTexture Memory\n\nThe read-only texture memory space is cached. Therefore, a texture fetch costs one device memory read only on a cache miss; otherwise, it just costs one read from the texture cache. The texture cache is optimized for 2D spatial locality, so threads of the same warp that read texture addresses that are close together will achieve best performance. Texture memory is also designed for streaming fetches with a constant latency; that is, a cache hit reduces DRAM bandwidth demand, but not fetch latency.\nIn certain addressing situations, reading device memory through texture fetching can be an advantageous alternative to reading device memory from global or constant memory.\n10.2.5.1.\nAdditional Texture Capabilities\n\nIf textures are fetched using\ntex1D()\n,\ntex2D()\n, or\ntex3D()\nrather than\ntex1Dfetch()\n, the hardware provides other capabilities that might be useful for some applications such as image processing, as shown in\nTable 4\n.\nTable 4\nUseful Features for tex1D(), tex2D(), and tex3D() Fetches\n\nFeature\nUse\nCaveat\nFiltering\nFast, low-precision interpolation between texels\nValid only if the texture reference returns floating-point data\nNormalized texture coordinates\nResolution-independent coding\nNone\nAddressing modes\nAutomatic handling of boundary cases\n1\nCan be used only with normalized texture coordinates\n1\nThe automatic handling of boundary cases in the bottom row of Table 4 refers to how a texture coordinate is resolved when it falls outside the valid addressing range. There are two options:\nclamp\nand\nwrap\n. If\nx\nis the coordinate and\nN\nis the number of texels for a one-dimensional texture, then with clamp,\nx\nis replaced by\n0\nif\nx\n< 0 and by 1-1/\nN\nif 1\n<\nx\n. With wrap,\nx\nis replaced by\nfrac(x)\nwhere\nfrac(x) = x - floor(x)\n. Floor returns the largest integer less than or equal to\nx\n. So, in clamp mode where\nN\n= 1, an\nx\nof 1.3 is clamped to 1.0; whereas in wrap mode, it is converted to 0.3\nWithin a kernel call, the texture cache is not kept coherent with respect to global memory writes, so texture fetches from addresses that have been written via global stores in the same kernel call return undefined data. That is, a thread can safely read a memory location via texture if the location has been updated by a previous kernel call or memory copy, but not if it has been previously updated by the same thread or another thread within the same kernel call.\n10.2.6.\nConstant Memory\n\nThere is a total of 64 KB constant memory on a device. The constant memory space is cached. As a result, a read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp accesses only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.\n10.2.7.\nRegisters\n\nGenerally, accessing a register consumes zero extra clock cycles per instruction, but delays may occur due to register read-after-write dependencies and register memory bank conflicts.\nThe compiler and hardware thread scheduler will schedule instructions as optimally as possible to avoid register memory bank conflicts. An application has no direct control over these bank conflicts. In particular, there is no register-related reason to pack data into vector data types such as\nfloat4\nor\nint4\ntypes.\n10.2.7.1.\nRegister Pressure\n\nRegister pressure occurs when there are not enough registers available for a given task. Even though each multiprocessor contains thousands of 32-bit registers (see Features and Technical Specifications of the CUDA C++ Programming Guide), these are partitioned among concurrent threads. To prevent the compiler from allocating too many registers, use the\n-maxrregcount=N\ncompiler command-line option or the launch bounds kernel definition qualifier (see Execution Configuration of the CUDA C++ Programming Guide) to control the maximum number of registers to allocated per thread.\n10.3.\nAllocation\n\nDevice memory allocation and de-allocation via\ncudaMalloc()\nand\ncudaFree()\nare expensive operations. It is recommended to use\ncudaMallocAsync()\nand\ncudaFreeAsync()\nwhich are stream ordered pool allocators to manage device memory.\n10.4.\nNUMA Best Practices\n\nSome recent Linux distributions enable automatic NUMA balancing (or “\nAutoNUMA\n”) by default. In some instances, operations performed by automatic NUMA balancing may degrade the performance of applications running on NVIDIA GPUs. For optimal performance, users should manually tune the NUMA characteristics of their application.\nThe optimal NUMA tuning will depend on the characteristics and desired hardware affinities of each application and node, but in general applications computing on NVIDIA GPUs are advised to choose a policy that disables automatic NUMA balancing. For example, on IBM Newell POWER9 nodes (where the CPUs correspond to NUMA nodes 0 and 8), use:\nnumactl --membind=0,8\nto bind memory allocations to the CPUs.\n11.\nExecution Configuration Optimizations\n\nOne of the keys to good performance is to keep the multiprocessors on the device as busy as possible. A device in which work is poorly balanced across the multiprocessors will deliver suboptimal performance. Hence, it’s important to design your application to use threads and blocks in a way that maximizes hardware utilization and to limit practices that impede the free distribution of work. A key concept in this effort is occupancy, which is explained in the following sections.\nHardware utilization can also be improved in some cases by designing your application so that multiple, independent kernels can execute at the same time. Multiple kernels executing at the same time is known as concurrent kernel execution. Concurrent kernel execution is described below.\nAnother important concept is the management of system resources allocated for a particular task. How to manage this resource utilization is discussed in the final sections of this chapter.\n11.1.\nOccupancy\n\nThread instructions are executed sequentially in CUDA, and, as a result, executing other warps when one warp is paused or stalled is the only way to hide latencies and keep the hardware busy. Some metric related to the number of active warps on a multiprocessor is therefore important in determining how effectively the hardware is kept busy. This metric is\noccupancy\n.\nOccupancy is the ratio of the number of active warps per multiprocessor to the maximum number of possible active warps. (To determine the latter number, see the\ndeviceQuery\nCUDA Sample or refer to\nCompute Capabilities\n.) Another way to view occupancy is the percentage of the hardware’s ability to process warps that is actively in use.\nHigher occupancy does not always equate to higher performance-there is a point above which additional occupancy does not improve performance. However, low occupancy always interferes with the ability to hide memory latency, resulting in performance degradation.\nPer thread resources required by a CUDA kernel might limit the maximum block size in an unwanted way. In order to maintain forward compatibility to future hardware and toolkits and to ensure that at least one thread block can run on an SM, developers should include the single argument\n__launch_bounds__(maxThreadsPerBlock)\nwhich specifies the largest block size that the kernel will be launched with. Failure to do so could lead to “too many resources requested for launch” errors. Providing the two argument version of\n__launch_bounds__(maxThreadsPerBlock,minBlocksPerMultiprocessor)\ncan improve performance in some cases. The right value for\nminBlocksPerMultiprocessor\nshould be determined using a detailed per kernel analysis.\n11.1.1.\nCalculating Occupancy\n\nOne of several factors that determine occupancy is register availability. Register storage enables threads to keep local variables nearby for low-latency access. However, the set of registers (known as the\nregister file\n) is a limited commodity that all threads resident on a multiprocessor must share. Registers are allocated to an entire block all at once. So, if each thread block uses many registers, the number of thread blocks that can be resident on a multiprocessor is reduced, thereby lowering the occupancy of the multiprocessor. The maximum number of registers per thread can be set manually at compilation time per-file using the\n-maxrregcount\noption or per-kernel using the\n__launch_bounds__\nqualifier (see\nRegister Pressure\n).\nFor purposes of calculating occupancy, the number of registers used by each thread is one of the key factors. For example, on devices of\nCUDA Compute Capability\n7.0 each multiprocessor has 65,536 32-bit registers and can have a maximum of 2048 simultaneous threads resident (64 warps x 32 threads per warp). This means that in one of these devices, for a multiprocessor to have 100% occupancy, each thread can use at most 32 registers. However, this approach of determining how register count affects occupancy does not take into account the register allocation granularity. For example, on a device of compute capability 7.0, a kernel with 128-thread blocks using 37 registers per thread results in an occupancy of 75% with 12 active 128-thread blocks per multi-processor, whereas a kernel with 320-thread blocks using the same 37 registers per thread results in an occupancy of 63% because only four 320-thread blocks can reside on a multiprocessor. Furthermore, register allocations are rounded up to the nearest 256 registers per warp.\nThe number of registers available, the maximum number of simultaneous threads resident on each multiprocessor, and the register allocation granularity vary over different\ncompute capabilities. Because of these nuances in register allocation and the fact that a multiprocessor’s shared memory is also partitioned between resident thread blocks,\nthe exact relationship between register usage and occupancy can be difficult to determine. The\n--ptxas\noptions=v\noption of\nnvcc\ndetails the number of registers\nused per thread for each kernel. See Hardware Multithreading of the CUDA C++ Programming Guide for the register allocation formulas for devices of various compute\ncapabilities and Features and Technical Specifications of the CUDA C++ Programming Guide for the total number of registers available on those devices. Alternatively,\nNVIDIA provides an occupancy calculator as part of Nsight Compute; refer to\nhttps://docs.nvidia.com/nsight-compute/NsightCompute/index.html#occupancy-calculator\n.\nFigure 15\nUsing the CUDA Occupancy Calculator to project GPU multiprocessor occupancy\n\nAn application can also use the Occupancy API from the CUDA Runtime, e.g.\ncudaOccupancyMaxActiveBlocksPerMultiprocessor\n, to dynamically select launch configurations based on runtime parameters.\n11.2.\nHiding Register Dependencies\n\nNote\nMedium Priority:\nTo hide latency arising from register dependencies, maintain sufficient numbers of active threads per multiprocessor (i.e., sufficient occupancy).\nRegister dependencies arise when an instruction uses a result stored in a register written by an instruction before it. The latency of most arithmetic instructions is typically 4 cycles on devices of compute capability 7.0. So threads must wait approximatly 4 cycles before using an arithmetic result. However, this latency can be completely hidden by the execution of threads in other warps. See\nRegisters\nfor details.\n11.3.\nThread and Block Heuristics\n\nNote\nMedium Priority:\nThe number of threads per block should be a multiple of 32 threads, because this provides optimal computing efficiency and facilitates coalescing.\nThe dimension and size of blocks per grid and the dimension and size of threads per block are both important factors. The multidimensional aspect of these parameters allows easier mapping of multidimensional problems to CUDA and does not play a role in performance. As a result, this section discusses size but not dimension.\nLatency hiding and occupancy depend on the number of active warps per multiprocessor, which is implicitly determined by the execution parameters along with resource (register and shared memory) constraints. Choosing execution parameters is a matter of striking a balance between latency hiding (occupancy) and resource utilization.\nChoosing the execution configuration parameters should be done in tandem; however, there are certain heuristics that apply to each parameter individually. When choosing the first execution configuration parameter-the number of blocks per grid, or\ngrid size\n- the primary concern is keeping the entire GPU busy. The number of blocks in a grid should be larger than the number of multiprocessors so that all multiprocessors have at least one block to execute. Furthermore, there should be multiple active blocks per multiprocessor so that blocks that aren’t waiting for a\n__syncthreads()\ncan keep the hardware busy. This recommendation is subject to resource availability; therefore, it should be determined in the context of the second execution parameter - the number of threads per block, or\nblock size\n- as well as shared memory usage. To scale to future devices, the number of blocks per kernel launch should be in the thousands.\nWhen choosing the block size, it is important to remember that multiple concurrent blocks can reside on a multiprocessor, so occupancy is not determined by block size alone. In particular, a larger block size does not imply a higher occupancy.\nAs mentioned in\nOccupancy\n, higher occupancy does not always equate to better performance. For example, improving occupancy from 66 percent to 100 percent generally does not translate to a similar increase in performance. A lower occupancy kernel will have more registers available per thread than a higher occupancy kernel, which may result in less register spilling to local memory; in particular, with a high degree of exposed instruction-level parallelism (ILP) it is, in some cases, possible to fully cover latency with a low occupancy.\nThere are many such factors involved in selecting block size, and inevitably some experimentation is required. However, a few rules of thumb should be followed:\nThreads per block should be a multiple of warp size to avoid wasting computation on under-populated warps and to facilitate coalescing.\nA minimum of 64 threads per block should be used, and only if there are multiple concurrent blocks per multiprocessor.\nBetween 128 and 256 threads per block is a good initial range for experimentation with different block sizes.\nUse several smaller thread blocks rather than one large thread block per multiprocessor if latency affects performance. This is particularly beneficial to kernels that frequently call\n__syncthreads()\n.\nNote that when a thread block allocates more registers than are available on a multiprocessor, the kernel launch fails, as it will when too much shared memory or too many threads are requested.\n11.4.\nEffects of Shared Memory\n\nShared memory can be helpful in several situations, such as helping to coalesce or eliminate redundant access to global memory. However, it also can act as a constraint on occupancy. In many cases, the amount of shared memory required by a kernel is related to the block size that was chosen, but the mapping of threads to shared memory elements does not need to be one-to-one. For example, it may be desirable to use a 64x64 element shared memory array in a kernel, but because the maximum number of threads per block is 1024, it is not possible to launch a kernel with 64x64 threads per block. In such cases, kernels with 32x32 or 64x16 threads can be launched with each thread processing four elements of the shared memory array. The approach of using a single thread to process multiple elements of a shared memory array can be beneficial even if limits such as threads per block are not an issue. This is because some operations common to each element can be performed by the thread once, amortizing the cost over the number of shared memory elements processed by the thread.\nA useful technique to determine the sensitivity of performance to occupancy is through experimentation with the amount of dynamically allocated shared memory, as specified in the third parameter of the execution configuration. By simply increasing this parameter (without modifying the kernel), it is possible to effectively reduce the occupancy of the kernel and measure its effect on performance.\n11.5.\nConcurrent Kernel Execution\n\nAs described in\nAsynchronous and Overlapping Transfers with Computation\n, CUDA streams can be used to overlap kernel execution with data transfers. On devices that are capable of concurrent kernel execution, streams can also be used to execute multiple kernels simultaneously to more fully take advantage of the device’s multiprocessors. Whether a device has this capability is indicated by the\nconcurrentKernels\nfield of the\ncudaDeviceProp\nstructure (or listed in the output of the\ndeviceQuery\nCUDA Sample). Non-default streams (streams other than stream 0) are required for concurrent execution because kernel calls that use the default stream begin only after all preceding calls on the device (in any stream) have completed, and no operation on the device (in any stream) commences until they are finished.\nThe following example illustrates the basic technique. Because\nkernel1\nand\nkernel2\nare executed in different, non-default streams, a capable device can execute the kernels at the same time.\ncudaStreamCreate\n(\n&\nstream1\n);\ncudaStreamCreate\n(\n&\nstream2\n);\nkernel1\n<<<\ngrid\n,\nblock\n,\n0\n,\nstream1\n>>>\n(\ndata_1\n);\nkernel2\n<<<\ngrid\n,\nblock\n,\n0\n,\nstream2\n>>>\n(\ndata_2\n);\n11.6.\nMultiple contexts\n\nCUDA work occurs within a process space for a particular GPU known as a\ncontext\n. The context encapsulates kernel launches and memory allocations for that GPU as well as supporting constructs such as the page tables. The context is explicit in the CUDA Driver API but is entirely implicit in the CUDA Runtime API, which creates and manages contexts automatically.\nWith the CUDA Driver API, a CUDA application process can potentially create more than one context for a given GPU. If multiple CUDA application processes access the same GPU concurrently, this almost always implies multiple contexts, since a context is tied to a particular host process unless\nMulti-Process Service\nis in use.\nWhile multiple contexts (and their associated resources such as global memory allocations) can be allocated concurrently on a given GPU, only one of these contexts can execute work at any given moment on that GPU; contexts sharing the same GPU are time-sliced. Creating additional contexts incurs memory overhead for per-context data and time overhead for context switching. Furthermore, the need for context switching can reduce utilization when work from several contexts could otherwise execute concurrently (see also\nConcurrent Kernel Execution\n).\nTherefore, it is best to avoid multiple contexts per GPU within the same CUDA application. To assist with this, the CUDA Driver API provides methods to access and manage a special context on each GPU called the\nprimary context\n. These are the same contexts used implicitly by the CUDA Runtime when there is not already a current context for a thread.\n// When initializing the program/library\nCUcontext\nctx\n;\ncuDevicePrimaryCtxRetain\n(\n&\nctx\n,\ndev\n);\n// When the program/library launches work\ncuCtxPushCurrent\n(\nctx\n);\nkernel\n<<<\n...\n>>>\n(...);\ncuCtxPopCurrent\n(\n&\nctx\n);\n// When the program/library is finished with the context\ncuDevicePrimaryCtxRelease\n(\ndev\n);\nNote\nNVIDIA-SMI can be used to configure a GPU for\nexclusive process mode\n, which limits the number of contexts per GPU to one. This context can be current to as many threads as desired within the creating process, and\ncuDevicePrimaryCtxRetain\nwill fail if a non-primary context that was created with the CUDA driver API already exists on the device.\n12.\nInstruction Optimization\n\nAwareness of how instructions are executed often permits low-level optimizations that can be useful, especially in code that is run frequently (the so-called hot spot in a program). Best practices suggest that this optimization be performed after all higher-level optimizations have been completed.\n12.1.\nArithmetic Instructions\n\nTo maximize instruction throughput the application should:\nMinimize the use of arithmetic instructions with low throughput; this includes trading precision for speed when it does not affect the end result, such as using intrinsic instead of regular functions (intrinsic functions are listed in the\nCUDA C++ Programming Guide\n), single-precision instead of double-precision, or flushing denormalized numbers to zero;\nMinimize divergent warps caused by control flow instructions as detailed in\nControl Flow Instructions\nReduce the number of instructions, for example, by optimizing out synchronization points whenever possible as described in\nSynchronization Instruction\nor by using restricted pointers as described in the\nCUDA C++ Programming Guide\n.\nIn this section, throughputs are given in number of operations per clock cycle per multiprocessor. For a warp size of 32, one instruction corresponds to 32 operations, so if N is the number of operations per clock cycle, the instruction throughput is N/32 instructions per clock cycle.\nAll throughputs are for one multiprocessor. They must be multiplied by the number of multiprocessors in the device to get throughput for the whole device.\n12.1.1.\nThroughput of Native Arithmetic Instructions\n\nThe following table gives the throughputs of the arithmetic instructions that are natively supported in hardware for devices of various compute capabilities.\nNote\nThis table reflects the max theoretical throughput of the mentioned operations.\nIn some cases, these throughputs may only be achieved via specific sequences of\ninstructions that require special care when using a compiler.\nMost rows provide a\nPTX instruction\nas an example of lower-level instruction expected to achieve the listed throughput.\nThis PTX instruction may not be the only instructions able to perform the described operation(s).\nTable 5\nThroughput of Native Arithmetic Instructions. (Number of Results per Clock Cycle per Multiprocessor)\n\nCompute Capability\n7.5\n8.0\n8.6\n8.9\n9.0\n10.0\n12.0\n16-bit floating-point add, multiply, multiply-add (2-way SIMD):\nadd.f16x2\n64\n3\n128\n4\n64\n128\n64\n32-bit floating-point add, multiply, multiply-add:\nadd.f32\n64\n128\n64-bit floating-point add, multiply, multiply-add:\nadd.f64\n2\n32\n2\n64\n64\n2\n32-bit approximate floating-point reciprocal, reciprocal square root, base-2 logarithm, base 2 exponential, sine, cosine:\nlg2.approx.f32\n16\n5\n32-bit integer add, subtract:\nadd.s32\n128\n32-bit integer extended-precision add, extended-precision subtract, 3-operand addition: multiple PTX instructions\n64\n32-bit integer multiply, multiply-add, extended-precision multiply-add:\nmad.lo.s32\n64\n6\n32-bit integer shift:\nshl.b32\n64\n64-bit integer add:\nadd.s64\n32\n64\n32-bit integer compare, minimum, maximum:\nmin.s32\n64\n128\n32-bit integer bit reverse:\nnot.b32\n64\n32-bit bitwise AND, OR, XOR:\nxor.b32\n64\ncount of leading zeros, most significant non-sign bit:\nclz.b32\n16\npopulation count:\npopc.b32\n16\nwarp shuffle\n7\n:\nshfl.sync.idx.b32\n16\n32\nwarp vote\n8\n:\nvote.sync.ballot.b32\n64\n128\nsum of absolute difference:\nsad.s32\n64\n32\n2-way SIMD absolute difference: multiple PTX instructions\nMultiple instruct.\n4-way SIMD absolute difference:\nvabsdiff4.u32.u32.u32\n64\n9\n32\n9\nType conversions from 8-bit and 16-bit integer to 32-bit integer types:\ncvt.u32.u16\n64\nType conversions from and to 64-bit floating-point types:\ncvt.f64.f32\n2\n16\n2\n2\n16\n2\nType conversion between 16-bit and 32-bit floating-point types:\ncvt.f32.f16\n64\n10\nType conversion between 32-bit integer and 32-bit floating-point types:\ncvt.rn.f32.s32\n16\n64\n11\nDPX (32-bit and 2-way SIMD 16-bit): multiple PTX instructions\nMultiple instruct.\n64\n12\n64\n13\n3\nmultiple instructions for __nv_bfloat16\n4\n64 for __nv_bfloat16\n5\nfor reciprocal: approximate using\n__fdividef(1.F,\nx)\n6\n32 for extended-precision\n7\nassuming converged threads\n8\nassuming converged threads\n9\n(\n1\n,\n2\n)\n22 for signed version\n10\n32 for __nv_bfloat16->float, 16 for float->__half, 16 for float->__nv_bfloat16 (SM > 7.5), multiple instructions for float->__nv_bfloat16 (SM 7.5)\n11\n16 for float->32-bit integer type\n12\nmultiple instructions for intrinsics with boolean predicate outputs\n13\n128 for intrinsics with 2 operands, multiple instructions for intrinsics with boolean predicate outputs\nOther instructions and functions are implemented on top of the native instructions. The implementation may be different for devices of different compute capabilities, and the number of native instructions after compilation may fluctuate with every compiler version. For complicated functions, there can be multiple code paths depending on input.\ncuobjdump\ncan be used to inspect a particular implementation in a\ncubin\nobject.\nThe implementation of some functions are readily available on the CUDA header files (\nmath_functions.h\n,\ndevice_functions.h\n, …).\nIn general, code compiled with\n-ftz=true\n(denormalized numbers are flushed to zero) tends to have higher performance than code compiled with\n-ftz=false\n. Similarly, code compiled with\n-prec-div=false\n(less precise division) tends to have higher performance code than code compiled with\n-prec-div=true\n, and code compiled with\n-prec-sqrt=false\n(less precise square root) tends to have higher performance than code compiled with\n-prec-sqrt=true\n. The nvcc user manual describes these compilation flags in more details.\nSingle-Precision Floating-Point Division\n__fdividef(x,\ny)\n(see the\nCUDA C++ Programming Guide\n) provides faster single-precision floating-point division than the division operator.\nSingle-Precision Floating-Point Reciprocal Square Root\nTo preserve IEEE-754 semantics the compiler can optimize\n1.0/sqrtf()\ninto\nrsqrtf()\nonly when both reciprocal and square root are approximate, (i.e., with\n-prec-div=false\nand\n-prec-sqrt=false\n). It is therefore recommended to invoke\nrsqrtf()\ndirectly where desired.\nSingle-Precision Floating-Point Square Root\nSingle-precision floating-point square root is implemented as a reciprocal square root followed by a reciprocal instead of a reciprocal square root followed by a multiplication so that it gives correct results for 0 and infinity.\nSine and Cosine\nsinf(x)\n,\ncosf(x)\n,\ntanf(x)\n,\nsincosf(x)\n, and corresponding double-precision instructions are much more expensive and even more so if the argument x is large in magnitude.\nMore precisely, the argument reduction code (see the\nCUDA C++ Programming Guide\nfor implementation) comprises two code paths referred to as the fast path and the slow path, respectively.\nThe fast path is used for arguments sufficiently small in magnitude and essentially consists of a few multiply-add operations. The slow path is used for arguments large in magnitude and consists of lengthy computations required to achieve correct results over the entire argument range.\nAt present, the argument reduction code for the trigonometric functions selects the fast path for arguments whose magnitude is less than\n105615.0f\nfor the single-precision functions, and less than\n2147483648.0\nfor the double-precision functions.\nAs the slow path requires more registers than the fast path, an attempt has been made to reduce register pressure in the slow path by storing some intermediate variables in local memory, which may affect performance because of local memory high latency and bandwidth (see the\nCUDA C++ Programming Guide\n). At present, 28 bytes of local memory are used by single-precision functions, and 44 bytes are used by double-precision functions. However, the exact amount is subject to change.\nDue to the lengthy computations and use of local memory in the slow path, the throughput of these trigonometric functions is lower by one order of magnitude when the slow path reduction is required as opposed to the fast path reduction.\nInteger Arithmetic\nInteger division and modulo operation are costly as they compile to up to 20 instructions. They can be replaced with bitwise operations in some cases: If\nn\nis a power of 2, (\ni/n\n) is equivalent to\n(i>>log2(n))\nand\n(i%n)\nis equivalent to (\ni&(n-1)\n); the compiler will perform these conversions if\nn\nis literal.\n__brev\nand\n__popc\nmap to a single instruction and\n__brevll\nand\n__popcll\nto a few instructions.\n__[u]mul24\nare legacy intrinsic functions that no longer have any reason to be used.\nHalf Precision Arithmetic\nIn order to achieve good performance for 16-bit precision floating-point add, multiply or multiply-add, it is recommended that the\nhalf2\ndatatype is used for\nhalf\nprecision and\n__nv_bfloat162\nbe used for\n__nv_bfloat16\nprecision. Vector intrinsics (for example,\n__hadd2\n,\n__hsub2\n,\n__hmul2\n,\n__hfma2\n) can then be used to do two operations in a single instruction. Using\nhalf2\nor\n__nv_bfloat162\nin place of two calls using\nhalf\nor\n__nv_bfloat16\nmay also help performance of other intrinsics, such as warp shuffles.\nThe intrinsic\n__halves2half2\nis provided to convert two\nhalf\nprecision values to the\nhalf2\ndatatype.\nThe intrinsic\n__halves2bfloat162\nis provided to convert two\n__nv_bfloat\nprecision values to the\n__nv_bfloat162\ndatatype.\nType Conversion\nSometimes, the compiler must insert conversion instructions, introducing additional execution cycles. This is the case for:\nFunctions operating on variables of type\nchar\nor\nshort\nwhose operands generally need to be converted to\nint\n,\nDouble-precision floating-point constants (i.e., those constants defined without any type suffix) used as input to single-precision floating-point computations (as mandated by C/C++ standards).\nThis last case can be avoided by using single-precision floating-point constants, defined with an\nf\nsuffix such as\n3.141592653589793f\n,\n1.0f\n,\n0.5f\n.\n12.1.2.\nControl Flow Instructions\n\nAny flow control instruction (\nif\n,\nswitch\n,\ndo\n,\nfor\n,\nwhile\n) can significantly impact the effective instruction throughput by causing threads of the same warp to diverge (i.e., to follow different execution paths). If this happens, the different executions paths have to be serialized, increasing the total number of instructions executed for this warp.\nTo obtain best performance in cases where the control flow depends on the thread ID, the controlling condition should be written so as to minimize the number of divergent warps. This is possible because the distribution of the warps across the block is deterministic as mentioned in the\nCUDA C++ Programming Guide\n. A trivial example is when the controlling condition only depends on (\nthreadIdx\n/\nwarpSize\n) where\nwarpSize\nis the warp size. In this case, no warp diverges since the controlling condition is perfectly aligned with the warps.\nSometimes, the compiler may unroll loops or it may optimize out short\nif\nor\nswitch\nblocks by using branch predication instead, as detailed below. In these cases, no warp can ever diverge. The programmer can also control loop unrolling using the\n#pragma\nunroll\ndirective (see the\nCUDA C++ Programming Guide\n).\nWhen using branch predication none of the instructions whose execution depends on the controlling condition gets skipped. Instead, each of them is associated with a per-thread condition code or predicate that is set to true or false based on the controlling condition and although each of these instructions gets scheduled for execution, only the instructions with a true predicate are actually executed. Instructions with a false predicate do not write results, and also do not evaluate addresses or read operands.\n12.1.3.\nSynchronization Instruction\n\nThroughput for\n__syncthreads()\nis 32 operations per clock cycle for devices of compute capability 6.0, 16 operations per clock cycle for devices of compute capability 7.x as well as 8.x and 64 operations per clock cycle for devices of compute capability 5.x, 6.1 and 6.2.\nNote that\n__syncthreads()\ncan impact performance by forcing the multiprocessor to idle as detailed in the\nCUDA C++ Programming Guide\n.\n12.1.4.\nDivision Modulo Operations\n\nNote\nLow Priority:\nUse shift operations to avoid expensive division and modulo calculations.\nInteger division and modulo operations are particularly costly and should be avoided or replaced with bitwise operations whenever possible: If\n\\(n\\)\nis a power of 2, (\n\\(i/n\\)\n) is equivalent to (\n\\(i \\gg {log2}(n)\\)\n) and (\n\\(i\\% n\\)\n) is equivalent to (\n\\(i\\&\\left( {n - 1} \\right)\\)\n).\nThe compiler will perform these conversions if n is literal. (For further information, refer to Performance Guidelines in the\nCUDA C++ Programming Guide\n).\n12.1.5.\nLoop Counters Signed vs. Unsigned\n\nNote\nLow Medium Priority:\nUse signed integers rather than unsigned integers as loop counters.\nIn the C language standard, unsigned integer overflow semantics are well defined, whereas signed integer overflow causes undefined results. Therefore, the compiler can optimize more aggressively with signed arithmetic than it can with unsigned arithmetic. This is of particular note with loop counters: since it is common for loop counters to have values that are always positive, it may be tempting to declare the counters as unsigned. For slightly better performance, however, they should instead be declared as signed.\nFor example, consider the following code:\nfor\n(\ni\n=\n0\n;\ni\n<\nn\n;\ni\n++\n)\n{\nout\n[\ni\n]\n=\nin\n[\noffset\n+\nstride\n*\ni\n];\n}\nHere, the sub-expression\nstride*i\ncould overflow a 32-bit integer, so if\ni\nis declared as unsigned, the overflow semantics prevent the compiler from using some optimizations that might otherwise have applied, such as strength reduction. If instead\ni\nis declared as signed, where the overflow semantics are undefined, the compiler has more leeway to use these optimizations.\n12.1.6.\nReciprocal Square Root\n\nThe reciprocal square root should always be invoked explicitly as\nrsqrtf()\nfor single precision and\nrsqrt()\nfor double precision. The compiler optimizes\n1.0f/sqrtf(x)\ninto\nrsqrtf()\nonly when this does not violate IEEE-754 semantics.\n12.1.7.\nOther Arithmetic Instructions\n\nNote\nLow Priority:\nAvoid automatic conversion of doubles to floats.\nThe compiler must on occasion insert conversion instructions, introducing additional execution cycles. This is the case for:\nFunctions operating on\nchar\nor\nshort\nwhose operands generally need to be converted to an\nint\nDouble-precision floating-point constants (defined without any type suffix) used as input to single-precision floating-point computations\nThe latter case can be avoided by using single-precision floating-point constants, defined with an\nf\nsuffix such as\n3.141592653589793f\n,\n1.0f\n,\n0.5f\n.\nFor single-precision code, use of the float type and the single-precision math functions are highly recommended.\nIt should also be noted that the CUDA math library’s complementary error function,\nerfcf()\n, is particularly fast with full single-precision accuracy.\n12.1.8.\nExponentiation With Small Fractional Arguments\n\nFor some fractional exponents, exponentiation can be accelerated significantly compared to the use of\npow()\nby using square roots, cube roots, and their inverses. For those exponentiations where the exponent is not exactly representable as a floating-point number, such as 1/3, this can also provide much more accurate results, as use of\npow()\nmagnifies the initial representational error.\nThe formulas in the table below are valid for\nx\n>=\n0,\nx\n!=\n-0\n, that is,\nsignbit(x)\n==\n0\n.\nTable 6\nFormulae for exponentiation by small fractions\n\nComputation\nFormula\nx\n1/9\nr\n=\nrcbrt(rcbrt(x))\nx\n-1/9\nr\n=\ncbrt(rcbrt(x))\nx\n1/6\nr\n=\nrcbrt(rsqrt(x))\nx\n-1/6\nr\n=\nrcbrt(sqrt(x))\nx\n1/4\nr\n=\nrsqrt(rsqrt(x))\nx\n-1/4\nr\n=\nsqrt(rsqrt(x))\nx\n1/3\nr\n=\ncbrt(x)\nx\n-1/3\nr\n=\nrcbrt(x)\nx\n1/2\nr\n=\nsqrt(x)\nx\n-1/2\nr\n=\nrsqrt(x)\nx\n2/3\nr\n=\ncbrt(x);\nr\n=\nr*r\nx\n-2/3\nr\n=\nrcbrt(x);\nr\n=\nr*r\nx\n3/4\nr\n=\nsqrt(x);\nr\n=\nr*sqrt(r)\nx\n-3/4\nr\n=\nrsqrt(x);\nr\n=\nr*sqrt(r)\nx\n7/6\nr\n=\nx*rcbrt(rsqrt(x))\nx\n-7/6\nr\n=\n(1/x)\n*\nrcbrt(sqrt(x))\nx\n5/4\nr\n=\nx*rsqrt(rsqrt(x))\nx\n-5/4\nr\n=\n(1/x)*sqrt(rsqrt(x))\nx\n4/3\nr\n=\nx*cbrt(x)\nx\n-4/3\nr\n=\n(1/x)*rcbrt(x)\nx\n3/2\nr\n=\nx*sqrt(x)\nx\n-3/2\nr\n=\n(1/x)*rsqrt(x)\n12.1.9.\nMath Libraries\n\nNote\nMedium Priority:\nUse the fast math library whenever speed trumps precision.\nTwo types of runtime math operations are supported. They can be distinguished by their names: some have names with prepended underscores, whereas others do not (e.g.,\n__functionName()\nversus\nfunctionName()\n). Functions following the\n__functionName()\nnaming convention map directly to the hardware level. They are faster but provide somewhat lower accuracy (e.g.,\n__sinf(x)\nand\n__expf(x)\n). Functions following\nfunctionName()\nnaming convention are slower but have higher accuracy (e.g.,\nsinf(x)\nand\nexpf(x)\n). The throughput of\n__sinf(x)\n,\n__cosf(x)\n, and\n__expf(x)\nis much greater than that of\nsinf(x)\n,\ncosf(x)\n, and\nexpf(x)\n. The latter become even more expensive (about an order of magnitude slower) if the magnitude of the argument\nx\nneeds to be reduced. Moreover, in such cases, the argument-reduction code uses local memory, which can affect performance even more because of the high latency of local memory. More details are available in the\nCUDA C++ Programming Guide\n.\nNote also that whenever sine and cosine of the same argument are computed, the\nsincos\nfamily of instructions should be used to optimize performance:\n__sincosf()\nfor single-precision fast math (see next paragraph)\nsincosf()\nfor regular single-precision\nsincos()\nfor double precision\nThe\n-use_fast_math\ncompiler option of\nnvcc\ncoerces every\nfunctionName()\ncall to the equivalent\n__functionName()\ncall. It also disables single-precision denormal support and lowers the precision of single-precision division in general. This is an aggressive optimization that can both reduce numerical accuracy and alter special case handling. A more robust approach is to selectively introduce calls to fast intrinsic functions only if merited by performance gains and where altered behavior can be tolerated. Note this switch is effective only on single-precision floating point.\nNote\nMedium Priority:\nPrefer faster, more specialized math functions over slower, more general ones when possible.\nFor small integer powers (e.g.,\nx2\nor\nx3\n), explicit multiplication is almost certainly faster than the use of general exponentiation routines such as\npow()\n. While compiler optimization improvements continually seek to narrow this gap, explicit multiplication (or the use of an equivalent purpose-built inline function or macro) can have a significant advantage. This advantage is increased when several powers of the same base are needed (e.g., where both\nx2\nand\nx5\nare calculated in close proximity), as this aids the compiler in its common sub-expression elimination (CSE) optimization.\nFor exponentiation using base 2 or 10, use the functions\nexp2()\nor\nexpf2()\nand\nexp10()\nor\nexpf10()\nrather than the functions\npow()\nor\npowf()\n. Both\npow()\nand\npowf()\nare heavy-weight functions in terms of register pressure and instruction count due to the numerous special cases arising in general exponentiation and the difficulty of achieving good accuracy across the entire ranges of the base and the exponent. The functions\nexp2()\n,\nexp2f()\n,\nexp10()\n, and\nexp10f()\n, on the other hand, are similar to\nexp()\nand\nexpf()\nin terms of performance, and can be as much as ten times faster than their\npow()\n/\npowf()\nequivalents.\nFor exponentiation with an exponent of 1/3, use the\ncbrt()\nor\ncbrtf()\nfunction rather than the generic exponentiation functions\npow()\nor\npowf()\n, as the former are significantly faster than the latter. Likewise, for exponentation with an exponent of -1/3, use\nrcbrt()\nor\nrcbrtf()\n.\nReplace\nsin(π*<expr>)\nwith\nsinpi(<expr>)\n,\ncos(π*<expr>)\nwith\ncospi(<expr>)\n, and\nsincos(π*<expr>)\nwith\nsincospi(<expr>)\n. This is advantageous with regard to both accuracy and performance. As a particular example, to evaluate the sine function in degrees instead of radians, use\nsinpi(x/180.0)\n. Similarly, the single-precision functions\nsinpif()\n,\ncospif()\n, and\nsincospif()\nshould replace calls to\nsinf()\n,\ncosf()\n, and\nsincosf()\nwhen the function argument is of the form\nπ*<expr>\n. (The performance advantage\nsinpi()\nhas over\nsin()\nis due to simplified argument reduction; the accuracy advantage is because\nsinpi()\nmultiplies by\nπ\nonly implicitly, effectively using an infinitely precise mathematical\nπ\nrather than a single- or double-precision approximation thereof.)\n12.1.10.\nPrecision-related Compiler Flags\n\nBy default, the\nnvcc\ncompiler generates IEEE-compliant code, but it also provides options to generate code that somewhat less accurate but faster:\n-ftz=true\n(denormalized numbers are flushed to zero)\n-prec-div=false\n(less precise division)\n-prec-sqrt=false\n(less precise square root)\nAnother, more aggressive, option is\n-use_fast_math\n, which coerces every\nfunctionName()\ncall to the equivalent\n__functionName()\ncall. This makes the code run faster at the cost of diminished precision and accuracy. See\nMath Libraries\n.\n12.2.\nMemory Instructions\n\nNote\nHigh Priority:\nMinimize the use of global memory. Prefer shared memory access where possible.\nMemory instructions include any instruction that reads from or writes to shared, local, or global memory. When accessing uncached local or global memory, there are hundreds of clock cycles of memory latency.\nAs an example, the assignment operator in the following sample code has a high throughput, but, crucially, there is a latency of hundreds of clock cycles to read data from global memory:\n__shared__\nfloat\nshared\n[\n32\n];\n__device__\nfloat\ndevice\n[\n32\n];\nshared\n[\nthreadIdx\n.\nx\n]\n=\ndevice\n[\nthreadIdx\n.\nx\n];\nMuch of this global memory latency can be hidden by the thread scheduler if there are sufficient independent arithmetic instructions that can be issued while waiting for the global memory access to complete. However, it is best to avoid accessing global memory whenever possible.\n13.\nControl Flow\n\n13.1.\nBranching and Divergence\n\nNote\nHigh Priority:\nAvoid different execution paths within the same warp.\nFlow control instructions (\nif\n,\nswitch\n,\ndo\n,\nfor\n,\nwhile\n) can significantly affect the instruction throughput by causing threads of the same warp to diverge; that is, to follow different execution paths. If this happens, the different execution paths must be executed separately; this increases the total number of instructions executed for this warp.\nTo obtain best performance in cases where the control flow depends on the thread ID, the controlling condition should be written so as to minimize the number of divergent warps.\nThis is possible because the distribution of the warps across the block is deterministic as mentioned in SIMT Architecture of the CUDA C++ Programming Guide. A trivial example is when the controlling condition depends only on (\nthreadIdx\n/\nWSIZE\n) where\nWSIZE\nis the warp size.\nIn this case, no warp diverges because the controlling condition is perfectly aligned with the warps.\nFor branches including just a few instructions, warp divergence generally results in marginal performance losses. For example, the compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Threads with a false predicate do not write results, and also do not evaluate addresses or read operands.\nStarting with the Volta architecture, Independent Thread Scheduling allows a warp to remain diverged outside of the data-dependent conditional block. An explicit\n__syncwarp()\ncan be used to guarantee that the warp has reconverged for subsequent instructions.\n13.2.\nBranch Predication\n\nNote\nLow Priority:\nMake it easy for the compiler to use branch predication in lieu of loops or control statements.\nSometimes, the compiler may unroll loops or optimize out\nif\nor\nswitch\nstatements by using branch predication instead. In these cases, no warp can ever diverge. The programmer can also control loop unrolling using\n#pragma unroll\nFor more information on this pragma, refer to the CUDA C++ Programming Guide.\nWhen using branch predication, none of the instructions whose execution depends on the controlling condition is skipped. Instead, each such instruction is associated with a per-thread condition code or predicate that is set to true or false according to the controlling condition. Although each of these instructions is scheduled for execution, only the instructions with a true predicate are actually executed. Instructions with a false predicate do not write results, and they also do not evaluate addresses or read operands.\nThe compiler replaces a branch instruction with predicated instructions only if the number of instructions controlled by the branch condition is less than or equal to a certain threshold.\n14.\nDeploying CUDA Applications\n\nHaving completed the GPU acceleration of one or more components of the application it is possible to compare the outcome with the original expectation. Recall that the initial\nassess\nstep allowed the developer to determine an upper bound for the potential speedup attainable by accelerating given hotspots.\nBefore tackling other hotspots to improve the total speedup, the developer should consider taking the partially parallelized implementation and carry it through to production. This is important for a number of reasons; for example, it allows the user to profit from their investment as early as possible (the speedup may be partial but is still valuable), and it minimizes risk for the developer and the user by providing an evolutionary rather than revolutionary set of changes to the application.\n15.\nUnderstanding the Programming Environment\n\nWith each generation of NVIDIA processors, new features are added to the GPU that CUDA can leverage. Consequently, it’s important to understand the characteristics of the architecture.\nProgrammers should be aware of two version numbers. The first is the\ncompute capability\n, and the second is the version number of the CUDA Runtime and CUDA Driver APIs.\n15.1.\nCUDA Compute Capability\n\nThe\ncompute capability\ndescribes the features of the hardware and reflects the set of instructions supported by the device as well as other specifications, such as the maximum number of threads per block and the number of registers per multiprocessor. Higher compute capability versions are supersets of lower (that is, earlier) versions, so they are backward compatible.\nThe compute capability of the GPU in the device can be queried programmatically as illustrated in the\ndeviceQuery\nCUDA Sample. The output for that program is shown in\nFigure 16\n. This information is obtained by calling\ncudaGetDeviceProperties()\nand accessing the information in the structure it returns.\nFigure 16\nSample CUDA configuration data reported by deviceQuery\n\nThe major and minor revision numbers of the compute capability are shown on the seventh line of\nFigure 16\n. Device 0 of this system has compute capability 7.0.\nMore details about the compute capabilities of various GPUs are in CUDA-Enabled GPUs and Compute Capabilities of the CUDA C++ Programming Guide. In particular, developers should note the number of multiprocessors on the device, the number of registers and the amount of memory available, and any special capabilities of the device.\n15.2.\nAdditional Hardware Data\n\nCertain hardware features are not described by the compute capability. For example, the ability to overlap kernel execution with asynchronous data transfers between the host and the device is available on most but not all GPUs irrespective of the compute capability. In such cases, call\ncudaGetDeviceProperties()\nto determine whether the device is capable of a certain feature. For example, the\nasyncEngineCount\nfield of the device property structure indicates whether overlapping kernel execution and data transfers is possible (and, if so, how many concurrent transfers are possible); likewise, the\ncanMapHostMemory\nfield indicates whether zero-copy data transfers can be performed.\n15.3.\nWhich Compute Capability Target\n\nTo target specific versions of NVIDIA hardware and CUDA software, use the\n-arch\n,\n-code\n, and\n-gencode\noptions of\nnvcc\n. Code that uses the warp shuffle operation, for example, must be compiled with\n-arch=sm_30\n(or higher compute capability).\nSee\nBuilding for Maximum Compatibility\nfor further discussion of the flags used for building code for multiple generations of CUDA-capable device simultaneously.\n15.4.\nCUDA Runtime\n\nThe host runtime component of the CUDA software environment can be used only by host functions. It provides functions to handle the following:\nDevice management\nContext management\nMemory management\nCode module management\nExecution control\nTexture reference management\nInteroperability with OpenGL and Direct3D\nAs compared to the lower-level CUDA Driver API, the CUDA Runtime greatly eases device management by providing implicit initialization, context management, and device code module management. The C++ host code generated by\nnvcc\nutilizes the CUDA Runtime, so applications that link to this code will depend on the CUDA Runtime; similarly, any code that uses the\ncuBLAS\n,\ncuFFT\n, and other CUDA Toolkit libraries will also depend on the CUDA Runtime, which is used internally by these libraries.\nThe functions that make up the CUDA Runtime API are explained in the CUDA Toolkit Reference Manual.\nThe CUDA Runtime handles kernel loading and setting up kernel parameters and launch configuration before the kernel is launched. The implicit driver version checking, code initialization, CUDA context management, CUDA module management (cubin to function mapping), kernel configuration, and parameter passing are all performed by the CUDA Runtime.\nIt comprises two principal parts:\nA C-style function interface (\ncuda_runtime_api.h\n).\nC++-style convenience wrappers (\ncuda_runtime.h\n) built on top of the C-style functions.\nFor more information on the Runtime API, refer to CUDA Runtime of the CUDA C++ Programming Guide.\n16.\nCUDA Compatibility Developer’s Guide\n\nCUDA Toolkit is released on a monthly release cadence to deliver new features, performance improvements, and critical bug fixes. CUDA compatibility allows users to update the latest CUDA Toolkit software (including the compiler, libraries, and tools) without requiring update to the entire driver stack.\nThe CUDA software environment consists of three parts:\nCUDA Toolkit (libraries, CUDA runtime and developer tools) - SDK for developers to build CUDA applications.\nCUDA driver - User-mode driver component used to run CUDA applications (e.g. libcuda.so on Linux systems).\nNVIDIA GPU device driver - Kernel-mode driver component for NVIDIA GPUs.\nOn Linux systems, the CUDA driver and kernel mode components are delivered together in the NVIDIA display driver package. This is shown in Figure 1.\nFigure 17\nComponents of CUDA\n\nThe CUDA compiler (nvcc), provides a way to handle CUDA and non-CUDA code (by splitting and steering compilation), along with the CUDA runtime, is part of the CUDA compiler toolchain. The CUDA Runtime API provides developers with high-level C++ interface for simplified management of devices, kernel executions etc., While the CUDA driver API provides (\nCUDA Driver API\n) a low-level programming interface for applications to target NVIDIA hardware.\nBuilt on top of these technologies are CUDA libraries, some of which are included in the CUDA Toolkit, while others such as cuDNN may be released independently of the CUDA Toolkit.\n16.1.\nCUDA Toolkit Versioning\n\nStarting with CUDA 11, the toolkit versions are based on an industry-standard semantic versioning scheme: .X.Y.Z, where:\n.X stands for the major version - APIs have changed and binary compatibility is broken.\n.Y stands for the minor version - Introduction of new APIs, deprecation of old APIs, and source compatibility might be broken but binary compatibility is maintained.\n.Z stands for the release/patch version - new updates and patches will increment this.\nEach component in the toolkit is recommended to be semantically versioned. From CUDA 11.3 NVRTC is also semantically versioned. We will note some of them later on in the document. The versions of the components in the toolkit are available in this\ntable\n.\nCompatibility of the CUDA platform is thus intended to address a few scenarios:\nNVIDIA driver upgrades to systems with GPUs running in production for enterprises or datacenters can be complex and may need advance planning. Delays in rolling out new NVIDIA drivers could mean that users of such systems may not have access to new features available in CUDA releases. Not requiring driver updates for new CUDA releases can mean that new versions of the software can be made available faster to users.\nMany software libraries and applications built on top of CUDA (e.g. math libraries or deep learning frameworks) do not have a direct dependency on the CUDA runtime, compiler or driver. In such cases, users or developers can still benefit from not having to upgrade the entire CUDA Toolkit or driver to use these libraries or frameworks.\nUpgrading dependencies is error-prone and time consuming, and in some corner cases, can even change the semantics of a program. Constantly recompiling with the latest CUDA Toolkit means forcing upgrades on the end-customers of an application product. Package managers facilitate this process but unexpected issues can still arise and if a bug is found, it necessitates a repeat of the above upgrade process.\nCUDA supports several compatibility choices:\nFirst introduced in CUDA 10, the\nCUDA Forward Compatible Upgrade\nis designed to allow users to get access to new CUDA features and run applications built with new CUDA releases on systems with older installations of the NVIDIA datacenter driver.\nFirst introduced in CUDA 11.1,\nCUDA Enhanced Compatibility\nprovides two benefits:\nBy leveraging semantic versioning across components in the CUDA Toolkit, an application can be built for one CUDA minor release (for example 11.1) and work across all future minor releases within the major family (i.e. 11.x).\nThe CUDA runtime has relaxed the minimum driver version check and thus no longer requires a driver upgrade when moving to a new minor release.\nThe CUDA driver ensures backward Binary Compatibility is maintained for compiled CUDA applications. Applications compiled with CUDA toolkit versions as old as 3.2 will run on newer drivers.\n16.2.\nSource Compatibility\n\nWe define source compatibility as a set of guarantees provided by the library, where a well-formed application built against a specific version of the library (using the SDK) will continue to build and run without errors when a newer version of the SDK is installed.\nBoth the CUDA driver and the CUDA runtime are not source compatible across the different SDK releases. APIs can be deprecated and removed. Therefore, an application that compiled successfully on an older version of the toolkit may require changes in order to compile against a newer version of the toolkit.\nDevelopers are notified through deprecation and documentation mechanisms of any current or upcoming changes. This does not mean that application binaries compiled using an older toolkit will not be supported anymore. Application binaries rely on CUDA Driver API interface and even though the CUDA Driver API itself may also have changed across toolkit versions, CUDA guarantees Binary Compatibility of the CUDA Driver API interface.\n16.3.\nBinary Compatibility\n\nWe define binary compatibility as a set of guarantees provided by the library, where an application targeting the said library will continue to work when dynamically linked against a different version of the library.\nThe CUDA Driver API has a versioned C-style ABI, which guarantees that applications that were running against an older driver (for example CUDA 3.2) will still run and function correctly against a modern driver (for example one shipped with CUDA 11.0). This means that even though an application source might need to be changed if it has to be recompiled against a newer CUDA Toolkit in order to use the newer features, replacing the driver components installed in a system with a newer version will always support existing applications and its functions.\nThe CUDA Driver API thus is binary-compatible (the OS loader can pick up a newer version and the application continues to work) but not source-compatible (rebuilding your application against a newer SDK might require source changes).\nFigure 18\nCUDA Toolkit and Minimum Driver Versions\n\nBefore we proceed further on this topic, it’s important for developers to understand the concept of Minimum Driver Version and how that may affect them.\nEach version of the CUDA Toolkit (and runtime) requires a minimum version of the NVIDIA driver. Applications compiled against a CUDA Toolkit version will only run on systems with the specified minimum driver version for that toolkit version. Prior to CUDA 11.0, the minimum driver version for a toolkit was the same as the driver shipped with that version of the CUDA Toolkit.\nSo, when an application is built with CUDA 11.0, it can only run on a system with an R450 or later driver. If such an application is run on a system with the R418 driver installed, CUDA initialization will return an error as can be seen in the example below.\nIn this example, the deviceQuery sample is compiled with CUDA 11.1 and is run on a system with R418. In this scenario, CUDA initialization returns an error due to the minimum driver requirement.\nubuntu@:~/samples/1_Utilities/deviceQuery\n$ make\n/usr/local/cuda-11.1/bin/nvcc -ccbin g++ -I../../common/inc -m64 -gencode arch=compute_35,code=sm_35 -gencode arch=compute_37,code=sm_37 -gencode arch=compute_50,code=sm_50 -gencode arch=compute_52,code=sm_52 -gencode arch=compute_60,code=sm_60 -gencode arch=compute_61,code=sm_61 -gencode arch=compute_70,code=sm_70 -gencode arch=compute_75,code=sm_75 -gencode arch=compute_80,code=sm_80 -gencode arch=compute_86,code=sm_86 -gencode arch=compute_86,code=compute_86 -o deviceQuery.o -c deviceQuery.cpp\n/usr/local/cuda-11.1/bin/nvcc -ccbin g++ -m64 -gencode arch=compute_35,code=sm_35 -gencode arch=compute_37,code=sm_37 -gencode arch=compute_50,code=sm_50 -gencode arch=compute_52,code=sm_52 -gencode arch=compute_60,code=sm_60 -gencode arch=compute_61,code=sm_61 -gencode arch=compute_70,code=sm_70 -gencode arch=compute_75,code=sm_75 -gencode arch=compute_80,code=sm_80 -gencode arch=compute_86,code=sm_86 -gencode arch=compute_86,code=compute_86 -o deviceQuery deviceQuery.o\n$ nvidia-smi\n+-----------------------------------------------------------------------------+\n| NVIDIA-SMI 418.165.02   Driver Version: 418.165.02   CUDA Version: 10.1     |\n|-------------------------------+----------------------+----------------------+\n| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |\n| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |\n|===============================+======================+======================|\n|   0  Tesla T4            On   | 00000000:00:1E.0 Off |                    0 |\n| N/A   42C    P0    28W /  70W |      0MiB / 15079MiB |      0%      Default |\n+-------------------------------+----------------------+----------------------+\n+-----------------------------------------------------------------------------+\n| Processes:                                                       GPU Memory |\n|  GPU       PID   Type   Process name                             Usage      |\n|=============================================================================|\n|  No running processes found                                                 |\n+-----------------------------------------------------------------------------+\n$ samples/bin/x86_64/linux/release/deviceQuery\nsamples/bin/x86_64/linux/release/deviceQuery Starting...\nCUDA Device Query (Runtime API) version (CUDART static linking)\ncudaGetDeviceCount returned 3\n-> initialization error\nResult = FAIL\nRefer to the\nCUDA Toolkit Release Notes\nfor details for the minimum driver version and the version of the driver shipped with the toolkit.\n16.3.1.\nCUDA Binary (cubin) Compatibility\n\nA slightly related but important topic is one of application binary compatibility across GPU architectures in CUDA.\nCUDA C++ provides a simple path for users familiar with the C++ programming language to easily write programs for execution by the device. Kernels can be written using the CUDA instruction set architecture, called PTX, which is described in the PTX reference manual. It is however usually more effective to use a high-level programming language such as C++. In both cases, kernels must be compiled into binary code by nvcc (called cubins) to execute on the device.\nThe cubins are architecture-specific. Binary compatibility for cubins is guaranteed from one compute capability minor revision to the next one, but not from one compute capability minor revision to the previous one or across major compute capability revisions. In other words, a cubin object generated for compute capability\nX.y\nwill only execute on devices of compute capability\nX.z\nwhere\nz≥y\n.\nTo execute code on devices of specific compute capability, an application must load binary or PTX code that is compatible with this compute capability. For portability, that is, to be able to execute code on future GPU architectures with higher compute capability (for which no binary code can be generated yet), an application must load PTX code that will be just-in-time compiled by the NVIDIA driver for these future devices.\nMore information on cubins, PTX and application compatibility can be found in the\nCUDA C++ Programming Guide\n.\n16.4.\nCUDA Compatibility Across Minor Releases\n\nBy leveraging the semantic versioning, starting with CUDA 11, components in the CUDA Toolkit will remain binary compatible across the minor versions of the toolkit. In order to maintain binary compatibility across minor versions, the CUDA runtime no longer bumps up the minimum driver version required for every minor release - this only happens when a major release is shipped.\nOne of the main reasons a new toolchain requires a new minimum driver is to handle the JIT compilation of PTX code and the JIT linking of binary code.\nIn this section, we will review the usage patterns that may require new user workflows when taking advantage of the compatibility features of the CUDA platform.\n16.4.1.\nExisting CUDA Applications within Minor Versions of CUDA\n\n$\nnvidia\n-\nsmi\n+-----------------------------------------------------------------------------+\n|\nNVIDIA\n-\nSMI\n450.80.02\nDriver\nVersion\n:\n450.80.02\nCUDA\nVersion\n:\n11.0\n|\n|-------------------------------+----------------------+----------------------+\n|\nGPU\nName\nPersistence\n-\nM\n|\nBus\n-\nId\nDisp\n.\nA\n|\nVolatile\nUncorr\n.\nECC\n|\n|\nFan\nTemp\nPerf\nPwr\n:\nUsage\n/\nCap\n|\nMemory\n-\nUsage\n|\nGPU\n-\nUtil\nCompute\nM\n.\n|\n|\n|\n|\nMIG\nM\n.\n|\n|===============================+======================+======================|\n|\n0\nTesla\nT4\nOn\n|\n00000000\n:\n00\n:\n1\nE\n.0\nOff\n|\n0\n|\n|\nN\n/\nA\n39\nC\nP8\n9\nW\n/\n70\nW\n|\n0\nMiB\n/\n15109\nMiB\n|\n0\n%\nDefault\n|\n|\n|\n|\nN\n/\nA\n|\n+-------------------------------+----------------------+----------------------+\n+-----------------------------------------------------------------------------+\n|\nProcesses\n:\n|\n|\nGPU\nGI\nCI\nPID\nType\nProcess\nname\nGPU\nMemory\n|\n|\nID\nID\nUsage\n|\n|=============================================================================|\n|\nNo\nrunning\nprocesses\nfound\n|\n+-----------------------------------------------------------------------------+\nWhen our CUDA 11.1 application (i.e. cudart 11.1 is statically linked) is run on the system, we see that it runs successfully even when the driver reports a 11.0 version - that is, without requiring the driver or other toolkit components to be updated on the system.\n$\nsamples\n/\nbin\n/\nx86_64\n/\nlinux\n/\nrelease\n/\ndeviceQuery\nsamples\n/\nbin\n/\nx86_64\n/\nlinux\n/\nrelease\n/\ndeviceQuery\nStarting\n...\nCUDA\nDevice\nQuery\n(\nRuntime\nAPI\n)\nversion\n(\nCUDART\nstatic\nlinking\n)\nDetected\n1\nCUDA\nCapable\ndevice\n(\ns\n)\nDevice\n0\n:\n\"Tesla T4\"\nCUDA\nDriver\nVersion\n/\nRuntime\nVersion\n11.0\n/\n11.1\nCUDA\nCapability\nMajor\n/\nMinor\nversion\nnumber\n:\n7.5\n...\n<\nsnip\n>\n...\ndeviceQuery\n,\nCUDA\nDriver\n=\nCUDART\n,\nCUDA\nDriver\nVersion\n=\n11.0\n,\nCUDA\nRuntime\nVersion\n=\n11.1\n,\nNumDevs\n=\n1\nResult\n=\nPASS\nBy using new CUDA versions, users can benefit from new CUDA programming model APIs, compiler optimizations and math library features.\nThe following sections discuss some caveats and considerations.\n16.4.1.1.\nHandling New CUDA Features and Driver APIs\n\nA subset of CUDA APIs don’t need a new driver and they can all be used without any driver dependencies. For example,\ncuMemMap\nAPIs or any of APIs introduced prior to CUDA 11.0, such as\ncudaDeviceSynchronize\n, do not require a driver upgrade. To use other CUDA APIs introduced in a minor release (that require a new driver), one would have to implement fallbacks or fail gracefully. This situation is not different from what is available today where developers use macros to compile out features based on CUDA versions. Users should refer to the CUDA headers and documentation for new CUDA APIs introduced in a release.\nWhen working with a feature exposed in a minor version of the toolkit, the feature might not be available at runtime if the application is running against an older CUDA driver. Users wishing to take advantage of such a feature should query its availability with a dynamic check in the code:\nstatic\nbool\nhostRegisterFeatureSupported\n=\nfalse\n;\nstatic\nbool\nhostRegisterIsDeviceAddress\n=\nfalse\n;\nstatic\nerror_t\ncuFooFunction\n(\nint\n*\nptr\n)\n{\nint\n*\ndptr\n=\nnull\n;\nif\n(\nhostRegisterFeatureSupported\n)\n{\ncudaHostRegister\n(\nptr\n,\nsize\n,\nflags\n);\nif\n(\nhostRegisterIsDeviceAddress\n)\n{\nqptr\n=\nptr\n;\n}\nelse\n{\ncudaHostGetDevicePointer\n(\n&\nqptr\n,\nptr\n,\n0\n);\n}\n}\nelse\n{\n// cudaMalloc();\n// cudaMemcpy();\n}\ngemm\n<<<\n1\n,\n1\n>>>\n(\ndptr\n);\ncudaDeviceSynchronize\n();\n}\nint\nmain\n()\n{\n// rest of code here\ncudaDeviceGetAttribute\n(\n&\nhostRegisterFeatureSupported\n,\ncudaDevAttrHostRegisterSupported\n,\n0\n);\ncudaDeviceGetAttribute\n(\n&\nhostRegisterIsDeviceAddress\n,\ncudaDevAttrCanUseHostPointerForRegisteredMem\n,\n0\n);\ncuFooFunction\n(\n/* malloced pointer */\n);\n}\nAlternatively the application’s interface might not work at all without a new CUDA driver and then its best to return an error right away:\n#define MIN_VERSION 11010\ncudaError_t\nfoo\n()\n{\nint\nversion\n=\n0\n;\ncudaGetDriverVersion\n(\n&\nversion\n);\nif\n(\nversion\n<\nMIN_VERSION\n)\n{\nreturn\nCUDA_ERROR_INSUFFICIENT_DRIVER\n;\n}\n// proceed as normal\n}\nA new error code is added to indicate that the functionality is missing from the driver you are running against:\ncudaErrorCallRequiresNewerDriver\n.\n16.4.1.2.\nUsing PTX\n\nPTX defines a virtual machine and ISA for general purpose parallel thread execution. PTX programs are translated at load time to the target hardware instruction set via the JIT Compiler which is part of the CUDA driver. As PTX is compiled by the CUDA driver, new toolchains will generate PTX that is not compatible with the older CUDA driver. This is not a problem when PTX is used for future device compatibility (the most common case), but can lead to issues when used for runtime compilation.\nFor codes continuing to make use of PTX, in order to support compiling on an older driver, your code must be first transformed into device code via the static ptxjitcompiler library or NVRTC with the option of generating code for a specific architecture (e.g. sm_80) rather than a virtual architecture (e.g. compute_80). For this workflow, a new nvptxcompiler_static library is shipped with the CUDA Toolkit.\nWe can see this usage in the following example:\nchar\n*\ncompilePTXToNVElf\n()\n{\nnvPTXCompilerHandle\ncompiler\n=\nNULL\n;\nnvPTXCompileResult\nstatus\n;\nsize_t\nelfSize\n,\ninfoSize\n,\nerrorSize\n;\nchar\n*\nelf\n,\n*\ninfoLog\n,\n*\nerrorLog\n;\nint\nminorVer\n,\nmajorVer\n;\nconst\nchar\n*\ncompile_options\n[]\n=\n{\n\"--gpu-name=sm_80\"\n,\n\"--device-debug\"\n};\nnvPTXCompilerGetVersion\n(\n&\nmajorVer\n,\n&\nminorVer\n);\nnvPTXCompilerCreate\n(\n&\ncompiler\n,\n(\nsize_t\n)\nstrlen\n(\nptxCode\n),\nptxCode\n);\nstatus\n=\nnvPTXCompilerCompile\n(\ncompiler\n,\n2\n,\ncompile_options\n);\nif\n(\nstatus\n!=\nNVPTXCOMPILE_SUCCESS\n)\n{\nnvPTXCompilerGetErrorLogSize\n(\ncompiler\n,\n(\nvoid\n*\n)\n&\nerrorSize\n);\nif\n(\nerrorSize\n!=\n0\n)\n{\nerrorLog\n=\n(\nchar\n*\n)\nmalloc\n(\nerrorSize\n+\n1\n);\nnvPTXCompilerGetErrorLog\n(\ncompiler\n,\n(\nvoid\n*\n)\nerrorLog\n);\nprintf\n(\n\"Error log: %s\n\\n\n\"\n,\nerrorLog\n);\nfree\n(\nerrorLog\n);\n}\nexit\n(\n1\n);\n}\nnvPTXCompilerGetCompiledProgramSize\n(\ncompiler\n,\n&\nelfSize\n));\nelf\n=\n(\nchar\n*\n)\nmalloc\n(\nelfSize\n);\nnvPTXCompilerGetCompiledProgram\n(\ncompiler\n,\n(\nvoid\n*\n)\nelf\n);\nnvPTXCompilerGetInfoLogSize\n(\ncompiler\n,\n(\nvoid\n*\n)\n&\ninfoSize\n);\nif\n(\ninfoSize\n!=\n0\n)\n{\ninfoLog\n=\n(\nchar\n*\n)\nmalloc\n(\ninfoSize\n+\n1\n);\nnvPTXCompilerGetInfoLog\n(\ncompiler\n,\n(\nvoid\n*\n)\ninfoLog\n);\nprintf\n(\n\"Info log: %s\n\\n\n\"\n,\ninfoLog\n);\nfree\n(\ninfoLog\n);\n}\nnvPTXCompilerDestroy\n(\n&\ncompiler\n);\nreturn\nelf\n;\n}\n16.4.1.3.\nDynamic Code Generation\n\nNVRTC is a runtime compilation library for CUDA C++. It accepts CUDA C++ source code in character string form and creates handles that can be used to obtain the PTX. The PTX string generated by NVRTC can be loaded by cuModuleLoadData and cuModuleLoadDataEx.\nDealing with relocatable objects is not yet supported, therefore the\ncuLink\n* set of APIs in the CUDA driver will not work with enhanced compatibility. An upgraded driver matching the CUDA runtime version is currently required for those APIs.\nAs mentioned in the PTX section, the compilation of PTX to device code lives along with the CUDA driver, hence the generated PTX might be newer than what is supported by the driver on the deployment system. When using NVRTC, it is recommended that the resulting PTX code is first transformed to the final device code via the steps outlined by the PTX user workflow. This ensures your code is compatible. Alternatively, NVRTC can generate cubins directly starting with CUDA 11.1. Applications using the new API can load the final device code directly using driver APIs\ncuModuleLoadData\nand\ncuModuleLoadDataEx\n.\nNVRTC used to support only virtual architectures through the option -arch, since it was only emitting PTX. It will now support actual architectures as well to emit SASS. The interface is augmented to retrieve either the PTX or cubin if an actual architecture is specified.\nThe example below shows how an existing example can be adapted to use the new features, guarded by the\nUSE_CUBIN\nmacro in this case:\n#include\n<nvrtc.h>\n#include\n<cuda.h>\n#include\n<iostream>\nvoid\nNVRTC_SAFE_CALL\n(\nnvrtcResult\nresult\n)\n{\nif\n(\nresult\n!=\nNVRTC_SUCCESS\n)\n{\nstd\n::\ncerr\n<<\n\"\n\\n\nnvrtc error: \"\n<<\nnvrtcGetErrorString\n(\nresult\n)\n<<\n'\\n'\n;\nstd\n::\nexit\n(\n1\n);\n}\n}\nvoid\nCUDA_SAFE_CALL\n(\nCUresult\nresult\n)\n{\nif\n(\nresult\n!=\nCUDA_SUCCESS\n)\n{\nconst\nchar\n*\nmsg\n;\ncuGetErrorName\n(\nresult\n,\n&\nmsg\n);\nstd\n::\ncerr\n<<\n\"\n\\n\ncuda error: \"\n<<\nmsg\n<<\n'\\n'\n;\nstd\n::\nexit\n(\n1\n);\n}\n}\nconst\nchar\n*\nhello\n=\n\"\n\\n\n\\\nextern\n\\\"\nC\n\\\"\n__global__ void hello() {\n\\n\n\\\nprintf(\n\\\"\nhello world\n\\\\\nn\n\\\"\n);\n\\n\n\\\n}\n\\n\n\"\n;\nint\nmain\n()\n{\nnvrtcProgram\nprog\n;\nNVRTC_SAFE_CALL\n(\nnvrtcCreateProgram\n(\n&\nprog\n,\nhello\n,\n\"hello.cu\"\n,\n0\n,\nNULL\n,\nNULL\n));\n#ifdef USE_CUBIN\nconst\nchar\n*\nopts\n[]\n=\n{\n\"-arch=sm_70\"\n};\n#else\nconst\nchar\n*\nopts\n[]\n=\n{\n\"-arch=compute_70\"\n};\n#endif\nnvrtcResult\ncompileResult\n=\nnvrtcCompileProgram\n(\nprog\n,\n1\n,\nopts\n);\nsize_t\nlogSize\n;\nNVRTC_SAFE_CALL\n(\nnvrtcGetProgramLogSize\n(\nprog\n,\n&\nlogSize\n));\nchar\n*\nlog\n=\nnew\nchar\n[\nlogSize\n];\nNVRTC_SAFE_CALL\n(\nnvrtcGetProgramLog\n(\nprog\n,\nlog\n));\nstd\n::\ncout\n<<\nlog\n<<\n'\\n'\n;\ndelete\n[]\nlog\n;\nif\n(\ncompileResult\n!=\nNVRTC_SUCCESS\n)\nexit\n(\n1\n);\nsize_t\ncodeSize\n;\n#ifdef USE_CUBIN\nNVRTC_SAFE_CALL\n(\nnvrtcGetCUBINSize\n(\nprog\n,\n&\ncodeSize\n));\nchar\n*\ncode\n=\nnew\nchar\n[\ncodeSize\n];\nNVRTC_SAFE_CALL\n(\nnvrtcGetCUBIN\n(\nprog\n,\ncode\n));\n#else\nNVRTC_SAFE_CALL\n(\nnvrtcGetPTXSize\n(\nprog\n,\n&\ncodeSize\n));\nchar\n*\ncode\n=\nnew\nchar\n[\ncodeSize\n];\nNVRTC_SAFE_CALL\n(\nnvrtcGetPTX\n(\nprog\n,\ncode\n));\n#endif\nNVRTC_SAFE_CALL\n(\nnvrtcDestroyProgram\n(\n&\nprog\n));\nCUdevice\ncuDevice\n;\nCUcontext\ncontext\n;\nCUmodule\nmodule\n;\nCUfunction\nkernel\n;\nCUDA_SAFE_CALL\n(\ncuInit\n(\n0\n));\nCUDA_SAFE_CALL\n(\ncuDeviceGet\n(\n&\ncuDevice\n,\n0\n));\nCUDA_SAFE_CALL\n(\ncuCtxCreate\n(\n&\ncontext\n,\nNULL\n,\n0\n,\ncuDevice\n));\nCUDA_SAFE_CALL\n(\ncuModuleLoadDataEx\n(\n&\nmodule\n,\ncode\n,\n0\n,\n0\n,\n0\n));\nCUDA_SAFE_CALL\n(\ncuModuleGetFunction\n(\n&\nkernel\n,\nmodule\n,\n\"hello\"\n));\nCUDA_SAFE_CALL\n(\ncuLaunchKernel\n(\nkernel\n,\n1\n,\n1\n,\n1\n,\n1\n,\n1\n,\n1\n,\n0\n,\nNULL\n,\nNULL\n,\n0\n));\nCUDA_SAFE_CALL\n(\ncuCtxSynchronize\n());\nCUDA_SAFE_CALL\n(\ncuModuleUnload\n(\nmodule\n));\nCUDA_SAFE_CALL\n(\ncuCtxDestroy\n(\ncontext\n));\ndelete\n[]\ncode\n;\n}\n16.4.1.4.\nRecommendations for building a minor-version compatible library\n\nWe recommend that the CUDA runtime be statically linked to minimize dependencies. Verify that your library doesn’t leak dependencies, breakages, namespaces, etc. outside your established ABI contract.\nFollow semantic versioning for your library’s soname. Having a semantically versioned ABI means the interfaces need to be maintained and versioned. The library should follow semantic rules and increment the version number when a change is made that affects this ABI contract. Missing dependencies is also a binary compatibility break, hence you should provide fallbacks or guards for functionality that depends on those interfaces. Increment major versions when there are ABI breaking changes such as API deprecation and modifications. New APIs can be added in minor versions.\nConditionally use features to remain compatible against older drivers. If no new features are used (or if they are used conditionally with fallbacks provided) you’ll be able to remain compatible.\nDon’t expose ABI structures that can change. A pointer to a structure with a size embedded is a better solution.\nWhen linking with dynamic libraries from the toolkit, the library must be equal to or newer than what is needed by any one of the components involved in the linking of your application. For example, if you link against the CUDA 11.1 dynamic runtime, and use functionality from 11.1, as well as a separate shared library that was linked against the CUDA 11.2 dynamic runtime that requires 11.2 functionality, the final link step must include a CUDA 11.2 or newer dynamic runtime.\n16.4.1.5.\nRecommendations for taking advantage of minor version compatibility in your application\n\nCertain functionality might not be available so you should query where applicable. This is common for building applications that are GPU architecture, platform and compiler agnostic. However we now add “the underlying driver” to that mix.\nAs with the previous section on library building recommendations, if using the CUDA runtime, we recommend linking to the CUDA runtime statically when building your application. When using the driver APIs directly, we recommend using the new driver entry point access API (\ncuGetProcAddress\n) documented here:\nCUDA Driver API :: CUDA Toolkit Documentation\n.\nWhen using a shared or static library, follow the release notes of said library to determine if the library supports minor version compatibility.\n17.\nPreparing for Deployment\n\n17.1.\nTesting for CUDA Availability\n\nWhen deploying a CUDA application, it is often desirable to ensure that the application will continue to function properly even if the target machine does not have a CUDA-capable GPU and/or a sufficient version of the NVIDIA Driver installed. (Developers targeting a single machine with known configuration may choose to skip this section.)\nDetecting a CUDA-Capable GPU\nWhen an application will be deployed to target machines of arbitrary/unknown configuration, the application should explicitly test for the existence of a CUDA-capable GPU in order to take appropriate action when no such device is available. The\ncudaGetDeviceCount()\nfunction can be used to query for the number of available devices. Like all CUDA Runtime API functions, this function will fail gracefully and return\ncudaErrorNoDevice\nto the application if there is no CUDA-capable GPU or\ncudaErrorInsufficientDriver\nif there is not an appropriate version of the NVIDIA Driver installed. If\ncudaGetDeviceCount()\nreports an error, the application should fall back to an alternative code path.\nA system with multiple GPUs may contain GPUs of different hardware versions and capabilities. When using multiple GPUs from the same application, it is recommended to use GPUs of the same type, rather than mixing hardware generations. The\ncudaChooseDevice()\nfunction can be used to select the device that most closely matches a desired set of features.\nDetecting Hardware and Software Configuration\nWhen an application depends on the availability of certain hardware or software capabilities to enable certain functionality, the CUDA API can be queried for details about the configuration of the available device and for the installed software versions.\nThe\ncudaGetDeviceProperties()\nfunction reports various features of the available devices, including the\nCUDA Compute Capability\nof the device (see also the Compute Capabilities section of the CUDA C++ Programming Guide). See\nVersion Management\nfor details on how to query the available CUDA software API versions.\n17.2.\nError Handling\n\nAll CUDA Runtime API calls return an error code of type\ncudaError_t\n; the return value will be equal to\ncudaSuccess\nif no errors have occurred. (The exceptions to this are kernel launches, which return void, and\ncudaGetErrorString()\n, which returns a character string describing the\ncudaError_t\ncode that was passed into it.) The CUDA Toolkit libraries (\ncuBLAS\n,\ncuFFT\n, etc.) likewise return their own sets of error codes.\nSince some CUDA API calls and all kernel launches are asynchronous with respect to the host code, errors may be reported to the host asynchronously as well; often this occurs the next time the host and device synchronize with each other, such as during a call to\ncudaMemcpy()\nor to\ncudaDeviceSynchronize()\n.\nAlways check the error return values on all CUDA API functions, even for functions that are not expected to fail, as this will allow the application to detect and recover from errors as soon as possible should they occur. To check for errors occurring during kernel launches using the\n<<<...>>>\nsyntax, which does not return any error code, the return code of\ncudaGetLastError()\nshould be checked immediately after the kernel launch. Applications that do not check for CUDA API errors could at times run to completion without having noticed that the data calculated by the GPU is incomplete, invalid, or uninitialized.\nNote\nThe CUDA Toolkit Samples provide several helper functions for error checking with the various CUDA APIs; these helper functions are located in the\nsamples/common/inc/helper_cuda.h\nfile in the CUDA Toolkit.\n17.3.\nBuilding for Maximum Compatibility\n\nEach generation of CUDA-capable device has an associated\ncompute capability\nversion that indicates the feature set supported by the device (see\nCUDA Compute Capability\n). One or more compute capability versions can be specified to the nvcc compiler while building a file; compiling for the native compute capability for the target GPU(s) of the application is important to ensure that application kernels achieve the best possible performance and are able to use the features that are available on a given generation of GPU.\nWhen an application is built for multiple compute capabilities simultaneously (using several instances of the\n-gencode\nflag to\nnvcc), the binaries for the specified compute capabilities are combined into the executable, and the CUDA Driver selects the most\nappropriate binary at runtime according to the compute capability of the present device. If an appropriate native binary (\ncubin\n)\nis not available, but the intermediate\nPTX\ncode (which targets an abstract virtual instruction set and is used for forward-compatibility)\nis available, then the kernel will be compiled\nJust In Time\n(JIT) (see\nCompiler JIT Cache Management Tools\n)\nfrom the PTX to the native cubin for the device. If the PTX is also not available, then the kernel launch will fail.\nWindows\nnvcc.exe -ccbin \"C:\\vs2008\\VC\\bin\"\n-Xcompiler \"/EHsc /W3 /nologo /O2 /Zi /MT\"\n-gencode=arch=compute_30,code=sm_30\n-gencode=arch=compute_35,code=sm_35\n-gencode=arch=compute_50,code=sm_50\n-gencode=arch=compute_60,code=sm_60\n-gencode=arch=compute_70,code=sm_70\n-gencode=arch=compute_75,code=sm_75\n-gencode=arch=compute_75,code=compute_75\n--compile -o \"Release\\mykernel.cu.obj\" \"mykernel.cu\"\nMac/Linux\n/usr/local/cuda/bin/nvcc\n-gencode=arch=compute_30,code=sm_30\n-gencode=arch=compute_35,code=sm_35\n-gencode=arch=compute_50,code=sm_50\n-gencode=arch=compute_60,code=sm_60\n-gencode=arch=compute_70,code=sm_70\n-gencode=arch=compute_75,code=sm_75\n-gencode=arch=compute_75,code=compute_75\n-O2 -o mykernel.o -c mykernel.cu\nAlternatively, the\nnvcc\ncommand-line option\n-arch=sm_XX\ncan be used as a shorthand equivalent to the following more explicit\n-gencode=\ncommand-line options described above:\n-gencode=arch=compute_XX,code=sm_XX\n-gencode=arch=compute_XX,code=compute_XX\nHowever, while the\n-arch=sm_XX\ncommand-line option does result in inclusion of a PTX back-end target by default (due to the\ncode=compute_XX\ntarget it implies), it can only specify a single target\ncubin\narchitecture at a time, and it is not possible to use multiple\n-arch=\noptions on the same\nnvcc\ncommand line, which is why the examples above use\n-gencode=\nexplicitly.\n17.4.\nDistributing the CUDA Runtime and Libraries\n\nCUDA applications are built against the CUDA Runtime library, which handles device, memory, and kernel management. Unlike the CUDA Driver, the CUDA Runtime guarantees neither forward nor backward binary compatibility across versions. It is therefore best to\nredistribute\nthe CUDA Runtime library with the application when using dynamic linking or else to statically link against the CUDA Runtime. This will ensure that the executable will be able to run even if the user does not have the same CUDA Toolkit installed that the application was built against.\nNote\nWhen statically linking to the CUDA Runtime, multiple versions of the runtime can peacably coexist in the same application process simultaneously; for example, if an application uses one version of the CUDA Runtime, and a plugin to that application is statically linked to a different version, that is perfectly acceptable, as long as the installed NVIDIA Driver is sufficient for both.\nStatically-linked CUDA Runtime\nThe easiest option is to statically link against the CUDA Runtime. This is the default if using\nnvcc\nto link in CUDA 5.5 and later. Static linking makes the executable slightly larger, but it ensures that the correct version of runtime library functions are included in the application binary without requiring separate redistribution of the CUDA Runtime library.\nDynamically-linked CUDA Runtime\nIf static linking against the CUDA Runtime is impractical for some reason, then a dynamically-linked version of the CUDA Runtime library is also available. (This was the default and only option provided in CUDA versions 5.0 and earlier.)\nTo use dynamic linking with the CUDA Runtime when using the\nnvcc\nfrom CUDA 5.5 or later to link the application, add\nthe\n--cudart=shared\nflag to the link command line; otherwise the\nstatically-linked CUDA Runtime library\nis used by default.\nAfter the application is dynamically linked against the CUDA Runtime, this version of the runtime library should be\nbundled with\nthe application. It can be copied into the same directory as the application executable or into a subdirectory of that installation path.\nOther CUDA Libraries\nAlthough the CUDA Runtime provides the option of static linking, some libraries included in the CUDA Toolkit are available only in dynamically-linked form. As with\nthe\ndynamically-linked version of the CUDA Runtime library\n, these libraries should\nbe\nbundled with\nthe application executable when distributing that application.\n17.4.1.\nCUDA Toolkit Library Redistribution\n\nThe CUDA Toolkit’s End-User License Agreement (EULA) allows for redistribution of many of the CUDA libraries under certain terms and conditions. This allows applications that depend on these libraries\nto redistribute the exact versions\nof the libraries against which they were built and tested, thereby avoiding any trouble for end users who might have a different version of the CUDA Toolkit (or perhaps none at all) installed on their machines. Please refer to the EULA for details.\nNote\nThis does\nnot\napply to the NVIDIA Driver; the end user must still download and install an NVIDIA Driver appropriate to their GPU(s) and operating system.\n17.4.1.1.\nWhich Files to Redistribute\n\nWhen redistributing the dynamically-linked versions of one or more CUDA libraries, it is important to identify the exact files that need to be redistributed. The following examples use the cuBLAS library from CUDA Toolkit 5.5 as an illustration:\nLinux\nIn a shared library on Linux, there is a string field called the\nSONAME\nthat indicates the binary compatibility level of the library. The\nSONAME\nof the library against which the application was built must match the filename of the library that is redistributed with the application.\nFor example, in the standard CUDA Toolkit installation, the files\nlibcublas.so\nand\nlibcublas.so.5.5\nare both symlinks pointing to a specific build of cuBLAS, which is named like\nlibcublas.so.5.5.x\n, where\nx\nis the build number (e.g.,\nlibcublas.so.5.5.17\n). However, the\nSONAME\nof this library is given as “\nlibcublas.so.5.5\n”:\n$ objdump -p /usr/local/cuda/lib64/libcublas.so | grep SONAME\nSONAME               libcublas.so.5.5\nBecause of this, even if\n-lcublas\n(with no version number specified) is used when linking the application, the\nSONAME\nfound at link time implies that “\nlibcublas.so.5.5\n” is the name of the file that the dynamic loader will look for when loading the application and therefore must be the name of the file (or a symlink to the same) that is redistributed with the application.\nThe\nldd\ntool is useful for identifying the exact filenames of the libraries that the application expects to find at runtime as well as the path, if any, of the copy of that library that the dynamic loader would select when loading the application given the current library search path:\n$ ldd a.out | grep libcublas\nlibcublas.so.5.5 => /usr/local/cuda/lib64/libcublas.so.5.5\nMac\nIn a shared library on Mac OS X, there is a field called the\ninstall\nname\nthat indicates the expected installation path and filename the library; the CUDA libraries also use this filename to indicate binary compatibility. The value of this field is propagated into an application built against the library and is used to locate the library of the correct version at runtime.\nFor example, if the install name of the cuBLAS library is given as\n@rpath/libcublas.5.5.dylib\n, then the library is version 5.5 and the copy of this library\nredistributed with the application must be named\nlibcublas.5.5.dylib\n, even though only\n-lcublas\n(with no version number specified) is used at link time.\nFurthermore, this file should be installed into the\n@rpath\nof the application; see\nWhere to Install Redistributed CUDA Libraries\n.\nTo view a library’s install name, use the\notool\n-L\ncommand:\n$ otool -L a.out\na.out:\n@rpath/libcublas.5.5.dylib (...)\nWindows\nThe binary compatibility version of the CUDA libraries on Windows is indicated as part of the filename.\nFor example, a 64-bit application linked to cuBLAS 5.5 will look for\ncublas64_55.dll\nat runtime, so this is the file that should be redistributed with that application, even though\ncublas.lib\nis the file that the application is linked against. For 32-bit applications, the file would be\ncublas32_55.dll\n.\nTo verify the exact DLL filename that the application expects to find at runtime, use the\ndumpbin\ntool from the Visual Studio command prompt:\n$ dumpbin /IMPORTS a.exe\nMicrosoft (R) COFF/PE Dumper Version 10.00.40219.01\nCopyright (C) Microsoft Corporation.  All rights reserved.\nDump of file a.exe\nFile Type: EXECUTABLE IMAGE\nSection contains the following imports:\n...\ncublas64_55.dll\n...\n17.4.1.2.\nWhere to Install Redistributed CUDA Libraries\n\nOnce the correct library files are identified for redistribution, they must be configured for installation into a location where the application will be able to find them.\nOn Windows, if the CUDA Runtime or other dynamically-linked CUDA Toolkit library is placed in the same directory as the executable, Windows will locate it automatically. On Linux and Mac, the\n-rpath\nlinker option should be used to instruct the executable to search its local path for these libraries before searching the system paths:\nLinux/Mac\nnvcc -I $(CUDA_HOME)/include\n-Xlinker \"-rpath '$ORIGIN'\" --cudart=shared\n-o myprogram myprogram.cu\nWindows\nnvcc.exe -ccbin \"C:\\vs2008\\VC\\bin\"\n-Xcompiler \"/EHsc /W3 /nologo /O2 /Zi /MT\" --cudart=shared\n-o \"Release\\myprogram.exe\" \"myprogram.cu\"\nNote\nIt may be necessary to adjust the value of\n-ccbin\nto reflect the location of your Visual Studio installation.\nTo specify an alternate path where the libraries will be distributed, use linker options similar to those below:\nLinux/Mac\nnvcc -I $(CUDA_HOME)/include\n-Xlinker \"-rpath '$ORIGIN/lib'\" --cudart=shared\n-o myprogram myprogram.cu\nWindows\nnvcc.exe -ccbin \"C:\\vs2008\\VC\\bin\"\n-Xcompiler \"/EHsc /W3 /nologo /O2 /Zi /MT /DELAY\" --cudart=shared\n-o \"Release\\myprogram.exe\" \"myprogram.cu\"\nFor Linux and Mac, the\n-rpath\noption is used as before. For Windows, the\n/DELAY\noption is used; this requires that the application call\nSetDllDirectory()\nbefore the first call to any CUDA API function in order to specify the directory containing the CUDA DLLs.\nNote\nFor Windows 8,\nSetDefaultDLLDirectories()\nand\nAddDllDirectory()\nshould be used instead of\nSetDllDirectory()\n. Please see the MSDN documentation for these routines for more information.\n18.\nDeployment Infrastructure Tools\n\n18.1.\nNvidia-SMI\n\nThe NVIDIA System Management Interface (\nnvidia-smi\n) is a command line utility that aids in the management and monitoring of NVIDIA GPU devices. This utility allows administrators to query GPU device state and, with the appropriate privileges, permits administrators to modify GPU device state.\nnvidia-smi\nis targeted at Tesla and certain Quadro GPUs, though limited support is also available on other NVIDIA GPUs.\nnvidia-smi\nships with NVIDIA GPU display drivers on Linux, and with 64-bit Windows Server 2008 R2 and Windows 7.\nnvidia-smi\ncan output queried information as XML or as human-readable plain text either to standard output or to a file. See the nvidia-smi documenation for details. Please note that new versions of nvidia-smi are not guaranteed to be backward-compatible with previous versions.\n18.1.1.\nQueryable state\n\nECC error counts\nBoth correctable single-bit and detectable double-bit errors are reported. Error counts are provided for both the current boot cycle and the lifetime of the GPU.\nGPU utilization\nCurrent utilization rates are reported for both the compute resources of the GPU and the memory interface.\nActive compute process\nThe list of active processes running on the GPU is reported, along with the corresponding process name/ID and allocated GPU memory.\nClocks and performance state\nMax and current clock rates are reported for several important clock domains, as well as the current GPU performance state (\npstate\n).\nTemperature and fan speed\nThe current GPU core temperature is reported, along with fan speeds for products with active cooling.\nPower management\nThe current board power draw and power limits are reported for products that report these measurements.\nIdentification\nVarious dynamic and static information is reported, including board serial numbers, PCI device IDs, VBIOS/Inforom version numbers and product names.\n18.1.2.\nModifiable state\n\nECC mode\nEnable and disable ECC reporting.\nECC reset\nClear single-bit and double-bit ECC error counts.\nCompute mode\nIndicate whether compute processes can run on the GPU and whether they run exclusively or concurrently with other compute processes.\nPersistence mode\nIndicate whether the NVIDIA driver stays loaded when no applications are connected to the GPU. It is best to enable this option in most circumstances.\nGPU reset\nReinitialize the GPU hardware and software state via a secondary bus reset.\n18.2.\nNVML\n\nThe NVIDIA Management Library (NVML) is a C-based interface that provides direct access to the queries and commands exposed via\nnvidia-smi\nintended as a platform for building 3rd-party system management applications. The NVML API is shipped with the CUDA Toolkit (since version 8.0) and is also available standalone on the NVIDIA developer website as part of the GPU Deployment Kit through a single header file accompanied by PDF documentation, stub libraries, and sample applications; see\nhttps://developer.nvidia.com/gpu-deployment-kit\n. Each new version of NVML is backward-compatible.\nAn additional set of Perl and Python bindings are provided for the NVML API. These bindings expose the same features as the C-based interface and also provide backwards compatibility. The Perl bindings are provided via CPAN and the Python bindings via PyPI.\nAll of these products (\nnvidia-smi\n, NVML, and the NVML language bindings) are updated with each new CUDA release and provide roughly the same functionality.\nSee\nhttps://developer.nvidia.com/nvidia-management-library-nvml\nfor additional information.\n18.3.\nCluster Management Tools\n\nManaging your GPU cluster will help achieve maximum GPU utilization and help you and your users extract the best possible performance. Many of the industry’s most popular cluster management tools support CUDA GPUs via NVML. For a listing of some of these tools, see\nhttps://developer.nvidia.com/cluster-management\n.\n18.4.\nCompiler JIT Cache Management Tools\n\nAny PTX device code loaded by an application at runtime is compiled further to binary code by the device driver. This is called\njust-in-time compilation\n(\nJIT\n). Just-in-time compilation increases application load time but allows applications to benefit from latest compiler improvements. It is also the only way for applications to run on devices that did not exist at the time the application was compiled.\nWhen JIT compilation of PTX device code is used, the NVIDIA driver caches the resulting binary code on disk. Some aspects of this behavior such as cache location and maximum cache size can be controlled via the use of environment variables; see Just in Time Compilation of the CUDA C++ Programming Guide.\n18.5.\nCUDA_VISIBLE_DEVICES\n\nIt is possible to rearrange the collection of installed CUDA devices that will be visible to and enumerated by a CUDA application prior to the start of that application by way of the\nCUDA_VISIBLE_DEVICES\nenvironment variable.\nDevices to be made visible to the application should be included as a comma-separated list in terms of the system-wide list of enumerable devices. For example, to use only devices 0 and 2 from the system-wide list of devices, set\nCUDA_VISIBLE_DEVICES=0,2\nbefore launching the application. The application will then enumerate these devices as device 0 and device 1, respectively.\n19.\nRecommendations and Best Practices\n\nThis chapter contains a summary of the recommendations for optimization that are explained in this document.\n19.1.\nOverall Performance Optimization Strategies\n\nPerformance optimization revolves around three basic strategies:\nMaximizing parallel execution\nOptimizing memory usage to achieve maximum memory bandwidth\nOptimizing instruction usage to achieve maximum instruction throughput\nMaximizing parallel execution starts with structuring the algorithm in a way that exposes as much parallelism as possible. Once the parallelism of the algorithm has been exposed, it needs to be mapped to the hardware as efficiently as possible. This is done by carefully choosing the execution configuration of each kernel launch. The application should also maximize parallel execution at a higher level by explicitly exposing concurrent execution on the device through streams, as well as maximizing concurrent execution between the host and the device.\nOptimizing memory usage starts with minimizing data transfers between the host and the device because those transfers have much lower bandwidth than internal device data transfers. Kernel access to global memory also should be minimized by maximizing the use of shared memory on the device. Sometimes, the best optimization might even be to avoid any data transfer in the first place by simply recomputing the data whenever it is needed.\nThe effective bandwidth can vary by an order of magnitude depending on the access pattern for each type of memory. The next step in optimizing memory usage is therefore to organize memory accesses according to the optimal memory access patterns. This optimization is especially important for global memory accesses, because latency of access costs hundreds of clock cycles. Shared memory accesses, in counterpoint, are usually worth optimizing only when there exists a high degree of bank conflicts.\nAs for optimizing instruction usage, the use of arithmetic instructions that have low throughput should be avoided. This suggests trading precision for speed when it does not affect the end result, such as using intrinsics instead of regular functions or single precision instead of double precision. Finally, particular attention must be paid to control flow instructions due to the SIMT (single instruction multiple thread) nature of the device.\n20.\nnvcc Compiler Switches\n\n20.1.\nnvcc\n\nThe NVIDIA\nnvcc\ncompiler driver converts\n.cu\nfiles into C++ for the host system and CUDA assembly or binary instructions for the device. It supports a number of command-line parameters, of which the following are especially useful for optimization and related best practices:\n-maxrregcount=N\nspecifies the maximum number of registers kernels can use at a per-file level. See\nRegister Pressure\n. (See also the\n__launch_bounds__\nqualifier discussed in Execution Configuration of the CUDA C++ Programming Guide to control the number of registers used on a per-kernel basis.)\n--ptxas-options=-v\nor\n-Xptxas=-v\nlists per-kernel register, shared, and constant memory usage.\n-ftz=true\n(denormalized numbers are flushed to zero)\n-prec-div=false\n(less precise division)\n-prec-sqrt=false\n(less precise square root)\n-use_fast_math\ncompiler option of\nnvcc\ncoerces every\nfunctionName()\ncall to the equivalent\n__functionName()\ncall. This makes the code run faster at the cost of diminished precision and accuracy. See\nMath Libraries\n.\n21.\nNotices\n\n21.1.\nNotice\n\nThis document is provided for information purposes only and shall not be regarded as a warranty of a certain functionality, condition, or quality of a product. NVIDIA Corporation (“NVIDIA”) makes no representations or warranties, expressed or implied, as to the accuracy or completeness of the information contained in this document and assumes no responsibility for any errors contained herein. NVIDIA shall have no liability for the consequences or use of such information or for any infringement of patents or other rights of third parties that may result from its use. This document is not a commitment to develop, release, or deliver any Material (defined below), code, or functionality.\nNVIDIA reserves the right to make corrections, modifications, enhancements, improvements, and any other changes to this document, at any time without notice.\nCustomer should obtain the latest relevant information before placing orders and should verify that such information is current and complete.\nNVIDIA products are sold subject to the NVIDIA standard terms and conditions of sale supplied at the time of order acknowledgement, unless otherwise agreed in an individual sales agreement signed by authorized representatives of NVIDIA and customer (“Terms of Sale”). NVIDIA hereby expressly objects to applying any customer general terms and conditions with regards to the purchase of the NVIDIA product referenced in this document. No contractual obligations are formed either directly or indirectly by this document.\nNVIDIA products are not designed, authorized, or warranted to be suitable for use in medical, military, aircraft, space, or life support equipment, nor in applications where failure or malfunction of the NVIDIA product can reasonably be expected to result in personal injury, death, or property or environmental damage. NVIDIA accepts no liability for inclusion and/or use of NVIDIA products in such equipment or applications and therefore such inclusion and/or use is at customer’s own risk.\nNVIDIA makes no representation or warranty that products based on this document will be suitable for any specified use. Testing of all parameters of each product is not necessarily performed by NVIDIA. It is customer’s sole responsibility to evaluate and determine the applicability of any information contained in this document, ensure the product is suitable and fit for the application planned by customer, and perform the necessary testing for the application in order to avoid a default of the application or the product. Weaknesses in customer’s product designs may affect the quality and reliability of the NVIDIA product and may result in additional or different conditions and/or requirements beyond those contained in this document. NVIDIA accepts no liability related to any default, damage, costs, or problem which may be based on or attributable to: (i) the use of the NVIDIA product in any manner that is contrary to this document or (ii) customer product designs.\nNo license, either expressed or implied, is granted under any NVIDIA patent right, copyright, or other NVIDIA intellectual property right under this document. Information published by NVIDIA regarding third-party products or services does not constitute a license from NVIDIA to use such products or services or a warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual property rights of the third party, or a license from NVIDIA under the patents or other intellectual property rights of NVIDIA.\nReproduction of information in this document is permissible only if approved in advance by NVIDIA in writing, reproduced without alteration and in full compliance with all applicable export laws and regulations, and accompanied by all associated conditions, limitations, and notices.\nTHIS DOCUMENT AND ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, “MATERIALS”) ARE BEING PROVIDED “AS IS.” NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL NVIDIA BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Notwithstanding any damages that customer might incur for any reason whatsoever, NVIDIA’s aggregate and cumulative liability towards customer for the products described herein shall be limited in accordance with the Terms of Sale for the product.\n21.2.\nOpenCL\n\nOpenCL is a trademark of Apple Inc. used under license to the Khronos Group Inc.\n21.3.\nTrademarks\n\nNVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated.", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html"}}
{"text": "CUDA Runtime API :: CUDA Toolkit Documentation\nNVIDIA\nCUDA Toolkit Documentation\nSearch In:\nEntire Site\nJust This Document\nclear search\nsearch\nCUDA Runtime API\n(\nPDF\n)\n-\nv13.0.2\n(\nolder\n)\n-\nLast updated October 9, 2025\n-\nSend Feedback\nTable of Contents\n1. Difference between the driver and runtime APIs\n2. API synchronization behavior\n3. Stream synchronization behavior\n4. Graph object thread safety\n5. Rules for version mixing\n6. Modules\n6.1. Device Management\n6.2. Device Management [DEPRECATED]\n6.3. Error Handling\n6.4. Stream Management\n6.5. Event Management\n6.6. External Resource Interoperability\n6.7. Execution Control\n6.8. Execution Control [DEPRECATED]\n6.9. Occupancy\n6.10. Memory Management\n6.11. Memory Management [DEPRECATED]\n6.12. Stream Ordered Memory Allocator\n6.13. Unified Addressing\n6.14. Peer Device Memory Access\n6.15. OpenGL Interoperability\n6.16. OpenGL Interoperability [DEPRECATED]\n6.17. Direct3D 9 Interoperability\n6.18. Direct3D 9 Interoperability [DEPRECATED]\n6.19. Direct3D 10 Interoperability\n6.20. Direct3D 10 Interoperability [DEPRECATED]\n6.21. Direct3D 11 Interoperability\n6.22. Direct3D 11 Interoperability [DEPRECATED]\n6.23. VDPAU Interoperability\n6.24. EGL Interoperability\n6.25. Graphics Interoperability\n6.26. Texture Object Management\n6.27. Surface Object Management\n6.28. Version Management\n6.29. Error Log Management Functions\n6.30. Graph Management\n6.31. Driver Entry Point Access\n6.32. Library Management\n6.33. C++ API Routines\n6.34. Interactions with the CUDA Driver API\n6.35. Profiler Control\n6.36. Data types used by CUDA Runtime\n7. Data Structures\n7.1. __cudaOccupancyB2DHelper\n7.2. cudaAccessPolicyWindow\n7.3. cudaArrayMemoryRequirements\n7.4. cudaArraySparseProperties\n7.5. cudaAsyncNotificationInfo_t\n7.6. cudaChannelFormatDesc\n7.7. cudaChildGraphNodeParams\n7.8. cudaConditionalNodeParams\n7.9. cudaDeviceProp\n7.10. cudaEglFrame\n7.11. cudaEglPlaneDesc\n7.12. cudaEventRecordNodeParams\n7.13. cudaEventWaitNodeParams\n7.14. cudaExtent\n7.15. cudaExternalMemoryBufferDesc\n7.16. cudaExternalMemoryHandleDesc\n7.17. cudaExternalMemoryMipmappedArrayDesc\n7.18. cudaExternalSemaphoreHandleDesc\n7.19. cudaExternalSemaphoreSignalNodeParams\n7.20. cudaExternalSemaphoreSignalNodeParamsV2\n7.21. cudaExternalSemaphoreSignalParams\n7.22. cudaExternalSemaphoreWaitNodeParams\n7.23. cudaExternalSemaphoreWaitNodeParamsV2\n7.24. cudaExternalSemaphoreWaitParams\n7.25. cudaFuncAttributes\n7.26. cudaGraphEdgeData\n7.27. cudaGraphExecUpdateResultInfo\n7.28. cudaGraphInstantiateParams\n7.29. cudaGraphKernelNodeUpdate\n7.30. cudaGraphNodeParams\n7.31. cudaHostNodeParams\n7.32. cudaHostNodeParamsV2\n7.33. cudaIpcEventHandle_t\n7.34. cudaIpcMemHandle_t\n7.35. cudaKernelNodeParams\n7.36. cudaKernelNodeParamsV2\n7.37. cudaLaunchAttribute\n7.38. cudaLaunchAttributeValue\n7.39. cudaLaunchConfig_t\n7.40. cudaLaunchMemSyncDomainMap\n7.41. cudaMemAccessDesc\n7.42. cudaMemAllocNodeParams\n7.43. cudaMemAllocNodeParamsV2\n7.44. cudaMemcpy3DOperand\n7.45. cudaMemcpy3DParms\n7.46. cudaMemcpy3DPeerParms\n7.47. cudaMemcpyAttributes\n7.48. cudaMemcpyNodeParams\n7.49. cudaMemFreeNodeParams\n7.50. cudaMemLocation\n7.51. cudaMemPoolProps\n7.52. cudaMemPoolPtrExportData\n7.53. cudaMemsetParams\n7.54. cudaMemsetParamsV2\n7.55. cudaOffset3D\n7.56. cudaPitchedPtr\n7.57. cudaPointerAttributes\n7.58. cudaPos\n7.59. cudaResourceDesc\n7.60. cudaResourceViewDesc\n7.61. cudaTextureDesc\n7.62. CUuuid_st\n8. Data Fields\n9. Deprecated List", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://docs.nvidia.com/cuda/cuda-runtime-api/index.html"}}
{"text": "CUDA Driver API :: CUDA Toolkit Documentation\nNVIDIA\nCUDA Toolkit Documentation\nSearch In:\nEntire Site\nJust This Document\nclear search\nsearch\nCUDA Driver API\n(\nPDF\n)\n-\nv13.0.97\n(\nolder\n)\n-\nLast updated October 2, 2025\n-\nSend Feedback\nTable of Contents\n1. Difference between the driver and runtime APIs\n2. API synchronization behavior\n3. Stream synchronization behavior\n4. Graph object thread safety\n5. Rules for version mixing\n6. Modules\n6.1. Data types used by CUDA driver\n6.2. Error Handling\n6.3. Initialization\n6.4. Version Management\n6.5. Device Management\n6.6. Device Management [DEPRECATED]\n6.7. Primary Context Management\n6.8. Context Management\n6.9. Context Management [DEPRECATED]\n6.10. Module Management\n6.11. Module Management [DEPRECATED]\n6.12. Library Management\n6.13. Memory Management\n6.14. Virtual Memory Management\n6.15. Stream Ordered Memory Allocator\n6.16. Multicast Object Management\n6.17. Unified Addressing\n6.18. Stream Management\n6.19. Event Management\n6.20. External Resource Interoperability\n6.21. Stream Memory Operations\n6.22. Execution Control\n6.23. Execution Control [DEPRECATED]\n6.24. Graph Management\n6.25. Occupancy\n6.26. Texture Reference Management [DEPRECATED]\n6.27. Surface Reference Management [DEPRECATED]\n6.28. Texture Object Management\n6.29. Surface Object Management\n6.30. Tensor Map Object Managment\n6.31. Peer Context Memory Access\n6.32. Graphics Interoperability\n6.33. Driver Entry Point Access\n6.34. Coredump Attributes Control API\n6.35. Green Contexts\n6.36. Error Log Management Functions\n6.37. CUDA Checkpointing\n6.38. Profiler Control [DEPRECATED]\n6.39. Profiler Control\n6.40. OpenGL Interoperability\n6.40.1. OpenGL Interoperability [DEPRECATED]\n6.41. Direct3D 9 Interoperability\n6.41.1. Direct3D 9 Interoperability [DEPRECATED]\n6.42. Direct3D 10 Interoperability\n6.42.1. Direct3D 10 Interoperability [DEPRECATED]\n6.43. Direct3D 11 Interoperability\n6.43.1. Direct3D 11 Interoperability [DEPRECATED]\n6.44. VDPAU Interoperability\n6.45. EGL Interoperability\n7. Data Structures\n7.1. CUaccessPolicyWindow_v1\n7.2. CUarrayMapInfo_v1\n7.3. CUasyncNotificationInfo\n7.4. CUcheckpointCheckpointArgs\n7.5. CUcheckpointGpuPair\n7.6. CUcheckpointLockArgs\n7.7. CUcheckpointRestoreArgs\n7.8. CUcheckpointUnlockArgs\n7.9. CUctxCigParam\n7.10. CUctxCreateParams\n7.11. CUDA_ARRAY3D_DESCRIPTOR_v2\n7.12. CUDA_ARRAY_DESCRIPTOR_v2\n7.13. CUDA_ARRAY_MEMORY_REQUIREMENTS_v1\n7.14. CUDA_ARRAY_SPARSE_PROPERTIES_v1\n7.15. CUDA_BATCH_MEM_OP_NODE_PARAMS_v1\n7.16.\n7.17. CUDA_CHILD_GRAPH_NODE_PARAMS\n7.18. CUDA_CONDITIONAL_NODE_PARAMS\n7.19. CUDA_EVENT_RECORD_NODE_PARAMS\n7.20. CUDA_EVENT_WAIT_NODE_PARAMS\n7.21. CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1\n7.22. CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2\n7.23. CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1\n7.24. CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2\n7.25. CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1\n7.26. CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1\n7.27. CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1\n7.28. CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1\n7.29. CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1\n7.30. CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1\n7.31. CUDA_GRAPH_INSTANTIATE_PARAMS\n7.32. CUDA_HOST_NODE_PARAMS_v1\n7.33. CUDA_HOST_NODE_PARAMS_v2\n7.34. CUDA_KERNEL_NODE_PARAMS_v1\n7.35. CUDA_KERNEL_NODE_PARAMS_v2\n7.36. CUDA_KERNEL_NODE_PARAMS_v3\n7.37. CUDA_LAUNCH_PARAMS_v1\n7.38. CUDA_MEM_ALLOC_NODE_PARAMS_v1\n7.39. CUDA_MEM_ALLOC_NODE_PARAMS_v2\n7.40. CUDA_MEM_FREE_NODE_PARAMS\n7.41. CUDA_MEMCPY2D_v2\n7.42. CUDA_MEMCPY3D_PEER_v1\n7.43. CUDA_MEMCPY3D_v2\n7.44. CUDA_MEMCPY_NODE_PARAMS\n7.45. CUDA_MEMSET_NODE_PARAMS_v1\n7.46. CUDA_MEMSET_NODE_PARAMS_v2\n7.47. CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1\n7.48. CUDA_RESOURCE_DESC_v1\n7.49. CUDA_RESOURCE_VIEW_DESC_v1\n7.50. CUDA_TEXTURE_DESC_v1\n7.51. CUdevprop_v1\n7.52. CUdevResource\n7.53. CUdevSmResource\n7.54. CUeglFrame_v1\n7.55. CUexecAffinityParam_v1\n7.56. CUexecAffinitySmCount_v1\n7.57. CUextent3D_v1\n7.58. CUgraphEdgeData\n7.59. CUgraphExecUpdateResultInfo_v1\n7.60. CUgraphNodeParams\n7.61. CUipcEventHandle_v1\n7.62. CUipcMemHandle_v1\n7.63. CUlaunchAttribute\n7.64. CUlaunchAttributeValue\n7.65. CUlaunchConfig\n7.66. CUlaunchMemSyncDomainMap\n7.67. CUmemAccessDesc_v1\n7.68. CUmemAllocationProp_v1\n7.69. CUmemcpy3DOperand_v1\n7.70. CUmemcpyAttributes_v1\n7.71. CUmemDecompressParams\n7.72. CUmemFabricHandle_v1\n7.73. CUmemLocation_v1\n7.74. CUmemPoolProps_v1\n7.75. CUmemPoolPtrExportData_v1\n7.76. CUmulticastObjectProp_v1\n7.77. CUoffset3D_v1\n7.78. CUstreamBatchMemOpParams_v1\n7.79. CUtensorMap\n8. Data Fields\n9. Deprecated List", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://docs.nvidia.com/cuda/cuda-driver-api/index.html"}}
{"text": "1. Introduction — cuBLAS 13.0 documentation\n»\n1.\nIntroduction\nv13.0 |\nPDF\n|\nArchive\ncuBLAS\nThe API Reference guide for cuBLAS, the CUDA Basic Linear Algebra Subroutine library.\n1.\nIntroduction\n\nThe cuBLAS library is an implementation of BLAS (Basic Linear Algebra Subprograms) on top of the NVIDIA®CUDA™ runtime. It allows the user to access the computational resources of NVIDIA Graphics Processing Unit (GPU).\nThe cuBLAS Library exposes four sets of APIs:\nThe\ncuBLAS API\n, which is simply called cuBLAS API in this document (starting with CUDA 6.0),\nThe\ncuBLASXt API\n(starting with CUDA 6.0), and\nThe\ncuBLASLt API\n(starting with CUDA 10.1)\nThe\ncuBLASDx API\n(not shipped with the CUDA Toolkit)\nTo use the cuBLAS API, the application must allocate the required matrices and vectors in the GPU memory space, fill them with data, call the sequence of desired cuBLAS functions, and then upload the results from the GPU memory space back to the host. The cuBLAS API also provides helper functions for writing and retrieving data from the GPU.\nTo use the cuBLASXt API, the application may have the data on the Host or any of the devices involved in the computation, and the Library will take care of dispatching the operation to, and transferring the data to, one or multiple GPUs present in the system, depending on the user request.\nThe cuBLASLt is a lightweight library dedicated to GEneral Matrix-to-matrix Multiply (GEMM) operations with a new flexible API. This library adds flexibility in matrix data layouts, input types, compute types, and also in choosing the algorithmic implementations and heuristics through parameter programmability. After a set of options for the intended GEMM operation are identified by the user, these options can be used repeatedly for different inputs. This is analogous to how cuFFT and FFTW first create a plan and reuse for same size and type FFTs with different input data.\n1.1.\nData Layout\n\nFor maximum compatibility with existing Fortran environments, the cuBLAS library uses column-major storage, and 1-based indexing. Since C and C++ use row-major storage, applications written in these languages can not use the native array semantics for two-dimensional arrays. Instead, macros or inline functions should be defined to implement matrices on top of one-dimensional arrays. For Fortran code ported to C in mechanical fashion, one may chose to retain 1-based indexing to avoid the need to transform loops. In this case, the array index of a matrix element in row “i” and column “j” can be computed via the following macro\n#define IDX2F(i,j,ld) ((((j)-1)*(ld))+((i)-1))\nHere, ld refers to the leading dimension of the matrix, which in the case of column-major storage is the number of rows of the allocated matrix (even if only a submatrix of it is being used). For natively written C and C++ code, one would most likely choose 0-based indexing, in which case the array index of a matrix element in row “i” and column “j” can be computed via the following macro\n#define IDX2C(i,j,ld) (((j)*(ld))+(i))\n1.2.\nNew and Legacy cuBLAS API\n\nStarting with version 4.0, the cuBLAS Library provides a new API, in addition to the existing legacy API. This section discusses why a new API is provided, the advantages of using it, and the differences with the existing legacy API.\nWarning\nThe legacy cuBLAS API is deprecated and will be removed in future release.\nThe new cuBLAS library API can be used by including the header file\ncublas_v2.h\n. It has the following features that the legacy cuBLAS API does not have:\nThe\nhandle\nto the cuBLAS library context is initialized using the function and is explicitly passed to every subsequent library function call. This allows the user to have more control over the library setup when using multiple host threads and multiple GPUs. This also allows the cuBLAS APIs to be reentrant.\nThe scalars\n\\(\\alpha\\)\nand\n\\(\\beta\\)\ncan be passed by reference on the host or the device, instead of only being allowed to be passed by value on the host. This change allows library functions to execute asynchronously using streams even when\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare generated by a previous kernel.\nWhen a library routine returns a scalar result, it can be returned by reference on the host or the device, instead of only being allowed to be returned by value only on the host. This change allows library routines to be called asynchronously when the scalar result is generated and returned by reference on the device resulting in maximum parallelism.\nThe error status\ncublasStatus_t\nis returned by all cuBLAS library function calls. This change facilitates debugging and simplifies software development. Note that\ncublasStatus\nwas renamed\ncublasStatus_t\nto be more consistent with other types in the cuBLAS library.\nThe\ncublasAlloc()\nand\ncublasFree()\nfunctions have been deprecated. This change removes these unnecessary wrappers around\ncudaMalloc()\nand\ncudaFree()\n, respectively.\nThe function\ncublasSetKernelStream()\nwas renamed\ncublasSetStream()\nto be more consistent with the other CUDA libraries.\nThe legacy cuBLAS API, explained in more detail in\nUsing the cuBLAS Legacy API\n, can be used by including the header file\ncublas.h\n. Since the legacy API is identical to the previously released cuBLAS library API, existing applications will work out of the box and automatically use this legacy API without any source code changes.\nThe current and the legacy cuBLAS APIs cannot be used simultaneously in a single translation unit: including both\ncublas.h\nand\ncublas_v2.h\nheader files will lead to compilation errors due to incompatible symbol redeclarations.\nIn general, new applications should not use the legacy cuBLAS API, and existing applications should convert to using the new API if it requires sophisticated and optimal stream parallelism, or if it calls cuBLAS routines concurrently from multiple threads.\nFor the rest of the document, the new cuBLAS Library API will simply be referred to as the cuBLAS Library API.\nAs mentioned earlier the interfaces to the legacy and the cuBLAS library APIs are the header file\ncublas.h\nand\ncublas_v2.h\n, respectively. In addition, applications using the cuBLAS library need to link against:\nThe DSO\ncublas.so\nfor Linux,\nThe DLL\ncublas.dll\nfor Windows, or\nThe dynamic library\ncublas.dylib\nfor Mac OS X.\nNote\nThe same dynamic library implements both the new and legacy cuBLAS APIs.\n1.3.\nExample Code\n\nFor sample code references please see the two examples below. They show an application written in C using the cuBLAS library API with two indexing styles (Example 1. “Application Using C and cuBLAS: 1-based indexing” and Example 2. “Application Using C and cuBLAS: 0-based Indexing”).\n//Example 1. Application Using C and cuBLAS: 1-based indexing\n//-----------------------------------------------------------\n#include\n<stdio.h>\n#include\n<stdlib.h>\n#include\n<math.h>\n#include\n<cuda_runtime.h>\n#include\n\"cublas_v2.h\"\n#define M 6\n#define N 5\n#define IDX2F(i,j,ld) ((((j)-1)*(ld))+((i)-1))\nstatic\n__inline__\nvoid\nmodify\n(\ncublasHandle_t\nhandle\n,\nfloat\n*\nm\n,\nint\nldm\n,\nint\nn\n,\nint\np\n,\nint\nq\n,\nfloat\nalpha\n,\nfloat\nbeta\n){\ncublasSscal\n(\nhandle\n,\nn\n-\nq\n+\n1\n,\n&\nalpha\n,\n&\nm\n[\nIDX2F\n(\np\n,\nq\n,\nldm\n)],\nldm\n);\ncublasSscal\n(\nhandle\n,\nldm\n-\np\n+\n1\n,\n&\nbeta\n,\n&\nm\n[\nIDX2F\n(\np\n,\nq\n,\nldm\n)],\n1\n);\n}\nint\nmain\n(\nvoid\n){\ncudaError_t\ncudaStat\n;\ncublasStatus_t\nstat\n;\ncublasHandle_t\nhandle\n;\nint\ni\n,\nj\n;\nfloat\n*\ndevPtrA\n;\nfloat\n*\na\n=\n0\n;\na\n=\n(\nfloat\n*\n)\nmalloc\n(\nM\n*\nN\n*\nsizeof\n(\n*\na\n));\nif\n(\n!\na\n)\n{\nprintf\n(\n\"host memory allocation failed\"\n);\nreturn\nEXIT_FAILURE\n;\n}\nfor\n(\nj\n=\n1\n;\nj\n<=\nN\n;\nj\n++\n)\n{\nfor\n(\ni\n=\n1\n;\ni\n<=\nM\n;\ni\n++\n)\n{\na\n[\nIDX2F\n(\ni\n,\nj\n,\nM\n)]\n=\n(\nfloat\n)((\ni\n-1\n)\n*\nN\n+\nj\n);\n}\n}\ncudaStat\n=\ncudaMalloc\n((\nvoid\n**\n)\n&\ndevPtrA\n,\nM\n*\nN\n*\nsizeof\n(\n*\na\n));\nif\n(\ncudaStat\n!=\ncudaSuccess\n)\n{\nprintf\n(\n\"device memory allocation failed\"\n);\nfree\n(\na\n);\nreturn\nEXIT_FAILURE\n;\n}\nstat\n=\ncublasCreate\n(\n&\nhandle\n);\nif\n(\nstat\n!=\nCUBLAS_STATUS_SUCCESS\n)\n{\nprintf\n(\n\"CUBLAS initialization failed\n\\n\n\"\n);\nfree\n(\na\n);\ncudaFree\n(\ndevPtrA\n);\nreturn\nEXIT_FAILURE\n;\n}\nstat\n=\ncublasSetMatrix\n(\nM\n,\nN\n,\nsizeof\n(\n*\na\n),\na\n,\nM\n,\ndevPtrA\n,\nM\n);\nif\n(\nstat\n!=\nCUBLAS_STATUS_SUCCESS\n)\n{\nprintf\n(\n\"data download failed\"\n);\nfree\n(\na\n);\ncudaFree\n(\ndevPtrA\n);\ncublasDestroy\n(\nhandle\n);\nreturn\nEXIT_FAILURE\n;\n}\nmodify\n(\nhandle\n,\ndevPtrA\n,\nM\n,\nN\n,\n2\n,\n3\n,\n16.0f\n,\n12.0f\n);\nstat\n=\ncublasGetMatrix\n(\nM\n,\nN\n,\nsizeof\n(\n*\na\n),\ndevPtrA\n,\nM\n,\na\n,\nM\n);\nif\n(\nstat\n!=\nCUBLAS_STATUS_SUCCESS\n)\n{\nprintf\n(\n\"data upload failed\"\n);\nfree\n(\na\n);\ncudaFree\n(\ndevPtrA\n);\ncublasDestroy\n(\nhandle\n);\nreturn\nEXIT_FAILURE\n;\n}\ncudaFree\n(\ndevPtrA\n);\ncublasDestroy\n(\nhandle\n);\nfor\n(\nj\n=\n1\n;\nj\n<=\nN\n;\nj\n++\n)\n{\nfor\n(\ni\n=\n1\n;\ni\n<=\nM\n;\ni\n++\n)\n{\nprintf\n(\n\"%7.0f\"\n,\na\n[\nIDX2F\n(\ni\n,\nj\n,\nM\n)]);\n}\nprintf\n(\n\"\n\\n\n\"\n);\n}\nfree\n(\na\n);\nreturn\nEXIT_SUCCESS\n;\n}\n//Example 2. Application Using C and cuBLAS: 0-based indexing\n//-----------------------------------------------------------\n#include\n<stdio.h>\n#include\n<stdlib.h>\n#include\n<math.h>\n#include\n<cuda_runtime.h>\n#include\n\"cublas_v2.h\"\n#define M 6\n#define N 5\n#define IDX2C(i,j,ld) (((j)*(ld))+(i))\nstatic\n__inline__\nvoid\nmodify\n(\ncublasHandle_t\nhandle\n,\nfloat\n*\nm\n,\nint\nldm\n,\nint\nn\n,\nint\np\n,\nint\nq\n,\nfloat\nalpha\n,\nfloat\nbeta\n){\ncublasSscal\n(\nhandle\n,\nn\n-\nq\n,\n&\nalpha\n,\n&\nm\n[\nIDX2C\n(\np\n,\nq\n,\nldm\n)],\nldm\n);\ncublasSscal\n(\nhandle\n,\nldm\n-\np\n,\n&\nbeta\n,\n&\nm\n[\nIDX2C\n(\np\n,\nq\n,\nldm\n)],\n1\n);\n}\nint\nmain\n(\nvoid\n){\ncudaError_t\ncudaStat\n;\ncublasStatus_t\nstat\n;\ncublasHandle_t\nhandle\n;\nint\ni\n,\nj\n;\nfloat\n*\ndevPtrA\n;\nfloat\n*\na\n=\n0\n;\na\n=\n(\nfloat\n*\n)\nmalloc\n(\nM\n*\nN\n*\nsizeof\n(\n*\na\n));\nif\n(\n!\na\n)\n{\nprintf\n(\n\"host memory allocation failed\"\n);\nreturn\nEXIT_FAILURE\n;\n}\nfor\n(\nj\n=\n0\n;\nj\n<\nN\n;\nj\n++\n)\n{\nfor\n(\ni\n=\n0\n;\ni\n<\nM\n;\ni\n++\n)\n{\na\n[\nIDX2C\n(\ni\n,\nj\n,\nM\n)]\n=\n(\nfloat\n)(\ni\n*\nN\n+\nj\n+\n1\n);\n}\n}\ncudaStat\n=\ncudaMalloc\n((\nvoid\n**\n)\n&\ndevPtrA\n,\nM\n*\nN\n*\nsizeof\n(\n*\na\n));\nif\n(\ncudaStat\n!=\ncudaSuccess\n)\n{\nprintf\n(\n\"device memory allocation failed\"\n);\nfree\n(\na\n);\nreturn\nEXIT_FAILURE\n;\n}\nstat\n=\ncublasCreate\n(\n&\nhandle\n);\nif\n(\nstat\n!=\nCUBLAS_STATUS_SUCCESS\n)\n{\nprintf\n(\n\"CUBLAS initialization failed\n\\n\n\"\n);\nfree\n(\na\n);\ncudaFree\n(\ndevPtrA\n);\nreturn\nEXIT_FAILURE\n;\n}\nstat\n=\ncublasSetMatrix\n(\nM\n,\nN\n,\nsizeof\n(\n*\na\n),\na\n,\nM\n,\ndevPtrA\n,\nM\n);\nif\n(\nstat\n!=\nCUBLAS_STATUS_SUCCESS\n)\n{\nprintf\n(\n\"data download failed\"\n);\nfree\n(\na\n);\ncudaFree\n(\ndevPtrA\n);\ncublasDestroy\n(\nhandle\n);\nreturn\nEXIT_FAILURE\n;\n}\nmodify\n(\nhandle\n,\ndevPtrA\n,\nM\n,\nN\n,\n1\n,\n2\n,\n16.0f\n,\n12.0f\n);\nstat\n=\ncublasGetMatrix\n(\nM\n,\nN\n,\nsizeof\n(\n*\na\n),\ndevPtrA\n,\nM\n,\na\n,\nM\n);\nif\n(\nstat\n!=\nCUBLAS_STATUS_SUCCESS\n)\n{\nprintf\n(\n\"data upload failed\"\n);\nfree\n(\na\n);\ncudaFree\n(\ndevPtrA\n);\ncublasDestroy\n(\nhandle\n);\nreturn\nEXIT_FAILURE\n;\n}\ncudaFree\n(\ndevPtrA\n);\ncublasDestroy\n(\nhandle\n);\nfor\n(\nj\n=\n0\n;\nj\n<\nN\n;\nj\n++\n)\n{\nfor\n(\ni\n=\n0\n;\ni\n<\nM\n;\ni\n++\n)\n{\nprintf\n(\n\"%7.0f\"\n,\na\n[\nIDX2C\n(\ni\n,\nj\n,\nM\n)]);\n}\nprintf\n(\n\"\n\\n\n\"\n);\n}\nfree\n(\na\n);\nreturn\nEXIT_SUCCESS\n;\n}\n1.4.\nForward Compatibility\n\ncuBLAS library can work on future GPUs in most cases thanks to PTX JIT. However, there are certain limitations:\nThere are no performance guarantees: running on new hardware may be slower despite better theoretical peaks.\nThere is limited forward compatibility for narrow precisions (FP4 and FP8) and tiled 8-bit integer layouts.\n1.5.\nFloating Point Emulation\n\nFloating point emulation was first introduced in CUDA 12.9 and is used to further accelerate matrix multiplication for higher precision data types. Floating point emulation works by first transforming the inputs into multiple lower precision values, then leverages lower precision hardware units to compute partial results, and finally recombines the results back into full precision. These algorithms can provide a significant performance advantage over native precision arithmetic while maintaining the same or better accuracy; however, the results are not IEEE-754 compliant.\nFloating Point Emulation Support Overview\n\nFloating Point Emulation Algorithm\nPrecision Emulated\nSupported compute capabilities\nCUDA Version\nBF16x9\nFP32\n10.0, 10.3\n12.9+\nFixed-Point\nFP64\n8.x, 9.0, 10.0, 11.0, 12.x\n13.0u2+\nTo enable floating point emulation without any code changes, the following environment variables can be used.\nFloating Point Emulation Environment Variables\n\nEnvironment Variable\nDescription\nCUBLAS_EMULATION_STRATEGY\nAn environment variable for overriding the default emulation strategy. The valid values are\nperformant\nand\neager\n; see\ncublasEmulationStrategy_t\nfor more details.\nCUBLAS_EMULATE_SINGLE_PRECISION\nAn environment variable for enabling and disabling single precision floating point emulation using the values 1 and 0, respectively.\nCUBLAS_EMULATE_DOUBLE_PRECISION\nAn environment variable for enabling and disabling double precision floating point emulation using the values 1 and 0, respectively.\nCUBLAS_FIXEDPOINT_EMULATION_MANTISSA_BIT_COUNT\nThe number of mantissa bits to be used for fixed-point emulation.  When set, emulated algorithms will use the specified number of mantissa bits.  This is equivalent to calling\ncublasSetFixedPointEmulationMantissaControl()\nwith\nCUDA_EMULATION_MANTISSA_CONTROL_FIXED\n(see\ncudaEmulationMantissaControl_t\n) and\ncublasSetFixedPointEmulationMaxMantissaBitCount()\nto the user-provided value.\n1.5.1.\nBF16x9\n\nThe BF16x9 algorithm is used for emulating FP32 arithmetic. An FP32 value can be exactly represented as three BF16 values as follows:\n\\[\\begin{split}a & = a_0 + 2^{-8} a_1 + 2^{-16} a_2 \\\\\\end{split}\\]\nWe can fully reconstruct the FP32 value from the BF16 values without any loss of accuracy. Using this, we define an FMA operation (\nd = ab + c\n) as follows:\n\\[\\begin{split}d & = ab + c \\\\\n& = (a_0 + 2^{-8} a_1 + 2^{-16} a_2) \\cdot (b_0 + 2^{-8} b_1 + 2^{-16} b_2) + c \\\\\n& = a_0b_0 + 2^{-8}a_0b_1 + 2^{-16}a_0b_2 \\\\\n& \\quad + 2^{-8}a_1b_0 + 2^{-16}a_1b_1 + 2^{-24}a_1b_2 \\\\\n& \\quad + 2^{-16}a_2b_0 + 2^{-24}a_2b_1 + 2^{-32}a_2b_2 + c \\\\\\end{split}\\]\nIn practice, the BF16 tensor cores are utilized rather than FMA units and this idea naturally extends into complex arithmetic as well.\nWhile BF16x9 can be supported on all hardware, it only provides a performance advantage when peak BF16 throughput is more than nine times greater than peak FP32 throughput. It also requires special hardware features to apply the additional scaling factors in a performant manner. As a result, BF16x9 is only supported on select architectures. See the\nFloating Point Emulation Support Overview\ntable for more details.\n1.5.2.\nFixed-Point\n\nFixed-point emulation is used for emulating FP64 arithmetic and follows the\nOzaki Scheme\n. Fixed-point representations emulate floating point through the addition of a shared power of two scaling factor and by encoding the remaining dynamic range of floating point within mantissa bits. The scaling factor is shared for elements in the same row of the A matrix or column of the B matrix and is used to logically scale all elements to be between -1 and 1 inclusively.\nDue to the large dynamic range of FP64, there is no single configuration of fixed-point which is both performant and accurate for all floating point inputs.  Therefore, we enable two flavors of fixed-point emulation:\nDynamic Mantissa Control\nand\nFixed Mantissa Control\n. These configurations can be set with\ncublasSetFixedPointEmulationMantissaControl()\n.\n1.5.2.1.\nDynamic Mantissa Control\n\nDynamic mantissa control represents the cuBLAS library default mantissa control.  Our automatic dynamic precision framework computes the proper number of fixed-point mantissa bits required to maintain equal or better accuracy than FP64.  If the number of required mantissa bits exceeds a library defined default (see\nDefault Library Configurations\n) or a user provided maximum number of bits (see\ncublasSetFixedPointEmulationMaxMantissaBitCount()\n), the framework dynamically dispatches to native FP64.\n1.5.2.2.\nFixed Mantissa Control\n\nFixed mantissa control can be leveraged to further accelerate fixed-point emulation.  The user can provide the number of mantissa bits for the fixed-point representation via\ncublasSetFixedPointEmulationMaxMantissaBitCount()\n; however, without the automatic dynamic precision framework, it is not possible to guarantee equal or better accuracy than FP64 arithmetic.\n1.5.2.3.\nRepresentation and Mappings\n\nThe fixed-point representation consists of a shared scaling factor for elements in the same row or column of a matrix, a sign bit, and mantissa bits.  We store the sign bit and mantissa bits within 8-bit integers.  Each matrix of 8-bit integers are referred to as a slice and the computational cost grows quadratically with the number of slices.  The formula to convert mantissa bit count to slice count is as follows:\n\\[\\text{sliceCount} = \\text{ceildiv}(\\text{mantissaBitCount} + 1, 8)\\]\nNote\nThe number of mantissa bits will always be rounded up to fully occupy the least significant slice\n1.5.2.4.\nFixed-Point Workspace Requirements\n\nTo compute with fixed-point emulation, the A and B matrices are translated into a fixed-point representation in workspace memory.  This leads to workspace requirements that are problem size and emulation parameter dependent.  The following function will provide a safe bound (possibly overestimating) on the workspace required for fixed-point emulation:\nsize_t\ngetFixedPointWorkspaceSizeInBytes\n(\nint\nm\n,\nint\nn\n,\nint\nk\n,\nint\nbatchCount\n,\nbool\nisComplex\n,\ncudaEmulationMantissaControl\nmantissaControl\n,\nint\nmaxMantissaBitCount\n)\n{\nconstexpr\ndouble\nMULTIPLIER\n=\n1.25\n;\nint\nmult\n=\nisComplex\n?\n2\n:\n1\n;\nint\nnumSlices\n=\nceildiv\n(\nmaxMantissaBitCount\n+\n1\n,\n8\n);\nint\npadded_m\n=\nceildiv\n(\nm\n,\n1024\n)\n*\n1024\n;\nint\npadded_n\n=\nceildiv\n(\nn\n,\n1024\n)\n*\n1024\n;\nint\npadded_k\n=\nceildiv\n(\nk\n,\n128\n)\n*\n128\n;\nint\nnum_blocks_k\n=\nceildiv\n(\nk\n,\n64\n);\nsize_t\ngemm_workspace\n=\nsizeof\n(\nint8_t\n)\n*\n((\nsize_t\n)\npadded_m\n*\npadded_k\n+\n(\nsize_t\n)\npadded_n\n*\npadded_k\n)\n*\nmult\n*\nnumSlices\n;\ngemm_workspace\n+=\nsizeof\n(\nint32_t\n)\n*\n((\nsize_t\n)\npadded_m\n+\npadded_n\n)\n*\nmult\n;\nif\n(\nisComplex\n)\n{\ngemm_workspace\n+=\nsizeof\n(\ndouble\n)\n*\n(\nsize_t\n)\nm\n*\nn\n*\nmult\n*\nmult\n;\n}\nsize_t\nadp_workspace\n=\n0\n;\nif\n(\nmantissaControl\n==\nCUDA_EMULATION_MANTISSA_CONTROL_DYNAMIC\n)\n{\nadp_workspace\n=\nsizeof\n(\nint32_t\n)\n*\n((\nsize_t\n)\nm\n*\nnum_blocks_k\n+\n(\nsize_t\n)\nn\n*\nnum_blocks_k\n+\n(\nsize_t\n)\nm\n*\nn\n)\n*\nmult\n;\n}\nconstexpr\nsize_t\nCONSTANT_SIZE\n=\n128\n*\n1024\n*\n1024\n;\nreturn\n(\nsize_t\n)(\nstd\n::\nmax\n(\ngemm_workspace\n,\nadp_workspace\n)\n*\nbatchCount\n*\nMULTIPLIER\n)\n+\nCONSTANT_SIZE\n;\n}\nThis function can be used to manage your own workspace memory with\ncublasSetWorkspace()\n, which can be used to guarantee\nreproducible results\nand\nimprove performance\n.\n1.5.2.5.\nFixed-Point Performance Guide\n\nFixed-point emulation allows users to make performance and precision trade-offs for further acceleration.  For dynamic mantissa control, users are able to configure the automatic dynamic precision framework to use fewer or more bits than the accuracy of native FP64 requires with\ncublasSetFixedPointEmulationMantissaBitOffset()\n.  Fixed mantissa control can be similarly tuned by increasing or decreasing the number of mantissa bits with\ncublasSetFixedPointEmulationMaxMantissaBitCount()\n.\nDue to the large\nfixed-point workspace requirements\n, asynchronous allocation is done with\ncudaMallocAsync()\n.  In cases where not enough GEMMs are called to amortize the cost of memory allocation, or very frequent CUDA stream synchronization occurs, you can improve performance by:\nReducing the number of CUDA stream synchronizations\nManaging your own memory and providing workspace with\ncublasSetWorkspace()\nAllowing the\ndefault memory pool\nto retain memory between synchronizations\n1.5.3.\nDefault Library Configurations\n\nLibrary default values for emulation are subject to change.\nEmulation Configuration Default Values\n\nAPI\nMantissa Control\nDefault Behavior\ncublasGetEmulationStrategy()\nNot applicable\nCUBLAS_EMULATION_STRATEGY_DEFAULT\ncublasGetEmulationSpecialValuesSupport()\nNot applicable\nCUBLAS_EMULATION_SPECIAL_VALUES_SUPPORT_DEFAULT\ncublasGetFixedPointEmulationMantissaControl()\nNot applicable\nCUDA_EMULATION_MANTISSA_CONTROL_DYNAMIC\ncublasGetFixedPointEmulationMaxMantissaBitCount()\nCUDA_EMULATION_MANTISSA_CONTROL_DYNAMIC\n79\ncublasGetFixedPointEmulationMaxMantissaBitCount()\nCUDA_EMULATION_MANTISSA_CONTROL_FIXED\n55\ncublasGetFixedPointEmulationMantissaBitOffset()\nNot applicable\n0\ncublasGetFixedPointEmulationMantissaBitCountPointer()\nNot applicable\nNULL\n1.5.4.\nSupport For Floating Point Special Values\n\nThe implementations of floating point emulation algorithms maintain the accuracy of the emulated precision for both normal and denormalized values but may not adhere to the IEEE-754 standard with respect to\n\\(\\text{Inf}\\)\n,\n\\(\\text{NaN}\\)\n, or signed zeros.  If the underlying emulated algorithm cannot implicitly support a given special value, and the library is configured to support it (see\ncublasSetEmulationSpecialValuesSupport()\n), then extra steps are taken to support it.  The following table shows which special values are implicitly supported for each emulation algorithm.\nEmulation Algorithms Implicit Special Values Support\n\nFloating Point Emulation Algorithm\nImplicitly Supported Special Values\nBF16x9\n\\(\\text{NaN}\\)\nFixed-Point\nNone\n2.\nUsing the cuBLAS API\n\n2.1.\nGeneral Description\n\nThis section describes how to use the cuBLAS library API.\n2.1.1.\nError Status\n\nAll cuBLAS library function calls return the error status\ncublasStatus_t\n.\n2.1.2.\ncuBLAS Context\n\nThe application must initialize a handle to the cuBLAS library context by calling the\ncublasCreate()\nfunction. Then, the handle is explicitly passed to every subsequent library function call. Once the application finishes using the library, it must call the function\ncublasDestroy()\nto release the resources associated with the cuBLAS library context.\nThis approach allows the user to explicitly control the library setup when using multiple host threads and multiple GPUs. For example, the application can use\ncudaSetDevice()\nto associate different devices with different host threads and in each of those host threads it can initialize a unique handle to the cuBLAS library context, which will use the particular device associated with that host thread. Then, the cuBLAS library function calls made with different handles will automatically dispatch the computation to different devices.\nThe device associated with a particular cuBLAS context is assumed to remain unchanged between the corresponding\ncublasCreate()\nand\ncublasDestroy()\ncalls. In order for the cuBLAS library to use a different device in the same host thread, the application must set the new device to be used by calling\ncudaSetDevice()\nand then create another cuBLAS context, which will be associated with the new device, by calling\ncublasCreate()\n. When multiple devices are available, applications must ensure that the device associated with a given cuBLAS context is current (e.g. by calling\ncudaSetDevice()\n) before invoking cuBLAS functions with this context.\nA cuBLAS library context is tightly coupled with the CUDA context that is current at the time of the\ncublasCreate()\ncall. An application that uses multiple CUDA contexts is required to create a cuBLAS context per CUDA context and make sure the former never outlives the latter. Starting from version 12.8, cuBLAS detects if the underlying CUDA context is tied to a graphics context and follows the shared memory size limits that are set in such case.\n2.1.3.\nThread Safety\n\nThe library is thread safe and its functions can be called from multiple host threads, even with the same handle. When multiple threads share the same handle, extreme care needs to be taken when the handle configuration is changed because that change will affect potentially subsequent cuBLAS calls in all threads. It is even more true for the destruction of the handle. So it is not recommended that multiple thread share the same cuBLAS handle.\nAdditional considerations apply when the same handle is used from multiple threads with a user provided workspace. See\ncublasSetWorkspace()\nfor details.\n2.1.4.\nResults Reproducibility\n\nBy design, all cuBLAS API routines from a given toolkit version, generate the same bit-wise results at every run when executed on GPUs with the same architecture and the same number of SMs. However, bit-wise reproducibility is not guaranteed across toolkit versions because the implementation might differ due to some implementation changes.\nThis guarantee no longer holds when multiple CUDA streams are active or\nfixed-point\nemulation is used. If multiple concurrent streams are active, the library may optimize total performance by picking different internal implementations.\nNote\nThe non-deterministic behavior of multi-stream execution is due to library optimizations in selecting internal workspace for the routines running in parallel streams. To avoid this effect user can either:\nprovide a separate workspace for each used stream using the\ncublasSetWorkspace()\nfunction, or\nhave one cuBLAS handle per stream, or\nuse\ncublasLtMatmul()\ninstead of GEMM-family of functions and provide user owned workspace, or\nset a debug environment variable\nCUBLAS_WORKSPACE_CONFIG\nto\n:16:8\n(may limit overall performance) or\n:4096:8\n(will increase library footprint in GPU memory by approximately 24MiB).\nThe non-deterministic behavior of\nfixed-point\nemulation is due to the large workspace memory requirements (see\nFixed-Point Workspace Requirements\nfor details).  This requires dynamically allocating memory with\ncudaMallocAsync()\nand allocation failures result in fallbacks to non-emulated routines. To avoid this effect, users can provide workspace via\ncublasSetWorkspace()\nto meet fixed-point emulation workspace requirements.\nAny of those settings will allow for deterministic behavior even with multiple concurrent streams sharing a single cuBLAS handle.\nThis behavior is expected to change in a future release.\nFor some routines such as\ncublas<t>symv()\nand\ncublas<t>hemv()\n, an alternate significantly faster routine can be chosen using the routine\ncublasSetAtomicsMode()\n. In that case, the results are not guaranteed to be bit-wise reproducible because atomics are used for the computation.\n2.1.5.\nScalar Parameters\n\nThere are two categories of the functions that use scalar parameters :\nFunctions that take\nalpha\nand/or\nbeta\nparameters by reference on the host or the device as scaling factors, such as\ngemm\n.\nFunctions that return a scalar result on the host or the device such as\namax()\n,\namin\n,\nasum()\n,\nrotg()\n,\nrotmg()\n,\ndot()\nand\nnrm2()\n.\nFor the functions of the first category, when the pointer mode is set to\nCUBLAS_POINTER_MODE_HOST\n, the scalar parameters\nalpha\nand/or\nbeta\ncan be on the stack or allocated on the heap, shouldn’t be placed in managed memory. Underneath, the CUDA kernels related to those functions will be launched with the value of\nalpha\nand/or\nbeta\n. Therefore if they were allocated on the heap, they can be freed just after the return of the call even though the kernel launch is asynchronous. When the pointer mode is set to\nCUBLAS_POINTER_MODE_DEVICE\n,\nalpha\nand/or\nbeta\nmust be accessible on the device and their values should not be modified until the kernel is done. Note that since\ncudaFree()\ndoes an implicit\ncudaDeviceSynchronize()\n,\ncudaFree()\ncan still be called on\nalpha\nand/or\nbeta\njust after the call but it would defeat the purpose of using this pointer mode in that case.\nFor the functions of the second category, when the pointer mode is set to\nCUBLAS_POINTER_MODE_HOST\n, these functions block the CPU, until the GPU has completed its computation and the results have been copied back to the Host. When the pointer mode is set to\nCUBLAS_POINTER_MODE_DEVICE\n, these functions return immediately. In this case, similar to matrix and vector results, the scalar result is ready only when execution of the routine on the GPU has completed. This requires proper synchronization in order to read the result from the host.\nIn either case, the pointer mode\nCUBLAS_POINTER_MODE_DEVICE\nallows the library functions to execute completely asynchronously from the Host even when\nalpha\nand/or\nbeta\nare generated by a previous kernel. For example, this situation can arise when iterative methods for solution of linear systems and eigenvalue problems are implemented using the cuBLAS library.\n2.1.6.\nParallelism with Streams\n\nIf the application uses the results computed by multiple independent tasks, CUDA™ streams can be used to overlap the computation performed in these tasks.\nThe application can conceptually associate each stream with each task. In order to achieve the overlap of computation between the tasks, the user should create CUDA™ streams using the function\ncudaStreamCreate()\nand set the stream to be used by each individual cuBLAS library routine by calling\ncublasSetStream()\njust before calling the actual cuBLAS routine. Note that\ncublasSetStream()\nresets the user-provided workspace to the default workspace pool; see\ncublasSetWorkspace()\n. Then, the computation performed in separate streams would be overlapped automatically when possible on the GPU. This approach is especially useful when the computation performed by a single task is relatively small and is not enough to fill the GPU with work.\nWe recommend using the new cuBLAS API with scalar parameters and results passed by reference in the device memory to achieve maximum overlap of the computation when using streams.\nA particular application of streams, batching of multiple small kernels, is described in the following section.\n2.1.7.\nBatching Kernels\n\nIn this section, we explain how to use streams to batch the execution of small kernels. For instance, suppose that we have an application where we need to make many small independent matrix-matrix multiplications with dense matrices.\nIt is clear that even with millions of small independent matrices we will not be able to achieve the same\nGFLOPS\nrate as with a one large matrix. For example, a single\n\\(n \\times n\\)\nlarge matrix-matrix multiplication performs\n\\(n^{3}\\)\noperations for\n\\(n^{2}\\)\ninput size, while 1024\n\\(\\frac{n}{32} \\times \\frac{n}{32}\\)\nsmall matrix-matrix multiplications perform\n\\(1024\\left( \\frac{n}{32} \\right)^{3} = \\frac{n^{3}}{32}\\)\noperations for the same input size. However, it is also clear that we can achieve a significantly better performance with many small independent matrices compared with a single small matrix.\nThe architecture family of GPUs allows us to execute multiple kernels simultaneously. Hence, in order to batch the execution of independent kernels, we can run each of them in a separate stream. In particular, in the above example we could create 1024 CUDA™ streams using the function\ncudaStreamCreate()\n, then preface each call to\ncublas<t>gemm()\nwith a call to\ncublasSetStream()\nwith a different stream for each of the matrix-matrix multiplications (note that\ncublasSetStream()\nresets user-provided workspace to the default workspace pool, see\ncublasSetWorkspace()\n). This will ensure that when possible the different computations will be executed concurrently. Although the user can create many streams, in practice it is not possible to have more than 32 concurrent kernels executing at the same time.\n2.1.8.\nCache Configuration\n\nOn some devices, L1 cache and shared memory use the same hardware resources. The cache configuration can be set directly with the CUDA Runtime function cudaDeviceSetCacheConfig. The cache configuration can also be set specifically for some functions using the routine cudaFuncSetCacheConfig. Please refer to the CUDA Runtime API documentation for details about the cache configuration settings.\nBecause switching from one configuration to another can affect kernels concurrency, the cuBLAS Library does not set any cache configuration preference and relies on the current setting. However, some cuBLAS routines, especially Level-3 routines, rely heavily on shared memory. Thus the cache preference setting might affect adversely their performance.\n2.1.9.\nStatic Library Support\n\nThe cuBLAS Library is also delivered in a static form as\nlibcublas_static.a\non Linux. The static cuBLAS library and all other static math libraries depend on a common thread abstraction layer library called\nlibculibos.a\n.\nFor example, on Linux, to compile a small application using cuBLAS, against the dynamic library, the following command can be used:\nnvcc\nmyCublasApp\n.\nc\n-\nlcublas\n-\no\nmyCublasApp\nWhereas to compile against the static cuBLAS library, the following command must be used:\nnvcc\nmyCublasApp\n.\nc\n-\nlcublas_static\n-\nlculibos\n-\no\nmyCublasApp\nIt is also possible to use the native Host C++ compiler. Depending on the Host operating system, some additional libraries like\npthread\nor\ndl\nmight be needed on the linking line. The following command on Linux is suggested :\ng\n++\nmyCublasApp\n.\nc\n-\nlcublas_static\n-\nlculibos\n-\nlcudart_static\n-\nlpthread\n-\nldl\n-\nI\n<\ncuda\n-\ntoolkit\n-\npath\n>/\ninclude\n-\nL\n<\ncuda\n-\ntoolkit\n-\npath\n>/\nlib64\n-\no\nmyCublasApp\nNote that in the latter case, the library\ncuda\nis not needed. The CUDA Runtime will try to open explicitly the\ncuda\nlibrary if needed. In the case of a system which does not have the CUDA driver installed, this allows the application to gracefully manage this issue and potentially run if a CPU-only path is available.\nStarting with release 11.2, using the typed functions instead of the extension functions (cublas**Ex()) helps in reducing the binary size when linking to static cuBLAS Library.\n2.1.10.\nGEMM Algorithms Numerical Behavior\n\nSome GEMM algorithms split the computation along the dimension K to increase the GPU occupancy, especially when the dimension K is large compared to dimensions M and N. When this type of algorithm is chosen by the cuBLAS heuristics or explicitly by the user, the results of each split is summed deterministically into the resulting matrix to get the final result.\nFor the routines\ncublas<t>gemmEx()\nand\ncublasGemmEx()\n, when the compute type is greater than the output type, the sum of the split chunks can potentially lead to some intermediate overflows thus producing a final resulting matrix with some overflows. Those overflows might not have occurred if all the dot products had been accumulated in the compute type before being converted at the end in the output type. This computation side-effect can be easily exposed when the computeType is\nCUDA_R_32F\nand Atype, Btype and Ctype are\nCUDA_R_16F\n. This behavior can be controlled using the compute precision mode\nCUBLAS_MATH_DISALLOW_REDUCED_PRECISION_REDUCTION\nwith\ncublasSetMathMode()\n2.1.11.\nTensor Core Usage\n\nTensor cores were first introduced with Volta GPUs (compute capability 7.0 and above) and significantly accelerate matrix multiplications. Starting with cuBLAS version 11.0.0, the library may automatically make use of Tensor Core capabilities wherever possible, unless they are explicitly disabled by selecting pedantic compute modes in cuBLAS (see\ncublasSetMathMode()\n,\ncublasMath_t\n).\nIt should be noted that the library will pick a Tensor Core enabled implementation wherever it determines that it would provide the best performance.\nThe best performance when using Tensor Cores can be achieved when the matrix dimensions and pointers meet certain memory alignment requirements. Specifically, all of the following conditions must be satisfied to get the most performance out of Tensor Cores:\n((op_A\n==\nCUBLAS_OP_N\n?\nm\n:\nk)\n*\nAtypeSize)\n%\n16\n==\n0\n((op_B\n==\nCUBLAS_OP_N\n?\nk\n:\nn)\n*\nBtypeSize)\n%\n16\n==\n0\n(m\n*\nCtypeSize)\n%\n16\n==\n0\n(lda\n*\nAtypeSize)\n%\n16\n==\n0\n(ldb\n*\nBtypeSize)\n%\n16\n==\n0\n(ldc\n*\nCtypeSize)\n%\n16\n==\n0\nintptr_t(A)\n%\n16\n==\n0\nintptr_t(B)\n%\n16\n==\n0\nintptr_t(C)\n%\n16\n==\n0\nTo conduct matrix multiplication with FP8 types (see\n8-bit Floating Point Data Types (FP8) Usage\n), you must ensure that your matrix dimensions and pointers meet the optimal requirements listed above.  Aside from FP8, there are no longer any restrictions on matrix dimensions and memory alignments to use Tensor Cores (starting with cuBLAS version 11.0.0).\n2.1.12.\nCUDA Graphs Support\n\ncuBLAS routines can be captured in CUDA Graph stream capture without restrictions in most situations.\nThe exception are routines that output results into host buffers (e.g.\ncublas<t>dot()\nwhile pointer mode\nCUBLAS_POINTER_MODE_HOST\nis configured), as it enforces synchronization.\nFor input coefficients (such as\nalpha\n,\nbeta\n) behavior depends on the pointer mode setting:\nIn the case of\nCUBLAS(LT)_POINTER_MODE_HOST\n, coefficient values are captured in the graph.\nIn the case of pointer modes with device pointers, coefficient value is accessed using the device pointer at the time of graph execution.\nNote\nWhen captured in CUDA Graph stream capture, cuBLAS routines can create\nmemory nodes\nthrough the use of stream-ordered allocation APIs,\ncudaMallocAsync\nand\ncudaFreeAsync\n. However, as there is currently no support for memory nodes in\nchild graphs\nor graphs launched\nfrom the device\n, attempts to capture cuBLAS routines in such scenarios may fail. To avoid this issue, use the\ncublasSetWorkspace()\nfunction to provide user-owned workspace memory.\n2.1.13.\n64-bit Integer Interface\n\ncuBLAS version 12 introduced 64-bit integer capable functions. Each 64-bit integer function is equivalent to a 32-bit integer function with the following changes:\nThe function name has\n_64\nsuffix.\nThe dimension (problem size) data type changed from\nint\nto\nint64_t\n. Examples of dimension:\nm\n,\nn\n, and\nk\n.\nThe leading dimension data type changed from\nint\nto\nint64_t\n. Examples of leading dimension:\nlda\n,\nldb\n, and\nldc\n.\nThe vector increment data type changed from\nint\nto\nint64_t\n. Examples of vector increment:\nincx\nand\nincy\n.\nFor example, consider the following 32-bit integer functions:\ncublasStatus_t\ncublasSetMatrix\n(\nint\nrows\n,\nint\ncols\n,\nint\nelemSize\n,\nconst\nvoid\n*\nA\n,\nint\nlda\n,\nvoid\n*\nB\n,\nint\nldb\n);\ncublasStatus_t\ncublasIsamax\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\nfloat\n*\nx\n,\nint\nincx\n,\nint\n*\nresult\n);\ncublasStatus_t\ncublasSsyr\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nx\n,\nint\nincx\n,\nfloat\n*\nA\n,\nint\nlda\n);\nThe equivalent 64-bit integer functions are:\ncublasStatus_t\ncublasSetMatrix_64\n(\nint64_t\nrows\n,\nint64_t\ncols\n,\nint64_t\nelemSize\n,\nconst\nvoid\n*\nA\n,\nint64_t\nlda\n,\nvoid\n*\nB\n,\nint64_t\nldb\n);\ncublasStatus_t\ncublasIsamax_64\n(\ncublasHandle_t\nhandle\n,\nint64_t\nn\n,\nconst\nfloat\n*\nx\n,\nint64_t\nincx\n,\nint64_t\n*\nresult\n);\ncublasStatus_t\ncublasSsyr_64\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint64_t\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nx\n,\nint64_t\nincx\n,\nfloat\n*\nA\n,\nint64_t\nlda\n);\nNot every function has a 64-bit integer equivalent. For instance,\ncublasSetMathMode()\ndoesn’t have any arguments that could meaningfully be\nint64_t\n. For documentation brevity, the 64-bit integer APIs are not explicitly listed, but only mentioned that they exist for the relevant functions.\n2.2.\ncuBLAS Datatypes Reference\n\n2.2.1.\ncublasHandle_t\n\nThe\ncublasHandle_t\ntype is a pointer type to an opaque structure holding the cuBLAS library context. The cuBLAS library context must be initialized using\ncublasCreate()\nand the returned handle must be passed to all subsequent library function calls. The context should be destroyed at the end using\ncublasDestroy()\n.\n2.2.2.\ncublasStatus_t\n\nThe type is used for function status returns. All cuBLAS library functions return their status, which can have the following values.\nValue\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully.\nCUBLAS_STATUS_NOT_INITIALIZED\nThe cuBLAS library was not initialized. This is usually caused by the lack of a prior\ncublasCreate()\ncall, an error in the CUDA Runtime API called by the cuBLAS routine, or an error in the hardware setup.\nTo correct: call\ncublasCreate()\nbefore the function call; and check that the hardware, an appropriate version of the driver, and the cuBLAS library are correctly installed.\nCUBLAS_STATUS_ALLOC_FAILED\nResource allocation failed inside the cuBLAS library. This is usually caused by a\ncudaMalloc()\nfailure.\nTo correct: prior to the function call, deallocate previously allocated memory as much as possible.\nCUBLAS_STATUS_INVALID_VALUE\nAn unsupported value or parameter was passed to the function (a negative vector size, for example).\nTo correct: ensure that all the parameters being passed have valid values.\nCUBLAS_STATUS_ARCH_MISMATCH\nThe function requires a feature absent from the device architecture; usually caused by compute capability lower than 5.0.\nTo correct: compile and run the application on a device with appropriate compute capability.\nCUBLAS_STATUS_MAPPING_ERROR\nAn access to GPU memory space failed, which is usually caused by a failure to bind a texture.\nTo correct: before the function call, unbind any previously bound textures.\nCUBLAS_STATUS_EXECUTION_FAILED\nThe GPU program failed to execute. This is often caused by a launch failure of the kernel on the GPU, which can be caused by multiple reasons.\nTo correct: check that the hardware, an appropriate version of the driver, and the cuBLAS library are correctly installed.\nCUBLAS_STATUS_INTERNAL_ERROR\nAn internal cuBLAS operation failed. This error is usually caused by a\ncudaMemcpyAsync()\nfailure.\nTo correct: check that the hardware, an appropriate version of the driver, and the cuBLAS library are correctly installed. Also, check that the memory passed as a parameter to the routine is not being deallocated prior to the routine’s completion.\nCUBLAS_STATUS_NOT_SUPPORTED\nThe functionality requested is not supported.\nCUBLAS_STATUS_LICENSE_ERROR\nThe functionality requested requires some license and an error was detected when trying to check the current licensing. This error can happen if the license is not present or is expired or if the environment variable NVIDIA_LICENSE_FILE is not set properly.\n2.2.3.\ncublasOperation_t\n\nThe\ncublasOperation_t\ntype indicates which operation needs to be performed with the dense matrix. Its values correspond to Fortran characters\n‘N’\nor\n‘n’\n(non-transpose),\n‘T’\nor\n‘t’\n(transpose) and\n‘C’\nor\n‘c’\n(conjugate transpose) that are often used as parameters to legacy BLAS implementations.\nValue\nMeaning\nCUBLAS_OP_N\nThe non-transpose operation is selected.\nCUBLAS_OP_T\nThe transpose operation is selected.\nCUBLAS_OP_C\nThe conjugate transpose operation is selected.\n2.2.4.\ncublasFillMode_t\n\nThe type indicates which part (lower or upper) of the dense matrix was filled and consequently should be used by the function. Its values correspond to Fortran characters\nL\nor\nl\n(lower) and\nU\nor\nu\n(upper) that are often used as parameters to legacy BLAS implementations.\nValue\nMeaning\nCUBLAS_FILL_MODE_LOWER\nThe lower part of the matrix is filled.\nCUBLAS_FILL_MODE_UPPER\nThe upper part of the matrix is filled.\nCUBLAS_FILL_MODE_FULL\nThe full matrix is filled.\n2.2.5.\ncublasDiagType_t\n\nThe type indicates whether the main diagonal of the dense matrix is unity and consequently should not be touched or modified by the function. Its values correspond to Fortran characters\n‘N’\nor\n‘n’\n(non-unit) and\n‘U’\nor\n‘u’\n(unit) that are often used as parameters to legacy BLAS implementations.\nValue\nMeaning\nCUBLAS_DIAG_NON_UNIT\nThe matrix diagonal has non-unit elements.\nCUBLAS_DIAG_UNIT\nThe matrix diagonal has unit elements.\n2.2.6.\ncublasSideMode_t\n\nThe type indicates whether the dense matrix is on the left or right side in the matrix equation solved by a particular function. Its values correspond to Fortran characters\n‘L’\nor\n‘l’\n(left) and\n‘R’\nor\n‘r’\n(right) that are often used as parameters to legacy BLAS implementations.\nValue\nMeaning\nCUBLAS_SIDE_LEFT\nThe matrix is on the left side in the equation.\nCUBLAS_SIDE_RIGHT\nThe matrix is on the right side in the equation.\n2.2.7.\ncublasPointerMode_t\n\nThe\ncublasPointerMode_t\ntype indicates whether the scalar values are passed by reference on the host or device. It is important to point out that if several scalar values are present in the function call, all of them must conform to the same single pointer mode. The pointer mode can be set and retrieved using\ncublasSetPointerMode()\nand\ncublasGetPointerMode()\nroutines, respectively.\nValue\nMeaning\nCUBLAS_POINTER_MODE_HOST\nThe scalars are passed by reference on the host.\nCUBLAS_POINTER_MODE_DEVICE\nThe scalars are passed by reference on the device.\n2.2.8.\ncublasAtomicsMode_t\n\nThe type indicates whether cuBLAS routines which has an alternate implementation using atomics can be used. The atomics mode can be set and queried using\ncublasSetAtomicsMode()\nand\ncublasGetAtomicsMode()\nand routines, respectively.\nValue\nMeaning\nCUBLAS_ATOMICS_NOT_ALLOWED\nThe usage of atomics is not allowed.\nCUBLAS_ATOMICS_ALLOWED\nThe usage of atomics is allowed.\n2.2.9.\ncublasGemmAlgo_t\n\ncublasGemmAlgo_t type is an enumerant to specify the algorithm for matrix-matrix multiplication on GPU architectures up to\nsm_75\n. On\nsm_80\nand newer GPU architectures, this enumarant has no effect. cuBLAS has the following algorithm options:\nValue\nMeaning\nCUBLAS_GEMM_DEFAULT\nApply Heuristics to select the GEMM algorithm\nCUBLAS_GEMM_ALGO0\nto\nCUBLAS_GEMM_ALGO23\nExplicitly choose an Algorithm\n0..23\n. Note: Doesn’t have effect on NVIDIA Ampere architecture GPUs and newer.\nCUBLAS_GEMM_DEFAULT_TENSOR_OP\n[DEPRECATED]\nThis mode is deprecated and will be removed in a future release. Apply Heuristics to select the GEMM algorithm, while allowing use of reduced precision CUBLAS_COMPUTE_32F_FAST_16F kernels (for backward compatibility).\nCUBLAS_GEMM_ALGO0_TENSOR_OP\nto\nCUBLAS_GEMM_ALGO15_TENSOR_OP\n[DEPRECATED]\nThose values are deprecated and will be removed in a future release. Explicitly choose a Tensor core GEMM Algorithm\n0..15\n. Allows use of reduced precision CUBLAS_COMPUTE_32F_FAST_16F kernels (for backward compatibility). Note: Doesn’t have effect on NVIDIA Ampere architecture GPUs and newer.\nCUBLAS_GEMM_AUTOTUNE\n[EXPERIMENTAL] The library will benchmark a number of available algorithms and choose the optimal one for the given problem configuration. Solution is cached in cublas handle so that next calls with the problem size will use the cached configuration. Note: To avoid overwriting the user’s data, the library will allocate the amount of memory corresponding to the size of the output. Note: The benchmarking is not supported during stream capture; CUBLAS_STATUS_NOT_SUPPORTED will be returned under stream capture if no configuration was found in the cache for the given problem size.\n2.2.10.\ncublasMath_t\n\ncublasMath_t\nenumerate type is used in\ncublasSetMathMode()\nto choose compute precision modes as defined in the following table. Since this setting does not directly control the use of Tensor Cores, the mode\nCUBLAS_TENSOR_OP_MATH\nis being deprecated, and will be removed in a future release.\nValue\nMeaning\nCUBLAS_DEFAULT_MATH\nThis is the default and highest-performance mode that uses compute and intermediate storage precisions with at least the same number of mantissa and exponent bits as requested. Tensor Cores will be used whenever possible.\nCUBLAS_PEDANTIC_MATH\nThis mode uses the prescribed precision and standardized arithmetic for all phases of calculations and is primarily intended for numerical robustness studies, testing, and debugging. This mode might not be as performant as the other modes.\nCUBLAS_TF32_TENSOR_OP_MATH\nEnable acceleration of single-precision routines using TF32 tensor cores. Note that input conversions round to nearest even.\nCUBLAS_FP32_EMULATED_BF16X9_MATH\nEnable acceleration of single-precision routines using the BF16x9 algorithm. See\nFloating Point Emulation\nfor more details. For single precision GEMM routines cuBLAS will use the\nCUBLAS_COMPUTE_32F_EMULATED_16BFX9\ncompute type.\nCUBLAS_FP64_EMULATED_FIXEDPOINT_MATH\nEnable acceleration of double-precision routines using fixed-point emulation algorithms. See\nFloating Point Emulation\nfor more details.\nCUBLAS_MATH_DISALLOW_REDUCED_PRECISION_REDUCTION\nForces any reductions during matrix multiplications to use the accumulator type (that is, compute type) and not the output type in case of mixed precision routines where output type precision is less than the compute type precision. This is a flag that can be set (using a bitwise or operation) alongside any of the other values.\nCUBLAS_TENSOR_OP_MATH\n[DEPRECATED]\nThis mode is deprecated and will be removed in a future release. Allows the library to use Tensor Core operations whenever possible. For single precision GEMM routines cuBLAS will use the\nCUBLAS_COMPUTE_32F_FAST_16F\ncompute type.\n2.2.11.\ncublasComputeType_t\n\ncublasComputeType_t\nenumerate type is used in\ncublasGemmEx()\nand\ncublasLtMatmul()\n(including all batched and strided batched variants) to choose compute precision modes as defined below.\nValue                                      | Meaning\nCUBLAS_COMPUTE_16F\nThis is the default and highest-performance mode for 16-bit half precision floating point and all compute and intermediate storage precisions with at least 16-bit half precision. Tensor Cores will be used whenever possible.\nCUBLAS_COMPUTE_16F_PEDANTIC\nThis mode uses 16-bit half precision floating point standardized arithmetic for all phases of calculations and is primarily intended for numerical robustness studies, testing, and debugging. This mode might not be as performant as the other modes since it disables use of tensor cores.\nCUBLAS_COMPUTE_32F\nThis is the default 32-bit single precision floating point and uses compute and intermediate storage precisions of at least 32-bits.\nCUBLAS_COMPUTE_32F_PEDANTIC\nUses 32-bit single precision floating point arithmetic for all phases of calculations and also disables algorithmic optimizations such as Gaussian complexity reduction (3M).\nCUBLAS_COMPUTE_32F_FAST_16F\nAllows the library to use Tensor Cores with automatic down-conversion and 16-bit half-precision compute for 32-bit input and output matrices.\nCUBLAS_COMPUTE_32F_FAST_16BF\nAllows the library to use Tensor Cores with automatic down-convesion and bfloat16 compute for 32-bit input and output matrices. See\nAlternate Floating Point\nsection for more details on bfloat16.\nCUBLAS_COMPUTE_32F_FAST_TF32\nAllows the library to use Tensor Cores with TF32 compute for 32-bit floating point input and output matrices. Note that input conversions round to nearest even. See\nAlternate Floating Point\nsection for more details on TF32 compute.\nCUBLAS_COMPUTE_32F_EMULATED_16BFX9\nAllows the library to use the BF16x9 floating point emulation algorithm for 32-bit floating point arithmetic. See\nFloating Point Emulation\nfor more details.\nCUBLAS_COMPUTE_64F\nThis is the default 64-bit double precision floating point and uses compute and intermediate storage precisions of at least 64-bits.\nCUBLAS_COMPUTE_64F_EMULATED_FIXEDPOINT\nAllows the library to use fixed-point emulation algorithms for 64-bit double precision floating point arithmetic. See\nFloating Point Emulation\nfor more details.\nCUBLAS_COMPUTE_64F_PEDANTIC\nUses 64-bit double precision floating point arithmetic for all phases of calculations and also disables algorithmic optimizations such as Gaussian complexity reduction (3M).\nCUBLAS_COMPUTE_32I\nThis is the default 32-bit integer mode and uses compute and intermediate storage precisions of at least 32-bits.\nCUBLAS_COMPUTE_32I_PEDANTIC\nUses 32-bit integer arithmetic for all phases of calculations.\nNote\nSetting the environment variable\nNVIDIA_TF32_OVERRIDE\n=\n0\nwill override any defaults or programmatic configuration of NVIDIA libraries, and consequently, cuBLAS will not accelerate single-precision computations with TF32 tensor cores.\n2.2.12.\ncublasEmulationStrategy_t\n\ncublasEmulationStrategy_t\nenumerate type is used in\ncublasSetEmulationStrategy()\nto choose how to leverage floating point emulation algorithms.\nValue\nMeaning\nCUBLAS_EMULATION_STRATEGY_DEFAULT\nThis is the default emulation strategy and is equivalent to\nCUBLAS_EMULATION_STRATEGY_PERFORMANT\nunless the\nCUBLAS_EMULATION_STRATEGY\nenvironment variable is set.\nCUBLAS_EMULATION_STRATEGY_PERFORMANT\nA strategy which utilizes emulation whenever it provides a performance benefit.\nCUBLAS_EMULATION_STRATEGY_EAGER\nA strategy which utilizes emulation whenever possible.\nNote\nIn general, the\ncublasSetEmulationStrategy()\nfunction takes precedence over the environment variable setting.\nHowever, setting the environment variable\nCUBLAS_EMULATION_STRATEGY\nto\nperformant\nor\neager\nwill override the default emulation strategy with the corresponding emulation strategy, even if the default strategy was set by the function call.\n2.3.\nCUDA Datatypes Reference\n\nThe chapter describes types shared by multiple CUDA Libraries and defined in the header file\nlibrary_types.h\n.\n2.3.1.\ncudaDataType_t\n\nThe\ncudaDataType_t\ntype is an enumerant to specify the data precision. It is used when the data reference does not carry the type itself (e.g void *)\nFor example, it is used in the routine\ncublasSgemmEx()\n.\nValue\nMeaning\nCUDA_R_16F\nThe data type is a 16-bit real half precision floating-point\nCUDA_C_16F\nThe data type is a 32-bit structure comprised of two half precision floating-points representing a complex number.\nCUDA_R_16BF\nThe data type is a 16-bit real bfloat16 floating-point\nCUDA_C_16BF\nThe data type is a 32-bit structure comprised of two bfloat16 floating-points representing a complex number.\nCUDA_R_32F\nThe data type is a 32-bit real single precision floating-point\nCUDA_C_32F\nThe data type is a 64-bit structure comprised of two single precision floating-points representing a complex number.\nCUDA_R_64F\nThe data type is a 64-bit real double precision floating-point\nCUDA_C_64F\nThe data type is a 128-bit structure comprised of two double precision floating-points representing a complex number.\nCUDA_R_8I\nThe data type is a 8-bit real signed integer\nCUDA_C_8I\nThe data type is a 16-bit structure comprised of two 8-bit signed integers representing a complex number.\nCUDA_R_8U\nThe data type is a 8-bit real unsigned integer\nCUDA_C_8U\nThe data type is a 16-bit structure comprised of two 8-bit unsigned integers representing a complex number.\nCUDA_R_32I\nThe data type is a 32-bit real signed integer\nCUDA_C_32I\nThe data type is a 64-bit structure comprised of two 32-bit signed integers representing a complex number.\nCUDA_R_8F_E4M3\nThe data type is an 8-bit real floating point in E4M3 format\nCUDA_R_8F_E5M2\nThe data type is an 8-bit real floating point in E5M2 format\nCUDA_R_4F_E2M1\nThe data type is a 4-bit real floating point in E2M1 format\n2.3.2.\ncudaEmulationStrategy_t\n\nThe\ncudaEmulationStrategy_t\nis a parameter to specify how to leverage floating point emulation algorithms. This is equivalent to\ncublasEmulationStrategy_t\n.\n2.3.3.\ncudaEmulationMantissaControl_t\n\nThe\ncudaEmulationMantissaControl_t\nis an enumerated type to specify how to configure how the number of mantissa bits are calculated in floating point emulation algorithms.\nSee See\ncublasSetFixedPointEmulationMantissaControl()\nand\ncublasGetFixedPointEmulationMaxMantissaBitCount()\n.\nValue\nMeaning\nCUDA_EMULATION_MANTISSA_CONTROL_DYNAMIC\nThe number of retained mantissa bits is computed at runtime to ensure the same or better accuracy than the native floating\npoint representation.\nCUDA_EMULATION_MANTISSA_CONTROL_FIXED\nThe number of retained mantissa bits is fixed at runtime.\n2.3.4.\ncudaEmulationSpecialValuesSupport_t\n\nThe\ncudaEmulationSpecialValuesSupport_t\nis an enumerated type to specify how to configure which floating point special values are required to be supported by\nfloating point emulation algorithms. See\ncublasSetEmulationSpecialValuesSupport()\nand\ncublasGetEmulationSpecialValuesSupport()\n.\nValue\nMeaning\nCUDA_EMULATION_SPECIAL_VALUES_SUPPORT_DEFAULT\nThe default special value support mask which contains support for signed infinities and NaN values.\nCUDA_EMULATION_SPECIAL_VALUES_SUPPORT_NONE\nThere are no requirements for emulation algorithms to support special values.\nCUDA_EMULATION_SPECIAL_VALUES_SUPPORT_INFINITY\nRequire emulation algorithms to handle signed infinity inputs and outputs.\nCUDA_EMULATION_SPECIAL_VALUES_SUPPORT_NAN\nRequire emulation algorithms to handle NaN inputs and outputs.\n2.3.5.\nlibraryPropertyType_t\n\nThe\nlibraryPropertyType_t\nis used as a parameter to specify which property is requested when using the routine\ncublasGetProperty()\nValue\nMeaning\nMAJOR_VERSION\nenumerant to query the major version\nMINOR_VERSION\nenumerant to query the minor version\nPATCH_LEVEL\nnumber to identify the patch level\n2.4.\ncuBLAS Helper Function Reference\n\n2.4.1.\ncublasCreate()\n\ncublasStatus_t\ncublasCreate\n(\ncublasHandle_t\n*\nhandle\n)\nThis function initializes the cuBLAS library and creates a handle to an opaque structure holding the cuBLAS library context. It allocates hardware resources on the host and device and must be called prior to making any other cuBLAS library calls.\nThe cuBLAS library context is tied to the current CUDA device. To use the library on multiple devices, one cuBLAS handle needs to be created for each device. See also\ncuBLAS Context\n.\nFor a given device, multiple cuBLAS handles with different configurations can be created. For multi-threaded applications that use the same device from different threads, the recommended programming model is to create one cuBLAS handle per thread and use that cuBLAS handle for the entire life of the thread.\nBecause\ncublasCreate()\nallocates some internal resources and the release of those resources by calling\ncublasDestroy()\nwill implicitly call\ncudaDeviceSynchronize()\n, it is recommended to minimize the number of times these functions are called.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe initialization succeeded\nCUBLAS_STATUS_NOT_INITIALIZED\nThe CUDA™ Runtime initialization failed\nCUBLAS_STATUS_ALLOC_FAILED\nThe resources could not be allocated\nCUBLAS_STATUS_INVALID_VALUE\nhandle\nis NULL\n2.4.2.\ncublasDestroy()\n\ncublasStatus_t\ncublasDestroy\n(\ncublasHandle_t\nhandle\n)\nThis function releases hardware resources used by the cuBLAS library. This function is usually the last call with a particular handle to the cuBLAS library. Because\ncublasCreate()\nallocates some internal resources and the release of those resources by calling\ncublasDestroy()\nwill implicitly call\ncudaDeviceSynchronize()\n, it is recommended to minimize the number of times these functions are called.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe shut down succeeded\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized\n2.4.3.\ncublasGetVersion()\n\ncublasStatus_t\ncublasGetVersion\n(\ncublasHandle_t\nhandle\n,\nint\n*\nversion\n)\nThis function returns the version number of the cuBLAS library.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_INVALID_VALUE\nversion\nis NULL\nNote\nThis function can be safely called with\nhandle\nset to NULL.  This allows users to get the version of the library without a handle.  Another way to do this is with\ncublasGetProperty()\n.\n2.4.4.\ncublasGetProperty()\n\ncublasStatus_t\ncublasGetProperty\n(\nlibraryPropertyType\ntype\n,\nint\n*\nvalue\n)\nThis function returns the value of the requested property in memory pointed to by value. Refer to\nlibraryPropertyType\nfor supported types.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_INVALID_VALUE\nInvalid type or value\nIf\ntype\nhas an invalid value, or\nif\nvalue\nis NULL\n2.4.5.\ncublasGetStatusName()\n\nconst\nchar\n*\ncublasGetStatusName\n(\ncublasStatus_t\nstatus\n)\nThis function returns the string representation of a given status.\nReturn Value\nMeaning\nNULL-terminated string\nThe string representation of the\nstatus\n2.4.6.\ncublasGetStatusString()\n\nconst\nchar\n*\ncublasGetStatusString\n(\ncublasStatus_t\nstatus\n)\nThis function returns the description string for a given status.\nReturn Value\nMeaning\nNULL-terminated string\nThe description of the\nstatus\n2.4.7.\ncublasSetStream()\n\ncublasStatus_t\ncublasSetStream\n(\ncublasHandle_t\nhandle\n,\ncudaStream_t\nstreamId\n)\nThis function sets the cuBLAS library stream, which will be used to execute all subsequent calls to the cuBLAS library functions. If the cuBLAS library stream is not set, all kernels use the\ndefault\nNULL stream. In particular, this routine can be used to change the stream between kernel launches and then to reset the cuBLAS library stream back to NULL. Additionally this function unconditionally resets the cuBLAS library workspace back to the default workspace pool (see\ncublasSetWorkspace()\n).\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe stream was set successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized\n2.4.8.\ncublasSetWorkspace()\n\ncublasStatus_t\ncublasSetWorkspace\n(\ncublasHandle_t\nhandle\n,\nvoid\n*\nworkspace\n,\nsize_t\nworkspaceSizeInBytes\n)\nThis function sets the cuBLAS library workspace to a user-owned device buffer, which will be used to execute all subsequent calls to the cuBLAS library functions (on the currently set stream). If the cuBLAS library workspace is not set, all kernels will use the default workspace pool allocated during the cuBLAS context creation. In particular, this routine can be used to change the workspace between kernel launches. The workspace pointer has to be aligned to at least 256 bytes, otherwise\nCUBLAS_STATUS_INVALID_VALUE\nerror is returned. The\ncublasSetStream()\nfunction unconditionally resets the cuBLAS library workspace back to the default workspace pool. Calling this function, including with\nworkspaceSizeInBytes\nequal to 0, will prevent the cuBLAS library from utilizing the default workspace. Too small value of\nworkspaceSizeInBytes\nmay cause some routines to fail with\nCUBLAS_STATUS_ALLOC_FAILED\nerror returned or cause large regressions in performance. Workspace size equal to or larger than 16KiB is enough to prevent\nCUBLAS_STATUS_ALLOC_FAILED\nerror, while a larger workspace can provide performance benefits for some routines.\nNote\nIf the stream set by\ncublasSetStream()\nis\ncudaStreamPerThread\nand there are multiple threads using the same cuBLAS library handle, then users must manually manage synchronization to avoid possible race conditions in the user provided workspace. Alternatively, users may rely on the default workspace pool which safely guards against race conditions.\nWarning\ncuBLAS functions may invoke more than one CUDA kernel, and rely on workspace being intact between the invocations. Hence, if cuBLAS handle is configured with user-provided workspace and is being used from multiple threads, it is user’s responsibility to serialize cuBLAS calls between threads, as otherwise the kernels from different cuBLAS invocations might interleave and invalidate the assumptions each of them makes regarding workspace intactness. The default workspace pool managed by cuBLAS is thread safe.\nThe table below shows the recommended size of user-provided workspace.\nThis is based on the cuBLAS default workspace pool size which is GPU architecture dependent.\nGPU Architecture\nRecommended workspace size\nNVIDIA Hopper Architecture (sm90)\n32 MiB\nNVIDIA Blackwell Architecture (sm10x)\n32 MiB\nNVIDIA Blackwell Architecture (sm12x)\n32 MiB\nOther\n4 MiB\nNote\nIf the cuBLAS library is configured to utilize\nfixed-point\nemulation, which can be done by setting the corresponding math mode in\ncublasSetMathMode()\nor calling APIs with\nCUBLAS_COMPUTE_64F_EMULATED_FIXEDPOINT\n, it can be beneficial to provide more workspace than recommended for the GPU architecture.  See\nFixed-Point Workspace Requirements\nfor more details.\nThe possible error values returned by this function and their meanings are listed below.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe stream was set successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nThe\nworkspace\npointer wasn’t aligned to at least 256 bytes\n2.4.9.\ncublasGetStream()\n\ncublasStatus_t\ncublasGetStream\n(\ncublasHandle_t\nhandle\n,\ncudaStream_t\n*\nstreamId\n)\nThis function gets the cuBLAS library stream, which is being used to execute all calls to the cuBLAS library functions. If the cuBLAS library stream is not set, all kernels use the\ndefault\nNULL stream.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe stream was returned successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nstreamId\nis NULL\n2.4.10.\ncublasGetPointerMode()\n\ncublasStatus_t\ncublasGetPointerMode\n(\ncublasHandle_t\nhandle\n,\ncublasPointerMode_t\n*\nmode\n)\nThis function obtains the pointer mode used by the cuBLAS library. Please see the section on the\ncublasPointerMode_t\ntype for more details.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe pointer mode was obtained successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nmode\nis NULL\n2.4.11.\ncublasSetPointerMode()\n\ncublasStatus_t\ncublasSetPointerMode\n(\ncublasHandle_t\nhandle\n,\ncublasPointerMode_t\nmode\n)\nThis function sets the pointer mode used by the cuBLAS library. The\ndefault\nis for the values to be passed by reference on the host. Please see the section on the\ncublasPointerMode_t\ntype for more details.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe pointer mode was set successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nmode\nis not\nCUBLAS_POINTER_MODE_HOST\nor\nCUBLAS_POINTER_MODE_DEVICE\n2.4.12.\ncublasSetVector()\n\ncublasStatus_t\ncublasSetVector\n(\nint\nn\n,\nint\nelemSize\n,\nconst\nvoid\n*\nx\n,\nint\nincx\n,\nvoid\n*\ny\n,\nint\nincy\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function copies\nn\nelements from a vector\nx\nin host memory space to a vector\ny\nin GPU memory space. Elements in both vectors are assumed to have a size of\nelemSize\nbytes. The storage spacing between consecutive elements is given by\nincx\nfor the source vector\nx\nand by\nincy\nfor the destination vector\ny\n.\nSince column-major format for two-dimensional matrices is assumed, if a vector is part of a matrix, a vector increment equal to\n1\naccesses a (partial) column of that matrix. Similarly, using an increment equal to the leading dimension of the matrix results in accesses to a (partial) row of that matrix.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_INVALID_VALUE\nThe parameters\nincx\n,\nincy\n, or\nelemSize\nare not positive\nCUBLAS_STATUS_MAPPING_ERROR\nThere was an error accessing GPU memory\n2.4.13.\ncublasGetVector()\n\ncublasStatus_t\ncublasGetVector\n(\nint\nn\n,\nint\nelemSize\n,\nconst\nvoid\n*\nx\n,\nint\nincx\n,\nvoid\n*\ny\n,\nint\nincy\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function copies\nn\nelements from a vector\nx\nin GPU memory space to a vector\ny\nin host memory space. Elements in both vectors are assumed to have a size of\nelemSize\nbytes. The storage spacing between consecutive elements is given by\nincx\nfor the source vector and\nincy\nfor the destination vector\ny\n.\nSince column-major format for two-dimensional matrices is assumed, if a vector is part of a matrix, a vector increment equal to\n1\naccesses a (partial) column of that matrix. Similarly, using an increment equal to the leading dimension of the matrix results in accesses to a (partial) row of that matrix.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_INVALID_VALUE\nThe parameters\nincx\n,\nincy\n, or\nelemSize\nare not positive\nCUBLAS_STATUS_MAPPING_ERROR\nThere was an error accessing GPU memory\n2.4.14.\ncublasSetMatrix()\n\ncublasStatus_t\ncublasSetMatrix\n(\nint\nrows\n,\nint\ncols\n,\nint\nelemSize\n,\nconst\nvoid\n*\nA\n,\nint\nlda\n,\nvoid\n*\nB\n,\nint\nldb\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function copies a tile of\nrows\nx\ncols\nelements from a matrix\nA\nin host memory space to a matrix\nB\nin GPU memory space. It is assumed that each element requires storage of\nelemSize\nbytes and that both matrices are stored in column-major format, with the leading dimension of the source matrix\nA\nand destination matrix\nB\ngiven in\nlda\nand\nldb\n, respectively. The leading dimension indicates the number of rows of the allocated matrix, even if only a submatrix of it is being used.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_INVALID_VALUE\nThe parameters\nrows\nor\ncols\nare negative, or\nelemSize\n,\nlda\nldb\nare not positive.\nCUBLAS_STATUS_MAPPING_ERROR\nThere was an error accessing GPU memory\n2.4.15.\ncublasGetMatrix()\n\ncublasStatus_t\ncublasGetMatrix\n(\nint\nrows\n,\nint\ncols\n,\nint\nelemSize\n,\nconst\nvoid\n*\nA\n,\nint\nlda\n,\nvoid\n*\nB\n,\nint\nldb\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function copies a tile of\nrows\nx\ncols\nelements from a matrix\nA\nin GPU memory space to a matrix\nB\nin host memory space. It is assumed that each element requires storage of\nelemSize\nbytes and that both matrices are stored in column-major format, with the leading dimension of the source matrix\nA\nand destination matrix\nB\ngiven in\nlda\nand\nldb\n, respectively. The leading dimension indicates the number of rows of the allocated matrix, even if only a submatrix of it is being used.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_INVALID_VALUE\nThe parameters\nrows\nor\ncols\nare negative, or\nelemSize\n,\nlda\nldb\nare not positive.\nCUBLAS_STATUS_MAPPING_ERROR\nThere was an error accessing GPU memory\n2.4.16.\ncublasSetVectorAsync()\n\ncublasStatus_t\ncublasSetVectorAsync\n(\nint\nn\n,\nint\nelemSize\n,\nconst\nvoid\n*\nhostPtr\n,\nint\nincx\n,\nvoid\n*\ndevicePtr\n,\nint\nincy\n,\ncudaStream_t\nstream\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function has the same functionality as\ncublasSetVector()\n, with the exception that the data transfer is done asynchronously (with respect to the host) using the given CUDA™ stream parameter.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_INVALID_VALUE\nThe parameters\nincx\n,\nincy\n, or\nelemSize\nare not positive\nCUBLAS_STATUS_MAPPING_ERROR\nThere was an error accessing GPU memory\n2.4.17.\ncublasGetVectorAsync()\n\ncublasStatus_t\ncublasGetVectorAsync\n(\nint\nn\n,\nint\nelemSize\n,\nconst\nvoid\n*\ndevicePtr\n,\nint\nincx\n,\nvoid\n*\nhostPtr\n,\nint\nincy\n,\ncudaStream_t\nstream\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function has the same functionality as\ncublasGetVector()\n, with the exception that the data transfer is done asynchronously (with respect to the host) using the given CUDA™ stream parameter.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_INVALID_VALUE\nThe parameters\nincx\n,\nincy\n, or\nelemSize\nare not positive\nCUBLAS_STATUS_MAPPING_ERROR\nThere was an error accessing GPU memory\n2.4.18.\ncublasSetMatrixAsync()\n\ncublasStatus_t\ncublasSetMatrixAsync\n(\nint\nrows\n,\nint\ncols\n,\nint\nelemSize\n,\nconst\nvoid\n*\nA\n,\nint\nlda\n,\nvoid\n*\nB\n,\nint\nldb\n,\ncudaStream_t\nstream\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function has the same functionality as\ncublasSetMatrix()\n, with the exception that the data transfer is done asynchronously (with respect to the host) using the given CUDA™ stream parameter.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_INVALID_VALUE\nThe parameters\nrows\nor\ncols\nare negative, or\nelemSize\n,\nlda\nldb\nare not positive.\nCUBLAS_STATUS_MAPPING_ERROR\nThere was an error accessing GPU memory\n2.4.19.\ncublasGetMatrixAsync()\n\ncublasStatus_t\ncublasGetMatrixAsync\n(\nint\nrows\n,\nint\ncols\n,\nint\nelemSize\n,\nconst\nvoid\n*\nA\n,\nint\nlda\n,\nvoid\n*\nB\n,\nint\nldb\n,\ncudaStream_t\nstream\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function has the same functionality as\ncublasGetMatrix()\n, with the exception that the data transfer is done asynchronously (with respect to the host) using the given CUDA™ stream parameter.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_INVALID_VALUE\nThe parameters\nrows\nor\ncols\nare negative, or\nelemSize\n,\nlda\nldb\nare not positive.\nCUBLAS_STATUS_MAPPING_ERROR\nThere was an error accessing GPU memory\n2.4.20.\ncublasSetAtomicsMode()\n\ncublasStatus_t\ncublasSetAtomicsMode\n(\ncublasHandlet\nhandle\n,\ncublasAtomicsMode_t\nmode\n)\nSome routines like\ncublas<t>symv()\nand\ncublas<t>hemv()\nhave an alternate implementation that use atomics to cumulate results. This implementation is generally significantly faster but can generate results that are not strictly identical from one run to the others. Mathematically, those different results are not significant but when debugging those differences can be prejudicial.\nThis function allows or disallows the usage of atomics in the cuBLAS library for all routines which have an alternate implementation. When not explicitly specified in the documentation of any cuBLAS routine, it means that this routine does not have an alternate implementation that use atomics. When atomics mode is disabled, each cuBLAS routine should produce the same results from one run to the other when called with identical parameters on the same Hardware.\nThe default atomics mode of default initialized\ncublasHandle_t\nobject is\nCUBLAS_ATOMICS_NOT_ALLOWED\n. Please see the section on the type for more details.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe atomics mode was set successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized\n2.4.21.\ncublasGetAtomicsMode()\n\ncublasStatus_t\ncublasGetAtomicsMode\n(\ncublasHandle_t\nhandle\n,\ncublasAtomicsMode_t\n*\nmode\n)\nThis function queries the atomic mode of a specific cuBLAS context.\nThe default atomics mode of default initialized\ncublasHandle_t\nobject is\nCUBLAS_ATOMICS_NOT_ALLOWED\n. Please see the section on the type for more details.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe atomics mode was queried successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nThe argument\nmode\nis a NULL pointer\n2.4.22.\ncublasSetMathMode()\n\ncublasStatus_t\ncublasSetMathMode\n(\ncublasHandle_t\nhandle\n,\ncublasMath_t\nmode\n)\nThe\ncublasSetMathMode()\nfunction enables you to choose the compute precision modes as defined by\ncublasMath_t\n. Users are allowed to set the compute precision mode as a logical combination of them (except the deprecated\nCUBLAS_TENSOR_OP_MATH\n). For example,\ncublasSetMathMode(handle,\nCUBLAS_DEFAULT_MATH\n|\nCUBLAS_MATH_DISALLOW_REDUCED_PRECISION_REDUCTION)\n. Please note that the default math mode is\nCUBLAS_DEFAULT_MATH\n.\nFor matrix and compute precisions allowed for\ncublasGemmEx()\nand\ncublasLtMatmul()\nAPIs and their strided variants please refer to:\ncublasGemmEx()\n,\ncublasGemmBatchedEx()\n,\ncublasGemmStridedBatchedEx()\n, and\ncublasLtMatmul()\n.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe math mode was set successfully.\nCUBLAS_STATUS_INVALID_VALUE\nAn invalid value for mode was specified.\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized.\n2.4.23.\ncublasGetMathMode()\n\ncublasStatus_t\ncublasGetMathMode\n(\ncublasHandle_t\nhandle\n,\ncublasMath_t\n*\nmode\n)\nThis function returns the math mode used by the library routines.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe math type was returned successfully.\nCUBLAS_STATUS_INVALID_VALUE\nIf\nmode\nis NULL.\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized.\n2.4.24.\ncublasSetSmCountTarget()\n\ncublasStatus_t\ncublasSetSmCountTarget\n(\ncublasHandle_t\nhandle\n,\nint\nsmCountTarget\n)\nThe\ncublasSetSmCountTarget()\nfunction allows overriding the number of multiprocessors available to the library during kernels execution.\nThis option can be used to improve the library performance when cuBLAS routines are known to run concurrently with other work on different CUDA streams. For example, on an NVIDIA A100 GPU, which has 108 multiprocessors, when there is a concurrent kenrel running with grid size of 8, one can use\ncublasSetSmCountTarget()\nwith\nsmCountTarget\nset to\n100\nto override the library heuristics to optimize for running on the remaining 100 multiprocessors.\nWhen set to\n0\n, the library returns to its default behavior. The input value should not exceed the device’s multiprocessor count, which can be obtained using\ncudaDeviceGetAttribute\n. Negative values are not accepted.\nThe user must ensure thread safety when modifying the library handle with this routine similar to when using\ncublasSetStream()\n, etc.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nSM count target was set successfully.\nCUBLAS_STATUS_INVALID_VALUE\nThe value of\nsmCountTarget\noutside of the allowed range.\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized.\n2.4.25.\ncublasGetSmCountTarget()\n\ncublasStatus_t\ncublasGetSmCountTarget\n(\ncublasHandle_t\nhandle\n,\nint\n*\nsmCountTarget\n)\nThis function obtains the value previously programmed to the library handle.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nSM count target was returned successfully.\nCUBLAS_STATUS_INVALID_VALUE\nsmCountTarget is NULL.\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized.\n2.4.26.\ncublasSetEmulationStrategy()\n\ncublasStatus_t\ncublasSetEmulationStrategy\n(\ncublasHandle_t\nhandle\n,\ncublasEmulationStrategy_t\nemulationStrategy\n)\nThe\ncublasSetEmulationStrategy()\nfunction enables you to select how the library should make use of\nfloating point emulation\n.  For more details, please see\ncublasEmulationStrategy_t\n.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe emulation strategy was set successfully.\nCUBLAS_STATUS_INVALID_VALUE\nAn invalid value for emulation strategy was specified.\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized.\n2.4.27.\ncublasGetEmulationStrategy()\n\ncublasStatus_t\ncublasGetEmulationStrategy\n(\ncublasHandle_t\nhandle\n,\ncublasEmulationStrategy_t\n*\nemulationStrategy\n)\nThis function obtains the value previously programmed to the library handle.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nemulation strategy was returned successfully.\nCUBLAS_STATUS_INVALID_VALUE\nemulationStrategy is NULL.\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized.\n2.4.28.\ncublasGetEmulationSpecialValuesSupport()\n\ncublasStatus_t\ncublasGetEmulationSpecialValuesSupport\n(\ncublasHandle_t\nhandle\n,\ncudaEmulationSpecialValuesSupport\n*\nmask\n)\nThis function obtains the value previously programmed to the library handle.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nemulation special values support was returned successfully.\nCUBLAS_STATUS_INVALID_VALUE\nmask is NULL.\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized.\n2.4.29.\ncublasSetEmulationSpecialValuesSupport()\n\ncublasStatus_t\ncublasSetEmulationSpecialValuesSupport\n(\ncublasHandle_t\nhandle\n,\ncudaEmulationSpecialValuesSupport\nmask\n)\nThis function sets the value previously programmed to the library handle.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nemulation special values support was set successfully.\nCUBLAS_STATUS_INVALID_VALUE\nmask is outside of the allowed range.\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized.\n2.4.30.\ncublasGetFixedPointEmulationMantissaControl()\n\ncublasStatus_t\ncublasGetFixedPointEmulationMantissaControl\n(\ncublasHandle_t\nhandle\n,\ncudaEmulationMantissaControl\n*\nmantissaControl\n)\nThis function obtains the value previously programmed to the library handle.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nfixed-point emulation mantissa control was returned successfully.\nCUBLAS_STATUS_INVALID_VALUE\nmantissaControl is NULL.\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized.\n2.4.31.\ncublasSetFixedPointEmulationMantissaControl()\n\ncublasStatus_t\ncublasSetFixedPointEmulationMantissaControl\n(\ncublasHandle_t\nhandle\n,\ncudaEmulationMantissaControl\nmantissaControl\n)\nThis function sets the value previously programmed to the library handle.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nfixed-point emulation mantissa control was set successfully.\nCUBLAS_STATUS_INVALID_VALUE\nmantissaControl is outside of the allowed range.\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized.\n2.4.32.\ncublasGetFixedPointEmulationMaxMantissaBitCount()\n\ncublasStatus_t\ncublasGetFixedPointEmulationMaxMantissaBitCount\n(\ncublasHandle_t\nhandle\n,\nint\n*\nmaxMantissaBitCount\n)\nThis function obtains the value previously programmed to the library handle.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nmaxMantissaBitCount was returned successfully.\nCUBLAS_STATUS_INVALID_VALUE\nmaxMantissaBitCount is NULL.\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized.\n2.4.33.\ncublasSetFixedPointEmulationMaxMantissaBitCount()\n\ncublasStatus_t\ncublasSetFixedPointEmulationMaxMantissaBitCount\n(\ncublasHandle_t\nhandle\n,\nint\nmaxMantissaBitCount\n)\nThis function sets the value previously programmed to the library handle.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nmaxMantissaBitCount was set successfully.\nCUBLAS_STATUS_INVALID_VALUE\nmaxMantissaBitCount is outside of the allowed range.\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized.\n2.4.34.\ncublasGetFixedPointEmulationMantissaBitOffset()\n\ncublasStatus_t\ncublasGetFixedPointEmulationMantissaBitOffset\n(\ncublasHandle_t\nhandle\n,\nint\n*\nmantissaBitOffset\n)\nThis function obtains the value previously programmed to the library handle.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nmantissaBitOffset was returned successfully.\nCUBLAS_STATUS_INVALID_VALUE\nmantissaBitOffset is NULL.\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized.\n2.4.35.\ncublasSetFixedPointEmulationMantissaBitOffset()\n\ncublasStatus_t\ncublasSetFixedPointEmulationMantissaBitOffset\n(\ncublasHandle_t\nhandle\n,\nint\nmantissaBitOffset\n)\nThis function sets the value previously programmed to the library handle.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nmantissaBitOffset was set successfully.\nCUBLAS_STATUS_INVALID_VALUE\nmantissaBitOffset is outside of the allowed range.\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized.\n2.4.36.\ncublasGetFixedPointEmulationMantissaBitCountPointer()\n\ncublasStatus_t\ncublasGetFixedPointEmulationMantissaBitCountPointer\n(\ncublasHandle_t\nhandle\n,\nint\n**\nmantissaBitCount\n)\nThis function obtains the value previously programmed to the library handle.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nmantissaBitCount was returned successfully.\nCUBLAS_STATUS_INVALID_VALUE\nmantissaBitCount is NULL.\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized.\n2.4.37.\ncublasSetFixedPointEmulationMantissaBitCountPointer()\n\ncublasStatus_t\ncublasSetFixedPointEmulationMantissaBitCountPointer\n(\ncublasHandle_t\nhandle\n,\nint\n*\nmantissaBitCount\n)\nThis function sets the value previously programmed to the library handle.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nmantissaBitCount was set successfully.\nCUBLAS_STATUS_INVALID_VALUE\nmantissaBitCount is outside of the allowed range.\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized.\n2.4.38.\ncublasLoggerConfigure()\n\ncublasStatus_t\ncublasLoggerConfigure\n(\nint\nlogIsOn\n,\nint\nlogToStdOut\n,\nint\nlogToStdErr\n,\nconst\nchar\n*\nlogFileName\n)\nThis function configures logging during runtime. Besides this type of configuration, it is possible to configure logging with special environment variables which will be checked by libcublas:\nCUBLAS_LOGINFO_DBG\n- setting this environment variable to\n1\nmeans turning logging on (by default logging is off).\nCUBLAS_LOGDEST_DBG\n- this environment variable encodes where to write the log to:\nstdout\n,\nstderr\nmean to write log messages to standard output or error streams, respectively. Other values are interpreted as file names.\nParameters\nParam.\nMemory\nIn/out\nMeaning\nlogIsOn\nhost\ninput\nTurn on/off logging completely. By default is off, but is turned on by calling\ncublasSetLoggerCallback()\nto user defined callback function.\nlogToStdOut\nhost\ninput\nTurn on/off logging to standard output I/O stream. By default is off.\nlogToStdErr\nhost\ninput\nTurn on/off logging to standard error I/O stream. By default is off.\nlogFileName\nhost\ninput\nTurn on/off logging to file in filesystem specified by it’s name.\ncublasLoggerConfigure()\ncopies the content of\nlogFileName\n. You should provide null pointer if you are not interested in this type of logging.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\n2.4.39.\ncublasGetLoggerCallback()\n\ncublasStatus_t\ncublasGetLoggerCallback\n(\ncublasLogCallback\n*\nuserCallback\n)\nThis function retrieves function pointer to previously installed custom user defined callback function via\ncublasSetLoggerCallback()\nor zero otherwise.\nParam.\nMemory\nIn/out\nMeaning\nuserCallback\nhost\noutput\nPointer to user defined callback function.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe operation completed successfully\nCUBLAS_STATUS_INVALID_VALUE\nuserCallback\nis NULL\n2.4.40.\ncublasSetLoggerCallback()\n\ncublasStatus_t\ncublasSetLoggerCallback\n(\ncublasLogCallback\nuserCallback\n)\nThis function installs a custom user defined callback function via cublas C public API.\nParam.\nMemory\nIn/out\nMeaning\nuserCallback\nhost\ninput\nPointer to user defined callback function.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\n2.5.\ncuBLAS Level-1 Function Reference\n\nIn this chapter we describe the Level-1 Basic Linear Algebra Subprograms (BLAS1) functions that perform scalar and vector based operations. We will use abbreviations <\ntype\n> for type and <\nt\n> for the corresponding short type to make a more concise and clear presentation of the implemented functions. Unless otherwise specified <\ntype\n> and <\nt\n> have the following meanings:\n<\ntype\n>\n<\nt\n>\nMeaning\nfloat\ns\nor\nS\nreal single-precision\ndouble\nd\nor\nD\nreal double-precision\ncuComplex\nc\nor\nC\ncomplex single-precision\ncuDoubleComplex\nz\nor\nZ\ncomplex double-precision\nWhen the parameters and returned values of the function differ, which sometimes happens for complex input, the <\nt\n> can also be\nSc\n,\nCs\n,\nDz\nand\nZd\n.\nThe abbreviation\n\\(\\mathbf{Re}(\\cdot)\\)\nand\n\\(\\mathbf{Im}(\\cdot)\\)\nwill stand for the real and imaginary part of a number, respectively. Since imaginary part of a real number does not exist, we will consider it to be zero and can usually simply discard it from the equation where it is being used. Also, the\n\\(\\bar{\\alpha}\\)\nwill denote the complex conjugate of\n\\(\\alpha\\)\n.\nIn general throughout the documentation, the lower case Greek symbols\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nwill denote scalars, lower case English letters in bold type\n\\(\\mathbf{x}\\)\nand\n\\(\\mathbf{y}\\)\nwill denote vectors and capital English letters\n\\(A\\)\n,\n\\(B\\)\nand\n\\(C\\)\nwill denote matrices.\n2.5.1.\ncublasI<t>amax()\n\ncublasStatus_t\ncublasIsamax\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\nfloat\n*\nx\n,\nint\nincx\n,\nint\n*\nresult\n)\ncublasStatus_t\ncublasIdamax\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ndouble\n*\nx\n,\nint\nincx\n,\nint\n*\nresult\n)\ncublasStatus_t\ncublasIcamax\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\nint\n*\nresult\n)\ncublasStatus_t\ncublasIzamax\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\nint\n*\nresult\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function finds the (smallest) index of the element of the maximum magnitude. Hence, the result is the first\n\\(i\\)\nsuch that\n\\(\\left| \\mathbf{Im}\\left( {x\\lbrack j\\rbrack} \\right) \\middle| + \\middle| \\mathbf{Re}\\left( {x\\lbrack j\\rbrack} \\right) \\right|\\)\nis maximum for\n\\(i = 1,\\ldots,n\\)\nand\n\\(j = 1 + \\left( {i - 1} \\right)*\\text{ incx}\\)\n. Notice that the last equation reflects 1-based indexing used for compatibility with Fortran.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nn\ninput\nNumber of elements in the vector\nx\n.\nx\ndevice\ninput\n<\ntype\n> vector with elements.\nincx\ninput\nStride between consecutive elements of\nx\n.\nresult\nhost or device\noutput\nThe resulting index, which is set to\n0\nif\nn\n<=\n0\nor\nincx\n<=\n0\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_ALLOC_FAILED\nThe reduction buffer could not be allocated\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nCUBLAS_STATUS_INVALID_VALUE\nresult\nis NULL\nFor references please refer to NETLIB documentation:\nisamax()\n,\nidamax()\n,\nicamax()\n,\nizamax()\n2.5.2.\ncublasI<t>amin()\n\ncublasStatus_t\ncublasIsamin\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\nfloat\n*\nx\n,\nint\nincx\n,\nint\n*\nresult\n)\ncublasStatus_t\ncublasIdamin\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ndouble\n*\nx\n,\nint\nincx\n,\nint\n*\nresult\n)\ncublasStatus_t\ncublasIcamin\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\nint\n*\nresult\n)\ncublasStatus_t\ncublasIzamin\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\nint\n*\nresult\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function finds the (smallest) index of the element of the minimum magnitude. Hence, the result is the first\n\\(i\\)\nsuch that\n\\(\\left| \\mathbf{Im}\\left( {x\\lbrack j\\rbrack} \\right) \\middle| + \\middle| \\mathbf{Re}\\left( {x\\lbrack j\\rbrack} \\right) \\right|\\)\nis minimum for\n\\(i = 1,\\ldots,n\\)\nand\n\\(j = 1 + \\left( {i - 1} \\right)*\\text{incx}\\)\nNotice that the last equation reflects 1-based indexing used for compatibility with Fortran.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nn\ninput\nNumber of elements in the vector\nx\n.\nx\ndevice\ninput\n<\ntype\n> vector with elements.\nincx\ninput\nStride between consecutive elements of\nx\n.\nresult\nhost or device\noutput\nThe resulting index, which is set to\n0\nif\nn\n<=\n0\nor\nincx\n<=\n0\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_ALLOC_FAILED\nThe reduction buffer could not be allocated\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nCUBLAS_STATUS_INVALID_VALUE\nresult\nis NULL\nFor references please refer to NETLIB documentation:\nisamin()\n2.5.3.\ncublas<t>asum()\n\ncublasStatus_t\ncublasSasum\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\nfloat\n*\nx\n,\nint\nincx\n,\nfloat\n*\nresult\n)\ncublasStatus_t\ncublasDasum\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ndouble\n*\nx\n,\nint\nincx\n,\ndouble\n*\nresult\n)\ncublasStatus_t\ncublasScasum\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\nfloat\n*\nresult\n)\ncublasStatus_t\ncublasDzasum\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\ndouble\n*\nresult\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function computes the sum of the absolute values of the elements of vector\nx\n. Hence, the result is\n\\(\\left. \\sum_{i = 1}^{n} \\middle| \\mathbf{Im}\\left( {x\\lbrack j\\rbrack} \\right) \\middle| + \\middle| \\mathbf{Re}\\left( {x\\lbrack j\\rbrack} \\right) \\right|\\)\nwhere\n\\(j = 1 + \\left( {i - 1} \\right)*\\text{incx}\\)\n. Notice that the last equation reflects 1-based indexing used for compatibility with Fortran.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nn\ninput\nNumber of elements in the vector\nx\n.\nx\ndevice\ninput\n<\ntype\n> vector with elements.\nincx\ninput\nStride between consecutive elements of\nx\n.\nresult\nhost or device\noutput\nThe resulting sum, which is set to\n0\nif\nn\n<=\n0\nor\nincx\n<=\n0\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_ALLOC_FAILED\nThe reduction buffer could not be allocated\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nCUBLAS_STATUS_INVALID_VALUE\nresult\nis NULL\nFor references please refer to NETLIB documentation:\nsasum()\n,\ndasum()\n,\nscasum()\n,\ndzasum()\n2.5.4.\ncublas<t>axpy()\n\ncublasStatus_t\ncublasSaxpy\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nx\n,\nint\nincx\n,\nfloat\n*\ny\n,\nint\nincy\n)\ncublasStatus_t\ncublasDaxpy\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nx\n,\nint\nincx\n,\ndouble\n*\ny\n,\nint\nincy\n)\ncublasStatus_t\ncublasCaxpy\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\ncuComplex\n*\ny\n,\nint\nincy\n)\ncublasStatus_t\ncublasZaxpy\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\ncuDoubleComplex\n*\ny\n,\nint\nincy\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function multiplies the vector\nx\nby the scalar\n\\(\\alpha\\)\nand adds it to the vector\ny\noverwriting the latest vector with the result. Hence, the performed operation is\n\\(\\mathbf{y}\\lbrack j\\rbrack = \\alpha \\times \\mathbf{x}\\lbrack k\\rbrack + \\mathbf{y}\\lbrack j\\rbrack\\)\nfor\n\\(i = 1,\\ldots,n\\)\n,\n\\(k = 1 + \\left( {i - 1} \\right)*\\text{incx}\\)\nand\n\\(j = 1 + \\left( {i - 1} \\right)*\\text{incy}\\)\n. Notice that the last two equations reflect 1-based indexing used for compatibility with Fortran.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nn\ninput\nNumber of elements in the vector\nx\nand\ny\n.\nx\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\ny\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nincy\ninput\nStride between consecutive elements of\ny\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nsaxpy()\n,\ndaxpy()\n,\ncaxpy()\n,\nzaxpy()\n2.5.5.\ncublas<t>copy()\n\ncublasStatus_t\ncublasScopy\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\nfloat\n*\nx\n,\nint\nincx\n,\nfloat\n*\ny\n,\nint\nincy\n)\ncublasStatus_t\ncublasDcopy\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ndouble\n*\nx\n,\nint\nincx\n,\ndouble\n*\ny\n,\nint\nincy\n)\ncublasStatus_t\ncublasCcopy\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\ncuComplex\n*\ny\n,\nint\nincy\n)\ncublasStatus_t\ncublasZcopy\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\ncuDoubleComplex\n*\ny\n,\nint\nincy\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function copies the vector\nx\ninto the vector\ny\n. Hence, the performed operation is\n\\(\\mathbf{y}\\lbrack j\\rbrack = \\mathbf{x}\\lbrack k\\rbrack\\)\nfor\n\\(i = 1,\\ldots,n\\)\n,\n\\(k = 1 + \\left( {i - 1} \\right)*\\text{incx}\\)\nand\n\\(j = 1 + \\left( {i - 1} \\right)*\\text{incy}\\)\n. Notice that the last two equations reflect 1-based indexing used for compatibility with Fortran.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nn\ninput\nNumber of elements in the vector\nx\nand\ny\n.\nx\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\ny\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nincy\ninput\nStride between consecutive elements of\ny\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nscopy()\n,\ndcopy()\n,\nccopy()\n,\nzcopy()\n2.5.6.\ncublas<t>dot()\n\ncublasStatus_t\ncublasSdot\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\nfloat\n*\nx\n,\nint\nincx\n,\nconst\nfloat\n*\ny\n,\nint\nincy\n,\nfloat\n*\nresult\n)\ncublasStatus_t\ncublasDdot\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ndouble\n*\nx\n,\nint\nincx\n,\nconst\ndouble\n*\ny\n,\nint\nincy\n,\ndouble\n*\nresult\n)\ncublasStatus_t\ncublasCdotu\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuComplex\n*\ny\n,\nint\nincy\n,\ncuComplex\n*\nresult\n)\ncublasStatus_t\ncublasCdotc\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuComplex\n*\ny\n,\nint\nincy\n,\ncuComplex\n*\nresult\n)\ncublasStatus_t\ncublasZdotu\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuDoubleComplex\n*\ny\n,\nint\nincy\n,\ncuDoubleComplex\n*\nresult\n)\ncublasStatus_t\ncublasZdotc\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuDoubleComplex\n*\ny\n,\nint\nincy\n,\ncuDoubleComplex\n*\nresult\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function computes the dot product of vectors\nx\nand\ny\n. Hence, the result is\n\\(\\sum_{i = 1}^{n}\\left( {\\mathbf{x}\\lbrack k\\rbrack \\times \\mathbf{y}\\lbrack j\\rbrack} \\right)\\)\nwhere\n\\(k = 1 + \\left( {i - 1} \\right)*\\text{incx}\\)\nand\n\\(j = 1 + \\left( {i - 1} \\right)*\\text{incy}\\)\n. Notice that in the first equation the conjugate of the element of vector x should be used if the function name ends in character ‘c’ and that the last two equations reflect 1-based indexing used for compatibility with Fortran.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nn\ninput\nNumber of elements in the vectors\nx\nand\ny\n.\nx\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\ny\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincy\ninput\nStride between consecutive elements of\ny\n.\nresult\nhost or device\noutput\nThe resulting dot product, which is set to\n0\nif\nn\n<=\n0\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_ALLOC_FAILED\nThe reduction buffer could not be allocated\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nsdot()\n,\nddot()\n,\ncdotu()\n,\ncdotc()\n,\nzdotu()\n,\nzdotc()\n2.5.7.\ncublas<t>nrm2()\n\ncublasStatus_t\ncublasSnrm2\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\nfloat\n*\nx\n,\nint\nincx\n,\nfloat\n*\nresult\n)\ncublasStatus_t\ncublasDnrm2\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ndouble\n*\nx\n,\nint\nincx\n,\ndouble\n*\nresult\n)\ncublasStatus_t\ncublasScnrm2\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\nfloat\n*\nresult\n)\ncublasStatus_t\ncublasDznrm2\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\ndouble\n*\nresult\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function computes the Euclidean norm of the vector\nx\n. The code uses a multiphase model of accumulation to avoid intermediate underflow and overflow, with the result being equivalent to\n\\(\\sqrt{\\sum_{i = 1}^{n}\\left( {\\mathbf{x}\\lbrack j\\rbrack \\times \\mathbf{x}\\lbrack j\\rbrack} \\right)}\\)\nwhere\n\\(j = 1 + \\left( {i - 1} \\right)*\\text{incx}\\)\nin exact arithmetic. Notice that the last equation reflects 1-based indexing used for compatibility with Fortran.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nn\ninput\nNumber of elements in the vector\nx\n.\nx\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\nresult\nhost or device\noutput\nThe resulting norm, which is set to\n0\nif\nn\n<=\n0\nor\nincx\n<=\n0\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_ALLOC_FAILED\nThe reduction buffer could not be allocated\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nCUBLAS_STATUS_INVALID_VALUE\nresult\nis NULL\nFor references please refer to NETLIB documentation:\nsnrm2()\n,\ndnrm2()\n,\nscnrm2()\n,\ndznrm2()\n2.5.8.\ncublas<t>rot()\n\ncublasStatus_t\ncublasSrot\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nfloat\n*\nx\n,\nint\nincx\n,\nfloat\n*\ny\n,\nint\nincy\n,\nconst\nfloat\n*\nc\n,\nconst\nfloat\n*\ns\n)\ncublasStatus_t\ncublasDrot\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\ndouble\n*\nx\n,\nint\nincx\n,\ndouble\n*\ny\n,\nint\nincy\n,\nconst\ndouble\n*\nc\n,\nconst\ndouble\n*\ns\n)\ncublasStatus_t\ncublasCrot\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\ncuComplex\n*\nx\n,\nint\nincx\n,\ncuComplex\n*\ny\n,\nint\nincy\n,\nconst\nfloat\n*\nc\n,\nconst\ncuComplex\n*\ns\n)\ncublasStatus_t\ncublasCsrot\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\ncuComplex\n*\nx\n,\nint\nincx\n,\ncuComplex\n*\ny\n,\nint\nincy\n,\nconst\nfloat\n*\nc\n,\nconst\nfloat\n*\ns\n)\ncublasStatus_t\ncublasZrot\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\ncuDoubleComplex\n*\ny\n,\nint\nincy\n,\nconst\ndouble\n*\nc\n,\nconst\ncuDoubleComplex\n*\ns\n)\ncublasStatus_t\ncublasZdrot\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\ncuDoubleComplex\n*\ny\n,\nint\nincy\n,\nconst\ndouble\n*\nc\n,\nconst\ndouble\n*\ns\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function applies Givens rotation matrix (i.e., rotation in the x,y plane counter-clockwise by angle defined by\n\\(cos(alpha) = c\\)\n,\n\\(sin(alpha) = s\\)\n):\n\\(G = \\begin{pmatrix}\nc & s \\\\\n{- s} & c \\\\\n\\end{pmatrix}\\)\nto vectors\nx\nand\ny\n.\nHence, the result is\n\\(\\mathbf{x}\\lbrack k\\rbrack = c \\times \\mathbf{x}\\lbrack k\\rbrack + s \\times \\mathbf{y}\\lbrack j\\rbrack\\)\nand\n\\(\\mathbf{y}\\lbrack j\\rbrack = - s \\times \\mathbf{x}\\lbrack k\\rbrack + c \\times \\mathbf{y}\\lbrack j\\rbrack\\)\nwhere\n\\(k = 1 + \\left( {i - 1} \\right)*\\text{incx}\\)\nand\n\\(j = 1 + \\left( {i - 1} \\right)*\\text{incy}\\)\n. Notice that the last two equations reflect 1-based indexing used for compatibility with Fortran.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nn\ninput\nNumber of elements in the vectors\nx\nand\ny\n.\nx\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\ny\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nincy\ninput\nStride between consecutive elements of\ny\n.\nc\nhost or device\ninput\nCosine element of the rotation matrix.\ns\nhost or device\ninput\nSine element of the rotation matrix.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nsrot()\n,\ndrot()\n,\ncrot()\n,\ncsrot()\n,\nzrot()\n,\nzdrot()\n2.5.9.\ncublas<t>rotg()\n\ncublasStatus_t\ncublasSrotg\n(\ncublasHandle_t\nhandle\n,\nfloat\n*\na\n,\nfloat\n*\nb\n,\nfloat\n*\nc\n,\nfloat\n*\ns\n)\ncublasStatus_t\ncublasDrotg\n(\ncublasHandle_t\nhandle\n,\ndouble\n*\na\n,\ndouble\n*\nb\n,\ndouble\n*\nc\n,\ndouble\n*\ns\n)\ncublasStatus_t\ncublasCrotg\n(\ncublasHandle_t\nhandle\n,\ncuComplex\n*\na\n,\ncuComplex\n*\nb\n,\nfloat\n*\nc\n,\ncuComplex\n*\ns\n)\ncublasStatus_t\ncublasZrotg\n(\ncublasHandle_t\nhandle\n,\ncuDoubleComplex\n*\na\n,\ncuDoubleComplex\n*\nb\n,\ndouble\n*\nc\n,\ncuDoubleComplex\n*\ns\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function constructs the Givens rotation matrix\n\\(G = \\begin{pmatrix}\nc & s \\\\\n{- s} & c \\\\\n\\end{pmatrix}\\)\nthat zeros out the second entry of a\n\\(2 \\times 1\\)\nvector\n\\(\\left( {a,b} \\right)^{T}\\)\n.\nThen, for real numbers we can write\n\\(\\begin{pmatrix}\nc & s \\\\\n{- s} & c \\\\\n\\end{pmatrix}\\begin{pmatrix}\na \\\\\nb \\\\\n\\end{pmatrix} = \\begin{pmatrix}\nr \\\\\n0 \\\\\n\\end{pmatrix}\\)\nwhere\n\\(c^{2} + s^{2} = 1\\)\nand\n\\(r = \\pm \\sqrt{a^{2} + b^{2}}\\)\n. The parameters\n\\(a\\)\nand\n\\(b\\)\nare overwritten with\n\\(r\\)\nand\n\\(z\\)\n, respectively. The value of\n\\(z\\)\nis such that\n\\(c\\)\nand\n\\(s\\)\nmay be recovered using the following rules:\n\\(\\left( {c,s} \\right) = \\begin{cases}\n\\left( {\\sqrt{1 - z^{2}},z} \\right) & {\\text{ if }\\left| z \\middle| < 1 \\right.} \\\\\n\\left( {0.0,1.0} \\right) & {\\text{ if }\\left| z \\middle| = 1 \\right.} \\\\\n\\left( 1/z,\\sqrt{1 - z^{2}} \\right) & {\\text{ if }\\left| z \\middle| > 1 \\right.} \\\\\n\\end{cases}\\)\nFor complex numbers we can write\n\\(\\begin{pmatrix}\nc & s \\\\\n{- \\bar{s}} & c \\\\\n\\end{pmatrix}\\begin{pmatrix}\na \\\\\nb \\\\\n\\end{pmatrix} = \\begin{pmatrix}\nr \\\\\n0 \\\\\n\\end{pmatrix}\\)\nwhere\n\\(c^{2} + \\left( {\\bar{s} \\times s} \\right) = 1\\)\nand\n\\(r = \\frac{a}{|a|} \\times \\parallel \\left( {a,b} \\right)^{T} \\parallel_{2}\\)\nwith\n\\(\\parallel \\left( {a,b} \\right)^{T} \\parallel_{2} = \\sqrt{\\left| a|^{2} + \\middle| B|^{2} \\right.}\\)\nfor\n\\(a \\neq 0\\)\nand\n\\(r = b\\)\nfor\n\\(a = 0\\)\n. Finally, the parameter\n\\(a\\)\nis overwritten with\n\\(r\\)\non exit.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\na\nhost or device\nin/out\n<\ntype\n> scalar that is overwritten with\n\\(r\\)\n.\nb\nhost or device\nin/out\n<\ntype\n> scalar that is overwritten with\n\\(z\\)\n.\nc\nhost or device\noutput\nCosine element of the rotation matrix.\ns\nhost or device\noutput\nSine element of the rotation matrix.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nsrotg()\n,\ndrotg()\n,\ncrotg()\n,\nzrotg()\n2.5.10.\ncublas<t>rotm()\n\ncublasStatus_t\ncublasSrotm\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nfloat\n*\nx\n,\nint\nincx\n,\nfloat\n*\ny\n,\nint\nincy\n,\nconst\nfloat\n*\nparam\n)\ncublasStatus_t\ncublasDrotm\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\ndouble\n*\nx\n,\nint\nincx\n,\ndouble\n*\ny\n,\nint\nincy\n,\nconst\ndouble\n*\nparam\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function applies the modified Givens transformation\n\\(H = \\begin{pmatrix}\nh_{11} & h_{12} \\\\\nh_{21} & h_{22} \\\\\n\\end{pmatrix}\\)\nto vectors\nx\nand\ny\n.\nHence, the result is\n\\(\\mathbf{x}\\lbrack k\\rbrack = h_{11} \\times \\mathbf{x}\\lbrack k\\rbrack + h_{12} \\times \\mathbf{y}\\lbrack j\\rbrack\\)\nand\n\\(\\mathbf{y}\\lbrack j\\rbrack = h_{21} \\times \\mathbf{x}\\lbrack k\\rbrack + h_{22} \\times \\mathbf{y}\\lbrack j\\rbrack\\)\nwhere\n\\(k = 1 + \\left( {i - 1} \\right)*\\text{incx}\\)\nand\n\\(j = 1 + \\left( {i - 1} \\right)*\\text{incy}\\)\n. Notice that the last two equations reflect 1-based indexing used for compatibility with Fortran.\nThe elements , , and of matrix\n\\(H\\)\nare stored in\nparam[1]\n,\nparam[2]\n,\nparam[3]\nand\nparam[4]\n, respectively. The\nflag\n=\nparam[0]\ndefines the following predefined values for the matrix\n\\(H\\)\nentries\nflag\n==\n-1.0\nflag\n==\n0.0\nflag\n==\n1.0\nflag\n==\n-2.0\n\\(\\begin{pmatrix}\nh_{11} & h_{12} \\\\\nh_{21} & h_{22} \\\\\n\\end{pmatrix}\\)\n\\(\\begin{pmatrix}\n{1.0} & h_{12} \\\\\nh_{21} & {1.0} \\\\\n\\end{pmatrix}\\)\n\\(\\begin{pmatrix}\nh_{11} & {1.0} \\\\\n{- 1.0} & h_{22} \\\\\n\\end{pmatrix}\\)\n\\(\\begin{pmatrix}\n{1.0} & {0.0} \\\\\n{0.0} & {1.0} \\\\\n\\end{pmatrix}\\)\nNotice that the values -1.0, 0.0 and 1.0 implied by the flag are not stored in param.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nn\ninput\nNumber of elements in the vectors\nx\nand\ny\n.\nx\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\ny\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nincy\ninput\nStride between consecutive elements of\ny\n.\nparam\nhost or device\ninput\n<\ntype\n> vector of 5 elements, where\nparam[0]\nand\nparam[1..4]\ncontain the flag and matrix\n\\(H\\)\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nsrotm()\n,\ndrotm()\n2.5.11.\ncublas<t>rotmg()\n\ncublasStatus_t\ncublasSrotmg\n(\ncublasHandle_t\nhandle\n,\nfloat\n*\nd1\n,\nfloat\n*\nd2\n,\nfloat\n*\nx1\n,\nconst\nfloat\n*\ny1\n,\nfloat\n*\nparam\n)\ncublasStatus_t\ncublasDrotmg\n(\ncublasHandle_t\nhandle\n,\ndouble\n*\nd1\n,\ndouble\n*\nd2\n,\ndouble\n*\nx1\n,\nconst\ndouble\n*\ny1\n,\ndouble\n*\nparam\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function constructs the modified Givens transformation\n\\(H = \\begin{pmatrix}\nh_{11} & h_{12} \\\\\nh_{21} & h_{22} \\\\\n\\end{pmatrix}\\)\nthat zeros out the second entry of a\n\\(2 \\times 1\\)\nvector\n\\(\\left( {\\sqrt{d1}*x1,\\sqrt{d2}*y1} \\right)^{T}\\)\n.\nThe\nflag\n=\nparam[0]\ndefines the following predefined values for the matrix\n\\(H\\)\nentries\nflag\n==\n-1.0\nflag\n==\n0.0\nflag\n==\n1.0\nflag\n==\n-2.0\n\\(\\begin{pmatrix}\nh_{11} & h_{12} \\\\\nh_{21} & h_{22} \\\\\n\\end{pmatrix}\\)\n\\(\\begin{pmatrix}\n{1.0} & h_{12} \\\\\nh_{21} & {1.0} \\\\\n\\end{pmatrix}\\)\n\\(\\begin{pmatrix}\nh_{11} & {1.0} \\\\\n{- 1.0} & h_{22} \\\\\n\\end{pmatrix}\\)\n\\(\\begin{pmatrix}\n{1.0} & {0.0} \\\\\n{0.0} & {1.0} \\\\\n\\end{pmatrix}\\)\nNotice that the values -1.0, 0.0 and 1.0 implied by the flag are not stored in param.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nd1\nhost or device\nin/out\n<\ntype\n> scalar that is overwritten on exit.\nd2\nhost or device\nin/out\n<\ntype\n> scalar that is overwritten on exit.\nx1\nhost or device\nin/out\n<\ntype\n> scalar that is overwritten on exit.\ny1\nhost or device\ninput\n<\ntype\n> scalar.\nparam\nhost or device\noutput\n<\ntype\n> vector of 5 elements, where\nparam[0]\nand\nparam[1-4]\ncontain the flag and matrix\n\\(H\\)\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nsrotmg()\n,\ndrotmg()\n2.5.12.\ncublas<t>scal()\n\ncublasStatus_t\ncublasSscal\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nfloat\n*\nx\n,\nint\nincx\n)\ncublasStatus_t\ncublasDscal\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ndouble\n*\nalpha\n,\ndouble\n*\nx\n,\nint\nincx\n)\ncublasStatus_t\ncublasCscal\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ncuComplex\n*\nalpha\n,\ncuComplex\n*\nx\n,\nint\nincx\n)\ncublasStatus_t\ncublasCsscal\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\ncuComplex\n*\nx\n,\nint\nincx\n)\ncublasStatus_t\ncublasZscal\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\ncuDoubleComplex\n*\nx\n,\nint\nincx\n)\ncublasStatus_t\ncublasZdscal\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ndouble\n*\nalpha\n,\ncuDoubleComplex\n*\nx\n,\nint\nincx\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function scales the vector\nx\nby the scalar\n\\(\\alpha\\)\nand overwrites it with the result. Hence, the performed operation is\n\\(\\mathbf{x}\\lbrack j\\rbrack = \\alpha \\times \\mathbf{x}\\lbrack j\\rbrack\\)\nfor\n\\(i = 1,\\ldots,n\\)\nand\n\\(j = 1 + \\left( {i - 1} \\right)*\\text{incx}\\)\n. Notice that the last two equations reflect 1-based indexing used for compatibility with Fortran.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nn\ninput\nNumber of elements in the vector\nx\n.\nx\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\nThe possible error values returned by this function and their meanings are listed below.\n:class: table-no-stripes\n\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nsscal()\n,\ndscal()\n,\ncsscal()\n,\ncscal()\n,\nzdscal()\n,\nzscal()\n2.5.13.\ncublas<t>swap()\n\ncublasStatus_t\ncublasSswap\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nfloat\n*\nx\n,\nint\nincx\n,\nfloat\n*\ny\n,\nint\nincy\n)\ncublasStatus_t\ncublasDswap\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\ndouble\n*\nx\n,\nint\nincx\n,\ndouble\n*\ny\n,\nint\nincy\n)\ncublasStatus_t\ncublasCswap\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\ncuComplex\n*\nx\n,\nint\nincx\n,\ncuComplex\n*\ny\n,\nint\nincy\n)\ncublasStatus_t\ncublasZswap\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\ncuDoubleComplex\n*\ny\n,\nint\nincy\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function interchanges the elements of vector\nx\nand\ny\n. Hence, the performed operation is\n\\(\\left. \\mathbf{y}\\lbrack j\\rbrack\\Leftrightarrow\\mathbf{x}\\lbrack k\\rbrack \\right.\\)\nfor\n\\(i = 1,\\ldots,n\\)\n,\n\\(k = 1 + \\left( {i - 1} \\right)*\\text{incx}\\)\nand\n\\(j = 1 + \\left( {i - 1} \\right)*\\text{incy}\\)\n. Notice that the last two equations reflect 1-based indexing used for compatibility with Fortran.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nn\ninput\nNumber of elements in the vectors\nx\nand\ny\n.\nx\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\ny\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nincy\ninput\nStride between consecutive elements of\ny\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nsswap()\n,\ndswap()\n,\ncswap()\n,\nzswap()\n2.6.\ncuBLAS Level-2 Function Reference\n\nIn this chapter we describe the Level-2 Basic Linear Algebra Subprograms (BLAS2) functions that perform matrix-vector operations.\n2.6.1.\ncublas<t>gbmv()\n\ncublasStatus_t\ncublasSgbmv\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nint\nkl\n,\nint\nku\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nx\n,\nint\nincx\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\ny\n,\nint\nincy\n)\ncublasStatus_t\ncublasDgbmv\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nint\nkl\n,\nint\nku\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nx\n,\nint\nincx\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\ny\n,\nint\nincy\n)\ncublasStatus_t\ncublasCgbmv\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nint\nkl\n,\nint\nku\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\ny\n,\nint\nincy\n)\ncublasStatus_t\ncublasZgbmv\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nint\nkl\n,\nint\nku\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\ny\n,\nint\nincy\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the banded matrix-vector multiplication\n\\(\\mathbf{y} = \\alpha\\text{ op}(A)\\mathbf{x} + \\beta\\mathbf{y}\\)\nwhere\n\\(A\\)\nis a banded matrix with\n\\(kl\\)\nsubdiagonals and\n\\(ku\\)\nsuperdiagonals,\n\\(\\mathbf{x}\\)\nand\n\\(\\mathbf{y}\\)\nare vectors, and\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars. Also, for matrix\n\\(A\\)\n\\(\\text{ op}(A) = \\begin{cases}\nA & \\text{ if trans == $\\mathrm{CUBLAS\\_OP\\_N}$} \\\\\nA^{T} & \\text{ if trans == $\\mathrm{CUBLAS\\_OP\\_T}$} \\\\\nA^{H} & \\text{ if trans == $\\mathrm{CUBLAS\\_OP\\_C}$} \\\\\n\\end{cases}\\)\nThe banded matrix\n\\(A\\)\nis stored column by column, with the main diagonal stored in row\n\\(ku + 1\\)\n(starting in first position), the first superdiagonal stored in row\n\\(ku\\)\n(starting in second position), the first subdiagonal stored in row\n\\(ku + 2\\)\n(starting in first position), etc. So that in general, the element\n\\(A\\left( {i,j} \\right)\\)\nis stored in the memory location\nA(ku+1+i-j,j)\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\in \\left\\lbrack {\\max\\left( {1,j - ku} \\right),\\min\\left( {m,j + kl} \\right)} \\right\\rbrack\\)\n. Also, the elements in the array\n\\(A\\)\nthat do not conceptually correspond to the elements in the banded matrix (the top left\n\\(ku \\times ku\\)\nand bottom right\n\\(kl \\times kl\\)\ntriangles) are not referenced.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\ntrans\ninput\nOperation op(\nA\n) that is non- or (conj.) transpose.\nm\ninput\nNumber of rows of matrix\nA\n.\nn\ninput\nNumber of columns of matrix\nA\n.\nkl\ninput\nNumber of subdiagonals of matrix\nA\n.\nku\ninput\nNumber of superdiagonals of matrix\nA\n.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nA\ndevice\ninput\n<\ntype\n> array of dimension\nlda\nx\nn\nwith\nlda\n>=\nkl\n+\nku\n+\n1\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nx\ndevice\ninput\n<\ntype\n> vector with\nn\nelements if\ntrans\n==\nCUBLAS_OP_N\nand\nm\nelements otherwise.\nincx\ninput\nStride between consecutive elements of\nx\n.\nbeta\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\nthen\ny\ndoes not have to be a valid input.\ny\ndevice\nin/out\n<\ntype\n> vector with\nm\nelements if\ntrans\n==\nCUBLAS_OP_N\nand\nn\nelements otherwise.\nincy\ninput\nStride between consecutive elements of\ny\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nm\n<\n0\n,\nn\n<\n0\n,\nkl\n<\n0\nor\nku\n<\n0\n, or\nif\nlda\n<\n(kl\n+\nku\n+\n1)\n, or\nif\nincx\n==\n0\nor\nincy\n==\n0\n, or\nif\ntrans\nis not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\n,\nCUBLAS_OP_C\n, or\nif\nalpha\nor\nbeta\nare NULL\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nsgbmv()\n,\ndgbmv()\n,\ncgbmv()\n,\nzgbmv()\n2.6.2.\ncublas<t>gemv()\n\ncublasStatus_t\ncublasSgemv\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nx\n,\nint\nincx\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\ny\n,\nint\nincy\n)\ncublasStatus_t\ncublasDgemv\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nx\n,\nint\nincx\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\ny\n,\nint\nincy\n)\ncublasStatus_t\ncublasCgemv\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\ny\n,\nint\nincy\n)\ncublasStatus_t\ncublasZgemv\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\ny\n,\nint\nincy\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the matrix-vector multiplication\n\\(\\textbf{y} = \\alpha\\text{ op}(A)\\textbf{x} + \\beta\\textbf{y}\\)\nwhere\n\\(A\\)\nis a\n\\(m \\times n\\)\nmatrix stored in column-major format,\n\\(\\mathbf{x}\\)\nand\n\\(\\mathbf{y}\\)\nare vectors, and\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars. Also, for matrix\n\\(A\\)\n\\(\\text{ op}(A) = \\begin{cases}\nA & \\text{ if trans == $\\mathrm{CUBLAS\\_OP\\_N}$} \\\\\nA^{T} & \\text{ if trans == $\\mathrm{CUBLAS\\_OP\\_T}$} \\\\\nA^{H} & \\text{ if trans == $\\mathrm{CUBLAS\\_OP\\_C}$} \\\\\n\\end{cases}\\)\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\ntrans\ninput\nOperation op(\nA\n) that is non- or (conj.) transpose.\nm\ninput\nNumber of rows of matrix\nA\n.\nn\ninput\nNumber of columns of matrix\nA\n.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nA\ndevice\ninput\n<\ntype\n> array of dimension\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nm)\n. Before entry, the leading\nm\nby\nn\npart of the array\nA\nmust contain the matrix of coefficients. Unchanged on exit.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nlda\nmust be at least\nmax(1,\nm)\n.\nx\ndevice\ninput\n<\ntype\n> vector at least\n(1\n+\n(n\n-\n1)\n*\nabs(incx))\nelements if\ntrans\n==\nCUBLAS_OP_N\nand at least\n(1\n+\n(m\n-\n1)\n*\nabs(incx))\nelements otherwise.\nincx\ninput\nStride between consecutive elements of\nx\n.\nbeta\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\nthen\ny\ndoes not have to be a valid input.\ny\ndevice\nin/out\n<\ntype\n> vector at least\n(1\n+\n(m\n-\n1)\n*\nabs(incy))\nelements if\ntrans\n==\nCUBLAS_OP_N\nand at least\n(1\n+\n(n\n-\n1)\n*\nabs(incy))\nelements otherwise.\nincy\ninput\nStride between consecutive elements of\ny\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nThe parameters\nm\n<\n0\nor\nn\n<\n0\n, or\nincx\n==\n0\nor\nincy\n==\n0\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nsgemv()\n,\ndgemv()\n,\ncgemv()\n,\nzgemv()\n2.6.3.\ncublas<t>ger()\n\ncublasStatus_t\ncublasSger\n(\ncublasHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nx\n,\nint\nincx\n,\nconst\nfloat\n*\ny\n,\nint\nincy\n,\nfloat\n*\nA\n,\nint\nlda\n)\ncublasStatus_t\ncublasDger\n(\ncublasHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nx\n,\nint\nincx\n,\nconst\ndouble\n*\ny\n,\nint\nincy\n,\ndouble\n*\nA\n,\nint\nlda\n)\ncublasStatus_t\ncublasCgeru\n(\ncublasHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuComplex\n*\ny\n,\nint\nincy\n,\ncuComplex\n*\nA\n,\nint\nlda\n)\ncublasStatus_t\ncublasCgerc\n(\ncublasHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuComplex\n*\ny\n,\nint\nincy\n,\ncuComplex\n*\nA\n,\nint\nlda\n)\ncublasStatus_t\ncublasZgeru\n(\ncublasHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuDoubleComplex\n*\ny\n,\nint\nincy\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n)\ncublasStatus_t\ncublasZgerc\n(\ncublasHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuDoubleComplex\n*\ny\n,\nint\nincy\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the rank-1 update\n\\(A = \\begin{cases}\n{\\alpha\\mathbf{xy}^{T} + A} & \\text{if ger(),geru() is called} \\\\\n{\\alpha\\mathbf{xy}^{H} + A} & \\text{if gerc() is called} \\\\\n\\end{cases}\\)\nwhere\n\\(A\\)\nis a\n\\(m \\times n\\)\nmatrix stored in column-major format,\n\\(\\mathbf{x}\\)\nand\n\\(\\mathbf{y}\\)\nare vectors, and\n\\(\\alpha\\)\nis a scalar.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nm\ninput\nNumber of rows of matrix\nA\n.\nn\ninput\nNumber of columns of matrix\nA\n.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nx\ndevice\ninput\n<\ntype\n> vector with\nm\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\ny\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincy\ninput\nStride between consecutive elements of\ny\n.\nA\ndevice\nin/out\n<\ntype\n> array of dimension\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nm)\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nm\n<\n0\nor\nn\n<\n0\n, or\nif\nincx\n==\n0\nor\nincy\n==\n0\n, or\nif\nalpha\nis NULL, or\nif\nlda\n<\nmax(1,\nm)\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nsger()\n,\ndger()\n,\ncgeru()\n,\ncgerc()\n,\nzgeru()\n,\nzgerc()\n2.6.4.\ncublas<t>sbmv()\n\ncublasStatus_t\ncublasSsbmv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nint\nk\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nx\n,\nint\nincx\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\ny\n,\nint\nincy\n)\ncublasStatus_t\ncublasDsbmv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nint\nk\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nx\n,\nint\nincx\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\ny\n,\nint\nincy\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the symmetric banded matrix-vector multiplication\n\\(\\textbf{y} = \\alpha A\\textbf{x} + \\beta\\textbf{y}\\)\nwhere\n\\(A\\)\nis a\n\\(n \\times n\\)\nsymmetric banded matrix with\n\\(k\\)\nsubdiagonals and superdiagonals,\n\\(\\mathbf{x}\\)\nand\n\\(\\mathbf{y}\\)\nare vectors, and\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_LOWER\nthen the symmetric banded matrix\n\\(A\\)\nis stored column by column, with the main diagonal of the matrix stored in row 1, the first subdiagonal in row 2 (starting at first position), the second subdiagonal in row 3 (starting at first position), etc. So that in general, the element\n\\(A(i,j)\\)\nis stored in the memory location\nA(1+i-j,j)\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\in \\lbrack j,\\min(m,j + k)\\rbrack\\)\n. Also, the elements in the array\nA\nthat do not conceptually correspond to the elements in the banded matrix (the bottom right\n\\(k \\times k\\)\ntriangle) are not referenced.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_UPPER\nthen the symmetric banded matrix\n\\(A\\)\nis stored column by column, with the main diagonal of the matrix stored in row\nk\n+\n1\n, the first superdiagonal in row\nk\n(starting at second position), the second superdiagonal in row\nk-1\n(starting at third position), etc. So that in general, the element\n\\(A(i,j)\\)\nis stored in the memory location\nA(1+k+i-j,j)\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\in \\lbrack\\max(1,j - k),j\\rbrack\\)\n. Also, the elements in the array\nA\nthat do not conceptually correspond to the elements in the banded matrix (the top left\n\\(k \\times k\\)\ntriangle) are not referenced.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements.\nn\ninput\nNumber of rows and columns of matrix\nA\n.\nk\ninput\nNumber of sub- and super-diagonals of matrix\nA\n.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nA\ndevice\ninput\n<\ntype\n> array of dimension\nlda\nx\nn\nwith\nlda\n>=\nk\n+\n1\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nx\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\nbeta\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\nthen\ny\ndoes not have to be a valid input.\ny\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nincy\ninput\nStride between consecutive elements of\ny\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\nor\nk\n<\n0\n, or\nif\nincx\n==\n0\nor\nincy\n==\n0\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nalpha\nor\nbeta\nare NULL, or\nif\nlda\n<\n(1\n+\nk)\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nssbmv()\n,\ndsbmv()\n2.6.5.\ncublas<t>spmv()\n\ncublasStatus_t\ncublasSspmv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nAP\n,\nconst\nfloat\n*\nx\n,\nint\nincx\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\ny\n,\nint\nincy\n)\ncublasStatus_t\ncublasDspmv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nAP\n,\nconst\ndouble\n*\nx\n,\nint\nincx\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\ny\n,\nint\nincy\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the symmetric packed matrix-vector multiplication\n\\(\\textbf{y} = \\alpha A\\textbf{x} + \\beta\\textbf{y}\\)\nwhere\n\\(A\\)\nis a\n\\(n \\times n\\)\nsymmetric matrix stored in packed format,\n\\(\\mathbf{x}\\)\nand\n\\(\\mathbf{y}\\)\nare vectors, and\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_LOWER\nthen the elements in the lower triangular part of the symmetric matrix\n\\(A\\)\nare packed together column by column without gaps, so that the element\n\\(A(i,j)\\)\nis stored in the memory location\nAP[i+((2*n-j+1)*j)/2]\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\geq j\\)\n. Consequently, the packed format requires only\n\\(\\frac{n(n + 1)}{2}\\)\nelements for storage.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_UPPER\nthen the elements in the upper triangular part of the symmetric matrix\n\\(A\\)\nare packed together column by column without gaps, so that the element\n\\(A(i,j)\\)\nis stored in the memory location\nAP[i+(j*(j+1))/2]\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\leq j\\)\n. Consequently, the packed format requires only\n\\(\\frac{n(n + 1)}{2}\\)\nelements for storage.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\n\\(A\\)\nlower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements.\nn\ninput\nNumber of rows and columns of matrix\n\\(A\\)\n.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nAP\ndevice\ninput\n<\ntype\n> array with\n\\(A\\)\nstored in packed format.\nx\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\nbeta\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\nthen\ny\ndoes not have to be a valid input.\ny\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincy\ninput\nStride between consecutive elements of\ny\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\n, or\nif\nincx\n==\n0\nor\nincy\n==\n0\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nalpha\nor\nbeta\nare NULL\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nsspmv()\n,\ndspmv()\n2.6.6.\ncublas<t>spr()\n\ncublasStatus_t\ncublasSspr\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nx\n,\nint\nincx\n,\nfloat\n*\nAP\n)\ncublasStatus_t\ncublasDspr\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nx\n,\nint\nincx\n,\ndouble\n*\nAP\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the packed symmetric rank-1 update\n\\(A = \\alpha\\textbf{x}\\textbf{x}^{T} + A\\)\nwhere\n\\(A\\)\nis a\n\\(n \\times n\\)\nsymmetric matrix stored in packed format,\n\\(\\mathbf{x}\\)\nis a vector, and\n\\(\\alpha\\)\nis a scalar.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_LOWER\nthen the elements in the lower triangular part of the symmetric matrix\n\\(A\\)\nare packed together column by column without gaps, so that the element\n\\(A(i,j)\\)\nis stored in the memory location\nAP[i+((2*n-j+1)*j)/2]\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\geq j\\)\n. Consequently, the packed format requires only\n\\(\\frac{n(n + 1)}{2}\\)\nelements for storage.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_UPPER\nthen the elements in the upper triangular part of the symmetric matrix\n\\(A\\)\nare packed together column by column without gaps, so that the element\n\\(A(i,j)\\)\nis stored in the memory location\nAP[i+(j*(j+1))/2]\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\leq j\\)\n. Consequently, the packed format requires only\n\\(\\frac{n(n + 1)}{2}\\)\nelements for storage.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\n\\(A\\)\nlower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements.\nn\ninput\nNumber of rows and columns of matrix\n\\(A\\)\n.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nx\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\nAP\ndevice\nin/out\n<\ntype\n> array with\n\\(A\\)\nstored in packed format.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\n, or\nif\nincx\n==\n0\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nalpha\nis NULL\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nsspr()\n,\ndspr()\n2.6.7.\ncublas<t>spr2()\n\ncublasStatus_t\ncublasSspr2\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nx\n,\nint\nincx\n,\nconst\nfloat\n*\ny\n,\nint\nincy\n,\nfloat\n*\nAP\n)\ncublasStatus_t\ncublasDspr2\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nx\n,\nint\nincx\n,\nconst\ndouble\n*\ny\n,\nint\nincy\n,\ndouble\n*\nAP\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the packed symmetric rank-2 update\n\\(A = \\alpha\\left( {\\textbf{x}\\textbf{y}^{T} + \\textbf{y}\\textbf{x}^{T}} \\right) + A\\)\nwhere\n\\(A\\)\nis a\n\\(n \\times n\\)\nsymmetric matrix stored in packed format,\n\\(\\mathbf{x}\\)\nis a vector, and\n\\(\\alpha\\)\nis a scalar.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_LOWER\nthen the elements in the lower triangular part of the symmetric matrix\n\\(A\\)\nare packed together column by column without gaps, so that the element\n\\(A(i,j)\\)\nis stored in the memory location\nAP[i+((2*n-j+1)*j)/2]\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\geq j\\)\n. Consequently, the packed format requires only\n\\(\\frac{n(n + 1)}{2}\\)\nelements for storage.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_UPPER\nthen the elements in the upper triangular part of the symmetric matrix\n\\(A\\)\nare packed together column by column without gaps, so that the element\n\\(A(i,j)\\)\nis stored in the memory location\nAP[i+(j*(j+1))/2]\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\leq j\\)\n. Consequently, the packed format requires only\n\\(\\frac{n(n + 1)}{2}\\)\nelements for storage.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\n\\(A\\)\nlower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements.\nn\ninput\nNumber of rows and columns of matrix\n\\(A\\)\n.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nx\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\ny\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincy\ninput\nStride between consecutive elements of\ny\n.\nAP\ndevice\nin/out\n<\ntype\n> array with\n\\(A\\)\nstored in packed format.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\n, or\nif\nincx\n==\n0\nor\nincy\n==\n0\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nalpha\nis NULL\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nsspr2()\n,\ndspr2()\n2.6.8.\ncublas<t>symv()\n\ncublasStatus_t\ncublasSsymv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nx\n,\nint\nincx\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\ny\n,\nint\nincy\n)\ncublasStatus_t\ncublasDsymv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nx\n,\nint\nincx\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\ny\n,\nint\nincy\n)\ncublasStatus_t\ncublasCsymv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuComplex\n*\nalpha\n,\n/* host or device pointer */\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\ny\n,\nint\nincy\n)\ncublasStatus_t\ncublasZsymv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\ny\n,\nint\nincy\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the symmetric matrix-vector multiplication.\n\\(\\textbf{y} = \\alpha A\\textbf{x} + \\beta\\textbf{y}\\)\nwhere\n\\(A\\)\nis a\n\\(n \\times n\\)\nsymmetric matrix stored in lower or upper mode,\n\\(\\mathbf{x}\\)\nand\n\\(\\mathbf{y}\\)\nare vectors, and\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars.\nThis function has an alternate faster implementation using atomics that can be enabled with\ncublasSetAtomicsMode()\n.\nPlease see the section on the function\ncublasSetAtomicsMode()\nfor more details about the usage of atomics.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix lower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements.\nn\ninput\nNumber of rows and columns of matrix\nA\n.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nA\ndevice\ninput\n<\ntype\n> array of dimension\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nn)\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nx\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\nbeta\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\nthen\ny\ndoes not have to be a valid input.\ny\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nincy\ninput\nStride between consecutive elements of\ny\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\n, or\nif\nincx\n==\n0\nor\nincy\n==\n0\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nlda\n<\nn\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nssymv()\n,\ndsymv()\n2.6.9.\ncublas<t>syr()\n\ncublasStatus_t\ncublasSsyr\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nx\n,\nint\nincx\n,\nfloat\n*\nA\n,\nint\nlda\n)\ncublasStatus_t\ncublasDsyr\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nx\n,\nint\nincx\n,\ndouble\n*\nA\n,\nint\nlda\n)\ncublasStatus_t\ncublasCsyr\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\ncuComplex\n*\nA\n,\nint\nlda\n)\ncublasStatus_t\ncublasZsyr\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the symmetric rank-1 update\n\\(A = \\alpha\\textbf{x}\\textbf{x}^{T} + A\\)\nwhere\n\\(A\\)\nis a\n\\(n \\times n\\)\nsymmetric matrix stored in column-major format,\n\\(\\mathbf{x}\\)\nis a vector, and\n\\(\\alpha\\)\nis a scalar.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements.\nn\ninput\nNumber of rows and columns of matrix\nA\n.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nx\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\nA\ndevice\nin/out\n<\ntype\n> array of dimensions\nlda\nx\nn\n, with\nlda\n>=\nmax(1,\nn)\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\n, or\nif\nincx\n==\n0\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nlda\n<\nmax(1,\nn)\n, or\nif\nalpha\nis NULL\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nssyr()\n,\ndsyr()\n2.6.10.\ncublas<t>syr2()\n\ncublasStatus_t\ncublasSsyr2\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nx\n,\nint\nincx\n,\nconst\nfloat\n*\ny\n,\nint\nincy\n,\nfloat\n*\nA\n,\nint\nlda\ncublasStatus_t\ncublasDsyr2\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nx\n,\nint\nincx\n,\nconst\ndouble\n*\ny\n,\nint\nincy\n,\ndouble\n*\nA\n,\nint\nlda\ncublasStatus_t\ncublasCsyr2\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuComplex\n*\ny\n,\nint\nincy\n,\ncuComplex\n*\nA\n,\nint\nlda\ncublasStatus_t\ncublasZsyr2\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuDoubleComplex\n*\ny\n,\nint\nincy\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the symmetric rank-2 update\n\\(A = \\alpha\\left( {\\textbf{x}\\textbf{y}^{T} + \\textbf{y}\\textbf{x}^{T}} \\right) + A\\)\nwhere\n\\(A\\)\nis a\n\\(n \\times n\\)\nsymmetric matrix stored in column-major format,\n\\(\\mathbf{x}\\)\nand\n\\(\\mathbf{y}\\)\nare vectors, and\n\\(\\alpha\\)\nis a scalar.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements.\nn\ninput\nNumber of rows and columns of matrix\nA\n.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nx\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\ny\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincy\ninput\nStride between consecutive elements of\ny\n.\nA\ndevice\nin/out\n<\ntype\n> array of dimensions\nlda\nx\nn\n, with\nlda\n>=\nmax(1,n)\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\n, or\nif\nincx\n==\n0\nor\nincy\n==\n0\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nalpha\nis NULL, or\nif\nlda\n<\nmax(1,\nn)\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nssyr2()\n,\ndsyr2()\n2.6.11.\ncublas<t>tbmv()\n\ncublasStatus_t\ncublasStbmv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nint\nk\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\n*\nx\n,\nint\nincx\n)\ncublasStatus_t\ncublasDtbmv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nint\nk\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\n*\nx\n,\nint\nincx\n)\ncublasStatus_t\ncublasCtbmv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nint\nk\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\ncuComplex\n*\nx\n,\nint\nincx\n)\ncublasStatus_t\ncublasZtbmv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nint\nk\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ncuDoubleComplex\n*\nx\n,\nint\nincx\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the triangular banded matrix-vector multiplication\n\\(\\textbf{x} = \\text{op}(A)\\textbf{x}\\)\nwhere\n\\(A\\)\nis a triangular banded matrix, and\n\\(\\mathbf{x}\\)\nis a vector. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\nA^{H} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nIf\nuplo\n==\nCUBLAS_FILL_MODE_LOWER\nthen the triangular banded matrix\n\\(A\\)\nis stored column by column, with the main diagonal of the matrix stored in row\n1\n, the first subdiagonal in row\n2\n(starting at first position), the second subdiagonal in row\n3\n(starting at first position), etc. So that in general, the element\n\\(A(i,j)\\)\nis stored in the memory location\nA(1+i-j,j)\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\in \\lbrack j,\\min(m,j + k)\\rbrack\\)\n. Also, the elements in the array\nA\nthat do not conceptually correspond to the elements in the banded matrix (the bottom right\n\\(k \\times k\\)\ntriangle) are not referenced.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_UPPER\nthen the triangular banded matrix\n\\(A\\)\nis stored column by column, with the main diagonal of the matrix stored in row\nk\n+\n1\n, the first superdiagonal in row\nk\n(starting at second position), the second superdiagonal in row\nk-1\n(starting at third position), etc. So that in general, the element\n\\(A(i,j)\\)\nis stored in the memory location\nA(1+k+i-j,j)\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\in \\lbrack\\max(1,j - k,j)\\rbrack\\)\n. Also, the elements in the array\nA\nthat do not conceptually correspond to the elements in the banded matrix (the top left\n\\(k \\times k\\)\ntriangle) are not referenced.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other part is not referenced and is inferred from the stored elements.\ntrans\ninput\nOperation op(\nA\n) that is non- or (conj.) transpose.\ndiag\ninput\nIndicates if the elements on the main diagonal of matrix\nA\nare unity and should not be accessed.\nn\ninput\nNumber of rows and columns of matrix\nA\n.\nk\ninput\nNumber of sub- and super-diagonals of matrix .\nA\ndevice\ninput\n<\ntype\n> array of dimension\nlda\nx\nn\n, with\nlda\n>=\nk\n+\n1\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nx\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\nor\nk\n<\n0\n, or\nif\nincx\n==\n0\n, or\nif\ntrans\nis not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\nand\nCUBLAS_OP_C\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\ndiag\nis not one of\nCUBLAS_DIAG_UNIT\nand\nCUBLAS_DIAG_NON_UNIT\n, or\nif\nlda\n<\n(1\n+\nk)\nCUBLAS_STATUS_ALLOC_FAILED\nThe allocation of internal scratch memory failed\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nstbmv()\n,\ndtbmv()\n,\nctbmv()\n,\nztbmv()\n2.6.12.\ncublas<t>tbsv()\n\ncublasStatus_t\ncublasStbsv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nint\nk\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\n*\nx\n,\nint\nincx\n)\ncublasStatus_t\ncublasDtbsv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nint\nk\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\n*\nx\n,\nint\nincx\n)\ncublasStatus_t\ncublasCtbsv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nint\nk\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\ncuComplex\n*\nx\n,\nint\nincx\n)\ncublasStatus_t\ncublasZtbsv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nint\nk\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ncuDoubleComplex\n*\nx\n,\nint\nincx\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function solves the triangular banded linear system with a single right-hand-side\n\\(\\text{op}(A)\\textbf{x} = \\textbf{b}\\)\nwhere\n\\(A\\)\nis a triangular banded matrix, and\n\\(\\mathbf{x}\\)\nand\n\\(\\mathbf{b}\\)\nare vectors. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\nA^{H} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nThe solution\n\\(\\mathbf{x}\\)\noverwrites the right-hand-sides\n\\(\\mathbf{b}\\)\non exit.\nNo test for singularity or near-singularity is included in this function.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_LOWER\nthen the triangular banded matrix\n\\(A\\)\nis stored column by column, with the main diagonal of the matrix stored in row\n1\n, the first subdiagonal in row\n2\n(starting at first position), the second subdiagonal in row\n3\n(starting at first position), etc. So that in general, the element\n\\(A(i,j)\\)\nis stored in the memory location\nA(1+i-j,j)\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\in \\lbrack j,\\min(m,j + k)\\rbrack\\)\n. Also, the elements in the array\nA\nthat do not conceptually correspond to the elements in the banded matrix (the bottom right\n\\(k \\times k\\)\ntriangle) are not referenced.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_UPPER\nthen the triangular banded matrix\n\\(A\\)\nis stored column by column, with the main diagonal of the matrix stored in row\nk\n+\n1\n, the first superdiagonal in row\nk\n(starting at second position), the second superdiagonal in row\nk-1\n(starting at third position), etc. So that in general, the element\n\\(A(i,j)\\)\nis stored in the memory location\nA(1+k+i-j,j)\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\in \\lbrack\\max(1,j - k,j)\\rbrack\\)\n. Also, the elements in the array\nA\nthat do not conceptually correspond to the elements in the banded matrix (the top left\n\\(k \\times k\\)\ntriangle) are not referenced.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other part is not referenced and is inferred from the stored elements.\ntrans\ninput\nOperation op(\nA\n) that is non- or (conj.) transpose.\ndiag\ninput\nIndicates if the elements on the main diagonal of matrix\nA\nare unity and should not be accessed.\nn\ninput\nNumber of rows and columns of matrix\nA\n.\nk\ninput\nNumber of sub- and super-diagonals of matrix\nA\n.\nA\ndevice\ninput\n<\ntype\n> array of dimension\nlda\nx\nn\n, with\nlda\n>=\nk+1\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nx\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\nor\nk\n<\n0\n, or\nif\nincx\n==\n0\n, or\nif\ntrans\nis not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\nand\nCUBLAS_OP_C\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\ndiag\nis not one of\nCUBLAS_DIAG_UNIT\nand\nCUBLAS_DIAG_NON_UNIT\n, or\nif\nlda\n<\n(1\n+\nk)\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nstbsv()\n,\ndtbsv()\n,\nctbsv()\n,\nztbsv()\n2.6.13.\ncublas<t>tpmv()\n\ncublasStatus_t\ncublasStpmv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nconst\nfloat\n*\nAP\n,\nfloat\n*\nx\n,\nint\nincx\n)\ncublasStatus_t\ncublasDtpmv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nconst\ndouble\n*\nAP\n,\ndouble\n*\nx\n,\nint\nincx\n)\ncublasStatus_t\ncublasCtpmv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nconst\ncuComplex\n*\nAP\n,\ncuComplex\n*\nx\n,\nint\nincx\n)\ncublasStatus_t\ncublasZtpmv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nAP\n,\ncuDoubleComplex\n*\nx\n,\nint\nincx\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the triangular packed matrix-vector multiplication\n\\(\\textbf{x} = \\text{op}(A)\\textbf{x}\\)\nwhere\n\\(A\\)\nis a triangular matrix stored in packed format, and\n\\(\\mathbf{x}\\)\nis a vector. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\nA^{H} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nIf\nuplo\n==\nCUBLAS_FILL_MODE_LOWER\nthen the elements in the lower triangular part of the triangular matrix\n\\(A\\)\nare packed together column by column without gaps, so that the element\n\\(A(i,j)\\)\nis stored in the memory location\nAP[i+((2*n-j+1)*j)/2]\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\geq j\\)\n. Consequently, the packed format requires only\n\\(\\frac{n(n + 1)}{2}\\)\nelements for storage.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_UPPER\nthen the elements in the upper triangular part of the triangular matrix\n\\(A\\)\nare packed together column by column without gaps, so that the element\n\\(A(i,j)\\)\nis stored in the memory location\nAP[i+(j*(j+1))/2]\nfor\n\\(A(i,j)\\)\nand\n\\(i \\leq j\\)\n. Consequently, the packed format requires only\n\\(\\frac{n(n + 1)}{2}\\)\nelements for storage.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other part is not referenced and is inferred from the stored elements.\ntrans\ninput\nOperation op(\nA\n) that is non- or (conj.) transpose.\ndiag\ninput\nIndicates if the elements on the main diagonal of matrix\nA\nare unity and should not be accessed.\nn\ninput\nNumber of rows and columns of matrix\nA\n.\nAP\ndevice\ninput\n<\ntype\n> array with\n\\(A\\)\nstored in packed format.\nx\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\n, or\nif\nincx\n==\n0\n, or\nif\ntrans\nis not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\nand\nCUBLAS_OP_C\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\ndiag\nis not one of\nCUBLAS_DIAG_UNIT\nand\nCUBLAS_DIAG_NON_UNIT\nCUBLAS_STATUS_ALLOC_FAILED\nThe allocation of internal scratch memory failed\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nstpmv()\n,\ndtpmv()\n,\nctpmv()\n,\nztpmv()\n2.6.14.\ncublas<t>tpsv()\n\ncublasStatus_t\ncublasStpsv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nconst\nfloat\n*\nAP\n,\nfloat\n*\nx\n,\nint\nincx\n)\ncublasStatus_t\ncublasDtpsv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nconst\ndouble\n*\nAP\n,\ndouble\n*\nx\n,\nint\nincx\n)\ncublasStatus_t\ncublasCtpsv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nconst\ncuComplex\n*\nAP\n,\ncuComplex\n*\nx\n,\nint\nincx\n)\ncublasStatus_t\ncublasZtpsv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nAP\n,\ncuDoubleComplex\n*\nx\n,\nint\nincx\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function solves the packed triangular linear system with a single right-hand-side\n\\(\\text{op}(A)\\textbf{x} = \\textbf{b}\\)\nwhere\n\\(A\\)\nis a triangular matrix stored in packed format, and\n\\(\\mathbf{x}\\)\nand\n\\(\\mathbf{b}\\)\nare vectors. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\nA^{H} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nThe solution\n\\(\\mathbf{x}\\)\noverwrites the right-hand-sides\n\\(\\mathbf{b}\\)\non exit.\nNo test for singularity or near-singularity is included in this function.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_LOWER\nthen the elements in the lower triangular part of the triangular matrix\n\\(A\\)\nare packed together column by column without gaps, so that the element\n\\(A(i,j)\\)\nis stored in the memory location\nAP[i+((2*n-j+1)*j)/2]\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\geq j\\)\n. Consequently, the packed format requires only\n\\(\\frac{n(n + 1)}{2}\\)\nelements for storage.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_UPPER\nthen the elements in the upper triangular part of the triangular matrix\n\\(A\\)\nare packed together column by column without gaps, so that the element\n\\(A(i,j)\\)\nis stored in the memory location\nAP[i+(j*(j+1))/2]\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\leq j\\)\n. Consequently, the packed format requires only\n\\(\\frac{n(n + 1)}{2}\\)\nelements for storage.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other part is not referenced and is inferred from the stored elements.\ntrans\ninput\nOperation op(\nA\n) that is non- or (conj.) transpose.\ndiag\ninput\nIndicates if the elements on the main diagonal of matrix are unity and should not be accessed.\nn\ninput\nNumber of rows and columns of matrix\nA\n.\nAP\ndevice\ninput\n<\ntype\n> array with\n\\(A\\)\nstored in packed format.\nx\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\n, or\nif\nincx\n==\n0\n, or\nif\ntrans\nis not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\nand\nCUBLAS_OP_C\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\ndiag\nis not one of\nCUBLAS_DIAG_UNIT\nand\nCUBLAS_DIAG_NON_UNIT\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nstpsv()\n,\ndtpsv()\n,\nctpsv()\n,\nztpsv()\n2.6.15.\ncublas<t>trmv()\n\ncublasStatus_t\ncublasStrmv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\n*\nx\n,\nint\nincx\n)\ncublasStatus_t\ncublasDtrmv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\n*\nx\n,\nint\nincx\n)\ncublasStatus_t\ncublasCtrmv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\ncuComplex\n*\nx\n,\nint\nincx\n)\ncublasStatus_t\ncublasZtrmv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ncuDoubleComplex\n*\nx\n,\nint\nincx\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the triangular matrix-vector multiplication\n\\(\\textbf{x} = \\text{op}(A)\\textbf{x}\\)\nwhere\n\\(A\\)\nis a triangular matrix stored in lower or upper mode with or without the main diagonal, and\n\\(\\mathbf{x}\\)\nis a vector. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\nA^{H} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other part is not referenced and is inferred from the stored elements.\ntrans\ninput\nOperation op(\nA\n) that is non- or (conj.) transpose.\ndiag\ninput\nIndicates if the elements on the main diagonal of matrix\nA\nare unity and should not be accessed.\nn\ninput\nNumber of rows and columns of matrix\nA\n.\nA\ndevice\ninput\n<\ntype\n> array of dimensions\nlda\nx\nn\n, with\nlda\n>=\nmax(1,\nn)\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nx\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\n, or\nif\nincx\n==\n0\n, or\nif\ntrans\nis not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\nand\nCUBLAS_OP_C\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\ndiag\nis not one of\nCUBLAS_DIAG_UNIT\nand\nCUBLAS_DIAG_NON_UNIT\n, or\nif\nlda\n<\nmax(1,\nn)\nCUBLAS_STATUS_ALLOC_FAILED\nThe allocation of internal scratch memory failed\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nstrmv()\n,\ndtrmv()\n,\nctrmv()\n,\nztrmv()\n2.6.16.\ncublas<t>trsv()\n\ncublasStatus_t\ncublasStrsv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\n*\nx\n,\nint\nincx\n)\ncublasStatus_t\ncublasDtrsv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\n*\nx\n,\nint\nincx\n)\ncublasStatus_t\ncublasCtrsv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\ncuComplex\n*\nx\n,\nint\nincx\n)\ncublasStatus_t\ncublasZtrsv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ncuDoubleComplex\n*\nx\n,\nint\nincx\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function solves the triangular linear system with a single right-hand-side\n\\(\\text{op}(A)\\textbf{x} = \\textbf{b}\\)\nwhere\n\\(A\\)\nis a triangular matrix stored in lower or upper mode with or without the main diagonal, and\n\\(\\mathbf{x}\\)\nand\n\\(\\mathbf{b}\\)\nare vectors. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\nA^{H} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nThe solution\n\\(\\mathbf{x}\\)\noverwrites the right-hand-sides\n\\(\\mathbf{b}\\)\non exit.\nNo test for singularity or near-singularity is included in this function.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other part is not referenced and is inferred from the stored elements.\ntrans\ninput\nOperation op(\nA\n) that is non- or (conj.) transpose.\ndiag\ninput\nIndicates if the elements on the main diagonal of matrix\nA\nare unity and should not be accessed.\nn\ninput\nNumber of rows and columns of matrix\nA\n.\nA\ndevice\ninput\n<\ntype\n> array of dimension\nlda\nx\nn\n, with\nlda\n>=\nmax(1,\nn)\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nx\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\n, or\nif\nincx\n==\n0\n, or\nif\ntrans\nis not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\nand\nCUBLAS_OP_C\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\ndiag\nis not one of\nCUBLAS_DIAG_UNIT\nand\nCUBLAS_DIAG_NON_UNIT\n, or\nif\nlda\n<\nmax(1,\nn)\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nstrsv()\n,\ndtrsv()\n,\nctrsv()\n,\nztrsv()\n2.6.17.\ncublas<t>hemv()\n\ncublasStatus_t\ncublasChemv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\ny\n,\nint\nincy\n)\ncublasStatus_t\ncublasZhemv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\ny\n,\nint\nincy\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the Hermitian matrix-vector multiplication\n\\(\\textbf{y} = \\alpha A\\textbf{x} + \\beta\\textbf{y}\\)\nwhere\n\\(A\\)\nis a\n\\(n \\times n\\)\nHermitian matrix stored in lower or upper mode,\n\\(\\mathbf{x}\\)\nand\n\\(\\mathbf{y}\\)\nare vectors, and\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars.\nThis function has an alternate faster implementation using atomics that can be enabled with\nPlease see the section on the for more details about the usage of atomics\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other Hermitian part is not referenced and is inferred from the stored elements.\nn\ninput\nNumber of rows and columns of matrix\nA\n.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nA\ndevice\ninput\n<\ntype\n> array of dimension\nlda\nx\nn\n, with\nlda\n>=\nmax(1,\nn)\n. The imaginary parts of the diagonal elements are assumed to be zero.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nx\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\nbeta\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\nthen\ny\ndoes not have to be a valid input.\ny\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nincy\ninput\nStride between consecutive elements of\ny\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\n, or\nif\nincx\n==\n0\nor\nincy\n==\n0\n, or\nif\nuplo\n!=\nCUBLAS_FILL_MODE_LOWER\nand\nuplo\n!=\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nlda\n<\nn\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nchemv()\n,\nzhemv()\n2.6.18.\ncublas<t>hbmv()\n\ncublasStatus_t\ncublasChbmv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nint\nk\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\ny\n,\nint\nincy\n)\ncublasStatus_t\ncublasZhbmv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nint\nk\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\ny\n,\nint\nincy\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the Hermitian banded matrix-vector multiplication\n\\(\\textbf{y} = \\alpha A\\textbf{x} + \\beta\\textbf{y}\\)\nwhere\n\\(A\\)\nis a\n\\(n \\times n\\)\nHermitian banded matrix with\n\\(k\\)\nsubdiagonals and superdiagonals,\n\\(\\mathbf{x}\\)\nand\n\\(\\mathbf{y}\\)\nare vectors, and\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_LOWER\nthen the Hermitian banded matrix\n\\(A\\)\nis stored column by column, with the main diagonal of the matrix stored in row\n1\n, the first subdiagonal in row\n2\n(starting at first position), the second subdiagonal in row\n3\n(starting at first position), etc. So that in general, the element\n\\(A(i,j)\\)\nis stored in the memory location\nA(1+i-j,j)\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\in \\lbrack j,\\min(m,j + k)\\rbrack\\)\n. Also, the elements in the array\nA\nthat do not conceptually correspond to the elements in the banded matrix (the bottom right\n\\(k \\times k\\)\ntriangle) are not referenced.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_UPPER\nthen the Hermitian banded matrix\n\\(A\\)\nis stored column by column, with the main diagonal of the matrix stored in row\nk\n+\n1\n, the first superdiagonal in row\nk\n(starting at second position), the second superdiagonal in row\nk-1\n(starting at third position), etc. So that in general, the element\n\\(A(i,j)\\)\nis stored in the memory location\nA(1+k+i-j,j)\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\in \\lbrack\\max(1,j - k),j\\rbrack\\)\n. Also, the elements in the array\nA\nthat do not conceptually correspond to the elements in the banded matrix (the top left\n\\(k \\times k\\)\ntriangle) are not referenced.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other Hermitian part is not referenced and is inferred from the stored elements.\nn\ninput\nNumber of rows and columns of matrix\nA\n.\nk\ninput\nNumber of sub- and super-diagonals of matrix\nA\n.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nA\ndevice\ninput\n<\ntype\n> array of dimensions\nlda\nx\nn\n, with\nlda\n>=\nk\n+\n1\n. The imaginary parts of the diagonal elements are assumed to be zero.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nx\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\nbeta\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\nthen does not have to be a valid input.\ny\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nincy\ninput\nStride between consecutive elements of\ny\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\nor\nk\n<\n0\n, or\nif\nincx\n==\n0\nor\nincy\n==\n0\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nlda\n<\n(1\n+\nk)\n, or\nif\nalpha\nor\nbeta\nare NULL\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nchbmv()\n,\nzhbmv()\n2.6.19.\ncublas<t>hpmv()\n\ncublasStatus_t\ncublasChpmv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nAP\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\ny\n,\nint\nincy\n)\ncublasStatus_t\ncublasZhpmv\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nAP\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\ny\n,\nint\nincy\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the Hermitian packed matrix-vector multiplication\n\\(\\textbf{y} = \\alpha A\\textbf{x} + \\beta\\textbf{y}\\)\nwhere\n\\(A\\)\nis a\n\\(n \\times n\\)\nHermitian matrix stored in packed format,\n\\(\\mathbf{x}\\)\nand\n\\(\\mathbf{y}\\)\nare vectors, and\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_LOWER\nthen the elements in the lower triangular part of the Hermitian matrix\n\\(A\\)\nare packed together column by column without gaps, so that the element\n\\(A(i,j)\\)\nis stored in the memory location\nAP[i+((2*n-j+1)*j)/2]\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\geq j\\)\n. Consequently, the packed format requires only\n\\(\\frac{n(n + 1)}{2}\\)\nelements for storage.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_UPPER\nthen the elements in the upper triangular part of the Hermitian matrix\n\\(A\\)\nare packed together column by column without gaps, so that the element\n\\(A(i,j)\\)\nis stored in the memory location\nAP[i+(j*(j+1))/2]\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\leq j\\)\n. Consequently, the packed format requires only\n\\(\\frac{n(n + 1)}{2}\\)\nelements for storage.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other Hermitian part is not referenced and is inferred from the stored elements.\nn\ninput\nNumber of rows and columns of matrix\nA\n.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nAP\ndevice\ninput\n<\ntype\n> array with\n\\(A\\)\nstored in packed format. The imaginary parts of the diagonal elements are assumed to be zero.\nx\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\nbeta\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\nthen\ny\ndoes not have to be a valid input.\ny\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nincy\ninput\nStride between consecutive elements of\ny\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\n, or\nif\nincx\n==\n0\nor\nincy\n==\n0\n, or\nif\nuplo\n!=\nCUBLAS_FILL_MODE_LOWER\nand\nuplo\n!=\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nalpha\nor\nbeta\nare NULL\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nchpmv()\n,\nzhpmv()\n2.6.20.\ncublas<t>her()\n\ncublasStatus_t\ncublasCher\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\ncuComplex\n*\nA\n,\nint\nlda\n)\ncublasStatus_t\ncublasZher\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the Hermitian rank-1 update\n\\(A = \\alpha\\textbf{x}\\textbf{x}^{H} + A\\)\nwhere\n\\(A\\)\nis a\n\\(n \\times n\\)\nHermitian matrix stored in column-major format,\n\\(\\mathbf{x}\\)\nis a vector, and\n\\(\\alpha\\)\nis a scalar.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other Hermitian part is not referenced and is inferred from the stored elements.\nn\ninput\nNumber of rows and columns of matrix\nA\n.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nx\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\nA\ndevice\nin/out\n<\ntype\n> array of dimensions\nlda\nx\nn\n, with\nlda\n>=\nmax(1,\nn)\n. The imaginary parts of the diagonal elements are assumed and set to zero.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\n, or\nif\nincx\n==\n0\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nlda\n<\nmax(1,\nn)\n, or\nif\nalpha\nis NULL\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\ncher()\n,\nzher()\n2.6.21.\ncublas<t>her2()\n\ncublasStatus_t\ncublasCher2\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuComplex\n*\ny\n,\nint\nincy\n,\ncuComplex\n*\nA\n,\nint\nlda\n)\ncublasStatus_t\ncublasZher2\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuDoubleComplex\n*\ny\n,\nint\nincy\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the Hermitian rank-2 update\n\\(A = \\alpha\\textbf{x}\\textbf{y}^{H} + \\overset{ˉ}{\\alpha}\\textbf{y}\\textbf{x}^{H} + A\\)\nwhere\n\\(A\\)\nis a\n\\(n \\times n\\)\nHermitian matrix stored in column-major format,\n\\(\\mathbf{x}\\)\nand\n\\(\\mathbf{y}\\)\nare vectors, and\n\\(\\alpha\\)\nis a scalar.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other Hermitian part is not referenced and is inferred from the stored elements.\nn\ninput\nNumber of rows and columns of matrix\nA\n.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nx\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\ny\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincy\ninput\nStride between consecutive elements of\ny\n.\nA\ndevice\nin/out\n<\ntype\n> array of dimension\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nn)\n. The imaginary parts of the diagonal elements are assumed and set to zero.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\n, or\nif\nincx\n==\n0\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nlda\n<\nmax(1,\nn)\n, or\nif\nalpha\nis NULL\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\ncher2()\n,\nzher2()\n2.6.22.\ncublas<t>hpr()\n\ncublasStatus_t\ncublasChpr\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\ncuComplex\n*\nAP\n)\ncublasStatus_t\ncublasZhpr\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\ncuDoubleComplex\n*\nAP\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the packed Hermitian rank-1 update\n\\(A = \\alpha\\textbf{x}\\textbf{x}^{H} + A\\)\nwhere\n\\(A\\)\nis a\n\\(n \\times n\\)\nHermitian matrix stored in packed format,\n\\(\\mathbf{x}\\)\nis a vector, and\n\\(\\alpha\\)\nis a scalar.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_LOWER\nthen the elements in the lower triangular part of the Hermitian matrix\n\\(A\\)\nare packed together column by column without gaps, so that the element\n\\(A(i,j)\\)\nis stored in the memory location\nAP[i+((2*n-j+1)*j)/2]\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\geq j\\)\n. Consequently, the packed format requires only\n\\(\\frac{n(n + 1)}{2}\\)\nelements for storage.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_UPPER\nthen the elements in the upper triangular part of the Hermitian matrix\n\\(A\\)\nare packed together column by column without gaps, so that the element\n\\(A(i,j)\\)\nis stored in the memory location\nAP[i+(j*(j+1))/2]\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\leq j\\)\n. Consequently, the packed format requires only\n\\(\\frac{n(n + 1)}{2}\\)\nelements for storage.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other Hermitian part is not referenced and is inferred from the stored elements.\nn\ninput\nNumber of rows and columns of matrix\nA\n.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nx\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\nAP\ndevice\nin/out\n<\ntype\n> array with\n\\(A\\)\nstored in packed format. The imaginary parts of the diagonal elements are assumed and set to zero.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\n, or\nif\nincx\n==\n0\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nalpha\nis NULL\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nchpr()\n,\nzhpr()\n2.6.23.\ncublas<t>hpr2()\n\ncublasStatus_t\ncublasChpr2\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuComplex\n*\ny\n,\nint\nincy\n,\ncuComplex\n*\nAP\n)\ncublasStatus_t\ncublasZhpr2\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\nconst\ncuDoubleComplex\n*\ny\n,\nint\nincy\n,\ncuDoubleComplex\n*\nAP\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the packed Hermitian rank-2 update\n\\(A = \\alpha\\textbf{x}\\textbf{y}^{H} + \\overset{ˉ}{\\alpha}\\textbf{y}\\textbf{x}^{H} + A\\)\nwhere\n\\(A\\)\nis a\n\\(n \\times n\\)\nHermitian matrix stored in packed format,\n\\(\\mathbf{x}\\)\nand\n\\(\\mathbf{y}\\)\nare vectors, and\n\\(\\alpha\\)\nis a scalar.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_LOWER\nthen the elements in the lower triangular part of the Hermitian matrix\n\\(A\\)\nare packed together column by column without gaps, so that the element\n\\(A(i,j)\\)\nis stored in the memory location\nAP[i+((2*n-j+1)*j)/2]\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\geq j\\)\n. Consequently, the packed format requires only\n\\(\\frac{n(n + 1)}{2}\\)\nelements for storage.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_UPPER\nthen the elements in the upper triangular part of the Hermitian matrix\n\\(A\\)\nare packed together column by column without gaps, so that the element\n\\(A(i,j)\\)\nis stored in the memory location\nAP[i+(j*(j+1))/2]\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\leq j\\)\n. Consequently, the packed format requires only\n\\(\\frac{n(n + 1)}{2}\\)\nelements for storage.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other Hermitian part is not referenced and is inferred from the stored elements.\nn\ninput\nNumber of rows and columns of matrix\nA\n.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nx\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincx\ninput\nStride between consecutive elements of\nx\n.\ny\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nincy\ninput\nStride between consecutive elements of\ny\n.\nAP\ndevice\nin/out\n<\ntype\n> array with\n\\(A\\)\nstored in packed format. The imaginary parts of the diagonal elements are assumed and set to zero.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\n, or\nif\nincx\n==\n0\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nalpha\nis NULL\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nchpr2, zhpr2\n2.6.24.\ncublas<t>gemvBatched()\n\ncublasStatus_t\ncublasSgemvBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nconst\nAarray\n[],\nint\nlda\n,\nconst\nfloat\n*\nconst\nxarray\n[],\nint\nincx\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\nconst\nyarray\n[],\nint\nincy\n,\nint\nbatchCount\n)\ncublasStatus_t\ncublasDgemvBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nconst\nAarray\n[],\nint\nlda\n,\nconst\ndouble\n*\nconst\nxarray\n[],\nint\nincx\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\nconst\nyarray\n[],\nint\nincy\n,\nint\nbatchCount\n)\ncublasStatus_t\ncublasCgemvBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nconst\nAarray\n[],\nint\nlda\n,\nconst\ncuComplex\n*\nconst\nxarray\n[],\nint\nincx\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\nconst\nyarray\n[],\nint\nincy\n,\nint\nbatchCount\n)\ncublasStatus_t\ncublasZgemvBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nconst\nAarray\n[],\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nconst\nxarray\n[],\nint\nincx\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\nconst\nyarray\n[],\nint\nincy\n,\nint\nbatchCount\n)\n#if defined(__cplusplus)\ncublasStatus_t\ncublasHSHgemvBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\n__half\n*\nconst\nAarray\n[],\nint\nlda\n,\nconst\n__half\n*\nconst\nxarray\n[],\nint\nincx\n,\nconst\nfloat\n*\nbeta\n,\n__half\n*\nconst\nyarray\n[],\nint\nincy\n,\nint\nbatchCount\n)\ncublasStatus_t\ncublasHSSgemvBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\n__half\n*\nconst\nAarray\n[],\nint\nlda\n,\nconst\n__half\n*\nconst\nxarray\n[],\nint\nincx\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\nconst\nyarray\n[],\nint\nincy\n,\nint\nbatchCount\n)\ncublasStatus_t\ncublasTSTgemvBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\n__nv_bfloat16\n*\nconst\nAarray\n[],\nint\nlda\n,\nconst\n__nv_bfloat16\n*\nconst\nxarray\n[],\nint\nincx\n,\nconst\nfloat\n*\nbeta\n,\n__nv_bfloat16\n*\nconst\nyarray\n[],\nint\nincy\n,\nint\nbatchCount\n)\ncublasStatus_t\ncublasTSSgemvBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\n__nv_bfloat16\n*\nconst\nAarray\n[],\nint\nlda\n,\nconst\n__nv_bfloat16\n*\nconst\nxarray\n[],\nint\nincx\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\nconst\nyarray\n[],\nint\nincy\n,\nint\nbatchCount\n)\n#endif\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the matrix-vector multiplication of a batch of matrices and vectors. The batch is considered to be “uniform”, i.e. all instances have the same dimensions (m, n), leading dimension (lda), increments (incx, incy) and transposition (trans) for their respective A matrix, x and y vectors. The address of the input matrix and vector, and the output vector of each instance of the batch are read from arrays of pointers passed to the function by the caller.\n\\(\\textbf{y}\\lbrack i\\rbrack = \\alpha\\text{op}(A\\lbrack i\\rbrack)\\textbf{x}\\lbrack i\\rbrack + \\beta\\textbf{y}\\lbrack i\\rbrack,\\text{ for i} \\in \\lbrack 0,batchCount - 1\\rbrack\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars, and\n\\(A\\)\nis an array of pointers to matrice\n\\(A\\lbrack i\\rbrack\\)\nstored in column-major format with dimension\n\\(m \\times n\\)\n, and\n\\(\\textbf{x}\\)\nand\n\\(\\textbf{y}\\)\nare arrays of pointers to vectors. Also, for matrix\n\\(A\\lbrack i\\rbrack\\)\n,\n\\(\\text{op}(A\\lbrack i\\rbrack) = \\left\\{ \\begin{matrix}\n{A\\lbrack i\\rbrack} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\n{A\\lbrack i\\rbrack}^{T} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\n{A\\lbrack i\\rbrack}^{H} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nNote\n\\(\\textbf{y}\\lbrack i\\rbrack\\)\nvectors must not overlap, i.e. the individual gemv operations must be computable independently; otherwise, undefined behavior is expected.\nOn certain problem sizes, it might be advantageous to make multiple calls to\ncublas<t>gemv()\nin different CUDA streams, rather than use this API.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\ntrans\ninput\nOperation op(\nA[i]\n) that is non- or (conj.) transpose.\nm\ninput\nNumber of rows of matrix\nA[i]\n.\nn\ninput\nNumber of columns of matrix\nA[i]\n.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nAarray\ndevice\ninput\nArray of pointers to <\ntype\n> array, with each array of dim.\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nm)\n.\nAll pointers must meet certain alignment criteria. Please see below for details.\nlda\ninput\nLeading dimension of two-dimensional array used to store each matrix\nA[i]\n.\nxarray\ndevice\ninput\nArray of pointers to <\ntype\n> array, with each dimension\nn\nif\ntrans\n==\nCUBLAS_OP_N\nand\nm\notherwise.\nAll pointers must meet certain alignment criteria. Please see below for details.\nincx\ninput\nStride of each one-dimensional array x[i].\nbeta\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\n,\ny\ndoes not have to be a valid input.\nyarray\ndevice\nin/out\nArray of pointers to <\ntype\n> array. It has dimensions\nm\nif\ntrans\n==\nCUBLAS_OP_N\nand\nn\notherwise. Vectors\ny[i]\nshould not overlap; otherwise, undefined behavior is expected.\nAll pointers must meet certain alignment criteria. Please see below for details.\nincy\ninput\nStride of each one-dimensional array y[i].\nbatchCount\ninput\nNumber of pointers contained in Aarray, xarray and yarray.\nIf math mode enables fast math modes when using\ncublasSgemvBatched()\n, pointers (not the pointer arrays) placed in the GPU memory must be properly aligned to avoid misaligned memory access errors. Ideally all pointers are aligned to at least 16 Bytes. Otherwise it is recommended that they meet the following rule:\nif\nk\n%\n4\n==\n0\nthen ensure\nintptr_t(ptr)\n%\n16\n==\n0\n,\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nm\n<\n0\n,\nn\n<\n0\n, or\nbatchCount\n<\n0\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\n2.6.25.\ncublas<t>gemvStridedBatched()\n\ncublasStatus_t\ncublasSgemvStridedBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\nconst\nfloat\n*\nx\n,\nint\nincx\n,\nlong\nlong\nint\nstridex\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\ny\n,\nint\nincy\n,\nlong\nlong\nint\nstridey\n,\nint\nbatchCount\n)\ncublasStatus_t\ncublasDgemvStridedBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\nconst\ndouble\n*\nx\n,\nint\nincx\n,\nlong\nlong\nint\nstridex\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\ny\n,\nint\nincy\n,\nlong\nlong\nint\nstridey\n,\nint\nbatchCount\n)\ncublasStatus_t\ncublasCgemvStridedBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\nlong\nlong\nint\nstridex\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\ny\n,\nint\nincy\n,\nlong\nlong\nint\nstridey\n,\nint\nbatchCount\n)\ncublasStatus_t\ncublasZgemvStridedBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\nlong\nlong\nint\nstridex\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\ny\n,\nint\nincy\n,\nlong\nlong\nint\nstridey\n,\nint\nbatchCount\n)\ncublasStatus_t\ncublasHSHgemvStridedBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\n__half\n*\nA\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\nconst\n__half\n*\nx\n,\nint\nincx\n,\nlong\nlong\nint\nstridex\n,\nconst\nfloat\n*\nbeta\n,\n__half\n*\ny\n,\nint\nincy\n,\nlong\nlong\nint\nstridey\n,\nint\nbatchCount\n)\ncublasStatus_t\ncublasHSSgemvStridedBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\n__half\n*\nA\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\nconst\n__half\n*\nx\n,\nint\nincx\n,\nlong\nlong\nint\nstridex\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\ny\n,\nint\nincy\n,\nlong\nlong\nint\nstridey\n,\nint\nbatchCount\n)\ncublasStatus_t\ncublasTSTgemvStridedBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\n__nv_bfloat16\n*\nA\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\nconst\n__nv_bfloat16\n*\nx\n,\nint\nincx\n,\nlong\nlong\nint\nstridex\n,\nconst\nfloat\n*\nbeta\n,\n__nv_bfloat16\n*\ny\n,\nint\nincy\n,\nlong\nlong\nint\nstridey\n,\nint\nbatchCount\n)\ncublasStatus_t\ncublasTSSgemvStridedBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\n__nv_bfloat16\n*\nA\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\nconst\n__nv_bfloat16\n*\nx\n,\nint\nincx\n,\nlong\nlong\nint\nstridex\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\ny\n,\nint\nincy\n,\nlong\nlong\nint\nstridey\n,\nint\nbatchCount\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the matrix-vector multiplication of a batch of matrices and vectors. The batch is considered to be “uniform”, i.e. all instances have the same dimensions (m, n), leading dimension (lda), increments (incx, incy) and transposition (trans) for their respective A matrix, x and y vectors. Input matrix A and vector x, and output vector y for each instance of the batch are located at fixed offsets in number of elements from their locations in the previous instance. Pointers to A matrix, x and y vectors for the first instance are passed to the function by the user along with offsets in number of elements - strideA, stridex and stridey that determine the locations of input matrices and vectors, and output vectors in future instances.\n\\(\\textbf{y} + i*{stridey} = \\alpha\\text{op}(A + i*{strideA})(\\textbf{x} + i*{stridex}) + \\beta(\\textbf{y} + i*{stridey}),\\text{ for i } \\in \\lbrack 0,batchCount - 1\\rbrack\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars, and\n\\(A\\)\nis an array of pointers to matrix stored in column-major format with dimension\n\\(A\\lbrack i\\rbrack\\)\n\\(m \\times n\\)\n, and\n\\(\\textbf{x}\\)\nand\n\\(\\textbf{y}\\)\nare arrays of pointers to vectors. Also, for matrix\n\\(A\\lbrack i\\rbrack\\)\n\\(\\text{op}(A\\lbrack i\\rbrack) = \\left\\{ \\begin{matrix}\n{A\\lbrack i\\rbrack} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\n{A\\lbrack i\\rbrack}^{T} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\n{A\\lbrack i\\rbrack}^{H} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nNote\n\\(\\textbf{y}\\lbrack i\\rbrack\\)\nmatrices must not overlap, i.e. the individual gemv operations must be computable independently; otherwise, undefined behavior is expected.\nOn certain problem sizes, it might be advantageous to make multiple calls to\ncublas<t>gemv()\nin different CUDA streams, rather than use this API.\nNote\nIn the table below, we use\nA[i],\nx[i],\ny[i]\nas notation for A matrix, and x and y vectors in the ith instance of the batch, implicitly assuming they are respectively offsets in number of elements\nstrideA,\nstridex,\nstridey\naway from\nA[i-1],\nx[i-1],\ny[i-1]\n. The unit for the offset is number of elements and must not be zero .\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\ntrans\ninput\nOperation op(\nA[i]\n) that is non- or (conj.) transpose.\nm\ninput\nNumber of rows of matrix\nA[i]\n.\nn\ninput\nNumber of columns of matrix\nA[i]\n.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nA\ndevice\ninput\n<\ntype\n>* pointer to the A matrix corresponding to the first instance of the batch, with dimensions\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nm)\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store each matrix\nA[i]\n.\nstrideA\ninput\nValue of type long long int that gives the offset in number of elements between\nA[i]\nand\nA[i+1]\nx\ndevice\ninput\n<\ntype\n>* pointer to the x vector corresponding to the first instance of the batch, with each dimension\nn\nif\ntrans\n==\nCUBLAS_OP_N\nand\nm\notherwise.\nincx\ninput\nStride of each one-dimensional array\nx[i]\n.\nstridex\ninput\nValue of type long long int that gives the offset in number of elements between\nx[i]\nand\nx[i+1]\nbeta\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\n,\ny\ndoes not have to be a valid input.\ny\ndevice\nin/out\n<\ntype\n>* pointer to the y vector corresponding to the first instance of the batch, with each dimension\nm\nif\ntrans\n==\nCUBLAS_OP_N\nand\nn\notherwise. Vectors\ny[i]\nshould not overlap; otherwise, undefined behavior is expected.\nincy\ninput\nStride of each one-dimensional array\ny[i]\n.\nstridey\ninput\nValue of type long long int that gives the offset in number of elements between\ny[i]\nand\ny[i+1]\nbatchCount\ninput\nNumber of GEMVs to perform in the batch.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nm\n<\n0\n,\nn\n<\n0\n, or\nbatchCount\n<\n0\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\n2.7.\ncuBLAS Level-3 Function Reference\n\nIn this chapter we describe the Level-3 Basic Linear Algebra Subprograms (BLAS3) functions that perform matrix-matrix operations.\n2.7.1.\ncublas<t>gemm()\n\ncublasStatus_t\ncublasSgemm\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nB\n,\nint\nldb\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasDgemm\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nB\n,\nint\nldb\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasCgemm\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\nB\n,\nint\nldb\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasZgemm\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasHgemm\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\n__half\n*\nalpha\n,\nconst\n__half\n*\nA\n,\nint\nlda\n,\nconst\n__half\n*\nB\n,\nint\nldb\n,\nconst\n__half\n*\nbeta\n,\n__half\n*\nC\n,\nint\nldc\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the matrix-matrix multiplication\n\\(C = \\alpha\\text{op}(A)\\text{op}(B) + \\beta C\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars, and\n\\(A\\)\n,\n\\(B\\)\nand\n\\(C\\)\nare matrices stored in column-major format with dimensions\n\\(\\text{op}(A)\\)\n\\(m \\times k\\)\n,\n\\(\\text{op}(B)\\)\n\\(k \\times n\\)\nand\n\\(C\\)\n\\(m \\times n\\)\n, respectively. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\nA^{H} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nand\n\\(\\text{op}(B)\\)\nis defined similarly for matrix\n\\(B\\)\n.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\ntransa\ninput\nOperation op(\nA\n) that is non- or (conj.) transpose.\ntransb\ninput\nOperation op(\nB\n) that is non- or (conj.) transpose.\nm\ninput\nNumber of rows of matrix op(\nA\n) and\nC\n.\nn\ninput\nNumber of columns of matrix op(\nB\n) and\nC\n.\nk\ninput\nNumber of columns of op(\nA\n) and rows of op(\nB\n).\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nA\ndevice\ninput\n<\ntype\n> array of dimensions\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nm)\nif\ntransa\n==\nCUBLAS_OP_N\nand\nlda\nx\nm\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nlda\ninput\nLeading dimension of two-dimensional array used to store the matrix\nA\n.\nB\ndevice\ninput\n<\ntype\n> array of dimension\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nk)\nif\ntransb\n==\nCUBLAS_OP_N\nand\nldb\nx\nk\nwith\nldb\n>=\nmax(1,n)\notherwise.\nldb\ninput\nLeading dimension of two-dimensional array used to store matrix\nB\n.\nbeta\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\n,\nC\ndoes not have to be a valid input.\nC\ndevice\nin/out\n<\ntype\n> array of dimensions\nldc\nx\nn\nwith\nldc\n>=\nmax(1,\nm)\n.\nldc\ninput\nLeading dimension of a two-dimensional array used to store the matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nm\n<\n0\nor\nn\n<\n0\nor\nk\n<\n0\n, or\nif\ntransa\nand\ntransb\nare not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_C\n,\nCUBLAS_OP_T\n, or\nif\nlda\n<\nmax(1,\nm)\nwhen\ntransa\n==\nCUBLAS_OP_N\nand\nlda\n<\nmax(1,\nk)\notherwise, or\nif\nldb\n<\nmax(1,\nk)\nwhen\ntransb\n==\nCUBLAS_OP_N\nand\nldb\n<\nmax(1,\nn)\notherwise, or\nif\nldc\n<\nmax(1,\nm)\n, or\nif\nalpha\nor\nbeta\nare NULL, or\nif\nC\nis NULL when\nbeta\nis not zero\nCUBLAS_STATUS_ARCH_MISMATCH\nIn the case of\ncublasHgemm()\nthe device does not support math in half precision.\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nsgemm()\n,\ndgemm()\n,\ncgemm()\n,\nzgemm()\n2.7.2.\ncublas<t>gemm3m()\n\ncublasStatus_t\ncublasCgemm3m\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\nB\n,\nint\nldb\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasZgemm3m\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\nC\n,\nint\nldc\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the complex matrix-matrix multiplication, using Gauss complexity reduction algorithm. This can lead to an increase in performance up to 25%\n\\(C = \\alpha\\text{op}(A)\\text{op}(B) + \\beta C\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars, and\n\\(A\\)\n,\n\\(B\\)\nand\n\\(C\\)\nare matrices stored in column-major format with dimensions\n\\(\\text{op}(A)\\)\n\\(m \\times k\\)\n,\n\\(\\text{op}(B)\\)\n\\(k \\times n\\)\nand\n\\(C\\)\n\\(m \\times n\\)\n, respectively. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\nA^{H} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nand\n\\(\\text{op}(B)\\)\nis defined similarly for matrix\n\\(B\\)\n.\nNote\nThese 2 routines are only supported on GPUs with architecture capabilities equal to or greater than 5.0\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\ntransa\ninput\nOperation op(\nA\n) that is non- or (conj.) transpose.\ntransb\ninput\nOperation op(\nB\n) that is non- or (conj.) transpose.\nm\ninput\nNumber of rows of matrix op(\nA\n) and\nC\n.\nn\ninput\nNumber of columns of matrix op(\nB\n) and\nC\n.\nk\ninput\nNumber of columns of op(\nA\n) and rows of op(\nB\n).\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nA\ndevice\ninput\n<\ntype\n> array of dimensions\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nm)\nif\ntransa\n==\nCUBLAS_OP_N\nand\nlda\nx\nm\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nlda\ninput\nLeading dimension of two-dimensional array used to store the matrix\nA\n.\nB\ndevice\ninput\n<\ntype\n> array of dimension\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nk)\nif\ntransb\n==\nCUBLAS_OP_N\nand\nldb\nx\nk\nwith\nldb\n>=\nmax(1,n)\notherwise.\nldb\ninput\nLeading dimension of two-dimensional array used to store matrix\nB\n.\nbeta\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\n,\nC\ndoes not have to be a valid input.\nC\ndevice\nin/out\n<\ntype\n> array of dimensions\nldc\nx\nn\nwith\nldc\n>=\nmax(1,\nm)\n.\nldc\ninput\nLeading dimension of a two-dimensional array used to store the matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed in the following table:\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully.\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUBLAS_STATUS_INVALID_VALUE\nIf\nm\n<\n0\nor\nn\n<\n0\nor\nk\n<\n0\n, or\nif\ntransa\nand\ntransb\nare not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_C\n,\nCUBLAS_OP_T\n, or\nif\nlda\n<\nmax(1,\nm)\nwhen\ntransa\n==\nCUBLAS_OP_N\nand\nlda\n<\nmax(1,\nk)\notherwise, or\nif\nldb\n<\nmax(1,\nk)\nwhen\ntransb\n==\nCUBLAS_OP_N\nand\nldb\n<\nmax(1,\nn)\notherwise, or\nif\nldc\n<\nmax(1,\nm)\n, or\nif\nalpha\nor\nbeta\nare NULL, or\nif\nC\nis NULL when\nbeta\nis not zero\nCUBLAS_STATUS_ARCH_MISMATCH\nThe device has a compute capabilites lower than 5.0.\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU.\nFor references please refer to NETLIB documentation:\ncgemm()\n,\nzgemm()\n2.7.3.\ncublas<t>gemmBatched()\n\ncublasStatus_t\ncublasHgemmBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\n__half\n*\nalpha\n,\nconst\n__half\n*\nconst\nAarray\n[],\nint\nlda\n,\nconst\n__half\n*\nconst\nBarray\n[],\nint\nldb\n,\nconst\n__half\n*\nbeta\n,\n__half\n*\nconst\nCarray\n[],\nint\nldc\n,\nint\nbatchCount\n)\ncublasStatus_t\ncublasSgemmBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nconst\nAarray\n[],\nint\nlda\n,\nconst\nfloat\n*\nconst\nBarray\n[],\nint\nldb\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\nconst\nCarray\n[],\nint\nldc\n,\nint\nbatchCount\n)\ncublasStatus_t\ncublasDgemmBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nconst\nAarray\n[],\nint\nlda\n,\nconst\ndouble\n*\nconst\nBarray\n[],\nint\nldb\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\nconst\nCarray\n[],\nint\nldc\n,\nint\nbatchCount\n)\ncublasStatus_t\ncublasCgemmBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nconst\nAarray\n[],\nint\nlda\n,\nconst\ncuComplex\n*\nconst\nBarray\n[],\nint\nldb\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\nconst\nCarray\n[],\nint\nldc\n,\nint\nbatchCount\n)\ncublasStatus_t\ncublasZgemmBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nconst\nAarray\n[],\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nconst\nBarray\n[],\nint\nldb\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\nconst\nCarray\n[],\nint\nldc\n,\nint\nbatchCount\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the matrix-matrix multiplication of a batch of matrices. The batch is considered to be “uniform”, i.e. all instances have the same dimensions (m, n, k), leading dimensions (lda, ldb, ldc) and transpositions (transa, transb) for their respective A, B and C matrices. The address of the input matrices and the output matrix of each instance of the batch are read from arrays of pointers passed to the function by the caller.\n\\(C\\lbrack i\\rbrack = \\alpha\\text{op}(A\\lbrack i\\rbrack)\\text{op}(B\\lbrack i\\rbrack) + \\beta C\\lbrack i\\rbrack,\\text{ for i } \\in \\lbrack 0,batchCount - 1\\rbrack\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars, and\n\\(A\\)\n,\n\\(B\\)\nand\n\\(C\\)\nare arrays of pointers to matrices stored in column-major format with dimensions\n\\(\\text{op}(A\\lbrack i\\rbrack)\\)\n\\(m \\times k\\)\n,\n\\(\\text{op}(B\\lbrack i\\rbrack)\\)\n\\(k \\times n\\)\nand\n\\(C\\lbrack i\\rbrack\\)\n\\(m \\times n\\)\n, respectively. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\nA^{H} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nand\n\\(\\text{op}(B\\lbrack i\\rbrack)\\)\nis defined similarly for matrix\n\\(B\\lbrack i\\rbrack\\)\n.\nNote\n\\(C\\lbrack i\\rbrack\\)\nmatrices must not overlap, that is, the individual gemm operations must be computable independently; otherwise, undefined behavior is expected.\nOn certain problem sizes, it might be advantageous to make multiple calls to\ncublas<t>gemm()\nin different CUDA streams, rather than use this API.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\ntransa\ninput\nOperation op(\nA[i]\n) that is non- or (conj.) transpose.\ntransb\ninput\nOperation op(\nB[i]\n) that is non- or (conj.) transpose.\nm\ninput\nNumber of rows of matrix op(\nA[i]\n) and\nC[i]\n.\nn\ninput\nNumber of columns of op(\nB[i]\n) and\nC[i]\n.\nk\ninput\nNumber of columns of op(\nA[i]\n) and rows of op(\nB[i]\n).\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nAarray\ndevice\ninput\nArray of pointers to <\ntype\n> array, with each array of dim.\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nm)\nif\ntransa\n==\nCUBLAS_OP_N\nand\nlda\nx\nm\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nAll pointers must meet certain alignment criteria. Please see below for details.\nlda\ninput\nLeading dimension of two-dimensional array used to store each matrix\nA[i]\n.\nBarray\ndevice\ninput\nArray of pointers to <\ntype\n> array, with each array of dim.\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nk)\nif\ntransb\n==\nCUBLAS_OP_N\nand\nldb\nx\nk\nwith\nldb\n>=\nmax(1,n)\notherwise.\nAll pointers must meet certain alignment criteria. Please see below for details.\nldb\ninput\nLeading dimension of two-dimensional array used to store each matrix\nB[i]\n.\nbeta\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\n,\nC\ndoes not have to be a valid input.\nCarray\ndevice\nin/out\nArray of pointers to <\ntype\n> array. It has dimensions\nldc\nx\nn\nwith\nldc\n>=\nmax(1,\nm)\n. Matrices\nC[i]\nshould not overlap; otherwise, undefined behavior is expected.\nAll pointers must meet certain alignment criteria. Please see below for details.\nldc\ninput\nLeading dimension of two-dimensional array used to store each matrix\nC[i]\n.\nbatchCount\ninput\nNumber of pointers contained in Aarray, Barray and Carray.\nIf math mode enables fast math modes when using\ncublasSgemmBatched()\n, pointers (not the pointer arrays) placed in the GPU memory must be properly aligned to avoid misaligned memory access errors. Ideally all pointers are aligned to at least 16 Bytes. Otherwise it is recommended that they meet the following rule:\nif\nk\n%\n4\n==\n0\nthen ensure\nintptr_t(ptr)\n%\n16\n==\n0\n,\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nm\n<\n0\nor\nn\n<\n0\nor\nk\n<\n0\n, or\nif\ntransa\nand\ntransb\nare not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_C\n,\nCUBLAS_OP_T\n, or\nif\nlda\n<\nmax(1,\nm)\nwhen\ntransa\n==\nCUBLAS_OP_N\nand\nlda\n<\nmax(1,\nk)\notherwise, or\nif\nldb\n<\nmax(1,\nk)\nwhen\ntransb\n==\nCUBLAS_OP_N\nand\nldb\n<\nmax(1,\nn)\notherwise, or\nif\nldc\n<\nmax(1,\nm)\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nCUBLAS_STATUS_ARCH_MISMATCH\ncublasHgemmBatched()\nis only supported for GPU with architecture capabilities equal or greater than 5.3\n2.7.4.\ncublas<t>gemmStridedBatched()\n\ncublasStatus_t\ncublasHgemmStridedBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\n__half\n*\nalpha\n,\nconst\n__half\n*\nA\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\nconst\n__half\n*\nB\n,\nint\nldb\n,\nlong\nlong\nint\nstrideB\n,\nconst\n__half\n*\nbeta\n,\n__half\n*\nC\n,\nint\nldc\n,\nlong\nlong\nint\nstrideC\n,\nint\nbatchCount\n)\ncublasStatus_t\ncublasSgemmStridedBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\nconst\nfloat\n*\nB\n,\nint\nldb\n,\nlong\nlong\nint\nstrideB\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\nC\n,\nint\nldc\n,\nlong\nlong\nint\nstrideC\n,\nint\nbatchCount\n)\ncublasStatus_t\ncublasDgemmStridedBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\nconst\ndouble\n*\nB\n,\nint\nldb\n,\nlong\nlong\nint\nstrideB\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\nC\n,\nint\nldc\n,\nlong\nlong\nint\nstrideC\n,\nint\nbatchCount\n)\ncublasStatus_t\ncublasCgemmStridedBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\nconst\ncuComplex\n*\nB\n,\nint\nldb\n,\nlong\nlong\nint\nstrideB\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\nC\n,\nint\nldc\n,\nlong\nlong\nint\nstrideC\n,\nint\nbatchCount\n)\ncublasStatus_t\ncublasCgemm3mStridedBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\nconst\ncuComplex\n*\nB\n,\nint\nldb\n,\nlong\nlong\nint\nstrideB\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\nC\n,\nint\nldc\n,\nlong\nlong\nint\nstrideC\n,\nint\nbatchCount\n)\ncublasStatus_t\ncublasZgemmStridedBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\nconst\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\nlong\nlong\nint\nstrideB\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\nC\n,\nint\nldc\n,\nlong\nlong\nint\nstrideC\n,\nint\nbatchCount\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the matrix-matrix multiplication of a batch of matrices. The batch is considered to be “uniform”, i.e. all instances have the same dimensions (m, n, k), leading dimensions (lda, ldb, ldc) and transpositions (transa, transb) for their respective A, B and C matrices. Input matrices A, B and output matrix C for each instance of the batch are located at fixed offsets in number of elements from their locations in the previous instance. Pointers to A, B and C matrices for the first instance are passed to the function by the user along with offsets in number of elements - strideA, strideB and strideC that determine the locations of input and output matrices in future instances.\n\\(C + i*{strideC} = \\alpha\\text{op}(A + i*{strideA})\\text{op}(B + i*{strideB}) + \\beta(C + i*{strideC}),\\text{ for i } \\in \\lbrack 0,batchCount - 1\\rbrack\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars, and\n\\(A\\)\n,\n\\(B\\)\nand\n\\(C\\)\nare arrays of pointers to matrices stored in column-major format with dimensions\n\\(\\text{op}(A\\lbrack i\\rbrack)\\)\n\\(m \\times k\\)\n,\n\\(\\text{op}(B\\lbrack i\\rbrack)\\)\n\\(k \\times n\\)\nand\n\\(C\\lbrack i\\rbrack\\)\n\\(m \\times n\\)\n, respectively. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\nA^{H} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nand\n\\(\\text{op}(B\\lbrack i\\rbrack)\\)\nis defined similarly for matrix\n\\(B\\lbrack i\\rbrack\\)\n.\nNote\n\\(C\\lbrack i\\rbrack\\)\nmatrices must not overlap, i.e. the individual gemm operations must be computable independently; otherwise, undefined behavior is expected.\nOn certain problem sizes, it might be advantageous to make multiple calls to\ncublas<t>gemm()\nin different CUDA streams, rather than use this API.\nNote\nIn the table below, we use\nA[i],\nB[i],\nC[i]\nas notation for A, B and C matrices in the ith instance of the batch, implicitly assuming they are respectively offsets in number of elements\nstrideA,\nstrideB,\nstrideC\naway from\nA[i-1],\nB[i-1],\nC[i-1]\n. The unit for the offset is number of elements and must not be zero .\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\ntransa\ninput\nOperation op(\nA[i]\n) that is non- or (conj.) transpose.\ntransb\ninput\nOperation op(\nB[i]\n) that is non- or (conj.) transpose.\nm\ninput\nNumber of rows of matrix op(\nA[i]\n) and\nC[i]\n.\nn\ninput\nNumber of columns of op(\nB[i]\n) and\nC[i]\n.\nk\ninput\nNumber of columns of op(\nA[i]\n) and rows of op(\nB[i]\n).\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nA\ndevice\ninput\n<\ntype\n>* pointer to the A matrix corresponding to the first instance of the batch, with dimensions\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nm)\nif\ntransa\n==\nCUBLAS_OP_N\nand\nlda\nx\nm\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nlda\ninput\nLeading dimension of two-dimensional array used to store each matrix\nA[i]\n.\nstrideA\ninput\nValue of type long long int that gives the offset in number of elements between\nA[i]\nand\nA[i+1]\nB\ndevice\ninput\n<\ntype\n>* pointer to the B matrix corresponding to the first instance of the batch, with dimensions\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nk)\nif\ntransb\n==\nCUBLAS_OP_N\nand\nldb\nx\nk\nwith\nldb\n>=\nmax(1,n)\notherwise.\nldb\ninput\nLeading dimension of two-dimensional array used to store each matrix\nB[i]\n.\nstrideB\ninput\nValue of type long long int that gives the offset in number of elements between\nB[i]\nand\nB[i+1]\nbeta\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\n,\nC\ndoes not have to be a valid input.\nC\ndevice\nin/out\n<\ntype\n>* pointer to the C matrix corresponding to the first instance of the batch, with dimensions\nldc\nx\nn\nwith\nldc\n>=\nmax(1,\nm)\n. Matrices\nC[i]\nshould not overlap; otherwise, undefined behavior is expected.\nldc\ninput\nLeading dimension of two-dimensional array used to store each matrix\nC[i]\n.\nstrideC\ninput\nValue of type long long int that gives the offset in number of elements between\nC[i]\nand\nC[i+1]\nbatchCount\ninput\nNumber of GEMMs to perform in the batch.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nm\n<\n0\nor\nn\n<\n0\nor\nk\n<\n0\n, or\nif\ntransa\nand\ntransb\nare not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_C\n,\nCUBLAS_OP_T\n, or\nif\nlda\n<\nmax(1,\nm)\nwhen\ntransa\n==\nCUBLAS_OP_N\nand\nlda\n<\nmax(1,\nk)\notherwise, or\nif\nldb\n<\nmax(1,\nk)\nwhen\ntransb\n==\nCUBLAS_OP_N\nand\nldb\n<\nmax(1,\nn)\notherwise, or\nif\nldc\n<\nmax(1,\nm)\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nCUBLAS_STATUS_ARCH_MISMATCH\ncublasHgemmStridedBatched()\nis only supported for GPU with architecture capabilities equal or greater than 5.3\n2.7.5.\ncublas<t>gemmGroupedBatched()\n\ncublasStatus_t\ncublasSgemmGroupedBatched\n(\ncublasHandle_t\nhandle\n,\nconst\ncublasOperation_t\ntransa_array\n[],\nconst\ncublasOperation_t\ntransb_array\n[],\nconst\nint\nm_array\n[],\nconst\nint\nn_array\n[],\nconst\nint\nk_array\n[],\nconst\nfloat\nalpha_array\n[],\nconst\nfloat\n*\nconst\nAarray\n[],\nconst\nint\nlda_array\n[],\nconst\nfloat\n*\nconst\nBarray\n[],\nconst\nint\nldb_array\n[],\nconst\nfloat\nbeta_array\n[],\nfloat\n*\nconst\nCarray\n[],\nconst\nint\nldc_array\n[],\nint\ngroup_count\n,\nconst\nint\ngroup_size\n[])\ncublasStatus_t\ncublasDgemmGroupedBatched\n(\ncublasHandle_t\nhandle\n,\nconst\ncublasOperation_t\ntransa_array\n[],\nconst\ncublasOperation_t\ntransb_array\n[],\nconst\nint\nm_array\n[],\nconst\nint\nn_array\n[],\nconst\nint\nk_array\n[],\nconst\ndouble\nalpha_array\n[],\nconst\ndouble\n*\nconst\nAarray\n[],\nconst\nint\nlda_array\n[],\nconst\ndouble\n*\nconst\nBarray\n[],\nconst\nint\nldb_array\n[],\nconst\ndouble\nbeta_array\n[],\ndouble\n*\nconst\nCarray\n[],\nconst\nint\nldc_array\n[],\nint\ngroup_count\n,\nconst\nint\ngroup_size\n[])\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the matrix-matrix multiplication on groups of matrices. A given group is considered to be “uniform”, i.e. all instances have the same dimensions (m, n, k), leading dimensions (lda, ldb, ldc) and transpositions (transa, transb) for their respective A, B and C matrices. However, the dimensions, leading dimensions, transpositions, and scaling factors (alpha, beta) may vary between groups. The address of the input matrices and the output matrix of each instance of the batch are read from arrays of pointers passed to the function by the caller.  This is functionally equivalent to the following:\nidx\n=\n0\n;\nfor\ni\n=\n0\n:\ngroup_count\n-\n1\nfor\nj\n=\n0\n:\ngroup_size\n[\ni\n]\n-\n1\ngemm\n(\ntransa_array\n[\ni\n],\ntransb_array\n[\ni\n],\nm_array\n[\ni\n],\nn_array\n[\ni\n],\nk_array\n[\ni\n],\nalpha_array\n[\ni\n],\nAarray\n[\nidx\n],\nlda_array\n[\ni\n],\nBarray\n[\nidx\n],\nldb_array\n[\ni\n],\nbeta_array\n[\ni\n],\nCarray\n[\nidx\n],\nldc_array\n[\ni\n]);\nidx\n+=\n1\n;\nend\nend\nwhere\n\\(\\text{$\\mathrm{alpha\\_array}$}\\)\nand\n\\(\\text{$\\mathrm{beta\\_array}$}\\)\nare arrays of scaling factors, and\n\\(\\text{Aarray}\\)\n,\n\\(\\text{Barray}\\)\nand\n\\(\\text{Carray}\\)\nare arrays of pointers to matrices stored in column-major format.  For a given index,\n\\(\\text{idx}\\)\n, that is part of group\n\\(i\\)\n, the dimensions are:\n\\(\\text{op}(\\text{Aarray}\\lbrack\\text{idx}\\rbrack)\\)\n:\n\\(\\text{$\\mathrm{m\\_array}$}\\lbrack i\\rbrack \\times \\text{$\\mathrm{k\\_array}$}\\lbrack i\\rbrack\\)\n\\(\\text{op}(\\text{Barray}\\lbrack\\text{idx}\\rbrack)\\)\n:\n\\(\\text{$\\mathrm{k\\_array}$}\\lbrack i\\rbrack \\times \\text{$\\mathrm{n\\_array}$}\\lbrack i\\rbrack\\)\n\\(\\text{Carray}\\lbrack\\text{idx}\\rbrack\\)\n:\n\\(\\text{$\\mathrm{m\\_array}$}\\lbrack i\\rbrack \\times \\text{$\\mathrm{n\\_array}$}\\lbrack i\\rbrack\\)\nNote\nThis API takes arrays of two different lengths.  The arrays of dimensions, leading dimensions, transpositions, and scaling factors are of length\ngroup_count\nand the arrays of matrices are of length\nproblem_count\nwhere\n\\(\\text{$\\mathrm{problem\\_count}$} = \\sum_{i = 0}^{\\text{$\\mathrm{group\\_count}$} - 1} \\text{$\\mathrm{group\\_size}$}\\lbrack i\\rbrack\\)\nFor matrix\n\\(A[\\text{idx}]\\)\nin group\n\\(i\\)\n\\(\\text{op}(A[\\text{idx}]) = \\left\\{ \\begin{matrix}\nA[\\text{idx}] & {\\text{if }\\textsf{$\\mathrm{transa\\_array}\\lbrack i\\rbrack$ == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA[\\text{idx}]^{T} & {\\text{if }\\textsf{$\\mathrm{transa\\_array}\\lbrack i\\rbrack$ == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\nA[\\text{idx}]^{H} & {\\text{if }\\textsf{$\\mathrm{transa\\_array}\\lbrack i\\rbrack$ == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nand\n\\(\\text{op}(B[\\text{idx}])\\)\nis defined similarly for matrix\n\\(B[\\text{idx}]\\)\nin group\n\\(i\\)\n.\nNote\n\\(C\\lbrack\\text{idx}\\rbrack\\)\nmatrices must not overlap, that is, the individual gemm operations must be computable independently; otherwise, undefined behavior is expected.\nOn certain problem sizes, it might be advantageous to make multiple calls to\ncublas<t>gemmBatched()\nin different CUDA streams, rather than use this API.\nParam.\nMemory\nIn/out\nMeaning\nArray Length\nhandle\ninput\nHandle to the cuBLAS library context.\ntransa_array\nhost\ninput\nOperation op(\nA[idx]\n) that is non- or (conj.) transpose for each group.\ngroup_count\ntransb_array\nhost\ninput\nOperation op(\nB[idx]\n) that is non- or (conj.) transpose for each group.\ngroup_count\nm_array\nhost\ninput\nArray containing the number of rows of matrix op(\nA[idx]\n) and\nC[idx]\nfor each group.\ngroup_count\nn_array\nhost\ninput\nArray containing the number of columns of op(\nB[idx]\n) and\nC[idx]\nfor each group.\ngroup_count\nk_array\nhost\ninput\nArray containing the number of columns of op(\nA[idx]\n) and rows of op(\nB[idx]\n) for each group.\ngroup_count\nalpha_array\nhost\ninput\nArray containing the <\ntype\n> scalar used for multiplication for each group.\ngroup_count\nAarray\ndevice\ninput\nArray of pointers to <\ntype\n> array, with each array of dim.\nlda[i]\nx\nk[i]\nwith\nlda[i]\n>=\nmax(1,m[i])\nif\ntransa[i]\n==\nCUBLAS_OP_N\nand\nlda[i]\nx\nm[i]\nwith\nlda[i]\n>=\nmax(1,k[i])\notherwise.\nAll pointers must meet certain alignment criteria. Please see below for details.\nproblem_count\nlda_array\nhost\ninput\nArray containing the leading dimensions of two-dimensional arrays used to store each matrix\nA[idx]\nfor each group.\ngroup_count\nBarray\ndevice\ninput\nArray of pointers to <\ntype\n> array, with each array of dim.\nldb[i]\nx\nn[i]\nwith\nldb[i]\n>=\nmax(1,k[i])\nif\ntransb[i]\n==\nCUBLAS_OP_N\nand\nldb[i]\nx\nk[i]\nwith\nldb[i]\n>=\nmax(1,n[i])\notherwise.\nAll pointers must meet certain alignment criteria. Please see below for details.\nproblem_count\nldb_array\nhost\ninput\nArray containing the leading dimensions of two-dimensional arrays used to store each matrix\nB[idx]\nfor each group.\ngroup_count\nbeta_array\nhost\ninput\nArray containing the <\ntype\n> scalar used for multiplication for each group.\ngroup_count\nCarray\ndevice\nin/out\nArray of pointers to <\ntype\n> array. It has dimensions\nldc[i]\nx\nn[i]\nwith\nldc[i]\n>=\nmax(1,m[i])\n. Matrices\nC[idx]\nshould not overlap; otherwise, undefined behavior is expected.\nAll pointers must meet certain alignment criteria. Please see below for details.\nproblem_count\nldc_array\nhost\ninput\nArray containing the leading dimensions of two-dimensional arrays used to store each matrix\nC[idx]\nfor each group.\ngroup_count\ngroup_count\nhost\ninput\nNumber of groups\ngroup_size\nhost\ninput\nArray containing the number of pointers contained in Aarray, Barray and Carray for each group.\ngroup_count\nIf math mode enables fast math modes when using\ncublasSgemmGroupedBatched()\n, pointers (not the pointer arrays) placed in the GPU memory must be properly aligned to avoid misaligned memory access errors. Ideally all pointers are aligned to at least 16 Bytes. Otherwise it is required that they meet the following rule:\nif\nk\n%\n4\n==\n0\nthen ensure\nintptr_t(ptr)\n%\n16\n==\n0\n,\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\ntransa_array\n,\ntransb_array\n,\nm_array\n,\nn_array\n,\nk_array\n,\nalpha_array\n,\nlda_array\n,\nldb_array\n,\nbeta_array\n,\nldc_array\n, or\ngroup_size\nare NULL, or\nif\ngroup_count\n<\n0\n, or\nif\nm_array[i]\n<\n0\n,\nn_array[i]\n<\n0\n,\nk_array[i]\n<\n0\n,\ngroup_size[i]\n<\n0\n, or\nif\ntransa_array[i]\nand\ntransb_array[i]\nare not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_C\n,\nCUBLAS_OP_T\n, or\nif\nlda_array[i]\n<\nmax(1,\nm_array[i])\nif\ntransa_array[i]\n==\nCUBLAS_OP_N\nand\nlda_array[i]\n<\nmax(1,\nk_array[i])\notherwise, or\nif\nldb_array[i]\n<\nmax(1,\nk_array[i])\nif\ntransb_array[i]\n==\nCUBLAS_OP_N\nand\nldb_array[i]\n<\nmax(1,\nn_array[i])\notherwise, or\nif\nldc_array[i]\n<\nmax(1,\nm_array[i])\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nCUBLAS_STATUS_NOT_SUPPORTED\nThe pointer mode is set to\nCUBLAS_POINTER_MODE_DEVICE\n2.7.6.\ncublas<t>symm()\n\ncublasStatus_t\ncublasSsymm\n(\ncublasHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nB\n,\nint\nldb\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasDsymm\n(\ncublasHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nB\n,\nint\nldb\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasCsymm\n(\ncublasHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\nB\n,\nint\nldb\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasZsymm\n(\ncublasHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\nC\n,\nint\nldc\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the symmetric matrix-matrix multiplication\n\\(C = \\left\\{ \\begin{matrix}\n{\\alpha AB + \\beta C} & {\\text{if }\\textsf{side == $\\mathrm{CUBLAS\\_SIDE\\_LEFT}$}} \\\\\n{\\alpha BA + \\beta C} & {\\text{if }\\textsf{side == $\\mathrm{CUBLAS\\_SIDE\\_RIGHT}$}} \\\\\n\\end{matrix} \\right.\\)\nwhere\n\\(A\\)\nis a symmetric matrix stored in lower or upper mode,\n\\(B\\)\nand\n\\(C\\)\nare\n\\(m \\times n\\)\nmatrices, and\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nside\ninput\nIndicates if matrix\nA\nis on the left or right of\nB\n.\nuplo\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements.\nm\ninput\nNumber of rows of matrix\nC\nand\nB\n, with matrix\nA\nsized accordingly.\nn\ninput\nNumber of columns of matrix\nC\nand\nB\n, with matrix\nA\nsized accordingly.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nA\ndevice\ninput\n<\ntype\n> array of dimension\nlda\nx\nm\nwith\nlda\n>=\nmax(1,\nm)\nif\nside\n==\nCUBLAS_SIDE_LEFT\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nn)\notherwise.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nB\ndevice\ninput\n<\ntype\n> array of dimension\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nm)\n.\nldb\ninput\nLeading dimension of two-dimensional array used to store matrix\nB\n.\nbeta\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\nthen\nC\ndoes not have to be a valid input.\nC\ndevice\nin/out\n<\ntype\n> array of dimension\nldc\nx\nn\nwith\nldc\n>=\nmax(1,\nm)\n.\nldc\ninput\nLeading dimension of two-dimensional array used to store matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nm\n<\n0\nor\nn\n<\n0\n, or\nif\nside\nis not one of\nCUBLAS_SIDE_LEFT\nand\nCUBLAS_SIDE_RIGHT\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n,  or\nif\nlda\n<\nmax(1,\nm)\nwhen\nside\n==\nCUBLAS_SIDE_LEFT\n, and\nlda\n<\nmax(1,\nn)\notherwise, or\nif\nldb\n<\nmax(1,\nm)\n, or\nif\nldc\n<\nmax(1,\nm)\n, or\nif\nalpha\nor\nbeta\nare NULL, or\nif\nC\nis NULL when\nbeta\nis not zero\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nssymm()\n,\ndsymm()\n,\ncsymm()\n,\nzsymm()\n2.7.7.\ncublas<t>syrk()\n\ncublasStatus_t\ncublasSsyrk\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasDsyrk\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasCsyrk\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasZsyrk\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\nC\n,\nint\nldc\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the symmetric rank-\n\\(k\\)\nupdate\n\\(C = \\alpha\\text{op}(A)\\text{op}(A)^{T} + \\beta C\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars,\n\\(C\\)\nis a symmetric matrix stored in lower or upper mode, and\n\\(A\\)\nis a matrix with dimensions\n\\(\\text{op}(A)\\)\n\\(n \\times k\\)\n. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\n\\end{matrix} \\right.\\)\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nC\nlower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements.\ntrans\ninput\nOperation op(\nA\n) that is non- or transpose.\nn\ninput\nNumber of rows of matrix op(\nA\n) and\nC\n.\nk\ninput\nNumber of columns of matrix op(\nA\n).\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nA\ndevice\ninput\n<\ntype\n> array of dimension\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nn)\nif\ntrans\n==\nCUBLAS_OP_N\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix A.\nbeta\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\nthen\nC\ndoes not have to be a valid input.\nC\ndevice\nin/out\n<\ntype\n> array of dimension\nldc\nx\nn\n, with\nldc\n>=\nmax(1,\nn)\n.\nldc\ninput\nLeading dimension of two-dimensional array used to store matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\nor\nk\n<\n0\n, or\nif\ntrans\nis not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\nand\nCUBLAS_OP_C\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nlda\n<\nmax(1,\nn)\nwhen\ntrans\n==\nCUBLAS_OP_N\n, and\nlda\n<\nmax(1,\nk)\notherwise, or\nif\nldc\n<\nmax(1,\nn)\n, or\nif\nalpha\nor\nbeta\nare NULL, or\nif\nC\nis NULL when\nbeta\nis not zero\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nssyrk()\n,\ndsyrk()\n,\ncsyrk()\n,\nzsyrk()\n2.7.8.\ncublas<t>syr2k()\n\ncublasStatus_t\ncublasSsyr2k\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nB\n,\nint\nldb\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasDsyr2k\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nB\n,\nint\nldb\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasCsyr2k\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\nB\n,\nint\nldb\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasZsyr2k\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\nC\n,\nint\nldc\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the symmetric rank-\n\\(2k\\)\nupdate\n\\(C = \\alpha(\\text{op}(A)\\text{op}(B)^{T} + \\text{op}(B)\\text{op}(A)^{T}) + \\beta C\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars,\n\\(C\\)\nis a symmetric matrix stored in lower or upper mode, and\n\\(A\\)\nand\n\\(B\\)\nare matrices with dimensions\n\\(\\text{op}(A)\\)\n\\(n \\times k\\)\nand\n\\(\\text{op}(B)\\)\n\\(n \\times k\\)\n, respectively. Also, for matrix\n\\(A\\)\nand\n\\(B\\)\n\\(\\text{op(}A\\text{) and op(}B\\text{)} = \\left\\{ \\begin{matrix}\n{A\\text{ and }B} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\n{A^{T}\\text{ and }B^{T}} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\n\\end{matrix} \\right.\\)\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nC\nlower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.\ntrans\ninput\nOperation op(\nA\n) that is non- or transpose.\nn\ninput\nNumber of rows of matrix op(\nA\n), op(\nB\n) and\nC\n.\nk\ninput\nNumber of columns of matrix op(\nA\n) and op(\nB\n).\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nA\ndevice\ninput\n<\ntype\n> array of dimension\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nn)\nif\ntransa\n==\nCUBLAS_OP_N\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nB\ndevice\ninput\n<\ntype\n> array of dimensions\nldb\nx\nk\nwith\nldb\n>=\nmax(1,\nn)\nif\ntransb\n==\nCUBLAS_OP_N\nand\nldb\nx\nn\nwith\nldb\n>=\nmax(1,k)\notherwise.\nldb\ninput\nLeading dimension of two-dimensional array used to store matrix\nB\n.\nbeta\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\n, then\nC\ndoes not have to be a valid input.\nC\ndevice\nin/out\n<\ntype\n> array of dimensions\nldc\nx\nn\nwith\nldc\n>=\nmax(1,\nn)\n.\nldc\ninput\nLeading dimension of two-dimensional array used to store matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\nor\nk\n<\n0\n, or\nif\ntrans\nis not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\nand\nCUBLAS_OP_C\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nlda\n<\nmax(1,\nn)\nwhen\ntrans\n==\nCUBLAS_OP_N\n, and\nlda\n<\nmax(1,\nk)\notherwise, or\nif\nldb\n<\nmax(1,\nn)\nwhen\ntrans\n==\nCUBLAS_OP_N\n, and\nldb\n<\nmax(1,\nk)\notherwise, or\nif\nldc\n<\nmax(1,\nn)\n, or\nif\nalpha\nor\nbeta\nare NULL, or\nif\nC\nis NULL when\nbeta\nis not zero\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nssyr2k()\n,\ndsyr2k()\n,\ncsyr2k()\n,\nzsyr2k()\n2.7.9.\ncublas<t>syrkx()\n\ncublasStatus_t\ncublasSsyrkx\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nB\n,\nint\nldb\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasDsyrkx\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nB\n,\nint\nldb\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasCsyrkx\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\nB\n,\nint\nldb\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasZsyrkx\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\nC\n,\nint\nldc\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs a variation of the symmetric rank-\n\\(k\\)\nupdate\n\\(C = \\alpha\\text{op}(A)\\text{op}(B)^{T} + \\beta C\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars,\n\\(C\\)\nis a symmetric matrix stored in lower or upper mode, and\n\\(A\\)\nand\n\\(B\\)\nare matrices with dimensions\n\\(\\text{op}(A)\\)\n\\(n \\times k\\)\nand\n\\(\\text{op}(B)\\)\n\\(n \\times k\\)\n, respectively. Also, for matrices\n\\(A\\)\nand\n\\(B\\)\n\\(\\text{op(}A\\text{) and op(}B\\text{)} = \\left\\{ \\begin{matrix}\n{A\\text{ and }B} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\n{A^{T}\\text{ and }B^{T}} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\n\\end{matrix} \\right.\\)\nThis routine can be used when B is in such way that the result is guaranteed to be symmetric. A usual example is when the matrix B is a scaled form of the matrix A: this is equivalent to B being the product of the matrix A and a diagonal matrix. For an efficient computation of the product of a regular matrix with a diagonal matrix, refer to the routine\ncublas<t>dgmm()\n.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nC\nlower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.\ntrans\ninput\nOperation op(\nA\n) that is non- or transpose.\nn\ninput\nNumber of rows of matrix op(\nA\n), op(\nB\n) and\nC\n.\nk\ninput\nNumber of columns of matrix op(\nA\n) and op(\nB\n).\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nA\ndevice\ninput\n<\ntype\n> array of dimension\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nn)\nif\ntransa\n==\nCUBLAS_OP_N\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nB\ndevice\ninput\n<\ntype\n> array of dimensions\nldb\nx\nk\nwith\nldb\n>=\nmax(1,\nn)\nif\ntransb\n==\nCUBLAS_OP_N\nand\nldb\nx\nn\nwith\nldb\n>=\nmax(1,k)\notherwise.\nldb\ninput\nLeading dimension of two-dimensional array used to store matrix\nB\n.\nbeta\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\n, then\nC\ndoes not have to be a valid input.\nC\ndevice\nin/out\n<\ntype\n> array of dimensions\nldc\nx\nn\nwith\nldc\n>=\nmax(1,\nn)\n.\nldc\ninput\nLeading dimension of two-dimensional array used to store matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\nor\nk\n<\n0\n, or\nif\ntrans\nis not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\nand\nCUBLAS_OP_C\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nlda\n<\nmax(1,\nn)\nwhen\ntrans\n==\nCUBLAS_OP_N\n, and\nlda\n<\nmax(1,\nk)\notherwise, or\nif\nldb\n<\nmax(1,\nn)\nwhen\ntrans\n==\nCUBLAS_OP_N\n, and\nldb\n<\nmax(1,\nk)\notherwise, or\nif\nldc\n<\nmax(1,\nn)\n, or\nif\nalpha\nor\nbeta\nare NULL, or\nif\nC\nis NULL when\nbeta\nis not zero\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nssyrk()\n,\ndsyrk()\n,\ncsyrk()\n,\nzsyrk()\nand\nssyr2k()\n,\ndsyr2k()\n,\ncsyr2k()\n,\nzsyr2k()\n2.7.10.\ncublas<t>trmm()\n\ncublasStatus_t\ncublasStrmm\n(\ncublasHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nB\n,\nint\nldb\n,\nfloat\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasDtrmm\n(\ncublasHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nB\n,\nint\nldb\n,\ndouble\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasCtrmm\n(\ncublasHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\nB\n,\nint\nldb\n,\ncuComplex\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasZtrmm\n(\ncublasHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\ncuDoubleComplex\n*\nC\n,\nint\nldc\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the triangular matrix-matrix multiplication\n\\(C = \\left\\{ \\begin{matrix}\n{\\alpha\\text{op}(A)B} & {\\text{if }\\textsf{side == $\\mathrm{CUBLAS\\_SIDE\\_LEFT}$}} \\\\\n{\\alpha B\\text{op}(A)} & {\\text{if }\\textsf{side == $\\mathrm{CUBLAS\\_SIDE\\_RIGHT}$}} \\\\\n\\end{matrix} \\right.\\)\nwhere\n\\(A\\)\nis a triangular matrix stored in lower or upper mode with or without the main diagonal,\n\\(B\\)\nand\n\\(C\\)\nare\n\\(m \\times n\\)\nmatrix, and\n\\(\\alpha\\)\nis a scalar. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\nA^{H} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nNotice that in order to achieve better parallelism cuBLAS differs from the BLAS API only for this routine. The BLAS API assumes an in-place implementation (with results written back to B), while the cuBLAS API assumes an out-of-place implementation (with results written into C). The application can obtain the in-place functionality of BLAS in the cuBLAS API by passing the address of the matrix B in place of the matrix C. No other overlapping in the input parameters is supported.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nside\ninput\nIndicates if matrix\nA\nis on the left or right of\nB\n.\nuplo\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other part is not referenced and is inferred from the stored elements.\ntrans\ninput\nOperation op(\nA\n) that is non- or (conj.) transpose.\ndiag\ninput\nIndicates if the elements on the main diagonal of matrix\nA\nare unity and should not be accessed.\nm\ninput\nNumber of rows of matrix\nB\n, with matrix\nA\nsized accordingly.\nn\ninput\nNumber of columns of matrix\nB\n, with matrix\nA\nsized accordingly.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication, if\nalpha\n==\n0\nthen\nA\nis not referenced and\nB\ndoes not have to be a valid input.\nA\ndevice\ninput\n<\ntype\n> array of dimension\nlda\nx\nm\nwith\nlda\n>=\nmax(1,\nm)\nif\nside\n==\nCUBLAS_SIDE_LEFT\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nn)\notherwise.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nB\ndevice\ninput\n<\ntype\n> array of dimension\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nm)\n.\nldb\ninput\nLeading dimension of two-dimensional array used to store matrix\nB\n.\nC\ndevice\nin/out\n<\ntype\n> array of dimension\nldc\nx\nn\nwith\nldc\n>=\nmax(1,\nm)\n.\nldc\ninput\nLeading dimension of two-dimensional array used to store matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nm\n<\n0\n,\nn\n<\n0\n, or\nif\ntrans\nis not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\nand\nCUBLAS_OP_C\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nside\nis not one of\nCUBLAS_SIDE_LEFT\nand\nCUBLAS_SIDE_RIGHT\n, or\nif\nlda\n<\nmax(1,\nm)\nif\nside\n==\nCUBLAS_SIDE_LEFT\n, and\nlda\n<\nmax(1,\nn)\notherwise, or\nif\nldb\n<\nmax(1,\nm)\n, or\nif\nldc\n<\nmax(1,\nm)\n, or\nif\nalpha\nis NULL\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nstrmm()\n,\ndtrmm()\n,\nctrmm()\n,\nztrmm()\n2.7.11.\ncublas<t>trsm()\n\ncublasStatus_t\ncublasStrsm\n(\ncublasHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\n*\nB\n,\nint\nldb\n)\ncublasStatus_t\ncublasDtrsm\n(\ncublasHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\n*\nB\n,\nint\nldb\n)\ncublasStatus_t\ncublasCtrsm\n(\ncublasHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\ncuComplex\n*\nB\n,\nint\nldb\n)\ncublasStatus_t\ncublasZtrsm\n(\ncublasHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ncuDoubleComplex\n*\nB\n,\nint\nldb\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function solves the triangular linear system with multiple right-hand-sides\n\\(\\left\\{ \\begin{matrix}\n{\\text{op}(A)X = \\alpha B} & {\\text{if }\\textsf{side == $\\mathrm{CUBLAS\\_SIDE\\_LEFT}$}} \\\\\n{X\\text{op}(A) = \\alpha B} & {\\text{if }\\textsf{side == $\\mathrm{CUBLAS\\_SIDE\\_RIGHT}$}} \\\\\n\\end{matrix} \\right.\\)\nwhere\n\\(A\\)\nis a triangular matrix stored in lower or upper mode with or without the main diagonal,\n\\(X\\)\nand\n\\(B\\)\nare\n\\(m \\times n\\)\nmatrices, and\n\\(\\alpha\\)\nis a scalar. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\nA^{H} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nThe solution\n\\(X\\)\noverwrites the right-hand-sides\n\\(B\\)\non exit.\nNo test for singularity or near-singularity is included in this function.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nside\ninput\nIndicates if matrix\nA\nis on the left or right of\nX\n.\nuplo\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other part is not referenced and is inferred from the stored elements.\ntrans\ninput\nOperation op(\nA\n) that is non- or (conj.) transpose.\ndiag\ninput\nIndicates if the elements on the main diagonal of matrix\nA\nare unity and should not be accessed.\nm\ninput\nNumber of rows of matrix\nB\n, with matrix\nA\nsized accordingly.\nn\ninput\nNumber of columns of matrix\nB\n, with matrix\nA\nis sized accordingly.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication, if\nalpha\n==\n0\nthen\nA\nis not referenced and\nB\ndoes not have to be a valid input.\nA\ndevice\ninput\n<\ntype\n> array of dimension\nlda\nx\nm\nwith\nlda\n>=\nmax(1,\nm)\nif\nside\n==\nCUBLAS_SIDE_LEFT\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nn)\notherwise.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nB\ndevice\nin/out\n<\ntype\n> array. It has dimensions\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nm)\n.\nldb\ninput\nLeading dimension of two-dimensional array used to store matrix\nB\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nm\n<\n0\n,\nn\n<\n0\n, or\nif\ntrans\nis not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\nand\nCUBLAS_OP_C\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nside\nis not one of\nCUBLAS_SIDE_LEFT\nand\nCUBLAS_SIDE_RIGHT\n, or\nif\ndiag\nis not one of\nCUBLAS_DIAG_UNIT\nand\nCUBLAS_DIAG_NON_UNIT\n, or\nif\nlda\n<\nmax(1,\nm)\nif\nside\n==\nCUBLAS_SIDE_LEFT\n, and\nlda\n<\nmax(1,\nn)\notherwise, or\nif\nldb\n<\nmax(1,\nm)\n, or\nif\nalpha\nis NULL\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nstrsm()\n,\ndtrsm()\n,\nctrsm()\n,\nztrsm()\n2.7.12.\ncublas<t>trsmBatched()\n\ncublasStatus_t\ncublasStrsmBatched\n(\ncublasHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nconst\nA\n[],\nint\nlda\n,\nfloat\n*\nconst\nB\n[],\nint\nldb\n,\nint\nbatchCount\n);\ncublasStatus_t\ncublasDtrsmBatched\n(\ncublasHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nconst\nA\n[],\nint\nlda\n,\ndouble\n*\nconst\nB\n[],\nint\nldb\n,\nint\nbatchCount\n);\ncublasStatus_t\ncublasCtrsmBatched\n(\ncublasHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nconst\nA\n[],\nint\nlda\n,\ncuComplex\n*\nconst\nB\n[],\nint\nldb\n,\nint\nbatchCount\n);\ncublasStatus_t\ncublasZtrsmBatched\n(\ncublasHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nconst\nA\n[],\nint\nlda\n,\ncuDoubleComplex\n*\nconst\nB\n[],\nint\nldb\n,\nint\nbatchCount\n);\nThis function supports the\n64-bit Integer Interface\n.\nThis function solves an array of triangular linear systems with multiple right-hand-sides\n\\(\\left\\{ \\begin{matrix}\n{\\text{op}(A\\lbrack i\\rbrack)X\\lbrack i\\rbrack = \\alpha B\\lbrack i\\rbrack} & {\\text{if }\\textsf{side == $\\mathrm{CUBLAS\\_SIDE\\_LEFT}$}} \\\\\n{X\\lbrack i\\rbrack\\text{op}(A\\lbrack i\\rbrack) = \\alpha B\\lbrack i\\rbrack} & {\\text{if }\\textsf{side == $\\mathrm{CUBLAS\\_SIDE\\_RIGHT}$}} \\\\\n\\end{matrix} \\right.\\)\nwhere\n\\(A\\lbrack i\\rbrack\\)\nis a triangular matrix stored in lower or upper mode with or without the main diagonal,\n\\(X\\lbrack i\\rbrack\\)\nand\n\\(B\\lbrack i\\rbrack\\)\nare\n\\(m \\times n\\)\nmatrices, and\n\\(\\alpha\\)\nis a scalar. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A\\lbrack i\\rbrack) = \\left\\{ \\begin{matrix}\n{A\\lbrack i\\rbrack} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\n{A^{T}\\lbrack i\\rbrack} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\n{A^{H}\\lbrack i\\rbrack} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nThe solution\n\\(X\\lbrack i\\rbrack\\)\noverwrites the right-hand-sides\n\\(B\\lbrack i\\rbrack\\)\non exit.\nNo test for singularity or near-singularity is included in this function.\nThis function works for any sizes but is intended to be used for matrices of small sizes where the launch overhead is a significant factor. For bigger sizes, it might be advantageous to call\nbatchCount\ntimes the regular\ncublas<t>trsm()\nwithin a set of CUDA streams.\nThe current implementation is limited to devices with compute capability above or equal 2.0.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nside\ninput\nIndicates if matrix\nA[i]\nis on the left or right of\nX[i]\n.\nuplo\ninput\nIndicates if matrix\nA[i]\nlower or upper part is stored, the other part is not referenced and is inferred from the stored elements.\ntrans\ninput\nOperation op(\nA[i]\n) that is non- or (conj.) transpose.\ndiag\ninput\nIndicates if the elements on the main diagonal of matrix\nA[i]\nare unity and should not be accessed.\nm\ninput\nNumber of rows of matrix\nB[i]\n, with matrix\nA[i]\nsized accordingly.\nn\ninput\nNumber of columns of matrix\nB[i]\n, with matrix\nA[i]\nis sized accordingly.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication, if\nalpha\n==\n0\nthen\nA[i]\nis not referenced and\nB[i]\ndoes not have to be a valid input.\nA\ndevice\ninput\nArray of pointers to <\ntype\n> array, with each array of dim.\nlda\nx\nm\nwith\nlda\n>=\nmax(1,\nm)\nif\nside\n==\nCUBLAS_SIDE_LEFT\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nn)\notherwise.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA[i]\n.\nB\ndevice\nin/out\nArray of pointers to <\ntype\n> array, with each array of dim.\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nm)\n. Matrices\nB[i]\nshould not overlap; otherwise, undefined behavior is expected.\nldb\ninput\nLeading dimension of two-dimensional array used to store matrix\nB[i]\n.\nbatchCount\ninput\nNumber of pointers contained in A and B.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nm\n<\n0\n,\nn\n<\n0\n, or\nif\ntrans\nis not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\nand\nCUBLAS_OP_C\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nside\nis not one of\nCUBLAS_SIDE_LEFT\nand\nCUBLAS_SIDE_RIGHT\n, or\nif\ndiag\nis not one of\nCUBLAS_DIAG_UNIT\nand\nCUBLAS_DIAG_NON_UNIT\n, or\nif\nlda\n<\nmax(1,\nm)\nif\nside\n==\nCUBLAS_SIDE_LEFT\n, and\nlda\n<\nmax(1,\nn)\notherwise, or\nif\nldb\n<\nmax(1,\nm)\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nstrsm()\n,\ndtrsm()\n,\nctrsm()\n,\nztrsm()\n2.7.13.\ncublas<t>hemm()\n\ncublasStatus_t\ncublasChemm\n(\ncublasHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\nB\n,\nint\nldb\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasZhemm\n(\ncublasHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\nC\n,\nint\nldc\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the Hermitian matrix-matrix multiplication\n\\(C = \\left\\{ \\begin{matrix}\n{\\alpha AB + \\beta C} & {\\text{if }\\textsf{side == $\\mathrm{CUBLAS\\_SIDE\\_LEFT}$}} \\\\\n{\\alpha BA + \\beta C} & {\\text{if }\\textsf{side == $\\mathrm{CUBLAS\\_SIDE\\_RIGHT}$}} \\\\\n\\end{matrix} \\right.\\)\nwhere\n\\(A\\)\nis a Hermitian matrix stored in lower or upper mode,\n\\(B\\)\nand\n\\(C\\)\nare\n\\(m \\times n\\)\nmatrices, and\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nside\ninput\nIndicates if matrix\nA\nis on the left or right of\nB\n.\nuplo\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other Hermitian part is not referenced and is inferred from the stored elements.\nm\ninput\nNumber of rows of matrix\nC\nand\nB\n, with matrix\nA\nsized accordingly.\nn\ninput\nNumber of columns of matrix\nC\nand\nB\n, with matrix\nA\nsized accordingly.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nA\ndevice\ninput\n<\ntype\n> array of dimension\nlda\nx\nm\nwith\nlda\n>=\nmax(1,\nm)\nif\nside\n==\nCUBLAS_SIDE_LEFT\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nn)\notherwise. The imaginary parts of the diagonal elements are assumed to be zero.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nB\ndevice\ninput\n<\ntype\n> array of dimension\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nm)\n.\nldb\ninput\nLeading dimension of two-dimensional array used to store matrix\nB\n.\nbeta\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\nthen\nC\ndoes not have to be a valid input.\nC\ndevice\nin/out\n<\ntype\n> array of dimensions\nldc\nx\nn\nwith\nldc\n>=\nmax(1,\nm)\n.\nldc\ninput\nLeading dimension of two-dimensional array used to store matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nm\n<\n0\nor\nn\n<\n0\n, or\nif\nside\nis not one of\nCUBLAS_SIDE_LEFT\nand\nCUBLAS_SIDE_RIGHT\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n,  or\nif\nlda\n<\nmax(1,\nm)\nwhen\nside\n==\nCUBLAS_SIDE_LEFT\n, and\nlda\n<\nmax(1,\nn)\notherwise, or\nif\nldb\n<\nmax(1,\nm)\n, or\nif\nldc\n<\nmax(1,\nm)\n, or\nif\nalpha\nor\nbeta\nare NULL, or\nif\nC\nis NULL when\nbeta\nis not zero\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nchemm()\n,\nzhemm()\n2.7.14.\ncublas<t>herk()\n\ncublasStatus_t\ncublasCherk\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\nfloat\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nbeta\n,\ncuComplex\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasZherk\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\ndouble\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nbeta\n,\ncuDoubleComplex\n*\nC\n,\nint\nldc\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the Hermitian rank-\n\\(k\\)\nupdate\n\\(C = \\alpha\\text{op}(A)\\text{op}(A)^{H} + \\beta C\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars,\n\\(C\\)\nis a Hermitian matrix stored in lower or upper mode, and\n\\(A\\)\nis a matrix with dimensions\n\\(\\text{op}(A)\\)\n\\(n \\times k\\)\n. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{H} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nC\nlower or upper part is stored, the other Hermitian part is not referenced.\ntrans\ninput\nOperation op(\nA\n) that is non- or (conj.) transpose.\nn\ninput\nNumber of rows of matrix op(\nA\n) and\nC\n.\nk\ninput\nNumber of columns of matrix op(\nA\n).\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nA\ndevice\ninput\n<\ntype\n> array of dimension\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nn)\nif\ntransa\n==\nCUBLAS_OP_N\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nbeta\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\nthen\nC\ndoes not have to be a valid input.\nC\ndevice\nin/out\n<\ntype\n> array of dimension\nldc\nx\nn\n, with\nldc\n>=\nmax(1,\nn)\n. The imaginary parts of the diagonal elements are assumed and set to zero.\nldc\ninput\nLeading dimension of two-dimensional array used to store matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\nor\nk\n<\n0\n, or\nif\ntrans\nis not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\nand\nCUBLAS_OP_C\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nlda\n<\nmax(1,\nn)\nwhen\ntrans\n==\nCUBLAS_OP_N\n, and\nlda\n<\nmax(1,\nk)\notherwise, or\nif\nldc\n<\nmax(1,\nn)\n, or\nif\nalpha\nor\nbeta\nare NULL, or\nif\nC\nis NULL when\nbeta\nis not zero\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\ncherk()\n,\nzherk()\n2.7.15.\ncublas<t>her2k()\n\ncublasStatus_t\ncublasCher2k\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\nB\n,\nint\nldb\n,\nconst\nfloat\n*\nbeta\n,\ncuComplex\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasZher2k\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\nconst\ndouble\n*\nbeta\n,\ncuDoubleComplex\n*\nC\n,\nint\nldc\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the Hermitian rank-\n\\(2k\\)\nupdate\n\\(C = \\alpha\\text{op}(A)\\text{op}(B)^{H} + \\overset{ˉ}{\\alpha}\\text{op}(B)\\text{op}(A)^{H} + \\beta C\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars,\n\\(C\\)\nis a Hermitian matrix stored in lower or upper mode, and\n\\(A\\)\nand\n\\(B\\)\nare matrices with dimensions\n\\(\\text{op}(A)\\)\n\\(n \\times k\\)\nand\n\\(\\text{op}(B)\\)\n\\(n \\times k\\)\n, respectively. Also, for matrix\n\\(A\\)\nand\n\\(B\\)\n\\(\\text{op(}A\\text{) and op(}B\\text{)} = \\left\\{ \\begin{matrix}\n{A\\text{ and }B} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\n{A^{H}\\text{ and }B^{H}} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nC\nlower or upper part is stored, the other Hermitian part is not referenced.\ntrans\ninput\nOperation op(\nA\n) that is non- or (conj.) transpose.\nn\ninput\nNumber of rows of matrix op(\nA\n), op(\nB\n) and\nC\n.\nk\ninput\nNumber of columns of matrix op(\nA\n) and op(\nB\n).\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nA\ndevice\ninput\n<\ntype\n> array of dimension\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nn)\nif\ntransa\n==\nCUBLAS_OP_N\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nB\ndevice\ninput\n<\ntype\n> array of dimension\nldb\nx\nk\nwith\nldb\n>=\nmax(1,\nn)\nif\ntransb\n==\nCUBLAS_OP_N\nand\nldb\nx\nn\nwith\nldb\n>=\nmax(1,k)\notherwise.\nldb\ninput\nLeading dimension of two-dimensional array used to store matrix\nB\n.\nbeta\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\nthen\nC\ndoes not have to be a valid input.\nC\ndevice\nin/out\n<\ntype\n> array of dimension\nldc\nx\nn\n, with\nldc\n>=\nmax(1,\nn)\n. The imaginary parts of the diagonal elements are assumed and set to zero.\nldc\ninput\nLeading dimension of two-dimensional array used to store matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\nor\nk\n<\n0\n, or\nif\ntrans\nis not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\nand\nCUBLAS_OP_C\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nlda\n<\nmax(1,\nn)\nwhen\ntrans\n==\nCUBLAS_OP_N\n, and\nlda\n<\nmax(1,\nk)\notherwise, or\nif\nldc\n<\nmax(1,\nn)\n, or\nif\nalpha\nor\nbeta\nare NULL, or\nif\nC\nis NULL when\nbeta\nis not zero\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\ncher2k()\n,\nzher2k()\n2.7.16.\ncublas<t>herkx()\n\ncublasStatus_t\ncublasCherkx\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\nB\n,\nint\nldb\n,\nconst\nfloat\n*\nbeta\n,\ncuComplex\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasZherkx\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\nconst\ndouble\n*\nbeta\n,\ncuDoubleComplex\n*\nC\n,\nint\nldc\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs a variation of the Hermitian rank-\n\\(k\\)\nupdate\n\\(C = \\alpha\\text{op}(A)\\text{op}(B)^{H} + \\beta C\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars,\n\\(C\\)\nis a Hermitian matrix stored in lower or upper mode, and\n\\(A\\)\nand\n\\(B\\)\nare matrices with dimensions\n\\(\\text{op}(A)\\)\n\\(n \\times k\\)\nand\n\\(\\text{op}(B)\\)\n\\(n \\times k\\)\n, respectively. Also, for matrix\n\\(A\\)\nand\n\\(B\\)\n\\(\\text{op(}A\\text{) and op(}B\\text{)} = \\left\\{ \\begin{matrix}\n{A\\text{ and }B} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\n{A^{H}\\text{ and }B^{H}} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nThis routine can be used when the matrix B is in such way that the result is guaranteed to be hermitian. An usual example is when the matrix B is a scaled form of the matrix A: this is equivalent to B being the product of the matrix A and a diagonal matrix. For an efficient computation of the product of a regular matrix with a diagonal matrix, refer to the routine\ncublas<t>dgmm()\n.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nC\nlower or upper part is stored, the other Hermitian part is not referenced.\ntrans\ninput\nOperation op(\nA\n) that is non- or (conj.) transpose.\nn\ninput\nNumber of rows of matrix op(\nA\n), op(\nB\n) and\nC\n.\nk\ninput\nNumber of columns of matrix op(\nA\n) and op(\nB\n).\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nA\ndevice\ninput\n<\ntype\n> array of dimension\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nn)\nif\ntransa\n==\nCUBLAS_OP_N\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nB\ndevice\ninput\n<\ntype\n> array of dimension\nldb\nx\nk\nwith\nldb\n>=\nmax(1,\nn)\nif\ntransb\n==\nCUBLAS_OP_N\nand\nldb\nx\nn\nwith\nldb\n>=\nmax(1,k)\notherwise.\nldb\ninput\nLeading dimension of two-dimensional array used to store matrix\nB\n.\nbeta\nhost or device\ninput\nReal scalar used for multiplication. If\nbeta\n==\n0\nthen\nC\ndoes not have to be a valid input.\nC\ndevice\nin/out\n<\ntype\n> array of dimension\nldc\nx\nn\n, with\nldc\n>=\nmax(1,\nn)\n. The imaginary parts of the diagonal elements are assumed and set to zero.\nldc\ninput\nLeading dimension of two-dimensional array used to store matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\nor\nk\n<\n0\n, or\nif\ntrans\nis not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\nand\nCUBLAS_OP_C\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nlda\n<\nmax(1,\nn)\nwhen\ntrans\n==\nCUBLAS_OP_N\n, and\nlda\n<\nmax(1,\nk)\notherwise, or\nif\nldc\n<\nmax(1,\nn)\n, or\nif\nalpha\nor\nbeta\nare NULL, or\nif\nC\nis NULL when\nbeta\nis not zero\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\ncherk()\n,\nzherk()\nand\ncher2k()\n,\nzher2k()\n2.8.\nBLAS-like Extension\n\nThis section describes the BLAS-extension functions that perform matrix-matrix operations.\n2.8.1.\ncublas<t>geam()\n\ncublasStatus_t\ncublasSgeam\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nbeta\n,\nconst\nfloat\n*\nB\n,\nint\nldb\n,\nfloat\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasDgeam\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nbeta\n,\nconst\ndouble\n*\nB\n,\nint\nldb\n,\ndouble\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasCgeam\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\nbeta\n,\nconst\ncuComplex\n*\nB\n,\nint\nldb\n,\ncuComplex\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasZgeam\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\nconst\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\ncuDoubleComplex\n*\nC\n,\nint\nldc\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the matrix-matrix addition/transposition\n\\(C = \\alpha\\text{op}(A) + \\beta\\text{op}(B)\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars, and\n\\(A\\)\n,\n\\(B\\)\nand\n\\(C\\)\nare matrices stored in column-major format with dimensions\n\\(\\text{op}(A)\\)\n\\(m \\times n\\)\n,\n\\(\\text{op}(B)\\)\n\\(m \\times n\\)\nand\n\\(C\\)\n\\(m \\times n\\)\n, respectively. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\nA^{H} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nand\n\\(\\text{op}(B)\\)\nis defined similarly for matrix\n\\(B\\)\n.\nThe operation is out-of-place if C does not overlap A or B.\nThe in-place mode supports the following two operations,\n\\(C = \\alpha\\text{*}C + \\beta\\text{op}(B)\\)\n\\(C = \\alpha\\text{op}(A) + \\beta\\text{*}C\\)\nFor in-place mode, if\nC\n==\nA\n,\nldc\n==\nlda\nand\ntransa\n==\nCUBLAS_OP_N\n. If\nC\n===\nB\n,\nldc\n==\nldb\nand\ntransb\n==\nCUBLAS_OP_N\n. If the user does not meet above requirements,\nCUBLAS_STATUS_INVALID_VALUE\nis returned.\nThe operation includes the following special cases:\nthe user can reset matrix C to zero by setting\n*alpha\n=\nbeta\n=\n0\n.\nthe user can transpose matrix A by setting\n*alpha\n=\n1\nand\n*beta\n=\n0\n.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\ntransa\ninput\nOperation op(\nA\n) that is non- or (conj.) transpose.\ntransb\ninput\nOperation op(\nB\n) that is non- or (conj.) transpose.\nm\ninput\nNumber of rows of matrix op(\nA\n) and\nC\n.\nn\ninput\nNumber of columns of matrix op(\nB\n) and\nC\n.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\n*alpha\n==\n0\n,\nA\ndoes not have to be a valid input.\nA\ndevice\ninput\n<\ntype\n> array of dimensions\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nm)\nif\ntransa\n==\nCUBLAS_OP_N\nand\nlda\nx\nm\nwith\nlda\n>=\nmax(1,\nn)\notherwise.\nlda\ninput\nLeading dimension of two-dimensional array used to store the matrix\nA\n.\nB\ndevice\ninput\n<\ntype\n> array of dimension\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nm)\nif\ntransb\n==\nCUBLAS_OP_N\nand\nldb\nx\nm\nwith\nldb\n>=\nmax(1,n)\notherwise.\nldb\ninput\nLeading dimension of two-dimensional array used to store matrix\nB\n.\nbeta\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\n*beta\n==\n0\n,\nB\ndoes not have to be a valid input.\nC\ndevice\noutput\n<\ntype\n> array of dimensions\nldc\nx\nn\nwith\nldc\n>=\nmax(1,\nm)\n.\nldc\ninput\nLeading dimension of a two-dimensional array used to store the matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nm\n<\n0\nor\nn\n<\n0\n, or\nif\ntransa\nis not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\nand\nCUBLAS_OP_C\n, or\nif\ntransb\nis not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\nand\nCUBLAS_OP_C\n, or\nif\nlda\n<\nmax(1,\nm)\nwhen\ntransa\n==\nCUBLAS_OP_N\n, and\nlda\n<\nmax(1,\nn)\notherwise, or\nif\nldb\n<\nmax(1,\nm)\nif\ntransb\n==\nCUBLAS_OP_N\n, and\nldb\n<\nmax(1,\nn)\notherwise, or\nif\nldc\n<\nmax(1,\nm)\n, or\nif\nA\n==\nC\nand\n(transa\n!=\nCUBLAS_OP_N)\n||\n(lda\n!=\nldc)\n, or\nif\nB\n==\nC\nand\n(transb\n!=\nCUBLAS_OP_N)\n||\n(ldb\n!=\nldc)\n, or\nif\nalpha\nor\nbeta\nare NULL\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\n2.8.2.\ncublas<t>dgmm()\n\ncublasStatus_t\ncublasSdgmm\n(\ncublasHandle_t\nhandle\n,\ncublasSideMode_t\nmode\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nx\n,\nint\nincx\n,\nfloat\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasDdgmm\n(\ncublasHandle_t\nhandle\n,\ncublasSideMode_t\nmode\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nx\n,\nint\nincx\n,\ndouble\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasCdgmm\n(\ncublasHandle_t\nhandle\n,\ncublasSideMode_t\nmode\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\nx\n,\nint\nincx\n,\ncuComplex\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasZdgmm\n(\ncublasHandle_t\nhandle\n,\ncublasSideMode_t\nmode\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nincx\n,\ncuDoubleComplex\n*\nC\n,\nint\nldc\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the matrix-matrix multiplication\n\\(C = \\left\\{ \\begin{matrix}\n{A \\times diag(X)} & {\\text{if }\\textsf{mode == $\\mathrm{CUBLAS\\_SIDE\\_RIGHT}$}} \\\\\n{diag(X) \\times A} & {\\text{if }\\textsf{mode == $\\mathrm{CUBLAS\\_SIDE\\_LEFT}$}} \\\\\n\\end{matrix} \\right.\\)\nwhere\n\\(A\\)\nand\n\\(C\\)\nare matrices stored in column-major format with dimensions\n\\(m \\times n\\)\n.\n\\(X\\)\nis a vector of size\n\\(n\\)\nif\nmode\n==\nCUBLAS_SIDE_RIGHT\nand of size\n\\(m\\)\nif\nmode\n==\nCUBLAS_SIDE_LEFT\n.\n\\(X\\)\nis gathered from one-dimensional array x with stride\nincx\n. The absolute value of\nincx\nis the stride and the sign of\nincx\nis direction of the stride. If\nincx\nis positive, then we forward x from the first element. Otherwise, we backward x from the last element. The formula of X is\n\\(X\\lbrack j\\rbrack = \\left\\{ \\begin{matrix}\n{x\\lbrack j \\times incx\\rbrack} & {\\text{if }incx \\geq 0} \\\\\n{x\\lbrack(\\chi - 1) \\times |incx| - j \\times |incx|\\rbrack} & {\\text{if }incx < 0} \\\\\n\\end{matrix} \\right.\\)\nwhere\n\\(\\chi = m\\)\nif\nmode\n==\nCUBLAS_SIDE_LEFT\nand\n\\(\\chi = n\\)\nif\nmode\n==\nCUBLAS_SIDE_RIGHT\n.\nExample 1: if the user wants to perform\n\\(diag(diag(B)) \\times A\\)\n, then\n\\(incx = ldb + 1\\)\nwhere\n\\(ldb\\)\nis leading dimension of matrix\nB\n, either row-major or column-major.\nExample 2: if the user wants to perform\n\\(\\alpha \\times A\\)\n, then there are two choices, either\ncublas<t>geam()\nwith\n*beta\n==\n0\nand\ntransa\n==\nCUBLAS_OP_N\nor\ncublas<t>dgmm()\nwith\nincx\n==\n0\nand\nx[0]\n==\nalpha\n.\nThe operation is out-of-place. The in-place only works if\nlda\n==\nldc\n.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nmode\ninput\nLeft multiply if\nmode\n==\nCUBLAS_SIDE_LEFT\nor right multiply if\nmode\n==\nCUBLAS_SIDE_RIGHT\nm\ninput\nNumber of rows of matrix\nA\nand\nC\n.\nn\ninput\nNumber of columns of matrix\nA\nand\nC\n.\nA\ndevice\ninput\n<\ntype\n> array of dimensions\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nm)\nlda\ninput\nLeading dimension of two-dimensional array used to store the matrix\nA\n.\nx\ndevice\ninput\nOne-dimensional <\ntype\n> array of size\nabs(incx)\nx\nm\nif\nmode\n==\nCUBLAS_SIDE_LEFT\nand\nabs(incx)\nx\nn\nif\nmode\n==\nCUBLAS_SIDE_RIGHT\nincx\ninput\nStride of one-dimensional array\nx\n.\nC\ndevice\nin/out\n<\ntype\n> array of dimensions\nldc\nx\nn\nwith\nldc\n>=\nmax(1,\nm)\n.\nldc\ninput\nLeading dimension of a two-dimensional array used to store the matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nm\n<\n0\nor\nn\n<\n0\n, or\nif\nmode\nis not one of\nCUBLAS_SIDE_LEFT\nand\nCUBLAS_SIDE_RIGHT\n, or\nif\nlda\n<\nmax(1,\nm)\n, or\nif\nldc\n<\nmax(1,\nm)\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\n2.8.3.\ncublas<t>getrfBatched()\n\ncublasStatus_t\ncublasSgetrfBatched\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nfloat\n*\nconst\nAarray\n[],\nint\nlda\n,\nint\n*\nPivotArray\n,\nint\n*\ninfoArray\n,\nint\nbatchSize\n);\ncublasStatus_t\ncublasDgetrfBatched\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\ndouble\n*\nconst\nAarray\n[],\nint\nlda\n,\nint\n*\nPivotArray\n,\nint\n*\ninfoArray\n,\nint\nbatchSize\n);\ncublasStatus_t\ncublasCgetrfBatched\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\ncuComplex\n*\nconst\nAarray\n[],\nint\nlda\n,\nint\n*\nPivotArray\n,\nint\n*\ninfoArray\n,\nint\nbatchSize\n);\ncublasStatus_t\ncublasZgetrfBatched\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\ncuDoubleComplex\n*\nconst\nAarray\n[],\nint\nlda\n,\nint\n*\nPivotArray\n,\nint\n*\ninfoArray\n,\nint\nbatchSize\n);\nAarray\nis an array of pointers to matrices stored in column-major format with dimensions\nnxn\nand leading dimension\nlda\n.\nThis function performs the LU factorization of each\nAarray[i]\nfor i = 0, …,\nbatchSize-1\nby the following equation\n\\(\\text{P}\\text{*}{Aarray}\\lbrack i\\rbrack = L\\text{*}U\\)\nwhere\nP\nis a permutation matrix which represents partial pivoting with row interchanges.\nL\nis a lower triangular matrix with unit diagonal and\nU\nis an upper triangular matrix.\nFormally\nP\nis written by a product of permutation matrices\nPj\n, for\nj\n=\n1,2,...,n\n, say\nP\n=\nP1\n*\nP2\n*\nP3\n*\n....\n*\nPn\n.\nPj\nis a permutation matrix which interchanges two rows of vector x when performing\nPj*x\n.\nPj\ncan be constructed by\nj\nelement of\nPivotArray[i]\nby the following Matlab code\n// In Matlab PivotArray[i] is an array of base-1.\n// In C, PivotArray[i] is base-0.\nPj\n=\neye\n(\nn\n);\nswap\nPj\n(\nj\n,\n:\n)\nand\nPj\n(\nPivotArray\n[\ni\n][\nj\n]\n,\n:\n)\nL\nand\nU\nare written back to original matrix\nA\n, and diagonal elements of\nL\nare discarded. The\nL\nand\nU\ncan be constructed by the following Matlab code\n// A is a matrix of nxn after getrf.\nL\n=\neye\n(\nn\n);\nfor\nj\n=\n1\n:\nn\nL\n(\nj\n+\n1\n:\nn\n,\nj\n)\n=\nA\n(\nj\n+\n1\n:\nn\n,\nj\n)\nend\nU\n=\nzeros\n(\nn\n);\nfor\ni\n=\n1\n:\nn\nU\n(\ni\n,\ni\n:\nn\n)\n=\nA\n(\ni\n,\ni\n:\nn\n)\nend\nIf matrix\nA(=Aarray[i])\nis singular, getrf still works and the value of\ninfo(=infoArray[i])\nreports first row index that LU factorization cannot proceed. If info is\nk\n,\nU(k,k)\nis zero. The equation\nP*A\n==\nL*U\nstill holds, however\nL\nand\nU\nreconstruction needs a different Matlab code as follows:\n// A is a matrix of nxn after getrf.\n// info is k, which means U(k,k) is zero.\nL\n=\neye\n(\nn\n);\nfor\nj\n=\n1\n:\nk\n-1\nL\n(\nj\n+\n1\n:\nn\n,\nj\n)\n=\nA\n(\nj\n+\n1\n:\nn\n,\nj\n)\nend\nU\n=\nzeros\n(\nn\n);\nfor\ni\n=\n1\n:\nk\n-1\nU\n(\ni\n,\ni\n:\nn\n)\n=\nA\n(\ni\n,\ni\n:\nn\n)\nend\nfor\ni\n=\nk\n:\nn\nU\n(\ni\n,\nk\n:\nn\n)\n=\nA\n(\ni\n,\nk\n:\nn\n)\nend\nThis function is intended to be used for matrices of small sizes where the launch overhead is a significant factor.\ncublas<t>getrfBatched supports non-pivot LU factorization if\nPivotArray\nis NULL.\ncublas<t>getrfBatched supports arbitrary dimension.\ncublas<t>getrfBatched only supports compute capability 2.0 or above.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nn\ninput\nNumber of rows and columns of\nAarray[i]\n.\nAarray\ndevice\ninput/output\nArray of pointers to <\ntype\n> array, with each array of dim.\nn\nx\nn\nwith\nlda\n>=\nmax(1,\nn)\n. Matrices\nAarray[i]\nshould not overlap; otherwise, undefined behavior is expected.\nlda\ninput\nLeading dimension of two-dimensional array used to store each matrix\nAarray[i]\n.\nPivotArray\ndevice\noutput\nArray of size\nn\nx\nbatchSize\nthat contains the pivoting sequence of each factorization of\nAarray[i]\nstored in a linear fashion. If\nPivotArray\nis NULL, pivoting is disabled.\ninfoArray\ndevice\noutput\nArray of size\nbatchSize\nthat info(=infoArray[i]) contains the information of factorization of\nAarray[i]\n.\nIf\ninfo\n==\n0\n, the execution is successful.\nIf\ninfo\n=\n-j\n, the\nj\n-th parameter had an illegal value.\nIf\ninfo\n=\nk\n,\nU(k,\nk)\n==\n0\n. The factorization has been completed, but U is exactly singular.\nbatchSize\ninput\nNumber of pointers contained in A\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nThe parameters\nn\n<\n0\nor\nbatchSize\n<\n0\nor\nlda\n<0\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nsgeqrf()\n,\ndgeqrf()\n,\ncgeqrf()\n,\nzgeqrf()\n2.8.4.\ncublas<t>getrsBatched()\n\ncublasStatus_t\ncublasSgetrsBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nnrhs\n,\nconst\nfloat\n*\nconst\nAarray\n[],\nint\nlda\n,\nconst\nint\n*\ndevIpiv\n,\nfloat\n*\nconst\nBarray\n[],\nint\nldb\n,\nint\n*\ninfo\n,\nint\nbatchSize\n);\ncublasStatus_t\ncublasDgetrsBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nnrhs\n,\nconst\ndouble\n*\nconst\nAarray\n[],\nint\nlda\n,\nconst\nint\n*\ndevIpiv\n,\ndouble\n*\nconst\nBarray\n[],\nint\nldb\n,\nint\n*\ninfo\n,\nint\nbatchSize\n);\ncublasStatus_t\ncublasCgetrsBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nnrhs\n,\nconst\ncuComplex\n*\nconst\nAarray\n[],\nint\nlda\n,\nconst\nint\n*\ndevIpiv\n,\ncuComplex\n*\nconst\nBarray\n[],\nint\nldb\n,\nint\n*\ninfo\n,\nint\nbatchSize\n);\ncublasStatus_t\ncublasZgetrsBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nnrhs\n,\nconst\ncuDoubleComplex\n*\nconst\nAarray\n[],\nint\nlda\n,\nconst\nint\n*\ndevIpiv\n,\ncuDoubleComplex\n*\nconst\nBarray\n[],\nint\nldb\n,\nint\n*\ninfo\n,\nint\nbatchSize\n);\nThis function solves an array of systems of linear equations of the form:\n\\(\\text{op}(A\\lbrack i \\rbrack) X\\lbrack i\\rbrack = B\\lbrack i\\rbrack\\)\nwhere\n\\(A\\lbrack i\\rbrack\\)\nis a matrix which has been LU factorized with pivoting,\n\\(X\\lbrack i\\rbrack\\)\nand\n\\(B\\lbrack i\\rbrack\\)\nare\n\\(n \\times {nrhs}\\)\nmatrices. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A\\lbrack i\\rbrack) = \\left\\{ \\begin{matrix}\n{A\\lbrack i\\rbrack} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\n{A^{T}\\lbrack i\\rbrack} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\n{A^{H}\\lbrack i\\rbrack} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nThis function is intended to be used for matrices of small sizes where the launch overhead is a significant factor.\ncublas<t>getrsBatched()\nsupports non-pivot LU factorization if\ndevIpiv\nis NULL.\ncublas<t>getrsBatched()\nsupports arbitrary dimension.\ncublas<t>getrsBatched()\nonly supports compute capability 2.0 or above.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\ntrans\ninput\nOperation op(\nA\n) that is non- or (conj.) transpose.\nn\ninput\nNumber of rows and columns of\nAarray[i]\n.\nnrhs\ninput\nNumber of columns of\nBarray[i]\n.\nAarray\ndevice\ninput\nArray of pointers to <\ntype\n> array, with each array of dim.\nn\nx\nn\nwith\nlda\n>=\nmax(1,\nn)\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store each matrix\nAarray[i]\n.\ndevIpiv\ndevice\ninput\nArray of size\nn\nx\nbatchSize\nthat contains the pivoting sequence of each factorization of\nAarray[i]\nstored in a linear fashion. If\ndevIpiv\nis NULL, pivoting for all\nAarray[i]\nis ignored.\nBarray\ndevice\ninput/output\nArray of pointers to <\ntype\n> array, with each array of dim.\nn\nx\nnrhs\nwith\nldb\n>=\nmax(1,\nn)\n. Matrices\nBarray[i]\nshould not overlap; otherwise, undefined behavior is expected.\nldb\ninput\nLeading dimension of two-dimensional array used to store each solution matrix\nBarray[i]\n.\ninfo\nhost\noutput\nIf\ninfo\n==\n0\n, the execution is successful.\nIf\ninfo\n=\n-j\n, the\nj\n-th parameter had an illegal value.\nbatchSize\ninput\nNumber of pointers contained in A\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\nor\nnrhs\n<\n0\n, or\nif\ntrans\nis not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\nand\nCUBLAS_OP_C\n, or\nif\nlda\n<\nmax(1,\nn)\n, or\nif\nldb\n<\nmax(1,\nn)\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nsgeqrs()\n,\ndgeqrs()\n,\ncgeqrs()\n,\nzgeqrs()\n2.8.5.\ncublas<t>getriBatched()\n\ncublasStatus_t\ncublasSgetriBatched\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\nfloat\n*\nconst\nAarray\n[],\nint\nlda\n,\nint\n*\nPivotArray\n,\nfloat\n*\nconst\nCarray\n[],\nint\nldc\n,\nint\n*\ninfoArray\n,\nint\nbatchSize\n);\ncublasStatus_t\ncublasDgetriBatched\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ndouble\n*\nconst\nAarray\n[],\nint\nlda\n,\nint\n*\nPivotArray\n,\ndouble\n*\nconst\nCarray\n[],\nint\nldc\n,\nint\n*\ninfoArray\n,\nint\nbatchSize\n);\ncublasStatus_t\ncublasCgetriBatched\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ncuComplex\n*\nconst\nAarray\n[],\nint\nlda\n,\nint\n*\nPivotArray\n,\ncuComplex\n*\nconst\nCarray\n[],\nint\nldc\n,\nint\n*\ninfoArray\n,\nint\nbatchSize\n);\ncublasStatus_t\ncublasZgetriBatched\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nconst\nAarray\n[],\nint\nlda\n,\nint\n*\nPivotArray\n,\ncuDoubleComplex\n*\nconst\nCarray\n[],\nint\nldc\n,\nint\n*\ninfoArray\n,\nint\nbatchSize\n);\nAarray\nand\nCarray\nare arrays of pointers to matrices stored in column-major format with dimensions\nn*n\nand leading dimension\nlda\nand\nldc\nrespectively.\nThis function performs the inversion of matrices\nA[i]\nfor i = 0, …,\nbatchSize-1\n.\nPrior to calling cublas<t>getriBatched, the matrix\nA[i]\nmust be factorized first using the routine cublas<t>getrfBatched. After the call of cublas<t>getrfBatched, the matrix pointing by\nAarray[i]\nwill contain the LU factors of the matrix\nA[i]\nand the vector pointing by\n(PivotArray+i)\nwill contain the pivoting sequence.\nFollowing the LU factorization, cublas<t>getriBatched uses forward and backward triangular solvers to complete inversion of matrices\nA[i]\nfor i = 0, …,\nbatchSize-1\n. The inversion is out-of-place, so memory space of Carray[i] cannot overlap memory space of Array[i].\nTypically all parameters in cublas<t>getrfBatched would be passed into cublas<t>getriBatched. For example,\n// step 1: perform in-place LU decomposition, P*A = L*U.\n//      Aarray[i] is n*n matrix A[i]\ncublasDgetrfBatched\n(\nhandle\n,\nn\n,\nAarray\n,\nlda\n,\nPivotArray\n,\ninfoArray\n,\nbatchSize\n);\n//      check infoArray[i] to see if factorization of A[i] is successful or not.\n//      Array[i] contains LU factorization of A[i]\n// step 2: perform out-of-place inversion, Carray[i] = inv(A[i])\ncublasDgetriBatched\n(\nhandle\n,\nn\n,\nAarray\n,\nlda\n,\nPivotArray\n,\nCarray\n,\nldc\n,\ninfoArray\n,\nbatchSize\n);\n//      check infoArray[i] to see if inversion of A[i] is successful or not.\nThe user can check singularity from either cublas<t>getrfBatched or cublas<t>getriBatched.\nThis function is intended to be used for matrices of small sizes where the launch overhead is a significant factor.\nIf cublas<t>getrfBatched is performed by non-pivoting,\nPivotArray\nof cublas<t>getriBatched should be NULL.\ncublas<t>getriBatched supports arbitrary dimension.\ncublas<t>getriBatched only supports compute capability 2.0 or above.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nn\ninput\nNumber of rows and columns of\nAarray[i]\n.\nAarray\ndevice\ninput\nArray of pointers to <\ntype\n> array, with each array of dimension\nn*n\nwith\nlda\n>=\nmax(1,\nn)\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store each matrix\nAarray[i]\n.\nPivotArray\ndevice\noutput\nArray of size\nn*batchSize\nthat contains the pivoting sequence of each factorization of\nAarray[i]\nstored in a linear fashion. If\nPivotArray\nis NULL, pivoting is disabled.\nCarray\ndevice\noutput\nArray of pointers to <\ntype\n> array, with each array of dimension\nn*n\nwith\nldc\n>=\nmax(1,\nn)\n. Matrices\nCarray[i]\nshould not overlap; otherwise, undefined behavior is expected.\nldc\ninput\nLeading dimension of two-dimensional array used to store each matrix\nCarray[i]\n.\ninfoArray\ndevice\noutput\nArray of size\nbatchSize\nthat info(=infoArray[i]) contains the information of inversion of\nA[i]\n.\nIf\ninfo\n==\n0\n, the execution is successful.\nIf\ninfo\n==\nk\n,\nU(k,\nk)\n==\n0\n. The U is exactly singular and the inversion failed.\nbatchSize\ninput\nNumber of pointers contained in A\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\nor\nlda\n<\n0\nor\nldc\n<\n0\nor\nbatchSize\n<\n0\n, or\nif\nlda\n<\nn\nor\nldc\n<\nn\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\n2.8.6.\ncublas<t>matinvBatched()\n\ncublasStatus_t\ncublasSmatinvBatched\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\nfloat\n*\nconst\nA\n[],\nint\nlda\n,\nfloat\n*\nconst\nAinv\n[],\nint\nlda_inv\n,\nint\n*\ninfo\n,\nint\nbatchSize\n);\ncublasStatus_t\ncublasDmatinvBatched\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ndouble\n*\nconst\nA\n[],\nint\nlda\n,\ndouble\n*\nconst\nAinv\n[],\nint\nlda_inv\n,\nint\n*\ninfo\n,\nint\nbatchSize\n);\ncublasStatus_t\ncublasCmatinvBatched\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ncuComplex\n*\nconst\nA\n[],\nint\nlda\n,\ncuComplex\n*\nconst\nAinv\n[],\nint\nlda_inv\n,\nint\n*\ninfo\n,\nint\nbatchSize\n);\ncublasStatus_t\ncublasZmatinvBatched\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nconst\nA\n[],\nint\nlda\n,\ncuDoubleComplex\n*\nconst\nAinv\n[],\nint\nlda_inv\n,\nint\n*\ninfo\n,\nint\nbatchSize\n);\nA\nand\nAinv\nare arrays of pointers to matrices stored in column-major format with dimensions\nn*n\nand leading dimension\nlda\nand\nlda_inv\nrespectively.\nThis function performs the inversion of matrices\nA[i]\nfor i = 0, …,\nbatchSize-1\n.\nThis function is a short cut of\ncublas<t>getrfBatched()\nplus\ncublas<t>getriBatched()\n. However it doesn’t work if\nn\nis greater than 32. If not, the user has to go through\ncublas<t>getrfBatched()\nand\ncublas<t>getriBatched()\n.\nIf the matrix\nA[i]\nis singular, then\ninfo[i]\nreports singularity, the same as\ncublas<t>getrfBatched()\n.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nn\ninput\nNumber of rows and columns of\nA[i]\n.\nA\ndevice\ninput\nArray of pointers to <\ntype\n> array, with each array of dimension\nn*n\nwith\nlda\n>=\nmax(1,\nn)\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store each matrix\nA[i]\n.\nAinv\ndevice\noutput\nArray of pointers to <\ntype\n> array, with each array of dimension\nn*n\nwith\nlda_inv\n>=\nmax(1,\nn)\n. Matrices\nAinv[i]\nshould not overlap; otherwise, undefined behavior is expected.\nlda_inv\ninput\nLeading dimension of two-dimensional array used to store each matrix\nAinv[i]\n.\ninfo\ndevice\noutput\nArray of size\nbatchSize\nthat info[i] contains the information of inversion of\nA[i]\n.\nIf\ninfo[i]\n==\n0\n, the execution is successful.\nIf\ninfo[i]\n==\nk\n, then\nU(k,\nk)\n==\n0\n. The U is exactly singular and the inversion failed.\nbatchSize\ninput\nNumber of pointers contained in\nA\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\nor\nlda\n<\n0\nor\nlda_inv\n<\n0\nor\nbatchSize\n<\n0\n, or\nif\nlda\n<\nn\nor\nlda_inv\n<\nn\n, or\nif\nn\n>\n32\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\n2.8.7.\ncublas<t>geqrfBatched()\n\ncublasStatus_t\ncublasSgeqrfBatched\n(\ncublasHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nfloat\n*\nconst\nAarray\n[],\nint\nlda\n,\nfloat\n*\nconst\nTauArray\n[],\nint\n*\ninfo\n,\nint\nbatchSize\n);\ncublasStatus_t\ncublasDgeqrfBatched\n(\ncublasHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\ndouble\n*\nconst\nAarray\n[],\nint\nlda\n,\ndouble\n*\nconst\nTauArray\n[],\nint\n*\ninfo\n,\nint\nbatchSize\n);\ncublasStatus_t\ncublasCgeqrfBatched\n(\ncublasHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\ncuComplex\n*\nconst\nAarray\n[],\nint\nlda\n,\ncuComplex\n*\nconst\nTauArray\n[],\nint\n*\ninfo\n,\nint\nbatchSize\n);\ncublasStatus_t\ncublasZgeqrfBatched\n(\ncublasHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\ncuDoubleComplex\n*\nconst\nAarray\n[],\nint\nlda\n,\ncuDoubleComplex\n*\nconst\nTauArray\n[],\nint\n*\ninfo\n,\nint\nbatchSize\n);\nAarray\nis an array of pointers to matrices stored in column-major format with dimensions\nm\nx\nn\nand leading dimension\nlda\n.\nTauArray\nis an array of pointers to vectors of dimension of at least\nmax\n(1,\nmin(m,\nn)\n.\nThis function performs the QR factorization of each\nAarray[i]\nfor\ni\n=\n0,\n...,batchSize-1\nusing Householder reflections. Each matrix\nQ[i]\nis represented as a product of elementary reflectors and is stored in the lower part of each\nAarray[i]\nas follows :\nQ[j] = H[j][1] H[j][2] . . . H[j](k), where k = min(m,n).\nEach H[j][i] has the form\nH[j][i] = I - tau[j] * v * v'\nwhere\ntau[j]\nis a real scalar, and\nv\nis a real vector with\nv(1:i-1)\n=\n0\nand\nv(i)\n=\n1\n;\nv(i+1:m)\nis stored on exit in\nAarray[j][i+1:m,i]\n, and\ntau\nin\nTauArray[j][i]\n.\nThis function is intended to be used for matrices of small sizes where the launch overhead is a significant factor.\ncublas<t>geqrfBatched supports arbitrary dimension.\ncublas<t>geqrfBatched only supports compute capability 2.0 or above.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nm\ninput\nNumber of rows\nAarray[i]\n.\nn\ninput\nNumber of columns of\nAarray[i]\n.\nAarray\ndevice\ninput\nArray of pointers to <\ntype\n> array, with each array of dim.\nm\nx\nn\nwith\nlda\n>=\nmax(1,\nm)\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store each matrix\nAarray[i]\n.\nTauArray\ndevice\noutput\nArray of pointers to <\ntype\n> vector, with each vector of dim.\nmax(1\n,min(m,\nn))\n.\ninfo\nhost\noutput\nIf\ninfo\n==\n0\n, the parameters passed to the function are valid\nIf\ninfo\n<\n0\n, the parameter in postion\n-info\nis invalid\nbatchSize\ninput\nNumber of pointers contained in\nAarray\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nm\n<\n0\nor\nn\n<\n0\nor\nbatchSize\n<\n0\n, or\nif\nlda\n<\nmax(1,\nm)\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nsgeqrf()\n,\ndgeqrf()\n,\ncgeqrf()\n,\nzgeqrf()\n2.8.8.\ncublas<t>gelsBatched()\n\ncublasStatus_t\ncublasSgelsBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\nfloat\n*\nconst\nAarray\n[],\nint\nlda\n,\nfloat\n*\nconst\nCarray\n[],\nint\nldc\n,\nint\n*\ninfo\n,\nint\n*\ndevInfoArray\n,\nint\nbatchSize\n);\ncublasStatus_t\ncublasDgelsBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ndouble\n*\nconst\nAarray\n[],\nint\nlda\n,\ndouble\n*\nconst\nCarray\n[],\nint\nldc\n,\nint\n*\ninfo\n,\nint\n*\ndevInfoArray\n,\nint\nbatchSize\n);\ncublasStatus_t\ncublasCgelsBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ncuComplex\n*\nconst\nAarray\n[],\nint\nlda\n,\ncuComplex\n*\nconst\nCarray\n[],\nint\nldc\n,\nint\n*\ninfo\n,\nint\n*\ndevInfoArray\n,\nint\nbatchSize\n);\ncublasStatus_t\ncublasZgelsBatched\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ncuDoubleComplex\n*\nconst\nAarray\n[],\nint\nlda\n,\ncuDoubleComplex\n*\nconst\nCarray\n[],\nint\nldc\n,\nint\n*\ninfo\n,\nint\n*\ndevInfoArray\n,\nint\nbatchSize\n);\nAarray\nis an array of pointers to matrices stored in column-major format.\nCarray\nis an array of pointers to matrices stored in column-major format.\nThis function find the least squares solution of a batch of overdetermined systems: it solves the least squares problem described as follows :\nminimize\n||\nCarray\n[\ni\n]\n-\nAarray\n[\ni\n]\n*\nXarray\n[\ni\n]\n||\n,\nwith\ni\n=\n0\n,\n...,\nbatchSize\n-1\nOn exit, each\nAarray[i]\nis overwritten with their QR factorization and each\nCarray[i]\nis overwritten with the least square solution\ncublas<t>gelsBatched supports only the non-transpose operation and only solves over-determined systems (m >= n).\ncublas<t>gelsBatched only supports compute capability 2.0 or above.\nThis function is intended to be used for matrices of small sizes where the launch overhead is a significant factor.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\ntrans\ninput\nOperation op(\nAarray[i]\n) that is non- or (conj.) transpose. Only non-transpose operation is currently supported.\nm\ninput\nNumber of rows of each\nAarray[i]\nand\nCarray[i]\nif\ntrans\n==\nCUBLAS_OP_N\n, numbers of columns of each\nAarray[i]\notherwise (not supported currently).\nn\ninput\nNumber of columns of each\nAarray[i]\nif\ntrans\n==\nCUBLAS_OP_N\n, and number of rows of each\nAarray[i]\nand\nCarray[i]\notherwise (not supported currently).\nnrhs\ninput\nNumber of columns of each\nCarray[i]\n.\nAarray\ndevice\ninput/output\nArray of pointers to <\ntype\n> array, with each array of dim.\nm\nx\nn\nwith\nlda\n>=\nmax(1,\nm)\nif\ntrans\n==\nCUBLAS_OP_N\n, and\nn\nx\nm\nwith\nlda\n>=\nmax(1,\nn)\notherwise (not supported currently). Matrices\nAarray[i]\nshould not overlap; otherwise, behavior is undefined.\nlda\ninput\nLeading dimension of two-dimensional array used to store each matrix\nAarray[i]\n.\nCarray\ndevice\ninput/output\nArray of pointers to <\ntype\n> array, with each array of dim.\nm\nx\nnrhs\nwith\nldc\n>=\nmax(1,\nm)\nif\ntrans\n==\nCUBLAS_OP_N\n, and\nn\nx\nnrhs\nwith\nlda\n>=\nmax(1,\nn)\notherwise (not supported currently). Matrices\nCarray[i]\nshould not overlap; otherwise, behavior is undefined.\nldc\ninput\nLeading dimension of two-dimensional array used to store each matrix\nCarray[i]\n.\ninfo\nhost\noutput\nIf\ninfo\n==\n0\nthe parameters passed to the function are valid\nIf\ninfo\n<\n0\nthe parameter in position\n-info\nis invalid\ndevInfoArray\ndevice\noutput\nOptional array of integers of dimension batchsize.\nIf non-null, every element of\ndevInfoArray[i]\n==\nV\nhas the following meaning:\nV\n==\n0\n: the\ni\n-th problem was sucessfully solved\nV\n>\n0\n: the\nV\n-th diagonal element of the\nAarray[i]\nis zero.\nAarray[i]\ndoes not have full rank.\nbatchSize\ninput\nNumber of pointers contained in Aarray and Carray\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nm\n<\n0\nor\nn\n<\n0\nor\nnrhs\n<\n0\nor\nbatchSize\n<\n0\nor\nif\nlda\n<\nmax(1,\nm)\nor\nldc\n<\nmax(1,\nm)\nCUBLAS_STATUS_NOT_SUPPORTED\nThe parameters\nm\n<n\nor\ntrans\nis different from non-transpose.\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nsgels()\n,\ndgels()\n,\ncgels()\n,\nzgels()\n2.8.9.\ncublas<t>tpttr()\n\ncublasStatus_t\ncublasStpttr\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\nfloat\n*\nAP\n,\nfloat\n*\nA\n,\nint\nlda\n);\ncublasStatus_t\ncublasDtpttr\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ndouble\n*\nAP\n,\ndouble\n*\nA\n,\nint\nlda\n);\ncublasStatus_t\ncublasCtpttr\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuComplex\n*\nAP\n,\ncuComplex\n*\nA\n,\nint\nlda\n);\ncublasStatus_t\ncublasZtpttr\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\nint\nn\n,\nconst\ncuDoubleComplex\n*\nAP\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n);\nThis function performs the conversion from the triangular packed format to the triangular format\nIf\nuplo\n==\nCUBLAS_FILL_MODE_LOWER\nthen the elements of\nAP\nare copied into the lower triangular part of the triangular matrix\nA\nand the upper part of\nA\nis left untouched. If\nuplo\n==\nCUBLAS_FILL_MODE_UPPER\nthen the elements of\nAP\nare copied into the upper triangular part of the triangular matrix\nA\nand the lower part of\nA\nis left untouched.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nAP\ncontains lower or upper part of matrix\nA\n.\nn\ninput\nNumber of rows and columns of matrix\nA\n.\nAP\ndevice\ninput\n<\ntype\n> array with\n\\(A\\)\nstored in packed format.\nA\ndevice\noutput\n<\ntype\n> array of dimensions\nlda\nx\nn\n, with\nlda\n>=\nmax(1,\nn)\n. The opposite side of A is left untouched.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nlda\n<\nmax(1,\nn)\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nstpttr()\n,\ndtpttr()\n,\nctpttr()\n,\nztpttr()\n2.8.10.\ncublas<t>trttp()\n\ncublasStatus_t\ncublasStrttp\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\n*\nAP\n);\ncublasStatus_t\ncublasDtrttp\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\n*\nAP\n);\ncublasStatus_t\ncublasCtrttp\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\ncuComplex\n*\nAP\n);\ncublasStatus_t\ncublasZtrttp\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ncuDoubleComplex\n*\nAP\n);\nThis function performs the conversion from the triangular format to the triangular packed format\nIf\nuplo\n==\nCUBLAS_FILL_MODE_LOWER\nthen the lower triangular part of the triangular matrix\nA\nis copied into the array\nAP\n. If\nuplo\n==\nCUBLAS_FILL_MODE_UPPER\nthen then the upper triangular part of the triangular matrix\nA\nis copied into the array\nAP\n.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates which matrix\nA\nlower or upper part is referenced.\nn\ninput\nNumber of rows and columns of matrix\nA\n.\nA\ndevice\ninput\n<\ntype\n> array of dimensions\nlda\nx\nn\n, with\nlda\n>=\nmax(1,\nn)\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nAP\ndevice\noutput\n<\ntype\n> array with\nA\nstored in packed format.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\nor\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\nlda\n<\nmax(1,\nn)\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nstrttp()\n,\ndtrttp()\n,\nctrttp()\n,\nztrttp()\n2.8.11.\ncublas<t>gemmEx()\n\ncublasStatus_t\ncublasSgemmEx\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\nfloat\n*\nalpha\n,\nconst\nvoid\n*\nA\n,\ncudaDataType_t\nAtype\n,\nint\nlda\n,\nconst\nvoid\n*\nB\n,\ncudaDataType_t\nBtype\n,\nint\nldb\n,\nconst\nfloat\n*\nbeta\n,\nvoid\n*\nC\n,\ncudaDataType_t\nCtype\n,\nint\nldc\n)\ncublasStatus_t\ncublasCgemmEx\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\nvoid\n*\nA\n,\ncudaDataType_t\nAtype\n,\nint\nlda\n,\nconst\nvoid\n*\nB\n,\ncudaDataType_t\nBtype\n,\nint\nldb\n,\nconst\ncuComplex\n*\nbeta\n,\nvoid\n*\nC\n,\ncudaDataType_t\nCtype\n,\nint\nldc\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function is an extension of\ncublas<t>gemm()\n. In this function the input matrices and output matrices can have a lower precision but the computation is still done in the type\n<t>\n. For example, in the type\nfloat\nfor\ncublasSgemmEx()\nand in the type\ncuComplex\nfor\ncublasCgemmEx()\n.\n\\(C = \\alpha\\text{op}(A)\\text{op}(B) + \\beta C\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars, and\n\\(A\\)\n,\n\\(B\\)\nand\n\\(C\\)\nare matrices stored in column-major format with dimensions\n\\(\\text{op}(A)\\)\n\\(m \\times k\\)\n,\n\\(\\text{op}(B)\\)\n\\(k \\times n\\)\nand\n\\(C\\)\n\\(m \\times n\\)\n, respectively. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\nA^{H} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nand\n\\(\\text{op}(B)\\)\nis defined similarly for matrix\n\\(B\\)\n.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\ntransa\ninput\nOperation op(\nA\n) that is non- or (conj.) transpose.\ntransb\ninput\nOperation op(\nB\n) that is non- or (conj.) transpose.\nm\ninput\nNumber of rows of matrix op(\nA\n) and\nC\n.\nn\ninput\nNumber of columns of matrix op(\nB\n) and\nC\n.\nk\ninput\nNumber of columns of op(\nA\n) and rows of op(\nB\n).\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nA\ndevice\ninput\n<\ntype\n> array of dimensions\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nm)\nif\ntransa\n==\nCUBLAS_OP_N\nand\nlda\nx\nm\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nAtype\ninput\nEnumerant specifying the datatype of matrix\nA\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store the matrix\nA\n.\nB\ndevice\ninput\n<\ntype\n> array of dimension\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nk)\nif\ntransb\n==\nCUBLAS_OP_N\nand\nldb\nx\nk\nwith\nldb\n>=\nmax(1,n)\notherwise.\nBtype\ninput\nEnumerant specifying the datatype of matrix\nB\n.\nldb\ninput\nLeading dimension of two-dimensional array used to store matrix\nB\n.\nbeta\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\n,\nC\ndoes not have to be a valid input.\nC\ndevice\nin/out\n<\ntype\n> array of dimensions\nldc\nx\nn\nwith\nldc\n>=\nmax(1,\nm)\n.\nCtype\ninput\nEnumerant specifying the datatype of matrix\nC\n.\nldc\ninput\nLeading dimension of a two-dimensional array used to store the matrix\nC\n.\nThe matrix types combinations supported for\ncublasSgemmEx()\nare listed below:\nC\nA/B\nCUDA_R_16BF\nCUDA_R_16BF\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_32F\nCUDA_R_8I\nCUDA_R_16BF\nCUDA_R_16F\nCUDA_R_32F\nThe matrix types combinations supported for\ncublasCgemmEx()\nare listed below :\nC\nA/B\nCUDA_C_32F\nCUDA_C_8I\nCUDA_C_32F\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_ARCH_MISMATCH\ncublasCgemmEx()\nis only supported for GPU with architecture capabilities equal or greater than 5.0\nCUBLAS_STATUS_NOT_SUPPORTED\nThe combination of the parameters\nAtype\n,\nBtype\nand\nCtype\nis not supported\nCUBLAS_STATUS_INVALID_VALUE\nIf\nm\n<\n0\nor\nn\n<\n0\nor\nk\n<\n0\n, or\nif\ntransa\nand\ntransb\nare not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_C\n,\nCUBLAS_OP_T\n, or\nif\nlda\n<\nmax(1,\nm)\nwhen\ntransa\n==\nCUBLAS_OP_N\nand\nlda\n<\nmax(1,\nk)\notherwise, or\nif\nldb\n<\nmax(1,\nk)\nwhen\ntransb\n==\nCUBLAS_OP_N\nand\nldb\n<\nmax(1,\nn)\notherwise, or\nif\nldc\n<\nmax(1,\nm)\n, or\nif\nalpha\nor\nbeta\nare NULL, or\nif\nC\nis NULL when\nbeta\nis not zero\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nsgemm()\nFor more information about the numerical behavior of some GEMM algorithms, refer to the\nGEMM Algorithms Numerical Behavior\nsection.\n2.8.12.\ncublasGemmEx()\n\ncublasStatus_t\ncublasGemmEx\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\nvoid\n*\nalpha\n,\nconst\nvoid\n*\nA\n,\ncudaDataType_t\nAtype\n,\nint\nlda\n,\nconst\nvoid\n*\nB\n,\ncudaDataType_t\nBtype\n,\nint\nldb\n,\nconst\nvoid\n*\nbeta\n,\nvoid\n*\nC\n,\ncudaDataType_t\nCtype\n,\nint\nldc\n,\ncublasComputeType_t\ncomputeType\n,\ncublasGemmAlgo_t\nalgo\n)\n#if defined(__cplusplus)\ncublasStatus_t\ncublasGemmEx\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\nvoid\n*\nalpha\n,\nconst\nvoid\n*\nA\n,\ncudaDataType\nAtype\n,\nint\nlda\n,\nconst\nvoid\n*\nB\n,\ncudaDataType\nBtype\n,\nint\nldb\n,\nconst\nvoid\n*\nbeta\n,\nvoid\n*\nC\n,\ncudaDataType\nCtype\n,\nint\nldc\n,\ncudaDataType\ncomputeType\n,\ncublasGemmAlgo_t\nalgo\n)\n#endif\nThis function supports the\n64-bit Integer Interface\n.\nThis function is an extension of\ncublas<t>gemm()\nthat allows the user to individually specify the data types for each of the A, B and C matrices, the precision of computation and the GEMM algorithm to be run. Supported combinations of arguments are listed further down in this section.\nNote\nThe second variant of\ncublasGemmEx()\nfunction is provided for backward compatibility with C++ applications code, where the\ncomputeType\nparameter is of\ncudaDataType\ninstead of\ncublasComputeType_t\n. C applications would still compile with the updated function signature.\nThis function is only supported on devices with compute capability 5.0 or later.\n\\(C = \\alpha\\text{op}(A)\\text{op}(B) + \\beta C\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars, and\n\\(A\\)\n,\n\\(B\\)\nand\n\\(C\\)\nare matrices stored in column-major format with dimensions\n\\(\\text{op}(A)\\)\n\\(m \\times k\\)\n,\n\\(\\text{op}(B)\\)\n\\(k \\times n\\)\nand\n\\(C\\)\n\\(m \\times n\\)\n, respectively. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\nA^{H} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nand\n\\(\\text{op}(B)\\)\nis defined similarly for matrix\n\\(B\\)\n.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\ntransa\ninput\nOperation op(\nA\n) that is non- or (conj.) transpose.\ntransb\ninput\nOperation op(\nB\n) that is non- or (conj.) transpose.\nm\ninput\nNumber of rows of matrix op(\nA\n) and\nC\n.\nn\ninput\nNumber of columns of matrix op(\nB\n) and\nC\n.\nk\ninput\nNumber of columns of op(\nA\n) and rows of op(\nB\n).\nalpha\nhost or device\ninput\nScaling factor for A*B of the type that corresponds to the computeType and Ctype, see the table below for details.\nA\ndevice\ninput\n<\ntype\n> array of dimensions\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nm)\nif\ntransa\n==\nCUBLAS_OP_N\nand\nlda\nx\nm\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nAtype\ninput\nEnumerant specifying the datatype of matrix\nA\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store the matrix\nA\n.\nB\ndevice\ninput\n<\ntype\n> array of dimension\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nk)\nif\ntransb\n==\nCUBLAS_OP_N\nand\nldb\nx\nk\nwith\nldb\n>=\nmax(1,n)\notherwise.\nBtype\ninput\nEnumerant specifying the datatype of matrix\nB\n.\nldb\ninput\nLeading dimension of two-dimensional array used to store matrix\nB\n.\nbeta\nhost or device\ninput\nScaling factor for C of the type that corresponds to the computeType and Ctype, see the table below for details. If\nbeta\n==\n0\n,\nC\ndoes not have to be a valid input.\nC\ndevice\nin/out\n<\ntype\n> array of dimensions\nldc\nx\nn\nwith\nldc\n>=\nmax(1,\nm)\n.\nCtype\ninput\nEnumerant specifying the datatype of matrix\nC\n.\nldc\ninput\nLeading dimension of a two-dimensional array used to store the matrix\nC\n.\ncomputeType\ninput\nEnumerant specifying the computation type.\nalgo\ninput\nEnumerant specifying the algorithm. See\ncublasGemmAlgo_t\n.\ncublasGemmEx()\nsupports the following Compute Type, Scale Type, Atype/Btype, and Ctype:\nCompute Type\nScale Type (alpha and beta)\nAtype/Btype\nCtype\nCUBLAS_COMPUTE_16F\nor\nCUBLAS_COMPUTE_16F_PEDANTIC\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_16F\nCUBLAS_COMPUTE_32I\nor\nCUBLAS_COMPUTE_32I_PEDANTIC\nCUDA_R_32I\nCUDA_R_8I\nCUDA_R_32I\nCUBLAS_COMPUTE_32F\nor\nCUBLAS_COMPUTE_32F_PEDANTIC\nCUDA_R_32F\nCUDA_R_16BF\nCUDA_R_16BF\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_8I\nCUDA_R_32F\nCUDA_R_16BF\nCUDA_R_32F\nCUDA_R_16F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_C_32F\nCUDA_C_8I\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nCUBLAS_COMPUTE_32F_FAST_16F\nor\nCUBLAS_COMPUTE_32F_FAST_16BF\nor\nCUBLAS_COMPUTE_32F_FAST_TF32\nor\nCUBLAS_COMPUTE_32F_EMULATED_16BFX9\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nCUBLAS_COMPUTE_64F\nor\nCUBLAS_COMPUTE_64F_PEDANTIC\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_C_64F\nCUDA_C_64F\nCUDA_C_64F\nNote\nCUBLAS_COMPUTE_32I\nand\nCUBLAS_COMPUTE_32I_PEDANTIC\ncompute types are only supported with A, B being 4-byte aligned and lda, ldb being multiples of 4. For better performance, it is also recommended that IMMA kernels requirements for a regular data ordering listed\nhere\nare met.\nThe possible error values returned by this function and their meanings are listed in the following table.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully.\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUBLAS_STATUS_ARCH_MISMATCH\ncublasGemmEx()\nis only supported for GPU with architecture capabilities equal or greater than 5.0.\nCUBLAS_STATUS_NOT_SUPPORTED\nThe combination of the parameters\nAtype\n,\nBtype\nand\nCtype\nor the algorithm,\nalgo\nis not supported.\nCUBLAS_STATUS_INVALID_VALUE\nIf\nm\n<\n0\nor\nn\n<\n0\nor\nk\n<\n0\n, or\nif\ntransa\nand\ntransb\nare not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_C\n,\nCUBLAS_OP_T\n, or\nif\nlda\n<\nmax(1,\nm)\nwhen\ntransa\n==\nCUBLAS_OP_N\nand\nlda\n<\nmax(1,\nk)\notherwise, or\nif\nldb\n<\nmax(1,\nk)\nwhen\ntransb\n==\nCUBLAS_OP_N\nand\nldb\n<\nmax(1,\nn)\notherwise, or\nif\nldc\n<\nmax(1,\nm)\n, or\nif\nalpha\nor\nbeta\nare NULL, or\nif\nC\nis NULL when\nbeta\nis not zero\nif\nAtype\nor\nBtype\nor\nCtype\nor\nalgo\nare not supported\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU.\nStarting with release 11.2, using the typed functions instead of the extension functions (cublas**Ex()) helps in reducing the binary size when linking to static cuBLAS Library.\nAlso refer to:\nsgemm.()\nFor more information about the numerical behavior of some GEMM algorithms, refer to the\nGEMM Algorithms Numerical Behavior\nsection.\n2.8.13.\ncublasGemmBatchedEx()\n\ncublasStatus_t\ncublasGemmBatchedEx\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\nvoid\n*\nalpha\n,\nconst\nvoid\n*\nconst\nAarray\n[],\ncudaDataType_t\nAtype\n,\nint\nlda\n,\nconst\nvoid\n*\nconst\nBarray\n[],\ncudaDataType_t\nBtype\n,\nint\nldb\n,\nconst\nvoid\n*\nbeta\n,\nvoid\n*\nconst\nCarray\n[],\ncudaDataType_t\nCtype\n,\nint\nldc\n,\nint\nbatchCount\n,\ncublasComputeType_t\ncomputeType\n,\ncublasGemmAlgo_t\nalgo\n)\n#if defined(__cplusplus)\ncublasStatus_t\ncublasGemmBatchedEx\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\nvoid\n*\nalpha\n,\nconst\nvoid\n*\nconst\nAarray\n[],\ncudaDataType\nAtype\n,\nint\nlda\n,\nconst\nvoid\n*\nconst\nBarray\n[],\ncudaDataType\nBtype\n,\nint\nldb\n,\nconst\nvoid\n*\nbeta\n,\nvoid\n*\nconst\nCarray\n[],\ncudaDataType\nCtype\n,\nint\nldc\n,\nint\nbatchCount\n,\ncudaDataType\ncomputeType\n,\ncublasGemmAlgo_t\nalgo\n)\n#endif\nThis function supports the\n64-bit Integer Interface\n.\nThis function is an extension of\ncublas<t>gemmBatched()\nthat performs the matrix-matrix multiplication of a batch of matrices and allows the user to individually specify the data types for each of the A, B and C matrix arrays, the precision of computation and the GEMM algorithm to be run. Like\ncublas<t>gemmBatched()\n, the batch is considered to be “uniform”, i.e. all instances have the same dimensions (m, n, k), leading dimensions (lda, ldb, ldc) and transpositions (transa, transb) for their respective A, B and C matrices. The address of the input matrices and the output matrix of each instance of the batch are read from arrays of pointers passed to the function by the caller. Supported combinations of arguments are listed further down in this section.\nNote\nThe second variant of\ncublasGemmBatchedEx()\nfunction is provided for backward compatibility with C++ applications code, where the\ncomputeType\nparameter is of\ncudaDataType\ninstead of\ncublasComputeType_t\n. C applications would still compile with the updated function signature.\n\\(C\\lbrack i\\rbrack = \\alpha\\text{op}(A\\lbrack i\\rbrack)\\text{op}(B\\lbrack i\\rbrack) + \\beta C\\lbrack i\\rbrack,\\text{ for i } \\in \\lbrack 0,batchCount - 1\\rbrack\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars, and\n\\(A\\)\n,\n\\(B\\)\nand\n\\(C\\)\nare arrays of pointers to matrices stored in column-major format with dimensions\n\\(\\text{op}(A\\lbrack i\\rbrack)\\)\n\\(m \\times k\\)\n,\n\\(\\text{op}(B\\lbrack i\\rbrack)\\)\n\\(k \\times n\\)\nand\n\\(C\\lbrack i\\rbrack\\)\n\\(m \\times n\\)\n, respectively. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\nA^{H} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nand\n\\(\\text{op}(B\\lbrack i\\rbrack)\\)\nis defined similarly for matrix\n\\(B\\lbrack i\\rbrack\\)\n.\nNote\n\\(C\\lbrack i\\rbrack\\)\nmatrices must not overlap, i.e. the individual gemm operations must be computable independently; otherwise, behavior is undefined.\nOn certain problem sizes, it might be advantageous to make multiple calls to\ncublas<t>gemm()\nin different CUDA streams, rather than use this API.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\ntransa\ninput\nOperation op(\nAarray[i]\n) that is non- or (conj.) transpose.\ntransb\ninput\nOperation op(\nBarray[i]\n) that is non- or (conj.) transpose.\nm\ninput\nNumber of rows of matrix op(\nAarray[i]\n) and\nCarray[i]\n.\nn\ninput\nNumber of columns of matrix op(\nBarray[i]\n) and\nCarray[i]\n.\nk\ninput\nNumber of columns of op(\nAarray[i]\n) and rows of op(\nBarray[i]\n).\nalpha\nhost or device\ninput\nScaling factor for matrix products of the type that corresponds to the computeType and Ctype, see the table below for details.\nAarray\ndevice\ninput\nArray of pointers to <\nAtype\n> array, with each array of dim.\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nm)\nif\ntransa\n==\nCUBLAS_OP_N\nand\nlda\nx\nm\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nAll pointers must meet certain alignment criteria. Please see below for details.\nAtype\ninput\nEnumerant specifying the datatype of\nAarray\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store the matrix\nAarray[i]\n.\nBarray\ndevice\ninput\nArray of pointers to <\nBtype\n> array, with each array of dim.\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nk)\nif\ntransb\n==\nCUBLAS_OP_N\nand\nldb\nx\nk\nwith\nldb\n>=\nmax(1,n)\notherwise.\nAll pointers must meet certain alignment criteria. Please see below for details.\nBtype\ninput\nEnumerant specifying the datatype of\nBarray\n.\nldb\ninput\nLeading dimension of two-dimensional array used to store matrix\nBarray[i]\n.\nbeta\nhost or device\ninput\nScaling factor for\nCarray\nof the type that corresponds to the computeType and Ctype, see the table below for details. If\nbeta\n==\n0\n,\nCarray[i]\ndoes not have to be a valid input.\nCarray\ndevice\nin/out\nArray of pointers to <\nCtype\n> array. It has dimensions\nldc\nx\nn\nwith\nldc\n>=\nmax(1,\nm)\n. Matrices\nCarray[i]\nshould not overlap; otherwise, the behavior is undefined.\nAll pointers must meet certain alignment criteria. Please see below for details.\nCtype\ninput\nEnumerant specifying the datatype of\nCarray\n.\nldc\ninput\nLeading dimension of a two-dimensional array used to store each matrix\nCarray[i]\n.\nbatchCount\ninput\nNumber of pointers contained in\nAarray\n,\nBarray\nand\nCarray\n.\ncomputeType\ninput\nEnumerant specifying the computation type.\nalgo\ninput\nEnumerant specifying the algorithm. See\ncublasGemmAlgo_t\n.\ncublasGemmBatchedEx()\nsupports the following Compute Type, Scale Type, Atype/Btype, and Ctype:\nCompute Type\nScale Type (alpha and beta)\nAtype/Btype\nCtype\nCUBLAS_COMPUTE_16F\nor\nCUBLAS_COMPUTE_16F_PEDANTIC\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_16F\nCUBLAS_COMPUTE_32I\nor\nCUBLAS_COMPUTE_32I_PEDANTIC\nCUDA_R_32I\nCUDA_R_8I\nCUDA_R_32I\nCUBLAS_COMPUTE_32F\nor\nCUBLAS_COMPUTE_32F_PEDANTIC\nCUDA_R_32F\nCUDA_R_16BF\nCUDA_R_16BF\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_8I\nCUDA_R_32F\nCUDA_R_16BF\nCUDA_R_32F\nCUDA_R_16F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_C_32F\nCUDA_C_8I\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nCUBLAS_COMPUTE_32F_FAST_16F\nor\nCUBLAS_COMPUTE_32F_FAST_16BF\nor\nCUBLAS_COMPUTE_32F_FAST_TF32\nor\nCUBLAS_COMPUTE_32F_EMULATED_16BFX9\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nCUBLAS_COMPUTE_64F\nor\nCUBLAS_COMPUTE_64F_PEDANTIC\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_C_64F\nCUDA_C_64F\nCUDA_C_64F\nIf\nAtype\nis\nCUDA_R_16F\nor\nCUDA_R_16BF\n, or\ncomputeType\nis any of the\nFAST\noptions, or when math mode or\nalgo\nenable fast math modes, pointers (not the pointer arrays) placed in the GPU memory must be properly aligned to avoid misaligned memory access errors. Ideally all pointers are aligned to at least 16 Bytes. Otherwise it is recommended that they meet the following rule:\nif\nk\n%\n8\n==\n0\nthen ensure\nintptr_t(ptr)\n%\n16\n==\n0\n,\nif\nk\n%\n2\n==\n0\nthen ensure\nintptr_t(ptr)\n%\n4\n==\n0\n.\nNote\nCompute types\nCUBLAS_COMPUTE_32I\nand\nCUBLAS_COMPUTE_32I_PEDANTIC\nare only supported with all pointers\nA[i]\n,\nB[i]\nbeing 4-byte aligned and lda, ldb being multiples of 4. For a better performance, it is also recommended that IMMA kernels requirements for the regular data ordering listed\nhere\nare met.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully.\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUBLAS_STATUS_ARCH_MISMATCH\ncublasGemmBatchedEx()\nis only supported for GPU with architecture capabilities equal to or greater than 5.0.\nCUBLAS_STATUS_NOT_SUPPORTED\nThe combination of the parameters\nAtype\n,\nBtype\nand\nCtype\nor the algorithm,\nalgo\nis not supported.\nCUBLAS_STATUS_INVALID_VALUE\nIf\nm\n<\n0\nor\nn\n<\n0\nor\nk\n<\n0\n, or\nif\ntransa\nand\ntransb\nare not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_C\n,\nCUBLAS_OP_T\n, or\nif\nlda\n<\nmax(1,\nm)\nwhen\ntransa\n==\nCUBLAS_OP_N\nand\nlda\n<\nmax(1,\nk)\notherwise, or\nif\nldb\n<\nmax(1,\nk)\nwhen\ntransb\n==\nCUBLAS_OP_N\nand\nldb\n<\nmax(1,\nn)\notherwise, or\nif\nldc\n<\nmax(1,\nm)\n, or\nif\nalpha\nor\nbeta\nare NULL, or\nif\nAtype\nor\nBtype\nor\nCtype\nor\nalgo\nor\ncomputeType\nis not supported\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU.\nAlso refer to:\nsgemm.()\n2.8.14.\ncublasGemmStridedBatchedEx()\n\ncublasStatus_t\ncublasGemmStridedBatchedEx\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\nvoid\n*\nalpha\n,\nconst\nvoid\n*\nA\n,\ncudaDataType_t\nAtype\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\nconst\nvoid\n*\nB\n,\ncudaDataType_t\nBtype\n,\nint\nldb\n,\nlong\nlong\nint\nstrideB\n,\nconst\nvoid\n*\nbeta\n,\nvoid\n*\nC\n,\ncudaDataType_t\nCtype\n,\nint\nldc\n,\nlong\nlong\nint\nstrideC\n,\nint\nbatchCount\n,\ncublasComputeType_t\ncomputeType\n,\ncublasGemmAlgo_t\nalgo\n)\n#if defined(__cplusplus)\ncublasStatus_t\ncublasGemmStridedBatchedEx\n(\ncublasHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\nvoid\n*\nalpha\n,\nconst\nvoid\n*\nA\n,\ncudaDataType\nAtype\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\nconst\nvoid\n*\nB\n,\ncudaDataType\nBtype\n,\nint\nldb\n,\nlong\nlong\nint\nstrideB\n,\nconst\nvoid\n*\nbeta\n,\nvoid\n*\nC\n,\ncudaDataType\nCtype\n,\nint\nldc\n,\nlong\nlong\nint\nstrideC\n,\nint\nbatchCount\n,\ncudaDataType\ncomputeType\n,\ncublasGemmAlgo_t\nalgo\n)\n#endif\nThis function supports the\n64-bit Integer Interface\n.\nThis function is an extension of\ncublas<t>gemmStridedBatched()\nthat performs the matrix-matrix multiplication of a batch of matrices and allows the user to individually specify the data types for each of the A, B and C matrices, the precision of computation and the GEMM algorithm to be run. Like\ncublas<t>gemmStridedBatched()\n, the batch is considered to be “uniform”, i.e. all instances have the same dimensions (m, n, k), leading dimensions (lda, ldb, ldc) and transpositions (transa, transb) for their respective A, B and C matrices. Input matrices A, B and output matrix C for each instance of the batch are located at fixed offsets in number of elements from their locations in the previous instance. Pointers to A, B and C matrices for the first instance are passed to the function by the user along with the offsets in number of elements - strideA, strideB and strideC that determine the locations of input and output matrices in future instances.\nNote\nThe second variant of\ncublasGemmStridedBatchedEx()\nfunction is provided for backward compatibility with C++ applications code, where the\ncomputeType\nparameter is of\ncudaDataType_t\ninstead of\ncublasComputeType_t\n. C applications would still compile with the updated function signature.\n\\(C + i*{strideC} = \\alpha\\text{op}(A + i*{strideA})\\text{op}(B + i*{strideB}) + \\beta(C + i*{strideC}),\\text{ for i } \\in \\lbrack 0,batchCount - 1\\rbrack\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars, and\n\\(A\\)\n,\n\\(B\\)\nand\n\\(C\\)\nare arrays of pointers to matrices stored in column-major format with dimensions\n\\(\\text{op}(A\\lbrack i\\rbrack)\\)\n\\(m \\times k\\)\n,\n\\(\\text{op}(B\\lbrack i\\rbrack)\\)\n\\(k \\times n\\)\nand\n\\(C\\lbrack i\\rbrack\\)\n\\(m \\times n\\)\n, respectively. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\nA^{H} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nand\n\\(\\text{op}(B\\lbrack i\\rbrack)\\)\nis defined similarly for matrix\n\\(B\\lbrack i\\rbrack\\)\n.\nNote\n\\(C\\lbrack i\\rbrack\\)\nmatrices must not overlap, i.e. the individual gemm operations must be computable independently; otherwise, the behavior is undefined.\nOn certain problem sizes, it might be advantageous to make multiple calls to\ncublas<t>gemm()\nin different CUDA streams, rather than use this API.\nNote\nIn the table below, we use\nA[i],\nB[i],\nC[i]\nas notation for A, B and C matrices in the ith instance of the batch, implicitly assuming they are respectively offsets in number of elements\nstrideA,\nstrideB,\nstrideC\naway from\nA[i-1],\nB[i-1],\nC[i-1]\n. The unit for the offset is number of elements and must not be zero .\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\ntransa\ninput\nOperation op(\nA[i]\n) that is non- or (conj.) transpose.\ntransb\ninput\nOperation op(\nB[i]\n) that is non- or (conj.) transpose.\nm\ninput\nNumber of rows of matrix op(\nA[i]\n) and\nC[i]\n.\nn\ninput\nNumber of columns of matrix op(\nB[i]\n) and\nC[i]\n.\nk\ninput\nNumber of columns of op(\nA[i]\n) and rows of op(\nB[i]\n).\nalpha\nhost or device\ninput\nScaling factor for A*B of the <\nScale Type\n> that corresponds to the computeType and Ctype, see the table below for details.\nA\ndevice\ninput\nPointer to <\nAtype\n> matrix, A, corresponds to the first instance of the batch, with dimensions\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nm)\nif\ntransa\n==\nCUBLAS_OP_N\nand\nlda\nx\nm\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nAtype\ninput\nEnumerant specifying the datatype of\nA\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store the matrix\nA[i]\n.\nstrideA\ninput\nValue of type long long int that gives the offset in number of elements between\nA[i]\nand\nA[i+1]\n.\nB\ndevice\ninput\nPointer to <\nBtype\n> matrix, B, corresponds to the first instance of the batch, with dimensions\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nk)\nif\ntransb\n==\nCUBLAS_OP_N\nand\nldb\nx\nk\nwith\nldb\n>=\nmax(1,n)\notherwise.\nBtype\ninput\nEnumerant specifying the datatype of\nB\n.\nldb\ninput\nLeading dimension of two-dimensional array used to store matrix\nB[i]\n.\nstrideB\ninput\nValue of type long long int that gives the offset in number of elements between\nB[i]\nand\nB[i+1]\n.\nbeta\nhost or device\ninput\nScaling factor for C of the <\nScale Type\n> that corresponds to the computeType and Ctype, see the table below for details. If\nbeta\n==\n0\n,\nC[i]\ndoes not have to be a valid input.\nC\ndevice\nin/out\nPointer to <\nCtype\n> matrix, C, corresponds to the first instance of the batch, with dimensions\nldc\nx\nn\nwith\nldc\n>=\nmax(1,\nm)\n. Matrices\nC[i]\nshould not overlap; otherwise, undefined behavior is expected.\nCtype\ninput\nEnumerant specifying the datatype of\nC\n.\nldc\ninput\nLeading dimension of a two-dimensional array used to store each matrix\nC[i]\n.\nstrideC\ninput\nValue of type long long int that gives the offset in number of elements between\nC[i]\nand\nC[i+1]\n.\nbatchCount\ninput\nNumber of GEMMs to perform in the batch.\ncomputeType\ninput\nEnumerant specifying the computation type.\nalgo\ninput\nEnumerant specifying the algorithm. See\ncublasGemmAlgo_t\n.\ncublasGemmStridedBatchedEx()\nsupports the following Compute Type, Scale Type, Atype/Btype, and Ctype:\nCompute Type\nScale Type (alpha and beta)\nAtype/Btype\nCtype\nCUBLAS_COMPUTE_16F\nor\nCUBLAS_COMPUTE_16F_PEDANTIC\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_16F\nCUBLAS_COMPUTE_32I\nor\nCUBLAS_COMPUTE_32I_PEDANTIC\nCUDA_R_32I\nCUDA_R_8I\nCUDA_R_32I\nCUBLAS_COMPUTE_32F\nor\nCUBLAS_COMPUTE_32F_PEDANTIC\nCUDA_R_32F\nCUDA_R_16BF\nCUDA_R_16BF\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_8I\nCUDA_R_32F\nCUDA_R_16BF\nCUDA_R_32F\nCUDA_R_16F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_C_32F\nCUDA_C_8I\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nCUBLAS_COMPUTE_32F_FAST_16F\nor\nCUBLAS_COMPUTE_32F_FAST_16BF\nor\nCUBLAS_COMPUTE_32F_FAST_TF32\nor\nCUBLAS_COMPUTE_32F_EMULATED_16BFX9\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nCUBLAS_COMPUTE_64F\nor\nCUBLAS_COMPUTE_64F_PEDANTIC\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_C_64F\nCUDA_C_64F\nCUDA_C_64F\nNote\nCompute types\nCUBLAS_COMPUTE_32I\nand\nCUBLAS_COMPUTE_32I_PEDANTIC\nare only supported with all pointers\nA[i]\n,\nB[i]\nbeing 4-byte aligned and lda, ldb being multiples of 4. For a better performance, it is also recommended that IMMA kernels requirements for the regular data ordering listed\nhere\nare met.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully.\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUBLAS_STATUS_ARCH_MISMATCH\ncublasGemmBatchedEx()\nis only supported for GPU with architecture capabilities equal or greater than 5.0.\nCUBLAS_STATUS_NOT_SUPPORTED\nThe combination of the parameters\nAtype\n,\nBtype\nand\nCtype\nor the algorithm,\nalgo\nis not supported.\nCUBLAS_STATUS_INVALID_VALUE\nIf\nm\n<\n0\nor\nn\n<\n0\nor\nk\n<\n0\n, or\nif\ntransa\nand\ntransb\nare not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_C\n,\nCUBLAS_OP_T\n, or\nif\nlda\n<\nmax(1,\nm)\nwhen\ntransa\n==\nCUBLAS_OP_N\nand\nlda\n<\nmax(1,\nk)\notherwise, or\nif\nldb\n<\nmax(1,\nk)\nwhen\ntransb\n==\nCUBLAS_OP_N\nand\nldb\n<\nmax(1,\nn)\notherwise, or\nif\nldc\n<\nmax(1,\nm)\n, or\nif\nalpha\nor\nbeta\nare NULL, or\nif\nAtype\nor\nBtype\nor\nCtype\nor\nalgo\nor\ncomputeType\nis not supported\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nAlso refer to:\nsgemm.()\n2.8.15.\ncublasGemmGroupedBatchedEx()\n\ncublasStatus_t\ncublasGemmGroupedBatchedEx\n(\ncublasHandle_t\nhandle\n,\nconst\ncublasOperation_t\ntransa_array\n[],\nconst\ncublasOperation_t\ntransb_array\n[],\nconst\nint\nm_array\n[],\nconst\nint\nn_array\n[],\nconst\nint\nk_array\n[],\nconst\nvoid\n*\nalpha_array\n,\nconst\nvoid\n*\nconst\nAarray\n[],\ncudaDataType_t\nAtype\n,\nconst\nint\nlda_array\n[],\nconst\nvoid\n*\nconst\nBarray\n[],\ncudaDataType_t\nBtype\n,\nconst\nint\nldb_array\n[],\nconst\nvoid\n*\nbeta_array\n,\nvoid\n*\nconst\nCarray\n[],\ncudaDataType_t\nCtype\n,\nconst\nint\nldc_array\n[],\nint\ngroup_count\n,\nconst\nint\ngroup_size\n[],\ncublasComputeType_t\ncomputeType\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function performs the matrix-matrix multiplication on groups of matrices. A given group is considered to be “uniform”, i.e. all instances have the same dimensions (m, n, k), leading dimensions (lda, ldb, ldc) and transpositions (transa, transb) for their respective A, B and C matrices. However, the dimensions, leading dimensions, transpositions, and scaling factors (alpha, beta) may vary between groups. The address of the input matrices and the output matrix of each instance of the batch are read from arrays of pointers passed to the function by the caller.  This is functionally equivalent to the following:\nidx\n=\n0\n;\nfor\ni\n=\n0\n:\ngroup_count\n-\n1\nfor\nj\n=\n0\n:\ngroup_size\n[\ni\n]\n-\n1\ngemmEx\n(\ntransa_array\n[\ni\n],\ntransb_array\n[\ni\n],\nm_array\n[\ni\n],\nn_array\n[\ni\n],\nk_array\n[\ni\n],\nalpha_array\n[\ni\n],\nAarray\n[\nidx\n],\nAtype\n,\nlda_array\n[\ni\n],\nBarray\n[\nidx\n],\nBtype\n,\nldb_array\n[\ni\n],\nbeta_array\n[\ni\n],\nCarray\n[\nidx\n],\nCtype\n,\nldc_array\n[\ni\n],\ncomputeType\n,\nCUBLAS_GEMM_DEFAULT\n);\nidx\n+=\n1\n;\nend\nend\nwhere\n\\(\\text{$\\mathrm{alpha\\_array}$}\\)\nand\n\\(\\text{$\\mathrm{beta\\_array}$}\\)\nare arrays of scaling factors, and\n\\(\\text{Aarray}\\)\n,\n\\(\\text{Barray}\\)\nand\n\\(\\text{Carray}\\)\nare arrays of pointers to matrices stored in column-major format.  For a given index,\n\\(\\text{idx}\\)\n, that is part of group\n\\(i\\)\n, the dimensions are:\n\\(\\text{op}(\\text{Aarray}\\lbrack\\text{idx}\\rbrack)\\)\n:\n\\(\\text{$\\mathrm{m\\_array}$}\\lbrack i\\rbrack \\times \\text{$\\mathrm{k\\_array}$}\\lbrack i\\rbrack\\)\n\\(\\text{op}(\\text{Barray}\\lbrack\\text{idx}\\rbrack)\\)\n:\n\\(\\text{$\\mathrm{k\\_array}$}\\lbrack i\\rbrack \\times \\text{$\\mathrm{n\\_array}$}\\lbrack i\\rbrack\\)\n\\(\\text{Carray}\\lbrack\\text{idx}\\rbrack\\)\n:\n\\(\\text{$\\mathrm{m\\_array}$}\\lbrack i\\rbrack \\times \\text{$\\mathrm{n\\_array}$}\\lbrack i\\rbrack\\)\nNote\nThis API takes arrays of two different lengths.  The arrays of dimensions, leading dimensions, transpositions, and scaling factors are of length\ngroup_count\nand the arrays of matrices are of length\nproblem_count\nwhere\n\\(\\text{$\\mathrm{problem\\_count}$} = \\sum_{i = 0}^{\\text{$\\mathrm{group\\_count}$} - 1} \\text{$\\mathrm{group\\_size}$}\\lbrack i\\rbrack\\)\nFor matrix\n\\(A[\\text{idx}]\\)\nin group\n\\(i\\)\n\\(\\text{op}(A[\\text{idx}]) = \\left\\{ \\begin{matrix}\nA[\\text{idx}] & {\\text{if }\\textsf{$\\mathrm{transa\\_array}\\lbrack i\\rbrack$ == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA[\\text{idx}]^{T} & {\\text{if }\\textsf{$\\mathrm{transa\\_array}\\lbrack i\\rbrack$ == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\nA[\\text{idx}]^{H} & {\\text{if }\\textsf{$\\mathrm{transa\\_array}\\lbrack i\\rbrack$ == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nand\n\\(\\text{op}(B[\\text{idx}])\\)\nis defined similarly for matrix\n\\(B[\\text{idx}]\\)\nin group\n\\(i\\)\n.\nNote\n\\(C\\lbrack\\text{idx}\\rbrack\\)\nmatrices must not overlap, that is, the individual gemm operations must be computable independently; otherwise, undefined behavior is expected.\nOn certain problem sizes, it might be advantageous to make multiple calls to\ncublasGemmBatchedEx()\nin different CUDA streams, rather than use this API.\nParam.\nMemory\nIn/out\nMeaning\nArray Length\nhandle\ninput\nHandle to the cuBLAS library context.\ntransa_array\nhost\ninput\nArray containing the operations, op(\nA[idx]\n), that is non- or (conj.) transpose for each group.\ngroup_count\ntransb_array\nhost\ninput\nArray containing the operations, op(\nB[idx]\n), that is non- or (conj.) transpose for each group.\ngroup_count\nm_array\nhost\ninput\nArray containing the number of rows of matrix op(\nA[idx]\n) and\nC[idx]\nfor each group.\ngroup_count\nn_array\nhost\ninput\nArray containing the number of columns of op(\nB[idx]\n) and\nC[idx]\nfor each group.\ngroup_count\nk_array\nhost\ninput\nArray containing the number of columns of op(\nA[idx]\n) and rows of op(\nB[idx]\n) for each group.\ngroup_count\nalpha_array\nhost\ninput\nArray containing the <\nScale Type\n> scalar used for multiplication for each group.\ngroup_count\nAarray\ndevice\ninput\nArray of pointers to <\nAtype\n> array, with each array of dim.\nlda[i]\nx\nk[i]\nwith\nlda[i]\n>=\nmax(1,m[i])\nif\ntransa[i]\n==\nCUBLAS_OP_N\nand\nlda[i]\nx\nm[i]\nwith\nlda[i]\n>=\nmax(1,k[i])\notherwise.\nAll pointers must meet certain alignment criteria. Please see below for details.\nproblem_count\nAtype\ninput\nEnumerant specifying the datatype of\nA\n.\nlda_array\nhost\ninput\nArray containing the leading dimensions of two-dimensional arrays used to store each matrix\nA[idx]\nfor each group.\ngroup_count\nBarray\ndevice\ninput\nArray of pointers to <\nBtype\n> array, with each array of dim.\nldb[i]\nx\nn[i]\nwith\nldb[i]\n>=\nmax(1,k[i])\nif\ntransb[i]\n==\nCUBLAS_OP_N\nand\nldb[i]\nx\nk[i]\nwith\nldb[i]\n>=\nmax(1,n[i])\notherwise.\nAll pointers must meet certain alignment criteria. Please see below for details.\nproblem_count\nBtype\ninput\nEnumerant specifying the datatype of\nB\n.\nldb_array\nhost\ninput\nArray containing the leading dimensions of two-dimensional arrays used to store each matrix\nB[idx]\nfor each group.\ngroup_count\nbeta_array\nhost\ninput\nArray containing the <\nScale Type\n> scalar used for multiplication for each group.\ngroup_count\nCarray\ndevice\nin/out\nArray of pointers to <\nCtype\n> array. It has dimensions\nldc[i]\nx\nn[i]\nwith\nldc[i]\n>=\nmax(1,m[i])\n. Matrices\nC[idx]\nshould not overlap; otherwise, undefined behavior is expected.\nAll pointers must meet certain alignment criteria. Please see below for details.\nproblem_count\nCtype\ninput\nEnumerant specifying the datatype of\nC\n.\nldc_array\nhost\ninput\nArray containing the leading dimensions of two-dimensional arrays used to store each matrix\nC[idx]\nfor each group.\ngroup_count\ngroup_count\nhost\ninput\nNumber of groups\ngroup_size\nhost\ninput\nArray containing the number of pointers contained in Aarray, Barray and Carray for each group.\ngroup_count\ncomputeType\ninput\nEnumerant specifying the computation type.\ncublasGemmGroupedBatchedEx()\nsupports the following Compute Type, Scale Type, Atype/Btype, and Ctype:\nCompute Type\nScale Type (alpha and beta)\nAtype/Btype\nCtype\nCUBLAS_COMPUTE_32F\nCUDA_R_32F\nCUDA_R_16BF\nCUDA_R_16BF\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_32F\nCUDA_R_32F\nCUBLAS_COMPUTE_32F_PEDANTIC\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUBLAS_COMPUTE_32F_FAST_TF32\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUBLAS_COMPUTE_64F\nor\nCUBLAS_COMPUTE_64F_PEDANTIC\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nIf\nAtype\nis\nCUDA_R_16F\nor\nCUDA_R_16BF\nor if the\ncomputeType\nis any of the\nFAST\noptions, pointers (not the pointer arrays) placed in the GPU memory must be properly aligned to avoid misaligned memory access errors. Ideally all pointers are aligned to at least 16 Bytes. Otherwise it is required that they meet the following rule:\nif\n(k\n*\nAtypeSize)\n%\n16\n==\n0\nthen ensure\nintptr_t(ptr)\n%\n16\n==\n0\n,\nif\n(k\n*\nAtypeSize)\n%\n4\n==\n0\nthen ensure\nintptr_t(ptr)\n%\n4\n==\n0\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nIf\ntransa_array\n,\ntransb_array\n,\nm_array\n,\nn_array\n,\nk_array\n,\nalpha_array\n,\nlda_array\n,\nldb_array\n,\nbeta_array\n,\nldc_array\n, or\ngroup_size\nare NULL, or\nif\ngroup_count\n<\n0\n, or\nif\nm_array[i]\n<\n0\n,\nn_array[i]\n<\n0\n,\nk_array[i]\n<\n0\n,\ngroup_size[i]\n<\n0\n, or\nif\ntransa_array[i]\nand\ntransb_array[i]\nare not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_C\n,\nCUBLAS_OP_T\n, or\nif\nlda_array[i]\n<\nmax(1,\nm_array[i])\nif\ntransa_array[i]\n==\nCUBLAS_OP_N\nand\nlda_array[i]\n<\nmax(1,\nk_array[i])\notherwise, or\nif\nldb_array[i]\n<\nmax(1,\nk_array[i])\nif\ntransb_array[i]\n==\nCUBLAS_OP_N\nand\nldb_array[i]\n<\nmax(1,\nn_array[i])\notherwise, or\nif\nldc_array[i]\n<\nmax(1,\nm_array[i])\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nCUBLAS_STATUS_NOT_SUPPORTED\nthe pointer mode is set to\nCUBLAS_POINTER_MODE_DEVICE\nAtype\nor\nBtype\nor\nCtype\nor\ncomputeType\nare not supported\n2.8.16.\ncublasCsyrkEx()\n\ncublasStatus_t\ncublasCsyrkEx\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\nvoid\n*\nA\n,\ncudaDataType\nAtype\n,\nint\nlda\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\nC\n,\ncudaDataType\nCtype\n,\nint\nldc\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function is an extension of\ncublasCsyrk()\nwhere the input matrix and output matrix can have a lower precision but the computation is still done in the type\ncuComplex\nThis function performs the symmetric rank-\n\\(k\\)\nupdate\n\\(C = \\alpha\\text{op}(A)\\text{op}(A)^{T} + \\beta C\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars,\n\\(C\\)\nis a symmetric matrix stored in lower or upper mode, and\n\\(A\\)\nis a matrix with dimensions\n\\(\\text{op}(A)\\)\n\\(n \\times k\\)\n. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\n\\end{matrix} \\right.\\)\nNote\nThis routine is only supported on GPUs with architecture capabilities equal to or greater than 5.0\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nC\nlower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements.\ntrans\ninput\nOperation op(\nA\n) that is non- or transpose.\nn\ninput\nNumber of rows of matrix op(\nA\n) and\nC\n.\nk\ninput\nNumber of columns of matrix op(\nA\n).\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nA\ndevice\ninput\n<\ntype\n> array of dimension\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nn)\nif\ntrans\n==\nCUBLAS_OP_N\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nAtype\ninput\nEnumerant specifying the datatype of matrix\nA\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix A.\nbeta\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\nthen\nC\ndoes not have to be a valid input.\nC\ndevice\nin/out\n<\ntype\n> array of dimension\nldc\nx\nn\n, with\nldc\n>=\nmax(1,\nn)\n.\nCtype\ninput\nEnumerant specifying the datatype of matrix\nC\n.\nldc\ninput\nLeading dimension of two-dimensional array used to store matrix\nC\n.\nThe matrix types combinations supported for\ncublasCsyrkEx()\nare listed below:\nA\nC\nCUDA_C_8I\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully.\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\nor\nk\n<\n0\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\ntrans\nis not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\nand\nCUBLAS_OP_C\n, or\nif\nlda\n<\nmax(1,\nn)\nif\ntrans\n==\nCUBLAS_OP_N\nand\nlda\n<\nmax(1,\nk)\notherwise, or\nif\nldc\n<\nmax(1,\nn)\n, or\nif\nAtype\nor\nCtype\nare not supported\nCUBLAS_STATUS_NOT_SUPPORTED\nThe combination of the parameters\nAtype\nand\nCtype\nis not supported.\nCUBLAS_STATUS_ARCH_MISMATCH\nThe device has a compute capability lower than 5.0.\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU.\nFor references please refer to NETLIB documentation:\nssyrk()\n,\ndsyrk()\n,\ncsyrk()\n,\nzsyrk()\n2.8.17.\ncublasCsyrk3mEx()\n\ncublasStatus_t\ncublasCsyrk3mEx\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\nvoid\n*\nA\n,\ncudaDataType\nAtype\n,\nint\nlda\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\nC\n,\ncudaDataType\nCtype\n,\nint\nldc\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function is an extension of\ncublasCsyrk()\nwhere the input matrix and output matrix can have a lower precision but the computation is still done in the type\ncuComplex\n. This routine is implemented using the Gauss complexity reduction algorithm which can lead to an increase in performance up to 25%\nThis function performs the symmetric rank-\n\\(k\\)\nupdate\n\\(C = \\alpha\\text{op}(A)\\text{op}(A)^{T} + \\beta C\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars,\n\\(C\\)\nis a symmetric matrix stored in lower or upper mode, and\n\\(A\\)\nis a matrix with dimensions\n\\(\\text{op}(A)\\)\n\\(n \\times k\\)\n. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\n\\end{matrix} \\right.\\)\nNote\nThis routine is only supported on GPUs with architecture capabilities equal to or greater than 5.0\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nC\nlower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements.\ntrans\ninput\nOperation op(\nA\n) that is non- or transpose.\nn\ninput\nNumber of rows of matrix op(\nA\n) and\nC\n.\nk\ninput\nNumber of columns of matrix op(\nA\n).\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nA\ndevice\ninput\n<\ntype\n> array of dimension\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nn)\nif\ntrans\n==\nCUBLAS_OP_N\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nAtype\ninput\nEnumerant specifying the datatype of matrix\nA\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix A.\nbeta\nhost or device\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\nthen\nC\ndoes not have to be a valid input.\nC\ndevice\nin/out\n<\ntype\n> array of dimension\nldc\nx\nn\n, with\nldc\n>=\nmax(1,\nn)\n.\nCtype\ninput\nEnumerant specifying the datatype of matrix\nC\n.\nldc\ninput\nLeading dimension of two-dimensional array used to store matrix\nC\n.\nThe matrix types combinations supported for\ncublasCsyrk3mEx()\nare listed below :\nA\nC\nCUDA_C_8I\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully.\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\nor\nk\n<\n0\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\ntrans\nis not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\nand\nCUBLAS_OP_C\n, or\nif\nlda\n<\nmax(1,\nn)\nif\ntrans\n==\nCUBLAS_OP_N\nand\nlda\n<\nmax(1,\nk)\notherwise, or\nif\nldc\n<\nmax(1,\nn)\n, or\nif\nAtype\nor\nCtype\nare not supported\nCUBLAS_STATUS_NOT_SUPPORTED\nThe combination of the parameters\nAtype\nand\nCtype\nis not supported.\nCUBLAS_STATUS_ARCH_MISMATCH\nThe device has a compute capability lower than 5.0.\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU.\nFor references please refer to NETLIB documentation:\nssyrk()\n,\ndsyrk()\n,\ncsyrk()\n,\nzsyrk()\n2.8.18.\ncublasCherkEx()\n\ncublasStatus_t\ncublasCherkEx\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\nfloat\n*\nalpha\n,\nconst\nvoid\n*\nA\n,\ncudaDataType\nAtype\n,\nint\nlda\n,\nconst\nfloat\n*\nbeta\n,\ncuComplex\n*\nC\n,\ncudaDataType\nCtype\n,\nint\nldc\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function is an extension of\ncublasCherk()\nwhere the input matrix and output matrix can have a lower precision but the computation is still done in the type\ncuComplex\nThis function performs the Hermitian rank-\n\\(k\\)\nupdate\n\\(C = \\alpha\\text{op}(A)\\text{op}(A)^{H} + \\beta C\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars,\n\\(C\\)\nis a Hermitian matrix stored in lower or upper mode, and\n\\(A\\)\nis a matrix with dimensions\n\\(\\text{op}(A)\\)\n\\(n \\times k\\)\n. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{H} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nNote\nThis routine is only supported on GPUs with architecture capabilities equal to or greater than 5.0\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nC\nlower or upper part is stored, the other Hermitian part is not referenced.\ntrans\ninput\nOperation op(\nA\n) that is non- or (conj.) transpose.\nn\ninput\nNumber of rows of matrix op(\nA\n) and\nC\n.\nk\ninput\nNumber of columns of matrix op(\nA\n).\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nA\ndevice\ninput\n<\ntype\n> array of dimension\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nn)\nif\ntransa\n==\nCUBLAS_OP_N\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nAtype\ninput\nEnumerant specifying the datatype of matrix\nA\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nbeta\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\nthen\nC\ndoes not have to be a valid input.\nC\ndevice\nin/out\n<\ntype\n> array of dimension\nldc\nx\nn\n, with\nldc\n>=\nmax(1,\nn)\n. The imaginary parts of the diagonal elements are assumed and set to zero.\nCtype\ninput\nEnumerant specifying the datatype of matrix\nC\n.\nldc\ninput\nLeading dimension of two-dimensional array used to store matrix\nC\n.\nThe matrix types combinations supported for\ncublasCherkEx()\nare listed in the following table:\nA\nC\nCUDA_C_8I\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully.\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\nor\nk\n<\n0\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\ntrans\nis not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\nand\nCUBLAS_OP_C\n, or\nif\nlda\n<\nmax(1,\nn)\nif\ntrans\n==\nCUBLAS_OP_N\nand\nlda\n<\nmax(1,\nk)\notherwise, or\nif\nldc\n<\nmax(1,\nn)\n, or\nif\nAtype\nor\nCtype\nare not supported\nCUBLAS_STATUS_NOT_SUPPORTED\nThe combination of the parameters\nAtype\nand\nCtype\nis not supported.\nCUBLAS_STATUS_ARCH_MISMATCH\nThe device has a compute capability lower than 5.0.\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU.\nFor references please refer to NETLIB documentation:\ncherk()\n2.8.19.\ncublasCherk3mEx()\n\ncublasStatus_t\ncublasCherk3mEx\n(\ncublasHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\nfloat\n*\nalpha\n,\nconst\nvoid\n*\nA\n,\ncudaDataType\nAtype\n,\nint\nlda\n,\nconst\nfloat\n*\nbeta\n,\ncuComplex\n*\nC\n,\ncudaDataType\nCtype\n,\nint\nldc\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function is an extension of\ncublasCherk()\nwhere the input matrix and output matrix can have a lower precision but the computation is still done in the type\ncuComplex\n. This routine is implemented using the Gauss complexity reduction algorithm which can lead to an increase in performance up to 25%\nThis function performs the Hermitian rank-\n\\(k\\)\nupdate\n\\(C = \\alpha\\text{op}(A)\\text{op}(A)^{H} + \\beta C\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars,\n\\(C\\)\nis a Hermitian matrix stored in lower or upper mode, and\n\\(A\\)\nis a matrix with dimensions\n\\(\\text{op}(A)\\)\n\\(n \\times k\\)\n. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{H} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nNote\nThis routine is only supported on GPUs with architecture capabilities equal to or greater than 5.0\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nuplo\ninput\nIndicates if matrix\nC\nlower or upper part is stored, the other Hermitian part is not referenced.\ntrans\ninput\nOperation op(\nA\n) that is non- or (conj.) transpose.\nn\ninput\nNumber of rows of matrix op(\nA\n) and\nC\n.\nk\ninput\nNumber of columns of matrix op(\nA\n).\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nA\ndevice\ninput\n<\ntype\n> array of dimension\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nn)\nif\ntrans\n==\nCUBLAS_OP_N\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nAtype\ninput\nEnumerant specifying the datatype of matrix\nA\n.\nlda\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nbeta\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\nthen\nC\ndoes not have to be a valid input.\nC\ndevice\nin/out\n<\ntype\n> array of dimension\nldc\nx\nn\n, with\nldc\n>=\nmax(1,\nn)\n. The imaginary parts of the diagonal elements are assumed and set to zero.\nCtype\ninput\nEnumerant specifying the datatype of matrix\nC\n.\nldc\ninput\nLeading dimension of two-dimensional array used to store matrix\nC\n.\nThe matrix types combinations supported for\ncublasCherk3mEx()\nare listed in the following table:\nA\nC\nCUDA_C_8I\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully.\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUBLAS_STATUS_INVALID_VALUE\nIf\nn\n<\n0\nor\nk\n<\n0\n, or\nif\nuplo\nis not one of\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, or\nif\ntrans\nis not one of\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\nand\nCUBLAS_OP_C\n, or\nif\nlda\n<\nmax(1,\nn)\nif\ntrans\n==\nCUBLAS_OP_N\nand\nlda\n<\nmax(1,\nk)\notherwise, or\nif\nldc\n<\nmax(1,\nn)\n, or\nif\nAtype\nor\nCtype\nare not supported\nCUBLAS_STATUS_NOT_SUPPORTED\nThe combination of the parameters\nAtype\nand\nCtype\nis not supported.\nCUBLAS_STATUS_ARCH_MISMATCH\nThe device has a compute capability lower than 5.0.\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU.\nFor references please refer to NETLIB documentation:\ncherk()\n2.8.20.\ncublasNrm2Ex()\n\ncublasStatus_t\ncublasNrm2Ex\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\nvoid\n*\nx\n,\ncudaDataType\nxType\n,\nint\nincx\n,\nvoid\n*\nresult\n,\ncudaDataType\nresultType\n,\ncudaDataType\nexecutionType\n)\nThis function supports the\n64-bit Integer Interface\n.\nThis function is an API generalization of the routine\ncublas<t>nrm2()\nwhere input data, output data and compute type can be specified independently.\nThis function computes the Euclidean norm of the vector\nx\n. The code uses a multiphase model of accumulation to avoid intermediate underflow and overflow, with the result being equivalent to\n\\(\\sqrt{\\sum_{i = 1}^{n}\\left( {\\mathbf{x}\\lbrack j\\rbrack \\times \\mathbf{x}\\lbrack j\\rbrack} \\right)}\\)\nwhere\n\\(j = 1 + \\left( {i - 1} \\right)*\\text{incx}\\)\nin exact arithmetic. Notice that the last equation reflects 1-based indexing used for compatibility with Fortran.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nn\ninput\nNumber of elements in the vector\nx\n.\nx\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nxType\ninput\nEnumerant specifying the datatype of vector\nx\n.\nincx\ninput\nStride between consecutive elements of\nx\n.\nresult\nhost or device\noutput\nThe resulting norm, which is set to\n0\nif\nn\n<=\n0\nor\nincx\n<=\n0\n.\nresultType\ninput\nEnumerant specifying the datatype of the\nresult\n.\nexecutionType\ninput\nEnumerant specifying the datatype in which the computation is executed.\nThe datatypes combinations currently supported for\ncublasNrm2Ex()\nare listed below :\nx\nresult\nexecution\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_32F\nCUDA_R_16BF\nCUDA_R_16BF\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_C_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_C_64F\nCUDA_R_64F\nCUDA_R_64F\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_ALLOC_FAILED\nThe reduction buffer could not be allocated\nCUBLAS_STATUS_NOT_SUPPORTED\nThe combination of the parameters\nxType\n,\nresultType\nand\nexecutionType\nis not supported\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nCUBLAS_STATUS_INVALID_VALUE\nIf\nxType\nor\nresultType\nor\nexecutionType\nis not supported, or\nif\nresult\nis NULL\nFor references please refer to NETLIB documentation:\nsnrm2()\n,\ndnrm2()\n,\nscnrm2()\n,\ndznrm2()\n2.8.21.\ncublasAxpyEx()\n\ncublasStatus_t\ncublasAxpyEx\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\nvoid\n*\nalpha\n,\ncudaDataType\nalphaType\n,\nconst\nvoid\n*\nx\n,\ncudaDataType\nxType\n,\nint\nincx\n,\nvoid\n*\ny\n,\ncudaDataType\nyType\n,\nint\nincy\n,\ncudaDataType\nexecutiontype\n);\nThis function supports the\n64-bit Integer Interface\n.\nThis function is an API generalization of the routine\ncublas<t>axpy()\nwhere input data, output data and compute type can be specified independently.\nThis function multiplies the vector\nx\nby the scalar\n\\(\\alpha\\)\nand adds it to the vector\ny\noverwriting the latest vector with the result. Hence, the performed operation is\n\\(\\mathbf{y}\\lbrack j\\rbrack = \\alpha \\times \\mathbf{x}\\lbrack k\\rbrack + \\mathbf{y}\\lbrack j\\rbrack\\)\nfor\n\\(i = 1,\\ldots,n\\)\n,\n\\(k = 1 + \\left( {i - 1} \\right)*\\text{incx}\\)\nand\n\\(j = 1 + \\left( {i - 1} \\right)*\\text{incy}\\)\n. Notice that the last two equations reflect 1-based indexing used for compatibility with Fortran.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nn\ninput\nNumber of elements in the vector\nx\nand\ny\n.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nalphaType\ninput\nEnumerant specifying the datatype of scalar\nalpha\n.\nx\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nxType\ninput\nEnumerant specifying the datatype of vector\nx\n.\nincx\ninput\nStride between consecutive elements of\nx\n.\ny\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nyType\ninput\nEnumerant specifying the datatype of vector\ny\n.\nincy\ninput\nStride between consecutive elements of\ny\n.\nexecutionType\ninput\nEnumerant specifying the datatype in which the computation is executed.\nThe datatypes combinations currently supported for\ncublasAxpyEx()\nare listed in the following table:\nalpha\nx\ny\nexecution\nCUDA_R_32F\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_16BF\nCUDA_R_16BF\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_64F\nCUDA_C_64F\nCUDA_C_64F\nCUDA_C_64F\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully.\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUBLAS_STATUS_NOT_SUPPORTED\nThe combination of the parameters\nxType\n,\nyType\n, and\nexecutionType\nis not supported.\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU.\nCUBLAS_STATUS_INVALID_VALUE\nalphaType\nor\nxType\nor\nyType\nor\nexecutionType\nis not supported.\nFor references please refer to NETLIB documentation:\nsaxpy()\n,\ndaxpy()\n,\ncaxpy()\n,\nzaxpy()\n2.8.22.\ncublasDotEx()\n\ncublasStatus_t\ncublasDotEx\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\nvoid\n*\nx\n,\ncudaDataType\nxType\n,\nint\nincx\n,\nconst\nvoid\n*\ny\n,\ncudaDataType\nyType\n,\nint\nincy\n,\nvoid\n*\nresult\n,\ncudaDataType\nresultType\n,\ncudaDataType\nexecutionType\n);\ncublasStatus_t\ncublasDotcEx\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\nvoid\n*\nx\n,\ncudaDataType\nxType\n,\nint\nincx\n,\nconst\nvoid\n*\ny\n,\ncudaDataType\nyType\n,\nint\nincy\n,\nvoid\n*\nresult\n,\ncudaDataType\nresultType\n,\ncudaDataType\nexecutionType\n);\nThese functions support the\n64-bit Integer Interface\n.\nThese functions are an API generalization of the routines\ncublas<t>dot()\nand\ncublas<t>dotc()\nwhere input data, output data and compute type can be specified independently. Note:\ncublas<t>dotc()\nis dot product conjugated,\ncublas<t>dotu()\nis dot product unconjugated.\nThis function computes the dot product of vectors\nx\nand\ny\n. Hence, the result is\n\\(\\sum_{i = 1}^{n}\\left( {\\mathbf{x}\\lbrack k\\rbrack \\times \\mathbf{y}\\lbrack j\\rbrack} \\right)\\)\nwhere\n\\(k = 1 + \\left( {i - 1} \\right)*\\text{incx}\\)\nand\n\\(j = 1 + \\left( {i - 1} \\right)*\\text{incy}\\)\n. Notice that in the first equation the conjugate of the element of vector x should be used if the function name ends in character ‘c’ and that the last two equations reflect 1-based indexing used for compatibility with Fortran.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nn\ninput\nNumber of elements in the vectors\nx\nand\ny\n.\nx\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nxType\ninput\nEnumerant specifying the datatype of vector\nx\n.\nincx\ninput\nStride between consecutive elements of\nx\n.\ny\ndevice\ninput\n<\ntype\n> vector with\nn\nelements.\nyType\ninput\nEnumerant specifying the datatype of vector\ny\n.\nincy\ninput\nStride between consecutive elements of\ny\n.\nresult\nhost or device\noutput\nThe resulting dot product, which is set to\n0\nif\nn\n<=\n0\nresultType\ninput\nEnumerant specifying the datatype of the\nresult\n.\nexecutionType\ninput\nEnumerant specifying the datatype in which the computation is executed.\nThe datatypes combinations currently supported for\ncublasDotEx()\nand\ncublasDotcEx()\nare listed below:\nx\ny\nresult\nexecution\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_32F\nCUDA_R_16BF\nCUDA_R_16BF\nCUDA_R_16BF\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_64F\nCUDA_C_64F\nCUDA_C_64F\nCUDA_C_64F\nThe possible error values returned by this function and their meanings are listed in the following table:\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully.\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUBLAS_STATUS_ALLOC_FAILED\nThe reduction buffer could not be allocated.\nCUBLAS_STATUS_NOT_SUPPORTED\nThe combination of the parameters\nxType\n,\nyType\n,\nresultType\nand\nexecutionType\nis not supported.\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU.\nCUBLAS_STATUS_INVALID_VALUE\nxType\nor\nyType\nor\nresultType\nor\nexecutionType\nis not supported.\nFor references please refer to NETLIB documentation:\nsdot()\n,\nddot()\n,\ncdotu()\n,\ncdotc()\n,\nzdotu()\n,\nzdotc()\n2.8.23.\ncublasRotEx()\n\ncublasStatus_t\ncublasRotEx\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nvoid\n*\nx\n,\ncudaDataType\nxType\n,\nint\nincx\n,\nvoid\n*\ny\n,\ncudaDataType\nyType\n,\nint\nincy\n,\nconst\nvoid\n*\nc\n,\n/* host or device pointer */\nconst\nvoid\n*\ns\n,\ncudaDataType\ncsType\n,\ncudaDataType\nexecutiontype\n);\nThis function supports the\n64-bit Integer Interface\n.\nThis function is an extension to the routine\ncublas<t>rot()\nwhere input data, output data, cosine/sine type, and compute type can be specified independently.\nThis function applies Givens rotation matrix (i.e., rotation in the x,y plane counter-clockwise by angle defined by\n\\(cos(alpha) = c\\)\n,\n\\(sin(alpha) = s\\)\n):\n\\(G = \\begin{pmatrix}\nc & s \\\\\n{- s} & c \\\\\n\\end{pmatrix}\\)\nto vectors\nx\nand\ny\n.\nHence, the result is\n\\(\\mathbf{x}\\lbrack k\\rbrack = c \\times \\mathbf{x}\\lbrack k\\rbrack + s \\times \\mathbf{y}\\lbrack j\\rbrack\\)\nand\n\\(\\mathbf{y}\\lbrack j\\rbrack = - s \\times \\mathbf{x}\\lbrack k\\rbrack + c \\times \\mathbf{y}\\lbrack j\\rbrack\\)\nwhere\n\\(k = 1 + \\left( {i - 1} \\right)*\\text{incx}\\)\nand\n\\(j = 1 + \\left( {i - 1} \\right)*\\text{incy}\\)\n. Notice that the last two equations reflect 1-based indexing used for compatibility with Fortran.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nn\ninput\nNumber of elements in the vectors\nx\nand\ny\n.\nx\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nxType\ninput\nEnumerant specifying the datatype of vector\nx\n.\nincx\ninput\nStride between consecutive elements of\nx\n.\ny\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nyType\ninput\nEnumerant specifying the datatype of vector\ny\n.\nincy\ninput\nStride between consecutive elements of\ny\n.\nc\nhost or device\ninput\nCosine element of the rotation matrix.\ns\nhost or device\ninput\nSine element of the rotation matrix.\ncsType\ninput\nEnumerant specifying the datatype of\nc\nand\ns\n.\nexecutionType\ninput\nEnumerant specifying the datatype in which the computation is executed.\nThe datatypes combinations currently supported for\ncublasRotEx()\nare listed below :\nexecutionType\nxType / yType\ncsType\nCUDA_R_32F\nCUDA_R_16BF\nCUDA_R_16F\nCUDA_R_32F\nCUDA_R_16BF\nCUDA_R_16F\nCUDA_R_32F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nCUDA_R_32F\nCUDA_C_32F\nCUDA_C_64F\nCUDA_C_64F\nCUDA_C_64F\nCUDA_R_64F\nCUDA_C_64F\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nsrot()\n,\ndrot()\n,\ncrot()\n,\ncsrot()\n,\nzrot()\n,\nzdrot()\n2.8.24.\ncublasScalEx()\n\ncublasStatus_t\ncublasScalEx\n(\ncublasHandle_t\nhandle\n,\nint\nn\n,\nconst\nvoid\n*\nalpha\n,\ncudaDataType\nalphaType\n,\nvoid\n*\nx\n,\ncudaDataType\nxType\n,\nint\nincx\n,\ncudaDataType\nexecutionType\n);\nThis function supports the\n64-bit Integer Interface\n.\nThis function scales the vector\nx\nby the scalar\n\\(\\alpha\\)\nand overwrites it with the result. Hence, the performed operation is\n\\(\\mathbf{x}\\lbrack j\\rbrack = \\alpha \\times \\mathbf{x}\\lbrack j\\rbrack\\)\nfor\n\\(i = 1,\\ldots,n\\)\nand\n\\(j = 1 + \\left( {i - 1} \\right)*\\text{incx}\\)\n. Notice that the last two equations reflect 1-based indexing used for compatibility with Fortran.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nHandle to the cuBLAS library context.\nn\ninput\nNumber of elements in the vector\nx\n.\nalpha\nhost or device\ninput\n<\ntype\n> scalar used for multiplication.\nalphaType\ninput\nEnumerant specifying the datatype of scalar\nalpha\n.\nx\ndevice\nin/out\n<\ntype\n> vector with\nn\nelements.\nxType\ninput\nEnumerant specifying the datatype of vector\nx\n.\nincx\ninput\nStride between consecutive elements of\nx\n.\nexecutionType\ninput\nEnumerant specifying the datatype in which the computation is executed.\nThe datatypes combinations currently supported for\ncublasScalEx()\nare listed below :\nalpha\nx\nexecution\nCUDA_R_32F\nCUDA_R_16F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_16BF\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_64F\nCUDA_C_64F\nCUDA_C_64F\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nThe library was not initialized\nCUBLAS_STATUS_NOT_SUPPORTED\nThe combination of the parameters\nxType\nand\nexecutionType\nis not supported\nCUBLAS_STATUS_EXECUTION_FAILED\nThe function failed to launch on the GPU\nCUBLAS_STATUS_INVALID_VALUE\nalphaType\nor\nxType\nor\nexecutionType\nis not supported\nFor references please refer to NETLIB documentation:\nsscal()\n,\ndscal()\n,\ncsscal()\n,\ncscal()\n,\nzdscal()\n,\nzscal()\n3.\nUsing the cuBLASLt API\n\n3.1.\nGeneral Description\n\nThe cuBLASLt library is a new lightweight library dedicated to GEneral Matrix-to-matrix Multiply (GEMM) operations with a new flexible API. This new library adds flexibility in matrix data layouts, input types, compute types, and also in choosing the algorithmic implementations and heuristics through parameter programmability.\nOnce a set of options for the intended GEMM operation are identified by the user, these options can be used repeatedly for different inputs. This is analogous to how cuFFT and FFTW first create a plan and reuse for same size and type FFTs with different input data.\nNote\nThe cuBLASLt library does not guarantee the support of all possible sizes and configurations, however, since CUDA 12.2 update 2, the problem size limitations on m, n, and batch size have been largely resolved. The main focus of the library is to provide the most performant kernels, which might have some implied limitations. Some non-standard configurations may require a user to handle them manually, typically by decomposing the problem into smaller parts (see\nProblem Size Limitations\n).\n3.1.1.\nProblem Size Limitations\n\nThere are inherent problem size limitations that are a result of limitations in CUDA grid dimensions.  For example, many kernels do not support batch sizes greater than 65535 due to a limitation on the\nz\ndimension of a grid.  There are similar restriction on the m and n values for a given problem.\nIn cases where a problem cannot be run by a single kernel, cuBLASLt will attempt to decompose the problem into multiple sub-problems and solve it by running the kernel on each sub-problem.\nThere are some restrictions on cuBLASLt internal problem decomposition which are summarized below:\nAmax computations are not supported.  This means that\nCUBLASLT_MATMUL_DESC_AMAX_D_POINTER\nand\nCUBLASLT_MATMUL_DESC_EPILOGUE_AUX_AMAX_POINTER\nmust be left unset (see\ncublasLtMatmulDescAttributes_t\n)\nAll matrix layouts must have\nCUBLASLT_MATRIX_LAYOUT_ORDER\nset to\nCUBLASLT_ORDER_COL\n(see\ncublasLtOrder_t\n)\ncuBLASLt will not partition along the n dimension when\nCUBLASLT_MATMUL_DESC_EPILOGUE\nis set to\nCUBLASLT_EPILOGUE_DRELU_BGRAD\nor\nCUBLASLT_EPILOGUE_DGELU_BGRAD\n(see\ncublasLtEpilogue_t\n)\nTo overcome these limitations, a user may want to partition the problem themself, launch kernels for each sub-problem, and compute any necessary reductions to combine the results.\n3.1.2.\nHeuristics Cache\n\ncuBLASLt uses heuristics to pick the most suitable matmul kernel for execution based on the problem sizes, GPU configuration, and other parameters. This requires performing some computations on the host CPU, which could take tens of microseconds. To overcome this overhead, it is recommended to query the heuristics once using\ncublasLtMatmulAlgoGetHeuristic()\nand then reuse the result for subsequent computations using\ncublasLtMatmul()\n.\nFor the cases where querying heuristics once and then reusing them is not feasible, cuBLASLt implements a heuristics cache that maps matmul problems to kernels previously selected by heuristics. The heuristics cache uses an LRU-like eviction policy and is thread-safe.\nThe user can control the heuristics cache capacity with the\nCUBLASLT_HEURISTICS_CACHE_CAPACITY\nenvironment variable or with the\ncublasLtHeuristicsCacheSetCapacity()\nfunction which has higher precedence. The capacity is measured in number of entries and might be rounded up to the nearest multiple of some factor for performance reasons. Each entry takes about 360 bytes but is subject to change. The default capacity is 8192 entries.\nNote\nSetting capacity to zero disables the cache completely. This can be useful for workloads that do not have a steady state and for which cache operations may have higher overhead than regular heuristics computations.\nNote\nThe cache is not ideal for performance reasons, so it is sometimes necessary to increase its capacity 1.5x-2.x over the anticipated number of unique matmul problems to achieve a nearly perfect hit rate.\nSee also:\ncublasLtHeuristicsCacheGetCapacity()\n,\ncublasLtHeuristicsCacheSetCapacity()\n.\n3.1.3.\ncuBLASLt Logging\n\ncuBLASLt logging mechanism can be enabled by setting the following environment variables before launching the target application:\nCUBLASLT_LOG_LEVEL=<level>\nwhere\n<level>\nis one of the following levels:\n0\n- Off - logging is disabled (default)\n1\n- Error - only errors will be logged\n2\n- Trace - API calls that launch CUDA kernels will log their parameters and important information\n3\n- Hints - hints that can potentially improve the application’s performance\n4\n- Info - provides general information about the library execution, may contain details about heuristic status\n5\n- API Trace - API calls will log their parameter and important information\nCUBLASLT_LOG_MASK=<mask>\n, where\n<mask>\nis a combination of the following flags:\n0\n- Off\n1\n- Error\n2\n- Trace\n4\n- Hints\n8\n- Info\n16\n- API Trace\nFor example, use\nCUBLASLT_LOG_MASK=5\nto enable Error and Hints messages.\nCUBLASLT_LOG_FILE=<file_name>\n, where\n<file_name>\nis a path to a logging file.  The file name may contain\n%i\n, which will be replaced with the process ID. For example\nfile_name_%i.log\n.\nIf\nCUBLASLT_LOG_FILE\nis not set, the log messages are printed to stdout.\nAnother option is to use the experimental cuBLASLt logging API. See:\ncublasLtLoggerSetCallback()\n,\ncublasLtLoggerSetFile()\n,\ncublasLtLoggerOpenFile()\n,\ncublasLtLoggerSetLevel()\n,\ncublasLtLoggerSetMask()\n,\ncublasLtLoggerForceDisable()\n3.1.4.\nNarrow Precision Data Types Usage\n\nWhat we call here\nnarrow precision data types\nwere first introduced as 8-bit floating point data types (FP8) with Ada and Hopper GPUs (compute capability 8.9 and above), and were designed to further accelerate matrix multiplications. There are two types of FP8 available:\nCUDA_R_8F_E4M3\nis designed to be accurate at a smaller dynamic range than half precision. The E4 and M3 indicate a 4-bit exponent and a 3-bit mantissa respectively. For more details, see\n__nv__fp8_e4m3\n.\nCUDA_R_8F_E5M2\nis designed to be accurate at a similar dynamic range as half precision. The E5 and M2 indicate a 5-bit exponent and a 2-bit mantissa respectively. For more information see\n__nv__fp8_e5m2\n.\nNote\nUnless otherwise stated, FP8 refers to both\nCUDA_R_8F_E4M3\nand\nCUDA_R_8F_E5M2\n.\nWith the Blackwell GPUs (compute capability 10.0 and above), cuBLAS adds support for 4-bit floating data type (FP4)\nCUDA_R_4F_E2M1\n. The E2 and M1 indicate a 2-bit exponent and a 1-bit mantissa respectively. For more details, see\n__nv_fp4_e2m1\n.\nIn order to maintain accuracy, data in narrow precisions needs to be scaled or dequantized before and potentially quantized after computations. cuBLAS provides several modes how the scaling factors are applied, defined in\ncublasLtMatmulMatrixScale_t\nand configured via the\nCUBLASLT_MATMUL_DESC_X_SCALE_MODE\nattributes (here\nX\nstands for\nA\n,\nB\n,\nC\n,\nD\n,\nD_OUT\n, or\nEPILOGUE_AUX\n; see\ncublasLtMatmulDescAttributes_t\n). The scaling modes overview is given in the next table, and more details are available in the subsequent sections.\nScaling Mode Support Overview\n\nMode\nSupported compute capabilities\nTensor values data type\nScaling factors data type\nScaling factor layout\nTensorwide scaling\n8.9+\nCUDA_R_8F_E4M3\n/\nCUDA_R_8F_E5M2\nCUDA_R_32F\n[#fp32]\nScalar\nOuter vector scaling\n9.0\nCUDA_R_8F_E4M3\n/\nCUDA_R_8F_E5M2\nCUDA_R_32F\nVector\n128-element 1D block scaling\n9.0\nCUDA_R_8F_E4M3\n/\nCUDA_R_8F_E5M2\nCUDA_R_32F\nTensor\n128x128-element 2D block scaling\n9.0\nCUDA_R_8F_E4M3\n/\nCUDA_R_8F_E5M2\nCUDA_R_32F\nTensor\n32-element 1D block scaling\n10.0+\nCUDA_R_8F_E4M3\n/\nCUDA_R_8F_E5M2\nCUDA_R_8F_UE8M0\n2\nTiled tensor\n4\n16-element 1D block scaling\n10.0+\nCUDA_R_4F_E2M1\nCUDA_R_8F_UE4M3\n3\nTiled tensor\n4\nNOTES:\n1\nScaling factors that have\nCUDA_R_32F\ndata type can be negative and are applied as-is without taking their absolute value first.\n2\nCUDA_R_8F_UE8M0\nis an 8-bit unsigned exponent-only floating data type. For more information see\n__nv_fp8_e8m0\n.\n3\nCUDA_R_8F_UE4M3\nis an unsigned version of\nCUDA_R_E4M3\n.  The sign bit is ignored, so this enumerant is provided for convenience.\n4\n(\n1\n,\n2\n)\nSee\n1D Block Scaling Factors Layout\nfor more details.\nNote\nScales are only applicable to narrow precisions matmuls. If any scale is set for a non-narrow precisions matmul, cuBLAS will return an error. Furthermore, scales are generally only supported for narrow precision tensors. If the corresponding scale is set for a non-narrow precisions tensor, cuBLAS will return an error. The one exception is that the C tensor is allowed to have a scale for non-narrow data types with tensorwide scaling mode.\nNote\nOnly Tensorwide scaling is supported when\ncublasLtBatchMode_t\nof any matrix is set to\nCUBLASLT_BATCH_MODE_POINTER_ARRAY\n.\n3.1.4.1.\nTensorwide Scaling For FP8 Data Types\n\nTensorwide scaling is enabled when\nCUBLASLT_MATMUL_DESC_X_SCALE_MODE\nattributes (here\nX\nstands for\nA\n,\nB\n,\nC\n,\nD\n, or\nEPILOGUE_AUX\n; see\ncublasLtMatmulDescAttributes_t\n) for all FP8-precision tensors is set to\nCUBLASLT_MATMUL_MATRIX_SCALE_SCALAR_32F\n(this is the default value for FP8 tensors). In such case, the matmul operation in cuBLAS is defined in the following way (assuming, for exposition, that all tensors are using an FP8 precision):\n\\[D = scale_D \\cdot (\\alpha \\cdot scale_A \\cdot scale_B \\cdot \\text{op}(A) \\text{op}(B) + \\beta \\cdot scale_C \\cdot C).\\]\nHere\n\\(A\\)\n,\n\\(B\\)\n, and\n\\(C\\)\nare input tensors, and\n\\(scale_A\\)\n,\n\\(scale_B\\)\n,\n\\(scale_C\\)\n,\n\\(scale_D\\)\n,\n\\(\\alpha\\)\n, and\n\\(\\beta\\)\nare input scalars. This differs from the other matrix multiplication routines because of this addition of scaling factors for each matrix. The\n\\(scale_A\\)\n,\n\\(scale_B\\)\n, and\n\\(scale_C\\)\nare used for de-quantization, and\n\\(scale_D\\)\nis used for quantization. Note that all the scaling factors are applied multiplicatively. This means that sometimes it is necessary to use a scaling factor or its reciprocal depending on the context in which it is applied. For more information on FP8, see\ncublasLtMatmul()\nand\ncublasLtMatmulDescAttributes_t\n.\nFor such matrix multiplications, epilogues and the absolute maximums of intermediate values are computed as follows:\n\\[\\begin{split}Aux_{temp} & = \\alpha \\cdot scale_A \\cdot scale_B \\cdot \\text{op}(A) \\text{op}(B) + \\beta \\cdot scale_C \\cdot C + bias, \\\\\nD_{temp} & = \\mathop{Epilogue}(Aux_{temp}), \\\\\namax_{D} & = \\mathop{absmax}(D_{temp}), \\\\\namax_{Aux} & = \\mathop{absmax}(Aux_{temp}), \\\\\nD & = scale_D * D_{temp}, \\\\\nAux & = scale_{Aux} * Aux_{temp}. \\\\\\end{split}\\]\nHere\n\\(Aux\\)\nis an auxiliary output of matmul consisting of the values that are passed to an epilogue function like GELU,\n\\(scale_{Aux}\\)\nis an optional scaling factor that can be applied to\n\\(Aux\\)\n, and\n\\(amax_{Aux}\\)\nis the maximum absolute value in\n\\(Aux\\)\nbefore scaling. For more information, see attributes\nCUBLASLT_MATMUL_DESC_AMAX_D_POINTER\nand\nCUBLASLT_MATMUL_DESC_EPILOGUE_AUX_AMAX_POINTER\nin\ncublasLtMatmulDescAttributes_t\n.\nNote\nAs indicated in equation above, bias is applied before calculating\n\\(Aux_{temp}\\)\n.\n3.1.4.2.\nOuter Vector Scaling for FP8 Data Types\n\nThis scaling mode (also known as channelwise or rowwise scaling) is a refinement of the tensorwide scaling. Instead of multiplying a matrix by a single scalar, a scaling factor is associated with each row of\n\\(A\\)\nand each column of\n\\(B\\)\n:\n\\[D_{ij} = \\alpha \\cdot scale_A^i \\cdot scale_B^j \\sum_{l=1}^k a_{il}\\cdot b_{lj} + \\beta \\cdot scale_C \\cdot C_{ij}.\\]\nNotably,\n\\(scale_D\\)\nis not supported because the only supported precisions for\n\\(D\\)\nare\nCUDA_R_16F\n,\nCUDA_R_16BF\n, and\nCUDA_R_32F\n.\nTo enable outer vector scaling, the\nCUBLASLT_MATMUL_DESC_A_SCALE_MODE\nand\nCUBLASLT_MATMUL_DESC_B_SCALE_MODE\nattributes, must be set to\nCUBLASLT_MATMUL_MATRIX_SCALE_OUTER_VEC_32F\n, while all the other scaling modes must not be modified.\nWhen using this scaling mode, the\n\\(scale_A\\)\nand\n\\(scale_B\\)\nmust be vectors of length\n\\(M\\)\nand\n\\(N\\)\nrespectively.\n3.1.4.3.\n16/32-Element 1D Block Scaling for FP8 and FP4 Data Types\n\n1D block scaling aims to overcome limitations of having a single scalar to scale a whole tensor. It is described in more details in the\nOCP MXFP\nspecification, so we give just a brief overview here. Block scaling means that elements within the same 16- or 32-element block of adjacent values are assigned a shared scaling factor.\nCurrently, block scaling is supported for FP8-precision and FP4-precision tensors and mixing precisions is not supported. To enable block scaling, the\nCUBLASLT_MATMUL_DESC_X_SCALE_MODE\nattributes (here\nX\nstands for\nA\n,\nB\n,\nC\n,\nDOUT\n, or\nEPILOGUE_AUX\n; see\ncublasLtMatmulDescAttributes_t\n) must be set to\nCUBLASLT_MATMUL_MATRIX_SCALE_VEC32_UE8M0\nfor all FP8-precision tensors or to\nCUBLASLT_MATMUL_MATRIX_SCALE_VEC16_UE4M3\nfor all FP4-precision tensors.\nWith block scaling, the matmul operation in cuBLAS is defined in the following way (assuming, for exposition, that all tensors are using a narrow precision). We loosely follow the OCP MXFP specification notation.\nFirst, a\nscaled block\n(or an\nMX-compliant format vector\nin the OCP MXFP specification) is a tuple\n\\(x = \\left(S^x, \\left[x^i\\right]_{i=1}^k\\right)\\)\n, where\n\\(S^x\\)\nis a shared\nscaling\nfactor, and each\n\\(x^i\\)\nis stored using an FP8 or FP4 data type.\nA dot product of two scaled blocks\n\\(x = \\left(S^x, \\left[x^i\\right]_{i=1}^{k}\\right)\\)\nand\n\\(y = \\left(S^y, \\left[y^i\\right]_{i=1}^{k}\\right)\\)\nis defined as follows:\n\\[Dot(x, y) = S^x S^y \\cdot \\sum_{i=1}^{k} x^i y^i.\\]\nFor a sequence of\n\\(n\\)\nblocks\n\\(X = \\{x_j\\}_{j=1}^n\\)\nand\n\\(Y = \\{y_j\\}_{j=1}^n\\)\n, the generalized dot product is defined as:\n\\[DotGeneral(X, Y) = \\sum_{j=1}^n Dot(x_j, y_j).\\]\nThe generalized dot product can be used to define the matrix multiplication by combining together one scaling factor per\n\\(k\\)\nelements of\n\\(A\\)\nand\n\\(B\\)\nin the\n\\(K\\)\ndimension (assuming, for simplicity, that\n\\(K\\)\nis divisible by\n\\(k\\)\nwithout a remainder):\n\\[\\begin{split}L & = \\frac{K}{k}, \\\\\nA_i & = \\left\\{{scale_A}_{i,b}, \\left[A_{i,(b-1)k+l}\\right]_{l=1}^{k}\\right\\}_{b=1}^L, \\\\\nB_j & = \\left\\{{scale_B}_{i,b}, \\left[B_{(b-1)k+l,j}\\right]_{l=1}^{k}\\right\\}_{b=1}^L, \\\\\n(\\left\\{scale_A, A\\right\\} \\times \\left\\{scale_B, B\\right\\})_{i,j} & = DotGeneral(A_i, B_j).\\end{split}\\]\nNow, the full matmul can be written as:\n\\[\\left\\{scale_D^{out}, D\\right\\} = Quantize\\left(scale_D^{in}\\left(\\alpha \\cdot \\left\\{scale_A, \\text{op}(A)\\right\\} \\times \\left\\{scale_B, \\text{op}(B)\\right\\} + \\beta \\cdot Dequantize(\\left\\{scale_C, C\\right\\})\\right)\\right).\\]\nThe\n\\(Quantize\\)\nis explained in the\n1D Block Quantization\nsection, and\n\\(Dequantize\\)\nis defined as:\n\\[Dequantize\\left(\\left\\{scale_C, C\\right\\})\\right)_{i,j} = {scale_C}_{i/k,j} \\cdot C_{i,j}.\\]\nNote\nIn addition to\n\\(scale_D^{out}\\)\nthat is computed during quantization, there is also an\ninput\nscalar tensor-wide scaling factor\n\\(scale_D^{in}\\)\nfor\n\\(D\\)\nthat is available only when scaling factors use the\nCUDA_R_8F_UE4M3\ndata type. It is used to ‘compress’ computed values prior to quantization.\n3.1.4.3.1.\n1D Block Quantization\n\nConsider a single block of\n\\(k\\)\nelements of\n\\(D\\)\nin the\n\\(M\\)\ndimension:\n\\(D^b_{fp32} = \\left[d^i_{fp32}\\right]_{i=1}^k\\)\n. Quantization of partial blocks is performed as if the missing values are zero. Let\n\\(Amax(DType)\\)\nbe the maximal value representable in the destination precision.\nThe following computations steps are common to all combinations of output and scaling factors data types.\nCompute the block absolute maximum value\n\\(Amax(D^b_{fp32}) = max(\\{|d_i|\\}_{i=1}^k)\\)\n.\nCompute the block scaling factor in single precision as\n\\(S^b_{fp32} = \\frac{Amax(D^b_{fp32})}{Amax(DType)}\\)\n.\nComputing scaling and conversion factors for FP8 with UE8M0 scales\nNote\nRNE rounding is assumed unless noted otherwise.\nComputations consist of the following steps:\nExtract the block scaling factor exponent without bias adjustment as an integer\n\\(E^b_{int}\\)\nand mantissa as a fixed point number\n\\(M^b_{fixp}\\)\nfrom\n\\(S^b_{fp32}\\)\n(the actual implementation operates on bit representation directly).\nRound the block exponent up keeping it within the range of values representable in UE8M0:\n\\(E^b_{int} = \\left\\{\\begin{array}{ll} E^b_{int} + 1, & \\text{if } S^b_{fp32} \\text{ is a normal number and }  E^b_{int} < 254 \\text{ and } M^b_{fixp} > 0 \\\\ E^b_{int} + 1, & \\text{if } S^b_{fp32} \\text{is a denormal number and } M^b_{fixp} > 0.5, \\\\ E^b_{int}, & \\text{otherwise.} \\end{array}\\right.\\)\nCompute the block scaling factor as\n\\(S^b_{ue8m0} = 2^{E^b_{int}}\\)\n. Note that UE8M0 data type has exponent bias of 127.\nCompute the block conversion factor\n\\(R^b_{fp32} = \\frac{1}{fp32(S^b_{ue8m0})}\\)\n.\nNote\nThe algorithm above differs from the OCP MXFP suggested rounding scheme.\nComputing scaling and conversion factors for FP4 with UE4M3 scales\nHere we assume that the algorithm is provided with a precomputed input tensorwide scaling factor\n\\(scale_D^{in}\\)\nwhich in general case is computed as\n\\[scale_D^{in} = \\frac{Amax(e2m1) \\cdot Amax(e4m3)}{Amax(D_{temp})},\\]\nwhere\n\\(Amax(D_{temp})\\)\nis a\nglobal\nabsolute maximum of matmul results before quantization. Since computing this value requires knowing the result of the whole computation, an approximate value from e.g. the previous iteration is used in practice.\nComputations consist of the following steps:\nCompute the narrow precision value of the block scaling factor\n\\(S^b_{e4m3} = e4m3(S^b_{fp32} \\cdot scale_D^{in})\\)\n.\nCompute the block conversion factor\n\\(R^b_{fp32} = \\frac{scale_D^{in}}{fp32(S^b_{e4m3})}\\)\n.\nApplying conversion factors\nFor each\n\\(i = 1 \\ldots k\\)\n, compute\n\\(d^i = DType(d^i_{fp32} \\cdot R^n_{fp32})\\)\n. The resulting quantized block is\n\\(\\left(S^b, \\left[d^i\\right]_{i=1}^k\\right)\\)\n, where\n\\(S^b\\)\nis\n\\(S^b_{ue8m0}\\)\nfor FP8 with UE8M0 scaling factors, and\n\\(S^b_{ue4m3}\\)\nfor FP4 with UE4M3 scaling factors.\n3.1.4.3.2.\n1D Block Scaling Factors Layout\n\nScaling factors are stored using a tiled layout. The following figure shows how each 128x4 tile is laid out in memory. The offset in memory is increasing from left to right, and then from top to bottom.\nThe following pseudocode can be used to translate from\ninner\n(K for A and B, and M for C or D) and\nouter\n(M for A, and N for B, C and D) indices to linear\noffset\nwithin a tile and back:\n// Indices -> offset\noffset\n=\n(\nouter\n%\n32\n)\n*\n16\n+\n(\nouter\n/\n32\n)\n*\n4\n+\ninner\n// Offset -> Indices\nouter\n=\n((\noffset\n%\n16\n)\n/\n4\n)\n*\n32\n+\n(\noffset\n/\n16\n)\ninner\n=\n(\noffset\n%\n4\n)\nA single tile of scaling factors is applied to a 128x64 block when the scaling mode is\nCUBLASLT_MATMUL_MATRIX_SCALE_VEC16_UE4M3\nand to a 128x128 block when it is\nCUBLASLT_MATMUL_MATRIX_SCALE_VEC32_UE8M0\n.\nMultiple blocks are arranged in the row-major manner. The next picture shows an example. The offset in memory is increasing from left to right, and then from top to bottom.\nIn general, for a scaling factors tensor with\nsf_inner_dim\nscaling factors per row, offset of a block with top left coordinate\n(sf_outer,\nsf_inner)\n(using the same correspondence to matrix coordinates as noted above) can be computed using the following pseudocode:\n// Indices -> offset\n//   note that sf_inner is a multiple of 4 due to the tiling layout\noffset\n=\n(\nsf_inner\n+\nsf_outer\n*\nsf_inner_dim\n)\n*\n128\nNote\nStarting addresses of scaling factors must be 16B aligned.\nNote\nNote that the layout described above does not allow transposition. This means that even though the input tensors can be transposed, the layout of scaling factors does not change.\nNote\nNote that when tensor dimensions are not multiples of the tile size above, it is necessary to still allocate full tile for storage and fill out of bounds values with zeroes. Moreover, when writing output scaling factors, kernels may write additional zeroes, so it is best to not make any assuptions regarding the persistence of out of bounds values.\n3.1.4.4.\n128-element 1D and 128x128 2D Block Scaling For FP8 Data Types\n\nThese two scaling modes apply principles of the scaling approach described\n16/32-Element 1D Block Scaling for FP8 and FP4 Data Types\nto the Hopper GPU architecture. However, here the scaling data type is\nCUDA_R_32F\n, and different scaling modes can be used for\n\\(A\\)\nand\n\\(B\\)\n, and the only supported precisions for\n\\(D\\)\nare\nCUDA_R_16F\n,\nCUDA_R_16BF\n, and\nCUDA_R_32F\n.\nTo enable this scaling mode, the\nCUBLASLT_MATMUL_DESC_X_SCALE_MODE\nattributes (here\nX\nstands for\nA\nor\nB\n), must be set to\nCUBLASLT_MATMUL_MATRIX_SCALE_VEC128_32F\nor\nCUBLASLT_MATMUL_MATRIX_SCALE_BLK128x128_32F\n, while all the other scaling modes must not be modified. The following table shows supported combinations:\nCUBLASLT_MATMUL_DESC_A_SCALE_MODE\nCUBLASLT_MATMUL_DESC_B_SCALE_MODE\nSupported?\nCUBLASLT_MATMUL_MATRIX_SCALE_VEC128_32F\nCUBLASLT_MATMUL_MATRIX_SCALE_VEC128_32F\nYes\nCUBLASLT_MATMUL_MATRIX_SCALE_VEC128_32F\nCUBLASLT_MATMUL_MATRIX_SCALE_BLK128x128_32F\nYes\nCUBLASLT_MATMUL_MATRIX_SCALE_BLK128x128_32F\nCUBLASLT_MATMUL_MATRIX_SCALE_VEC128_32F\nYes\nCUBLASLT_MATMUL_MATRIX_SCALE_BLK128x128_32F\nCUBLASLT_MATMUL_MATRIX_SCALE_BLK128x128_32F\nNo\nUsing the notation from the\n16/32-Element 1D Block Scaling for FP8 and FP4 Data Types\n, we can define sequences of scaled blocks for the\n\\(i\\)\n-th row of\n\\(A\\)\nin the following way:\n\\[\\begin{split}L & = \\lceil \\frac{K}{128} \\rceil, \\\\\nA^{128}_i & = \\left\\{{scale_A}_{i,b}, \\left[A_{i,(b-1)128+l}\\right]_{l=1}^{128}\\right\\}_{b=1}^L, \\text{(this is the 128-element 1D block scaling)} \\\\\n\\\\\np & = \\lceil \\frac{i}{128} \\rceil, \\\\\nA^{128 \\times 128}_i & = \\left\\{{scale_A}_{p,b}, \\left[A_{i,(b-1)128+l}\\right]_{l=1}^{128}\\right\\}_{b=1}^L. \\text{(this is the 128x128-element 2D block scaling)} \\\\\\end{split}\\]\nDefinitions for\n\\(B\\)\nare similar. The matmul is then defined as in\n16/32-Element 1D Block Scaling for FP8 and FP4 Data Types\nwith the notable difference that when using the 2D block scaling a single scaling factor is used for the whole 128x128 block of elements.\n3.1.4.4.1.\nScaling factors layouts\n\nNote\nStarting addresses of scaling factors must be 16B aligned.\nNote\n\\(M\\)\nand\n\\(N\\)\nmust be multiples of 4.\nThen for the\nCUBLASLT_MATMUL_MATRIX_SCALE_VEC128_32F\nscaling mode, the scaling factors are:\n\\(M\\)\n-major for\n\\(A\\)\nwith shape\n\\(M \\times L\\)\n(\n\\(M\\)\n-major means that elements along the\n\\(M\\)\ndimension are contiguous in memory),\n\\(N\\)\n-major for\n\\(B\\)\nwith shape\n\\(N \\times L\\)\n.\nFor the\nCUBLASLT_MATMUL_MATRIX_SCALE_BLK128x128_32F\nscaling mode, the scaling factors are\n\\(K\\)\n-major and the stride between the consecutive columns must be a multiple of 4. Let\n\\(L_4 = \\lceil L \\rceil_4\\)\n, where the\n\\(\\lceil \\cdot \\rceil_4\\)\ndenotes rounding up to the nearest multiple of 4. Then\nfor\n\\(A\\)\n, the shape of the scaling factors is\n\\(L_4 \\times \\lceil \\frac{M}{128} \\rceil\\)\n,\nfor\n\\(B\\)\n, the shape of the scaling factors is\n\\(L_4 \\times \\lceil \\frac{N}{128} \\rceil\\)\n.\n3.1.5.\nDisabling CPU Instructions\n\nAs mentioned in the\nHeuristics Cache\nsection, cuBLASLt heuristics perform some compute-intensive operations on the host CPU.\nTo speed-up the operations, the implementation detects CPU capabilities and may use special instructions, such as Advanced Vector Extensions (AVX) on x86-64 CPUs.\nHowever, in some rare cases this might be not desirable. For instance, using advanced instructions may result in CPU running at a lower frequency, which would affect performance of the other host code.\nThe user can optionally instruct the cuBLASLt library to not use some CPU instructions with the\nCUBLASLT_DISABLE_CPU_INSTRUCTIONS_MASK\nenvironment variable or with the\ncublasLtDisableCpuInstructionsSetMask()\nfunction which has higher precedence.\nThe default mask is 0, meaning that there are no restrictions.\nPlease check\ncublasLtDisableCpuInstructionsSetMask()\nfor more information.\n3.2.\ncuBLASLt Code Examples\n\nPlease visit\nhttps://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuBLASLt\nfor updated code examples.\n3.3.\ncuBLASLt Datatypes Reference\n\n3.3.1.\ncublasLtClusterShape_t\n\ncublasLtClusterShape_t\nis an enumerated type used to configure thread block cluster dimensions. Thread block clusters add an optional hierarchical level and are made up of thread blocks. Similar to thread blocks, these can be one, two, or three-dimensional. See also\nThread Block Clusters\n.\nValue\nDescription\nCUBLASLT_CLUSTER_SHAPE_AUTO\nCluster shape is automatically selected.\nCUBLASLT_CLUSTER_SHAPE_1x1x1\nCluster shape is 1 x 1 x 1.\nCUBLASLT_CLUSTER_SHAPE_1x2x1\nCluster shape is 1 x 2 x 1.\nCUBLASLT_CLUSTER_SHAPE_1x4x1\nCluster shape is 1 x 4 x 1.\nCUBLASLT_CLUSTER_SHAPE_2x1x1\nCluster shape is 2 x 1 x 1.\nCUBLASLT_CLUSTER_SHAPE_2x2x1\nCluster shape is 2 x 2 x 1.\nCUBLASLT_CLUSTER_SHAPE_2x4x1\nCluster shape is 2 x 4 x 1.\nCUBLASLT_CLUSTER_SHAPE_4x1x1\nCluster shape is 4 x 1 x 1.\nCUBLASLT_CLUSTER_SHAPE_4x2x1\nCluster shape is 4 x 2 x 1.\nCUBLASLT_CLUSTER_SHAPE_4x4x1\nCluster shape is 4 x 4 x 1.\nCUBLASLT_CLUSTER_SHAPE_1x8x1\nCluster shape is 1 x 8 x 1.\nCUBLASLT_CLUSTER_SHAPE_8x1x1\nCluster shape is 8 x 1 x 1.\nCUBLASLT_CLUSTER_SHAPE_2x8x1\nCluster shape is 2 x 8 x 1.\nCUBLASLT_CLUSTER_SHAPE_8x2x1\nCluster shape is 8 x 2 x 1.\nCUBLASLT_CLUSTER_SHAPE_1x16x1\nCluster shape is 1 x 16 x 1.\nCUBLASLT_CLUSTER_SHAPE_16x1x1\nCluster shape is 16 x 1 x 1.\nCUBLASLT_CLUSTER_SHAPE_1x3x1\nCluster shape is 1 x 3 x 1.\nCUBLASLT_CLUSTER_SHAPE_1x5x1\nCluster shape is 1 x 5 x 1.\nCUBLASLT_CLUSTER_SHAPE_1x6x1\nCluster shape is 1 x 6 x 1.\nCUBLASLT_CLUSTER_SHAPE_1x7x1\nCluster shape is 1 x 7 x 1.\nCUBLASLT_CLUSTER_SHAPE_1x9x1\nCluster shape is 1 x 9 x 1.\nCUBLASLT_CLUSTER_SHAPE_1x10x1\nCluster shape is 1 x 10 x 1.\nCUBLASLT_CLUSTER_SHAPE_1x11x1\nCluster shape is 1 x 11 x 1.\nCUBLASLT_CLUSTER_SHAPE_1x12x1\nCluster shape is 1 x 12 x 1.\nCUBLASLT_CLUSTER_SHAPE_1x13x1\nCluster shape is 1 x 13 x 1.\nCUBLASLT_CLUSTER_SHAPE_1x14x1\nCluster shape is 1 x 14 x 1.\nCUBLASLT_CLUSTER_SHAPE_1x15x1\nCluster shape is 1 x 15 x 1.\nCUBLASLT_CLUSTER_SHAPE_2x3x1\nCluster shape is 2 x 3 x 1.\nCUBLASLT_CLUSTER_SHAPE_2x5x1\nCluster shape is 2 x 5 x 1.\nCUBLASLT_CLUSTER_SHAPE_2x6x1\nCluster shape is 2 x 6 x 1.\nCUBLASLT_CLUSTER_SHAPE_2x7x1\nCluster shape is 2 x 7 x 1.\nCUBLASLT_CLUSTER_SHAPE_3x1x1\nCluster shape is 3 x 1 x 1.\nCUBLASLT_CLUSTER_SHAPE_3x2x1\nCluster shape is 3 x 2 x 1.\nCUBLASLT_CLUSTER_SHAPE_3x3x1\nCluster shape is 3 x 3 x 1.\nCUBLASLT_CLUSTER_SHAPE_3x4x1\nCluster shape is 3 x 4 x 1.\nCUBLASLT_CLUSTER_SHAPE_3x5x1\nCluster shape is 3 x 5 x 1.\nCUBLASLT_CLUSTER_SHAPE_4x3x1\nCluster shape is 4 x 3 x 1.\nCUBLASLT_CLUSTER_SHAPE_5x1x1\nCluster shape is 5 x 1 x 1.\nCUBLASLT_CLUSTER_SHAPE_5x2x1\nCluster shape is 5 x 2 x 1.\nCUBLASLT_CLUSTER_SHAPE_5x3x1\nCluster shape is 5 x 3 x 1.\nCUBLASLT_CLUSTER_SHAPE_6x1x1\nCluster shape is 6 x 1 x 1.\nCUBLASLT_CLUSTER_SHAPE_6x2x1\nCluster shape is 6 x 2 x 1.\nCUBLASLT_CLUSTER_SHAPE_7x1x1\nCluster shape is 7 x 1 x 1.\nCUBLASLT_CLUSTER_SHAPE_7x2x1\nCluster shape is 7 x 2 x 1.\nCUBLASLT_CLUSTER_SHAPE_9x1x1\nCluster shape is 9 x 1 x 1.\nCUBLASLT_CLUSTER_SHAPE_10x1x1\nCluster shape is 10 x 1 x 1.\nCUBLASLT_CLUSTER_SHAPE_11x1x1\nCluster shape is 11 x 1 x 1.\nCUBLASLT_CLUSTER_SHAPE_12x1x1\nCluster shape is 12 x 1 x 1.\nCUBLASLT_CLUSTER_SHAPE_13x1x1\nCluster shape is 13 x 1 x 1.\nCUBLASLT_CLUSTER_SHAPE_14x1x1\nCluster shape is 14 x 1 x 1.\nCUBLASLT_CLUSTER_SHAPE_15x1x1\nCluster shape is 15 x 1 x 1.\n3.3.2.\ncublasLtEpilogue_t\n\nThe\ncublasLtEpilogue_t\nis an enum type to set the postprocessing options for the epilogue.\nValue\nDescription\nCUBLASLT_EPILOGUE_DEFAULT\n=\n1\nNo special postprocessing, just scale and quantize the results if necessary.\nCUBLASLT_EPILOGUE_RELU\n=\n2\nApply ReLU point-wise transform to the results (\nx\n:=\nmax(x,\n0)\n).\nCUBLASLT_EPILOGUE_RELU_AUX\n=\nCUBLASLT_EPILOGUE_RELU\n|\n128\nApply ReLU point-wise transform to the results (\nx\n:=\nmax(x,\n0)\n). This epilogue mode produces an extra output, see\nCUBLASLT_MATMUL_DESC_EPILOGUE_AUX_POINTER\nof\ncublasLtMatmulDescAttributes_t\n.\nCUBLASLT_EPILOGUE_BIAS\n=\n4\nApply (broadcast) bias from the bias vector. Bias vector length must match matrix D rows, and it must be packed (such as stride between vector elements is 1). Bias vector is broadcast to all columns and added before applying the final postprocessing.\nCUBLASLT_EPILOGUE_RELU_BIAS\n=\nCUBLASLT_EPILOGUE_RELU\n=\nCUBLASLT_EPILOGUE_BIAS\nApply bias and then ReLU transform.\nCUBLASLT_EPILOGUE_RELU_AUX_BIAS\n=\nCUBLASLT_EPILOGUE_RELU_AUX\n=\nCUBLASLT_EPILOGUE_BIAS\nApply bias and then ReLU transform. This epilogue mode produces an extra output, see\nCUBLASLT_MATMUL_DESC_EPILOGUE_AUX_POINTER\nof\ncublasLtMatmulDescAttributes_t\n.\nCUBLASLT_EPILOGUE_DRELU\n=\n8\n|\n128\nApply ReLu gradient to matmul output. Store ReLu gradient in the output matrix. This epilogue mode requires an extra input, see\nCUBLASLT_MATMUL_DESC_EPILOGUE_AUX_POINTER\nof\ncublasLtMatmulDescAttributes_t\n.\nCUBLASLT_EPILOGUE_DRELU_BGRAD\n=\nCUBLASLT_EPILOGUE_DRELU\n|\n16\nApply independently ReLu and Bias gradient to matmul output. Store ReLu gradient in the output matrix, and Bias gradient in the bias buffer (see\nCUBLASLT_MATMUL_DESC_BIAS_POINTER\n). This epilogue mode requires an extra input, see\nCUBLASLT_MATMUL_DESC_EPILOGUE_AUX_POINTER\nof\ncublasLtMatmulDescAttributes_t\n.\nCUBLASLT_EPILOGUE_GELU\n=\n32\nApply GELU point-wise transform to the results (\nx\n:=\nGELU(x)\n).\nCUBLASLT_EPILOGUE_GELU_AUX\n=\nCUBLASLT_EPILOGUE_GELU\n|\n128\nApply GELU point-wise transform to the results (\nx\n:=\nGELU(x)\n). This epilogue mode outputs GELU input as a separate matrix (useful for training). See\nCUBLASLT_MATMUL_DESC_EPILOGUE_AUX_POINTER\nof\ncublasLtMatmulDescAttributes_t\n.\nCUBLASLT_EPILOGUE_GELU_BIAS\n=\nCUBLASLT_EPILOGUE_GELU\n=\nCUBLASLT_EPILOGUE_BIAS\nApply Bias and then GELU transform\n5\n.\nCUBLASLT_EPILOGUE_GELU_AUX_BIAS\n=\nCUBLASLT_EPILOGUE_GELU_AUX\n=\nCUBLASLT_EPILOGUE_BIAS\nApply Bias and then GELU transform\n5\n. This epilogue mode outputs GELU input as a separate matrix (useful for training). See\nCUBLASLT_MATMUL_DESC_EPILOGUE_AUX_POINTER\nof\ncublasLtMatmulDescAttributes_t\n.\nCUBLASLT_EPILOGUE_DGELU\n=\n64\n|\n128\nApply GELU gradient to matmul output. Store GELU gradient in the output matrix. This epilogue mode requires an extra input, see\nCUBLASLT_MATMUL_DESC_EPILOGUE_AUX_POINTER\nof\ncublasLtMatmulDescAttributes_t\n.\nCUBLASLT_EPILOGUE_DGELU_BGRAD\n=\nCUBLASLT_EPILOGUE_DGELU\n|\n16\nApply independently GELU and Bias gradient to matmul output. Store GELU gradient in the output matrix, and Bias gradient in the bias buffer (see\nCUBLASLT_MATMUL_DESC_BIAS_POINTER\n). This epilogue mode requires an extra input, see\nCUBLASLT_MATMUL_DESC_EPILOGUE_AUX_POINTER\nof\ncublasLtMatmulDescAttributes_t\n.\nCUBLASLT_EPILOGUE_BGRADA\n=\n256\nApply Bias gradient to the input matrix A. The bias size corresponds to the number of rows of the matrix D. The reduction happens over the GEMM’s “k” dimension. Store Bias gradient in the bias buffer, see\nCUBLASLT_MATMUL_DESC_BIAS_POINTER\nof\ncublasLtMatmulDescAttributes_t\n.\nCUBLASLT_EPILOGUE_BGRADB\n=\n512\nApply Bias gradient to the input matrix B. The bias size corresponds to the number of columns of the matrix D. The reduction happens over the GEMM’s “k” dimension. Store Bias gradient in the bias buffer, see\nCUBLASLT_MATMUL_DESC_BIAS_POINTER\nof\ncublasLtMatmulDescAttributes_t\n.\nNOTES:\n5\n(\n1\n,\n2\n)\nGELU (Gaussian Error Linear Unit) is approximated by:\n\\({0.5}x\\left( 1 + \\text{tanh}\\left( \\sqrt{2/\\pi}\\left( x + {0.044715}x^{3} \\right) \\right) \\right)\\)\nNote\nOnly\nCUBLASLT_EPILOGUE_DEFAULT\nis supported when\ncublasLtBatchMode_t\nof any matrix is set to\nCUBLASLT_BATCH_MODE_POINTER_ARRAY\n.\n3.3.3.\ncublasLtHandle_t\n\nThe\ncublasLtHandle_t\ntype is a pointer type to an opaque structure holding the cuBLASLt  library context. Use\ncublasLtCreate()\nto initialize the cuBLASLt library context and return a handle to an opaque structure holding the cuBLASLt library context, and use\ncublasLtDestroy()\nto destroy a previously created cuBLASLt library context descriptor and release the resources.\nNote\ncuBLAS handle (\ncublasHandle_t\n) encapsulates a cuBLASLt handle. Any valid\ncublasHandle_t\ncan be used in place of\ncublasLtHandle_t\nwith a simple cast. However, unlike a cuBLAS handle, a cuBLASLt handle is not tied to any particular CUDA context with the exception of CUDA contexts tied to a graphics context (starting from CUDA 12.8). If a cuBLASLt handle is created when the current CUDA context is tied to a graphics context, then cuBLASLt detects the corresponding shared memory limitations and records it in the handle.\n3.3.4.\ncublasLtLoggerCallback_t\n\ncublasLtLoggerCallback_t\nis a callback function pointer type. A callback function can be set using\ncublasLtLoggerSetCallback()\n.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nlogLevel\nOutput\nSee\ncuBLASLt Logging\n.\nfunctionName\nOutput\nThe name of the API that logged this message.\nmessage\nOutput\nThe log message.\n3.3.5.\ncublasLtMatmulAlgo_t\n\ncublasLtMatmulAlgo_t\nis an opaque structure holding the description of the matrix multiplication algorithm. This structure can be trivially serialized and later restored for use with the same version of cuBLAS library to save on selecting the right configuration again.\n3.3.6.\ncublasLtMatmulAlgoCapAttributes_t\n\ncublasLtMatmulAlgoCapAttributes_t\nenumerates matrix multiplication algorithm capability attributes that can be retrieved from an initialized\ncublasLtMatmulAlgo_t\ndescriptor using\ncublasLtMatmulAlgoCapGetAttribute()\n.\nValue\nDescription\nData Type\nCUBLASLT_ALGO_CAP_SPLITK_SUPPORT\nSupport for split-K. Boolean (0 or 1) to express if split-K implementation is supported. 0 means no support, and supported otherwise. See\nCUBLASLT_ALGO_CONFIG_SPLITK_NUM\nof\ncublasLtMatmulAlgoConfigAttributes_t\n.\nint32_t\nCUBLASLT_ALGO_CAP_REDUCTION_SCHEME_MASK\nMask to express the types of reduction schemes supported, see\ncublasLtReductionScheme_t\n. If the reduction scheme is not masked out then it is supported. For example:\nint\nisReductionSchemeComputeTypeSupported\n?\n(reductionSchemeMask\n&\nCUBLASLT_REDUCTION_SCHEME_COMPUTE_TYPE)\n==\nCUBLASLT_REDUCTION_SCHEME_COMPUTE_TYPE\n?\n1\n:\n0;\nuint32_t\nCUBLASLT_ALGO_CAP_CTA_SWIZZLING_SUPPORT\nSupport for CTA-swizzling. Boolean (0 or 1) to express if CTA-swizzling implementation is supported. 0 means no support, and 1 means supported value of 1; other values are reserved. See also\nCUBLASLT_ALGO_CONFIG_CTA_SWIZZLING\nof\ncublasLtMatmulAlgoConfigAttributes_t\n.\nuint32_t\nCUBLASLT_ALGO_CAP_STRIDED_BATCH_SUPPORT\nSupport strided batch. 0 means no support, supported otherwise.\nint32_t\nCUBLASLT_ALGO_CAP_POINTER_ARRAY_BATCH_SUPPORT\nSupport pointer array batch. 0 means no support, supported otherwise.\nint32_t\nCUBLASLT_ALGO_CAP_OUT_OF_PLACE_RESULT_SUPPORT\nSupport results out of place (D != C in D = alpha.A.B + beta.C). 0 means no support, supported otherwise.\nint32_t\nCUBLASLT_ALGO_CAP_UPLO_SUPPORT\nSyrk (symmetric rank k update)/herk (Hermitian rank k update) support (on top of regular gemm). 0 means no support, supported otherwise.\nint32_t\nCUBLASLT_ALGO_CAP_TILE_IDS\nThe tile ids possible to use. See\ncublasLtMatmulTile_t\n. If no tile ids are supported then use\nCUBLASLT_MATMUL_TILE_UNDEFINED\n. Use\ncublasLtMatmulAlgoCapGetAttribute()\nwith\nsizeInBytes\n=\n0\nto query the actual count.\nuint32_t[]\nCUBLASLT_ALGO_CAP_STAGES_IDS\nThe stages ids possible to use. See\ncublasLtMatmulStages_t\n. If no stages ids are supported then use\nCUBLASLT_MATMUL_STAGES_UNDEFINED\n. Use\ncublasLtMatmulAlgoCapGetAttribute()\nwith\nsizeInBytes\n=\n0\nto query the actual count.\nuint32_t[]\nCUBLASLT_ALGO_CAP_CUSTOM_OPTION_MAX\nCustom option range is from 0 to\nCUBLASLT_ALGO_CAP_CUSTOM_OPTION_MAX\n(inclusive). See\nCUBLASLT_ALGO_CONFIG_CUSTOM_OPTION\nof\ncublasLtMatmulAlgoConfigAttributes_t\n.\nint32_t\nCUBLASLT_ALGO_CAP_MATHMODE_IMPL\nIndicates whether the algorithm is using regular compute or tensor operations. 0 means regular compute, 1 means tensor operations.\nDEPRECATED\nint32_t\nCUBLASLT_ALGO_CAP_GAUSSIAN_IMPL\nIndicate whether the algorithm implements the Gaussian optimization of complex matrix multiplication. 0 means regular compute; 1 means Gaussian. See\ncublasMath_t\n.\nDEPRECATED\nint32_t\nCUBLASLT_ALGO_CAP_CUSTOM_MEMORY_ORDER\nIndicates whether the algorithm supports custom (not COL or ROW memory order). 0 means only COL and ROW memory order is allowed, non-zero means that algo might have different requirements. See\ncublasLtOrder_t\n.\nint32_t\nCUBLASLT_ALGO_CAP_POINTER_MODE_MASK\nBitmask enumerating the pointer modes the algorithm supports. See\ncublasLtPointerModeMask_t\n.\nuint32_t\nCUBLASLT_ALGO_CAP_EPILOGUE_MASK\nBitmask enumerating the kinds of postprocessing algorithm supported in the epilogue. See\ncublasLtEpilogue_t\n.\nuint32_t\nCUBLASLT_ALGO_CAP_LD_NEGATIVE\nSupport for negative leading dimension for all of the matrices. 0 means no support, supported otherwise.\nuint32_t\nCUBLASLT_ALGO_CAP_NUMERICAL_IMPL_FLAGS\nDetails about algorithm’s implementation that affect it’s numerical behavior. See\ncublasLtNumericalImplFlags_t\n.\nuint64_t\nCUBLASLT_ALGO_CAP_MIN_ALIGNMENT_A_BYTES\nMinimum alignment required for A matrix in bytes.\nuint32_t\nCUBLASLT_ALGO_CAP_MIN_ALIGNMENT_B_BYTES\nMinimum alignment required for B matrix in bytes.\nuint32_t\nCUBLASLT_ALGO_CAP_MIN_ALIGNMENT_C_BYTES\nMinimum alignment required for C matrix in bytes.\nuint32_t\nCUBLASLT_ALGO_CAP_MIN_ALIGNMENT_D_BYTES\nMinimum alignment required for D matrix in bytes.\nuint32_t\nCUBLASLT_ALGO_CAP_FLOATING_POINT_EMULATION_SUPPORT\nSupport for for floating point emulation. See\nFloating Point Emulation\n.\nint32_t\n3.3.7.\ncublasLtMatmulAlgoConfigAttributes_t\n\ncublasLtMatmulAlgoConfigAttributes_t\nis an enumerated type that contains the configuration attributes for cuBLASLt matrix multiply algorithms. The configuration attributes are algorithm-specific, and can be set. The attributes configuration of a given algorithm should agree with its capability attributes. Use\ncublasLtMatmulAlgoConfigGetAttribute()\nand\ncublasLtMatmulAlgoConfigSetAttribute()\nto get and set the attribute value of a matmul algorithm descriptor.\nValue\nDescription\nData Type\nCUBLASLT_ALGO_CONFIG_ID\nRead-only attribute. Algorithm index. See\ncublasLtMatmulAlgoGetIds()\n. Set by\ncublasLtMatmulAlgoInit()\n.\nint32_t\nCUBLASLT_ALGO_CONFIG_TILE_ID\nTile id. See\ncublasLtMatmulTile_t\n. Default:\nCUBLASLT_MATMUL_TILE_UNDEFINED\n.\nuint32_t\nCUBLASLT_ALGO_CONFIG_STAGES_ID\nstages id, see\ncublasLtMatmulStages_t\n. Default:\nCUBLASLT_MATMUL_STAGES_UNDEFINED\n.\nuint32_t\nCUBLASLT_ALGO_CONFIG_SPLITK_NUM\nNumber of K splits. If the number of K splits is greater than one, SPLITK_NUM parts of matrix multiplication will be computed in parallel. The results will be accumulated according to\nCUBLASLT_ALGO_CONFIG_REDUCTION_SCHEME\n.\nuint32_t\nCUBLASLT_ALGO_CONFIG_REDUCTION_SCHEME\nReduction scheme to use when splitK value > 1. Default:\nCUBLASLT_REDUCTION_SCHEME_NONE\n. See\ncublasLtReductionScheme_t\n.\nuint32_t\nCUBLASLT_ALGO_CONFIG_CTA_SWIZZLING\nEnable/Disable CTA swizzling. Change mapping from CUDA grid coordinates to parts of the matrices. Possible values: 0 and 1; other values reserved.\nuint32_t\nCUBLASLT_ALGO_CONFIG_CUSTOM_OPTION\nCustom option value. Each algorithm can support some custom options that don’t fit the description of the other configuration attributes. See the\nCUBLASLT_ALGO_CAP_CUSTOM_OPTION_MAX\nof\ncublasLtMatmulAlgoCapAttributes_t\nfor the accepted range for a specific case.\nuint32_t\nCUBLASLT_ALGO_CONFIG_INNER_SHAPE_ID\nInner shape ID. Refer to\ncublasLtMatmulInnerShape_t.\nDefault:\nCUBLASLT_MATMUL_INNER_SHAPE_UNDEFINED\n.\nuint16_t\nCUBLASLT_ALGO_CONFIG_CLUSTER_SHAPE_ID\nCluster shape ID. Refer to\ncublasLtClusterShape_t.\nDefault:\nCUBLASLT_CLUSTER_SHAPE_AUTO\n.\nuint16_t\n3.3.8.\ncublasLtMatmulDesc_t\n\nThe\ncublasLtMatmulDesc_t\nis a pointer to an opaque structure holding the description of the matrix multiplication operation\ncublasLtMatmul()\n. A descriptor can be created by calling\ncublasLtMatmulDescCreate()\nand destroyed by calling\ncublasLtMatmulDescDestroy()\n.\n3.3.9.\ncublasLtMatmulDescAttributes_t\n\ncublasLtMatmulDescAttributes_t\nis a descriptor structure containing the attributes that define the specifics of the matrix multiply operation. Use\ncublasLtMatmulDescGetAttribute()\nand\ncublasLtMatmulDescSetAttribute()\nto get and set the attribute value of a matmul descriptor.\nValue\nDescription\nData Type\nCUBLASLT_MATMUL_DESC_COMPUTE_TYPE\nCompute type. Defines the data type used for multiply and accumulate operations, and the accumulator during the matrix multiplication. See\ncublasComputeType_t\n.\nint32_t\nCUBLASLT_MATMUL_DESC_SCALE_TYPE\nScale type. Defines the data type of the scaling factors\nalpha\nand\nbeta\n. The accumulator value and the value from matrix\nC\nare typically converted to scale type before final scaling. The value is then converted from scale type to the type of matrix\nD\nbefore storing in memory. The default value depends on\nCUBLASLT_MATMUL_DESC_COMPUTE_TYPE\n. See\ncudaDataType_t\n.\nint32_t\nCUBLASLT_MATMUL_DESC_POINTER_MODE\nSpecifies\nalpha\nand\nbeta\nare passed by reference, whether they are scalars on the host or on the device, or device vectors. Default value is:\nCUBLASLT_POINTER_MODE_HOST\n(i.e., on the host). See\ncublasLtPointerMode_t\n.\nint32_t\nCUBLASLT_MATMUL_DESC_TRANSA\nSpecifies the type of transformation operation that should be performed on matrix A. Default value is:\nCUBLAS_OP_N\n(i.e., non-transpose operation). See\ncublasOperation_t\n.\nint32_t\nCUBLASLT_MATMUL_DESC_TRANSB\nSpecifies the type of transformation operation that should be performed on matrix B. Default value is:\nCUBLAS_OP_N\n(i.e., non-transpose operation). See\ncublasOperation_t\n.\nint32_t\nCUBLASLT_MATMUL_DESC_TRANSC\nSpecifies the type of transformation operation that should be performed on matrix C. Currently only\nCUBLAS_OP_N\nis supported. Default value is:\nCUBLAS_OP_N\n(i.e., non-transpose operation). See\ncublasOperation_t\n.\nint32_t\nCUBLASLT_MATMUL_DESC_FILL_MODE\nIndicates whether the lower or upper part of the dense matrix was filled, and consequently should be used by the function. Currently this flag is not supported for bfloat16 or FP8 data types and is not supported on the following GPUs: Hopper, Blackwell. Default value is:\nCUBLAS_FILL_MODE_FULL\n. See\ncublasFillMode_t\n.\nint32_t\nCUBLASLT_MATMUL_DESC_EPILOGUE\nEpilogue function. See\ncublasLtEpilogue_t\n. Default value is:\nCUBLASLT_EPILOGUE_DEFAULT\n.\nuint32_t\nCUBLASLT_MATMUL_DESC_BIAS_POINTER\nBias or Bias gradient vector pointer in the device memory.\nInput vector with length that matches the number of rows of matrix D when one of the following epilogues is used:\nCUBLASLT_EPILOGUE_BIAS\n,\nCUBLASLT_EPILOGUE_RELU_BIAS\n,\nCUBLASLT_EPILOGUE_RELU_AUX_BIAS\n,\nCUBLASLT_EPILOGUE_GELU_BIAS\n,\nCUBLASLT_EPILOGUE_GELU_AUX_BIAS\n.\nOutput vector with length that matches the number of rows of matrix D when one of the following epilogues is used:\nCUBLASLT_EPILOGUE_DRELU_BGRAD\n,\nCUBLASLT_EPILOGUE_DGELU_BGRAD\n,\nCUBLASLT_EPILOGUE_BGRADA\n.\nOutput vector with length that matches the number of columns of matrix D when one of the following epilogues is used:\nCUBLASLT_EPILOGUE_BGRADB\n.\nBias vector elements are the same type as\nalpha\nand\nbeta\n(see\nCUBLASLT_MATMUL_DESC_SCALE_TYPE\nin this table) when matrix D datatype is\nCUDA_R_8I\nand same as matrix D datatype otherwise. See the datatypes table under\ncublasLtMatmul()\nfor detailed mapping. Default value is: NULL.\nvoid\n*\n/\nconst\nvoid\n*\nCUBLASLT_MATMUL_DESC_BIAS_BATCH_STRIDE\nStride (in elements) to the next bias or bias gradient vector for strided batch operations.  The default value is 0.\nint64_t\nCUBLASLT_MATMUL_DESC_EPILOGUE_AUX_POINTER\nPointer for epilogue auxiliary buffer.\nOutput vector for ReLu bit-mask in forward pass when\nCUBLASLT_EPILOGUE_RELU_AUX\nor\nCUBLASLT_EPILOGUE_RELU_AUX_BIAS\nepilogue is used.\nInput vector for ReLu bit-mask in backward pass when\nCUBLASLT_EPILOGUE_DRELU\nor\nCUBLASLT_EPILOGUE_DRELU_BGRAD\nepilogue is used.\nOutput of GELU input matrix in forward pass when\nCUBLASLT_EPILOGUE_GELU_AUX_BIAS\nepilogue is used.\nInput of GELU input matrix for backward pass when\nCUBLASLT_EPILOGUE_DGELU\nor\nCUBLASLT_EPILOGUE_DGELU_BGRAD\nepilogue is used.\nFor aux data type, see\nCUBLASLT_MATMUL_DESC_EPILOGUE_AUX_DATA_TYPE\n. Routines that don’t dereference this pointer, like\ncublasLtMatmulAlgoGetHeuristic()\ndepend on its value to determine expected pointer alignment. Requires setting the\nCUBLASLT_MATMUL_DESC_EPILOGUE_AUX_LD\nattribute.\nvoid\n*\n/\nconst\nvoid\n*\nCUBLASLT_MATMUL_DESC_EPILOGUE_AUX_LD\nLeading dimension for epilogue auxiliary buffer.\nReLu bit-mask matrix leading dimension in elements (i.e. bits) when\nCUBLASLT_EPILOGUE_RELU_AUX\n,\nCUBLASLT_EPILOGUE_RELU_AUX_BIAS\n,\nCUBLASLT_EPILOGUE_DRELU_BGRAD\n, or\nCUBLASLT_EPILOGUE_DRELU_BGRAD\nepilogue is used. Must be divisible by 128 and be no less than the number of rows in the output matrix.\nGELU input matrix leading dimension in elements when\nCUBLASLT_EPILOGUE_GELU_AUX_BIAS\n,\nCUBLASLT_EPILOGUE_DGELU\n,  or\nCUBLASLT_EPILOGUE_DGELU_BGRAD\nepilogue used. Must be divisible by 8 and be no less than the number of rows in the output matrix.\nint64_t\nCUBLASLT_MATMUL_DESC_EPILOGUE_AUX_BATCH_STRIDE\nBatch stride for epilogue auxiliary buffer.\nReLu bit-mask matrix batch stride in elements (i.e. bits) when\nCUBLASLT_EPILOGUE_RELU_AUX\n,\nCUBLASLT_EPILOGUE_RELU_AUX_BIAS\nor\nCUBLASLT_EPILOGUE_DRELU_BGRAD\nepilogue is used. Must be divisible by 128.\nGELU input matrix batch stride in elements when\nCUBLASLT_EPILOGUE_GELU_AUX_BIAS\n,\nCUBLASLT_EPILOGUE_DRELU\n, or\nCUBLASLT_EPILOGUE_DGELU_BGRAD\nepilogue used. Must be divisible by 8.\nDefault value: 0.\nint64_t\nCUBLASLT_MATMUL_DESC_ALPHA_VECTOR_BATCH_STRIDE\nBatch stride for alpha vector. Used together with\nCUBLASLT_POINTER_MODE_ALPHA_DEVICE_VECTOR_BETA_HOST\nwhen matrix D’s\nCUBLASLT_MATRIX_LAYOUT_BATCH_COUNT\nis greater than 1. If\nCUBLASLT_POINTER_MODE_ALPHA_DEVICE_VECTOR_BETA_ZERO\nis set then\nCUBLASLT_MATMUL_DESC_ALPHA_VECTOR_BATCH_STRIDE\nmust be set to 0 as this mode doesn’t support batched alpha vector. If\ncublasLtBatchMode_t\nof any matrix is set to\nCUBLASLT_BATCH_MODE_POINTER_ARRAY\nthen\nCUBLASLT_MATMUL_DESC_ALPHA_VECTOR_BATCH_STRIDE\nmust be set to 0. Default value: 0.\nint64_t\nCUBLASLT_MATMUL_DESC_SM_COUNT_TARGET\nNumber of SMs to target for parallel execution. Optimizes heuristics for execution on a different number of SMs when user expects a concurrent stream to be using some of the device resources. Default value: 0.\nint32_t\nCUBLASLT_MATMUL_DESC_A_SCALE_POINTER\nDevice pointer to the scale factor value that converts data in matrix A to the compute data type range. The scaling factor must have the same type as the compute type. If not specified, or set to NULL, the scaling factor is assumed to be 1. If set for an unsupported matrix data, scale, and compute type combination, calling\ncublasLtMatmul()\nwill return\nCUBLAS_INVALID_VALUE\n. Default value: NULL\nconst\nvoid\n*\nCUBLASLT_MATMUL_DESC_B_SCALE_POINTER\nEquivalent to\nCUBLASLT_MATMUL_DESC_A_SCALE_POINTER\nfor matrix B. Default value: NULL\nconst\nvoid\n*\nCUBLASLT_MATMUL_DESC_C_SCALE_POINTER\nEquivalent to\nCUBLASLT_MATMUL_DESC_A_SCALE_POINTER\nfor matrix C. Default value: NULL\nconst\nvoid\n*\nCUBLASLT_MATMUL_DESC_D_SCALE_POINTER\nEquivalent to\nCUBLASLT_MATMUL_DESC_A_SCALE_POINTER\nfor matrix D. Default value: NULL\nconst\nvoid\n*\nCUBLASLT_MATMUL_DESC_AMAX_D_POINTER\nDevice pointer to the memory location that on completion will be set to the maximum of absolute values in the output matrix. The computed value has the same type as the compute type. If not specified, or set to NULL, the maximum absolute value is not computed. If set for an unsupported matrix data, scale, and compute type combination, calling\ncublasLtMatmul()\nwill return\nCUBLAS_INVALID_VALUE\n. Default value: NULL\nvoid\n*\nCUBLASLT_MATMUL_DESC_EPILOGUE_AUX_DATA_TYPE\nThe type of the data that will be stored in\nCUBLASLT_MATMUL_DESC_EPILOGUE_AUX_POINTER\n. If unset (or set to the default value of -1), the data type is set to be the output matrix element data type (DType) with some exceptions:\nReLu uses a bit-mask.\nFor FP8 kernels with an output type (DType) of\nCUDA_R_8F_E4M3\n, the data type can be set to a non-default value if:\nAType and BType are\nCUDA_R_8F_E4M3\n.\nBias Type is\nCUDA_R_16F\n.\nCType is\nCUDA_R_16BF\nor\nCUDA_R_16F\nCUBLASLT_MATMUL_DESC_EPILOGUE\nis set to\nCUBLASLT_EPILOGUE_GELU_AUX\nWhen CType is\nCUDA_R_16F\n, the data type may be set to\nCUDA_R_16F\nor\nCUDA_R_8F_E4M3\n. When CType is\nCUDA_R_16BF\n, the data type may be set to\nCUDA_R_16BF\n. Otherwise, the data type should be left unset or set to the default value of -1.\nIf set for an unsupported matrix data, scale, and compute type combination, calling\ncublasLtMatmul()\nwill return\nCUBLAS_INVALID_VALUE\n. Default value: -1\nint32_t\n(\ncudaDataType_t\n)\nCUBLASLT_MATMUL_DESC_EPILOGUE_AUX_SCALE_POINTER\nDevice pointer to the scaling factor value to convert results from compute type data range to storage data range in the auxiliary matrix that is set via\nCUBLASLT_MATMUL_DESC_EPILOGUE_AUX_POINTER\n. The scaling factor value must have the same type as the compute type. If not specified, or set to NULL, the scaling factor is assumed to be 1. If set for an unsupported matrix data, scale, and compute type combination, calling\ncublasLtMatmul()\nwill return\nCUBLAS_INVALID_VALUE\n. Default value: NULL\nvoid\n*\nCUBLASLT_MATMUL_DESC_EPILOGUE_AUX_AMAX_POINTER\nDevice pointer to the memory location that on completion will be set to the maximum of absolute values in the buffer that is set via\nCUBLASLT_MATMUL_DESC_EPILOGUE_AUX_POINTER\n. The computed value has the same type as the compute type. If not specified, or set to NULL, the maximum absolute value is not computed. If set for an unsupported matrix data, scale, and compute type combination, calling\ncublasLtMatmul()\nwill return\nCUBLAS_INVALID_VALUE\n. Default value: NULL\nvoid\n*\nCUBLASLT_MATMUL_DESC_FAST_ACCUM\nFlag for managing FP8 fast accumulation mode. When enabled, on some GPUs problem execution might be faster but at the cost of lower accuracy because intermediate results will not periodically be promoted to a higher precision. Currently this flag has an effect on the following GPUs: Ada, Hopper. Default value: 0 - fast accumulation mode is disabled\nint8_t\nCUBLASLT_MATMUL_DESC_BIAS_DATA_TYPE\nType of the bias or bias gradient vector in the device memory. Bias case: see\nCUBLASLT_EPILOGUE_BIAS\n. If unset (or set to the default value of -1), the bias vector elements are the same type as the elements of the output matrix (Dtype) with the following exceptions:\nIMMA kernels with computeType=\nCUDA_R_32I\nand\nCtype=CUDA_R_8I\nwhere the bias vector elements are the same type as alpha, beta (\nCUBLASLT_MATMUL_DESC_SCALE_TYPE=CUDA_R_32F\n)\nFor FP8 kernels with an output type of\nCUDA_R_32F\n,\nCUDA_R_8F_E4M3\nor\nCUDA_R_8F_E5M2\n. See\ncublasLtMatmul()\nfor more details.\nDefault value: -1\nint32_t\n(\ncudaDataType_t\n)\nCUBLASLT_MATMUL_DESC_A_SCALE_MODE\nScaling mode that defines how the matrix scaling factor for matrix A is interpreted. Default value: 0. See\ncublasLtMatmulMatrixScale_t\n.\nint32_t\nCUBLASLT_MATMUL_DESC_B_SCALE_MODE\nScaling mode that defines how the matrix scaling factor for matrix B is interpreted. Default value: 0. See\ncublasLtMatmulMatrixScale_t\n.\nint32_t\nCUBLASLT_MATMUL_DESC_C_SCALE_MODE\nScaling mode that defines how the matrix scaling factor for matrix C is interpreted. Default value: 0. See\ncublasLtMatmulMatrixScale_t\n.\nint32_t\nCUBLASLT_MATMUL_DESC_D_SCALE_MODE\nScaling mode that defines how the matrix scaling factor for matrix D is interpreted. Default value: 0. See\ncublasLtMatmulMatrixScale_t\n.\nint32_t\nCUBLASLT_MATMUL_DESC_EPILOGUE_AUX_SCALE_MODE\nScaling mode that defines how the matrix scaling factor for the auxiliary matrix is interpreted. Default value: 0. See\ncublasLtMatmulMatrixScale_t\n.\nint32_t\nCUBLASLT_MATMUL_DESC_D_OUT_SCALE_POINTER\nDevice pointer to the scale factors that are used to convert data in matrix D to the compute data type range. The scaling factor value type is defined by the scaling mode (see\nCUBLASLT_MATMUL_DESC_D_OUT_SCALE_MODE\n). If set for an unsupported matrix data, scale, scale mode, and compute type combination, or missing for a supported combination, then calling\ncublasLtMatmul()\nwill return\nCUBLAS_INVALID_VALUE\n. Default value: NULL.\nvoid\n*\nCUBLASLT_MATMUL_DESC_D_OUT_SCALE_MODE\nScaling mode that defines how the output matrix scaling factor for matrix D is interpreted. Default value: 0. See\ncublasLtMatmulMatrixScale_t\n.\nint32_t\nCUBLASLT_MATMUL_DESC_EMULATION_DESCRIPTOR\nEmulation descriptor to configure floating point emulation parameters. Default value: NULL.\nint32_t\n3.3.10.\ncublasLtMatmulHeuristicResult_t\n\ncublasLtMatmulHeuristicResult_t\nis a descriptor that holds the configured matrix multiplication algorithm descriptor and its runtime properties.\nMember\nDescription\ncublasLtMatmulAlgo_t\nalgo\nMust be initialized with\ncublasLtMatmulAlgoInit()\nif the preference\nCUBLASLT_MATMUL_PERF_SEARCH_MODE\nis set to\nCUBLASLT_SEARCH_LIMITED_BY_ALGO_ID\n. See\ncublasLtMatmulSearch_t\n.\nsize_t\nworkspaceSize;\nActual size of workspace memory required.\ncublasStatus_t\nstate;\nResult status. Other fields are valid only if, after call to\ncublasLtMatmulAlgoGetHeuristic()\n, this member is set to\nCUBLAS_STATUS_SUCCESS\n.\nfloat\nwavesCount;\nWaves count is a device utilization metric. A\nwavesCount\nvalue of 1.0f suggests that when the kernel is launched it will fully occupy the GPU.\nint\nreserved[4];\nReserved.\n3.3.11.\ncublasLtMatmulInnerShape_t\n\ncublasLtMatmulInnerShape_t\nis an enumerated type used to configure various aspects of the internal kernel design. This does not impact the CUDA grid size.\nValue\nDescription\nCUBLASLT_MATMUL_INNER_SHAPE_UNDEFINED\nInner shape is undefined.\nCUBLASLT_MATMUL_INNER_SHAPE_MMA884\nInner shape is MMA884.\nCUBLASLT_MATMUL_INNER_SHAPE_MMA1684\nInner shape is MMA1684.\nCUBLASLT_MATMUL_INNER_SHAPE_MMA1688\nInner shape is MMA1688.\nCUBLASLT_MATMUL_INNER_SHAPE_MMA16816\nInner shape is MMA16816.\n3.3.12.\ncublasLtMatmulPreference_t\n\nThe\ncublasLtMatmulPreference_t\nis a pointer to an opaque structure holding the description of the preferences for\ncublasLtMatmulAlgoGetHeuristic()\nconfiguration. Use\ncublasLtMatmulPreferenceCreate()\nto create one instance of the descriptor and\ncublasLtMatmulPreferenceDestroy()\nto destroy a previously created descriptor and release the resources.\n3.3.13.\ncublasLtMatmulPreferenceAttributes_t\n\ncublasLtMatmulPreferenceAttributes_t\nis an enumerated type used to apply algorithm search preferences while fine-tuning the heuristic function. Use\ncublasLtMatmulPreferenceGetAttribute()\nand\ncublasLtMatmulPreferenceSetAttribute()\nto get and set the attribute value of a matmul preference descriptor.\nValue\nDescription\nData Type\nCUBLASLT_MATMUL_PREF_SEARCH_MODE\nSearch mode. See\ncublasLtMatmulSearch_t\n. Default is\nCUBLASLT_SEARCH_BEST_FIT\n.\nuint32_t\nCUBLASLT_MATMUL_PREF_MAX_WORKSPACE_BYTES\nMaximum allowed workspace memory. Default is 0 (no workspace memory allowed).\nuint64_t\nCUBLASLT_MATMUL_PREF_REDUCTION_SCHEME_MASK\nReduction scheme mask. See\ncublasLtReductionScheme_t\n. Only algorithm configurations specifying\nCUBLASLT_ALGO_CONFIG_REDUCTION_SCHEME\nthat is not masked out by this attribute are allowed. For example, a mask value of 0x03 will allow only\nINPLACE\nand\nCOMPUTE_TYPE\nreduction schemes. Default is\nCUBLASLT_REDUCTION_SCHEME_MASK\n(i.e., allows all reduction schemes).\nuint32_t\nCUBLASLT_MATMUL_PREF_MIN_ALIGNMENT_A_BYTES\nMinimum buffer alignment for matrix A (in bytes). Selecting a smaller value will exclude algorithms that can not work with matrix A, which is not as strictly aligned as the algorithms need. Default is 256 bytes.\nuint32_t\nCUBLASLT_MATMUL_PREF_MIN_ALIGNMENT_B_BYTES\nMinimum buffer alignment for matrix B (in bytes). Selecting a smaller value will exclude algorithms that can not work with matrix B, which is not as strictly aligned as the algorithms need. Default is 256 bytes.\nuint32_t\nCUBLASLT_MATMUL_PREF_MIN_ALIGNMENT_C_BYTES\nMinimum buffer alignment for matrix C (in bytes). Selecting a smaller value will exclude algorithms that can not work with matrix C, which is not as strictly aligned as the algorithms need. Default is 256 bytes.\nuint32_t\nCUBLASLT_MATMUL_PREF_MIN_ALIGNMENT_D_BYTES\nMinimum buffer alignment for matrix D (in bytes). Selecting a smaller value will exclude algorithms that can not work with matrix D, which is not as strictly aligned as the algorithms need. Default is 256 bytes.\nuint32_t\nCUBLASLT_MATMUL_PREF_MAX_WAVES_COUNT\nMaximum wave count. See\ncublasLtMatmulHeuristicResult_t\n::wavesCount.\nSelecting a non-zero value will exclude algorithms that report device utilization higher than specified. Default is\n0.0f.\nfloat\nCUBLASLT_MATMUL_PREF_IMPL_MASK\nNumerical implementation details mask. See\ncublasLtNumericalImplFlags_t\n. Filters heuristic result to only include algorithms that use the allowed implementations. default: uint64_t(-1) (allow everything)\nuint64_t\n3.3.14.\ncublasLtMatmulSearch_t\n\ncublasLtMatmulSearch_t\nis an enumerated type that contains the attributes for heuristics search type.\nValue\nDescription\nData Type\nCUBLASLT_SEARCH_BEST_FIT\nRequest heuristics for the best algorithm for the given use case.\nCUBLASLT_SEARCH_LIMITED_BY_ALGO_ID\nRequest heuristics only for the pre-configured algo id.\n3.3.15.\ncublasLtMatmulTile_t\n\ncublasLtMatmulTile_t\nis an enumerated type used to set the tile size in\nrows\nx\ncolumns.\nSee also\nCUTLASS: Fast Linear Algebra in CUDA C++\n.\nValue\nDescription\nCUBLASLT_MATMUL_TILE_UNDEFINED\nTile size is undefined.\nCUBLASLT_MATMUL_TILE_8x8\nTile size is 8 rows x 8 columns.\nCUBLASLT_MATMUL_TILE_8x16\nTile size is 8 rows x 16 columns.\nCUBLASLT_MATMUL_TILE_16x8\nTile size is 16 rows x 8 columns.\nCUBLASLT_MATMUL_TILE_8x32\nTile size is 8 rows x 32 columns.\nCUBLASLT_MATMUL_TILE_16x16\nTile size is 16 rows x 16 columns.\nCUBLASLT_MATMUL_TILE_32x8\nTile size is 32 rows x 8 columns.\nCUBLASLT_MATMUL_TILE_8x64\nTile size is 8 rows x 64 columns.\nCUBLASLT_MATMUL_TILE_16x32\nTile size is 16 rows x 32 columns.\nCUBLASLT_MATMUL_TILE_32x16\nTile size is 32 rows x 16 columns.\nCUBLASLT_MATMUL_TILE_64x8\nTile size is 64 rows x 8 columns.\nCUBLASLT_MATMUL_TILE_32x32\nTile size is 32 rows x 32 columns.\nCUBLASLT_MATMUL_TILE_32x64\nTile size is 32 rows x 64 columns.\nCUBLASLT_MATMUL_TILE_64x32\nTile size is 64 rows x 32 columns.\nCUBLASLT_MATMUL_TILE_32x128\nTile size is 32 rows x 128 columns.\nCUBLASLT_MATMUL_TILE_64x64\nTile size is 64 rows x 64 columns.\nCUBLASLT_MATMUL_TILE_128x32\nTile size is 128 rows x 32 columns.\nCUBLASLT_MATMUL_TILE_64x128\nTile size is 64 rows x 128 columns.\nCUBLASLT_MATMUL_TILE_128x64\nTile size is 128 rows x 64 columns.\nCUBLASLT_MATMUL_TILE_64x256\nTile size is 64 rows x 256 columns.\nCUBLASLT_MATMUL_TILE_128x128\nTile size is 128 rows x 128 columns.\nCUBLASLT_MATMUL_TILE_256x64\nTile size is 256 rows x 64 columns.\nCUBLASLT_MATMUL_TILE_64x512\nTile size is 64 rows x 512 columns.\nCUBLASLT_MATMUL_TILE_128x256\nTile size is 128 rows x 256 columns.\nCUBLASLT_MATMUL_TILE_256x128\nTile size is 256 rows x 128 columns.\nCUBLASLT_MATMUL_TILE_512x64\nTile size is 512 rows x 64 columns.\nCUBLASLT_MATMUL_TILE_64x96\nTile size is 64 rows x 96 columns.\nCUBLASLT_MATMUL_TILE_96x64\nTile size is 96 rows x 64 columns.\nCUBLASLT_MATMUL_TILE_96x128\nTile size is 96 rows x 128 columns.\nCUBLASLT_MATMUL_TILE_128x160\nTile size is 128 rows x 160 columns.\nCUBLASLT_MATMUL_TILE_160x128\nTile size is 160 rows x 128 columns.\nCUBLASLT_MATMUL_TILE_192x128\nTile size is 192 rows x 128 columns.\nCUBLASLT_MATMUL_TILE_128x192\nTile size is 128 rows x 192 columns.\nCUBLASLT_MATMUL_TILE_128x96\nTile size is 128 rows x 96 columns.\n3.3.16.\ncublasLtMatmulStages_t\n\ncublasLtMatmulStages_t\nis an enumerated type used to configure the size and number of shared memory buffers where input elements are staged. Number of staging buffers defines kernel’s pipeline depth.\nValue\nDescription\nCUBLASLT_MATMUL_STAGES_UNDEFINED\nStage size is undefined.\nCUBLASLT_MATMUL_STAGES_16x1\nStage size is 16, number of stages is 1.\nCUBLASLT_MATMUL_STAGES_16x2\nStage size is 16, number of stages is 2.\nCUBLASLT_MATMUL_STAGES_16x3\nStage size is 16, number of stages is 3.\nCUBLASLT_MATMUL_STAGES_16x4\nStage size is 16, number of stages is 4.\nCUBLASLT_MATMUL_STAGES_16x5\nStage size is 16, number of stages is 5.\nCUBLASLT_MATMUL_STAGES_16x6\nStage size is 16, number of stages is 6.\nCUBLASLT_MATMUL_STAGES_32x1\nStage size is 32, number of stages is 1.\nCUBLASLT_MATMUL_STAGES_32x2\nStage size is 32, number of stages is 2.\nCUBLASLT_MATMUL_STAGES_32x3\nStage size is 32, number of stages is 3.\nCUBLASLT_MATMUL_STAGES_32x4\nStage size is 32, number of stages is 4.\nCUBLASLT_MATMUL_STAGES_32x5\nStage size is 32, number of stages is 5.\nCUBLASLT_MATMUL_STAGES_32x6\nStage size is 32, number of stages is 6.\nCUBLASLT_MATMUL_STAGES_64x1\nStage size is 64, number of stages is 1.\nCUBLASLT_MATMUL_STAGES_64x2\nStage size is 64, number of stages is 2.\nCUBLASLT_MATMUL_STAGES_64x3\nStage size is 64, number of stages is 3.\nCUBLASLT_MATMUL_STAGES_64x4\nStage size is 64, number of stages is 4.\nCUBLASLT_MATMUL_STAGES_64x5\nStage size is 64, number of stages is 5.\nCUBLASLT_MATMUL_STAGES_64x6\nStage size is 64, number of stages is 6.\nCUBLASLT_MATMUL_STAGES_128x1\nStage size is 128, number of stages is 1.\nCUBLASLT_MATMUL_STAGES_128x2\nStage size is 128, number of stages is 2.\nCUBLASLT_MATMUL_STAGES_128x3\nStage size is 128, number of stages is 3.\nCUBLASLT_MATMUL_STAGES_128x4\nStage size is 128, number of stages is 4.\nCUBLASLT_MATMUL_STAGES_128x5\nStage size is 128, number of stages is 5.\nCUBLASLT_MATMUL_STAGES_128x6\nStage size is 128, number of stages is 6.\nCUBLASLT_MATMUL_STAGES_32x10\nStage size is 32, number of stages is 10.\nCUBLASLT_MATMUL_STAGES_8x4\nStage size is 8, number of stages is 4.\nCUBLASLT_MATMUL_STAGES_16x10\nStage size is 16, number of stages is 10.\nCUBLASLT_MATMUL_STAGES_8x5\nStage size is 8, number of stages is 5.\nCUBLASLT_MATMUL_STAGES_8x3\nStage size is 8, number of stages is 3.\nCUBLASLT_MATMUL_STAGES_8xAUTO\nStage size is 8, number of stages is selected automatically.\nCUBLASLT_MATMUL_STAGES_16xAUTO\nStage size is 16, number of stages is selected automatically.\nCUBLASLT_MATMUL_STAGES_32xAUTO\nStage size is 32, number of stages is selected automatically.\nCUBLASLT_MATMUL_STAGES_64xAUTO\nStage size is 64, number of stages is selected automatically.\nCUBLASLT_MATMUL_STAGES_128xAUTO\nStage size is 128, number of stages is selected automatically.\nCUBLASLT_MATMUL_STAGES_256xAUTO\nStage size is 256, number of stages is selected automatically.\nCUBLASLT_MATMUL_STAGES_768xAUTO\nStage size is 768, number of stages is selected automatically.\n3.3.17.\ncublasLtNumericalImplFlags_t\n\ncublasLtNumericalImplFlags_t\n: a set of bit-flags that can be specified to select implementation details that may affect numerical behavior of algorithms.\nFlags below can be combined using the bit OR operator “|”.\nValue\nDescription\nCUBLASLT_NUMERICAL_IMPL_FLAGS_FMA\nSpecify that the implementation is based on [H,F,D]FMA (fused multiply-add) family instructions.\nCUBLASLT_NUMERICAL_IMPL_FLAGS_HMMA\nSpecify that the implementation is based on HMMA (tensor operation) family instructions.\nCUBLASLT_NUMERICAL_IMPL_FLAGS_IMMA\nSpecify that the implementation is based on IMMA (integer tensor operation) family instructions.\nCUBLASLT_NUMERICAL_IMPL_FLAGS_DMMA\nSpecify that the implementation is based on DMMA (double precision tensor operation) family instructions.\nCUBLASLT_NUMERICAL_IMPL_FLAGS_TENSOR_OP_MASK\nMask to filter implementations using any of the above kinds of tensor operations.\nCUBLASLT_NUMERICAL_IMPL_FLAGS_OP_TYPE_MASK\nMask to filter implementation details about multiply-accumulate instructions used.\nCUBLASLT_NUMERICAL_IMPL_FLAGS_ACCUMULATOR_16F\nSpecify that the implementation’s inner dot product is using half precision accumulator.\nCUBLASLT_NUMERICAL_IMPL_FLAGS_ACCUMULATOR_32F\nSpecify that the implementation’s inner dot product is using single precision accumulator.\nCUBLASLT_NUMERICAL_IMPL_FLAGS_ACCUMULATOR_64F\nSpecify that the implementation’s inner dot product is using double precision accumulator.\nCUBLASLT_NUMERICAL_IMPL_FLAGS_ACCUMULATOR_32I\nSpecify that the implementation’s inner dot product is using 32 bit signed integer precision accumulator.\nCUBLASLT_NUMERICAL_IMPL_FLAGS_ACCUMULATOR_TYPE_MASK\nMask to filter implementation details about accumulator used.\nCUBLASLT_NUMERICAL_IMPL_FLAGS_INPUT_16F\nSpecify that the implementation’s inner dot product multiply-accumulate instruction is using half-precision inputs.\nCUBLASLT_NUMERICAL_IMPL_FLAGS_INPUT_16BF\nSpecify that the implementation’s inner dot product multiply-accumulate instruction is using bfloat16 inputs.\nCUBLASLT_NUMERICAL_IMPL_FLAGS_INPUT_TF32\nSpecify that the implementation’s inner dot product multiply-accumulate instruction is using TF32 inputs.\nCUBLASLT_NUMERICAL_IMPL_FLAGS_INPUT_32F\nSpecify that the implementation’s inner dot product multiply-accumulate instruction is using single-precision inputs.\nCUBLASLT_NUMERICAL_IMPL_FLAGS_INPUT_64F\nSpecify that the implementation’s inner dot product multiply-accumulate instruction is using double-precision inputs.\nCUBLASLT_NUMERICAL_IMPL_FLAGS_INPUT_8I\nSpecify that the implementation’s inner dot product multiply-accumulate instruction is using 8-bit integer inputs.\nCUBLASLT_NUMERICAL_IMPL_FLAGS_OP_INPUT_TYPE_MASK\nMask to filter implementation details about accumulator input used.\nCUBLASLT_NUMERICAL_IMPL_FLAGS_GAUSSIAN\nSpecify that the implementation applies Gauss complexity reduction algorithm to reduce arithmetic complexity of the complex matrix multiplication problem\n3.3.18.\ncublasLtMatrixLayout_t\n\nThe\ncublasLtMatrixLayout_t\nis a pointer to an opaque structure holding the description of a matrix layout. Use\ncublasLtMatrixLayoutCreate()\nto create one instance of the descriptor and\ncublasLtMatrixLayoutDestroy()\nto destroy a previously created descriptor and release the resources.\n3.3.19.\ncublasLtMatrixLayoutAttribute_t\n\ncublasLtMatrixLayoutAttribute_t\nis a descriptor structure containing the attributes that define the details of the matrix operation. Use\ncublasLtMatrixLayoutGetAttribute()\nand\ncublasLtMatrixLayoutSetAttribute()\nto get and set the attribute value of a matrix layout descriptor.\nValue\nDescription\nData Type\nCUBLASLT_MATRIX_LAYOUT_TYPE\nSpecifies the data precision type. See\ncudaDataType_t\n.\nuint32_t\nCUBLASLT_MATRIX_LAYOUT_ORDER\nSpecifies the memory order of the data of the matrix. Default value is\nCUBLASLT_ORDER_COL\n. See\ncublasLtOrder_t\n.\nint32_t\nCUBLASLT_MATRIX_LAYOUT_ROWS\nDescribes the number of rows in the matrix. Normally only values that can be expressed as\nint32_t\nare supported.\nuint64_t\nCUBLASLT_MATRIX_LAYOUT_COLS\nDescribes the number of columns in the matrix. Normally only values that can be expressed as\nint32_t\nare supported.\nuint64_t\nCUBLASLT_MATRIX_LAYOUT_LD\nThe leading dimension of the matrix. For\nCUBLASLT_ORDER_COL\nthis is the stride (in elements) of matrix column. See also\ncublasLtOrder_t\n.\nCurrently only non-negative values are supported.\nMust be large enough so that matrix memory locations are not overlapping (e.g., greater or equal to\nCUBLASLT_MATRIX_LAYOUT_ROWS\nin case of\nCUBLASLT_ORDER_COL\n).\nint64_t\nCUBLASLT_MATRIX_LAYOUT_BATCH_COUNT\nNumber of matmul operations to perform in the batch. Default value is 1. See also\nCUBLASLT_ALGO_CAP_STRIDED_BATCH_SUPPORT\nand\nCUBLASLT_ALGO_CAP_POINTER_ARRAY_BATCH_SUPPORT\nin\ncublasLtMatmulAlgoCapAttributes_t\n.\nint32_t\nCUBLASLT_MATRIX_LAYOUT_STRIDED_BATCH_OFFSET\nStride (in elements) to the next matrix for the strided batch operation. Default value is 0. When matrix type is planar-complex (\nCUBLASLT_MATRIX_LAYOUT_PLANE_OFFSET\n!= 0), batch stride is interpreted by\ncublasLtMatmul()\nin number of real valued sub-elements. E.g. for data of type CUDA_C_16F, offset of 1024B is encoded as a stride of value 512 (since each element of the real and imaginary matrices is a 2B (16bit) floating point type). NOTE: A bug in\ncublasLtMatrixTransform()\ncauses it to interpret the batch stride for a planar-complex matrix as if it was specified in number of complex elements. Therefore an offset of 1024B must be encoded as stride value 256 when calling\ncublasLtMatrixTransform()\n(each complex element is 4B with real and imaginary values 2B each). This behavior is expected to be corrected in the next major cuBLAS version.\nint64_t\nCUBLASLT_MATRIX_LAYOUT_PLANE_OFFSET\nStride (in bytes) to the imaginary plane for planar-complex layout. Default value is 0, indicating that the layout is regular (real and imaginary parts of complex numbers are interleaved in memory for each element).\nint64_t\nCUBLASLT_MATRIX_LAYOUT_BATCH_MODE\nThe batch mode of the matrix. Default value is\nCUBLASLT_BATCH_MODE_STRIDED\n. See\ncublasLtBatchMode_t\n.\nint32_t\n3.3.20.\ncublasLtMatrixTransformDesc_t\n\nThe\ncublasLtMatrixTransformDesc_t\nis a pointer to an opaque structure holding the description of a matrix transformation operation. Use\ncublasLtMatrixTransformDescCreate()\nto create one instance of the descriptor and\ncublasLtMatrixTransformDescDestroy()\nto destroy a previously created descriptor and release the resources.\n3.3.21.\ncublasLtMatrixTransformDescAttributes_t\n\ncublasLtMatrixTransformDescAttributes_t\nis a descriptor structure containing the attributes that define the specifics of the matrix transform operation. Use\ncublasLtMatrixTransformDescGetAttribute()\nand\ncublasLtMatrixTransformDescSetAttribute()\nto set the attribute value of a matrix transform descriptor.\nValue\nDescription\nData Type\nCUBLASLT_MATRIX_TRANSFORM_DESC_SCALE_TYPE\nScale type. Inputs are converted to the scale type for scaling and summation, and results are then converted to the output type to store in the memory. For the supported data types see\ncudaDataType_t\n.\nint32_t\nCUBLASLT_MATRIX_TRANSFORM_DESC_POINTER_MODE\nSpecifies the scalars alpha and beta are passed by reference whether on the host or on the device. Default value is:\nCUBLASLT_POINTER_MODE_HOST\n(i.e., on the host). See\ncublasLtPointerMode_t\n.\nint32_t\nCUBLASLT_MATRIX_TRANSFORM_DESC_TRANSA\nSpecifies the type of operation that should be performed on the matrix A. Default value is:\nCUBLAS_OP_N\n(i.e., non-transpose operation). See\ncublasOperation_t\n.\nint32_t\nCUBLASLT_MATRIX_TRANSFORM_DESC_TRANSB\nSpecifies the type of operation that should be performed on the matrix B. Default value is:\nCUBLAS_OP_N\n(i.e., non-transpose operation). See\ncublasOperation_t\n.\nint32_t\n3.3.22.\ncublasLtOrder_t\n\ncublasLtOrder_t\nis an enumerated type used to indicate the data ordering of the matrix.\nValue\nDescription\nCUBLASLT_ORDER_COL\nData is ordered in column-major format. The leading dimension is the stride (in elements) to the beginning of next column in memory.\nCUBLASLT_ORDER_ROW\nData is ordered in row-major format. The leading dimension is the stride (in elements) to the beginning of next row in memory.\nCUBLASLT_ORDER_COL32\nData is ordered in column-major ordered tiles of 32 columns. The leading dimension is the stride (in elements) to the beginning of next group of 32-columns.\nFor example, if the matrix has 33 columns and 2 rows, then the leading dimension must be at least\n32\n*\n2\n=\n64\n.\nCUBLASLT_ORDER_COL4_4R2_8C\nData is ordered in column-major ordered tiles of composite tiles with total 32 columns and 8 rows. A tile is composed of interleaved inner tiles of 4 columns within 4 even or odd rows in an alternating pattern.\nThe leading dimension is the stride (in elements) to the beginning of the first 32 column x 8 row tile for the next 32-wide group of columns. For example, if the matrix has 33 columns and 1 row,\nthe leading dimension must be at least\n(32\n*\n8)\n*\n1\n=\n256\n.\nCUBLASLT_ORDER_COL32_2R_4R4\nData is ordered in column-major ordered tiles of composite tiles with total 32 columns ands 32 rows. Element offset within the tile is calculated as\n(((row\n%\n8)\n/\n2\n*\n4\n+\nrow\n/\n8)\n*\n2\n+\nrow\n%\n2)\n*\n32\n+\ncol\n.\nLeading dimension is the stride (in elements) to the beginning of the first 32 column x 32 row tile for the next 32-wide group of columns. E.g. if matrix has 33 columns and 1 row, then its leading dimensions\nmust be at least\n(32\n*\n32)\n*\n1\n=\n1024\n.\n3.3.23.\ncublasLtPointerMode_t\n\ncublasLtPointerMode_t\nis an enumerated type used to set the pointer mode for the scaling factors\nalpha\nand\nbeta\n.\nValue\nDescription\nCUBLASLT_POINTER_MODE_HOST\n=\nCUBLAS_POINTER_MODE_HOST\nMatches\nCUBLAS_POINTER_MODE_HOST\n, and the pointer targets a single value host memory.\nCUBLASLT_POINTER_MODE_DEVICE\n=\nCUBLAS_POINTER_MODE_DEVICE\nMatches\nCUBLAS_POINTER_MODE_DEVICE\n, and the pointer targets a single value device memory.\nCUBLASLT_POINTER_MODE_DEVICE_VECTOR\n= 2\nPointers target device memory vectors of length equal to the number of rows of matrix D.\nCUBLASLT_POINTER_MODE_ALPHA_DEVICE_VECTOR_BETA_ZERO\n= 3\nalpha\npointer targets a device memory vector of length equal to the number of rows of matrix D, and\nbeta\nis zero.\nCUBLASLT_POINTER_MODE_ALPHA_DEVICE_VECTOR_BETA_HOST\n= 4\nalpha\npointer targets a device memory vector of length equal to the number of rows of matrix D, and\nbeta\nis a single value in host memory.\nNote\nOnly pointer modes\nCUBLASLT_POINTER_MODE_HOST\nand\nCUBLASLT_POINTER_MODE_DEVICE\nare supported when\ncublasLtBatchMode_t\nof any matrix is set to\nCUBLASLT_BATCH_MODE_POINTER_ARRAY\n.\n3.3.24.\ncublasLtPointerModeMask_t\n\ncublasLtPointerModeMask_t\nis an enumerated type used to define and query the pointer mode capability.\nValue\nDescription\nCUBLASLT_POINTER_MODE_MASK_HOST\n=\n1\nSee\nCUBLASLT_POINTER_MODE_HOST\nin\ncublasLtPointerMode_t\n.\nCUBLASLT_POINTER_MODE_MASK_DEVICE\n=\n2\nSee\nCUBLASLT_POINTER_MODE_DEVICE\nin\ncublasLtPointerMode_t\n.\nCUBLASLT_POINTER_MODE_MASK_DEVICE_VECTOR\n=\n4\nSee\nCUBLASLT_POINTER_MODE_DEVICE_VECTOR\nin\ncublasLtPointerMode_t\nCUBLASLT_POINTER_MODE_MASK_ALPHA_DEVICE_VECTOR_BETA_ZERO\n=\n8\nSee\nCUBLASLT_POINTER_MODE_ALPHA_DEVICE_VECTOR_BETA_ZERO\nin\ncublasLtPointerMode_t\nCUBLASLT_POINTER_MODE_MASK_ALPHA_DEVICE_VECTOR_BETA_HOST\n=\n16\nSee\nCUBLASLT_POINTER_MODE_ALPHA_DEVICE_VECTOR_BETA_HOST\nin\ncublasLtPointerMode_t\n3.3.25.\ncublasLtReductionScheme_t\n\ncublasLtReductionScheme_t\nis an enumerated type used to specify a reduction scheme for the portions of the dot-product calculated in parallel (i.e., “split - K”).\nValue\nDescription\nCUBLASLT_REDUCTION_SCHEME_NONE\nDo not apply reduction. The dot-product will be performed in one sequence.\nCUBLASLT_REDUCTION_SCHEME_INPLACE\nReduction is performed “in place” using the output buffer, parts are added up in the output data type. Workspace is only used for counters that guarantee sequentiality.\nCUBLASLT_REDUCTION_SCHEME_COMPUTE_TYPE\nReduction done out of place in a user-provided workspace. The intermediate results are stored in the compute type in the workspace and reduced in a separate step.\nCUBLASLT_REDUCTION_SCHEME_OUTPUT_TYPE\nReduction done out of place in a user-provided workspace. The intermediate results are stored in the output type in the workspace and reduced in a separate step.\nCUBLASLT_REDUCTION_SCHEME_MASK\nAllows all reduction schemes.\n3.3.26.\ncublasLtMatmulMatrixScale_t\n\ncublasLtMatmulMatrixScale_t\nis an enumerated type used to specify scaling mode that defines how scaling factor pointers are interpreted.\nValue\nDescription\nCUBLASLT_MATMUL_MATRIX_SCALE_SCALAR_32F\nScaling factors are single-precision scalars applied to the whole tensors (this mode is the default for fp8). This is the only value valid for\nCUBLASLT_MATMUL_DESC_D_SCALE_MODE\nwhen the D tensor uses a narrow precision data type.\nCUBLASLT_MATMUL_MATRIX_SCALE_VEC16_UE4M3\nScaling factors are tensors that contain a dedicated scaling factor stored as an 8-bit\nCUDA_R_8F_UE4M3\nvalue for each 16-element block in the innermost dimension of the corresponding data tensor.\nCUBLASLT_MATMUL_MATRIX_SCALE_VEC32_UE8M0\nScaling factors are tensors that contain a dedicated scaling factor stored as an 8-bit\nCUDA_R_8F_UE8M0\nvalue for each 32-element block in the innermost dimension of the corresponding data tensor.\nCUBLASLT_MATMUL_MATRIX_SCALE_OUTER_VEC_32F\nScaling factors are vectors of CUDA_R_32F values. This mode is only applicable to matrices A and B, in which case the vectors are expected to have M and N elements respectively, and each (i, j)-th element of product of A and B is multiplied by i-th element of A scale and j-th element of B scale.\nCUBLASLT_MATMUL_MATRIX_SCALE_VEC128_32F\nScaling factors are tensors that contain a dedicated CUDA_R_32F scaling factor for each 128-element block in the innermost dimension of the corresponding data tensor.\nCUBLASLT_MATMUL_MATRIX_SCALE_BLK128x128_32F\nScaling factors are tensors that contain a dedicated CUDA_R_32F scaling factor for each 128x128-element block in the the corresponding data tensor.\n3.3.27.\ncublasLtBatchMode_t\n\nValue\nDescription\nCUBLASLT_BATCH_MODE_STRIDED\nThe matrices of each instance of the batch are located at fixed offsets in number of elements from their locations in the previous instance.\nCUBLASLT_BATCH_MODE_POINTER_ARRAY\nThe address of the matrix of each instance of the batch are read from arrays of pointers.\n3.3.28.\ncublasLtEmulationDesc_t\n\ncublasLtEmulationDesc_t\nis a pointer to an opaque structure holding the emulation descriptor. Use\ncublasLtEmulationDescCreate()\nto create a new emulation descriptor, and\ncublasLtEmulationDescDestroy()\nto destroy it and release the resources.\n3.3.29.\ncublasLtEmulationDescAttributes_t\n\ncublasLtEmulationDescAttributes_t\nis an enumerated type used to configure floating point emulation parameters. See\nFloating Point Emulation\ndocumentation for more details.\nValue\nDescription\nData Type\nCUBLASLT_EMULATION_DESC_STRATEGY\nStrategy, see\ncublasEmulationStrategy_t\n. Defines when to use floating point emulation algorithms. Default:\nEMULATION_STRATEGY_DEFAULT\n.\nint32_t\nCUBLASLT_EMULATION_DESC_SPECIAL_VALUES_SUPPORT\nSpecial values support, see\ncudaEmulationSpecialValuesSupport_t\n. Defines a bit mask of special cases in floating-point representations that must be supported. Default:\nEMULATION_SPECIAL_VALUE_HANDLING_DEFAULT\n.\nint32_t\nCUBLASLT_EMULATION_DESC_FIXEDPOINT_MANTISSA_CONTROL\nMantissa control, see\ncudaEmulationMantissaControl_t\n. For fixed-point emulation, defines how to compute the number of retained mantissa bits. See\nFloating Point Emulation\ndocumentation for more details.\nint32_t\nCUBLASLT_EMULATION_DESC_FIXEDPOINT_MAX_MANTISSA_BIT_COUNT\nFor fixed-point emulation only. An int32_t representing the maximum (up to quantization) number of mantissa bits to retain during fixed-point emulation. A default value of 0 allows the library to select a reasonable value based on device properties. Default: 0.\nint32_t\nCUBLASLT_EMULATION_DESC_FIXEDPOINT_MANTISSA_BIT_OFFSET\nThis parameter is for fixed-point emulation with\nCUDA_EMULATION_MANTISSA_CONTROL_DYNAMIC\nmantissa control (see\ncudaEmulationMantissaControl_t\n). An integer which can be used to bias the number of recommended mantissa bits. Default: 0.\nint32_t\nCUBLASLT_EMULATION_DESC_FIXEDPOINT_MANTISSA_BIT_COUNT_POINTER\nThis parameter is for fixed-point emulation. A device pointer which will contain the number of mantissa bits that were retained. If emulation is not used, the pointer will contain -1. Default: nullptr.\nint32_t\n*\n3.4.\ncuBLASLt API Reference\n\n3.4.1.\ncublasLtCreate()\n\ncublasStatus_t\ncublasLtCreate\n(\ncublasLtHandle_t\n*\nlighthandle\n)\nThis function initializes the cuBLASLt library and creates a handle to an opaque structure holding the cuBLASLt library context. It allocates light hardware resources on the host and device, and must be called prior to making any other cuBLASLt library calls.\nThe cuBLASLt library context is tied to the current CUDA device. To use the library on multiple devices, one cuBLASLt handle must be created for each device. Furthermore, the device must be set as the current before invoking cuBLASLt functions with a handle tied to that device.\nSee also:\ncuBLAS Context\n.\nParameters:\nParameter\nMemory\nInput / Output\nDescription\nlightHandle\nOutput\nPointer to the allocated cuBLASLt handle for the created cuBLASLt context.\nReturns:\nReturn Value\nDescription\nCUBLAS_STATUS_SUCCESS\nThe allocation completed successfully.\nCUBLAS_STATUS_NOT_INITIALIZED\nThe cuBLASLt library was not initialized. This usually happens:\nwhen\ncublasLtCreate()\nis not called first\nan error in the CUDA Runtime API called by the cuBLASLt routine, or\nan error in the hardware setup.\nCUBLAS_STATUS_ALLOC_FAILED\nResource allocation failed inside the cuBLASLt library. This is usually caused by a\ncudaMalloc()\nfailure.\nTo correct: prior to the function call, deallocate the previously allocated memory as much as possible.\nCUBLAS_STATUS_INVALID_VALUE\nlighthandle\nis NULL\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.2.\ncublasLtDestroy()\n\ncublasStatus_t\ncublasLtDestroy\n(\ncublasLtHandle_t\nlightHandle\n)\nThis function releases hardware resources used by the cuBLASLt library. This function is usually the last call with a particular handle to the cuBLASLt library. Because\ncublasLtCreate()\nallocates some internal resources and the release of those resources by calling\ncublasLtDestroy()\nwill implicitly call\ncudaDeviceSynchronize()\n, it is recommended to minimize the number of times these functions are called.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nlightHandle\nInput\nPointer to the cuBLASLt handle to be destroyed.\nReturns\n:\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe cuBLASLt context was successfully destroyed.\nCUBLAS_STATUS_NOT_INITIALIZED\nThe cuBLASLt library was not initialized.\nCUBLAS_STATUS_INVALID_VALUE\nlightHandle\nis NULL\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.3.\ncublasLtDisableCpuInstructionsSetMask()\n\nunsigned\ncublasLtDisableCpuInstructionsSetMask\n(\nunsigned\nmask\n);\nInstructs cuBLASLt library to not use\nCPU instructions\nspecified by the flags in the\nmask\n.\nThe function takes precedence over the\nCUBLASLT_DISABLE_CPU_INSTRUCTIONS_MASK\nenvironment variable.\nParameters:\nmask\n– the flags combined with bitwise\nOR(|)\noperator that specify which CPU instructions should not be used.\nSupported flags:\nValue\nDescription\n0x1\nx86-64 AVX512 ISA.\nReturns:\nthe previous value of the\nmask\n.\n3.4.4.\ncublasLtGetCudartVersion()\n\nsize_t\ncublasLtGetCudartVersion\n(\nvoid\n);\nThis function returns the version number of the CUDA Runtime library.\nParameters:\nNone.\nReturns:\nsize_t\n- The version number of the CUDA Runtime library.\n3.4.5.\ncublasLtGetProperty()\n\ncublasStatus_t\ncublasLtGetProperty\n(\nlibraryPropertyType\ntype\n,\nint\n*\nvalue\n);\nThis function returns the value of the requested property by writing it to the memory location pointed to by the value parameter.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\ntype\nInput\nOf the type\nlibraryPropertyType\n, whose value is requested from the property. See\nlibraryPropertyType_t\n.\nvalue\nOutput\nPointer to the host memory location where the requested information should be written.\nReturns\n:\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nThe requested\nlibraryPropertyType\ninformation is successfully written at the provided address.\nCUBLAS_STATUS_INVALID_VALUE\nIf invalid value of the\ntype\ninput argument, or\nif\nvalue\nis NULL\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.6.\ncublasLtGetStatusName()\n\nconst\nchar\n*\ncublasLtGetStatusName\n(\ncublasStatus_t\nstatus\n);\nReturns the string representation of a given status.\nParameters:\ncublasStatus_t\n- the status.\nReturns:\nconst\nchar*\n- the NULL-terminated string.\n3.4.7.\ncublasLtGetStatusString()\n\nconst\nchar\n*\ncublasLtGetStatusString\n(\ncublasStatus_t\nstatus\n);\nReturns the description string for a given status.\nParameters:\ncublasStatus_t\n- the status.\nReturns:\nconst\nchar*\n- the NULL-terminated string.\n3.4.8.\ncublasLtHeuristicsCacheGetCapacity()\n\ncublasStatus_t\ncublasLtHeuristicsCacheGetCapacity\n(\nsize_t\n*\ncapacity\n);\nReturns the\nHeuristics Cache\ncapacity.\nParameters:\nParameter\nDescription\ncapacity\nThe pointer to the returned capacity value.\nReturns:\nReturn Value\nDescription\nCUBLAS_STATUS_SUCCESS\nThe capacity was successfully written.\nCUBLAS_STATUS_INVALID_VALUE\nThe capacity was successfully set.\n3.4.9.\ncublasLtHeuristicsCacheSetCapacity()\n\ncublasStatus_t\ncublasLtHeuristicsCacheSetCapacity\n(\nsize_t\ncapacity\n);\nSets the\nHeuristics Cache\ncapacity. Set the capacity to 0 to disable the heuristics cache.\nThis function takes precedence over\nCUBLASLT_HEURISTICS_CACHE_CAPACITY\nenvironment variable.\nParameters:\nParameter\nDescription\ncapacity\nThe desirable heuristics cache capacity.\nReturns:\nReturn Value\nDescription\nCUBLAS_STATUS_SUCCESS\nThe capacity was successfully set.\n3.4.10.\ncublasLtGetVersion()\n\nsize_t\ncublasLtGetVersion\n(\nvoid\n);\nThis function returns the version number of cuBLASLt library.\nParameters:\nNone.\nReturns:\nsize_t\n- The version number of cuBLASLt library.\n3.4.11.\ncublasLtLoggerSetCallback()\n\ncublasStatus_t\ncublasLtLoggerSetCallback\n(\ncublasLtLoggerCallback_t\ncallback\n);\nExperimental: This function sets the logging callback function.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\ncallback\nInput\nPointer to a callback function. See\ncublasLtLoggerCallback_t\n.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_SUCCESS\nIf the callback function was successfully set.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.12.\ncublasLtLoggerSetFile()\n\ncublasStatus_t\ncublasLtLoggerSetFile\n(\nFILE\n*\nfile\n);\nExperimental: This function sets the logging output file. Note: once registered using this function call, the provided file handle must not be closed unless the function is called again to switch to a different file handle.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nfile\nInput\nPointer to an open file. File should have write permission.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_SUCCESS\nIf logging file was successfully set.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.13.\ncublasLtLoggerOpenFile()\n\ncublasStatus_t\ncublasLtLoggerOpenFile\n(\nconst\nchar\n*\nlogFile\n);\nExperimental: This function opens a logging output file in the given path.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nlogFile\nInput\nPath of the logging output file.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_SUCCESS\nIf the logging file was successfully opened.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.14.\ncublasLtLoggerSetLevel()\n\ncublasStatus_t\ncublasLtLoggerSetLevel\n(\nint\nlevel\n);\nExperimental: This function sets the value of the logging level.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nlevel\nInput\nValue of the logging level. See\ncuBLASLt Logging\n.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_INVALID_VALUE\nIf the value was not a valid logging level. See\ncuBLASLt Logging\n.\nCUBLAS_STATUS_SUCCESS\nIf the logging level was successfully set.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.15.\ncublasLtLoggerSetMask()\n\ncublasStatus_t\ncublasLtLoggerSetMask\n(\nint\nmask\n);\nExperimental: This function sets the value of the logging mask.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nmask\nInput\nValue of the logging mask. See\ncuBLASLt Logging\n.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_SUCCESS\nIf the logging mask was successfully set.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.16.\ncublasLtLoggerForceDisable()\n\ncublasStatus_t\ncublasLtLoggerForceDisable\n();\nExperimental: This function disables logging for the entire run.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_SUCCESS\nIf logging was successfully disabled.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.17.\ncublasLtMatmul()\n\ncublasStatus_t\ncublasLtMatmul\n(\ncublasLtHandle_t\nlightHandle\n,\ncublasLtMatmulDesc_t\ncomputeDesc\n,\nconst\nvoid\n*\nalpha\n,\nconst\nvoid\n*\nA\n,\ncublasLtMatrixLayout_t\nAdesc\n,\nconst\nvoid\n*\nB\n,\ncublasLtMatrixLayout_t\nBdesc\n,\nconst\nvoid\n*\nbeta\n,\nconst\nvoid\n*\nC\n,\ncublasLtMatrixLayout_t\nCdesc\n,\nvoid\n*\nD\n,\ncublasLtMatrixLayout_t\nDdesc\n,\nconst\ncublasLtMatmulAlgo_t\n*\nalgo\n,\nvoid\n*\nworkspace\n,\nsize_t\nworkspaceSizeInBytes\n,\ncudaStream_t\nstream\n);\nThis function computes the matrix multiplication of matrices A and B to produce the output matrix D, according to the following operation:\nD\n=\nalpha*(A*B)\n+\nbeta*(C),\nwhere\nA\n,\nB\n, and\nC\nare input matrices, and\nalpha\nand\nbeta\nare input scalars.\nNote\nThis function supports both in-place matrix multiplication (\nC\n==\nD\nand\nCdesc\n==\nDdesc\n) and out-of-place matrix multiplication (\nC\n!=\nD\n, both matrices must have the same data type, number of rows, number of columns, batch size, and memory order). In the out-of-place case, the leading dimension of C can be different from the leading dimension of D. Specifically the leading dimension of C can be 0 to achieve row or column broadcast. If\nCdesc\nis omitted, this function assumes it to be equal to\nDdesc\n.\nThe\nworkspace\npointer must be aligned to at least a multiple of 256 bytes.\nThe recommendations on\nworkspaceSizeInBytes\nare the same as mentioned in the\ncublasSetWorkspace()\nsection.\nDatatypes Supported:\ncublasLtMatmul()\nsupports the following computeType, scaleType, Atype/Btype, and Ctype. Footnotes can be found at the end of this section.\nTable 1. When A, B, C, and D are Regular Column- or Row-major Matrices\n\ncomputeType\nscaleType\nAtype/Btype\nCtype\nBias Type\n6\nCUBLAS_COMPUTE_16F\nor\nCUBLAS_COMPUTE_16F_PEDANTIC\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_16F\n6\nCUBLAS_COMPUTE_32I\nor\nCUBLAS_COMPUTE_32I_PEDANTIC\nCUDA_R_32I\nCUDA_R_8I\nCUDA_R_32I\nEpilogue is not supported.\nCUDA_R_32F\nCUDA_R_8I\nCUDA_R_8I\nEpilogue is not supported.\nCUBLAS_COMPUTE_32F\nor\nCUBLAS_COMPUTE_32F_PEDANTIC\nCUDA_R_32F\nCUDA_R_16BF\nCUDA_R_16BF\nCUDA_R_16BF\n6\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_16F\n6\nCUDA_R_8I\nCUDA_R_32F\nEpilogue is not supported.\nCUDA_R_16BF\nCUDA_R_32F\nCUDA_R_32F\n6\nCUDA_R_16F\nCUDA_R_32F\nCUDA_R_32F\n6\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\n6\nCUDA_C_32F\n7\nCUDA_C_8I\n7\nCUDA_C_32F\n7\nEpilogue is not supported.\nCUDA_C_32F\n7\nCUDA_C_32F\n7\nCUBLAS_COMPUTE_32F_FAST_16F\nor\nCUBLAS_COMPUTE_32F_FAST_16BF\nor\nCUBLAS_COMPUTE_32F_FAST_TF32\nor\nCUBLAS_COMPUTE_32F_EMULATED_16BFX9\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\n6\nCUDA_C_32F\n7\nCUDA_C_32F\n7\nCUDA_C_32F\n7\nEpilogue is not supported.\nCUBLAS_COMPUTE_64F\nor\nCUBLAS_COMPUTE_64F_PEDANTIC\nor\nCUBLAS_COMPUTE_64F_EMULATED_FIXEDPOINT\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\n6\nCUDA_C_64F\n7\nCUDA_C_64F\n7\nCUDA_C_64F\n7\nEpilogue is not supported.\nTo use IMMA kernels, one of the following sets of requirements, with the first being the preferred one, must be met:\nUsing a regular data ordering:\nAll matrix pointers must be 4-byte aligned. For even better performance, this condition should hold with 16 instead of 4.\nLeading dimensions of matrices A, B, C must be multiples of 4.\nOnly the “TN” format is supported - A must be transposed and B non-transposed.\nPointer mode can be\nCUBLASLT_POINTER_MODE_HOST\n,\nCUBLASLT_POINTER_MODE_DEVICE\nor\nCUBLASLT_POINTER_MODE_ALPHA_DEVICE_VECTOR_BETA_HOST\n. With the latter mode, the kernels support the\nCUBLASLT_MATMUL_DESC_ALPHA_VECTOR_BATCH_STRIDE\nattribute.\nDimensions m and k must be multiples of 4.\nUsing the IMMA-specific data ordering on Ampere (compute capability 8.0) or Turing (compute capability 7.5) (but not Hopper, compute capability 9.0, or later) architecture -\nCUBLASLT_ORDER_COL32`\nfor matrices A, C, D, and\nCUBLASLT_ORDER_COL4_4R2_8C\n(on Turing or Ampere architecture) or\nCUBLASLT_ORDER_COL32_2R_4R4\n(on Ampere architecture) for matrix B:\nLeading dimensions of matrices A, B, C must fulfill conditions specific to the memory ordering (see\ncublasLtOrder_t\n).\nMatmul descriptor must specify\nCUBLAS_OP_T\non matrix B and\nCUBLAS_OP_N\n(default) on matrix A and C.\nIf scaleType\nCUDA_R_32I\nis used, the only supported values for\nalpha\nand\nbeta\nare\n0\nor\n1\n.\nPointer mode can be\nCUBLASLT_POINTER_MODE_HOST\n,\nCUBLASLT_POINTER_MODE_DEVICE\n,\nCUBLASLT_POINTER_MODE_DEVICE_VECTOR\nor\nCUBLASLT_POINTER_MODE_ALPHA_DEVICE_VECTOR_BETA_ZERO\n. These kernels do not support\nCUBLASLT_MATMUL_DESC_ALPHA_VECTOR_BATCH_STRIDE\n.\nOnly the “NT” format is supported - A must be non-transposed and B transposed.\nTable 2. When A, B, C, and D Use Layouts for IMMA\n\ncomputeType\nscaleType\nAtype/Btype\nCtype\nBias Type\nCUBLAS_COMPUTE_32I\nor\nCUBLAS_COMPUTE_32I_PEDANTIC\nCUDA_R_32I\nCUDA_R_8I\nCUDA_R_32I\nNon-default epilogue not supported.\nCUDA_R_32F\nCUDA_R_8I\nCUDA_R_8I\nCUDA_R_32F\nTo use tensor- or block-scaled FP8 kernels, the following set of requirements must be satisfied:\nAll matrix dimensions must meet the optimal requirements listed in\nTensor Core Usage\n(i.e. pointers and matrix dimension must support 16-byte alignment).\nScaling mode must meet the restrictions noted in the\nScaling Mode Support Overview\ntable.\nA must be transposed and B non-transposed (The “TN” format) on Ada (compute capability 8.9), Hopper (compute capability 9.0), and Blackwell GeForce (compute capability 12.x) GPUs.\nThe compute type must be\nCUBLAS_COMPUTE_32F\n.\nThe scale type must be\nCUDA_R_32F\n.\nSee the table below when using FP8 kernels:\nTable 3. When A, B, C, and D Use Layouts for FP8\n\nAType\nBType\nCType\nDType\nBias Type\nCUDA_R_8F_E4M3\nCUDA_R_8F_E4M3\nCUDA_R_16BF\nCUDA_R_16BF\nCUDA_R_16BF\n6\nCUDA_R_8F_E4M3\n8\nCUDA_R_16BF\n6\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_16F\n6\nCUDA_R_8F_E4M3\n8\nCUDA_R_16F\n6\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_16BF\n6\nCUDA_R_8F_E5M2\nCUDA_R_16BF\nCUDA_R_16BF\nCUDA_R_16BF\n6\nCUDA_R_8F_E4M3\n8\nCUDA_R_16BF\n6\nCUDA_R_8F_E5M2\n8\nCUDA_R_16BF\n6\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_16F\n6\nCUDA_R_8F_E4M3\n8\nCUDA_R_16F\n6\nCUDA_R_8F_E5M2\n8\nCUDA_R_16F\n6\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_16BF\n6\nCUDA_R_8F_E5M2\nCUDA_R_8F_E4M3\nCUDA_R_16BF\nCUDA_R_16BF\nCUDA_R_16BF\n6\nCUDA_R_8F_E4M3\n8\nCUDA_R_16BF\n6\nCUDA_R_8F_E5M2\n8\nCUDA_R_16BF\n6\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_16F\n6\nCUDA_R_8F_E4M3\n8\nCUDA_R_16F\n6\nCUDA_R_8F_E5M2\n8\nCUDA_R_16F\n6\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_16BF\n6\nTo use block-scaled FP4 kernels, the following set of requirements must be satisfied:\nAll matrix dimensions must meet the optimal requirements listed in\nTensor Core Usage\n(i.e. pointers and matrix dimension must support 16-byte alignment).\nScaling mode must be\nCUBLASLT_MATMUL_MATRIX_SCALE_VEC16_UE4M3\nA must be transposed and B non-transposed (The “TN” format)\nThe compute type must be\nCUBLAS_COMPUTE_32F\n.\nThe scale type must be\nCUDA_R_32F\n.\nTable 4. When A, B, C, and D Use Layouts for FP4\n\nAType\nBType\nCType\nDType\nBias Type\nCUDA_R_4F_E2M1\nCUDA_R_4F_E2M1\nCUDA_R_16BF\nCUDA_R_16BF\nCUDA_R_16BF\n6\nCUDA_R_4F_E2M1\nCUDA_R_16BF\n6\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_16F\n6\nCUDA_R_4F_E2M1\nCUDA_R_16F\n6\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_16BF\n6\nAnd finally, see below table when A,B,C,D are planar-complex matrices (\nCUBLASLT_MATRIX_LAYOUT_PLANE_OFFSET\n!=\n0\n, see\ncublasLtMatrixLayoutAttribute_t\n) to make use of mixed precision tensor core acceleration.\nTable 5. When A, B, C, and D are Planar-Complex Matrices\n\ncomputeType\nscaleType\nAtype/Btype\nCtype\nCUBLAS_COMPUTE_32F\nCUDA_C_32F\nCUDA_C_16F\n7\nCUDA_C_16F\n7\nCUDA_C_32F\n7\nCUDA_C_16BF\n7\nCUDA_C_16BF\n7\nCUDA_C_32F\n7\nNOTES:\n6\n(\n1\n,\n2\n,\n3\n,\n4\n,\n5\n,\n6\n,\n7\n,\n8\n,\n9\n,\n10\n,\n11\n,\n12\n,\n13\n,\n14\n,\n15\n,\n16\n,\n17\n,\n18\n,\n19\n,\n20\n,\n21\n,\n22\n,\n23\n,\n24\n,\n25\n,\n26\n,\n27\n,\n28\n,\n29\n,\n30\n,\n31\n,\n32\n,\n33\n)\nReLU, dReLu, GELU, dGELU and Bias epilogue modes (see\nCUBLASLT_MATMUL_DESC_EPILOGUE\nin\ncublasLtMatmulDescAttributes_t\n) are not supported when D matrix memory order is defined as\nCUBLASLT_ORDER_ROW\n. For best performance when using the bias vector, specify zero beta and set pointer mode to\nCUBLASLT_POINTER_MODE_HOST\n.\n7\n(\n1\n,\n2\n,\n3\n,\n4\n,\n5\n,\n6\n,\n7\n,\n8\n,\n9\n,\n10\n,\n11\n,\n12\n,\n13\n,\n14\n,\n15\n,\n16\n,\n17\n)\nUse of\nCUBLAS_ORDER_ROW\ntogether with\nCUBLAS_OP_C\n(Hermitian operator) is not supported unless all of A, B, C, and D matrices use the\nCUBLAS_ORDER_ROW\nordering.\n8\n(\n1\n,\n2\n,\n3\n,\n4\n,\n5\n,\n6\n,\n7\n,\n8\n,\n9\n,\n10\n)\nFP8 DType is not supported when scaling modes are one of\nCUBLASLT_MATMUL_MATRIX_SCALE_OUTER_VEC_32F\n,\nCUBLASLT_MATMUL_MATRIX_SCALE_VEC128_32F\n, and\nCUBLASLT_MATMUL_MATRIX_SCALE_BLK128x128_32F\n.\nParameters:\nParameter\nMemory\nInput / Output\nDescription\nlightHandle\nInput\nPointer to the allocated cuBLASLt handle for the cuBLASLt context. See\ncublasLtHandle_t\n.\ncomputeDesc\nInput\nHandle to a previously created matrix multiplication descriptor of type\ncublasLtMatmulDesc_t\n.\nalpha\n,\nbeta\nDevice or host\nInput\nPointers to the scalars used in the multiplication.\nA\n,\nB\n, and\nC\nDevice\nInput\nPointers to the GPU memory associated with the corresponding descriptors\nAdesc\n,\nBdesc\nand\nCdesc\n.\nAdesc\n,\nBdesc\nand\nCdesc\nInput\nHandles to the previous created descriptors of the type\ncublasLtMatrixLayout_t\n.\nD\nDevice\nOutput\nPointer to the GPU memory associated with the descriptor\nDdesc\n.\nDdesc\nInput\nHandle to the previous created descriptor of the type\ncublasLtMatrixLayout_t\n.\nalgo\nInput\nHandle for matrix multiplication algorithm to be used. See\ncublasLtMatmulAlgo_t\n. When NULL, an implicit heuristics query with default search preferences will be performed to determine actual algorithm to use.\nworkspace\nDevice\nPointer to the workspace buffer allocated in the GPU memory. Must be 256B aligned (i.e. lowest 8 bits of address must be 0).\nworkspaceSizeInBytes\nInput\nSize of the workspace.\nstream\nHost\nInput\nThe CUDA stream where all the GPU work will be submitted.\nReturns:\nReturn Value\nDescription\nCUBLAS_STATUS_NOT_INITIALIZED\nIf cuBLASLt handle has not been initialized.\nCUBLAS_STATUS_INVALID_VALUE\nIf the parameters are unexpectedly NULL, in conflict or in an impossible configuration. For example, when\nworkspaceSizeInBytes\nis less than workspace required by the configured algo.\nCUBLAS_STATUS_NOT_SUPPORTED\nIf the current implementation on the selected device doesn’t support the configured operation.\nCUBLAS_STATUS_ARCH_MISMATCH\nIf the configured operation cannot be run using the selected device.\nCUBLAS_STATUS_EXECUTION_FAILED\nIf CUDA reported an execution error from the device.\nCUBLAS_STATUS_SUCCESS\nIf the operation completed successfully.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.18.\ncublasLtMatmulAlgoCapGetAttribute()\n\ncublasStatus_t\ncublasLtMatmulAlgoCapGetAttribute\n(\nconst\ncublasLtMatmulAlgo_t\n*\nalgo\n,\ncublasLtMatmulAlgoCapAttributes_t\nattr\n,\nvoid\n*\nbuf\n,\nsize_t\nsizeInBytes\n,\nsize_t\n*\nsizeWritten\n);\nThis function returns the value of the queried capability attribute for an initialized\ncublasLtMatmulAlgo_t\ndescriptor structure. The capability attribute value is retrieved from the enumerated type\ncublasLtMatmulAlgoCapAttributes_t\n.\nFor example, to get list of supported Tile IDs:\ncublasLtMatmulTile_t\ntiles\n[\nCUBLASLT_MATMUL_TILE_END\n];\nsize_t\nnum_tiles\n,\nsize_written\n;\nif\n(\ncublasLtMatmulAlgoCapGetAttribute\n(\nalgo\n,\nCUBLASLT_ALGO_CAP_TILE_IDS\n,\ntiles\n,\nsizeof\n(\ntiles\n),\n&\nsize_written\n)\n==\nCUBLAS_STATUS_SUCCESS\n)\n{\nnum_tiles\n=\nsize_written\n/\nsizeof\n(\ntiles\n[\n0\n]);}\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nalgo\nInput\nPointer to the previously created opaque structure holding the matrix multiply algorithm descriptor. See\ncublasLtMatmulAlgo_t\n.\nattr\nInput\nThe capability attribute whose value will be retrieved by this function. See\ncublasLtMatmulAlgoCapAttributes_t\n.\nbuf\nOutput\nThe attribute value returned by this function.\nsizeInBytes\nInput\nSize of\nbuf\nbuffer (in bytes) for verification.\nsizeWritten\nOutput\nValid only when the return value is\nCUBLAS_STATUS_SUCCESS\n. If\nsizeInBytes\nis non-zero: then\nsizeWritten\nis the number of bytes actually written; if\nsizeInBytes\nis 0: then\nsizeWritten\nis the number of bytes needed to write full contents.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_INVALID_VALUE\nIf\nsizeInBytes\nis 0 and\nsizeWritten\nis NULL, or\nif\nsizeInBytes\nis non-zero and\nbuf\nis NULL, or\nif\nsizeInBytes\ndoesn’t match size of internal storage for the selected attribute\nCUBLAS_STATUS_SUCCESS\nIf attribute’s value was successfully written to user memory.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.19.\ncublasLtMatmulAlgoCheck()\n\ncublasStatus_t\ncublasLtMatmulAlgoCheck\n(\ncublasLtHandle_t\nlightHandle\n,\ncublasLtMatmulDesc_t\noperationDesc\n,\ncublasLtMatrixLayout_t\nAdesc\n,\ncublasLtMatrixLayout_t\nBdesc\n,\ncublasLtMatrixLayout_t\nCdesc\n,\ncublasLtMatrixLayout_t\nDdesc\n,\nconst\ncublasLtMatmulAlgo_t\n*\nalgo\n,\ncublasLtMatmulHeuristicResult_t\n*\nresult\n);\nThis function performs the correctness check on the matrix multiply algorithm descriptor for the matrix multiply operation\ncublasLtMatmul()\nfunction with the given input matrices A, B and C, and the output matrix D. It checks whether the descriptor is supported on the current device, and returns the result containing the required workspace and the calculated wave count.\nNote\nCUBLAS_STATUS_SUCCESS\ndoesn’t fully guarantee that the algo will run. The algo will fail if, for example, the buffers are not correctly aligned. However, if\ncublasLtMatmulAlgoCheck()\nfails, the algo will not run.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nlightHandle\nInput\nPointer to the allocated cuBLASLt handle for the cuBLASLt context. See\ncublasLtHandle_t\n.\noperationDesc\nInput\nHandle to a previously created matrix multiplication descriptor of type\ncublasLtMatmulDesc_t\n.\nAdesc\n,\nBdesc\n,\nCdesc\n, and\nDdesc\nInput\nHandles to the previously created matrix layout descriptors of the type\ncublasLtMatrixLayout_t\n.\nalgo\nInput\nDescriptor which specifies which matrix multiplication algorithm should be used. See\ncublasLtMatmulAlgo_t\n. May point to\nresult->algo\n.\nresult\nOutput\nPointer to the structure holding the results returned by this function. The results comprise of the required workspace and the calculated wave count. The\nalgo\nfield is never updated. See\ncublasLtMatmulHeuristicResult_t\n.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_INVALID_VALUE\nIf matrix layout descriptors or the operation descriptor do not match the\nalgo\ndescriptor.\nCUBLAS_STATUS_NOT_SUPPORTED\nIf the\nalgo\nconfiguration or data type combination is not currently supported on the given device.\nCUBLAS_STATUS_ARCH_MISMATCH\nIf the\nalgo\nconfiguration cannot be run using the selected device.\nCUBLAS_STATUS_SUCCESS\nIf the check was successful.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.20.\ncublasLtMatmulAlgoConfigGetAttribute()\n\ncublasStatus_t\ncublasLtMatmulAlgoConfigGetAttribute\n(\nconst\ncublasLtMatmulAlgo_t\n*\nalgo\n,\ncublasLtMatmulAlgoConfigAttributes_t\nattr\n,\nvoid\n*\nbuf\n,\nsize_t\nsizeInBytes\n,\nsize_t\n*\nsizeWritten\n);\nThis function returns the value of the queried configuration attribute for an initialized\ncublasLtMatmulAlgo_t\ndescriptor. The configuration attribute value is retrieved from the enumerated type\ncublasLtMatmulAlgoConfigAttributes_t\n.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nalgo\nInput\nPointer to the previously created opaque structure holding the matrix multiply algorithm descriptor. See\ncublasLtMatmulAlgo_t\n.\nattr\nInput\nThe configuration attribute whose value will be retrieved by this function. See\ncublasLtMatmulAlgoConfigAttributes_t\n.\nbuf\nOutput\nThe attribute value returned by this function.\nsizeInBytes\nInput\nSize of\nbuf\nbuffer (in bytes) for verification.\nsizeWritten\nOutput\nValid only when the return value is\nCUBLAS_STATUS_SUCCESS\n. If\nsizeInBytes\nis non-zero: then\nsizeWritten\nis the number of bytes actually written; if\nsizeInBytes\nis 0: then\nsizeWritten\nis the number of bytes needed to write full contents.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_INVALID_VALUE\nIf\nsizeInBytes\nis 0 and\nsizeWritten\nis NULL, or\nif\nsizeInBytes\nis non-zero and\nbuf\nis NULL, or\nif\nsizeInBytes\ndoesn’t match size of internal storage for the selected attribute\nCUBLAS_STATUS_SUCCESS\nIf attribute’s value was successfully written to user memory.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.21.\ncublasLtMatmulAlgoConfigSetAttribute()\n\ncublasStatus_t\ncublasLtMatmulAlgoConfigSetAttribute\n(\ncublasLtMatmulAlgo_t\n*\nalgo\n,\ncublasLtMatmulAlgoConfigAttributes_t\nattr\n,\nconst\nvoid\n*\nbuf\n,\nsize_t\nsizeInBytes\n);\nThis function sets the value of the specified configuration attribute for an initialized\ncublasLtMatmulAlgo_t\ndescriptor. The configuration attribute is an enumerant of the type\ncublasLtMatmulAlgoConfigAttributes_t\n.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nalgo\nInput\nPointer to the previously created opaque structure holding the matrix multiply algorithm descriptor. See\ncublasLtMatmulAlgo_t\n.\nattr\nInput\nThe configuration attribute whose value will be set by this function. See\ncublasLtMatmulAlgoConfigAttributes_t\n.\nbuf\nInput\nThe value to which the configuration attribute should be set.\nsizeInBytes\nInput\nSize of\nbuf\nbuffer (in bytes) for verification.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_INVALID_VALUE\nIf\nbuf\nis NULL or\nsizeInBytes\ndoesn’t match the size of the internal storage for the selected attribute.\nCUBLAS_STATUS_SUCCESS\nIf the attribute was set successfully.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.22.\ncublasLtMatmulAlgoGetHeuristic()\n\ncublasStatus_t\ncublasLtMatmulAlgoGetHeuristic\n(\ncublasLtHandle_t\nlightHandle\n,\ncublasLtMatmulDesc_t\noperationDesc\n,\ncublasLtMatrixLayout_t\nAdesc\n,\ncublasLtMatrixLayout_t\nBdesc\n,\ncublasLtMatrixLayout_t\nCdesc\n,\ncublasLtMatrixLayout_t\nDdesc\n,\ncublasLtMatmulPreference_t\npreference\n,\nint\nrequestedAlgoCount\n,\ncublasLtMatmulHeuristicResult_t\nheuristicResultsArray\n[],\nint\n*\nreturnAlgoCount\n);\nThis function retrieves the possible algorithms for the matrix multiply operation\ncublasLtMatmul()\nfunction with the given input matrices A, B and C, and the output matrix D. The output is placed in\nheuristicResultsArray[]\nin the order of increasing estimated compute time.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nlightHandle\nInput\nPointer to the allocated cuBLASLt handle for the cuBLASLt context. See\ncublasLtHandle_t\n.\noperationDesc\nInput\nHandle to a previously created matrix multiplication descriptor of type\ncublasLtMatmulDesc_t\n.\nAdesc\n,\nBdesc\n,\nCdesc\n, and\nDdesc\nInput\nHandles to the previously created matrix layout descriptors of the type\ncublasLtMatrixLayout_t\n.\npreference\nInput\nPointer to the structure holding the heuristic search preferences descriptor. See\ncublasLtMatmulPreference_t\n.\nrequestedAlgoCount\nInput\nSize of the\nheuristicResultsArray\n(in elements). This is the requested maximum number of algorithms to return.\nheuristicResultsArray[]\nOutput\nArray containing the algorithm heuristics and associated runtime characteristics, returned by this function, in the order of increasing estimated compute time.\nreturnAlgoCount\nOutput\nNumber of algorithms returned by this function. This is the number of\nheuristicResultsArray\nelements written.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_INVALID_VALUE\nIf\nrequestedAlgoCount\nis less or equal to zero.\nCUBLAS_STATUS_NOT_SUPPORTED\nIf no heuristic function available for current configuration.\nCUBLAS_STATUS_SUCCESS\nIf query was successful. Inspect\nheuristicResultsArray[0\nto\n(returnAlgoCount\n-1)].state\nfor the status of the results.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\nNote\nThis function may load some kernels using CUDA Driver API which may fail when there is no available GPU memory. Do not allocate the entire VRAM before running\ncublasLtMatmulAlgoGetHeuristic()\n.\n3.4.23.\ncublasLtMatmulAlgoGetIds()\n\ncublasStatus_t\ncublasLtMatmulAlgoGetIds\n(\ncublasLtHandle_t\nlightHandle\n,\ncublasComputeType_t\ncomputeType\n,\ncudaDataType_t\nscaleType\n,\ncudaDataType_t\nAtype\n,\ncudaDataType_t\nBtype\n,\ncudaDataType_t\nCtype\n,\ncudaDataType_t\nDtype\n,\nint\nrequestedAlgoCount\n,\nint\nalgoIdsArray\n[],\nint\n*\nreturnAlgoCount\n);\nThis function retrieves the IDs of all the matrix multiply algorithms that are valid, and can potentially be run by the\ncublasLtMatmul()\nfunction, for given types of the input matrices A, B and C, and of the output matrix D.\nNote\nThe IDs are returned in no particular order. To make sure the best possible algo is contained in the list, make\nrequestedAlgoCount\nlarge enough to receive the full list. The list is guaranteed to be full if\nreturnAlgoCount\n<\nrequestedAlgoCount\n.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nlightHandle\nInput\nPointer to the allocated cuBLASLt handle for the cuBLASLt context. See\ncublasLtHandle_t\n.\ncomputeType\n,\nscaleType\n,\nAtype\n,\nBtype\n,\nCtype\n, and\nDtype\nInputs\nData types of the computation type, scaling factors and of the operand matrices. See\ncudaDataType_t\n.\nrequestedAlgoCount\nInput\nNumber of algorithms requested. Must be > 0.\nalgoIdsArray[]\nOutput\nArray containing the algorithm IDs returned by this function.\nreturnAlgoCount\nOutput\nNumber of algorithms actually returned by this function.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_INVALID_VALUE\nIf\nrequestedAlgoCount\nis less or equal to zero.\nCUBLAS_STATUS_SUCCESS\nIf query was successful. Inspect\nreturnAlgoCount\nto get actual number of IDs available.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.24.\ncublasLtMatmulAlgoInit()\n\ncublasStatus_t\ncublasLtMatmulAlgoInit\n(\ncublasLtHandle_t\nlightHandle\n,\ncublasComputeType_t\ncomputeType\n,\ncudaDataType_t\nscaleType\n,\ncudaDataType_t\nAtype\n,\ncudaDataType_t\nBtype\n,\ncudaDataType_t\nCtype\n,\ncudaDataType_t\nDtype\n,\nint\nalgoId\n,\ncublasLtMatmulAlgo_t\n*\nalgo\n);\nThis function initializes the matrix multiply algorithm structure for the\ncublasLtMatmul()\n, for a specified matrix multiply algorithm and input matrices A, B and C, and the output matrix D.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nlightHandle\nInput\nPointer to the allocated cuBLASLt handle for the cuBLASLt context. See\ncublasLtHandle_t\n.\ncomputeType\nInput\nCompute type. See\nCUBLASLT_MATMUL_DESC_COMPUTE_TYPE\nof\ncublasLtMatmulDescAttributes_t\n.\nscaleType\nInput\nScale type. See\nCUBLASLT_MATMUL_DESC_SCALE_TYPE\nof\ncublasLtMatmulDescAttributes_t\n. Usually same as computeType.\nAtype\n,\nBtype\n,\nCtype\n, and\nDtype\nInput\nDatatype precision for the input and output matrices. See\ncudaDataType_t\n.\nalgoId\nInput\nSpecifies the algorithm being initialized. Should be a valid\nalgoId\nreturned by the\ncublasLtMatmulAlgoGetIds()\nfunction.\nalgo\nInput\nPointer to the opaque structure to be initialized. See\ncublasLtMatmulAlgo_t\n.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_INVALID_VALUE\nIf\nalgo\nis NULL or\nalgoId\nis outside the recognized range.\nCUBLAS_STATUS_NOT_SUPPORTED\nIf\nalgoId\nis not supported for given combination of data types.\nCUBLAS_STATUS_SUCCESS\nIf the structure was successfully initialized.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.25.\ncublasLtMatmulDescCreate()\n\ncublasStatus_t\ncublasLtMatmulDescCreate\n(\ncublasLtMatmulDesc_t\n*\nmatmulDesc\n,\ncublasComputeType_t\ncomputeType\n,\ncudaDataType_t\nscaleType\n);\nThis function creates a matrix multiply descriptor by allocating the memory needed to hold its opaque structure.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nmatmulDesc\nOutput\nPointer to the structure holding the matrix multiply descriptor created by this function. See\ncublasLtMatmulDesc_t\n.\ncomputeType\nInput\nEnumerant that specifies the data precision for the matrix multiply descriptor this function creates. See\ncublasComputeType_t\n.\nscaleType\nInput\nEnumerant that specifies the data precision for the matrix transform descriptor this function creates. See\ncudaDataType_t\n.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_ALLOC_FAILED\nIf memory could not be allocated.\nCUBLAS_STATUS_SUCCESS\nIf the descriptor was created successfully.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.26.\ncublasLtMatmulDescInit()\n\ncublasStatus_t\ncublasLtMatmulDescInit\n(\ncublasLtMatmulDesc_t\nmatmulDesc\n,\ncublasComputeType_t\ncomputeType\n,\ncudaDataType_t\nscaleType\n);\nThis function initializes a matrix multiply descriptor in a previously allocated one.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nmatmulDesc\nOutput\nPointer to the structure holding the matrix multiply descriptor initialized by this function. See\ncublasLtMatmulDesc_t\n.\ncomputeType\nInput\nEnumerant that specifies the data precision for the matrix multiply descriptor this function initializes. See\ncublasComputeType_t\n.\nscaleType\nInput\nEnumerant that specifies the data precision for the matrix transform descriptor this function initializes. See\ncudaDataType_t\n.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_ALLOC_FAILED\nIf memory could not be allocated.\nCUBLAS_STATUS_SUCCESS\nIf the descriptor was created successfully.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.27.\ncublasLtMatmulDescDestroy()\n\ncublasStatus_t\ncublasLtMatmulDescDestroy\n(\ncublasLtMatmulDesc_t\nmatmulDesc\n);\nThis function destroys a previously created matrix multiply descriptor object.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nmatmulDesc\nInput\nPointer to the structure holding the matrix multiply descriptor that should be destroyed by this function. See\ncublasLtMatmulDesc_t\n.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_SUCCESS\nIf operation was successful.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.28.\ncublasLtMatmulDescGetAttribute()\n\ncublasStatus_t\ncublasLtMatmulDescGetAttribute\n(\ncublasLtMatmulDesc_t\nmatmulDesc\n,\ncublasLtMatmulDescAttributes_t\nattr\n,\nvoid\n*\nbuf\n,\nsize_t\nsizeInBytes\n,\nsize_t\n*\nsizeWritten\n);\nThis function returns the value of the queried attribute belonging to a previously created matrix multiply descriptor.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nmatmulDesc\nInput\nPointer to the previously created structure holding the matrix multiply descriptor queried by this function. See\ncublasLtMatmulDesc_t\n.\nattr\nInput\nThe attribute that will be retrieved by this function. See\ncublasLtMatmulDescAttributes_t\n.\nbuf\nOutput\nMemory address containing the attribute value retrieved by this function.\nsizeInBytes\nInput\nSize of\nbuf\nbuffer (in bytes) for verification.\nsizeWritten\nOutput\nValid only when the return value is\nCUBLAS_STATUS_SUCCESS\n. If\nsizeInBytes\nis non-zero: then\nsizeWritten\nis the number of bytes actually written; if\nsizeInBytes\nis 0: then\nsizeWritten\nis the number of bytes needed to write full contents.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_INVALID_VALUE\nIf\nsizeInBytes\nis 0 and\nsizeWritten\nis NULL, or\nif\nsizeInBytes\nis non-zero and\nbuf\nis NULL, or\nsizeInBytes\ndoesn’t match size of internal storage for the selected attribute\nCUBLAS_STATUS_SUCCESS\nIf attribute’s value was successfully written to user memory.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.29.\ncublasLtMatmulDescSetAttribute()\n\ncublasStatus_t\ncublasLtMatmulDescSetAttribute\n(\ncublasLtMatmulDesc_t\nmatmulDesc\n,\ncublasLtMatmulDescAttributes_t\nattr\n,\nconst\nvoid\n*\nbuf\n,\nsize_t\nsizeInBytes\n);\nThis function sets the value of the specified attribute belonging to a previously created matrix multiply descriptor.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nmatmulDesc\nInput\nPointer to the previously created structure holding the matrix multiply descriptor queried by this function. See\ncublasLtMatmulDesc_t\n.\nattr\nInput\nThe attribute that will be set by this function. See\ncublasLtMatmulDescAttributes_t\n.\nbuf\nInput\nThe value to which the specified attribute should be set.\nsizeInBytes\nInput\nSize of\nbuf\nbuffer (in bytes) for verification.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_INVALID_VALUE\nIf\nbuf\nis NULL or\nsizeInBytes\ndoesn’t match the size of the internal storage for the selected attribute.\nCUBLAS_STATUS_SUCCESS\nIf the attribute was set successfully.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.30.\ncublasLtMatmulPreferenceCreate()\n\ncublasStatus_t\ncublasLtMatmulPreferenceCreate\n(\ncublasLtMatmulPreference_t\n*\npref\n);\nThis function creates a matrix multiply heuristic search preferences descriptor by allocating the memory needed to hold its opaque structure.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\npref\nOutput\nPointer to the structure holding the matrix multiply preferences descriptor created by this function. See\ncublasLtMatrixLayout_t\n.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_ALLOC_FAILED\nIf memory could not be allocated.\nCUBLAS_STATUS_SUCCESS\nIf the descriptor was created successfully.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.31.\ncublasLtMatmulPreferenceInit()\n\ncublasStatus_t\ncublasLtMatmulPreferenceInit\n(\ncublasLtMatmulPreference_t\npref\n);\nThis function initializes a matrix multiply heuristic search preferences descriptor in a previously allocated one.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\npref\nOutput\nPointer to the structure holding the matrix multiply preferences descriptor created by this function. See\ncublasLtMatrixLayout_t\n.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_ALLOC_FAILED\nIf memory could not be allocated.\nCUBLAS_STATUS_SUCCESS\nIf the descriptor was created successfully.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.32.\ncublasLtMatmulPreferenceDestroy()\n\ncublasStatus_t\ncublasLtMatmulPreferenceDestroy\n(\ncublasLtMatmulPreference_t\npref\n);\nThis function destroys a previously created matrix multiply preferences descriptor object.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\npref\nInput\nPointer to the structure holding the matrix multiply preferences descriptor that should be destroyed by this function. See\ncublasLtMatmulPreference_t\n.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_SUCCESS\nIf the operation was successful.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.33.\ncublasLtMatmulPreferenceGetAttribute()\n\ncublasStatus_t\ncublasLtMatmulPreferenceGetAttribute\n(\ncublasLtMatmulPreference_t\npref\n,\ncublasLtMatmulPreferenceAttributes_t\nattr\n,\nvoid\n*\nbuf\n,\nsize_t\nsizeInBytes\n,\nsize_t\n*\nsizeWritten\n);\nThis function returns the value of the queried attribute belonging to a previously created matrix multiply heuristic search preferences descriptor.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\npref\nInput\nPointer to the previously created structure holding the matrix multiply heuristic search preferences descriptor queried by this function. See\ncublasLtMatmulPreference_t\n.\nattr\nInput\nThe attribute that will be queried by this function. See\ncublasLtMatmulPreferenceAttributes_t\n.\nbuf\nOutput\nMemory address containing the attribute value retrieved by this function.\nsizeInBytes\nInput\nSize of\nbuf\nbuffer (in bytes) for verification.\nsizeWritten\nOutput\nValid only when the return value is\nCUBLAS_STATUS_SUCCESS\n. If\nsizeInBytes\nis non-zero: then\nsizeWritten\nis the number of bytes actually written; if\nsizeInBytes\nis 0: then\nsizeWritten\nis the number of bytes needed to write full contents.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_INVALID_VALUE\nIf\nsizeInBytes\nis 0 and\nsizeWritten\nis NULL, or\nif\nsizeInBytes\nis non-zero and\nbuf\nis NULL, or\nsizeInBytes\ndoesn’t match size of internal storage for the selected attribute\nCUBLAS_STATUS_SUCCESS\nIf attribute’s value was successfully written to user memory.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.34.\ncublasLtMatmulPreferenceSetAttribute()\n\ncublasStatus_t\ncublasLtMatmulPreferenceSetAttribute\n(\ncublasLtMatmulPreference_t\npref\n,\ncublasLtMatmulPreferenceAttributes_t\nattr\n,\nconst\nvoid\n*\nbuf\n,\nsize_t\nsizeInBytes\n);\nThis function sets the value of the specified attribute belonging to a previously created matrix multiply preferences descriptor.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\npref\nInput\nPointer to the previously created structure holding the matrix multiply preferences descriptor queried by this function. See\ncublasLtMatmulPreference_t\n.\nattr\nInput\nThe attribute that will be set by this function. See\ncublasLtMatmulPreferenceAttributes_t\n.\nbuf\nInput\nThe value to which the specified attribute should be set.\nsizeInBytes\nInput\nSize of\nbuf\nbuffer (in bytes) for verification.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_INVALID_VALUE\nIf buf is NULL or\nsizeInBytes\ndoesn’t match the size of the internal storage for the selected attribute.\nCUBLAS_STATUS_SUCCESS\nIf the attribute was set successfully.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.35.\ncublasLtMatrixLayoutCreate()\n\ncublasStatus_t\ncublasLtMatrixLayoutCreate\n(\ncublasLtMatrixLayout_t\n*\nmatLayout\n,\ncudaDataType\ntype\n,\nuint64_t\nrows\n,\nuint64_t\ncols\n,\nint64_t\nld\n);\nThis function creates a matrix layout descriptor by allocating the memory needed to hold its opaque structure.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nmatLayout\nOutput\nPointer to the structure holding the matrix layout descriptor created by this function. See\ncublasLtMatrixLayout_t\n.\ntype\nInput\nEnumerant that specifies the data precision for the matrix layout descriptor this function creates. See\ncudaDataType_t\n.\nrows\n,\ncols\nInput\nNumber of rows and columns of the matrix.\nld\nInput\nThe leading dimension of the matrix. In column major layout, this is the number of elements to jump to reach the next column. Thus\nld\n>=\nm\n(number of rows).\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_ALLOC_FAILED\nIf the memory could not be allocated.\nCUBLAS_STATUS_SUCCESS\nIf the descriptor was created successfully.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.36.\ncublasLtMatrixLayoutInit()\n\ncublasStatus_t\ncublasLtMatrixLayoutInit\n(\ncublasLtMatrixLayout_t\nmatLayout\n,\ncudaDataType\ntype\n,\nuint64_t\nrows\n,\nuint64_t\ncols\n,\nint64_t\nld\n);\nThis function initializes a matrix layout descriptor in a previously allocated one.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nmatLayout\nOutput\nPointer to the structure holding the matrix layout descriptor initialized by this function. See\ncublasLtMatrixLayout_t\n.\ntype\nInput\nEnumerant that specifies the data precision for the matrix layout descriptor this function initializes. See\ncudaDataType_t\n.\nrows\n,\ncols\nInput\nNumber of rows and columns of the matrix.\nld\nInput\nThe leading dimension of the matrix. In column major layout, this is the number of elements to jump to reach the next column. Thus\nld\n>=\nm\n(number of rows).\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_ALLOC_FAILED\nIf the memory could not be allocated.\nCUBLAS_STATUS_SUCCESS\nIf the descriptor was created successfully.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.37.\ncublasLtMatrixLayoutDestroy()\n\ncublasStatus_t\ncublasLtMatrixLayoutDestroy\n(\ncublasLtMatrixLayout_t\nmatLayout\n);\nThis function destroys a previously created matrix layout descriptor object.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nmatLayout\nInput\nPointer to the structure holding the matrix layout descriptor that should be destroyed by this function. See\ncublasLtMatrixLayout_t\n.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_SUCCESS\nIf the operation was successful.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.38.\ncublasLtMatrixLayoutGetAttribute()\n\ncublasStatus_t\ncublasLtMatrixLayoutGetAttribute\n(\ncublasLtMatrixLayout_t\nmatLayout\n,\ncublasLtMatrixLayoutAttribute_t\nattr\n,\nvoid\n*\nbuf\n,\nsize_t\nsizeInBytes\n,\nsize_t\n*\nsizeWritten\n);\nThis function returns the value of the queried attribute belonging to the specified matrix layout descriptor.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nmatLayout\nInput\nPointer to the previously created structure holding the matrix layout descriptor queried by this function. See\ncublasLtMatrixLayout_t\n.\nattr\nInput\nThe attribute being queried for. See\ncublasLtMatrixLayoutAttribute_t\n.\nbuf\nOutput\nThe attribute value returned by this function.\nsizeInBytes\nInput\nSize of\nbuf\nbuffer (in bytes) for verification.\nsizeWritten\nOutput\nValid only when the return value is\nCUBLAS_STATUS_SUCCESS\n. If\nsizeInBytes\nis non-zero: then\nsizeWritten\nis the number of bytes actually written; if\nsizeInBytes\nis 0: then\nsizeWritten\nis the number of bytes needed to write full contents.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_INVALID_VALUE\nIf\nsizeInBytes\nis 0 and\nsizeWritten\nis NULL, or\nif\nsizeInBytes\nis non-zero and\nbuf\nis NULL, or\nsizeInBytes\ndoesn’t match size of internal storage for the selected attribute\nCUBLAS_STATUS_SUCCESS\nIf attribute’s value was successfully written to user memory.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.39.\ncublasLtMatrixLayoutSetAttribute()\n\ncublasStatus_t\ncublasLtMatrixLayoutSetAttribute\n(\ncublasLtMatrixLayout_t\nmatLayout\n,\ncublasLtMatrixLayoutAttribute_t\nattr\n,\nconst\nvoid\n*\nbuf\n,\nsize_t\nsizeInBytes\n);\nThis function sets the value of the specified attribute belonging to a previously created matrix layout descriptor.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nmatLayout\nInput\nPointer to the previously created structure holding the matrix layout descriptor queried by this function. See\ncublasLtMatrixLayout_t\n.\nattr\nInput\nThe attribute that will be set by this function. See\ncublasLtMatrixLayoutAttribute_t\n.\nbuf\nInput\nThe value to which the specified attribute should be set.\nsizeInBytes\nInput\nSize of\nbuf\n, the attribute buffer.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_INVALID_VALUE\nIf\nbuf\nis NULL or\nsizeInBytes\ndoesn’t match size of internal storage for the selected attribute.\nCUBLAS_STATUS_SUCCESS\nIf attribute was set successfully.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.40.\ncublasLtMatrixTransform()\n\ncublasStatus_t\ncublasLtMatrixTransform\n(\ncublasLtHandle_t\nlightHandle\n,\ncublasLtMatrixTransformDesc_t\ntransformDesc\n,\nconst\nvoid\n*\nalpha\n,\nconst\nvoid\n*\nA\n,\ncublasLtMatrixLayout_t\nAdesc\n,\nconst\nvoid\n*\nbeta\n,\nconst\nvoid\n*\nB\n,\ncublasLtMatrixLayout_t\nBdesc\n,\nvoid\n*\nC\n,\ncublasLtMatrixLayout_t\nCdesc\n,\ncudaStream_t\nstream\n);\nThis function computes the matrix transformation operation on the input matrices A and B, to produce the output matrix C, according to the below operation:\nC\n=\nalpha*transformation(A)\n+\nbeta*transformation(B),\nwhere\nA\n,\nB\nare input matrices, and\nalpha\nand\nbeta\nare input scalars. The transformation operation is defined by the\ntransformDesc\npointer. This function can be used to change the memory order of data or to scale and shift the values.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nlightHandle\nInput\nPointer to the allocated cuBLASLt handle for the cuBLASLt context. See\ncublasLtHandle_t\n.\ntransformDesc\nInput\nPointer to the opaque descriptor holding the matrix transformation operation. See\ncublasLtMatrixTransformDesc_t\n.\nalpha\n,\nbeta\nDevice or host\nInput\nPointers to the scalars used in the multiplication.\nA\n,\nB\nDevice\nInput\nPointers to the GPU memory associated with the corresponding descriptors\nAdesc\nand\nBdesc\n.\nC\nDevice\nOutput\nPointer to the GPU memory associated with the\nCdesc\ndescriptor.\nAdesc\n,\nBdesc\nand\nCdesc\nInput\nHandles to the previous created descriptors of the type\ncublasLtMatrixLayout_t\n.\nAdesc\nor\nBdesc\ncan be NULL if the corresponding pointer is NULL and the corresponding scalar is zero.\nstream\nHost\nInput\nThe CUDA stream where all the GPU work will be submitted.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_NOT_INITIALIZED\nIf cuBLASLt handle has not been initialized.\nCUBLAS_STATUS_INVALID_VALUE\nIf the parameters are in conflict or in an impossible configuration. For example, when\nA\nis not NULL, but\nAdesc\nis NULL.\nCUBLAS_STATUS_NOT_SUPPORTED\nIf the current implementation on the selected device does not support the configured operation.\nCUBLAS_STATUS_ARCH_MISMATCH\nIf the configured operation cannot be run using the selected device.\nCUBLAS_STATUS_EXECUTION_FAILED\nIf CUDA reported an execution error from the device.\nCUBLAS_STATUS_SUCCESS\nIf the operation completed successfully.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.41.\ncublasLtMatrixTransformDescCreate()\n\ncublasStatus_t\ncublasLtMatrixTransformDescCreate\n(\ncublasLtMatrixTransformDesc_t\n*\ntransformDesc\n,\ncudaDataType\nscaleType\n);\nThis function creates a matrix transform descriptor by allocating the memory needed to hold its opaque structure.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\ntransformDesc\nOutput\nPointer to the structure holding the matrix transform descriptor created by this function. See\ncublasLtMatrixTransformDesc_t\n.\nscaleType\nInput\nEnumerant that specifies the data precision for the matrix transform descriptor this function creates. See\ncudaDataType_t\n.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_ALLOC_FAILED\nIf memory could not be allocated.\nCUBLAS_STATUS_SUCCESS\nIf the descriptor was created successfully.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.42.\ncublasLtMatrixTransformDescInit()\n\ncublasStatus_t\ncublasLtMatrixTransformDescInit\n(\ncublasLtMatrixTransformDesc_t\ntransformDesc\n,\ncudaDataType\nscaleType\n);\nThis function initializes a matrix transform descriptor in a previously allocated one.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\ntransformDesc\nOutput\nPointer to the structure holding the matrix transform descriptor initialized by this function. See\ncublasLtMatrixTransformDesc_t\n.\nscaleType\nInput\nEnumerant that specifies the data precision for the matrix transform descriptor this function initializes. See\ncudaDataType_t\n.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_ALLOC_FAILED\nIf memory could not be allocated.\nCUBLAS_STATUS_SUCCESS\nIf the descriptor was created successfully.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.43.\ncublasLtMatrixTransformDescDestroy()\n\ncublasStatus_t\ncublasLtMatrixTransformDescDestroy\n(\ncublasLtMatrixTransformDesc_t\ntransformDesc\n);\nThis function destroys a previously created matrix transform descriptor object.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\ntransformDesc\nInput\nPointer to the structure holding the matrix transform descriptor that should be destroyed by this function. See\ncublasLtMatrixTransformDesc_t\n.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_SUCCESS\nIf the operation was successful.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.44.\ncublasLtMatrixTransformDescGetAttribute()\n\ncublasStatus_t\ncublasLtMatrixTransformDescGetAttribute\n(\ncublasLtMatrixTransformDesc_t\ntransformDesc\n,\ncublasLtMatrixTransformDescAttributes_t\nattr\n,\nvoid\n*\nbuf\n,\nsize_t\nsizeInBytes\n,\nsize_t\n*\nsizeWritten\n);\nThis function returns the value of the queried attribute belonging to a previously created matrix transform descriptor.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\ntransformDesc\nInput\nPointer to the previously created structure holding the matrix transform descriptor queried by this function. See\ncublasLtMatrixTransformDesc_t\n.\nattr\nInput\nThe attribute that will be retrieved by this function. See\ncublasLtMatrixTransformDescAttributes_t\n.\nbuf\nOutput\nMemory address containing the attribute value retrieved by this function.\nsizeInBytes\nInput\nSize of\nbuf\nbuffer (in bytes) for verification.\nsizeWritten\nOutput\nValid only when the return value is\nCUBLAS_STATUS_SUCCESS\n. If\nsizeInBytes\nis non-zero: then\nsizeWritten\nis the number of bytes actually written; if\nsizeInBytes\nis 0: then\nsizeWritten\nis the number of bytes needed to write full contents.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_INVALID_VALUE\nIf\nsizeInBytes\nis zero and\nsizeWritten\nis NULL, or\nif\nsizeInBytes\nis non-zero and\nbuf\nis NULL, or\nif\nsizeInBytes\ndoesn’t match size of internal storage for the selected attribute\nCUBLAS_STATUS_SUCCESS\nIf attribute’s value was successfully written to user memory.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.45.\ncublasLtMatrixTransformDescSetAttribute()\n\ncublasStatus_t\ncublasLtMatrixTransformDescSetAttribute\n(\ncublasLtMatrixTransformDesc_t\ntransformDesc\n,\ncublasLtMatrixTransformDescAttributes_t\nattr\n,\nconst\nvoid\n*\nbuf\n,\nsize_t\nsizeInBytes\n);\nThis function sets the value of the specified attribute belonging to a previously created matrix transform descriptor.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\ntransformDesc\nInput\nPointer to the previously created structure holding the matrix transform descriptor queried by this function. See\ncublasLtMatrixTransformDesc_t\n.\nattr\nInput\nThe attribute that will be set by this function. See\ncublasLtMatrixTransformDescAttributes_t\n.\nbuf\nInput\nThe value to which the specified attribute should be set.\nsizeInBytes\nInput\nSize of\nbuf\nbuffer (in bytes) for verification.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_INVALID_VALUE\nIf\nbuf\nis NULL or\nsizeInBytes\ndoes not match size of the internal storage for the selected attribute.\nCUBLAS_STATUS_SUCCESS\nIf the attribute was set successfully.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.46.\ncublasLtEmulationDescInit()\n\ncublasStatus_t\ncublasLtEmulationDescInit\n(\ncublasLtEmulationDesc_t\nemulationDesc\n);\nThis function initializes a previously allocated emulation descriptor.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nemulationDesc\nInput\nPointer to the previously created structure holding the emulation descriptor queried by this function. See\ncublasLtEmulationDesc_t\n.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_ALLOC_FAILED\nIf the size of the pre-allocated space is insufficient.\nCUBLAS_STATUS_SUCCESS\nIf the descriptor was created successfully.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.47.\ncublasLtEmulationDescCreate()\n\ncublasStatus_t\ncublasLtEmulationDescCreate\n(\ncublasLtEmulationDesc_t\n*\nemulationDesc\n);\nThis function creates a new emulation descriptor.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nemulationDesc\nInput\nPointer to the previously created structure holding the emulation descriptor queried by this function. See\ncublasLtEmulationDesc_t\n.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_ALLOC_FAILED\nIf memory could not be allocated.\nCUBLAS_STATUS_SUCCESS\nIf the descriptor was created successfully.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.48.\ncublasLtEmulationDescDestroy()\n\ncublasStatus_t\ncublasLtEmulationDescDestroy\n(\ncublasLtEmulationDesc_t\nemulationDesc\n);\nThis function destroys a previously created emulation descriptor.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nemulationDesc\nInput\nPointer to the previously created structure holding the emulation descriptor queried by this function. See\ncublasLtEmulationDesc_t\n.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_SUCCESS\nIf the descriptor was destroyed successfully.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.49.\ncublasLtEmulationDescSetAttribute()\n\ncublasStatus_t\ncublasLtEmulationDescSetAttribute\n(\ncublasLtEmulationDesc_t\nemulationDesc\n,\ncublasLtEmulationDescAttributes_t\nattr\n,\nconst\nvoid\n*\nbuf\n,\nsize_t\nsizeInBytes\n);\nThis function sets the value of the specified attribute belonging to a previously created emulation descriptor.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nemulationDesc\nInput\nPointer to the previously created structure holding the emulation descriptor queried by this function. See\ncublasLtEmulationDesc_t\n.\nattr\nInput\nThe attribute that will be set by this function. See\ncublasLtEmulationDescAttributes_t\n.\nbuf\nInput\nThe value to which the specified attribute should be set.\nsizeInBytes\nInput\nSize of\nbuf\nbuffer (in bytes) for verification.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_INVALID_VALUE\nIf\nbuf\nis NULL or\nsizeInBytes\ndoes not match size of the internal storage for the selected attribute.\nCUBLAS_STATUS_SUCCESS\nIf the attribute was set successfully.\nSee\ncublasStatus_t\nfor a complete list of valid return codes.\n3.4.50.\ncublasLtEmulationDescGetAttribute()\n\ncublasStatus_t\ncublasLtEmulationDescGetAttribute\n(\ncublasLtEmulationDesc_t\nemulationDesc\n,\ncublasLtEmulationDescAttributes_t\nattr\n,\nvoid\n*\nbuf\n,\nsize_t\nsizeInBytes\n,\nsize_t\n*\nsizeWritten\n);\nThis function returns the value of the queried attribute belonging to a previously created emulation descriptor.\nParameters\n:\nParameter\nMemory\nInput / Output\nDescription\nemulationDesc\nInput\nPointer to the previously created structure holding the emulation descriptor queried by this function. See\ncublasLtEmulationDesc_t\n.\nattr\nInput\nThe attribute that will be retrieved by this function. See\ncublasLtEmulationDescAttributes_t\n.\nbuf\nOutput\nMemory address containing the attribute value retrieved by this function.\nsizeInBytes\nInput\nSize of\nbuf\nbuffer (in bytes) for verification.\nsizeWritten\nOutput\nValid only when the return value is\nCUBLAS_STATUS_SUCCESS\n.\nIf\nsizeInBytes\nis non-zero: then\nsizeWritten\nis the number of bytes actually written;\nIf\nsizeInBytes\nis 0: then\nsizeWritten\nis the number of bytes needed to write full contents.\nReturns\n:\nReturn Value\nDescription\nCUBLAS_STATUS_INVALID_VALUE\nIf\nsizeInBytes\nis zero and\nsizeWritten\nis NULL, or\nif\nsizeInBytes\nis non-zero and\nbuf\nis NULL, or\nif\nsizeInBytes\ndoesn’t match size of internal storage for the selected attribute\nCUBLAS_STATUS_SUCCESS\nIf attribute’s value was successfully written to user memory.\n4.\nUsing the cuBLASXt API\n\n4.1.\nGeneral description\n\nThe cuBLASXt API of cuBLAS exposes a multi-GPU capable host interface: when using this API the application only needs to allocate the required matrices on the host memory space. Additionally, the current implementation supports managed memory on Linux with GPU devices that have compute capability 6.x or greater but treats it as host memory. Managed memory is not supported on Windows. There are no restriction on the sizes of the matrices as long as they can fit into the host memory. The cuBLASXt API takes care of allocating the memory across the designated GPUs and dispatched the workload between them and finally retrieves the results back to the host. The cuBLASXt API supports only the compute-intensive BLAS3 routines (e.g matrix-matrix operations) where the PCI transfers back and forth from the GPU can be amortized. The cuBLASXt API has its own header file\ncublasXt.h\n.\nStarting with release 8.0, cuBLASXt API allows any of the matrices to be located on a GPU device.\nNote\nWhen providing matrices allocated on the GPU using the Stream Ordered Memory Allocator, ensure visibility across all devices by using\ncudaMemPoolSetAccess\n.\nNote\nThe cuBLASXt API is only supported on 64-bit platforms.\n4.1.1.\nTiling design approach\n\nTo be able to share the workload between multiple GPUs, the cuBLASXt API uses a tiling strategy : every matrix is divided in square tiles of user-controllable dimension BlockDim x BlockDim. The resulting matrix tiling defines the static scheduling policy : each resulting tile is affected to a GPU in a round robin fashion One CPU thread is created per GPU and is responsible to do the proper memory transfers and cuBLAS operations to compute all the tiles that it is responsible for. From a performance point of view, due to this static scheduling strategy, it is better that compute capabilities and PCI bandwidth are the same for every GPU. The figure below illustrates the tiles distribution between 3 GPUs. To compute the first tile G0 from C, the CPU thread 0 responsible of GPU0, have to load 3 tiles from the first row of A and tiles from the first column of B in a pipeline fashion in order to overlap memory transfer and computations and sum the results into the first tile G0 of C before to move on to the next tile G0.\nExample of\ncublasXt<t>gemm()\ntiling for 3 Gpus\n\nWhen the tile dimension is not an exact multiple of the dimensions of C, some tiles are partially filled on the right border or/and the bottom border. The current implementation does not pad the incomplete tiles but simply keep track of those incomplete tiles by doing the right reduced cuBLAS operations : this way, no extra computation is done. However it still can lead to some load unbalance when all GPUS do not have the same number of incomplete tiles to work on.\nWhen one or more matrices are located on some GPU devices, the same tiling approach and workload sharing is applied. The memory transfers are in this case done between devices. However, when the computation of a tile and some data are located on the same GPU device, the memory transfer to/from the local data into tiles is bypassed and the GPU operates directly on the local data. This can lead to a significant performance increase, especially when only one GPU is used for the computation.\nThe matrices can be located on any GPU device, and do not have to be located on the same GPU device. Furthermore, the matrices can even be located on a GPU device that do not participate to the computation.\nOn the contrary of the cuBLAS API, even if all matrices are located on the same device, the cuBLASXt API is still a blocking API from the host point of view : the data results wherever located will be valid on the call return and no device synchronization is required.\n4.1.2.\nHybrid CPU-GPU computation\n\nIn the case of very large problems, the cuBLASXt API offers the possibility to offload some of the computation to the host CPU. This feature can be setup with the routines\ncublasXtSetCpuRoutine()\nand\ncublasXtSetCpuRatio()\nThe workload affected to the CPU is put aside : it is simply a percentage of the resulting matrix taken from the bottom and the right side whichever dimension is bigger. The GPU tiling is done after that on the reduced resulting matrix.\nIf any of the matrices is located on a GPU device, the feature is ignored and all computation will be done only on the GPUs\nThis feature should be used with caution because it could interfere with the CPU threads responsible of feeding the GPUs.\nCurrently, only the routine\ncublasXt<t>gemm()\nsupports this feature.\n4.1.3.\nResults reproducibility\n\nCurrently all cuBLASXt API routines from a given toolkit version, generate the same bit-wise results when the following conditions are respected :\nall GPUs participating to the computation have the same compute capabilities and the same number of SMs.\nthe tiles size is kept the same between run.\neither the CPU hybrid computation is not used or the CPU Blas provided is also guaranteed to produce reproducible results.\n4.2.\ncuBLASXt API Datatypes Reference\n\n4.2.1.\ncublasXtHandle_t\n\nThe\ncublasXtHandle_t\ntype is a pointer type to an opaque structure holding the cuBLASXt API context. The cuBLASXt API context must be initialized using\ncublasXtCreate()\nand the returned handle must be passed to all subsequent cuBLASXt API function calls. The context should be destroyed at the end using\ncublasXtDestroy()\n.\n4.2.2.\ncublasXtOpType_t\n\nThe\ncublasOpType_t\nenumerates the four possible types supported by BLAS routines. This enum is used as parameters of the routines\ncublasXtSetCpuRoutine\nand\ncublasXtSetCpuRatio\nto setup the hybrid configuration.\nValue\nMeaning\nCUBLASXT_FLOAT\nfloat or single precision type\nCUBLASXT_DOUBLE\ndouble precision type\nCUBLASXT_COMPLEX\nsingle precision complex\nCUBLASXT_DOUBLECOMPLEX\ndouble precision complex\n4.2.3.\ncublasXtBlasOp_t\n\nThe\ncublasXtBlasOp_t\ntype enumerates the BLAS3 or BLAS-like routine supported by cuBLASXt API. This enum is used as parameters of the routines\ncublasXtSetCpuRoutine\nand\ncublasXtSetCpuRatio\nto setup the hybrid configuration.\nValue\nMeaning\nCUBLASXT_GEMM\nGEMM routine\nCUBLASXT_SYRK\nSYRK routine\nCUBLASXT_HERK\nHERK routine\nCUBLASXT_SYMM\nSYMM routine\nCUBLASXT_HEMM\nHEMM routine\nCUBLASXT_TRSM\nTRSM routine\nCUBLASXT_SYR2K\nSYR2K routine\nCUBLASXT_HER2K\nHER2K routine\nCUBLASXT_SPMM\nSPMM routine\nCUBLASXT_SYRKX\nSYRKX routine\nCUBLASXT_HERKX\nHERKX routine\n4.2.4.\ncublasXtPinningMemMode_t\n\nThe type is used to enable or disable the Pinning Memory mode through the routine\ncubasMgSetPinningMemMode\nValue\nMeaning\nCUBLASXT_PINNING_DISABLED\nthe Pinning Memory mode is disabled\nCUBLASXT_PINNING_ENABLED\nthe Pinning Memory mode is enabled\n4.3.\ncuBLASXt API Helper Function Reference\n\n4.3.1.\ncublasXtCreate()\n\ncublasStatus_t\ncublasXtCreate\n(\ncublasXtHandle_t\n*\nhandle\n)\nThis function initializes the cuBLASXt API and creates a handle to an opaque structure holding the cuBLASXt API context. It allocates hardware resources on the host and device and must be called prior to making any other cuBLASXt API calls.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe initialization succeeded\nCUBLAS_STATUS_ALLOC_FAILED\nthe resources could not be allocated\nCUBLAS_STATUS_NOT_SUPPORTED\ncuBLASXt API is only supported on 64-bit platform\n4.3.2.\ncublasXtDestroy()\n\ncublasStatus_t\ncublasXtDestroy\n(\ncublasXtHandle_t\nhandle\n)\nThis function releases hardware resources used by the cuBLASXt API context. The release of GPU resources may be deferred until the application exits. This function is usually the last call with a particular handle to the cuBLASXt API.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe shut down succeeded\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized\n4.3.3.\ncublasXtDeviceSelect()\n\ncublasXtDeviceSelect\n(\ncublasXtHandle_t\nhandle\n,\nint\nnbDevices\n,\nint\ndeviceId\n[])\nThis function allows the user to provide the number of GPU devices and their respective Ids that will participate to the subsequent cuBLASXt API Math function calls. This function will create a cuBLAS context for every GPU provided in that list. Currently the device configuration is static and cannot be changed between Math function calls. In that regard, this function should be called only once after\ncublasXtCreate\n. To be able to run multiple configurations, multiple cuBLASXt API contexts should be created.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nUser call was successful\nCUBLAS_STATUS_INVALID_VALUE\nAccess to at least one of the device could not be done or a cuBLAS context could not be created on at least one of the device\nCUBLAS_STATUS_ALLOC_FAILED\nSome resources could not be allocated.\n4.3.4.\ncublasXtSetBlockDim()\n\ncublasXtSetBlockDim\n(\ncublasXtHandle_t\nhandle\n,\nint\nblockDim\n)\nThis function allows the user to set the block dimension used for the tiling of the matrices for the subsequent Math function calls. Matrices are split in square tiles of blockDim x blockDim dimension. This function can be called anytime and will take effect for the following Math function calls. The block dimension should be chosen in a way to optimize the math operation and to make sure that the PCI transfers are well overlapped with the computation.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe call has been successful\nCUBLAS_STATUS_INVALID_VALUE\nblockDim <= 0\n4.3.5.\ncublasXtGetBlockDim()\n\ncublasXtGetBlockDim\n(\ncublasXtHandle_t\nhandle\n,\nint\n*\nblockDim\n)\nThis function allows the user to query the block dimension used for the tiling of the matrices.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe call has been successful\n4.3.6.\ncublasXtSetCpuRoutine()\n\ncublasXtSetCpuRoutine\n(\ncublasXtHandle_t\nhandle\n,\ncublasXtBlasOp_t\nblasOp\n,\ncublasXtOpType_t\ntype\n,\nvoid\n*\nblasFunctor\n)\nThis function allows the user to provide a CPU implementation of the corresponding BLAS routine. This function can be used with the function\ncublasXtSetCpuRatio()\nto define an hybrid computation between the CPU and the GPUs. Currently the hybrid feature is only supported for the xGEMM routines.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe call has been successful\nCUBLAS_STATUS_INVALID_VALUE\nblasOp or type define an invalid combination\nCUBLAS_STATUS_NOT_SUPPORTED\nCPU-GPU Hybridization for that routine is not supported\n4.3.7.\ncublasXtSetCpuRatio()\n\ncublasXtSetCpuRatio\n(\ncublasXtHandle_t\nhandle\n,\ncublasXtBlasOp_t\nblasOp\n,\ncublasXtOpType_t\ntype\n,\nfloat\nratio\n)\nThis function allows the user to define the percentage of workload that should be done on a CPU in the context of an hybrid computation. This function can be used with the function\ncublasXtSetCpuRoutine()\nto define an hybrid computation between the CPU and the GPUs. Currently the hybrid feature is only supported for the xGEMM routines.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe call has been successful\nCUBLAS_STATUS_INVALID_VALUE\nblasOp or type define an invalid combination\nCUBLAS_STATUS_NOT_SUPPORTED\nCPU-GPU Hybridization for that routine is not supported\n4.3.8.\ncublasXtSetPinningMemMode()\n\ncublasXtSetPinningMemMode\n(\ncublasXtHandle_t\nhandle\n,\ncublasXtPinningMemMode_t\nmode\n)\nThis function allows the user to enable or disable the Pinning Memory mode. When enabled, the matrices passed in subsequent cuBLASXt API calls will be pinned/unpinned using the CUDART routine\ncudaHostRegister()\nand\ncudaHostUnregister()\nrespectively if the matrices are not already pinned. If a matrix happened to be pinned partially, it will also not be pinned. Pinning the memory improve PCI transfer performance and allows to overlap PCI memory transfer with computation. However pinning/unpinning the memory take some time which might not be amortized. It is advised that the user pins the memory on its own using\ncudaMallocHost()\nor\ncudaHostRegister()\nand unpin it when the computation sequence is completed. By default, the Pinning Memory mode is disabled.\nNote\nThe Pinning Memory mode should not be enabled when matrices used for different calls to cuBLASXt API overlap. cuBLASXt determines that a matrix is pinned or not if the first address of that matrix is pinned using\ncudaHostGetFlags()\n, thus cannot know if the matrix is already partially pinned or not. This is especially true in multi-threaded application where memory could be partially or totally pinned or unpinned while another thread is accessing that memory.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe call has been successful\nCUBLAS_STATUS_INVALID_VALUE\nthe mode value is different from\nCUBLASXT_PINNING_DISABLED\nand\nCUBLASXT_PINNING_ENABLED\n4.3.9.\ncublasXtGetPinningMemMode()\n\ncublasXtGetPinningMemMode\n(\ncublasXtHandle_t\nhandle\n,\ncublasXtPinningMemMode_t\n*\nmode\n)\nThis function allows the user to query the Pinning Memory mode. By default, the Pinning Memory mode is disabled.\nReturn Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe call has been successful\n4.4.\ncuBLASXt API Math Functions Reference\n\nIn this chapter we describe the actual Linear Algebra routines that cuBLASXt API supports. We will use abbreviations <\ntype\n> for type and <\nt\n> for the corresponding short type to make a more concise and clear presentation of the implemented functions. Unless otherwise specified <\ntype\n> and <\nt\n> have the following meanings:\n<\ntype\n>\n<\nt\n>\nMeaning\nfloat\n‘s’ or ‘S’\nreal single-precision\ndouble\n‘d’ or ‘D’\nreal double-precision\ncuComplex\n‘c’ or ‘C’\ncomplex single-precision\ncuDoubleComplex\n‘z’ or ‘Z’\ncomplex double-precision\nThe abbreviation\n\\(\\mathbf{Re}(\\cdot)\\)\nand\n\\(\\mathbf{Im}(\\cdot)\\)\nwill stand for the real and imaginary part of a number, respectively. Since imaginary part of a real number does not exist, we will consider it to be zero and can usually simply discard it from the equation where it is being used. Also, the\n\\(\\bar{\\alpha}\\)\nwill denote the complex conjugate of\n\\(\\alpha\\)\n.\nIn general throughout the documentation, the lower case Greek symbols\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nwill denote scalars, lower case English letters in bold type\n\\(\\mathbf{x}\\)\nand\n\\(\\mathbf{y}\\)\nwill denote vectors and capital English letters\n\\(A\\)\n,\n\\(B\\)\nand\n\\(C\\)\nwill denote matrices.\n4.4.1.\ncublasXt<t>gemm()\n\ncublasStatus_t\ncublasXtSgemm\n(\ncublasXtHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nsize_t\nm\n,\nsize_t\nn\n,\nsize_t\nk\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nB\n,\nint\nldb\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasXtDgemm\n(\ncublasXtHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nB\n,\nint\nldb\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasXtCgemm\n(\ncublasXtHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\nB\n,\nint\nldb\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasXtZgemm\n(\ncublasXtHandle_t\nhandle\n,\ncublasOperation_t\ntransa\n,\ncublasOperation_t\ntransb\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\nC\n,\nint\nldc\n)\nThis function performs the matrix-matrix multiplication\n\\(C = \\alpha\\text{op}(A)\\text{op}(B) + \\beta C\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars, and\n\\(A\\)\n,\n\\(B\\)\nand\n\\(C\\)\nare matrices stored in column-major format with dimensions\n\\(\\text{op}(A)\\)\n\\(m \\times k\\)\n,\n\\(\\text{op}(B)\\)\n\\(k \\times n\\)\nand\n\\(C\\)\n\\(m \\times n\\)\n, respectively. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\nA^{H} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nand\n\\(\\text{op}(B)\\)\nis defined similarly for matrix\n\\(B\\)\n.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nhandle to the cuBLASXt API context.\ntransa\ninput\noperation op(\nA\n) that is non- or (conj.) transpose.\ntransb\ninput\noperation op(\nB\n) that is non- or (conj.) transpose.\nm\ninput\nnumber of rows of matrix op(\nA\n) and\nC\n.\nn\ninput\nnumber of columns of matrix op(\nB\n) and\nC\n.\nk\ninput\nnumber of columns of op(\nA\n) and rows of op(\nB\n).\nalpha\nhost\ninput\n<\ntype\n> scalar used for multiplication.\nA\nhost or device\ninput\n<\ntype\n> array of dimensions\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nm)\nif\ntransa\n==\nCUBLAS_OP_N\nand\nlda\nx\nm\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nlda\ninput\nleading dimension of two-dimensional array used to store the matrix\nA\n.\nB\nhost or device\ninput\n<\ntype\n> array of dimension\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nk)\nif\ntransb\n==\nCUBLAS_OP_N\nand\nldb\nx\nk\nwith\nldb\n>=\nmax(1,\nn)\notherwise.\nldb\ninput\nleading dimension of two-dimensional array used to store matrix\nB\n.\nbeta\nhost\ninput\n<\ntype\n> scalar used for multiplication. If\nbeta\n==\n0\n,\nC\ndoes not have to be a valid input.\nC\nhost or device\nin/out\n<\ntype\n> array of dimensions\nldc\nx\nn\nwith\nldc\n>=\nmax(1,\nm)\n.\nldc\ninput\nleading dimension of a two-dimensional array used to store the matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nthe parameters\nm,n,k<0\nCUBLAS_STATUS_EXECUTION_FAILED\nthe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nsgemm()\n,\ndgemm()\n,\ncgemm()\n,\nzgemm()\n4.4.2.\ncublasXt<t>hemm()\n\ncublasStatus_t\ncublasXtChemm\n(\ncublasXtHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\nsize_t\nm\n,\nsize_t\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nsize_t\nlda\n,\nconst\ncuComplex\n*\nB\n,\nsize_t\nldb\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\nC\n,\nsize_t\nldc\n)\ncublasStatus_t\ncublasXtZhemm\n(\ncublasXtHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\nsize_t\nm\n,\nsize_t\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nsize_t\nlda\n,\nconst\ncuDoubleComplex\n*\nB\n,\nsize_t\nldb\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\nC\n,\nsize_t\nldc\n)\nThis function performs the Hermitian matrix-matrix multiplication\n\\(C = \\left\\{ \\begin{matrix}\n{\\alpha AB + \\beta C} & {\\text{if }\\textsf{side == $\\mathrm{CUBLAS\\_SIDE\\_LEFT}$}} \\\\\n{\\alpha BA + \\beta C} & {\\text{if }\\textsf{side == $\\mathrm{CUBLAS\\_SIDE\\_RIGHT}$}} \\\\\n\\end{matrix} \\right.\\)\nwhere\n\\(A\\)\nis a Hermitian matrix stored in lower or upper mode,\n\\(B\\)\nand\n\\(C\\)\nare\n\\(m \\times n\\)\nmatrices, and\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nhandle to the cuBLASXt API context.\nside\ninput\nindicates if matrix\nA\nis on the left or right of\nB\n.\nuplo\ninput\nindicates if matrix\nA\nlower or upper part is stored, the other Hermitian part is not referenced and is inferred from the stored elements.\nm\ninput\nnumber of rows of matrix\nC\nand\nB\n, with matrix\nA\nsized accordingly.\nn\ninput\nnumber of columns of matrix\nC\nand\nB\n, with matrix\nA\nsized accordingly.\nalpha\nhost\ninput\n<\ntype\n> scalar used for multiplication.\nA\nhost or device\ninput\n<\ntype\n> array of dimension\nlda\nx\nm\nwith\nlda\n>=\nmax(1,\nm)\nif\nside\n=\nCUBLAS_SIDE_LEFT\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nn)\notherwise. The imaginary parts of the diagonal elements are assumed to be zero.\nlda\ninput\nleading dimension of two-dimensional array used to store matrix\nA\n.\nB\nhost or device\ninput\n<\ntype\n> array of dimension\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nm)\n.\nldb\ninput\nleading dimension of two-dimensional array used to store matrix\nB\n.\nbeta\nhost\ninput\n<\ntype\n> scalar used for multiplication, if\nbeta\n==\n0\nthen\nC\ndoes not have to be a valid input.\nC\nhost or device\nin/out\n<\ntype\n> array of dimensions\nldc\nx\nn\nwith\nldc\n>=\nmax(1,\nm)\n.\nldc\ninput\nleading dimension of two-dimensional array used to store matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nthe parameters\nm\n<\n0\nor\nn\n<\n0\nCUBLAS_STATUS_EXECUTION_FAILED\nthe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nchemm()\n,\nzhemm()\n4.4.3.\ncublasXt<t>symm()\n\ncublasStatus_t\ncublasXtSsymm\n(\ncublasXtHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\nsize_t\nm\n,\nsize_t\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nA\n,\nsize_t\nlda\n,\nconst\nfloat\n*\nB\n,\nsize_t\nldb\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\nC\n,\nsize_t\nldc\n)\ncublasStatus_t\ncublasXtDsymm\n(\ncublasXtHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\nsize_t\nm\n,\nsize_t\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nA\n,\nsize_t\nlda\n,\nconst\ndouble\n*\nB\n,\nsize_t\nldb\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\nC\n,\nsize_t\nldc\n)\ncublasStatus_t\ncublasXtCsymm\n(\ncublasXtHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\nsize_t\nm\n,\nsize_t\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nsize_t\nlda\n,\nconst\ncuComplex\n*\nB\n,\nsize_t\nldb\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\nC\n,\nsize_t\nldc\n)\ncublasStatus_t\ncublasXtZsymm\n(\ncublasXtHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\nsize_t\nm\n,\nsize_t\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nsize_t\nlda\n,\nconst\ncuDoubleComplex\n*\nB\n,\nsize_t\nldb\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\nC\n,\nsize_t\nldc\n)\nThis function performs the symmetric matrix-matrix multiplication\n\\(C = \\left\\{ \\begin{matrix}\n{\\alpha AB + \\beta C} & {\\text{if }\\textsf{side == $\\mathrm{CUBLAS\\_SIDE\\_LEFT}$}} \\\\\n{\\alpha BA + \\beta C} & {\\text{if }\\textsf{side == $\\mathrm{CUBLAS\\_SIDE\\_RIGHT}$}} \\\\\n\\end{matrix} \\right.\\)\nwhere\n\\(A\\)\nis a symmetric matrix stored in lower or upper mode,\n\\(A\\)\nand\n\\(A\\)\nare\n\\(m \\times n\\)\nmatrices, and\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nhandle to the cuBLASXt API context.\nside\ninput\nindicates if matrix\nA\nis on the left or right of\nB\n.\nuplo\ninput\nindicates if matrix\nA\nlower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements.\nm\ninput\nnumber of rows of matrix\nA\nand\nB\n, with matrix\nA\nsized accordingly.\nn\ninput\nnumber of columns of matrix\nC\nand\nA\n, with matrix\nA\nsized accordingly.\nalpha\nhost\ninput\n<\ntype\n> scalar used for multiplication.\nA\nhost or device\ninput\n<\ntype\n> array of dimension\nlda\nx\nm\nwith\nlda\n>=\nmax(1,\nm)\nif\nside\n==\nCUBLAS_SIDE_LEFT\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nn)\notherwise.\nlda\ninput\nleading dimension of two-dimensional array used to store matrix\nA\n.\nB\nhost or device\ninput\n<\ntype\n> array of dimension\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nm)\n.\nldb\ninput\nleading dimension of two-dimensional array used to store matrix\nB\n.\nbeta\nhost\ninput\n<\ntype\n> scalar used for multiplication, if\nbeta\n==\n0\nthen\nC\ndoes not have to be a valid input.\nC\nhost or device\nin/out\n<\ntype\n> array of dimension\nldc\nx\nn\nwith\nldc\n>=\nmax(1,\nm)\n.\nldc\ninput\nleading dimension of two-dimensional array used to store matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nthe parameters\nm\n<\n0\nor\nn\n<\n0\nCUBLAS_STATUS_EXECUTION_FAILED\nthe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nssymm()\n,\ndsymm()\n,\ncsymm()\n,\nzsymm()\n4.4.4.\ncublasXt<t>syrk()\n\ncublasStatus_t\ncublasXtSsyrk\n(\ncublasXtHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasXtDsyrk\n(\ncublasXtHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasXtCsyrk\n(\ncublasXtHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasXtZsyrk\n(\ncublasXtHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\nC\n,\nint\nldc\n)\nThis function performs the symmetric rank-\n\\(k\\)\nupdate\n\\(C = \\alpha\\text{op}(A)\\text{op}(A)^{T} + \\beta C\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars,\n\\(C\\)\nis a symmetric matrix stored in lower or upper mode, and\n\\(A\\)\nis a matrix with dimensions\n\\(\\text{op}(A)\\)\n\\(n \\times k\\)\n. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\n\\end{matrix} \\right.\\)\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nhandle to the cuBLASXt API context.\nuplo\ninput\nindicates if matrix\nC\nlower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements.\ntrans\ninput\noperation op(\nA\n) that is non- or transpose.\nn\ninput\nnumber of rows of matrix op(\nA\n) and\nC\n.\nk\ninput\nnumber of columns of matrix op(\nA\n).\nalpha\nhost\ninput\n<\ntype\n> scalar used for multiplication.\nA\nhost or device\ninput\n<\ntype\n> array of dimension\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nn)\nif\ntrans\n==\nCUBLAS_OP_N\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nlda\ninput\nleading dimension of two-dimensional array used to store matrix A.\nbeta\nhost\ninput\n<\ntype\n> scalar used for multiplication, if\nbeta\n==\n0\nthen\nC\ndoes not have to be a valid input.\nC\nhost or device\nin/out\n<\ntype\n> array of dimension\nldc\nx\nn\n, with\nldc\n>=\nmax(1,\nn)\n.\nldc\ninput\nleading dimension of two-dimensional array used to store matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nthe parameters\nn\n<\n0\nor\nk\n<\n0\nCUBLAS_STATUS_EXECUTION_FAILED\nthe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nssyrk()\n,\ndsyrk()\n,\ncsyrk()\n,\nzsyrk()\n4.4.5.\ncublasXt<t>syr2k()\n\ncublasStatus_t\ncublasXtSsyr2k\n(\ncublasXtHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nsize_t\nn\n,\nsize_t\nk\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nA\n,\nsize_t\nlda\n,\nconst\nfloat\n*\nB\n,\nsize_t\nldb\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\nC\n,\nsize_t\nldc\n)\ncublasStatus_t\ncublasXtDsyr2k\n(\ncublasXtHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nsize_t\nn\n,\nsize_t\nk\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nA\n,\nsize_t\nlda\n,\nconst\ndouble\n*\nB\n,\nsize_t\nldb\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\nC\n,\nsize_t\nldc\n)\ncublasStatus_t\ncublasXtCsyr2k\n(\ncublasXtHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nsize_t\nn\n,\nsize_t\nk\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nsize_t\nlda\n,\nconst\ncuComplex\n*\nB\n,\nsize_t\nldb\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\nC\n,\nsize_t\nldc\n)\ncublasStatus_t\ncublasXtZsyr2k\n(\ncublasXtHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nsize_t\nn\n,\nsize_t\nk\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nsize_t\nlda\n,\nconst\ncuDoubleComplex\n*\nB\n,\nsize_t\nldb\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\nC\n,\nsize_t\nldc\n)\nThis function performs the symmetric rank-\n\\(2k\\)\nupdate\n\\(C = \\alpha(\\text{op}(A)\\text{op}(B)^{T} + \\text{op}(B)\\text{op}(A)^{T}) + \\beta C\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars,\n\\(C\\)\nis a symmetric matrix stored in lower or upper mode, and\n\\(A\\)\nand\n\\(B\\)\nare matrices with dimensions\n\\(\\text{op}(A)\\)\n\\(n \\times k\\)\nand\n\\(\\text{op}(B)\\)\n\\(n \\times k\\)\n, respectively. Also, for matrix\n\\(A\\)\nand\n\\(B\\)\n\\(\\text{op(}A\\text{) and op(}B\\text{)} = \\left\\{ \\begin{matrix}\n{A\\text{ and }B} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\n{A^{T}\\text{ and }B^{T}} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\n\\end{matrix} \\right.\\)\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nhandle to the cuBLASXt API context.\nuplo\ninput\nindicates if matrix\nC\nlower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.\ntrans\ninput\noperation op(\nA\n) that is non- or transpose.\nn\ninput\nnumber of rows of matrix op(\nA\n), op(\nB\n) and\nC\n.\nk\ninput\nnumber of columns of matrix op(\nA\n) and op(\nB\n).\nalpha\nhost\ninput\n<\ntype\n> scalar used for multiplication.\nA\nhost or device\ninput\n<\ntype\n> array of dimension\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nn)\nif\ntransa\n==\nCUBLAS_OP_N\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nlda\ninput\nleading dimension of two-dimensional array used to store matrix\nA\n.\nB\nhost or device\ninput\n<\ntype\n> array of dimensions\nldb\nx\nk\nwith\nldb\n>=\nmax(1,\nn)\nif\ntransb\n==\nCUBLAS_OP_N\nand\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nk)\notherwise.\nldb\ninput\nleading dimension of two-dimensional array used to store matrix\nB\n.\nbeta\nhost\ninput\n<\ntype\n> scalar used for multiplication, if\nbeta\n==\n0\n, then\nC\ndoes not have to be a valid input.\nC\nhost or device\nin/out\n<\ntype\n> array of dimensions\nldc\nx\nn\nwith\nldc\n>=\nmax(1,\nn)\n.\nldc\ninput\nleading dimension of two-dimensional array used to store matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nthe parameters\nn\n<\n0\nor\nk\n<\n0\nCUBLAS_STATUS_EXECUTION_FAILED\nthe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nssyr2k()\n,\ndsyr2k()\n,\ncsyr2k()\n,\nzsyr2k()\n4.4.6.\ncublasXt<t>syrkx()\n\ncublasStatus_t\ncublasXtSsyrkx\n(\ncublasXtHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nsize_t\nn\n,\nsize_t\nk\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nA\n,\nsize_t\nlda\n,\nconst\nfloat\n*\nB\n,\nsize_t\nldb\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\nC\n,\nsize_t\nldc\n)\ncublasStatus_t\ncublasXtDsyrkx\n(\ncublasXtHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nsize_t\nn\n,\nsize_t\nk\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nA\n,\nsize_t\nlda\n,\nconst\ndouble\n*\nB\n,\nsize_t\nldb\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\nC\n,\nsize_t\nldc\n)\ncublasStatus_t\ncublasXtCsyrkx\n(\ncublasXtHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nsize_t\nn\n,\nsize_t\nk\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nsize_t\nlda\n,\nconst\ncuComplex\n*\nB\n,\nsize_t\nldb\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\nC\n,\nsize_t\nldc\n)\ncublasStatus_t\ncublasXtZsyrkx\n(\ncublasXtHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nsize_t\nn\n,\nsize_t\nk\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nsize_t\nlda\n,\nconst\ncuDoubleComplex\n*\nB\n,\nsize_t\nldb\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\nC\n,\nsize_t\nldc\n)\nThis function performs a variation of the symmetric rank-\n\\(k\\)\nupdate\n\\(C = \\alpha(\\text{op}(A)\\text{op}(B)^{T} + \\beta C\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars,\n\\(C\\)\nis a symmetric matrix stored in lower or upper mode, and\n\\(A\\)\nand\n\\(B\\)\nare matrices with dimensions\n\\(\\text{op}(A)\\)\n\\(n \\times k\\)\nand\n\\(\\text{op}(B)\\)\n\\(n \\times k\\)\n, respectively. Also, for matrix\n\\(A\\)\nand\n\\(B\\)\n\\(\\text{op(}A\\text{) and op(}B\\text{)} = \\left\\{ \\begin{matrix}\n{A\\text{ and }B} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\n{A^{T}\\text{ and }B^{T}} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\n\\end{matrix} \\right.\\)\nThis routine can be used when B is in such way that the result is guaranteed to be symmetric. A usual example is when the matrix B is a scaled form of the matrix A : this is equivalent to B being the product of the matrix A and a diagonal matrix.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nhandle to the cuBLASXt API context.\nuplo\ninput\nindicates if matrix\nC\nlower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.\ntrans\ninput\noperation op(\nA\n) that is non- or transpose.\nn\ninput\nnumber of rows of matrix op(\nA\n), op(\nB\n) and\nC\n.\nk\ninput\nnumber of columns of matrix op(\nA\n) and op(\nB\n).\nalpha\nhost\ninput\n<\ntype\n> scalar used for multiplication.\nA\nhost or device\ninput\n<\ntype\n> array of dimension\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nn)\nif\ntransa\n==\nCUBLAS_OP_N\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nlda\ninput\nleading dimension of two-dimensional array used to store matrix\nA\n.\nB\nhost or device\ninput\n<\ntype\n> array of dimensions\nldb\nx\nk\nwith\nldb\n>=\nmax(1,\nn)\nif\ntransb\n==\nCUBLAS_OP_N\nand\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nk)\notherwise.\nldb\ninput\nleading dimension of two-dimensional array used to store matrix\nB\n.\nbeta\nhost\ninput\n<\ntype\n> scalar used for multiplication, if\nbeta\n==\n0\n, then\nC\ndoes not have to be a valid input.\nC\nhost or device\nin/out\n<\ntype\n> array of dimensions\nldc\nx\nn\nwith\nldc\n>=\nmax(1,\nn)\n.\nldc\ninput\nleading dimension of two-dimensional array used to store matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nthe parameters\nn\n<\n0\nor\nk\n<\n0\nCUBLAS_STATUS_EXECUTION_FAILED\nthe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nssyrk()\n,\ndsyrk()\n,\ncsyrk()\n,\nzsyrk()\nand\nssyr2k()\n,\ndsyr2k()\n,\ncsyr2k()\n,\nzsyr2k()\n4.4.7.\ncublasXt<t>herk()\n\ncublasStatus_t\ncublasXtCherk\n(\ncublasXtHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\nfloat\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nbeta\n,\ncuComplex\n*\nC\n,\nint\nldc\n)\ncublasStatus_t\ncublasXtZherk\n(\ncublasXtHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nk\n,\nconst\ndouble\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nbeta\n,\ncuDoubleComplex\n*\nC\n,\nint\nldc\n)\nThis function performs the Hermitian rank-\n\\(k\\)\nupdate\n\\(C = \\alpha\\text{op}(A)\\text{op}(A)^{H} + \\beta C\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars,\n\\(C\\)\nis a Hermitian matrix stored in lower or upper mode, and\n\\(A\\)\nis a matrix with dimensions\n\\(\\text{op}(A)\\)\n\\(n \\times k\\)\n. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{H} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nhandle to the cuBLASXt API context.\nuplo\ninput\nindicates if matrix\nC\nlower or upper part is stored, the other Hermitian part is not referenced.\ntrans\ninput\noperation op(\nA\n) that is non- or (conj.) transpose.\nn\ninput\nnumber of rows of matrix op(\nA\n) and\nC\n.\nk\ninput\nnumber of columns of matrix op(\nA\n).\nalpha\nhost\ninput\n<\ntype\n> scalar used for multiplication.\nA\nhost or device\ninput\n<\ntype\n> array of dimension\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nn)\nif\ntransa\n==\nCUBLAS_OP_N\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nlda\ninput\nleading dimension of two-dimensional array used to store matrix\nA\n.\nbeta\nhost\ninput\n<\ntype\n> scalar used for multiplication, if\nbeta\n==\n0\nthen\nC\ndoes not have to be a valid input.\nC\nhost or device\nin/out\n<\ntype\n> array of dimension\nldc\nx\nn\n, with\nldc\n>=\nmax(1,\nn)\n. The imaginary parts of the diagonal elements are assumed and set to zero.\nldc\ninput\nleading dimension of two-dimensional array used to store matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nthe parameters\nn\n<\n0\nor\nk\n<\n0\nCUBLAS_STATUS_EXECUTION_FAILED\nthe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\ncherk()\n,\nzherk()\n4.4.8.\ncublasXt<t>her2k()\n\ncublasStatus_t\ncublasXtCher2k\n(\ncublasXtHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nsize_t\nn\n,\nsize_t\nk\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nsize_t\nlda\n,\nconst\ncuComplex\n*\nB\n,\nsize_t\nldb\n,\nconst\nfloat\n*\nbeta\n,\ncuComplex\n*\nC\n,\nsize_t\nldc\n)\ncublasStatus_t\ncublasXtZher2k\n(\ncublasXtHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nsize_t\nn\n,\nsize_t\nk\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nsize_t\nlda\n,\nconst\ncuDoubleComplex\n*\nB\n,\nsize_t\nldb\n,\nconst\ndouble\n*\nbeta\n,\ncuDoubleComplex\n*\nC\n,\nsize_t\nldc\n)\nThis function performs the Hermitian rank-\n\\(2k\\)\nupdate\n\\(C = \\alpha\\text{op}(A)\\text{op}(B)^{H} + \\overset{ˉ}{\\alpha}\\text{op}(B)\\text{op}(A)^{H} + \\beta C\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars,\n\\(C\\)\nis a Hermitian matrix stored in lower or upper mode, and\n\\(A\\)\nand\n\\(B\\)\nare matrices with dimensions\n\\(\\text{op}(A)\\)\n\\(n \\times k\\)\nand\n\\(\\text{op}(B)\\)\n\\(n \\times k\\)\n, respectively. Also, for matrix\n\\(A\\)\nand\n\\(B\\)\n\\(\\text{op(}A\\text{) and op(}B\\text{)} = \\left\\{ \\begin{matrix}\n{A\\text{ and }B} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\n{A^{H}\\text{ and }B^{H}} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nhandle to the cuBLASXt API context.\nuplo\ninput\nindicates if matrix\nC\nlower or upper part is stored, the other Hermitian part is not referenced.\ntrans\ninput\noperation op(\nA\n) that is non- or (conj.) transpose.\nn\ninput\nnumber of rows of matrix op(\nA\n), op(\nB\n) and\nC\n.\nk\ninput\nnumber of columns of matrix op(\nA\n) and op(\nB\n).\nalpha\nhost\ninput\n<\ntype\n> scalar used for multiplication.\nA\nhost or device\ninput\n<\ntype\n> array of dimension\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nn)\nif\ntransa\n==\nCUBLAS_OP_N\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nlda\ninput\nleading dimension of two-dimensional array used to store matrix\nA\n.\nB\nhost or device\ninput\n<\ntype\n> array of dimension\nldb\nx\nk\nwith\nldb\n>=\nmax(1,\nn)\nif\ntransb\n==\nCUBLAS_OP_N\nand\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nk)\notherwise.\nldb\ninput\nleading dimension of two-dimensional array used to store matrix\nB\n.\nbeta\nhost\ninput\n<\ntype\n> scalar used for multiplication, if\nbeta\n==\n0\nthen\nC\ndoes not have to be a valid input.\nC\nhost or device\nin/out\n<\ntype\n> array of dimension\nldc\nx\nn\n, with\nldc\n>=\nmax(1,\nn)\n. The imaginary parts of the diagonal elements are assumed and set to zero.\nldc\ninput\nleading dimension of two-dimensional array used to store matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nthe parameters\nn\n<\n0\nor\nk\n<\n0\nCUBLAS_STATUS_EXECUTION_FAILED\nthe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\ncher2k()\n,\nzher2k()\n4.4.9.\ncublasXt<t>herkx()\n\ncublasStatus_t\ncublasXtCherkx\n(\ncublasXtHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nsize_t\nn\n,\nsize_t\nk\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nsize_t\nlda\n,\nconst\ncuComplex\n*\nB\n,\nsize_t\nldb\n,\nconst\nfloat\n*\nbeta\n,\ncuComplex\n*\nC\n,\nsize_t\nldc\n)\ncublasStatus_t\ncublasXtZherkx\n(\ncublasXtHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nsize_t\nn\n,\nsize_t\nk\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nsize_t\nlda\n,\nconst\ncuDoubleComplex\n*\nB\n,\nsize_t\nldb\n,\nconst\ndouble\n*\nbeta\n,\ncuDoubleComplex\n*\nC\n,\nsize_t\nldc\n)\nThis function performs a variation of the Hermitian rank-\n\\(k\\)\nupdate\n\\(C = \\alpha\\text{op}(A)\\text{op}(B)^{H} + \\beta C\\)\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars,\n\\(C\\)\nis a Hermitian matrix stored in lower or upper mode, and\n\\(A\\)\nand\n\\(B\\)\nare matrices with dimensions\n\\(\\text{op}(A)\\)\n\\(n \\times k\\)\nand\n\\(\\text{op}(B)\\)\n\\(n \\times k\\)\n, respectively. Also, for matrix\n\\(A\\)\nand\n\\(B\\)\n\\(\\text{op(}A\\text{) and op(}B\\text{)} = \\left\\{ \\begin{matrix}\n{A\\text{ and }B} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\n{A^{H}\\text{ and }B^{H}} & {\\text{if }\\textsf{trans == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nThis routine can be used when the matrix B is in such way that the result is guaranteed to be hermitian. A usual example is when the matrix B is a scaled form of the matrix A : this is equivalent to B being the product of the matrix A and a diagonal matrix.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nhandle to the cuBLASXt API context.\nuplo\ninput\nindicates if matrix\nC\nlower or upper part is stored, the other Hermitian part is not referenced.\ntrans\ninput\noperation op(\nA\n) that is non- or (conj.) transpose.\nn\ninput\nnumber of rows of matrix op(\nA\n), op(\nB\n) and\nC\n.\nk\ninput\nnumber of columns of matrix op(\nA\n) and op(\nB\n).\nalpha\nhost\ninput\n<\ntype\n> scalar used for multiplication.\nA\nhost or device\ninput\n<\ntype\n> array of dimension\nlda\nx\nk\nwith\nlda\n>=\nmax(1,\nn)\nif\ntransa\n==\nCUBLAS_OP_N\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nk)\notherwise.\nlda\ninput\nleading dimension of two-dimensional array used to store matrix\nA\n.\nB\nhost or device\ninput\n<\ntype\n> array of dimension\nldb\nx\nk\nwith\nldb\n>=\nmax(1,\nn)\nif\ntransb\n==\nCUBLAS_OP_N\nand\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nk)\notherwise.\nldb\ninput\nleading dimension of two-dimensional array used to store matrix\nB\n.\nbeta\nhost\ninput\nreal scalar used for multiplication, if\nbeta\n==\n0\nthen\nC\ndoes not have to be a valid input.\nC\nhost or device\nin/out\n<\ntype\n> array of dimension\nldc\nx\nn\n, with\nldc\n>=\nmax(1,\nn)\n. The imaginary parts of the diagonal elements are assumed and set to zero.\nldc\ninput\nleading dimension of two-dimensional array used to store matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nthe parameters\nn\n<\n0\nor\nk\n<\n0\nCUBLAS_STATUS_EXECUTION_FAILED\nthe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\ncherk()\n,\nzherk()\nand\ncher2k()\n,\nzher2k()\n4.4.10.\ncublasXt<t>trsm()\n\ncublasStatus_t\ncublasXtStrsm\n(\ncublasXtHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasXtDiagType_t\ndiag\n,\nsize_t\nm\n,\nsize_t\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nA\n,\nsize_t\nlda\n,\nfloat\n*\nB\n,\nsize_t\nldb\n)\ncublasStatus_t\ncublasXtDtrsm\n(\ncublasXtHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasXtDiagType_t\ndiag\n,\nsize_t\nm\n,\nsize_t\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nA\n,\nsize_t\nlda\n,\ndouble\n*\nB\n,\nsize_t\nldb\n)\ncublasStatus_t\ncublasXtCtrsm\n(\ncublasXtHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasXtDiagType_t\ndiag\n,\nsize_t\nm\n,\nsize_t\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nsize_t\nlda\n,\ncuComplex\n*\nB\n,\nsize_t\nldb\n)\ncublasStatus_t\ncublasXtZtrsm\n(\ncublasXtHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasXtDiagType_t\ndiag\n,\nsize_t\nm\n,\nsize_t\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nsize_t\nlda\n,\ncuDoubleComplex\n*\nB\n,\nsize_t\nldb\n)\nThis function solves the triangular linear system with multiple right-hand-sides\n\\(\\left\\{ \\begin{matrix}\n{\\text{op}(A)X = \\alpha B} & {\\text{if }\\textsf{side == $\\mathrm{CUBLAS\\_SIDE\\_LEFT}$}} \\\\\n{X\\text{op}(A) = \\alpha B} & {\\text{if }\\textsf{side == $\\mathrm{CUBLAS\\_SIDE\\_RIGHT}$}} \\\\\n\\end{matrix} \\right.\\)\nwhere\n\\(A\\)\nis a triangular matrix stored in lower or upper mode with or without the main diagonal,\n\\(X\\)\nand\n\\(B\\)\nare\n\\(m \\times n\\)\nmatrices, and\n\\(\\alpha\\)\nis a scalar. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\nA^{H} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nThe solution\n\\(X\\)\noverwrites the right-hand-sides\n\\(B\\)\non exit.\nNo test for singularity or near-singularity is included in this function.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nhandle to the cuBLASXt API context.\nside\ninput\nindicates if matrix\nA\nis on the left or right of\nX\n.\nuplo\ninput\nindicates if matrix\nA\nlower or upper part is stored, the other part is not referenced and is inferred from the stored elements.\ntrans\ninput\noperation op(\nA\n) that is non- or (conj.) transpose.\ndiag\ninput\nindicates if the elements on the main diagonal of matrix\nA\nare unity and should not be accessed.\nm\ninput\nnumber of rows of matrix\nB\n, with matrix\nA\nsized accordingly.\nn\ninput\nnumber of columns of matrix\nB\n, with matrix\nA\nis sized accordingly.\nalpha\nhost\ninput\n<\ntype\n> scalar used for multiplication, if\nalpha\n==\n0\nthen\nA\nis not referenced and\nB\ndoes not have to be a valid input.\nA\nhost or device\ninput\n<\ntype\n> array of dimension\nlda\nx\nm\nwith\nlda\n>=\nmax(1,\nm)\nif\nside\n==\nCUBLAS_SIDE_LEFT\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nn)\notherwise.\nlda\ninput\nleading dimension of two-dimensional array used to store matrix\nA\n.\nB\nhost or device\nin/out\n<\ntype\n> array. It has dimensions\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nm)\n.\nldb\ninput\nleading dimension of two-dimensional array used to store matrix\nB\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nthe parameters\nm\n<\n0\nor\nn\n<\n0\nCUBLAS_STATUS_EXECUTION_FAILED\nthe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nstrsm()\n,\ndtrsm()\n,\nctrsm()\n,\nztrsm()\n4.4.11.\ncublasXt<t>trmm()\n\ncublasStatus_t\ncublasXtStrmm\n(\ncublasXtHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nsize_t\nm\n,\nsize_t\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nA\n,\nsize_t\nlda\n,\nconst\nfloat\n*\nB\n,\nsize_t\nldb\n,\nfloat\n*\nC\n,\nsize_t\nldc\n)\ncublasStatus_t\ncublasXtDtrmm\n(\ncublasXtHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nsize_t\nm\n,\nsize_t\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nA\n,\nsize_t\nlda\n,\nconst\ndouble\n*\nB\n,\nsize_t\nldb\n,\ndouble\n*\nC\n,\nsize_t\nldc\n)\ncublasStatus_t\ncublasXtCtrmm\n(\ncublasXtHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nsize_t\nm\n,\nsize_t\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nsize_t\nlda\n,\nconst\ncuComplex\n*\nB\n,\nsize_t\nldb\n,\ncuComplex\n*\nC\n,\nsize_t\nldc\n)\ncublasStatus_t\ncublasXtZtrmm\n(\ncublasXtHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\ncublasDiagType_t\ndiag\n,\nsize_t\nm\n,\nsize_t\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nsize_t\nlda\n,\nconst\ncuDoubleComplex\n*\nB\n,\nsize_t\nldb\n,\ncuDoubleComplex\n*\nC\n,\nsize_t\nldc\n)\nThis function performs the triangular matrix-matrix multiplication\n\\(C = \\left\\{ \\begin{matrix}\n{\\alpha\\text{op}(A)B} & {\\text{if }\\textsf{side == $\\mathrm{CUBLAS\\_SIDE\\_LEFT}$}} \\\\\n{\\alpha B\\text{op}(A)} & {\\text{if }\\textsf{side == $\\mathrm{CUBLAS\\_SIDE\\_RIGHT}$}} \\\\\n\\end{matrix} \\right.\\)\nwhere\n\\(A\\)\nis a triangular matrix stored in lower or upper mode with or without the main diagonal,\n\\(B\\)\nand\n\\(C\\)\nare\n\\(m \\times n\\)\nmatrix, and\n\\(\\alpha\\)\nis a scalar. Also, for matrix\n\\(A\\)\n\\(\\text{op}(A) = \\left\\{ \\begin{matrix}\nA & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_N}$}} \\\\\nA^{T} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_T}$}} \\\\\nA^{H} & {\\text{if }\\textsf{transa == $\\mathrm{CUBLAS\\_OP\\_C}$}} \\\\\n\\end{matrix} \\right.\\)\nNotice that in order to achieve better parallelism, similarly to the cublas API, cuBLASXt API differs from the BLAS API for this routine. The BLAS API assumes an in-place implementation (with results written back to B), while the cuBLASXt API assumes an out-of-place implementation (with results written into C). The application can still obtain the in-place functionality of BLAS in the cuBLASXt API by passing the address of the matrix B in place of the matrix C. No other overlapping in the input parameters is supported.\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nhandle to the cuBLASXt API context.\nside\ninput\nindicates if matrix\nA\nis on the left or right of\nB\n.\nuplo\ninput\nindicates if matrix\nA\nlower or upper part is stored, the other part is not referenced and is inferred from the stored elements.\ntrans\ninput\noperation op(\nA\n) that is non- or (conj.) transpose.\ndiag\ninput\nindicates if the elements on the main diagonal of matrix\nA\nare unity and should not be accessed.\nm\ninput\nnumber of rows of matrix\nB\n, with matrix\nA\nsized accordingly.\nn\ninput\nnumber of columns of matrix\nB\n, with matrix\nA\nsized accordingly.\nalpha\nhost\ninput\n<\ntype\n> scalar used for multiplication, if\nalpha\nthen\nA\nis not referenced and\nB\ndoes not have to be a valid input.\nA\nhost or device\ninput\n<\ntype\n> array of dimension\nlda\nx\nm\nwith\nlda\n>=\nmax(1,\nm)\nif\nside\n==\nCUBLAS_SIDE_LEFT\nand\nlda\nx\nn\nwith\nlda\n>=\nmax(1,\nn)\notherwise.\nlda\ninput\nleading dimension of two-dimensional array used to store matrix\nA\n.\nB\nhost or device\ninput\n<\ntype\n> array of dimension\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nm)\n.\nldb\ninput\nleading dimension of two-dimensional array used to store matrix\nB\n.\nC\nhost or device\nin/out\n<\ntype\n> array of dimension\nldc\nx\nn\nwith\nldc\n>=\nmax(1,\nm)\n.\nldc\ninput\nleading dimension of two-dimensional array used to store matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nthe parameters\nm\n<\n0\nor\nn\n<\n0\nCUBLAS_STATUS_EXECUTION_FAILED\nthe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nstrmm()\n,\ndtrmm()\n,\nctrmm()\n,\nztrmm()\n4.4.12.\ncublasXt<t>spmm()\n\ncublasStatus_t\ncublasXtSspmm\n(\ncublasXtHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\nsize_t\nm\n,\nsize_t\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nAP\n,\nconst\nfloat\n*\nB\n,\nsize_t\nldb\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\nC\n,\nsize_t\nldc\n);\ncublasStatus_t\ncublasXtDspmm\n(\ncublasXtHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\nsize_t\nm\n,\nsize_t\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nAP\n,\nconst\ndouble\n*\nB\n,\nsize_t\nldb\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\nC\n,\nsize_t\nldc\n);\ncublasStatus_t\ncublasXtCspmm\n(\ncublasXtHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\nsize_t\nm\n,\nsize_t\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nAP\n,\nconst\ncuComplex\n*\nB\n,\nsize_t\nldb\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\nC\n,\nsize_t\nldc\n);\ncublasStatus_t\ncublasXtZspmm\n(\ncublasXtHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\nsize_t\nm\n,\nsize_t\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nAP\n,\nconst\ncuDoubleComplex\n*\nB\n,\nsize_t\nldb\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\nC\n,\nsize_t\nldc\n);\nThis function performs the symmetric packed matrix-matrix multiplication\n\\(C = \\left\\{ \\begin{matrix}\n{\\alpha AB + \\beta C} & {\\text{if }\\textsf{side == $\\mathrm{CUBLAS\\_SIDE\\_LEFT}$}} \\\\\n{\\alpha BA + \\beta C} & {\\text{if }\\textsf{side == $\\mathrm{CUBLAS\\_SIDE\\_RIGHT}$}} \\\\\n\\end{matrix} \\right.\\)\nwhere\n\\(A\\)\nis a\n\\(n \\times n\\)\nsymmetric matrix stored in packed format,\n\\(B\\)\nand\n\\(C\\)\nare\n\\(m \\times n\\)\nmatrices, and\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_LOWER\nthen the elements in the lower triangular part of the symmetric matrix\n\\(A\\)\nare packed together column by column without gaps, so that the element\n\\(A(i,j)\\)\nis stored in the memory location\nAP[i+((2*n-j+1)*j)/2]\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\geq j\\)\n. Consequently, the packed format requires only\n\\(\\frac{n(n + 1)}{2}\\)\nelements for storage.\nIf\nuplo\n==\nCUBLAS_FILL_MODE_UPPER\nthen the elements in the upper triangular part of the symmetric matrix\n\\(A\\)\nare packed together column by column without gaps, so that the element\n\\(A(i,j)\\)\nis stored in the memory location\nAP[i+(j*(j+1))/2]\nfor\n\\(j = 1,\\ldots,n\\)\nand\n\\(i \\leq j\\)\n. Consequently, the packed format requires only\n\\(\\frac{n(n + 1)}{2}\\)\nelements for storage.\nNote\nThe packed matrix AP must be located on the host or managed memory whereas the other matrices can be located on the host or any GPU device\nParam.\nMemory\nIn/out\nMeaning\nhandle\ninput\nhandle to the cuBLASXt API context.\nside\ninput\nindicates if matrix\nA\nis on the left or right of\nB\n.\nuplo\ninput\nindicates if matrix\nA\nlower or upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements.\nm\ninput\nnumber of rows of matrix\nA\nand\nB\n, with matrix\nA\nsized accordingly.\nn\ninput\nnumber of columns of matrix\nC\nand\nA\n, with matrix\nA\nsized accordingly.\nalpha\nhost\ninput\n<\ntype\n> scalar used for multiplication.\nAP\nhost\ninput\n<\ntype\n> array with\n\\(A\\)\nstored in packed format.\nB\nhost or device\ninput\n<\ntype\n> array of dimension\nldb\nx\nn\nwith\nldb\n>=\nmax(1,\nm)\n.\nldb\ninput\nleading dimension of two-dimensional array used to store matrix\nB\n.\nbeta\nhost\ninput\n<\ntype\n> scalar used for multiplication, if\nbeta\n==\n0\nthen\nC\ndoes not have to be a valid input.\nC\nhost or device\nin/out\n<\ntype\n> array of dimension\nldc\nx\nn\nwith\nldc\n>=\nmax(1,\nm)\n.\nldc\ninput\nleading dimension of two-dimensional array used to store matrix\nC\n.\nThe possible error values returned by this function and their meanings are listed below.\nError Value\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized\nCUBLAS_STATUS_INVALID_VALUE\nthe parameters\nm\n<\n0\nor\nn\n<\n0\nCUBLAS_STATUS_NOT_SUPPORTED\nthe matrix AP is located on a GPU device\nCUBLAS_STATUS_EXECUTION_FAILED\nthe function failed to launch on the GPU\nFor references please refer to NETLIB documentation:\nssymm()\n,\ndsymm()\n,\ncsymm()\n,\nzsymm()\n5.\nUsing the cuBLASDx API\n\nThe cuBLASDx library (preview) is a device side API extension for performing BLAS calculations inside CUDA kernels.\nBy fusing numerical operations you can decrease latency and further improve performance of your applications.\nYou can access cuBLASDx documentation\nhere\n.\ncuBLASDx is not a part of the CUDA Toolkit. You can download cuBLASDx separately from\nhere\n.\n6.\nUsing the cuBLAS Legacy API\n\nThis section does not provide a full reference of each Legacy API datatype and entry point. Instead, it describes how to use the API, especially where this is different from the regular cuBLAS API.\nNote that in this section, all references to the “cuBLAS Library” refer to the Legacy cuBLAS API only.\nWarning\nThe legacy cuBLAS API is deprecated and will be removed in future release.\n6.1.\nError Status\n\nThe\ncublasStatus\ntype is used for function status returns. The cuBLAS Library helper functions return status directly, while the status of core functions can be retrieved using\ncublasGetError()\n. Notice that reading the error status via\ncublasGetError()\n, resets the internal error state to\nCUBLAS_STATUS_SUCCESS\n. Currently, the following values are defined:\nValue\nMeaning\nCUBLAS_STATUS_SUCCESS\nthe operation completed successfully\nCUBLAS_STATUS_NOT_INITIALIZED\nthe library was not initialized\nCUBLAS_STATUS_ALLOC_FAILED\nthe resource allocation failed\nCUBLAS_STATUS_INVALID_VALUE\nan invalid numerical value was used as an argument\nCUBLAS_STATUS_ARCH_MISMATCH\nan absent device architectural feature is required\nCUBLAS_STATUS_MAPPING_ERROR\nan access to GPU memory space failed\nCUBLAS_STATUS_EXECUTION_FAILED\nthe GPU program failed to execute\nCUBLAS_STATUS_INTERNAL_ERROR\nan internal operation failed\nCUBLAS_STATUS_NOT_SUPPORTED\nthe feature required is not supported\nThis legacy type corresponds to type\ncublasStatus_t\nin the cuBLAS library API.\n6.2.\nInitialization and Shutdown\n\nThe functions\ncublasInit()\nand\ncublasShutdown()\nare used to initialize and shutdown the cuBLAS library. It is recommended for\ncublasInit()\nto be called before any other function is invoked. It allocates hardware resources on the GPU device that is currently bound to the host thread from which it was invoked.\nThe legacy initialization and shutdown functions are similar to the cuBLAS library API routines\ncublasCreate()\nand\ncublasDestroy()\n.\n6.3.\nThread Safety\n\nThe legacy API is not thread safe when used with multiple host threads and devices. It is recommended to be used only when utmost compatibility with Fortran is required and when a single host thread is used to setup the library and make all the functions calls.\n6.4.\nMemory Management\n\nThe memory used by the legacy cuBLAS library API is allocated and released using functions\ncublasAlloc()\nand\ncublasFree()\n, respectively. These functions create and destroy an object in the GPU memory space capable of holding an array of\nn\nelements, where each element requires\nelemSize\nbytes of storage. Please see the legacy cuBLAS API header file “cublas.h” for the prototypes of these functions.\nThe function\ncublasAlloc()\nis a wrapper around the function\ncudaMalloc()\n, therefore device pointers returned by\ncublasAlloc()\ncan be passed to any CUDA™ device kernel functions. However, these device pointers can not be dereferenced in the host code. The function\ncublasFree()\nis a wrapper around the function\ncudaFree()\n.\n6.5.\nScalar Parameters\n\nIn the legacy cuBLAS API, scalar parameters are passed by value from the host. Also, the few functions that do return a scalar result, such as dot() and nrm2(), return the resulting value on the host, and hence these routines will wait for kernel execution on the device to complete before returning, which makes parallelism with streams impractical. However, the majority of functions do not return any value, in order to be more compatible with Fortran and the existing BLAS libraries.\n6.6.\nHelper Functions\n\nIn this section we list the helper functions provided by the legacy cuBLAS API and their functionality. For the exact prototypes of these functions please refer to the legacy cuBLAS API header file “cublas.h”.\nHelper function\nMeaning\ncublasInit()\ninitialize the library\ncublasShutdown()\nshuts down the library\ncublasGetError()\nretrieves the error status of the library\ncublasSetKernelStream()\nsets the stream to be used by the library\ncublasAlloc()\nallocates the device memory for the library\ncublasFree()\nreleases the device memory allocated for the library\ncublasSetVector()\ncopies a vector\nx\non the host to a vector on the GPU\ncublasGetVector()\ncopies a vector\nx\non the GPU to a vector on the host\ncublasSetMatrix()\ncopies a\n\\(m \\times n\\)\ntile from a matrix on the host to the GPU\ncublasGetMatrix()\ncopies a\n\\(m \\times n\\)\ntile from a matrix on the GPU to the host\ncublasSetVectorAsync()\nsimilar to\ncublasSetVector()\n, but the copy is asynchronous\ncublasGetVectorAsync()\nsimilar to\ncublasGetVector()\n, but the copy is asynchronous\ncublasSetMatrixAsync()\nsimilar to\ncublasSetMatrix()\n, but the copy is asynchronous\ncublasGetMatrixAsync()\nsimilar to\ncublasGetMatrix()\n, but the copy is asynchronous\n6.7.\nLevel-1,2,3 Functions\n\nThe Level-1,2,3 cuBLAS functions (also called core functions) have the same name and behavior as the ones listed in the chapters 3, 4 and 5 in this document. Please refer to the legacy cuBLAS API header file “cublas.h” for their exact prototype. Also, the next section talks a bit more about the differences between the legacy and the cuBLAS API prototypes, more specifically how to convert the function calls from one API to another.\n6.8.\nConverting Legacy to the cuBLAS API\n\nThere are a few general rules that can be used to convert from legacy to the cuBLAS API:\nExchange the header file “cublas.h” for “cublas_v2.h”.\nExchange the type\ncublasStatus\nfor\ncublasStatus_t\n.\nExchange the function\ncublasSetKernelStream()\nfor\ncublasSetStream()\n.\nExchange the function\ncublasAlloc()\nand\ncublasFree()\nfor\ncudaMalloc()\nand\ncudaFree()\n, respectively. Notice that\ncudaMalloc()\nexpects the size of the allocated memory to be provided in bytes (usually simply provide\nn\nx\nelemSize\nto allocate\nn\nelements, each of size\nelemSize\nbytes).\nDeclare the\ncublasHandle_t\ncuBLAS library handle.\nInitialize the handle using\ncublasCreate()\n. Also, release the handle once finished using\ncublasDestroy()\n.\nAdd the handle as the first parameter to all the cuBLAS library function calls.\nChange the scalar parameters to be passed by reference, instead of by value (usually simply adding “&” symbol in C/C++ is enough, because the parameters are passed by reference on the host by\ndefault\n). However, note that if the routine is running asynchronously, then the variable holding the scalar parameter cannot be changed until the kernels that the routine dispatches are completed. See the CUDA C++ Programming Guide for a detailed discussion of how to use streams.\nChange the parameter characters\nN\nor\nn\n(non-transpose operation),\nT\nor\nt\n(transpose operation) and\nC\nor\nc\n(conjugate transpose operation) to\nCUBLAS_OP_N\n,\nCUBLAS_OP_T\nand\nCUBLAS_OP_C\n, respectively.\nChange the parameter characters\nL\nor\nl\n(lower part filled) and\nU\nor\nu\n(upper part filled) to\nCUBLAS_FILL_MODE_LOWER\nand\nCUBLAS_FILL_MODE_UPPER\n, respectively.\nChange the parameter characters\nN\nor\nn\n(non-unit diagonal) and\nU\nor\nu\n(unit diagonal) to\nCUBLAS_DIAG_NON_UNIT\nand\nCUBLAS_DIAG_UNIT\n, respectively.\nChange the parameter characters\nL\nor\nl\n(left side) and\nR\nor\nr\n(right side) to\nCUBLAS_SIDE_LEFT\nand\nCUBLAS_SIDE_RIGHT\n, respectively.\nIf the legacy API function returns a scalar value, add an extra scalar parameter of the same type passed by reference, as the last parameter to the same function.\nInstead of using\ncublasGetError()\n, use the return value of the function itself to check for errors.\nFinally, please use the function prototypes in the header files\ncublas.h\nand\ncublas_v2.h\nto check the code for correctness.\n6.9.\nExamples\n\nFor sample code references that use the legacy cuBLAS API please see the two examples below. They show an application written in C using the legacy cuBLAS library API with two indexing styles (Example A.1. “Application Using C and cuBLAS: 1-based indexing” and Example A.2. “Application Using C and cuBLAS: 0-based Indexing”). This application is analogous to the one using the cuBLAS library API that is shown in the Introduction chapter.\nExample A.1. Application Using C and cuBLAS: 1-based indexing\n//-----------------------------------------------------------\n#include\n<stdio.h>\n#include\n<stdlib.h>\n#include\n<math.h>\n#include\n\"cublas.h\"\n#define M 6\n#define N 5\n#define IDX2F(i,j,ld) ((((j)-1)*(ld))+((i)-1))\nstatic\n__inline__\nvoid\nmodify\n(\nfloat\n*\nm\n,\nint\nldm\n,\nint\nn\n,\nint\np\n,\nint\nq\n,\nfloat\nalpha\n,\nfloat\nbeta\n){\ncublasSscal\n(\nn\n-\nq\n+\n1\n,\nalpha\n,\n&\nm\n[\nIDX2F\n(\np\n,\nq\n,\nldm\n)],\nldm\n);\ncublasSscal\n(\nldm\n-\np\n+\n1\n,\nbeta\n,\n&\nm\n[\nIDX2F\n(\np\n,\nq\n,\nldm\n)],\n1\n);\n}\nint\nmain\n(\nvoid\n){\nint\ni\n,\nj\n;\ncublasStatus\nstat\n;\nfloat\n*\ndevPtrA\n;\nfloat\n*\na\n=\n0\n;\na\n=\n(\nfloat\n*\n)\nmalloc\n(\nM\n*\nN\n*\nsizeof\n(\n*\na\n));\nif\n(\n!\na\n)\n{\nprintf\n(\n\"host memory allocation failed\"\n);\nreturn\nEXIT_FAILURE\n;\n}\nfor\n(\nj\n=\n1\n;\nj\n<=\nN\n;\nj\n++\n)\n{\nfor\n(\ni\n=\n1\n;\ni\n<=\nM\n;\ni\n++\n)\n{\na\n[\nIDX2F\n(\ni\n,\nj\n,\nM\n)]\n=\n(\nfloat\n)((\ni\n-1\n)\n*\nM\n+\nj\n);\n}\n}\ncublasInit\n();\nstat\n=\ncublasAlloc\n(\nM\n*\nN\n,\nsizeof\n(\n*\na\n),\n(\nvoid\n**\n)\n&\ndevPtrA\n);\nif\n(\nstat\n!=\nCUBLAS_STATUS_SUCCESS\n)\n{\nprintf\n(\n\"device memory allocation failed\"\n);\ncublasShutdown\n();\nreturn\nEXIT_FAILURE\n;\n}\nstat\n=\ncublasSetMatrix\n(\nM\n,\nN\n,\nsizeof\n(\n*\na\n),\na\n,\nM\n,\ndevPtrA\n,\nM\n);\nif\n(\nstat\n!=\nCUBLAS_STATUS_SUCCESS\n)\n{\nprintf\n(\n\"data download failed\"\n);\ncublasFree\n(\ndevPtrA\n);\ncublasShutdown\n();\nreturn\nEXIT_FAILURE\n;\n}\nmodify\n(\ndevPtrA\n,\nM\n,\nN\n,\n2\n,\n3\n,\n16.0f\n,\n12.0f\n);\nstat\n=\ncublasGetMatrix\n(\nM\n,\nN\n,\nsizeof\n(\n*\na\n),\ndevPtrA\n,\nM\n,\na\n,\nM\n);\nif\n(\nstat\n!=\nCUBLAS_STATUS_SUCCESS\n)\n{\nprintf\n(\n\"data upload failed\"\n);\ncublasFree\n(\ndevPtrA\n);\ncublasShutdown\n();\nreturn\nEXIT_FAILURE\n;\n}\ncublasFree\n(\ndevPtrA\n);\ncublasShutdown\n();\nfor\n(\nj\n=\n1\n;\nj\n<=\nN\n;\nj\n++\n)\n{\nfor\n(\ni\n=\n1\n;\ni\n<=\nM\n;\ni\n++\n)\n{\nprintf\n(\n\"%7.0f\"\n,\na\n[\nIDX2F\n(\ni\n,\nj\n,\nM\n)]);\n}\nprintf\n(\n\"\n\\n\n\"\n);\n}\nfree\n(\na\n);\nreturn\nEXIT_SUCCESS\n;\n}\nExample A.2. Application Using C and cuBLAS: 0-based indexing\n//-----------------------------------------------------------\n#include\n<stdio.h>\n#include\n<stdlib.h>\n#include\n<math.h>\n#include\n\"cublas.h\"\n#define M 6\n#define N 5\n#define IDX2C(i,j,ld) (((j)*(ld))+(i))\nstatic\n__inline__\nvoid\nmodify\n(\nfloat\n*\nm\n,\nint\nldm\n,\nint\nn\n,\nint\np\n,\nint\nq\n,\nfloat\nalpha\n,\nfloat\nbeta\n){\ncublasSscal\n(\nn\n-\nq\n,\nalpha\n,\n&\nm\n[\nIDX2C\n(\np\n,\nq\n,\nldm\n)],\nldm\n);\ncublasSscal\n(\nldm\n-\np\n,\nbeta\n,\n&\nm\n[\nIDX2C\n(\np\n,\nq\n,\nldm\n)],\n1\n);\n}\nint\nmain\n(\nvoid\n){\nint\ni\n,\nj\n;\ncublasStatus\nstat\n;\nfloat\n*\ndevPtrA\n;\nfloat\n*\na\n=\n0\n;\na\n=\n(\nfloat\n*\n)\nmalloc\n(\nM\n*\nN\n*\nsizeof\n(\n*\na\n));\nif\n(\n!\na\n)\n{\nprintf\n(\n\"host memory allocation failed\"\n);\nreturn\nEXIT_FAILURE\n;\n}\nfor\n(\nj\n=\n0\n;\nj\n<\nN\n;\nj\n++\n)\n{\nfor\n(\ni\n=\n0\n;\ni\n<\nM\n;\ni\n++\n)\n{\na\n[\nIDX2C\n(\ni\n,\nj\n,\nM\n)]\n=\n(\nfloat\n)(\ni\n*\nM\n+\nj\n+\n1\n);\n}\n}\ncublasInit\n();\nstat\n=\ncublasAlloc\n(\nM\n*\nN\n,\nsizeof\n(\n*\na\n),\n(\nvoid\n**\n)\n&\ndevPtrA\n);\nif\n(\nstat\n!=\nCUBLAS_STATUS_SUCCESS\n)\n{\nprintf\n(\n\"device memory allocation failed\"\n);\ncublasShutdown\n();\nreturn\nEXIT_FAILURE\n;\n}\nstat\n=\ncublasSetMatrix\n(\nM\n,\nN\n,\nsizeof\n(\n*\na\n),\na\n,\nM\n,\ndevPtrA\n,\nM\n);\nif\n(\nstat\n!=\nCUBLAS_STATUS_SUCCESS\n)\n{\nprintf\n(\n\"data download failed\"\n);\ncublasFree\n(\ndevPtrA\n);\ncublasShutdown\n();\nreturn\nEXIT_FAILURE\n;\n}\nmodify\n(\ndevPtrA\n,\nM\n,\nN\n,\n1\n,\n2\n,\n16.0f\n,\n12.0f\n);\nstat\n=\ncublasGetMatrix\n(\nM\n,\nN\n,\nsizeof\n(\n*\na\n),\ndevPtrA\n,\nM\n,\na\n,\nM\n);\nif\n(\nstat\n!=\nCUBLAS_STATUS_SUCCESS\n)\n{\nprintf\n(\n\"data upload failed\"\n);\ncublasFree\n(\ndevPtrA\n);\ncublasShutdown\n();\nreturn\nEXIT_FAILURE\n;\n}\ncublasFree\n(\ndevPtrA\n);\ncublasShutdown\n();\nfor\n(\nj\n=\n0\n;\nj\n<\nN\n;\nj\n++\n)\n{\nfor\n(\ni\n=\n0\n;\ni\n<\nM\n;\ni\n++\n)\n{\nprintf\n(\n\"%7.0f\"\n,\na\n[\nIDX2C\n(\ni\n,\nj\n,\nM\n)]);\n}\nprintf\n(\n\"\n\\n\n\"\n);\n}\nfree\n(\na\n);\nreturn\nEXIT_SUCCESS\n;\n}\n7.\ncuBLAS Fortran Bindings\n\nThe cuBLAS library is implemented using the C-based CUDA toolchain. Thus, it provides a C-style API. This makes interfacing to applications written in C and C++ trivial, but the library can also be used by applications written in Fortran. In particular, the cuBLAS library uses 1-based indexing and Fortran-style column-major storage for multidimensional data to simplify interfacing to Fortran applications. Unfortunately, Fortran-to-C calling conventions are not standardized and differ by platform and toolchain. In particular, differences may exist in the following areas:\nsymbol names (capitalization, name decoration)\nargument passing (by value or reference)\npassing of string arguments (length information)\npassing of pointer arguments (size of the pointer)\nreturning floating-point or compound data types (for example single-precision or complex data types)\nTo provide maximum flexibility in addressing those differences, the cuBLAS Fortran interface is provided in the form of wrapper functions and is part of the Toolkit delivery. The C source code of those wrapper functions is located in the\nsrc\ndirectory and provided in two different forms:\nthe thunking wrapper interface located in the file\nfortran_thunking.c\nthe direct wrapper interface located in the file\nfortran.c\nThe code of one of those two files needs to be compiled into an application for it to call the cuBLAS API functions. Providing source code allows users to make any changes necessary for a particular platform and toolchain.\nThe code in those two C files has been used to demonstrate interoperability with the compilers g77 3.2.3 and g95 0.91 on 32-bit Linux, g77 3.4.5 and g95 0.91 on 64-bit Linux, Intel Fortran 9.0 and Intel Fortran 10.0 on 32-bit and 64-bit Microsoft Windows XP, and g77 3.4.0 and g95 0.92 on Mac OS X.\nNote that for g77, use of the compiler flag\n-fno-second-underscore\nis required to use these wrappers as provided. Also, the use of the default calling conventions with regard to argument and return value passing is expected. Using the flag -fno-f2c changes the default calling convention with respect to these two items.\nThe thunking wrappers allow interfacing to existing Fortran applications without any changes to the application. During each call, the wrappers allocate GPU memory, copy source data from CPU memory space to GPU memory space, call cuBLAS, and finally copy back the results to CPU memory space and deallocate the GPU memory. As this process causes very significant call overhead, these wrappers are intended for light testing, not for production code. To use the thunking wrappers, the application needs to be compiled with the file\nfortran_thunking.c\n.\nThe direct wrappers, intended for production code, substitute device pointers for vector and matrix arguments in all BLAS functions. To use these interfaces, existing applications need to be modified slightly to allocate and deallocate data structures in GPU memory space (using\ncuBLAS_ALLOC\nand\ncuBLAS_FREE\n) and to copy data between GPU and CPU memory spaces (using\ncuBLAS_SET_VECTOR\n,\ncuBLAS_GET_VECTOR\n,\ncuBLAS_SET_MATRIX\n, and\ncuBLAS_GET_MATRIX\n). The sample wrappers provided in\nfortran.c\nmap device pointers to the OS-dependent type\nsize_t\n, which is 32-bit wide on 32-bit platforms and 64-bit wide on a 64-bit platforms.\nOne approach to deal with index arithmetic on device pointers in Fortran code is to use C-style macros, and use the C preprocessor to expand these, as shown in the example below. On Linux and Mac OS X, one way of pre-processing is to use the option\n-E\n-x\nf77-cpp-input\nwhen using g77 compiler, or simply the option\n-cpp\nwhen using g95 or gfortran. On Windows platforms with Microsoft Visual C/C++, using ’cl -EP’ achieves similar results.\n! Example B.1. Fortran 77 Application Executing on the Host\n! ----------------------------------------------------------\nsubroutine\nmodify\n(\nm\n,\nldm\n,\nn\n,\np\n,\nq\n,\nalpha\n,\nbeta\n)\nimplicit none\ninteger\nldm\n,\nn\n,\np\n,\nq\nreal\n*\n4\nm\n(\nldm\n,\n*\n)\n,\nalpha\n,\nbeta\nexternal\ncublas_sscal\ncall\ncublas_sscal\n(\nn\n-\np\n+\n1\n,\nalpha\n,\nm\n(\np\n,\nq\n),\nldm\n)\ncall\ncublas_sscal\n(\nldm\n-\np\n+\n1\n,\nbeta\n,\nm\n(\np\n,\nq\n),\n1\n)\nreturn\nend\nprogram\nmatrixmod\nimplicit none\ninteger\nM\n,\nN\nparameter\n(\nM\n=\n6\n,\nN\n=\n5\n)\nreal\n*\n4\na\n(\nM\n,\nN\n)\ninteger\ni\n,\nj\nexternal\ncublas_init\nexternal\ncublas_shutdown\ndo\nj\n=\n1\n,\nN\ndo\ni\n=\n1\n,\nM\na\n(\ni\n,\nj\n)\n=\n(\ni\n-\n1\n)\n*\nM\n+\nj\nenddo\nenddo\ncall\ncublas_init\ncall\nmodify\n(\na\n,\nM\n,\nN\n,\n2\n,\n3\n,\n1\n6.0\n,\n1\n2.0\n)\ncall\ncublas_shutdown\ndo\nj\n=\n1\n,\nN\ndo\ni\n=\n1\n,\nM\nwrite\n(\n*\n,\n\"(F7.0$)\"\n)\na\n(\ni\n,\nj\n)\nenddo\nwrite\n(\n*\n,\n*\n)\n\"\"\nenddo\nstop\nend\nWhen traditional fixed-form Fortran 77 code is ported to use the cuBLAS library, line length often increases when the BLAS calls are exchanged for cuBLAS calls. Longer function names and possible macro expansion are contributing factors. Inadvertently exceeding the maximum line length can lead to run-time errors that are difficult to find, so care should be taken not to exceed the 72-column limit if fixed form is retained.\nThe examples in this chapter show a small application implemented in Fortran 77 on the host and the same application with the non-thunking wrappers after it has been ported to use the cuBLAS library.\nThe second example should be compiled with ARCH_64 defined as 1 on 64-bit OS system and as 0 on 32-bit OS system. For example for g95 or gfortran, this can be done directly on the command line by using the option\n-cpp\n-DARCH_64=1\n.\n! Example B.2. Same Application Using Non-thunking cuBLAS Calls\n!-------------------------------------------------------------\n#define IDX2F(i,j,ld) ((((j)-1)*(ld))+((i)-1))\nsubroutine\nmodify\n(\ndevPtrM\n,\nldm\n,\nn\n,\np\n,\nq\n,\nalpha\n,\nbeta\n)\nimplicit none\ninteger\nsizeof_real\nparameter\n(\nsizeof_real\n=\n4\n)\ninteger\nldm\n,\nn\n,\np\n,\nq\n#if ARCH_64\ninteger\n*\n8\ndevPtrM\n#else\ninteger\n*\n4\ndevPtrM\n#endif\nreal\n*\n4\nalpha\n,\nbeta\ncall\ncublas_sscal\n(\nn\n-\np\n+\n1\n,\nalpha\n,\n1\ndevPtrM\n+\nIDX2F\n(\np\n,\nq\n,\nldm\n)\n*\nsizeof_real\n,\n2\nldm\n)\ncall\ncublas_sscal\n(\nldm\n-\np\n+\n1\n,\nbeta\n,\n1\ndevPtrM\n+\nIDX2F\n(\np\n,\nq\n,\nldm\n)\n*\nsizeof_real\n,\n2\n1\n)\nreturn\nend\nprogram\nmatrixmod\nimplicit none\ninteger\nM\n,\nN\n,\nsizeof_real\n#if ARCH_64\ninteger\n*\n8\ndevPtrA\n#else\ninteger\n*\n4\ndevPtrA\n#endif\nparameter\n(\nM\n=\n6\n,\nN\n=\n5\n,\nsizeof_real\n=\n4\n)\nreal\n*\n4\na\n(\nM\n,\nN\n)\ninteger\ni\n,\nj\n,\nstat\nexternal\ncublas_init\n,\ncublas_set_matrix\n,\ncublas_get_matrix\nexternal\ncublas_shutdown\n,\ncublas_alloc\ninteger\ncublas_alloc\n,\ncublas_set_matrix\n,\ncublas_get_matrix\ndo\nj\n=\n1\n,\nN\ndo\ni\n=\n1\n,\nM\na\n(\ni\n,\nj\n)\n=\n(\ni\n-\n1\n)\n*\nM\n+\nj\nenddo\nenddo\ncall\ncublas_init\nstat\n=\ncublas_alloc\n(\nM\n*\nN\n,\nsizeof_real\n,\ndevPtrA\n)\nif\n(\nstat\n.\nNE\n.\n0\n)\nthen\nwrite\n(\n*\n,\n*\n)\n\"device memory allocation failed\"\ncall\ncublas_shutdown\nstop\nendif\nstat\n=\ncublas_set_matrix\n(\nM\n,\nN\n,\nsizeof_real\n,\na\n,\nM\n,\ndevPtrA\n,\nM\n)\nif\n(\nstat\n.\nNE\n.\n0\n)\nthen\ncall\ncublas_free\n(\ndevPtrA\n)\nwrite\n(\n*\n,\n*\n)\n\"data download failed\"\ncall\ncublas_shutdown\nstop\nendif\n—\n— Code block continues below. Space added for formatting purposes. —\n—\ncall\nmodify\n(\ndevPtrA\n,\nM\n,\nN\n,\n2\n,\n3\n,\n16.0\n,\n12.0\n)\nstat\n=\ncublas_get_matrix\n(\nM\n,\nN\n,\nsizeof_real\n,\ndevPtrA\n,\nM\n,\na\n,\nM\n)\nif\n(\nstat\n.\nNE\n.0\n)\nthen\ncall\ncublas_free\n(\ndevPtrA\n)\nwrite\n(\n*\n,\n*\n)\n\"data upload failed\"\ncall\ncublas_shutdown\nstop\nendif\ncall\ncublas_free\n(\ndevPtrA\n)\ncall\ncublas_shutdown\ndo\nj\n=\n1\n,\nN\ndo\ni\n=\n1\n,\nM\nwrite\n(\n*\n,\n\"(F7.0$)\"\n)\na\n(\ni\n,\nj\n)\nenddo\nwrite\n(\n*\n,\n*\n)\n\"\"\nenddo\nstop\nend\n8.\nInteraction with Other Libraries and Tools\n\nThis section describes important requirements and recommendations that ensure correct use of cuBLAS with other libraries and utilities.\n8.1.\nnvprune\n\nnvprune\nenables pruning relocatable host objects and static libraries to only contain device code for the specific target architectures. In case of cuBLAS, particular care must be taken if using\nnvprune\nwith compute capabilities, whose minor revision number is different than 0. To reduce binary size, cuBLAS may only store major revision equivalents of CUDA binary files for kernels reused between different minor revision versions. Therefore, to ensure that a pruned library does not fail for arbitrary problems, the user must keep binaries for a selected architecture and all prior minor architectures in its major architecture.\nFor example, the following call prunes\nlibcublas_static.a\nto contain only sm_75 (Turing) and sm_70 (Volta) cubins:\nnvprune\n--\ngenerate\n-\ncode\ncode\n=\nsm_70\n--\ngenerate\n-\ncode\ncode\n=\nsm_75\nlibcublasLt_static\n.\na\n-\no\nlibcublasLt_static_sm70_sm75\n.\na\nwhich should be used instead of:\nnvprune\n-\narch\n=\nsm_75\nlibcublasLt_static\n.\na\n-\no\nlibcublasLt_static_sm75\n.\na\n9.\nAcknowledgements\n\nNVIDIA would like to thank the following individuals and institutions for their contributions:\nPortions of the SGEMM, DGEMM, CGEMM and ZGEMM library routines were written by Vasily Volkov of the University of California.\nPortions of the SGEMM, DGEMM and ZGEMM library routines were written by Davide Barbieri of the University of Rome Tor Vergata.\nPortions of the DGEMM and SGEMM library routines optimized for Fermi architecture were developed by the University of Tennessee. Subsequently, several other routines that are optimized for the Fermi architecture have been derived from these initial DGEMM and SGEMM implementations.\nThe substantial optimizations of the STRSV, DTRSV, CTRSV and ZTRSV library routines were developed by Jonathan Hogg of The Science and Technology Facilities Council (STFC). Subsequently, some optimizations of the STRSM, DTRSM, CTRSM and ZTRSM have been derived from these TRSV implementations.\nSubstantial optimizations of the SYMV and HEMV library routines were developed by Ahmad Abdelfattah, David Keyes and Hatem Ltaief of King Abdullah University of Science and Technology (KAUST).\nSubstantial optimizations of the TRMM and TRSM library routines were developed by Ali Charara, David Keyes and Hatem Ltaief of King Abdullah University of Science and Technology (KAUST).\nThis product includes {fmt} - A modern formatting library\nhttps://fmt.dev\nCopyright (c) 2012 - present, Victor Zverovich.\nThis product includes spdlog - Fast C++ logging library.\nhttps://github.com/gabime/spdlog\nThe MIT License (MIT).\nThis product includes SIMD Library for Evaluating Elementary Functions, vectorized libm and DFT\nhttps://sleef.org\nBoost Software License - Version 1.0 - August 17th, 2003.\nThis product includes Frozen - a header-only, constexpr alternative to gperf for C++14 users.\nhttps://github.com/serge-sans-paille/frozen\nApache License - Version 2.0, January 2004.\nThis product includes Boost C++ Libraries - free peer-reviewed portable C++ source libraries\nhttps://www.boost.org/\nBoost Software License - Version 1.0 - August 17th, 2003.\nThis product includes Zstandard - a fast lossless compression algorithm, targeting real-time compression scenarios at zlib-level and better compression ratios.\nhttps://github.com/facebook/zstd\nThe BSD License.\n10.\nNotices\n\n10.1.\nNotice\n\nThis document is provided for information purposes only and shall not be regarded as a warranty of a certain functionality, condition, or quality of a product. NVIDIA Corporation (“NVIDIA”) makes no representations or warranties, expressed or implied, as to the accuracy or completeness of the information contained in this document and assumes no responsibility for any errors contained herein. NVIDIA shall have no liability for the consequences or use of such information or for any infringement of patents or other rights of third parties that may result from its use. This document is not a commitment to develop, release, or deliver any Material (defined below), code, or functionality.\nNVIDIA reserves the right to make corrections, modifications, enhancements, improvements, and any other changes to this document, at any time without notice.\nCustomer should obtain the latest relevant information before placing orders and should verify that such information is current and complete.\nNVIDIA products are sold subject to the NVIDIA standard terms and conditions of sale supplied at the time of order acknowledgement, unless otherwise agreed in an individual sales agreement signed by authorized representatives of NVIDIA and customer (“Terms of Sale”). NVIDIA hereby expressly objects to applying any customer general terms and conditions with regards to the purchase of the NVIDIA product referenced in this document. No contractual obligations are formed either directly or indirectly by this document.\nNVIDIA products are not designed, authorized, or warranted to be suitable for use in medical, military, aircraft, space, or life support equipment, nor in applications where failure or malfunction of the NVIDIA product can reasonably be expected to result in personal injury, death, or property or environmental damage. NVIDIA accepts no liability for inclusion and/or use of NVIDIA products in such equipment or applications and therefore such inclusion and/or use is at customer’s own risk.\nNVIDIA makes no representation or warranty that products based on this document will be suitable for any specified use. Testing of all parameters of each product is not necessarily performed by NVIDIA. It is customer’s sole responsibility to evaluate and determine the applicability of any information contained in this document, ensure the product is suitable and fit for the application planned by customer, and perform the necessary testing for the application in order to avoid a default of the application or the product. Weaknesses in customer’s product designs may affect the quality and reliability of the NVIDIA product and may result in additional or different conditions and/or requirements beyond those contained in this document. NVIDIA accepts no liability related to any default, damage, costs, or problem which may be based on or attributable to: (i) the use of the NVIDIA product in any manner that is contrary to this document or (ii) customer product designs.\nNo license, either expressed or implied, is granted under any NVIDIA patent right, copyright, or other NVIDIA intellectual property right under this document. Information published by NVIDIA regarding third-party products or services does not constitute a license from NVIDIA to use such products or services or a warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual property rights of the third party, or a license from NVIDIA under the patents or other intellectual property rights of NVIDIA.\nReproduction of information in this document is permissible only if approved in advance by NVIDIA in writing, reproduced without alteration and in full compliance with all applicable export laws and regulations, and accompanied by all associated conditions, limitations, and notices.\nTHIS DOCUMENT AND ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, “MATERIALS”) ARE BEING PROVIDED “AS IS.” NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL NVIDIA BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Notwithstanding any damages that customer might incur for any reason whatsoever, NVIDIA’s aggregate and cumulative liability towards customer for the products described herein shall be limited in accordance with the Terms of Sale for the product.\n10.2.\nOpenCL\n\nOpenCL is a trademark of Apple Inc. used under license to the Khronos Group Inc.\n10.3.\nTrademarks\n\nNVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated.", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://docs.nvidia.com/cuda/cublas/index.html"}}
{"text": "1. Introduction — cuFFT 13.0 documentation\n»\n1.\nIntroduction\nv13.0 |\nPDF\n|\nArchive\ncuFFT API Reference\nThe API reference guide for cuFFT, the CUDA Fast Fourier Transform library.\n1.\nIntroduction\n\ncuFFT Release Notes\n:\nCUDA Toolkit Release Notes\ncuFFT GitHub Samples\n:\nCUDA Library Samples\nNVIDIA Developer Forum\n:\nGPU-Accelerated Libraries\nProvide Feedback\n:\nMath-Libs-Feedback\n@\nnvidia\n.\ncom\nRelated FFT Libraries\n:\ncuFFTMp\ncuFFTDx\ncuFFTDx + cuFFT LTO EA\nNVPL FFT\nnvmath python\nRelevant cuFFT Blog Posts and GTC presentations\n:\nAccelerating GPU Applications with NVIDIA Math Libraries\nMultinode Multi-GPU: Using NVIDIA cuFFTMp FFTs at Scale\nNew Asynchronous Programming Model Library Now Available with NVIDIA HPC SDK v22.11\nJust-In-Time Link-Time Optimization Adoption in cuSPARSE/cuFFT: Use Case Overview\nThis document describes cuFFT, the NVIDIA® CUDA® Fast Fourier Transform (FFT) product. It consists of two separate libraries: cuFFT and cuFFTW. The cuFFT library is designed to provide high performance on NVIDIA GPUs. The cuFFTW library is provided as a porting tool to enable users of FFTW to start using NVIDIA GPUs with a minimum amount of effort.\nThe FFT is a divide-and-conquer algorithm for efficiently computing discrete Fourier transforms of complex or real-valued data sets. It is one of the most important and widely used numerical algorithms in computational physics and general signal processing. The cuFFT library provides a simple interface for computing FFTs on an NVIDIA GPU, which allows users to quickly leverage the floating-point power and parallelism of the GPU in a highly optimized and tested FFT library.\nThe cuFFT product supports a wide range of FFT inputs and options efficiently on NVIDIA GPUs. This version of the cuFFT library supports the following features:\nAlgorithms highly optimized for input sizes that can be written in the form\n\\(2^{a} \\times 3^{b} \\times 5^{c} \\times 7^{d}\\)\n. In general the smaller the prime factor, the better the performance, i.e., powers of two are fastest.\nAn\n\\(O\\left( n\\log n \\right)\\)\nalgorithm for every input data size\nHalf-precision (16-bit floating point), single-precision (32-bit floating point) and double-precision (64-bit floating point). Transforms of lower precision have higher performance.\nComplex and real-valued input and output. Real valued input or output require less computations and data than complex values and often have faster time to solution. Types supported are:\nC2C - Complex input to complex output\nR2C - Real input to complex output\nC2R - Symmetric complex input to real output\n1D, 2D and 3D transforms\nExecution of multiple 1D, 2D and 3D transforms simultaneously. These batched transforms have higher performance than single transforms.\nIn-place and out-of-place transforms\nArbitrary intra- and inter-dimension element strides (strided layout)\nFFTW compatible data layout\nExecution of transforms across multiple GPUs\nStreamed execution, enabling asynchronous computation and data movement\nThe cuFFTW library provides the FFTW3 API to facilitate porting of existing FFTW applications.\nPlease note that starting from CUDA 13.0, the minimum supported GPU architecture is SM75. See\nDeprecated Functionality\n.\n2.\nUsing the cuFFT API\n\nThis chapter provides a general overview of the cuFFT library API. For more complete information on specific functions, see\ncuFFT API Reference\n. Users are encouraged to read this chapter before continuing with more detailed descriptions.\nThe Discrete Fourier transform (DFT) maps a complex-valued vector\n\\(x_{k}\\)\n(\ntime domain\n) into its\nfrequency domain representation\ngiven by:\n\\(X_{k} = \\sum\\limits_{n = 0}^{N - 1}x_{n}e^{-2\\pi i\\frac{kn}{N}}\\)\nwhere\n\\(X_{k}\\)\nis a complex-valued vector of the same size. This is known as a\nforward\nDFT. If the sign on the exponent of e is changed to be positive, the transform is an\ninverse\ntransform. Depending on\n\\(N\\)\n, different algorithms are deployed for the best performance.\nThe cuFFT API is modeled after\nFFTW\n, which is one of the most popular and efficient CPU-based FFT libraries. cuFFT provides a simple configuration mechanism called a\nplan\nthat uses internal building blocks to optimize the transform for the given configuration and the particular GPU hardware selected. Then, when the\nexecution\nfunction is called, the actual transform takes place following the plan of execution. The advantage of this approach is that once the user creates a plan, the library retains whatever state is needed to execute the plan multiple times without recalculation of the configuration. This model works well for cuFFT because different kinds of FFTs require different thread configurations and GPU resources, and the plan interface provides a simple way of reusing configurations.\nComputing a number\nBATCH\nof one-dimensional DFTs of size\nNX\nusing cuFFT will typically look like this:\n#define NX 256\n#define BATCH 10\n#define RANK 1\n...\n{\ncufftHandle\nplan\n;\ncufftComplex\n*\ndata\n;\n...\ncudaMalloc\n((\nvoid\n**\n)\n&\ndata\n,\nsizeof\n(\ncufftComplex\n)\n*\nNX\n*\nBATCH\n);\ncufftPlanMany\n(\n&\nplan\n,\nRANK\n,\nNX\n,\n&\niembed\n,\nistride\n,\nidist\n,\n&\noembed\n,\nostride\n,\nodist\n,\nCUFFT_C2C\n,\nBATCH\n);\n...\ncufftExecC2C\n(\nplan\n,\ndata\n,\ndata\n,\nCUFFT_FORWARD\n);\ncudaDeviceSynchronize\n();\n...\ncufftDestroy\n(\nplan\n);\ncudaFree\n(\ndata\n);\n}\n2.1.\nAccessing cuFFT\n\nThe cuFFT and cuFFTW libraries are available as shared libraries. They consist of compiled programs ready for users to incorporate into applications with the compiler and linker. cuFFT can be downloaded from\nhttps://developer.nvidia.com/cufft\n. By selecting\nDownload CUDA Production Release\nusers are all able to install the package containing the CUDA Toolkit, SDK code samples and development drivers. The CUDA Toolkit contains cuFFT and the samples include\nsimplecuFFT\n.\nThe Linux release for\nsimplecuFFT\nassumes that the root install directory is\n/usr/local/cuda\nand that the locations of the products are contained there as follows. Modify the Makefile as appropriate for your system.\nProduct\nLocation and name\nInclude file\nnvcc\ncompiler\n/bin/nvcc\ncuFFT\nlibrary\n{lib,\nlib64}/libcufft.so\ninc/cufft.h\ncuFFT\nlibrary with Xt functionality\n{lib,\nlib64}/libcufft.so\ninc/cufftXt.h\ncuFFTW\nlibrary\n{lib,\nlib64}/libcufftw.so\ninc/cufftw.h\nThe most common case is for developers to modify an existing CUDA routine (for example,\nfilename.cu\n) to call cuFFT routines. In this case the include file\ncufft.h\nor\ncufftXt.h\nshould be inserted into\nfilename.cu\nfile and the library included in the link line. A single compile and link line might appear as\n/usr/local/cuda/bin/nvcc\n[options]\nfilename.cu\n…\n-I/usr/local/cuda/inc\n-L/usr/local/cuda/lib\n-lcufft\nOf course there will typically be many compile lines and the compiler\ng++\nmay be used for linking so long as the library path is set correctly.\nUsers of the FFTW interface (see\nFFTW Interface to cuFFT\n) should include\ncufftw.h\nand link with both cuFFT and cuFFTW libraries.\nFunctions in the cuFFT and cuFFTW library assume that the data is in GPU visible memory. This means any memory allocated by\ncudaMalloc\n,\ncudaMallocHost\nand\ncudaMallocManaged\nor registered with\ncudaHostRegister\ncan be used as input, output or plan work area with cuFFT and cuFFTW functions. For the best performance input data, output data and plan work area should reside in device memory.\ncuFFTW library also supports input data and output data that is not GPU visible.\n2.2.\nFourier Transform Setup\n\nThe first step in using the cuFFT Library is to create a plan using one of the following:\ncufftPlan1D()\n/\ncufftPlan2D()\n/\ncufftPlan3D()\n- Create a simple plan for a 1D/2D/3D transform respectively.\ncufftPlanMany()\n- Creates a plan supporting batched input and strided data layouts.\ncufftXtMakePlanMany()\n- Creates a plan supporting batched input and strided data layouts for any supported precision.\nAmong the plan creation functions,\ncufftPlanMany()\nallows use of more complicated data layouts and batched executions. Execution of a transform of a particular size and type may take several stages of processing. When a plan for the transform is generated, cuFFT derives the internal steps that need to be taken. These steps may include multiple kernel launches, memory copies, and so on. In addition, all the intermediate buffer allocations (on CPU/GPU memory) take place during planning. These buffers are released when the plan is destroyed. In the worst case, the cuFFT Library allocates space for\n8*batch*n[0]*..*n[rank-1]\ncufftComplex\nor\ncufftDoubleComplex\nelements (where\nbatch\ndenotes the number of transforms that will be executed in parallel,\nrank\nis the number of dimensions of the input data (see\nMultidimensional Transforms\n) and\nn[]\nis the array of transform dimensions) for single and double-precision transforms respectively. Depending on the configuration of the plan, less memory may be used. In some specific cases, the temporary space allocations can be as low as\n1*batch*n[0]*..*n[rank-1]\ncufftComplex\nor\ncufftDoubleComplex\nelements. This temporary space is allocated separately for each individual plan when it is created (i.e., temporary space is not shared between the plans).\nThe next step in using the library is to call an execution function such as\ncufftExecC2C()\n(see\nParameter cufftType\n) which will perform the transform with the specifications defined at planning.\nOne can create a cuFFT plan and perform multiple transforms on different data sets by providing different input and output pointers. Once the plan is no longer needed, the\ncufftDestroy()\nfunction should be called to release the resources allocated for the plan.\n2.2.1.\nFree Memory Requirement\n\nThe first program call to any cuFFT function causes the initialization of the cuFFT kernels. This can fail if there is not enough free memory on the GPU. It is advisable to initialize cufft first (e.g. by creating a plan) and then allocating memory.\n2.2.2.\nPlan Initialization Time\n\nDuring plan initialization, cuFFT conducts a series of steps, including heuristics to determine which kernels to be used as well as kernel module loads. Starting from CUDA 12.0, cuFFT delivers a larger portion of kernels using the CUDA Parallel Thread eXecution assembly form (PTX code), instead of the binary form (cubin object). The PTX code of cuFFT kernels are loaded and compiled further to the binary code by the CUDA device driver at runtime when a cuFFT plan is initialized. This is called\njust-in-time (JIT) compilation\n.\nJIT compilation slightly increases cuFFT plan initialization time, depending on the transform size and the speed of the host CPU (see\nModule load driver API\n) . But the JIT overhead occurs only when a binary code is generated for the first time during plan initialization using one of the\nplan creation functions\n. The device driver automatically caches a copy of the generated binary code to avoid repeating the compilation in subsequent invocations. If necessary,\nCUDA_CACHE_PATH\nor\nCUDA_CACHE_MAXSIZE\ncan be customized to set the cache folder and max size (see detail in\nCUDA Environmental Variables\n), but the default settings are fine in general.\n2.3.\nFourier Transform Types\n\nApart from the general complex-to-complex (C2C) transform, cuFFT implements efficiently two other types: real-to-complex (R2C) and complex-to-real (C2R). In many practical applications the input vector is real-valued. It can be easily shown that in this case the output satisfies Hermitian symmetry (\n\\(X_{k} = X_{N - k}^{\\ast}\\)\n, where the star denotes complex conjugation). The converse is also true: for complex-Hermitian input the inverse transform will be purely real-valued. cuFFT takes advantage of this redundancy and works only on the first half of the Hermitian vector.\nTransform execution functions for single and double-precision are defined separately as:\ncufftExecC2C()\n/\ncufftExecZ2Z()\n- complex-to-complex transforms for single/double precision.\ncufftExecR2C()\n/\ncufftExecD2Z()\n- real-to-complex forward transform for single/double precision.\ncufftExecC2R()\n/\ncufftExecZ2D()\n- complex-to-real inverse transform for single/double precision.\nEach of those functions demands different input data layout (see\nData Layout\nfor details).\nNote\nComplex-to-real (C2R) transforms accept complex-Hermitian input. For one-dimensional signals, this requires the 0th element (and the\n\\(\\frac{N}{2}\\)\nth input if N is even) to be real-valued, i.e. its imaginary part should be zero.\nFor d-dimension signals, this means\n\\(x_{(n_{1},n_{2},\\ldots,n_{d})} = x_{(N_{1} - n_{1},N_{2} - n_{2},\\ldots,N_{d} - n_{d})}^{\\ast}\\)\n.\nOtherwise, the behavior of the transform is undefined. Also see\nMultidimensional Transforms\n.\nFunctions\ncufftXtExec()\nand\ncufftXtExecDescriptor()\ncan perform transforms on any of the supported types.\n2.3.1.\nHalf-precision cuFFT Transforms\n\nHalf-precision transforms have the following limitations:\nMinimum GPU architecture is SM_75\nSizes are restricted to powers of two only\nStrides on the real part of real-to-complex and complex-to-real transforms are not supported\nMore than one GPU is not supported\nTransforms spanning more than 4 billion elements are not supported\nPlease refer to\ncufftXtMakePlanMany\nfunction for plan creation details.\nThe CUDA Toolkit provides the\ncuda_fp16.h\nheader with types and intrinsic functions for handling half-precision arithmetic.\n2.3.2.\nBfloat16-precision cuFFT Transforms\n\ncuFFT supports bfloat16 precision using the\nnv_bfloat16\ndata type. Please note that cuFFT utilizes a combination of single- and bfloat16-precision arithmetic operations when computing the FFT in bfloat16 precision. Bfloat16-precision transforms have similar limitations to half-precision transforms:\nMinimum GPU architecture is SM_80\nSizes are restricted to powers of two only\nStrides on the real part of real-to-complex and complex-to-real transforms are not supported\nMore than one GPU is not supported\nTransforms spanning more than 4 billion elements are not supported\nPlease refer to\ncufftXtMakePlanMany\nfunction for plan creation details.\nThe CUDA Toolkit provides the\ncuda_bf16.h\nheader with types and intrinsic functions for handling bfloat16-precision arithmetic.\n2.4.\nData Layout\n\nIn the cuFFT Library, data layout depends strictly on the configuration and the transform type. In the case of general complex-to-complex transform both the input and output data shall be a\ncufftComplex\n/\ncufftDoubleComplex\narray in single- and double-precision modes respectively. In C2R mode an input array\n\\((x_{1},x_{2},\\ldots,x_{\\lfloor\\frac{N}{2}\\rfloor + 1})\\)\nof only non-redundant complex elements is required. The output array\n\\((X_{1},X_{2},\\ldots,X_{N})\\)\nconsists of\ncufftReal\n/\ncufftDouble\nelements in this mode. Finally, R2C demands an input array\n\\((X_{1},X_{2},\\ldots,X_{N})\\)\nof real values and returns an array\n\\((x_{1},x_{2},\\ldots,x_{\\lfloor\\frac{N}{2}\\rfloor + 1})\\)\nof non-redundant complex elements.\nIn real-to-complex and complex-to-real transforms the size of input data and the size of output data differ. For out-of-place transforms a separate array of appropriate size is created. For in-place transforms the user should use\npadded\ndata layout. This layout is FFTW compatibile.\nIn the\npadded\nlayout output signals begin at the same memory addresses as the input data. Therefore input data for real-to-complex and output data for complex-to-real must be padded.\nExpected sizes of input/output data for 1-d transforms are summarized in the table below:\nFFT type\ninput data size\noutput data size\nC2C\n\\(x\\)\ncufftComplex\n\\(x\\)\ncufftComplex\nC2R\n\\(\\left\\lfloor \\frac{x}{2} \\right\\rfloor + 1\\)\ncufftComplex\n\\(x\\)\ncufftReal\nR2C*\n\\(x\\)\ncufftReal\n\\(\\left\\lfloor \\frac{x}{2} \\right\\rfloor + 1\\)\ncufftComplex\nThe real-to-complex transform is implicitly a forward transform. For an in-place real-to-complex transform where FFTW compatible output is desired, the input size must be padded to\n\\(\\left( {\\lfloor\\frac{N}{2}\\rfloor + 1} \\right)\\)\ncomplex elements. For out-of-place transforms, input and output sizes match the logical transform size\n\\(N\\)\nand the non-redundant size\n\\(\\lfloor\\frac{N}{2}\\rfloor + 1\\)\n, respectively.\nThe complex-to-real transform is implicitly inverse. For in-place complex-to-real FFTs where FFTW compatible output is selected (default padding mode), the input size is assumed to be\n\\(\\lfloor\\frac{N}{2}\\rfloor + 1\\)\ncufftComplex\nelements. Note that in-place complex-to-real FFTs may\noverwrite\narbitrary imaginary input point values when non-unit input and output strides are chosen. Out-of-place complex-to-real FFT will always\noverwrite\ninput buffer. For out-of-place transforms, input and output sizes match the logical transform non-redundant size\n\\(\\lfloor\\frac{N}{2}\\rfloor + 1\\)\nand size\n\\(N\\)\n, respectively.\n2.5.\nMultidimensional Transforms\n\nMultidimensional DFT map a\n\\(d\\)\n-dimensional array\n\\(x_{\\mathbf{n}}\\)\n, where\n\\(\\mathbf{n} = (n_{1},n_{2},\\ldots,n_{d})\\)\ninto its frequency domain array given by:\n\\(X_{\\mathbf{k}} = \\sum\\limits_{n = 0}^{N - 1}x_{\\mathbf{n}}e^{-2\\pi i\\frac{\\mathbf{k}\\mathbf{n}}{\\mathbf{N}}}\\)\nwhere\n\\(\\frac{\\mathbf{n}}{\\mathbf{N}} = (\\frac{n_{1}}{N_{1}},\\frac{n_{2}}{N_{2}},\\ldots,\\frac{n_{d}}{N_{d}})\\)\n, and the summation denotes the set of nested summations\n\\(\\sum\\limits_{n_{1} = 0}^{N_{1} - 1}\\sum\\limits_{n_{2} = 0}^{N_{2} - 1}\\ldots\\sum\\limits_{n_{d} = 0}^{N_{d} - 1}\\)\ncuFFT supports one-dimensional, two-dimensional and three-dimensional transforms, which can all be called by the same\ncufftExec*\nfunctions (see\nFourier Transform Types\n).\nSimilar to the one-dimensional case, the frequency domain representation of real-valued input data satisfies Hermitian symmetry, defined as:\n\\(x_{(n_{1},n_{2},\\ldots,n_{d})} = x_{(N_{1} - n_{1},N_{2} - n_{2},\\ldots,N_{d} - n_{d})}^{\\ast}\\)\n.\nC2R and R2C algorithms take advantage of this fact by operating only on half of the elements of signal array, namely on:\n\\(x_{\\mathbf{n}}\\)\nfor\n\\(\\mathbf{n} \\in \\{ 1,\\ldots,N_{1}\\} \\times \\ldots \\times \\{ 1,\\ldots,N_{d - 1}\\} \\times \\{ 1,\\ldots,\\lfloor\\frac{N_{d}}{2}\\rfloor + 1\\}\\)\n.\nThe general rules of data alignment described in\nData Layout\napply to higher-dimensional transforms. The following table summarizes input and output data sizes for multidimensional DFTs:\nDims\nFFT type\nInput data size\nOutput data size\n1D\nC2C\n\\(\\mathbf{N}_{1}\\)\ncufftComplex\n\\(\\mathbf{N}_{1}\\)\ncufftComplex\n1D\nC2R\n\\(\\lfloor\\frac{\\mathbf{N}_{1}}{2}\\rfloor + 1\\)\ncufftComplex\n\\(\\mathbf{N}_{1}\\)\ncufftReal\n1D\nR2C\n\\(\\mathbf{N}_{1}\\)\ncufftReal\n\\(\\lfloor\\frac{\\mathbf{N}_{1}}{2}\\rfloor + 1\\)\ncufftComplex\n2D\nC2C\n\\(\\mathbf{N}_{1}\\mathbf{N}_{2}\\)\ncufftComplex\n\\(\\mathbf{N}_{1}\\mathbf{N}_{2}\\)\ncufftComplex\n2D\nC2R\n\\(\\mathbf{N}_{1}(\\lfloor\\frac{\\mathbf{N}_{2}}{2}\\rfloor + 1)\\)\ncufftComplex\n\\(\\mathbf{N}_{1}\\mathbf{N}_{2}\\)\ncufftReal\n2D\nR2C\n\\(\\mathbf{N}_{1}\\mathbf{N}_{2}\\)\ncufftReal\n\\(\\mathbf{N}_{1}(\\lfloor\\frac{\\mathbf{N}_{2}}{2}\\rfloor + 1)\\)\ncufftComplex\n3D\nC2C\n\\(\\mathbf{N}_{1}\\mathbf{N}_{2}\\mathbf{N}_{3}\\)\ncufftComplex\n\\(\\mathbf{N}_{1}\\mathbf{N}_{2}\\mathbf{N}_{3}\\)\ncufftComplex\n3D\nC2R\n\\(\\mathbf{N}_{1}\\mathbf{N}_{2}(\\lfloor\\frac{\\mathbf{N}_{3}}{2}\\rfloor + 1)\\)\ncufftComplex\n\\(\\mathbf{N}_{1}\\mathbf{N}_{2}\\mathbf{N}_{3}\\)\ncufftReal\n3D\nR2C\n\\(\\mathbf{N}_{1}\\mathbf{N}_{2}\\mathbf{N}_{3}\\)\ncufftReal\n\\(\\mathbf{N}_{1}\\mathbf{N}_{2}(\\lfloor\\frac{\\mathbf{N}_{3}}{2}\\rfloor + 1)\\)\ncufftComplex\nFor example, static declaration of a three-dimensional array for the output of an out-of-place real-to-complex transform will look like this:\ncufftComplex\nodata\n[\nN1\n][\nN2\n][\nN3\n/\n2\n+\n1\n];\n2.6.\nAdvanced Data Layout\n\nThe advanced data layout feature allows transforming only a subset of an input array, or outputting to only a portion of a larger data structure. It can be set by calling function:\ncufftResult\ncufftPlanMany\n(\ncufftHandle\n*\nplan\n,\nint\nrank\n,\nint\n*\nn\n,\nint\n*\ninembed\n,\nint\nistride\n,\nint\nidist\n,\nint\n*\nonembed\n,\nint\nostride\n,\nint\nodist\n,\ncufftType\ntype\n,\nint\nbatch\n);\nPassing\ninembed\nor\nonembed\nset to\nNULL\nis a special case and is equivalent to passing\nn\nfor each. This is same as the basic data layout and other advanced parameters such as\nistride\nare ignored.\nIf the advanced parameters are to be used, then all of the advanced interface parameters must be specified correctly. Advanced parameters are defined in units of the relevant data type (\ncufftReal\n,\ncufftDoubleReal\n,\ncufftComplex\n, or\ncufftDoubleComplex\n).\nAdvanced layout can be perceived as an additional layer of abstraction above the access to input/output data arrays. An element of coordinates\n[z][y][x]\nin signal number\nb\nin the batch will be associated with the following addresses in the memory:\n1D\ninput[\nb\n*\nidist\n+\nx\n*\nistride\n]\noutput[\nb\n*\nodist\n+\nx\n*\nostride\n]\n2D\ninput[\nb\n*\nidist`\n+\n(x\n*\ninembed[1]\n+\ny)\n*\nistride\n]\noutput[\nb\n*\nodist\n+\n(x\n*\nonembed[1]\n+\ny)\n*\nostride\n]\n3D\ninput[\nb\n*\nidist\n+\n((x\n*\ninembed[1]\n+\ny)\n*\ninembed[2]\n+\nz)\n*\nistride\n]\noutput[\nb\n*\nodist\n+\n((x\n*\nonembed[1]\n+\ny)\n*\nonembed[2]\n+\nz)\n*\nostride\n]\nThe\nistride\nand\nostride\nparameters denote the distance between two successive input and output elements in the least significant (that is, the innermost) dimension respectively. In a single 1D transform, if every input element is to be used in the transform,\nistride\nshould be set to\n\\(1\\)\n; if every other input element is to be used in the transform, then\nistride\nshould be set to\n\\(2\\)\n. Similarly, in a single 1D transform, if it is desired to output final elements one after another compactly,\nostride\nshould be set to\n\\(1\\)\n; if spacing is desired between the least significant dimension output data,\nostride\nshould be set to the distance between the elements.\nThe\ninembed\nand\nonembed\nparameters define the number of elements in each dimension in the input array and the output array respectively. The\ninembed[rank-1]\ncontains the number of elements in the least significant (innermost) dimension of the input data excluding the\nistride\nelements; the number of total elements in the least significant dimension of the input array is then\nistride*inembed[rank-1]\n. The\ninembed[0]\nor\nonembed[0]\ncorresponds to the most significant (that is, the outermost) dimension and is effectively ignored since the\nidist\nor\nodist\nparameter provides this information instead. Note that the size of each dimension of the transform should be less than or equal to the\ninembed\nand\nonembed\nvalues for the corresponding dimension, that is\nn[i]\n≤\ninembed[i]\n,\nn[i]\n≤\nonembed[i]\n, where\n\\(i \\in \\{ 0,\\ldots,rank - 1\\}\\)\n.\nThe\nidist\nand\nodist\nparameters indicate the distance between the first element of two consecutive batches in the input and output data.\n2.7.\nStreamed cuFFT Transforms\n\nEvery cuFFT plan may be associated with a CUDA stream. Once so associated, all launches of the internal stages of that plan take place through the specified stream. Streaming of cuFFT execution allows for potential overlap between transforms and memory copies. (See the\nNVIDIA CUDA Programming Guide\nfor more information on streams.) If no stream is associated with a plan, launches take place in\nstream(0)\n, the default CUDA stream. Note that many plan executions require multiple kernel launches.\ncuFFT uses private streams internally to sort operations, including event syncrhonization. cuFFT does not guarantee ordering of internal operations, and the order is only preserved with respect to the streams set by the user.\nAs of CUDA 11.2 (cuFFT 10.4.0),\ncufftSetStream()\nis supported in multiple GPU cases. However, calls to\ncufftXtMemcpy()\nare still synchronous across multiple GPUs when using streams. In previous versions of cuFFT,\ncufftSetStream()\nreturns an error in the multiple GPU case. Likewise, calling certain multi-GPU functions such as\ncufftXtSetCallback()\nafter setting a stream with\ncufftSetStream()\nwill result in an error (see API functions for more details).\nPlease note that in order to overlap plans using single plan handle user needs to manage work area buffers. Each concurrent plan execution needs it’s exclusive work area. Work area can be set by\ncufftSetWorkArea\nfunction.\n2.8.\nMultiple GPU cuFFT Transforms\n\ncuFFT supports using up to sixteen GPUs connected to a CPU to perform Fourier Transforms whose calculations are distributed across the GPUs. An API has been defined to allow users to write new code or modify existing code to use this functionality.\nSome existing functions such as the creation of a plan using\ncufftCreate()\nalso apply in the multiple GPU case. Multiple GPU routines contain\nXt\nin their name.\nThe memory on the GPUs is managed by helper functions\ncufftXtMalloc()/cufftXtFree()\nand\ncufftXtMemcpy()\nusing the\ncudaLibXtDesc\ndescriptor.\nPerformance is a function of the bandwidth between the GPUs, the computational ability of the individual GPUs, and the type and number of FFT to be performed. The highest performance is obtained using NVLink interconnect (\nhttps://www.nvidia.com/object/nvlink.html\n). The second best option is using PCI Express 3.0 between the GPUs and ensuring that both GPUs are on the same switch. Note that multiple GPU execution is not guaranteed to solve a given size problem in a shorter time than single GPU execution.\nThe multiple GPU extensions to cuFFT are built on the extensible cuFFT API. The general steps in defining and executing a transform with this API are:\ncufftCreate()\n- create an empty plan, as in the single GPU case\ncufftXtSetGPUs()\n- define which GPUs are to be used\nOptional:\ncufftEstimate{1d,2d,3d,Many}()\n- estimate the sizes of the work areas required. These are the same functions used in the single GPU case although the definition of the argument\nworkSize\nreflects the number of GPUs used.\ncufft{Xt}MakePlan{1d,2d,3d,Many}()\n- create the plan. These are the same functions used in the single GPU case although the definition of the argument\nworkSize\nreflects the number of GPUs used.\nOptional:\ncufftGetSize{1d,2d,3d,Many}()\n- refined estimate of the sizes of the work areas required. These are the same functions used in the single GPU case although the definition of the argument\nworkSize\nreflects the number of GPUs used.\nOptional:\ncufftGetSize()\n- check workspace size. This is the same function used in the single GPU case although the definition of the argument\nworkSize\nreflects the number of GPUs used.\nOptional:\ncufftXtSetWorkArea()\n- do your own workspace allocation.\ncufftXtMalloc()\n- allocate descriptor and data on the GPUs\ncufftXtMemcpy()\n- copy data to the GPUs\ncufftXtExecDescriptorC2C()/cufftXtExecDescriptorZ2Z()\n- execute the plan\ncufftXtMemcpy()\n- copy data from the GPUs\ncufftXtFree()\n- free any memory allocated with\ncufftXtMalloc()\ncufftDestroy()\n- free cuFFT plan resources\n2.8.1.\nPlan Specification and Work Areas\n\nIn the single GPU case a plan is created by a call to\ncufftCreate()\nfollowed by a call to\ncufftMakePlan*()\n. For multiple GPUs, the GPUs to use for execution are identified by a call to\ncufftXtSetGPUs()\nand this must occur after the call to\ncufftCreate()\nand prior to the call to\ncufftMakePlan*()\n.\nNote that when\ncufftMakePlan*()\nis called for a single GPU, the work area is on that GPU. In a multiple GPU plan, the returned work area has multiple entries; one value per GPU. That is\nworkSize\npoints to a\nsize_t\narray, one entry per GPU. Also the strides and batches apply to the entire plan across all GPUs associated with the plan.\nOnce a plan is locked by a call to\ncufftMakePlan*()\n, different descriptors may be specified in calls to\ncufftXtExecDescriptor*()\nto execute the plan on different data sets, but the new descriptors must use the same GPUs in the same order.\nAs in the single GPU case,\ncufftEstimateSize{Many,1d,2d,3d}()\nand\ncufftGetSize{Many,1d,2d,3d}()\ngive estimates of the work area sizes required for a multiple GPU plan and in this case\nworkSize\npoints to a\nsize_t\narray, one entry per GPU.\nSimilarly the actual work size returned by\ncufftGetSize()\nis a\nsize_t\narray, one entry per GPU in the multiple GPU case.\n2.8.2.\nHelper Functions\n\nMultiple GPU cuFFT execution functions assume a certain data layout in terms of what input data has been copied to which GPUs prior to execution, and what output data resides in which GPUs post execution. cuFFT provides functions to assist users in manipulating data on multiple GPUs. These must be called after the call to\ncufftMakePlan*()\n.\nOn a single GPU users may call\ncudaMalloc()\nand\ncudaFree()\nto allocate and free GPU memory. To provide similar functionality in the multiple GPU case, cuFFT includes\ncufftXtMalloc()\nand\ncufftXtFree()\nfunctions. The function\ncufftXtMalloc()\nreturns a descriptor which specifies the location of these memories.\nOn a single GPU users may call\ncudaMemcpy()\nto transfer data between host and GPU memory. To provide similar functionality in the multiple GPU case, cuFFT includes\ncufftXtMemcpy()\nwhich allows users to copy between host and multiple GPU memories or even between the GPU memories.\nAll single GPU cuFFT FFTs return output the data in natural order, that is the ordering of the result is the same as if a DFT had been performed on the data. Some Fast Fourier Transforms produce intermediate results where the data is left in a permutation of the natural output. When batch is one, data is left in the GPU memory in a permutation of the natural output.\nWhen\ncufftXtMemcpy()\nis used to copy data from GPU memory back to host memory, the results are in natural order regardless of whether the data on the GPUs is in natural order or permuted. Using\nCUFFT_COPY_DEVICE_TO_DEVICE\nallows users to copy data from the permuted data format produced after a single transform to the natural order on GPUs.\n2.8.3.\nMultiple GPU 2D and 3D Transforms on Permuted Input\n\nFor single 2D or 3D transforms on multiple GPUs, when\ncufftXtMemcpy()\ndistributes the data to the GPUs, the array is divided on the X axis. E.G. for two GPUs half of the X dimenson points, for all Y (and Z) values, are copied to each of the GPUs. When the transform is computed, the data are permuted such that they are divided on the Y axis. I.E. half of the Y dimension points, for all X (and Z) values are on each of the GPUs.\nWhen cuFFT creates a 2D or 3D plan for a single transform on multiple GPUs, it actually creates two plans. One plan expects input to be divided on the X axis. The other plan expects data to be divided on the Y axis. This is done because many algorithms compute a forward FFT, then perform some point-wise operation on the result, and then compute the inverse FFT. A memory copy to restore the data to the original order would be expensive. To avoid this,\ncufftXtMemcpy\nand\ncufftXtExecDescriptor()\nkeep track of the data ordering so that the correct operation is used.\nThe ability of cuFFT to process data in either order makes the following sequence possible.\ncufftCreate()\n- create an empty plan, as in the single GPU case\ncufftXtSetGPUs()\n- define which GPUs are to be used\ncufft{Xt}MakePlan{1d,2d,3d,Many}()\n- create the plan.\ncufftXtMalloc()\n- allocate descriptor and data on the GPUs\ncufftXtMemcpy()\n- copy data to the GPUs\ncufftXtExecDescriptorC2C()/cufftXtExecDescriptorZ2Z()\n- compute the forward FFT\nuserFunction()\n- modify the data in the frequency domain\ncufftXtExecDescriptorC2C()/cufftXtExecDescriptorZ2Z()\n- compute the inverse FFT\nNote that it was not necessary to copy/permute the data between execute calls\ncufftXtMemcpy()\n- copy data to the host\ncufftXtFree()\n- free any memory allocated with\ncufftXtMalloc()\ncufftDestroy()\n- free cuFFT plan resources\n2.8.4.\nSupported Functionality\n\nStarting with cuFFT version 7.0, a subset of single GPU functionality is supported for multiple GPU execution.\nRequirements and limitations:\nAll GPUs must have the same CUDA architecture level and support Unified Virtual Address Space.\nOn Windows, the GPU boards must be operating in Tesla Compute Cluster (TCC) mode.\nFor an application that uses the CUDA Driver API, running cuFFT on multiple GPUs is only compatible with applications using the primary context on each GPU.\nStrided input and output are not supported.\nRunning cuFFT on more than 8 GPUs (16 GPUs is max) is supported on machines with NVLink only.\nWhile transforms with batch count greater than one do not impose additional constraints, those with a single batch have some restrictions. Single-batch FFTs support only in-place mode, and have additional constraints depending on the FFT type. This behavior is summarized in the following table:\nbatch=1\n1D\n2D\n3D\nC2C\n/\nZ2Z\n2,4,8,16 GPUs\npower of 2 sizes only\nMinimum size for 2-4 GPUs is 64\nMinimum size for 8 GPUs is 128\nMinimum size for 16 GPUs is 1024\n2-16 GPUs\nOne of the following conditions is met for each dimension:\nDimension must factor into primes less than or equal to 127\nMaximum dimension size is 4096 for single precision\nMaximum dimension size is 2048 for double precision\nMinimum size is 32\nNo LTO callback support\nR2C\n/\nD2Z\nnot supported\n2-16 GPUs\nOne of the following conditions is met for each dimension:\nDimension must factor into primes less than or equal to 127\nMaximum dimension size is 4096 for single precision\nMaximum dimension size is 2048 for double precision\nMinimum size is 32\nFastest changing dimension size needs to be even\nSupports only\nCUFFT_XT_FORMAT_INPLACE\ninput descriptor format\nNo legacy callback / LTO callback support\nC2R\n/\nZ2D\nnot supported\n2-16 GPUs\nOne of the following conditions is met for each dimension:\nDimension must factor into primes less than or equal to 127\nMaximum dimension size is 4096 for single precision\nMaximum dimension size is 2048 for double precision\nMinimum size is 32\nFastest changing dimension size needs to be even\nSupports only\nCUFFT_XT_FORMAT_INPLACE_SHUFFLED\ninput descriptor format\nNo legacy callback / LTO callback support\nGeneral guidelines are:\nParameter\nwhichGPUs\nof\ncufftXtSetGPUs()\nfunction determines ordering of the GPUs with respect to data decomposition (first data chunk is placed on GPU denoted by first element of\nwhichGPUs\n)\nThe data for the entire transform must fit within the memory of the GPUs assigned to it.\nFor batch size\nm\non\nn\nGPUs :\nThe first\nm\n%\nn\nGPUs execute\n\\(\\left\\lfloor \\frac{m}{n} \\right\\rfloor+\\ 1\\)\ntransforms.\nThe remaining GPUs execute\n\\(\\left\\lfloor \\frac{m}{n} \\right\\rfloor\\)\ntransforms.\nBatch size output differences:\nSingle GPU cuFFT results are always returned in natural order. When multiple GPUs are used to perform more than one transform, the results are also returned in natural order. When multiple GPUs are used to perform a single transform the results are returned in a permutation of the normal results to reduce communication time. This behavior is summarized in the following table:\nNumber of GPUs\nNumber of transforms\nOutput Order on GPUs\nOne\nOne or multiple transforms\nNatural order\nMultiple\nOne\nPermuted results\nMultiple\nMultiple\nNatural order\nTo produce natural order results in GPU memory for multi-GPU runs in the 1D single transform case, requires calling\ncufftXtMemcpy()\nwith\nCUFFT_COPY_DEVICE_TO_DEVICE\n.\n2D and 3D multi-GPU transforms support execution of a transform given permuted order results as input. After execution in this case, the output will be in natural order. It is also possible to use\ncufftXtMemcpy()\nwith\nCUFFT_COPY_DEVICE_TO_DEVICE\nto return 2D or 3D data to natural order.\nSee the cuFFT Code Examples section for single GPU and multiple GPU examples.\n2.9.\ncuFFT Callback Routines\n\nCallback routines are user-supplied kernel routines that cuFFT will call when loading or storing data. They allow the user to do data pre- or post- processing without additional kernel calls.\nNote\nIn CUDA 12.6 Update 2, we introduced support for Link-Time Optimized (LTO) callbacks as a replacement for the deprecated (legacy) callbacks. See more in\nLTO Load and Store Callback Routines\n.\nStarting from CUDA 11.4, support for callback functionality using separately compiled device code (i.e. legacy callbacks) is deprecated on all GPU architectures. Callback functionality will continue to be supported for all GPU architectures.\n2.9.1.\nOverview of the cuFFT Callback Routine Feature\n\ncuFFT provides a set of APIs that allow the cuFFT user to provide CUDA functions that re-direct or manipulate the data as it is loaded prior to processing the FFT, or stored once the FFT has been done. For the load callback, cuFFT calls the callback routine the address of the input data and the offset to the value to be loaded from device memory, and the callback routine returns the value it wishes cuFFT to use instead. For the store callback, cuFFT calls the callback routine the value it has computed, along with the address of the output data and the offset to the value to be written to device memory, and the callback routine modifies the value and stores the modified result.\nIn order to provide a callback to cuFFT, a plan is created using the extensible plan APIs. After the call to\ncufftCreate\n, the user may associate a load callback routine, or a store callback routine, or both, with the plan, by:\nCalling\ncufftXtSetJITCallback\nbefore\ncufftMakePlan\n, for LTO callbacks\nCalling\ncufftXtSetCallback\nafter\ncufftMakePlan\n, for legacy callbacks\nThe caller also has the option to specify a device pointer to an opaque structure they wish to associate with the plan. This pointer will be passed to the callback routine by the cuFFT library. The caller may use this structure to remember plan dimensions and strides, or have a pointer to auxiliary data, etc.\nWith some restrictions, the callback routine is allowed to request shared memory for its own use. If the requested amount of shared memory is available, cufft will pass a pointer to it when it calls the callback routine.\nCUFFT allows for 8 types of callback routines, one for each possible combination of: load or store, real or complex, single precision or double:\nFor LTO callbacks, the user must provide an LTO routine that matches the function prototype for the type of routine specified. Otherwise, the planning function\ncufftMakePlan\nwill fail\n.\nFor legacy callbacks, it is the caller’s responsibility to provide a routine that matches the function prototype for the type of routine specified.\nIf there is already a callback of the specified type associated with the plan handle, the set callback functions will replace it with the new one.\nThe callback routine extensions to cuFFT are built on the extensible cuFFT API. The general steps in defining and executing a transform with callbacks are:\ncufftCreate()\n- create an empty plan, as in the single GPU case.\n(For\nLTO\ncallbacks)\ncufftXtSetJITCallback()\n- set a load and/or store LTO callback for this plan.\ncufft{Xt}MakePlan{1d,2d,3d,Many}()\n- create the plan. These are the same functions used in the single GPU case.\n(For\nlegacy\ncallbacks)\ncufftXtSetCallback()\n- set a load and/or store legacy callback for this plan.\ncufftExecC2C()\netc.\n- execute the plan.\ncufftDestroy()\n- free cuFFT plan resources.\nCallback functions are not supported on transforms with a dimension size that does not factor into primes smaller than 127. Callback functions on plans whose dimensions’ prime factors are limited to 2, 3, 5, and 7 can safely call\n__syncthreads()\n. On other plans, results are not defined.\nNote\nThe LTO callback API is available in the dynamic and static cuFFT libraries on 64 bit Windows and LINUX operating systems. The LTO callback API requires compatible nvJitLink and NVRTC libraries present in the dynamic library path. See more details in\nLTO Load and Store Callback Routines\n.\nThe legacy callback API is available only in the static cuFFT library on 64 bit LINUX operating systems.\n2.9.2.\nLTO Load and Store Callback Routines\n\nLTO callbacks in cuFFT for a given toolkit version require using the\nnvJitLink library\nfrom the same toolkit or greater, but within the same toolkit major.\nAdditionally, in order to specify custom names for the LTO callback routines, cuFFT requires using the\nNVRTC library\n. cuFFT uses NVRTC to compile a minimal wrapper around the user callback with custom symbol name. The custom symbol name provided to the cuFFT API must be a valid, null-terminated C-string containing the unmangled name; currently, keywords that alter the scope of the symbol name (such as\nnamespace\n) or the mangling (such as\nextern\n\"C\"\n) are not supported.\nThe NVRTC library used must be from a toolkit that is either the same version or older than the nvJitLink library, and both must be from the same toolkit major.\nFor example, in toolkit version 12.6 cuFFT requires nvJitLink to be from toolkit version 12.X, where\nX\n>=\n6\n, and NVRTC to be from toolkit version 12.Y, where\n0\n<=\nY\n<=\nX\n.\nBoth the nvJitLink and the NVRTC libraries are loaded dynamically, and should be present in the system’s dynamic linking path (e.g.\nLD_LIBRARY_PATH\non Unix systems, or\nPATH\non Windows systems).\nCode samples for LTO callbacks are available in the public\nCUDA Library Samples github repository\n.\n2.9.2.1.\nSpecifying LTO Load and Store Callback Routines\n\nUsage of LTO callbacks in cuFFT is divided in two parts:\nGenerating the LTO callback (i.e. compiling the callback routine to LTO-IR).\nAssociating the LTO callback with the cuFFT plan.\nTo generate\nthe LTO callback, users can compile the callback device function to LTO-IR using nvcc with any of the supported flags (such as\n-dlto\nor\n-gencode=arch=compute_XX,code=lto_XX\n, with\nXX\nindicating the target GPU architecture); alternatively, users can generate the LTO callback using NVRTC to do runtime compilation via the\n-dlto\nflag.\nNotice that PTX JIT is part of the JIT LTO kernel finalization trajectory, so architectures older than the current system architecture are supported; users can compile their callback function to LTO-IR for target arch\nXX\nand and execute plans which use the callback functions on GPUs with arch\nYY\n, where\nXX\n<=\nYY\n. Please see\nCompiler Support for Runtime LTO Using nvJitLink Library\nand\nJust-in-Time (JIT) Compilation\nfor more details.\nAs an example, if a user wants to specify a load callback for a R2C transform, they could write the following code\n__device__\ncufftReal\nmyOwnLTOCallback\n(\nvoid\n*\ndataIn\n,\nunsigned\nlong\nlong\noffset\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPtr\n)\n{\ncufftReal\nret\n;\n// use offset, dataIn, and optionally callerInfo to\n// compute the return value\nreturn\nret\n;\n}\nTo compile the callback to LTO-IR, the user could do\n# Compile the code to SM70 LTO-IR into a fatbin file\nnvcc\n-\ngencode\n=\narch\n=\ncompute_75\n,\ncode\n=\nlto_75\n-\ndc\n-\nfatbin\ncallback\n.\ncu\n-\no\ncallback\n.\nfatbin\n#Turn the fatbin data into a C array inside a header, for easy inclusion in host code\nbin2c\n--\nname\nmy_lto_callback_fatbin\n--\ntype\nlonglong\ncallback\n.\nfatbin\n>\ncallback_fatbin\n.\nh\nTo associate\nthe LTO callback with the cuFFT plan, users can leverage the new API call\ncufftXtSetJITCallback()\n, which works similarly to\ncufftXtSetCallback()\n, with a few caveats.\nFirst,\ncufftXtSetJITCallback()\nmust be called after plan creation with\ncufftCreate()\n, and before calling the plan initialization function with\ncufftMakePlan*()\nand similar routines.\nSecond, removing the LTO callback from the plan (using\ncufftXtClearCallback()\n) is currently not supported. A new plan must be created.\n#include\n<cufftXt.h>\n#include\n\"callback_fatbin.h\"\nint\nmain\n()\n{\ncufftResult\nstatus\n;\ncufftHandle\nfft_plan\n;\n...\nstatus\n=\ncufftCreate\n(\n&\nfft_plan\n);\n// NOTE: LTO callbacks must be set before plan creation and cannot be unset (yet)\nsize_t\nlto_callback_fatbin_size\n=\nsizeof\n(\nmy_lto_callback_fatbin\n);\nstatus\n=\ncufftXtSetJITCallback\n(\nfft_plan\n,\n\"myOwnLTOCallback\"\n,\n(\nvoid\n*\n)\nmy_lto_callback_fatbin\n,\nlto_callback_fatbin_size\n,\nCUFFT_CB_LD_REAL\n,\n(\nvoid\n**\n)\n&\ndevice_params\n));\nstatus\n=\ncufftMakePlan1d\n(\nfft_plan\n,\nsignal_size\n,\nCUFFT_C2R\n,\nbatches\n,\n&\nwork_size\n);\n...\n}\n2.9.2.2.\nLTO Callback Routine Function Details\n\nBelow are the function prototypes for the user-supplied LTO callback routines that cuFFT calls to load data prior to the transform.\ntypedef\ncufftComplex\n(\n*\ncufftJITCallbackLoadC\n)(\nvoid\n*\ndataIn\n,\nunsigned\nlong\nlong\noffset\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\ncufftDoubleComplex\n(\n*\ncufftJITCallbackLoadZ\n)(\nvoid\n*\ndataIn\n,\nunsigned\nlong\nlong\noffset\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\ncufftReal\n(\n*\ncufftJITCallbackLoadR\n)(\nvoid\n*\ndataIn\n,\nunsigned\nlong\nlong\noffset\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\ncufftDoubleReal\n(\n*\ncufftJITCallbackLoadD\n)(\nvoid\n*\ndataIn\n,\nunsigned\nlong\nlong\noffset\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\nParameters for all of the LTO load callbacks are defined as below:\noffset\n: offset of the input element from the start of the input data. This is not a byte offset, rather it is the number of elements from the start of the data input array that was passed in the\ncufftExec*\ncall.\ndataIn\n: device pointer to the start of the input array that was passed in the\ncufftExec*\ncall.\ncallerInfo\n: device pointer to the optional caller specified data passed in the\ncufftXtSetCallback\ncall.\nsharedPointer\n: pointer to shared memory, valid only if the user has called\ncufftXtSetCallbackSharedSize()\n.\nBelow are the function prototypes, and typedefs for pointers to the user supplied LTO callback routines that cuFFT calls to store data after completion of the transform. Note that the store callback functions do not return a value. This is because a store callback function is responsible not only for transforming the data as desired, but also for writing the data to the desired location. This allows the store callback to rearrange the data, for example to shift the zero frequency result to the center of the ouput.\ntypedef\nvoid\n(\n*\ncufftJITCallbackStoreC\n)(\nvoid\n*\ndataOut\n,\nunsigned\nlong\nlong\noffset\n,\ncufftComplex\nelement\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\nvoid\n(\n*\ncufftJITCallbackStoreZ\n)(\nvoid\n*\ndataOut\n,\nunsigned\nlong\nlong\noffset\n,\ncufftDoubleComplex\nelement\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\nvoid\n(\n*\ncufftJITCallbackStoreR\n)(\nvoid\n*\ndataOut\n,\nunsigned\nlong\nlong\noffset\n,\ncufftReal\nelement\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\nvoid\n(\n*\ncufftJITCallbackStoreD\n)(\nvoid\n*\ndataOut\n,\nunsigned\nlong\nlong\noffset\n,\ncufftDoubleReal\nelement\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\nParameters for all of the LTO store callbacks are defined as below:\noffset\n: offset of the input element from the start of the input data. This is not a byte offset, rather it is the number of elements from the start of the data input array that was passed in the\ncufftExec*\ncall.\ndataOut\n: device pointer to the start of the output array that was passed in the\ncufftExec*\ncall.\nelement\n: the real or complex result computed by CUFFT for the element specified by the offset argument.\ncallerInfo\n: device pointer to the optional caller specified data passed in the\ncufftXtSetCallback\ncall.\nsharedPointer\n: pointer to shared memory, valid only if the user has called\ncufftXtSetCallbackSharedSize()\n.\n2.9.3.\nLegacy Load and Store Callback Routines\n\n2.9.3.1.\nSpecifying Legacy Load and Store Callback Routines\n\nIn order to associate a legacy callback routine with a plan, it is necessary to obtain a device pointer to the callback routine.\nAs an example, if the user wants to specify a load callback for an R2C transform, they would write the device code for the callback function, and define a global device variable that contains a pointer to the function:\n__device__\ncufftReal\nmyOwnCallback\n(\nvoid\n*\ndataIn\n,\nsize_t\noffset\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPtr\n)\n{\ncufftReal\nret\n;\n// use offset, dataIn, and optionally callerInfo to\n// compute the return value\nreturn\nret\n;\n}\n__device__\ncufftCallbackLoadR\nmyOwnCallbackPtr\n=\nmyOwnCallback\n;\nFrom the host side, the user then has to get the address of the legacy callback routine, which is stored in\nmyOwnCallbackPtr\n. This is done with\ncudaMemcpyFromSymbol\n, as follows:\ncufftCallbackLoadR\nhostCopyOfCallbackPtr\n;\ncudaMemcpyFromSymbol\n(\n&\nhostCopyOfCallbackPtr\n,\nmyOwnCallbackPtr\n,\nsizeof\n(\nhostCopyOfCallbackPtr\n));\nhostCopyOfCallbackPtr\nthen contains the device address of the callback routine, that should be passed to\ncufftXtSetCallback\n. Note that, for multi-GPU transforms,\nhostCopyOfCallbackPtr\nwill need to be an array of pointers, and the\ncudaMemcpyFromSymbol\nwill have to be invoked for each GPU. Please note that\n__managed__\nvariables are not suitable to pass to\ncufftSetCallback\ndue to restrictions on variable usage (See the\nNVIDIA CUDA Programming Guide\nfor more information about\n__managed__\nvariables).\n2.9.3.2.\nLegacy Callback Routine Function Details\n\nBelow are the function prototypes, and typedefs for pointers to the user supplied legacy callback routines that cuFFT calls to load data prior to the transform.\ntypedef\ncufftComplex\n(\n*\ncufftCallbackLoadC\n)(\nvoid\n*\ndataIn\n,\nsize_t\noffset\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\ncufftDoubleComplex\n(\n*\ncufftCallbackLoadZ\n)(\nvoid\n*\ndataIn\n,\nsize_t\noffset\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\ncufftReal\n(\n*\ncufftCallbackLoadR\n)(\nvoid\n*\ndataIn\n,\nsize_t\noffset\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\ncufftDoubleReal\n(\n*\ncufftCallbackLoadD\n)(\nvoid\n*\ndataIn\n,\nsize_t\noffset\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\nParameters for all of the legacy load callbacks are defined as below:\noffset\n: offset of the input element from the start of the input data. This is not a byte offset, rather it is the number of elements from the start of the data input array that was passed in the\ncufftExec*\ncall.\ndataIn\n: device pointer to the start of the input array that was passed in the\ncufftExec*\ncall.\ncallerInfo\n: device pointer to the optional caller specified data passed in the\ncufftXtSetCallback\ncall.\nsharedPointer\n: pointer to shared memory, valid only if the user has called\ncufftXtSetCallbackSharedSize()\n.\nBelow are the function prototypes, and typedefs for pointers to the user supplied legacy callback routines that cuFFT calls to store data after completion of the transform. Note that the store callback functions do not return a value. This is because a store callback function is responsible not only for transforming the data as desired, but also for writing the data to the desired location. This allows the store callback to rearrange the data, for example to shift the zero frequency result to the center of the ouput.\ntypedef\nvoid\n(\n*\ncufftCallbackStoreC\n)(\nvoid\n*\ndataOut\n,\nsize_t\noffset\n,\ncufftComplex\nelement\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\nvoid\n(\n*\ncufftCallbackStoreZ\n)(\nvoid\n*\ndataOut\n,\nsize_t\noffset\n,\ncufftDoubleComplex\nelement\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\nvoid\n(\n*\ncufftCallbackStoreR\n)(\nvoid\n*\ndataOut\n,\nsize_t\noffset\n,\ncufftReal\nelement\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\nvoid\n(\n*\ncufftCallbackStoreD\n)(\nvoid\n*\ndataOut\n,\nsize_t\noffset\n,\ncufftDoubleReal\nelement\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\nParameters for all of the legacy store callbacks are defined as below:\noffset\n: offset of the input element from the start of the input data. This is not a byte offset, rather it is the number of elements from the start of the data input array that was passed in the\ncufftExec*\ncall.\ndataOut\n: device pointer to the start of the output array that was passed in the\ncufftExec*\ncall.\nelement\n: the real or complex result computed by CUFFT for the element specified by the offset argument.\ncallerInfo\n: device pointer to the optional caller specified data passed in the\ncufftXtSetCallback\ncall.\nsharedPointer\n: pointer to shared memory, valid only if the user has called\ncufftXtSetCallbackSharedSize()\n.\n2.9.4.\nCoding Considerations for the cuFFT Callback Routine Feature\n\ncuFFT supports callbacks on all types of transforms, dimension, batch, or stride between elements. Callbacks are supported for transforms of single and double precision.\ncuFFT supports a wide range of parameters, and based on those for a given plan, it attempts to optimize performance. The number of kernels launched, and for each of those, the number of blocks launched and the number of threads per block, will vary depending on how cuFFT decomposes the transform. For some configurations, cuFFT will load or store (and process) multiple inputs or outputs per thread. For some configurations, threads may load or store inputs or outputs in any order, and cuFFT does not guarantee that the inputs or outputs handled by a given thread will be contiguous. These characteristics may vary with transform size, transform type (e.g. C2C vs C2R), number of dimensions, and GPU architecture. These variations may also change from one library version to the next.\nWhen more than one kernel are used to implement a transform, the thread and block structure of the first kernel (the one that does the load) is often different from the thread and block structure of the last kernel (the one that does the store).\nOne common use of callbacks is to reduce the amount of data read or written to memory, either by selective filtering or via type conversions. When more than one kernel are used to implement a transform, cuFFT alternates using the workspace and the output buffer to write intermediate results. This means that the output buffer must always be large enough to accommodate the entire transform.\nFor transforms whose dimensions can be factored into powers of 2, 3, 5, or 7, cuFFT guarantees that it will call the load and store callback routines from points in the kernel where it is safe to call the\n__syncthreads\nfunction from within the callback routine. The caller is responsible for guaranteeing that the callback routine is at a point where the callback code has converged, to avoid deadlock. For plans whose dimensions are factored into higher primes, results of a callback routine calling\n__syncthreads\nare not defined.\nNote that there are no guarantees on the relative order of execution of blocks within a grid. As such, callbacks should not rely on any particular ordering within a kernel. For instance, reordering data (such as an FFT-shift) could rely on the order of execution of the blocks. Results in this case would be undefined.\n2.9.4.1.\nCoding Considerations for LTO Callback Routines\n\ncuFFT will call the LTO load callback routine, for each point in the input, once and only once for real-to-complex (\nR2C\n,\nD2Z\n) and complex-to-complex (\nC2C\n,\nZ2Z\n) transforms. Unlike with legacy callbacks,\nLTO load callbacks may be called more than once per element for complex-to-real\n(\nC2R\n,\nZ2D\n) transforms. The input value will not be updated twice (i.e. the transformed value will be stored in register and not memory, even for in-place transforms), but users should not rely on the amount of calls per element in their callback device functions.\nSimilarly to legacy callbacks, LTO store callbacks will be called once and only once for each point in the output. If the transform is being done in-place (i.e. the input and output data are in the same memory location) the store callback for a given element cannot overwrite other elements. It can either overwrite the given element, or write in a completely distinct output buffer.\ncuFFT does not support LTO callbacks for multi-GPU transforms (yet).\n2.9.4.2.\nCoding Considerations for Legacy Callback Routines\n\ncuFFT supports legacy callbacks on any number of GPUs.\ncuFFT will call the load callback routine, for each point in the input, once and only once. Similarly it will call the store callback routine, for each point in the output, once and only once. If the transform is being done in-place (i.e. the input and output data are in the same memory location) the store callback for a given element cannot overwrite other elements. It can either overwrite the given element, or write in a completely distinct output buffer.\nFor multi-GPU transforms, the index passed to the callback routine is the element index from the start of data\non that GPU\n, not from the start of the entire input or output data array.\n2.10.\nThread Safety\n\ncuFFT APIs are thread safe as long as different host threads execute FFTs using different plans and the output data are disjoint.\n2.11.\nCUDA Graphs Support\n\nUsing\nCUDA Graphs\nwith cuFFT is supported on single GPU plans. It is also supported on multiple GPU plans starting with cuFFT version 10.4.0. The stream associated with a cuFFT plan must meet the requirements stated in\nCreating a Graph Using Stream Capture\n.\nNote\nStarting from CUDA 11.8 (including CUDA 12.0 onward), CUDA Graphs are no longer supported for legacy callback routines that load data in out-of-place mode transforms. Starting from CUDA 12.6 Update 2, LTO callbacks can be used as a replacement for legacy callbacks without this limitation. cuFFT deprecated callback functionality based on separate compiled device code (legacy callbacks) in cuFFT 11.4.\n2.12.\nStatic Library and Callback Support\n\nStarting with release 6.5, the cuFFT libraries are also delivered in a static form as libcufft_static.a and libcufftw_static.a on Linux and Mac. Static libraries are not supported on Windows. The static cufft and cufftw libraries depend on thread abstraction layer library\nlibculibos.a\n.\nFor example, on linux, to compile a small application using cuFFT against the dynamic library, the following command can be used:\nnvcc mCufftApp.c  -lcufft  -o myCufftApp\nFor cufftw on Linux, to compile a small application against the dynamic library, the following command can be used:\nnvcc mCufftwApp.c  -lcufftw  -lcufft  -o myCufftwApp\nWhereas to compile against the static cuFFT library, extra steps need to be taken. The library needs to be device linked. It may happen during building and linking of a simple program, or as a separate step. The entire process is described in\nUsing Separarate Compilation in CUDA\n.\nFor cuFFT and cufftw in version 9.0 or later any supported architecture can be used to do the device linking:\nStatic cuFFT compilation command:\nnvcc mCufftApp.c  -lcufft_static   -lculibos -o myCufftApp\nStatic cufftw compilation command:\nnvcc mCufftwApp.c   -lcufftw_static  -lcufft_static   -lculibos  -o myCufftwApp\nPrior to version 9.0 proper linking required specifying a subset of supported architectures, as shown in the following commands:\nStatic cuFFT compilation command:\nnvcc mCufftApp.c  -lcufft_static   -lculibos -o myCufftApp\\\n-gencode arch=compute_75, \\\"code=sm_75\\\"\n-gencode arch=compute_80, \\\"code=sm_80\\\"\n-gencode arch=compute_90, \\\"code=sm_90\\\"\n-gencode arch=compute_100,\\\"code=sm_100\\\"\n-gencode arch=compute_120,\\\"code=sm_120\\\"\nStatic cufftw compilation command:\nnvcc mCufftwApp.c    -lcufftw_static  -lcufft_static   -lculibos  -o myCufftwApp\\\n-gencode arch=compute_75, \\\"code=sm_75\\\"\n-gencode arch=compute_80, \\\"code=sm_80\\\"\n-gencode arch=compute_90, \\\"code=sm_90\\\"\n-gencode arch=compute_100,\\\"code=sm_100\\\"\n-gencode arch=compute_120,\\\"code=sm_120\\\"\nPlease note that the cuFFT library might not contain legacy callback code for certain architectures as long as there is code for a lower architecture that is binary compatibile (e.g. SM80 and SM86). To determine if a specific SM is included in the cuFFT library for legacy callbacks, one may use\ncuobjdump\nutility. For example, if you wish to know if SM75 is included, the command to run is\ncuobjdump\n-arch\nsm_75\nlibcufft_static.a\n. Some legacy callback kernels are built only on select architectures (e.g. kernels with bfloat precision arithmetic are present only for SM80 and above). This can cause warnings at link time that architectures are missing from these kernels. These warnings can be safely ignored.\nIt is also possible to use the native Host C++ compiler and perform device link as a separate step. Please consult NVCC documentation for more details. Depending on the Host Operating system, some additional libraries like\npthread\nor\ndl\nmight be needed on the linking line.\nNote that in this case, the library\ncuda\nis not needed. The CUDA Runtime will try to open explicitly the\ncuda\nlibrary if needed. In the case of a system which does not have the CUDA driver installed, this allows the application to gracefully manage this issue and potentially run if a CPU-only path is available.\nThe cuFFT static library supports user supplied legacy callback routines. The legacy callback routines are CUDA device code, and must be separately compiled with NVCC and linked with the cuFFT library. Please refer to the NVCC documentation regarding separate compilation for details. If you specify an SM when compiling your callback functions, you must specify one of the SM’s cuFFT includes.\n2.13.\nAccuracy and Performance\n\nA DFT can be implemented as a matrix vector multiplication that requires\n\\(O(N^{2})\\)\noperations. However, the cuFFT Library employs the\nCooley-Tukey algorithm\nto reduce the number of required operations to optimize the performance of particular transform sizes. This algorithm expresses the DFT matrix as a product of sparse building block matrices. The cuFFT Library implements the following building blocks: radix-2, radix-3, radix-5, and radix-7. Hence the performance of any transform size that can be factored as\n\\(2^{a} \\times 3^{b} \\times 5^{c} \\times 7^{d}\\)\n(where\na\n,\nb\n,\nc\n, and\nd\nare non-negative integers) is optimized in the cuFFT library. There are also radix-m building blocks for other primes, m, whose value is < 128. When the length cannot be decomposed as multiples of powers of primes from 2 to 127,\nBluestein’s algorithm\nis used. Since the Bluestein implementation requires more computations per output point than the Cooley-Tukey implementation, the accuracy of the Cooley-Tukey algorithm is better. The pure Cooley-Tukey implementation has excellent accuracy, with the relative error growing proportionally to\n\\(\\log_{2}(N)\\)\n, where\n\\(N\\)\nis the transform size in points.\nFor sizes handled by the Cooley-Tukey code path, the most efficient implementation is obtained by applying the following constraints (listed in order from the most generic to the most specialized constraint, with each subsequent constraint providing the potential of an additional performance improvement).\nHalf precision transforms might not be suitable for all kinds of problems due to limited range represented by half precision floating point arithmetics. Please note that the first element of FFT result is the sum of all input elements and it is likely to overflow for certain inputs.\nResults produced by the cuFFT library are deterministic (ie, bitwise reproducible) as long as the following are kept constant between runs: plan input parameters, cuFFT version, and GPU model.\ncuFFT batched plans require that input data includes valid signal for all batches. Performance optimizations in batched mode can combine signal from different batches for processing. Optimizations used in cuFFT can vary from version to version.\nApplies to\nRecommendation\nComment\nAll\nUse single precision transforms.\nSingle precision transforms require less bandwidth per computation than double precision transforms.\nAll\nRestrict the size along all dimensions to be representable as\n\\(2^{a} \\times 3^{b} \\times 5^{c} \\times 7^{d}\\)\n.\nThe cuFFT library has highly optimized kernels for transforms whose dimensions have these prime factors. In general the best performance occurs when using powers of 2, followed by powers of 3, then 5, 7.\nAll\nRestrict the size along each dimension to use fewer distinct prime factors.\nA transform of size\n\\(2^{n}\\)\nor\n\\(3^{n}\\)\nwill usually be faster than one of size\n\\(2^{i} \\times 3^{j}\\)\neven if the latter is slightly smaller, due to the composition of specialized paths.\nAll\nRestrict the data to be contiguous in memory when performing a single transform. When performing multiple transforms make the individual datasets contiguous\nThe cuFFT library has been optimized for this data layout.\nAll\nPerform multiple (i.e., batched) transforms.\nAdditional optimizations are performed in batched mode.\nreal-to-complex transforms or complex-to-real transforms\nEnsure problem size of x dimension is a multiple of 4.\nThis scheme uses more efficient kernels to implement conjugate symmetry property.\nreal-to-complex transforms or complex-to-real transforms\nUse\nout-of-place\nmode.\nThis scheme uses more efficient kernels than\nin-place\nmode.\nMultiple GPU transforms\nUse PCI Express 3.0 between GPUs and ensure the GPUs are on the same switch.\nThe faster the interconnect between the GPUs, the faster the performance.\n2.14.\nCaller Allocated Work Area Support\n\ncuFFT plans may use additional memory to store intermediate results. The cuFFT library offers several functions to manage this temporary memory utilization behavior:\ncufftSetAutoAllocation\ncufftEstimate1d\n,\ncufftEstimate2d\n,\ncufftEstimate3d\nand\ncufftEstimateMany\ncufftGetSize\ncufftXtSetWorkAreaPolicy\nThe first two functions manage allocation and ownership of temporary memory. By default cuFFT always allocates its own work area in GPU memory. Each cuFFT handle allocates data separately. If multiple cuFFT plans are to be launched sequentially it is possible to assign the same memory chunk as work area to all those plans and reduce memory overhead.\nThe memory assigned as work area needs to be GPU visible. In addition to the regular memory acquired with\ncudaMalloc\n, usage of CUDA Unified Virtual Addressing enables cuFFT to use the following types of memory as work area memory: pinned host memory, managed memory, memory on GPU other than the one performing the calculations. While this provides flexibility, it comes with a performance penalty whose magnitude depends on the available memory bandwidth.\nThe\ncufftEstimateNd\n,\ncufftEstimateMany\n, and\ncufftGetSize\nfunctions provide information about the required memory size for cases where the user is allocating the work space buffer.\nIn version 9.2 cuFFT also introduced the\ncufftXtSetWorkAreaPolicy\nfunction. This function allows fine tuning of work area memory usage.\ncuFFT 9.2 version supports only the\nCUFFT_WORKAREA_MINIMAL\npolicy, which instructs cuFFT to re-plan the existing plan without the need to use work area memory.\nAlso as of cuFFT 9.2, supported FFT transforms that allow for\nCUFFT_WORKAREA_MINIMAL\npolicy are as follows:\nTransforms of type\nC2C\nare supported with sizes up to 4096 in any dimension.\nTransforms of type\nZ2Z\nare supported with sizes up to 2048 in any dimension.\nOnly single GPU transforms are supported.\nDepending on the FFT transform size, a different FFT algorithm may be used when the\nCUFFT_WORKAREA_MINIMAL\npolicy is set.\n2.15.\ncuFFT Link-Time Optimized Kernels\n\nStarting from CUDA 12.4, cuFFT ships Link-Time Optimized (LTO) kernels. These kernels are linked and finalized at runtime as part of the cuFFT planning routines. This enables the cuFFT library to generate kernels optimized for the underlying architecture and the specific problem to solve.\nThe current LTO kernel coverage includes:\nLTO callback kernels\n, which replace legacy callback kernels.\nKernels for 64-bit addressing (with FFTs spanning addresses greater than 2^(32)-1 elements).\nSome single- and double-precision R2C and C2R sizes.\nThe number and coverage of LTO kernels will grow with future releases of cuFFT. We encourage our users to test whether LTO kernels improve the performance for their use case.\nUsers can opt-in into LTO non-callback kernels by setting the\nNVFFT_PLAN_PROPERTY_INT64_PATIENT_JIT\nplan property using the\ncufftSetPlanProperty\nroutine. LTO callback kernels are enabled through the\ncufftXtSetJITCallback\nAPI.\nIn order to finalize LTO kernels, cuFFT relies on the nvJitLink library that ships as part of the CUDA Toolkit. Finalizing the kernels at runtime can cause an\nincrease in planning time\n(which could be in the order of hundreds of milliseconds, depending on the cuFFT plan and hardware characteristics of the host system), in exchange for faster execution time of the optimized kernels. Note that nvJitLink caches kernels linked at runtime to speed-up subsequent kernel finalizations in repeated planning routines.\nIf for any reason the runtime linking of the kernel fails, cuFFT will fall back to offline-compiled kernels to compute the FFT.\nNote\ncuFFT LTO kernels for a given toolkit version require using the nvJitLink library from the same toolkit or greater, but within the same toolkit major. For example, cuFFT in 12.4 requires nvJitLink to be from a CUDA Toolkit 12.X, with\nX\n>=\n4\n.\nThe nvJitLink library is loaded dynamically, and should be present in the system’s dynamic linking path (e.g.\nLD_LIBRARY_PATH\non Unix systems, or\nPATH\non Windows systems).\nNote\nCurrently the NVRTC library is optionally required for\nLTO callbacks\nwith custom function names, but will be required for any LTO kernel in a future cuFFT release.\n3.\ncuFFT API Reference\n\nThis chapter specifies the behavior of the cuFFT library functions by describing their input/output parameters, data types, and error codes. The cuFFT library is initialized upon the first invocation of an API function, and cuFFT shuts down automatically when all user-created FFT plans are destroyed.\n3.1.\nReturn value cufftResult\n\nAll cuFFT Library return values except for\nCUFFT_SUCCESS\nindicate that the current API call failed and the user should reconfigure to correct the problem. The possible return values are defined as follows:\ntypedef\nenum\ncufftResult_t\n{\nCUFFT_SUCCESS\n=\n0\n,\n// The cuFFT operation was successful\nCUFFT_INVALID_PLAN\n=\n1\n,\n// cuFFT was passed an invalid plan handle\nCUFFT_ALLOC_FAILED\n=\n2\n,\n// cuFFT failed to allocate GPU or CPU memory\nCUFFT_INVALID_TYPE\n=\n3\n,\n// The cuFFT type provided is unsupported\nCUFFT_INVALID_VALUE\n=\n4\n,\n// User specified an invalid pointer or parameter\nCUFFT_INTERNAL_ERROR\n=\n5\n,\n// Driver or internal cuFFT library error\nCUFFT_EXEC_FAILED\n=\n6\n,\n// Failed to execute an FFT on the GPU\nCUFFT_SETUP_FAILED\n=\n7\n,\n// The cuFFT library failed to initialize\nCUFFT_INVALID_SIZE\n=\n8\n,\n// User specified an invalid transform size\nCUFFT_UNALIGNED_DATA\n=\n9\n,\n// Not currently in use\nCUFFT_INVALID_DEVICE\n=\n11\n,\n// Execution of a plan was on different GPU than plan creation\nCUFFT_NO_WORKSPACE\n=\n13\n// No workspace has been provided prior to plan execution\nCUFFT_NOT_IMPLEMENTED\n=\n14\n,\n// Function does not implement functionality for parameters given.\nCUFFT_NOT_SUPPORTED\n=\n16\n,\n// Operation is not supported for parameters given.\nCUFFT_MISSING_DEPENDENCY\n=\n17\n,\n// cuFFT is unable to find a dependency\nCUFFT_NVRTC_FAILURE\n=\n18\n,\n// An NVRTC failure was encountered during a cuFFT operation\nCUFFT_NVJITLINK_FAILURE\n=\n19\n,\n// An nvJitLink failure was encountered during a cuFFT operation\nCUFFT_NVSHMEM_FAILURE\n=\n20\n,\n// An NVSHMEM failure was encountered during a cuFFT operation\n}\ncufftResult\n;\nUsers are encouraged to check return values from cuFFT functions for errors as shown in\ncuFFT Code Examples\n.\n3.2.\ncuFFT Basic Plans\n\nThese API routines take care of initializing the cufftHandle. Any already-initialized handle attributes passed to the planning functions will be ignored.\n3.2.1.\ncufftPlan1d()\n\ncufftResult\ncufftPlan1d\n(\ncufftHandle\n*\nplan\n,\nint\nnx\n,\ncufftType\ntype\n,\nint\nbatch\n)\n;\n\nCreates a 1D FFT plan configuration for a specified signal size and data type. The\nbatch\ninput parameter tells cuFFT how many 1D transforms to configure.\nThis call can only be used once for a given handle. It will fail and return\nCUFFT_INVALID_PLAN\nif the plan is locked, i.e. the handle was previously used with a different\ncufftPlan\nor\ncufftMakePlan\ncall.\nParameters\nplan[In]\n– Pointer to an uninitialized\ncufftHandle\nobject.\nnx[In]\n– The transform size (e.g. 256 for a 256-point FFT).\ntype[In]\n– The transform data type (e.g.,\nCUFFT_C2C\nfor single precision complex to complex).\nbatch[In]\n– Number of transforms of size\nnx\n. Please consider using\ncufftPlanMany\nfor multiple transforms.\nplan[Out]\n– Contains a cuFFT 1D plan handle value.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully created the FFT plan.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle. Handle is not valid when the plan is locked.\nCUFFT_ALLOC_FAILED\n– The allocation of GPU resources for the plan failed.\nCUFFT_INVALID_VALUE\n– One or more invalid parameters were passed to the API.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_SIZE\n– The\nnx\nor\nbatch\nparameter is not a supported size.\nCUFFT_MISSING_DEPENDENCY\n– The cuFFT library was unable to find a dependency either because it is missing or the version found is incompatible\nCUFFT_NVRTC_FAILURE\n– NVRTC encountered an error during planning\nCUFFT_NVJITLINK_FAILURE\n– nvJitLink encountered an error during planning\n3.2.2.\ncufftPlan2d()\n\ncufftResult\ncufftPlan2d\n(\ncufftHandle\n*\nplan\n,\nint\nnx\n,\nint\nny\n,\ncufftType\ntype\n)\n;\n\nCreates a 2D FFT plan configuration according to specified signal sizes and data type.\nThis call can only be used once for a given handle. It will fail and return\nCUFFT_INVALID_PLAN\nif the plan is locked, i.e. the handle was previously used with a different\ncufftPlan\nor\ncufftMakePlan\ncall.\nParameters\nplan[In]\n– Pointer to an uninitialized\ncufftHandle\nobject.\nnx[In]\n– The transform size in the\nx\ndimension This is slowest changing dimension of a transform (strided in memory).\nny[In]\n– The transform size in the\ny\ndimension. This is fastest changing dimension of a transform (contiguous in memory).\ntype[In]\n– The transform data type (e.g.,\nCUFFT_C2R\nfor single precision complex to real).\nplan[Out]\n– Contains a cuFFT 2D plan handle value.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully created the FFT plan.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle. Handle is not valid when the plan is locked.\nCUFFT_ALLOC_FAILED\n– The allocation of GPU resources for the plan failed.\nCUFFT_INVALID_VALUE\n– One or more invalid parameters were passed to the API.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_SIZE\n– Either or both of the\nnx\nor\nny\nparameters is not a supported size.\nCUFFT_MISSING_DEPENDENCY\n– The cuFFT library was unable to find a dependency either because it is missing or the version found is incompatible\nCUFFT_NVRTC_FAILURE\n– NVRTC encountered an error during planning\nCUFFT_NVJITLINK_FAILURE\n– nvJitLink encountered an error during planning\n3.2.3.\ncufftPlan3d()\n\ncufftResult\ncufftPlan3d\n(\ncufftHandle\n*\nplan\n,\nint\nnx\n,\nint\nny\n,\nint\nnz\n,\ncufftType\ntype\n)\n;\n\nCreates a 3D FFT plan configuration according to specified signal sizes and data type. This function is the same as\ncufftPlan2d()\nexcept that it takes a third size parameter\nnz\n.\nThis call can only be used once for a given handle. It will fail and return\nCUFFT_INVALID_PLAN\nif the plan is locked, i.e. the handle was previously used with a different\ncufftPlan\nor\ncufftMakePlan\ncall.\nParameters\nplan[In]\n– Pointer to an uninitialized\ncufftHandle\nobject.\nnx[In]\n– The transform size in the\nx\ndimension. This is slowest changing dimension of a transform (strided in memory).\nny[In]\n– The transform size in the\ny\ndimension.\nnz[In]\n– The transform size in the\nz\ndimension. This is fastest changing dimension of a transform (contiguous in memory).\ntype[In]\n– The transform data type (e.g.,\nCUFFT_R2C\nfor single precision real to complex).\nplan[Out]\n– Contains a cuFFT 3D plan handle value.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully created the FFT plan.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle. Handle is not valid when the plan is locked.\nCUFFT_ALLOC_FAILED\n– The allocation of GPU resources for the plan failed.\nCUFFT_INVALID_VALUE\n– One or more invalid parameters were passed to the API.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_SIZE\n– One or more of the\nnx\n,\nny\n, or\nnz\nparameters is not a supported size.\nCUFFT_MISSING_DEPENDENCY\n– The cuFFT library was unable to find a dependency either because it is missing or the version found is incompatible\nCUFFT_NVRTC_FAILURE\n– NVRTC encountered an error during planning\nCUFFT_NVJITLINK_FAILURE\n– nvJitLink encountered an error during planning\n3.2.4.\ncufftPlanMany()\n\ncufftResult\ncufftPlanMany\n(\ncufftHandle\n*\nplan\n,\nint\nrank\n,\nint\n*\nn\n,\nint\n*\ninembed\n,\nint\nistride\n,\nint\nidist\n,\nint\n*\nonembed\n,\nint\nostride\n,\nint\nodist\n,\ncufftType\ntype\n,\nint\nbatch\n)\n;\n\nCreates a FFT plan configuration of dimension\nrank\n, with sizes specified in the array\nn\n. The\nbatch\ninput parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created.\nThe\ncufftPlanMany()\nAPI supports more complicated input and output data layouts via the advanced data layout parameters:\ninembed\n,\nistride\n,\nidist\n,\nonembed\n,\nostride\n, and\nodist\n.\nIf\ninembed\nand\nonembed\nare set to\nNULL\n, all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays.\nAll arrays are assumed to be in CPU memory.\nPlease note that behavior of\ncufftPlanMany\nfunction when\ninembed\nand\nonembed\nis\nNULL\nis different than corresponding function in FFTW library\nfftw_plan_many_dft\n.\nThis call can only be used once for a given handle. It will fail and return\nCUFFT_INVALID_PLAN\nif the plan is locked, i.e. the handle was previously used with a different\ncufftPlan\nor\ncufftMakePlan\ncall.\nParameters\nplan[In]\n– Pointer to an uninitialized\ncufftHandle\nobject.\nrank[In]\n– Dimensionality of the transform (1, 2, or 3).\nn[In]\n– Array of size\nrank\n, describing the size of each dimension,\nn[0]\nbeing the size of the outermost and\nn[rank-1]\ninnermost (contiguous) dimension of a transform.\ninembed[In]\n– Pointer of size\nrank\nthat indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored.\nistride[In]\n– Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension.\nidist[In]\n– Indicates the distance between the first element of two consecutive signals in a batch of the input data.\nonembed[In]\n– Pointer of size\nrank\nthat indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored.\nostride[In]\n– Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension.\nodist[In]\n– Indicates the distance between the first element of two consecutive signals in a batch of the output data.\ntype[In]\n– The transform data type (e.g.,\nCUFFT_R2C\nfor single precision real to complex).\nbatch[In]\n– Batch size for this transform.\nplan[Out]\n– Contains a cuFFT plan handle.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully created the FFT plan.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle. Handle is not valid when the plan is locked.\nCUFFT_ALLOC_FAILED\n– The allocation of GPU resources for the plan failed.\nCUFFT_INVALID_VALUE\n– One or more invalid parameters were passed to the API.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_SIZE\n– One or more of the parameters is not a supported size.\nCUFFT_MISSING_DEPENDENCY\n– The cuFFT library was unable to find a dependency either because it is missing or the version found is incompatible\nCUFFT_NVRTC_FAILURE\n– NVRTC encountered an error during planning\nCUFFT_NVJITLINK_FAILURE\n– nvJitLink encountered an error during planning\n3.3.\ncuFFT Extensible Plans\n\nThese API routines separates handle creation from plan generation. This makes it possible to change plan settings, which may alter the outcome of the plan generation phase, before the plan is actually generated.\n3.3.1.\ncufftCreate()\n\ncufftResult\ncufftCreate\n(\ncufftHandle\n*\nplan\n)\n\nCreates only an opaque handle, and allocates small data structures on the host. The\ncufftMakePlan*()\ncalls actually do the plan generation.\nParameters\nplan[In]\n– Pointer to a\ncufftHandle\nobject.\nplan[Out]\n– Contains a cuFFT plan handle value.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully created the FFT plan.\nCUFFT_ALLOC_FAILED\n– The allocation of resources for the plan failed.\nCUFFT_INVALID_VALUE\n– One or more invalid parameters were passed to the API.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\n3.3.2.\ncufftDestroy()\n\ncufftResult\ncufftDestroy\n(\ncufftHandle\nplan\n)\n\nFrees all GPU resources associated with a cuFFT plan and destroys the internal plan data structure. This function should be called once a plan is no longer needed, to avoid wasting GPU memory.\nIn the case of multi-GPU plans, the plan created first should be destroyed last.\nParameters\nplan[In]\n– The\ncufftHandle\nobject of the plan to be destroyed.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully destroyed the FFT plan.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\n3.3.3.\ncufftMakePlan1d()\n\ncufftResult\ncufftMakePlan1d\n(\ncufftHandle\nplan\n,\nint\nnx\n,\ncufftType\ntype\n,\nint\nbatch\n,\nsize_t\n*\nworkSize\n)\n;\n\nFollowing a call to\ncufftCreate()\nmakes a 1D FFT plan configuration for a specified signal size and data type. The\nbatch\ninput parameter tells cuFFT how many 1D transforms to configure.\nThis call can only be used once for a given handle. It will fail and return\nCUFFT_INVALID_PLAN\nif the plan is locked, i.e. the handle was previously used with a different\ncufftPlan\nor\ncufftMakePlan\ncall.\nIf\ncufftXtSetGPUs()\nwas called prior to this call with multiple GPUs, then\nworkSize\nwill contain multiple sizes. See sections on multiple GPUs for more details.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\nnx[In]\n– The transform size (e.g. 256 for a 256-point FFT). For multiple GPUs, this must be a power of 2.\ntype[In]\n– The transform data type (e.g.,\nCUFFT_C2C\nfor single precision complex to complex). For multiple GPUs this must be a complex to complex transform.\nbatch[In]\n– Number of transforms of size\nnx\n. Please consider using\ncufftMakePlanMany\nfor multiple transforms.\n*workSize[In]\n– Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements.\n*workSize[Out]\n– Pointer to the size(s) of the work areas.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully created the FFT plan.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met.\nCUFFT_ALLOC_FAILED\n– The allocation of GPU resources for the plan failed.\nCUFFT_INVALID_VALUE\n– One or more invalid parameters were passed to the API.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED`\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_SIZE\n– The\nnx\nor\nbatch\nparameter is not a supported size.\nCUFFT_MISSING_DEPENDENCY\n– The cuFFT library was unable to find a dependency either because it is missing or the version found is incompatible\nCUFFT_NVRTC_FAILURE\n– NVRTC encountered an error during planning\nCUFFT_NVJITLINK_FAILURE\n– nvJitLink encountered an error during planning\n3.3.4.\ncufftMakePlan2d()\n\ncufftResult\ncufftMakePlan2d\n(\ncufftHandle\nplan\n,\nint\nnx\n,\nint\nny\n,\ncufftType\ntype\n,\nsize_t\n*\nworkSize\n)\n;\n\nFollowing a call to\ncufftCreate()\nmakes a 2D FFT plan configuration according to specified signal sizes and data type.\nThis call can only be used once for a given handle. It will fail and return\nCUFFT_INVALID_PLAN\nif the plan is locked, i.e. the handle was previously used with a different\ncufftPlan\nor\ncufftMakePlan\ncall.\nIf\ncufftXtSetGPUs()\nwas called prior to this call with multiple GPUs, then\nworkSize\nwill contain multiple sizes. See sections on multiple GPUs for more details.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\nnx[In]\n– The transform size in the\nx\ndimension. This is slowest changing dimension of a transform (strided in memory). For multiple GPUs, this must be factorable into primes less than or equal to 127.\nny[In]\n– The transform size in the\ny\ndimension. This is fastest changing dimension of a transform (contiguous in memory). For 2 GPUs, this must be factorable into primes less than or equal to 127.\ntype[In]\n– The transform data type (e.g.,\nCUFFT_C2R\nfor single precision complex to real).\nworkSize[In]\n– Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements.\n*workSize[Out]\n– Pointer to the size(s) of the work areas.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully created the FFT plan.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_ALLOC_FAILED\n– The allocation of GPU resources for the plan failed.\nCUFFT_INVALID_VALUE\n– One or more invalid parameters were passed to the API.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_SIZE\n– Either or both of the\nnx\nor\nny\nparameters is not a supported size.\nCUFFT_MISSING_DEPENDENCY\n– The cuFFT library was unable to find a dependency either because it is missing or the version found is incompatible\nCUFFT_NVRTC_FAILURE\n– NVRTC encountered an error during planning\nCUFFT_NVJITLINK_FAILURE\n– nvJitLink encountered an error during planning\n3.3.5.\ncufftMakePlan3d()\n\ncufftResult\ncufftMakePlan3d\n(\ncufftHandle\nplan\n,\nint\nnx\n,\nint\nny\n,\nint\nnz\n,\ncufftType\ntype\n,\nsize_t\n*\nworkSize\n)\n;\n\nFollowing a call to\ncufftCreate()\nmakes a 3D FFT plan configuration according to specified signal sizes and data type. This function is the same as\ncufftPlan2d()\nexcept that it takes a third size parameter\nnz\n.\nThis call can only be used once for a given handle. It will fail and return\nCUFFT_INVALID_PLAN\nif the plan is locked, i.e. the handle was previously used with a different\ncufftPlan\nor\ncufftMakePlan\ncall.\nIf\ncufftXtSetGPUs()\nwas called prior to this call with multiple GPUs, then\nworkSize\nwill contain multiple sizes. See sections on multiple GPUs for more details.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\nnx[In]\n– The transform size in the\nx\ndimension. This is slowest changing dimension of a transform (strided in memory). For multiple GPUs, this must be factorable into primes less than or equal to 127.\nny[In]\n– The transform size in the\ny\ndimension. For multiple GPUs, this must be factorable into primes less than or equal to 127.\nnz[In]\n– The transform size in the\nz\ndimension. This is fastest changing dimension of a transform (contiguous in memory). For multiple GPUs, this must be factorable into primes less than or equal to 127.\ntype[In]\n– The transform data type (e.g.,\nCUFFT_R2C\nfor single precision real to complex).\nworkSize[In]\n– Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements.\n*workSize[Out]\n– Pointer to the size(s) of the work area(s).\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully created the FFT plan.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_ALLOC_FAILED\n– The allocation of GPU resources for the plan failed.\nCUFFT_INVALID_VALUE\n– One or more invalid parameters were passed to the API.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_SIZE\n– One or more of the\nnx\n,\nny\n, or\nnz\nparameters is not a supported size.\nCUFFT_MISSING_DEPENDENCY\n– The cuFFT library was unable to find a dependency either because it is missing or the version found is incompatible\nCUFFT_NVRTC_FAILURE\n– NVRTC encountered an error during planning\nCUFFT_NVJITLINK_FAILURE\n– nvJitLink encountered an error during planning\n3.3.6.\ncufftMakePlanMany()\n\ncufftResult\ncufftMakePlanMany\n(\ncufftHandle\nplan\n,\nint\nrank\n,\nint\n*\nn\n,\nint\n*\ninembed\n,\nint\nistride\n,\nint\nidist\n,\nint\n*\nonembed\n,\nint\nostride\n,\nint\nodist\n,\ncufftType\ntype\n,\nint\nbatch\n,\nsize_t\n*\nworkSize\n)\n;\n\nFollowing a call to\ncufftCreate()\nmakes a FFT plan configuration of dimension\nrank\n, with sizes specified in the array\nn\n. The\nbatch\ninput parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created.\nThe\ncufftPlanMany()\nAPI supports more complicated input and output data layouts via the advanced data layout parameters:\ninembed\n,\nistride\n,\nidist\n,\nonembed\n,\nostride\n, and\nodist\n.\nIf\ninembed\nand\nonembed\nare set to\nNULL\n, all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays.\nThis call can only be used once for a given handle. It will fail and return\nCUFFT_INVALID_PLAN\nif the plan is locked, i.e. the handle was previously used with a different\ncufftPlan\nor\ncufftMakePlan\ncall.\nIf\ncufftXtSetGPUs()\nwas called prior to this call with multiple GPUs, then\nworkSize\nwill contain multiple sizes. See sections on multiple GPUs for more details.\nAll arrays are assumed to be in CPU memory.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\nrank[In]\n– Dimensionality of the transform (1, 2, or 3)\nn[In]\n– Array of size\nrank\n, describing the size of each dimension,\nn[0]\nbeing the size of the outermost and\nn[rank-1]\ninnermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127.\ninembed[In]\n– Pointer of size\nrank\nthat indicates the storage dimensions of the input data in memory,\ninembed[0]\nbeing the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored.\nistride[In]\n– Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension\nidist[In]\n– Indicates the distance between the first element of two consecutive signals in a batch of the input data\nonembed[In]\n– Pointer of size\nrank\nthat indicates the storage dimensions of the output data in memory,\nonembed[0]\nbeing the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored.\nostride[In]\n– Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension\nodist[In]\n– Indicates the distance between the first element of two consecutive signals in a batch of the output data\ntype[In]\n– The transform data type (e.g.,\nCUFFT_R2C\nfor single precision real to complex). For 2 GPUs this must be a complex to complex transform.\nbatch[In]\n– Batch size for this transform.\n*workSize[In]\n– Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements.\n*workSize[Out]\n– Pointer to the size(s) of the work areas.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully created the FFT plan.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met.\nCUFFT_ALLOC_FAILED\n– The allocation of GPU resources for the plan failed.\nCUFFT_INVALID_VALUE\n– One or more invalid parameters were passed to the API.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_SIZE\n– One or more of the parameters is not a supported size.\nCUFFT_MISSING_DEPENDENCY\n– The cuFFT library was unable to find a dependency either because it is missing or the version found is incompatible\nCUFFT_NVRTC_FAILURE\n– NVRTC encountered an error during planning\nCUFFT_NVJITLINK_FAILURE\n– nvJitLink encountered an error during planning\n3.3.7.\ncufftMakePlanMany64()\n\ncufftResult\ncufftMakePlanMany64\n(\ncufftHandle\nplan\n,\nint\nrank\n,\nlong\nlong\nint\n*\nn\n,\nlong\nlong\nint\n*\ninembed\n,\nlong\nlong\nint\nistride\n,\nlong\nlong\nint\nidist\n,\nlong\nlong\nint\n*\nonembed\n,\nlong\nlong\nint\nostride\n,\nlong\nlong\nint\nodist\n,\ncufftType\ntype\n,\nlong\nlong\nint\nbatch\n,\nsize_t\n*\nworkSize\n)\n;\n\nFollowing a call to\ncufftCreate()\nmakes a FFT plan configuration of dimension\nrank\n, with sizes specified in the array\nn\n. The\nbatch\ninput parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created.\nThis API is identical to\ncufftMakePlanMany\nexcept that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic.\nAll sizes and types of transform are supported by this interface, with two exceptions. For transforms whose size exceeds 4G elements, the dimensions specified in the array\nn\nmust be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose size exceeds 4G elements, the fastest changing dimension must be even.\nThe\ncufftPlanMany64()\nAPI supports more complicated input and output data layouts via the advanced data layout parameters:\ninembed\n,\nistride\n,\nidist\n,\nonembed\n,\nostride\n, and\nodist\n.\nIf\ninembed\nand\nonembed\nare set to\nNULL\n, all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays.\nThis call can only be used once for a given handle. It will fail and return\nCUFFT_INVALID_PLAN\nif the plan is locked, i.e. the handle was previously used with a different\ncufftPlan\nor\ncufftMakePlan\ncall.\nIf\ncufftXtSetGPUs()\nwas called prior to this call with multiple GPUs, then\nworkSize\nwill contain multiple sizes. See sections on multiple GPUs for more details.\nAll arrays are assumed to be in CPU memory.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\nrank[In]\n– Dimensionality of the transform (1, 2, or 3).\nn[In]\n– Array of size\nrank\n, describing the size of each dimension. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127.\ninembed[In]\n– Pointer of size\nrank\nthat indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored.\nistride[In]\n– Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension.\nidist[In]\n– Indicates the distance between the first element of two consecutive signals in a batch of the input data.\nonembed[In]\n– Pointer of size\nrank\nthat indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored.\nostride[In]\n– Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension.\nodist[In]\n– Indicates the distance between the first element of two consecutive signals in a batch of the output data.\ntype[In]\n– The transform data type (e.g.,\nCUFFT_R2C\nfor single precision real to complex). For 2 GPUs this must be a complex to complex transform.\nbatch[In]\n– Batch size for this transform.\n*workSize[In]\n– Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements.\n*workSize[Out]\n– Pointer to the size(s) of the work areas.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully created the FFT plan.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met.\nCUFFT_ALLOC_FAILED\n– The allocation of GPU resources for the plan failed.\nCUFFT_INVALID_VALUE\n– One or more invalid parameters were passed to the API.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_SIZE\n– One or more of the parameters is not a supported size.\nCUFFT_MISSING_DEPENDENCY\n– The cuFFT library was unable to find a dependency either because it is missing or the version found is incompatible\nCUFFT_NVRTC_FAILURE\n– NVRTC encountered an error during planning\nCUFFT_NVJITLINK_FAILURE\n– nvJitLink encountered an error during planning\n3.3.8.\ncufftXtMakePlanMany()\n\ncufftResult\ncufftXtMakePlanMany\n(\ncufftHandle\nplan\n,\nint\nrank\n,\nlong\nlong\nint\n*\nn\n,\nlong\nlong\nint\n*\ninembed\n,\nlong\nlong\nint\nistride\n,\nlong\nlong\nint\nidist\n,\ncudaDataType\ninputtype\n,\nlong\nlong\nint\n*\nonembed\n,\nlong\nlong\nint\nostride\n,\nlong\nlong\nint\nodist\n,\ncudaDataType\noutputtype\n,\nlong\nlong\nint\nbatch\n,\nsize_t\n*\nworkSize\n,\ncudaDataType\nexecutiontype\n)\n;\n\nFollowing a call to\ncufftCreate()\nmakes an FFT plan configuration of dimension\nrank\n, with sizes specified in the array\nn\n. The\nbatch\ninput parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created.\nType specifiers\ninputtype\n,\noutputtype\nand\nexecutiontype\ndictate type and precision of transform to be performed. Not all combinations of parameters are supported. Currently all three parameters need to match precision. Parameters\ninputtype\nand\noutputtype\nneed to match transform type complex-to-complex, real-to-complex or complex-to-real. Parameter\nexecutiontype\nneeds to match precision and be of a complex type. Example: for a half-precision real-to-complex transform, parameters\ninputtype\n,\noutputtype\nand\nexecutiontype\nwould have values of\nCUDA_R_16F\n,\nCUDA_C_16F\nand\nCUDA_C_16F\nrespectively. Similarly, a bfloat16 complex-to-real transform would use\nCUDA_C_16BF\nfor\ninputtype\nand\nexecutiontype\n, and\nCUDA_R_16BF\nfor\noutputtype\n.\nThe\ncufftXtMakePlanMany()\nAPI supports more complicated input and output data layouts via the advanced data layout parameters:\ninembed\n,\nistride\n,\nidist\n,\nonembed\n,\nostride\n, and\nodist\n.\nIf\ninembed\nand\nonembed\nare set to\nNULL\n, all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays.\nIf\ncufftXtSetGPUs()\nwas called prior to this call with multiple GPUs, then\nworkSize\nwill contain multiple sizes. See sections on multiple GPUs for more details.\nAll arrays are assumed to be in CPU memory.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\nrank[In]\n– Dimensionality of the transform (1, 2, or 3).\nn[In]\n– Array of size\nrank\n, describing the size of each dimension,\nn[0]\nbeing the size of the outermost and\nn[rank-1]\ninnermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127.\ninembed[In]\n– Pointer of size\nrank\nthat indicates the storage dimensions of the input data in memory,\ninembed[0]\nbeing the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored.\nistride[In]\n– Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension.\nidist[In]\n– Indicates the distance between the first element of two consecutive signals in a batch of the input data.\ninputtype[In]\n– Type of input data.\nonembed[In]\n– Pointer of size\nrank\nthat indicates the storage dimensions of the output data in memory,\nonembed[0]\nbeing the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored.\nostride[In]\n– Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension.\nodist[In]\n– Indicates the distance between the first element of two consecutive signals in a batch of the output data.\noutputtype[In]\n– Type of output data.\nbatch[In]\n– Batch size for this transform.\n*workSize[In]\n– Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements.\nexecutiontype[In]\n– Type of data to be used for computations.\n*workSize[Out]\n– Pointer to the size(s) of the work areas.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully created the FFT plan.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle. Handle is not valid when multi-GPU restrictions are not met.\nCUFFT_ALLOC_FAILED\n– The allocation of GPU resources for the plan failed.\nCUFFT_INVALID_VALUE\n– One or more invalid parameters were passed to the API.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_SIZE\n– One or more of the parameters is not a supported size.\nCUFFT_MISSING_DEPENDENCY\n– The cuFFT library was unable to find a dependency either because it is missing or the version found is incompatible\nCUFFT_NVRTC_FAILURE\n– NVRTC encountered an error during planning\nCUFFT_NVJITLINK_FAILURE\n– nvJitLink encountered an error during planning\n3.4.\ncuFFT Plan Properties\n\nUsers can further customize cuFFT plans using plan properties. These properties can be set, queried and reset on a per-plan basis as needed, using the routines listed in this section.\nThe current supported properties are listed below:\nProperty\nUnderlying Type\nDescription\nBehavior\nNVFFT_PLAN_PROPERTY_INT64_PATIENT_JIT\nlong long int\nRuntime LTO kernels are enabled when set to not-zero value. See\nLink-Time Optimized Kernels\nRuntime LTO kernles are disabled when set to zero (default)\nCan be set / reset before planning\nCannot be set / reset after planning\n3.4.1.\ncufftSetPlanPropertyInt64()\n\ncufftResult\ncufftSetPlanPropertyInt64\n(\ncufftHandle\nplan\n,\ncufftProperty\nproperty\n,\nconst\nlong\nlong\nint\npropertyValueInt64\n)\n;\n\nAssociates a cuFFT plan with a property identified by the key\nproperty\n. The value for the property is given by value\npropertyValueInt64\n, which is a signed long long integer.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\nproperty[In]\n– The property identifier, of type\ncufftPlanProperty\n.\npropertyValueInt64[In]\n– Value to set for the property, a long long signed integer.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully set the property.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_NOT_SUPPORTED\n– The property is not supported, or it cannot be set at the time (e.g. some properties cannot be set after calling a planning routine for the plan, see\ncuFFT Plan Properties\n).\nCUFFT_INVALID_VALUE\n– Invalid property or value with which to set the property\n3.4.2.\ncufftGetPlanPropertyInt64()\n\ncufftResult\ncufftGetPlanPropertyInt64\n(\ncufftHandle\nplan\n,\ncufftProperty\nproperty\n,\nlong\nlong\nint\n*\npropertyValueInt64\n)\n;\n\nRetrieves the property value identified by the key\nproperty\nassociated with the cuFFT plan\nplan\n. The value for the property, which is a signed long long integer, is set in the address space pointed by\npropertyValueInt64\n.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\nproperty[In]\n– The property identifier, of type\ncufftPlanProperty\n.\npropertyValueInt64[In]\n– Pointer to the value to be set with the value of the property.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully retrieved the property value.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_NOT_SUPPORTED\n– The property is not supported.\nCUFFT_INVALID_VALUE\n– Invalid property, or pointer\npropertyValueInt64\nis null\n3.4.3.\ncufftResetPlanProperty()\n\ncufftResult\ncufftResetPlanProperty\n(\ncufftHandle\nplan\n,\ncufftProperty\nproperty\n)\n;\n\nResets the value of the property identified by the key\nproperty\n, associated with the cuFFT plan\nplan\n, to its default value.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\nproperty[In]\n– The property identifier, of type\ncufftPlanProperty\n.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully reset the property value.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_NOT_SUPPORTED\n– The property is not supported for\nplan\n, or cannot be reset at present time (see Behavior column on\ncuFFT Plan Properties\n).\nCUFFT_INVALID_VALUE\n– Invalid property\n3.5.\ncuFFT Estimated Size of Work Area\n\nDuring plan execution, cuFFT may require a work area for temporary storage of intermediate results. The\ncufftEstimate*()\ncalls return an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. Some problem sizes may require no temporary storage, returning a work area size of 0, while others may require large amounts of storage. In particular powers of 2 are very efficient in terms of temporary storage. Large prime numbers, however, use different algorithms and may need up to the eight times that of a similarly sized power of 2. These routines return estimated\nworkSize\nvalues which may still be smaller than the actual values needed especially for values of\nn\nthat are not multiples of powers of 2, 3, 5 and 7. More refined values are given by the\ncufftGetSize*()\nroutines, but these values may still be conservative.\n3.5.1.\ncufftEstimate1d()\n\ncufftResult\ncufftEstimate1d\n(\nint\nnx\n,\ncufftType\ntype\n,\nint\nbatch\n,\nsize_t\n*\nworkSize\n)\n;\n\nDuring plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings.\nParameters\nnx[In]\n– The transform size (e.g. 256 for a 256-point FFT).\ntype[In]\n– The transform data type (e.g.,\nCUFFT_C2C\nfor single precision complex to complex).\nbatch[In]\n– Number of transforms of size\nnx\n. Please consider using\ncufftEstimateMany\nfor multiple transforms.\n*workSize[In]\n– Pointer to the size, in bytes, of the work space.\n*workSize[Out]\n– Pointer to the size of the work space.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully returned the size of the work space.\nCUFFT_ALLOC_FAILED\n– The allocation of GPU resources for the plan failed.\nCUFFT_INVALID_VALUE\n– One or more invalid parameters were passed to the API.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_SIZE\n– The\nnx\nparameter is not a supported size.\nCUFFT_MISSING_DEPENDENCY\n– The cuFFT library was unable to find a dependency either because it is missing or the version found is incompatible\nCUFFT_NVRTC_FAILURE\n– NVRTC encountered an error during planning\nCUFFT_NVJITLINK_FAILURE\n– nvJitLink encountered an error during planning\n3.5.2.\ncufftEstimate2d()\n\ncufftResult\ncufftEstimate2d\n(\nint\nnx\n,\nint\nny\n,\ncufftType\ntype\n,\nsize_t\n*\nworkSize\n)\n;\n\nDuring plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. If a work area size of 0 is returned it means no temporary storage is needed for evaluation.\nParameters\nnx[In]\n– The transform size in the\nx\ndimension (number of rows).\nny[In]\n– The transform size in the\ny\ndimension (number of columns).\ntype[In]\n– The transform data type (e.g.,\nCUFFT_C2R\nfor single precision complex to real).\n*workSize[In]\n– Pointer to the size, in bytes, of the work space.\n*workSize[Out]\n– Pointer to the size of the work space.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully returned the size of the work space.\nCUFFT_ALLOC_FAILED\n– The allocation of GPU resources for the plan failed.\nCUFFT_INVALID_VALUE\n– One or more invalid parameters were passed to the API.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_SIZE\n– Either or both of the\nnx\nor\nny\nparameters is not a supported size.\nCUFFT_MISSING_DEPENDENCY\n– The cuFFT library was unable to find a dependency either because it is missing or the version found is incompatible\nCUFFT_NVRTC_FAILURE\n– NVRTC encountered an error during planning\nCUFFT_NVJITLINK_FAILURE\n– nvJitLink encountered an error during planning\n3.5.3.\ncufftEstimate3d()\n\ncufftResult\ncufftEstimate3d\n(\nint\nnx\n,\nint\nny\n,\nint\nnz\n,\ncufftType\ntype\n,\nsize_t\n*\nworkSize\n)\n;\n\nDuring plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. If a work area size of 0 is returned it means no temporary storage is needed for evaluation.\nParameters\nnx[In]\n– The transform size in the\nx\ndimension.\nny[In]\n– The transform size in the\ny\ndimension.\nnz[In]\n– The transform size in the\nz\ndimension.\ntype[In]\n– The transform data type (e.g.,\nCUFFT_R2C\nfor single precision real to complex).\n*workSize[In]\n– Pointer to the size, in bytes, of the work space.\n*workSize[Out]\n– Pointer to the size of the work space.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully returned the size of the work space.\nCUFFT_ALLOC_FAILED\n– The allocation of GPU resources for the plan failed.\nCUFFT_INVALID_VALUE\n– One or more invalid parameters were passed to the API.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_SIZE\n– One or more of the\nnx\n,\nny\n, or\nnz\nparameters is not a supported size.\nCUFFT_MISSING_DEPENDENCY\n– The cuFFT library was unable to find a dependency either because it is missing or the version found is incompatible\nCUFFT_NVRTC_FAILURE\n– NVRTC encountered an error during planning\nCUFFT_NVJITLINK_FAILURE\n– nvJitLink encountered an error during planning\n3.5.4.\ncufftEstimateMany()\n\ncufftResult\ncufftEstimateMany\n(\nint\nrank\n,\nint\n*\nn\n,\nint\n*\ninembed\n,\nint\nistride\n,\nint\nidist\n,\nint\n*\nonembed\n,\nint\nostride\n,\nint\nodist\n,\ncufftType\ntype\n,\nint\nbatch\n,\nsize_t\n*\nworkSize\n)\n;\n\nDuring plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. If a work area size of 0 is returned it means no temporary storage is needed for evaluation.\nThe\ncufftEstimateMany()\nAPI supports more complicated input and output data layouts via the advanced data layout parameters:\ninembed\n,\nistride\n,\nidist\n,\nonembed\n,\nostride\n, and\nodist\n.\nAll arrays are assumed to be in CPU memory.\nParameters\nrank[In]\n– Dimensionality of the transform (1, 2, or 3).\nn[In]\n– Array of size\nrank\n, describing the size of each dimension.\ninembed[In]\n– Pointer of size\nrank\nthat indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored.\nistride[In]\n– Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension.\nidist[In]\n– Indicates the distance between the first element of two consecutive signals in a batch of the input data.\nonembed[In]\n– Pointer of size\nrank\nthat indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored.\nostride[In]\n– Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension.\nodist[In]\n– Indicates the distance between the first element of two consecutive signals in a batch of the output data.\ntype[In]\n– The transform data type (e.g.,\nCUFFT_R2C\nfor single precision real to complex).\nbatch[In]\n– Batch size for this transform.\n*workSize[In]\n– Pointer to the size, in bytes, of the work space.\n*workSize[Out]\n– Pointer to the size of the work space\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully returned the size of the work space.\nCUFFT_ALLOC_FAILED\n– The allocation of GPU resources for the plan failed.\nCUFFT_INVALID_VALUE\n– One or more invalid parameters were passed to the API.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_SIZE\n– One or more of the parameters is not a supported size.\nCUFFT_MISSING_DEPENDENCY\n– The cuFFT library was unable to find a dependency either because it is missing or the version found is incompatible\nCUFFT_NVRTC_FAILURE\n– NVRTC encountered an error during planning\nCUFFT_NVJITLINK_FAILURE\n– nvJitLink encountered an error during planning\n3.6.\ncuFFT Refined Estimated Size of Work Area\n\nThe\ncufftGetSize*()\nroutines give a more accurate estimate of the work area size required for a plan than the\ncufftEstimate*()\nroutines as they take into account any plan settings that may have been made. As discussed in the section\ncuFFT Estimated Size of Work Area\n, the\nworkSize\nvalue(s) returned may be conservative especially for values of\nn\nthat are not multiples of powers of 2, 3, 5 and 7. If a work size of 0 is returned it means no temporary work space is needed to evaluate the FFT.\n3.6.1.\ncufftGetSize1d()\n\ncufftResult\ncufftGetSize1d\n(\ncufftHandle\nplan\n,\nint\nnx\n,\ncufftType\ntype\n,\nint\nbatch\n,\nsize_t\n*\nworkSize\n)\n;\n\nThis call gives a more accurate estimate of the work area size required for a plan than\ncufftEstimate1d()\n, given the specified parameters, and taking into account any plan settings that may have been made. If a work area size of 0 is returned it means no temporary storage is needed for evaluation.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\nnx[In]\n– The transform size (e.g. 256 for a 256-point FFT).\ntype[In]\n– The transform data type (e.g.,\nCUFFT_C2C\nfor single precision complex to complex).\nbatch[In]\n– Number of transforms of size\nnx\n. Please consider using\ncufftGetSizeMany\nfor multiple transforms.\n*workSize[In]\n– Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements.\n*workSize[Out]\n– Pointer to the size of the work space.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully returned the size of the work space.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_ALLOC_FAILED\n– The allocation of GPU resources for the plan failed.\nCUFFT_INVALID_VALUE\n– One or more invalid parameters were passed to the API.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_SIZE\n– The\nnx\nparameter is not a supported size.\n3.6.2.\ncufftGetSize2d()\n\ncufftResult\ncufftGetSize2d\n(\ncufftHandle\nplan\n,\nint\nnx\n,\nint\nny\n,\ncufftType\ntype\n,\nsize_t\n*\nworkSize\n)\n;\n\nThis call gives a more accurate estimate of the work area size required for a plan than\ncufftEstimate2d()\n, given the specified parameters, and taking into account any plan settings that may have been made. If a work area size of 0 is returned it means no temporary storage is needed for evaluation.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\nnx[In]\n– The transform size in the\nx\ndimension (number of rows).\nny[In]\n– The transform size in the\ny\ndimension (number of columns).\ntype[In]\n– The transform data type (e.g.,\nCUFFT_C2R\nfor single precision complex to real).\n*workSize[In]\n– Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements.\n*workSize[Out]\n– Pointer to the size of the work space.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully returned the size of the work space.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_ALLOC_FAILED\n– The allocation of GPU resources for the plan failed.\nCUFFT_INVALID_VALUE\n– One or more invalid parameters were passed to the API.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_SIZE\n– Either or both of the\nnx\nor\nny\nparameters is not a supported size.\n3.6.3.\ncufftGetSize3d()\n\ncufftResult\ncufftGetSize3d\n(\ncufftHandle\nplan\n,\nint\nnx\n,\nint\nny\n,\nint\nnz\n,\ncufftType\ntype\n,\nsize_t\n*\nworkSize\n)\n;\n\nThis call gives a more accurate estimate of the work area size required for a plan than\ncufftEstimate3d()\n, given the specified parameters, and taking into account any plan settings that may have been made. If a work area size of 0 is returned it means no temporary storage is needed for evaluation.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\nnx[In]\n– The transform size in the\nx\ndimension.\nny[In]\n– The transform size in the\ny\ndimension.\nnz[In]\n– The transform size in the\nz\ndimension.\ntype[In]\n– The transform data type (e.g.,\nCUFFT_R2C\nfor single precision real to complex).\n*workSize[In]\n– Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements.\n*workSize[Out]\n– Pointer to the size of the work space.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully returned the size of the work space.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_ALLOC_FAILED\n– The allocation of GPU resources for the plan failed.\nCUFFT_INVALID_VALUE\n– One or more invalid parameters were passed to the API.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_SIZE\n– One or more of the\nnx\n,\nny\n, or\nnz\nparameters is not a supported size.\n3.6.4.\ncufftGetSizeMany()\n\ncufftResult\ncufftGetSizeMany\n(\ncufftHandle\nplan\n,\nint\nrank\n,\nint\n*\nn\n,\nint\n*\ninembed\n,\nint\nistride\n,\nint\nidist\n,\nint\n*\nonembed\n,\nint\nostride\n,\nint\nodist\n,\ncufftType\ntype\n,\nint\nbatch\n,\nsize_t\n*\nworkSize\n)\n;\n\nThis call gives a more accurate estimate of the work area size required for a plan than\ncufftEstimateSizeMany()\n, given the specified parameters, and taking into account any plan settings that may have been made. If a work area size of 0 is returned it means no temporary storage is needed for evaluation.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\nrank[In]\n– Dimensionality of the transform (1, 2, or 3).\nn[In]\n– Array of size\nrank\n, describing the size of each dimension.\ninembed[In]\n– Pointer of size\nrank\nthat indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored.\nistride[In]\n– Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension.\nidist[In]\n– Indicates the distance between the first element of two consecutive signals in a batch of the input data.\nonembed[In]\n– Pointer of size\nrank\nthat indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored.\nostride[In]\n– Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension.\nodist[In]\n– Indicates the distance between the first element of two consecutive signals in a batch of the output data.\ntype[In]\n– The transform data type (e.g.,\nCUFFT_R2C\nfor single precision real to complex).\nbatch[In]\n– Batch size for this transform.\n*workSize[In]\n– Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements.\n*workSize[Out]\n– Pointer to the size of the work area.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully returned the size of the work space.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_ALLOC_FAILED\n– The allocation of GPU resources for the plan failed.\nCUFFT_INVALID_VALUE\n– One or more invalid parameters were passed to the API.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_SIZE\n– One or more of the parameters is not a supported size.\n3.6.5.\ncufftGetSizeMany64()\n\ncufftResult\ncufftGetSizeMany64\n(\ncufftHandle\nplan\n,\nint\nrank\n,\nlong\nlong\nint\n*\nn\n,\nlong\nlong\nint\n*\ninembed\n,\nlong\nlong\nint\nistride\n,\nlong\nlong\nint\nidist\n,\nlong\nlong\nint\n*\nonembed\n,\nlong\nlong\nint\nostride\n,\nlong\nlong\nint\nodist\n,\ncufftType\ntype\n,\nlong\nlong\nint\nbatch\n,\nsize_t\n*\nworkSize\n)\n;\n\nThis call gives a more accurate estimate of the work area size required for a plan than\ncufftEstimateSizeMany()\n, given the specified parameters, and taking into account any plan settings that may have been made. If a work area size of 0 is returned it means no temporary storage is needed for evaluation.\nThis API is identical to\ncufftMakePlanMany\nexcept that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic.\nAll sizes and types of transform are supported by this interface, with two exceptions. For transforms whose total size exceeds 4G elements, the dimensions specified in the array\nn\nmust be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose total size exceeds 4G elements, the fastest changing dimension must be even.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\nrank[In]\n– Dimensionality of the transform (1, 2, or 3).\nn[In]\n– Array of size\nrank\n, describing the size of each dimension.\ninembed[In]\n– Pointer of size\nrank\nthat indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored.\nistride[In]\n– Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension.\nidist[In]\n– Indicates the distance between the first element of two consecutive signals in a batch of the input data.\nonembed[In]\n– Pointer of size\nrank\nthat indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored.\nostride[In]\n– Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension.\nodist[In]\n– Indicates the distance between the first element of two consecutive signals in a batch of the output data.\ntype[In]\n– The transform data type (e.g.,\nCUFFT_R2C\nfor single precision real to complex).\nbatch[In]\n– Batch size for this transform.\n*workSize[In]\n– Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements.\n*workSize[Out]\n– Pointer to the size of the work area.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully returned the size of the work space.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_ALLOC_FAILED\n– The allocation of GPU resources for the plan failed.\nCUFFT_INVALID_VALUE\n– One or more invalid parameters were passed to the API.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_SIZE\n– One or more of the parameters is not a supported size.\n3.6.6.\ncufftXtGetSizeMany()\n\ncufftResult\ncufftXtGetSizeMany\n(\ncufftHandle\nplan\n,\nint\nrank\n,\nlong\nlong\nint\n*\nn\n,\nlong\nlong\nint\n*\ninembed\n,\nlong\nlong\nint\nistride\n,\nlong\nlong\nint\nidist\n,\ncudaDataType\ninputtype\n,\nlong\nlong\nint\n*\nonembed\n,\nlong\nlong\nint\nostride\n,\nlong\nlong\nint\nodist\n,\ncudaDataType\noutputtype\n,\nlong\nlong\nint\nbatch\n,\nsize_t\n*\nworkSize\n,\ncudaDataType\nexecutiontype\n)\n;\n\nThis call gives a more accurate estimate of the work area size required for a plan than\ncufftEstimateSizeMany()\n, given the specified parameters that match signature of\ncufftXtMakePlanMany\nfunction, and taking into account any plan settings that may have been made. If a work area size of 0 is returned it means no temporary storage is needed for evaluation.\nFor more information about valid combinations of\ninputtype\n,\noutputtype\nand\nexecutiontype\nparameters please refer to documentation of\ncufftXtMakePlanMany\nfunction.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\nrank[In]\n– Dimensionality of the transform (1, 2, or 3).\nn[In]\n– Array of size\nrank\n, describing the size of each dimension.\ninembed[In]\n– Pointer of size\nrank\nthat indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored.\nistride[In]\n– Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension.\nidist[In]\n– Indicates the distance between the first element of two consecutive signals in a batch of the input data.\ninputtype[In]\n(\ncudaDataType\n) – Type of input data.\nonembed[In]\n– Pointer of size\nrank\nthat indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored.\nostride[In]\n– Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension.\nodist[In]\n– Indicates the distance between the first element of two consecutive signals in a batch of the output data.\noutputtype[In]\n(\ncudaDataType\n) – Type of output data.\nbatch[In]\n– Batch size for this transform.\n*workSize[In]\n– Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements.\nexecutiontype[In]\n(\ncudaDataType\n) – Type of data to be used for computations.\n*workSize[Out]\n– Pointer to the size of the work area.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully returned the size of the work space.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_ALLOC_FAILED\n– The allocation of GPU resources for the plan failed.\nCUFFT_INVALID_VALUE\n– One or more invalid parameters were passed to the API.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_SIZE\n– One or more of the parameters is not a supported size.\n3.7.\ncufftGetSize()\n\ncufftResult\ncufftGetSize\n(\ncufftHandle\nplan\n,\nsize_t\n*\nworkSize\n)\n;\n\nOnce plan generation has been done, either with the original API or the extensible API, this call returns the actual size of the work area required to support the plan. Callers who choose to manage work area allocation within their application must use this call after plan generation, and after any\ncufftSet*()\ncalls subsequent to plan generation, if those calls might alter the required work space size.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\n*workSize[In]\n– Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements.\n*workSize[Out]\n– Pointer to the size of the work area.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully returned the size of the work space.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\n3.8.\ncuFFT Caller Allocated Work Area Support\n\n3.8.1.\ncufftSetAutoAllocation()\n\ncufftResult\ncufftSetAutoAllocation\n(\ncufftHandle\nplan\n,\nint\nautoAllocate\n)\n;\n\ncufftSetAutoAllocation()\nindicates that the caller intends to allocate and manage work areas for plans that have been generated. cuFFT default behavior is to allocate the work area at plan generation time. If\ncufftSetAutoAllocation()\nhas been called with autoAllocate set to 0 (“false”) prior to one of the\ncufftMakePlan*()\ncalls, cuFFT does not allocate the work area. This is the preferred sequence for callers wishing to manage work area allocation.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\nautoAllocate[In]\n– Indicates whether to allocate work area.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully returned the size of the work space.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\n3.8.2.\ncufftSetWorkArea()\n\ncufftResult\ncufftSetWorkArea\n(\ncufftHandle\nplan\n,\nvoid\n*\nworkArea\n)\n;\n\ncufftSetWorkArea()\noverrides the work area pointer associated with a plan. If the work area was auto-allocated, cuFFT frees the auto-allocated space. The\ncufftExec*()\ncalls assume that the work area pointer is valid and that it points to a contiguous region in device memory that does not overlap with any other work area. If this is not the case, results are indeterminate.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\n*workArea[In]\n– Pointer to\nworkArea\n. For multiple GPUs, multiple work area pointers must be given.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully returned the size of the work space.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\n3.8.3.\ncufftXtSetWorkAreaPolicy()\n\ncufftResult\ncufftXtSetWorkAreaPolicy\n(\ncufftHandle\nplan\n,\ncufftXtWorkAreaPolicy\npolicy\n,\nsize_t\n*\nworkSize\n)\n;\n\ncufftXtSetWorkAreaPolicy()\nindicates that the caller intends to change work area size for a given plan handle. cuFFT’s default behavior is to allocate the work area at plan generation time with a default size that depends on the plan type and other parameters. If\ncufftXtSetWorkAreaPolicy()\nhas been called with the\npolicy\nparameter set to\nCUFFT_WORKAREA_MINIMAL\n, cuFFT will attempt to re-plan the handle to use zero bytes of work area memory. If the\ncufftXtSetWorkAreaPolicy()\ncall is successful the auto-allocated work area memory is released.\nCurrently the policies\nCUFFT_WORKAREA_PERFORMANCE\n,\nCUFFT_WORKAREA_USER\nand the\nworkSize\nparameter are not supported and reserved for use in future cuFFT releases.\nThis function can be called once per lifetime of a plan handle.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\npolicy[In]\n– Type of work area policy to apply.\n*workSize[In]\n– Reserved for future use.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully returned the size of the work space.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_INVALID_SIZE\n– FFT size does not allow use of the selected policy.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\n3.9.\ncuFFT Execution\n\n3.9.1.\ncufftExecC2C() and cufftExecZ2Z()\n\ncufftResult\ncufftExecC2C\n(\ncufftHandle\nplan\n,\ncufftComplex\n*\nidata\n,\ncufftComplex\n*\nodata\n,\nint\ndirection\n)\n;\n\ncufftResult\ncufftExecZ2Z\n(\ncufftHandle\nplan\n,\ncufftDoubleComplex\n*\nidata\n,\ncufftDoubleComplex\n*\nodata\n,\nint\ndirection\n)\n;\n\ncufftExecC2C()\n(\ncufftExecZ2Z()\n) executes a single-precision (double-precision) complex-to-complex transform plan in the transform direction as specified by\ndirection\nparameter. cuFFT uses the GPU memory pointed to by the\nidata\nparameter as input data. This function stores the Fourier coefficients in the\nodata\narray. If\nidata\nand\nodata\nare the same, this method does an in-place transform.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\nidata[In]\n– Pointer to the complex input data (in GPU memory) to transform.\nodata[In]\n– Pointer to the complex output data (in GPU memory).\ndirection[In]\n– The transform direction:\nCUFFT_FORWARD\nor\nCUFFT_INVERSE\n.\nodata[Out]\n– ontains the complex Fourier coefficients.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully returned the size of the work space.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_INVALID_VALUE\n– At least one of the parameters\nidata\n,\nodata\n, and\ndirection\nis not valid.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_EXEC_FAILED\n– cuFFT failed to execute the transform on the GPU.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\n3.9.2.\ncufftExecR2C() and cufftExecD2Z()\n\ncufftResult\ncufftExecR2C\n(\ncufftHandle\nplan\n,\ncufftReal\n*\nidata\n,\ncufftComplex\n*\nodata\n)\n;\n\ncufftResult\ncufftExecD2Z\n(\ncufftHandle\nplan\n,\ncufftDoubleReal\n*\nidata\n,\ncufftDoubleComplex\n*\nodata\n)\n;\n\ncufftExecR2C()\n(\ncufftExecD2Z()\n) executes a single-precision (double-precision) real-to-complex, implicitly forward, cuFFT transform plan. cuFFT uses as input data the GPU memory pointed to by the\nidata\nparameter. This function stores the nonredundant Fourier coefficients in the\nodata\narray. Pointers to\nidata\nand\nodata\nare both required to be aligned to\ncufftComplex\ndata type in single-precision transforms and\ncufftDoubleComplex\ndata type in double-precision transforms. If\nidata\nand\nodata\nare the same, this method does an in-place transform. Note the data layout differences between in-place and out-of-place transforms as described in\nParameter cufftType\n.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\nidata[In]\n– Pointer to the real input data (in GPU memory) to transform.\nodata[In]\n– Pointer to the complex output data (in GPU memory).\nodata[Out]\n– Contains the complex Fourier coefficients.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully returned the size of the work space.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_INVALID_VALUE\n– At least one of the parameters\nidata\nand\nodata\nis not valid.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_EXEC_FAILED\n– cuFFT failed to execute the transform on the GPU.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\n3.9.3.\ncufftExecC2R() and cufftExecZ2D()\n\ncufftResult\ncufftExecC2R\n(\ncufftHandle\nplan\n,\ncufftComplex\n*\nidata\n,\ncufftReal\n*\nodata\n)\n;\n\ncufftResult\ncufftExecZ2D\n(\ncufftHandle\nplan\n,\ncufftDoubleComplex\n*\nidata\n,\ncufftDoubleReal\n*\nodata\n)\n;\n\ncufftExecC2R()\n(\ncufftExecZ2D()\n) executes a single-precision (double-precision) complex-to-real, implicitly inverse, cuFFT transform plan. cuFFT uses as input data the GPU memory pointed to by the\nidata\nparameter. The input array holds only the nonredundant complex Fourier coefficients. This function stores the real output values in the\nodata\narray. and pointers are both required to be aligned to\ncufftComplex\ndata type in single-precision transforms and\ncufftDoubleComplex\ntype in double-precision transforms. If\nidata\nand\nodata\nare the same, this method does an in-place transform.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\nidata[In]\n– Pointer to the complex input data (in GPU memory) to transform.\nodata[In]\n– Pointer to the real output data (in GPU memory).\nodata[Out]\n– Contains the real output data.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully executed the FFT plan.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_INVALID_VALUE\n– At least one of the parameters\nidata\nand\nodata\nis not valid.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_EXEC_FAILED\n– cuFFT failed to execute the transform on the GPU.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\n3.9.4.\ncufftXtExec()\n\ncufftResult\ncufftXtExec\n(\ncufftHandle\nplan\n,\nvoid\n*\ninput\n,\nvoid\n*\noutput\n,\nint\ndirection\n)\n;\n\nFunction\ncufftXtExec\nexecutes any cuFFT transform regardless of precision and type. In case of complex-to-real and real-to-complex transforms\ndirection\nparameter is ignored. cuFFT uses the GPU memory pointed to by the\ninput\nparameter as input data. This function stores the Fourier coefficients in the\noutput\narray. If\ninput\nand\noutput\nare the same, this method does an in-place transform.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\ninput[In]\n– Pointer to the input data (in GPU memory) to transform.\noutput[In]\n– Pointer to the output data (in GPU memory).\ndirection[In]\n– The transform direction:\nCUFFT_FORWARD\nor\nCUFFT_INVERSE\n. Ignored for complex-to-real and real-to-complex transforms.\noutput[Out]\n– Contains the complex Fourier coefficients.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully executed the FFT plan.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_INVALID_VALUE\n– At least one of the parameters\nidata\n,\nodata\n, and\ndirection\nis not valid.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_EXEC_FAILED\n– cuFFT failed to execute the transform on the GPU.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\n3.9.5.\ncufftXtExecDescriptor()\n\ncufftResult\ncufftXtExecDescriptor\n(\ncufftHandle\nplan\n,\ncudaLibXtDesc\n*\ninput\n,\ncudaLibXtDesc\n*\noutput\n,\nint\ndirection\n)\n;\n\nFunction\ncufftXtExecDescriptor()\nexecutes any cuFFT transform regardless of precision and type. In case of complex-to-real and real-to-complex transforms\ndirection\nparameter is ignored. cuFFT uses the GPU memory pointed to by\ncudaLibXtDesc\n*input\ndescriptor as input data and\ncudaLibXtDesc\n*output\nas output data.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\ninput[In]\n– Pointer to the complex input data (in GPU memory) to transform.\noutput[In]\n– Pointer to the complex output data (in GPU memory).\ndirection[In]\n– The transform direction:\nCUFFT_FORWARD\nor\nCUFFT_INVERSE\n. Ignored for complex-to-real and real-to-complex transforms.\nidata[Out]\n– Contains the complex Fourier coefficients.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully executed the FFT plan.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_INVALID_VALUE\n– At least one of the parameters\nidata\nand\ndirection\nis not valid.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_EXEC_FAILED\n– cuFFT failed to execute the transform on the GPU.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_DEVICE\n– An invalid GPU index was specified in a descriptor.\n3.10.\ncuFFT and Multiple GPUs\n\n3.10.1.\ncufftXtSetGPUs()\n\ncufftResult\ncufftXtSetGPUs\n(\ncufftHandle\nplan\n,\nint\nnGPUs\n,\nint\n*\nwhichGPUs\n)\n;\n\ncufftXtSetGPUs()\nidentifies which GPUs are to be used with the plan. As in the single GPU case\ncufftCreate()\ncreates a plan and\ncufftMakePlan*()\ndoes the plan generation. In cuFFT prior to 10.4.0, this call will return an error if a non-default stream has been associated with the plan.\nNote that the call to\ncufftXtSetGPUs()\nmust occur after the call to\ncufftCreate()\nand prior to the call to\ncufftMakePlan*()\n. Parameter\nwhichGPUs\nof\ncufftXtSetGPUs()\nfunction determines ordering of the GPUs with respect to data decomposition (first data chunk is placed on GPU denoted by first element of\nwhichGPUs\n).\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\nnGPUs[In]\n– Number of GPUs to use.\nwhichGPUs[In]\n– The GPUs to use.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully set the GPUs to use.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle, or a\nnon-default stream has been associated with the plan in cuFFT prior to 10.4.0\n.\nCUFFT_ALLOC_FAILED\n– The allocation of GPU resources for the plan failed.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_VALUE\n– The requested number of GPUs was less than 2 or more than 8.\nCUFFT_INVALID_DEVICE\n– An invalid GPU index was specified.\nCUFFT_INVALID_SIZE\n– Transform size that\nplan\nwas created for does not meet minimum size criteria.\n3.10.2.\ncufftXtSetWorkArea()\n\ncufftResult\ncufftXtSetWorkArea\n(\ncufftHandle\nplan\n,\nvoid\n*\n*\nworkArea\n)\n;\n\ncufftXtSetWorkArea()\noverrides the work areas associated with a plan. If the work area was auto-allocated, cuFFT frees the auto-allocated space. The\ncufftXtExec*()\ncalls assume that the work area is valid and that it points to a contiguous region in each device memory that does not overlap with any other work area. If this is not the case, results are indeterminate.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\nworkArea[In]\n– Pointer to the pointers to workArea.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully set the GPUs to use.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_DEVICE\n– A GPU associated with the plan could not be selected.\n3.10.3.\ncuFFT Multiple GPU Execution\n\n3.10.3.1.\ncufftXtExecDescriptorC2C() and cufftXtExecDescriptorZ2Z()\n\ncufftResult\ncufftXtExecDescriptorC2C\n(\ncufftHandle\nplan\n,\ncudaLibXtDesc\n*\ninput\n,\ncudaLibXtDesc\n*\noutput\n,\nint\ndirection\n)\n;\n\ncufftResult\ncufftXtExecDescriptorZ2Z\n(\ncufftHandle\nplan\n,\ncudaLibXtDesc\n*\ninput\n,\ncudaLibXtDesc\n*\noutput\n,\nint\ndirection\n)\n;\n\ncufftXtExecDescriptorC2C()\n(\ncufftXtExecDescriptorZ2Z()\n) executes a single-precision (double-precision) complex-to-complex transform plan in the transform direction as specified by\ndirection\nparameter. cuFFT uses the GPU memory pointed to by\ncudaLibXtDesc\n*input\nas input data. Since only in-place multiple GPU functionality is supported, this function also stores the result in the\ncudaLibXtDesc\n*input\narrays.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\n*input[In]\n– Pointer to the complex input data (in GPU memory) to transform.\n*output[In]\n– Pointer to the complex output data (in GPU memory).\ndirection[In]\n– The transform direction:\nCUFFT_FORWARD\nor\nCUFFT_INVERSE\n.\ninput[Out]\n– Contains the complex Fourier coefficients.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully executed the FFT plan.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_INVALID_VALUE\n– At least one of the parameters\ninput\nand\ndirection\nis not valid.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_EXEC_FAILED\n– cuFFT failed to execute the transform on the GPU.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_DEVICE\n– An invalid GPU index was specified in a descriptor.\n3.10.3.2.\ncufftXtExecDescriptorR2C() and cufftXtExecDescriptorD2Z()\n\ncufftResult\ncufftXtExecDescriptorR2C\n(\ncufftHandle\nplan\n,\ncudaLibXtDesc\n*\ninput\n,\ncudaLibXtDesc\n*\noutput\n)\n;\n\ncufftResult\ncufftXtExecDescriptorD2Z\n(\ncufftHandle\nplan\n,\ncudaLibXtDesc\n*\ninput\n,\ncudaLibXtDesc\n*\noutput\n)\n;\n\ncufftXtExecDescriptorR2C()\n(\ncufftXtExecDescriptorD2Z()\n) executes a single-precision (double-precision) real-to-complex transform plan. cuFFT uses the GPU memory pointed to by\ncudaLibXtDesc\n*input\nas input data. Since only in-place multiple GPU functionality is supported, this function also stores the result in the\ncudaLibXtDesc\n*input\narrays.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\n*input[In]\n– Pointer to the complex input data (in GPU memory) to transform.\n*output[In]\n– Pointer to the complex output data (in GPU memory).\ninput[Out]\n– Contains the complex Fourier coefficients\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully executed the FFT plan.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_INVALID_VALUE\n– At least one of the parameters\ninput\nand\ndirection\nis not valid.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_EXEC_FAILED\n– cuFFT failed to execute the transform on the GPU.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_DEVICE\n– An invalid GPU index was specified in a descriptor.\n3.10.3.3.\ncufftXtExecDescriptorC2R() and cufftXtExecDescriptorZ2D()\n\ncufftResult\ncufftXtExecDescriptorC2R\n(\ncufftHandle\nplan\n,\ncudaLibXtDesc\n*\ninput\n,\ncudaLibXtDesc\n*\noutput\n)\n;\n\ncufftResult\ncufftXtExecDescriptorZ2D\n(\ncufftHandle\nplan\n,\ncudaLibXtDesc\n*\ninput\n,\ncudaLibXtDesc\n*\noutput\n)\n;\n\ncufftXtExecDescriptorC2R()\n(\ncufftXtExecDescriptorZ2D()\n) executes a single-precision (double-precision) complex-to-real transform plan in the transform direction as specified by\ndirection\nparameter. cuFFT uses the GPU memory pointed to by\ncudaLibXtDesc\n*input\nas input data. Since only in-place multiple GPU functionality is supported, this function also stores the result in the\ncudaLibXtDesc\n*input\narrays.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\n*input[In]\n– Pointer to the complex input data (in GPU memory) to transform.\n*output[In]\n– Pointer to the complex output data (in GPU memory).\ninput[Out]\n– Contains the complex Fourier coefficients.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully executed the FFT plan.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_INVALID_VALUE\n– At least one of the parameters\ninput\nand\ndirection\nis not valid.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_EXEC_FAILED\n– cuFFT failed to execute the transform on the GPU.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_DEVICE\n– An invalid GPU index was specified in a descriptor.\n3.10.4.\nMemory Allocation and Data Movement Functions\n\nMultiple GPU cuFFT execution functions assume a certain data layout in terms of what input data has been copied to which GPUs prior to execution, and what output data resides in which GPUs post execution. The following functions assist in allocation, setup and retrieval of the data. They must be called after the call to\ncufftMakePlan*()\n.\n3.10.4.1.\ncufftXtMalloc()\n\ncufftResult\ncufftXtMalloc\n(\ncufftHandle\nplan\n,\ncudaLibXtDesc\n*\n*\ndescriptor\n,\ncufftXtSubFormat\nformat\n)\n;\n\ncufftXtMalloc()\nallocates a descriptor, and all memory for data in GPUs associated with the plan, and returns a pointer to the descriptor. Note the descriptor contains an array of device pointers so that the application may preprocess or postprocess the data on the GPUs. The enumerated parameter\ncufftXtSubFormat_t\nindicates if the buffer will be used for input or output.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\n**descriptor[In]\n– Pointer to a pointer to a\ncudaLibXtDesc\nobject.\nformat[In]\n– cufftXtSubFormat`` value.\n**descriptor[Out]\n– Pointer to a pointer to a\ncudaLibXtDesc\nobject.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully allows user to allocate descriptor and GPU memory.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle or it is not a multiple GPU\nplan\n.\nCUFFT_ALLOC_FAILED\n– The allocation of GPU resources for the plan failed.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_DEVICE\n– An invalid GPU index was specified in the descriptor.\n3.10.4.1.1.\nParameter cufftXtSubFormat\n\ncufftXtSubFormat_t\nis an enumerated type that indicates if the buffer will be used for input or output and the ordering of the data.\ntypedef\nenum\ncufftXtSubFormat_t\n{\nCUFFT_XT_FORMAT_INPUT\n,\n//by default input is in linear order across GPUs\nCUFFT_XT_FORMAT_OUTPUT\n,\n//by default output is in scrambled order depending on transform\nCUFFT_XT_FORMAT_INPLACE\n,\n//by default inplace is input order, which is linear across GPUs\nCUFFT_XT_FORMAT_INPLACE_SHUFFLED\n,\n//shuffled output order after execution of the transform\nCUFFT_FORMAT_UNDEFINED\n}\ncufftXtSubFormat\n;\n3.10.4.2.\ncufftXtFree()\n\ncufftResult\ncufftXtFree\n(\ncudaLibXtDesc\n*\ndescriptor\n)\n;\n\ncufftXtFree()\nfrees the descriptor and all memory associated with it. The descriptor and memory must have been returned by a previous call to\ncufftXtMalloc()\n.\nParameters\n*descriptor[In]\n– Pointer to a\ncudaLibXtDesc\nobject.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully allows user to free descriptor and associated GPU memory.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\n3.10.4.3.\ncufftXtMemcpy()\n\ncufftResult\ncufftXtMemcpy\n(\ncufftHandle\nplan\n,\nvoid\n*\ndstPointer\n,\nvoid\n*\nsrcPointer\n,\ncufftXtCopyType\ntype\n)\n;\n\ncufftXtMemcpy()\ncopies data between buffers on the host and GPUs or between GPUs. The enumerated parameter\ncufftXtCopyType_t\nindicates the type and direction of transfer. Calling\ncufftXtMemcpy\nfunction for multi-GPU batched FFT plans with\nCUFFT_COPY_DEVICE_TO_DEVICE\ntransfer type is not supported.\nNote that starting from CUDA 11.2 (cuFFT 10.4.0),\ncufftSetStream()\nis supported on multi-GPU plans. When associating a stream with a plan,\ncufftXtMemcpy()\nremains synchronous across the multiple GPUs.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\ndstPointer[In]\n– Pointer to the destination address(es).\nsrcPointer[In]\n– Pointer to the source address(es).\ntype[In]\n–\ncufftXtCopyType\nvalue.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully allows user to copy memory between host and GPUs or between GPUs.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle.\nCUFFT_INVALID_VALUE\n– One or more invalid parameters were passed to the API.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\nCUFFT_INVALID_DEVICE\n– An invalid GPU index was specified in a descriptor.\n3.10.4.3.1.\nParameter cufftXtCopyType\n\ncufftXtCopyType_t\nis an enumerated type for multiple GPU functions that specifies the type of copy for\ncufftXtMemcpy()\n.\nCUFFT_COPY_HOST_TO_DEVICE\ncopies data from a contiguous host buffer to multiple device buffers, in the layout cuFFT requires for input data.\ndstPointer\nmust point to a\ncudaLibXtDesc\nstructure, and\nsrcPointer\nmust point to a host memory buffer.\nCUFFT_COPY_DEVICE_TO_HOST\ncopies data from multiple device buffers, in the layout cuFFT produces for output data, to a contiguous host buffer.\ndstPointer\nmust point to a host memory buffer, and\nsrcPointer\nmust point to a\ncudaLibXtDesc\nstructure.\nCUFFT_COPY_DEVICE_TO_DEVICE\ncopies data from multiple device buffers, in the layout cuFFT produces for output data, to multiple device buffers, in the layout cuFFT requires for input data.\ndstPointer\nand\nsrcPointer\nmust point to different\ncudaLibXtDesc\nstructures (and therefore memory locations). That is, the copy cannot be in-place. Note that device_to_device\ncufftXtMemcpy()\nfor 2D and 3D data is not currently supported.\ntypedef\nenum\ncufftXtCopyType_t\n{\nCUFFT_COPY_HOST_TO_DEVICE\n,\nCUFFT_COPY_DEVICE_TO_HOST\n,\nCUFFT_COPY_DEVICE_TO_DEVICE\n}\ncufftXtCopyType\n;\n3.10.5.\nGeneral Multiple GPU Descriptor Types\n\n3.10.5.1.\ncudaXtDesc\n\nA descriptor type used in multiple GPU routines that contains information about the GPUs and their memory locations.\nstruct\ncudaXtDesc_t\n{\nint\nversion\n;\n//descriptor version\nint\nnGPUs\n;\n//number of GPUs\nint\nGPUs\n[\nMAX_CUDA_DESCRIPTOR_GPUS\n];\n//array of device IDs\nvoid\n*\ndata\n[\nMAX_CUDA_DESCRIPTOR_GPUS\n];\n//array of pointers to data, one per GPU\nsize_t\nsize\n[\nMAX_CUDA_DESCRIPTOR_GPUS\n];\n//array of data sizes, one per GPU\nvoid\n*\ncudaXtState\n;\n//opaque CUDA utility structure\n};\ntypedef\nstruct\ncudaXtDesc_t\ncudaXtDesc\n;\n3.10.5.2.\ncudaLibXtDesc\n\nA descriptor type used in multiple GPU routines that contains information about the library used.\nstruct\ncudaLibXtDesc_t\n{\nint\nversion\n;\n//descriptor version\ncudaXtDesc\n*\ndescriptor\n;\n//multi-GPU memory descriptor\nlibFormat\nlibrary\n;\n//which library recognizes the format\nint\nsubFormat\n;\n//library specific enumerator of sub formats\nvoid\n*\nlibDescriptor\n;\n//library specific descriptor e.g. FFT transform plan object\n};\ntypedef\nstruct\ncudaLibXtDesc_t\ncudaLibXtDesc\n;\n3.11.\ncuFFT Callbacks\n\n3.11.1.\ncufftXtSetJITCallback()\n\ncufftResult\ncufftXtSetJITCallback\n(\ncufftHandle\nplan\n,\nconst\nchar\n*\ncallbackSymbolName\n,\nconst\nvoid\n*\ncallbackFatbin\n,\nsize_t\ncallbackFatbinSize\n,\ncufftXtCallbackType\ntype\n,\nvoid\n*\n*\ncaller_info\n)\n\ncufftXtSetJITCallback()\nspecifies a load or store LTO callback to be used with the plan.\nThis call is valid only after a call to\ncufftCreate()\n, but before calling\ncufftMakePlan*()\n, which does the plan generation.\nIf there was already an LTO callback of this type associated with the plan, this new callback routine replaces it. If the new callback requires shared memory, you must call\ncufftXtSetCallbackSharedSize\nwith the amount of shared memory the callback function needs. cuFFT will not retain the amount of shared memory associated with the previous callback if the callback function is changed.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\ncallbackSymbolName[In]\n– null-terminated C string containing the (unmangled) callback symbol name (i.e. the name of the LTO callback routine). This symbol name will be runtime-compiled, and modifiers such as\nextern\n\"C\"\nor\nnamespace\nare not supported.\ncallbackFatbin[In]\n– Pointer to the location in host memory where the callback device function is located, after being compiled into LTO-IR with nvcc or NVRTC.\ncallbackFatbinSize[In]\n– Size in bytes of the data pointed at by\ncallbackFatbin\n.\ntype[In]\n– Type of callback routine.\ncallerInfo[In]\n– Optional array of device pointers to caller specific information, one per GPU.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully associated the callback function with the plan.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not valid (e.g. the handle was already used to make a plan).\nCUFFT_INVALID_TYPE\n– The callback type is not valid.\nCUFFT_INVALID_VALUE\n– The pointer to the callback device function is invalid or the size is\n0\n.\nCUFFT_NOT_SUPPORTED\n– The functionality is not supported yet (e.g. multi-GPU with LTO callbacks).\nCUFFT_INTERNAL_ERROR\n– cuFFT encountered an unexpected error, likely in the runtime linking process; error codes will be expanded in a future release.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\n3.11.2.\ncufftXtSetCallback()\n\ncufftResult\ncufftXtSetCallback\n(\ncufftHandle\nplan\n,\nvoid\n*\n*\ncallbackRoutine\n,\ncufftXtCallbackType\ntype\n,\nvoid\n*\n*\ncallerInfo\n)\n\ncufftXtSetCallback()\nspecifies a load or store legacy callback to be used with the plan. This call is valid only after a call to\ncufftMakePlan*()\n, which does the plan generation. If there was already a legacy callback of this type associated with the plan, this new callback routine replaces it. If the new callback requires shared memory, you must call\ncufftXtSetCallbackSharedSize\nwith the amount of shared memory it needs. cuFFT will not retain the amount of shared memory associated with the previous callback.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\ncallbackRoutine[In]\n– Array of callback routine pointers, one per GPU.\ntype[In]\n– Type of callback routine.\ncallerInfo[In]\n– Optional array of device pointers to caller specific information, one per GPU.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully associated the callback function with the plan.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle, or a\nnon-default stream has been associated with the plan in cuFFT prior to 10.4.0\n.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_SETUP_FAILED\n– The cuFFT library failed to initialize.\n3.11.3.\ncufftXtClearCallback()\n\ncufftResult\ncufftXtClearCallback\n(\ncufftHandle\nplan\n,\ncufftXtCallbackType\ntype\n)\n\ncufftXtClearCallback()\ninstructs cuFFT to stop invoking the specified legacy callback type when executing the plan. Only the specified callback is cleared. If no callback of this type had been specified, the return code is\nCUFFT_SUCCESS\n.\nNote that this method\ndoes not work\nwith LTO callbacks.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\ntype[In]\n– Type of callback routine.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully disassociated the callback function with the plan.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle, or a\nnon-default stream has been associated with the plan in cuFFT prior to 10.4.0\n.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\n3.11.4.\ncufftXtSetCallbackSharedSize()\n\ncufftResult\ncufftXtSetCallbackSharedSize\n(\ncufftHandle\nplan\n,\ncufftXtCallbackType\ntype\n,\nsize_t\nsharedSize\n)\n\ncufftXtSetCallbackSharedSize()\ninstructs cuFFT to dynamically allocate shared memory at launch time, for use by the callback. The maximum allowable amount of shared memory is 16K bytes. cuFFT passes a pointer to this shared memory to the callback routine at execution time. This shared memory is only valid for the life of the load or store callback operation. During execution, cuFFT may overwrite shared memory for its own purposes.\nParameters\nplan[In]\n–\ncufftHandle\nreturned by\ncufftCreate\n.\ntype[In]\n– Type of callback routine.\nsharedSize[In]\n– Amount of shared memory requested.\nReturn values\nCUFFT_SUCCESS\n– cuFFT will invoke the callback routine with a pointer to the requested amount of shared memory.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle, or a\nnon-default stream has been associated with the plan in cuFFT prior to 10.4.0\n.\nCUFFT_INTERNAL_ERROR\n– An internal driver error was detected.\nCUFFT_ALLOC_FAILED\n– cuFFT will not be able to allocate the requested amount of shared memory.\n3.12.\ncufftSetStream()\n\ncufftResult\ncufftSetStream\n(\ncufftHandle\nplan\n,\ncudaStream_t\nstream\n)\n;\n\nAssociates a CUDA stream with a cuFFT plan. All kernel launches made during plan execution are now done through the associated stream, enabling overlap with activity in other streams (e.g. data copying). The association remains until the plan is destroyed or the stream is changed with another call to\ncufftSetStream()\n.\nNote that starting from CUDA 11.2 (cuFFT 10.4.0),\ncufftSetStream()\nis supported on multi-GPU plans. When associating a stream with a plan,\ncufftXtMemcpy()\nremains synchronous across the multiple GPUs. For previous versions of cuFFT,\ncufftSetStream()\nwill return an error in multiple GPU plans.\nNote that starting from CUDA 12.2 (cuFFT 11.0.8), on multi-GPU plans,\nstream\ncan be associated with any context on any GPU. However, repeated calls to\ncufftSetStream()\nwith streams from different contexts incur a small time penalty. Optimal performance is obtained when repeated calls to\ncufftSetStream\nuse streams from the same CUDA context.\nParameters\nplan[In]\n– The\ncufftHandle\nobject to associate with the stream.\nstream[In]\n– A valid CUDA stream created with\ncudaStreamCreate()\n;\n0\nfor the default stream.\nReturn values\nCUFFT_SUCCESS\n– The stream was associated with the plan.\nCUFFT_INVALID_PLAN\n– The\nplan\nparameter is not a valid handle, or plan is multi-gpu in cuFFT version prior to 10.4.0.\n3.13.\ncufftGetVersion()\n\ncufftResult\ncufftGetVersion\n(\nint\n*\nversion\n)\n;\n\nReturns the version number of cuFFT.\nParameters\n*version[In]\n– Pointer to the version number.\n*version[Out]\n– Contains the version number.\nReturn values\nCUFFT_SUCCESS\n– cuFFT successfully returned the version number.\n3.14.\ncufftGetProperty()\n\ncufftResult\ncufftGetProperty\n(\nlibraryPropertyType\ntype\n,\nint\n*\nvalue\n)\n;\n\nReturn in\n*value\nthe number for the property described by\ntype\nof the dynamically linked CUFFT library.\nParameters\ntype[In]\n– CUDA library property.\nvalue[Out]\n– Contains the integer value for the requested property.\nReturn values\nCUFFT_SUCCESS\n– The property value was successfully returned.\nCUFFT_INVALID_TYPE\n– The property type is not recognized.\nCUFFT_INVALID_VALUE\n–\nvalue\nis\nNULL\n.\n3.15.\ncuFFT Types\n\n3.15.1.\nNull cufftHandle\n\nThe cuFFT library provides a null plan handle that can be safely destroyed with\ncufftDestroy()\nas a no-op.\n#define CUFFT_PLAN_NULL -1\n3.15.2.\nParameter cufftType\n\nThe cuFFT library supports complex- and real-data transforms. The\ncufftType\ndata type is an enumeration of the types of transform data supported by cuFFT.\ntypedef\nenum\ncufftType_t\n{\nCUFFT_R2C\n=\n0x2a\n,\n// Real to complex (interleaved)\nCUFFT_C2R\n=\n0x2c\n,\n// Complex (interleaved) to real\nCUFFT_C2C\n=\n0x29\n,\n// Complex to complex (interleaved)\nCUFFT_D2Z\n=\n0x6a\n,\n// Double to double-complex (interleaved)\nCUFFT_Z2D\n=\n0x6c\n,\n// Double-complex (interleaved) to double\nCUFFT_Z2Z\n=\n0x69\n// Double-complex to double-complex (interleaved)\n}\ncufftType\n;\n3.15.3.\nParameters for Transform Direction\n\nThe cuFFT library defines forward and inverse Fast Fourier Transforms according to the sign of the complex exponential term.\n#define CUFFT_FORWARD -1\n#define CUFFT_INVERSE 1\ncuFFT performs un-normalized FFTs; that is, performing a forward FFT on an input data set followed by an inverse FFT on the resulting set yields data that is equal to the input, scaled by the number of elements. Scaling either transform by the reciprocal of the size of the data set is left for the user to perform as seen fit.\n3.15.4.\nType definitions for callbacks\n\nThe cuFFT library supports callback funtions for all combinations of single or double precision, real or complex data, load or store. These are enumerated in the parameter\ncufftXtCallbackType\n.\ntypedef\nenum\ncufftXtCallbackType_t\n{\nCUFFT_CB_LD_COMPLEX\n=\n0x0\n,\nCUFFT_CB_LD_COMPLEX_DOUBLE\n=\n0x1\n,\nCUFFT_CB_LD_REAL\n=\n0x2\n,\nCUFFT_CB_LD_REAL_DOUBLE\n=\n0x3\n,\nCUFFT_CB_ST_COMPLEX\n=\n0x4\n,\nCUFFT_CB_ST_COMPLEX_DOUBLE\n=\n0x5\n,\nCUFFT_CB_ST_REAL\n=\n0x6\n,\nCUFFT_CB_ST_REAL_DOUBLE\n=\n0x7\n,\nCUFFT_CB_UNDEFINED\n=\n0x8\n}\ncufftXtCallbackType\n;\n3.15.4.1.\nType definitions for LTO callbacks\n\nThe LTO callback function prototypes and pointer type definitions are as follows:\ntypedef\ncufftComplex\n(\n*\ncufftJITCallbackLoadC\n)(\nvoid\n*\ndataIn\n,\nunsigned\nlong\nlong\noffset\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\ncufftDoubleComplex\n(\n*\ncufftJITCallbackLoadZ\n)(\nvoid\n*\ndataIn\n,\nunsigned\nlong\nlong\noffset\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\ncufftReal\n(\n*\ncufftJITCallbackLoadR\n)(\nvoid\n*\ndataIn\n,\nunsigned\nlong\nlong\noffset\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\ncufftDoubleReal\n(\n*\ncufftJITCallbackLoadD\n)(\nvoid\n*\ndataIn\n,\nunsigned\nlong\nlong\noffset\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\nvoid\n(\n*\ncufftJITCallbackStoreC\n)(\nvoid\n*\ndataOut\n,\nunsigned\nlong\nlong\noffset\n,\ncufftComplex\nelement\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\nvoid\n(\n*\ncufftJITCallbackStoreZ\n)(\nvoid\n*\ndataOut\n,\nunsigned\nlong\nlong\noffset\n,\ncufftDoubleComplex\nelement\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\nvoid\n(\n*\ncufftJITCallbackStoreR\n)(\nvoid\n*\ndataOut\n,\nunsigned\nlong\nlong\noffset\n,\ncufftReal\nelement\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\nvoid\n(\n*\ncufftJITCallbackStoreD\n)(\nvoid\n*\ndataOut\n,\nunsigned\nlong\nlong\noffset\n,\ncufftDoubleReal\nelement\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\nNotice the difference in the type of the\noffset\nparameter (\nunsigned\nlong\nlong\n) vs. legacy callbacks (which use\nsize_t\n).\n3.15.4.2.\nType definitions for legacy callbacks\n\nThe legacy callback function prototypes and pointer type definitions are as follows:\ntypedef\ncufftComplex\n(\n*\ncufftCallbackLoadC\n)(\nvoid\n*\ndataIn\n,\nsize_t\noffset\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\ncufftDoubleComplex\n(\n*\ncufftCallbackLoadZ\n)(\nvoid\n*\ndataIn\n,\nsize_t\noffset\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\ncufftReal\n(\n*\ncufftCallbackLoadR\n)(\nvoid\n*\ndataIn\n,\nsize_t\noffset\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\ncufftDoubleReal\n(\n*\ncufftCallbackLoadD\n)(\nvoid\n*\ndataIn\n,\nsize_t\noffset\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\nvoid\n(\n*\ncufftCallbackStoreC\n)(\nvoid\n*\ndataOut\n,\nsize_t\noffset\n,\ncufftComplex\nelement\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\nvoid\n(\n*\ncufftCallbackStoreZ\n)(\nvoid\n*\ndataOut\n,\nsize_t\noffset\n,\ncufftDoubleComplex\nelement\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\nvoid\n(\n*\ncufftCallbackStoreR\n)(\nvoid\n*\ndataOut\n,\nsize_t\noffset\n,\ncufftReal\nelement\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\ntypedef\nvoid\n(\n*\ncufftCallbackStoreD\n)(\nvoid\n*\ndataOut\n,\nsize_t\noffset\n,\ncufftDoubleReal\nelement\n,\nvoid\n*\ncallerInfo\n,\nvoid\n*\nsharedPointer\n);\n3.15.5.\nOther cuFFT Types\n\n3.15.5.1.\ncufftHandle\n\ntype\ncufftHandle\n\nA handle type used to store and access cuFFT plans. The user receives a handle after creating a cuFFT plan and uses this handle to execute the plan.\ntypedef\nunsigned\nint\ncufftHandle\n;\n3.15.5.2.\ncufftReal\n\nA single-precision, floating-point real data type.\ntypedef\nfloat\ncufftReal\n;\n3.15.5.3.\ncufftDoubleReal\n\nA double-precision, floating-point real data type.\ntypedef\ndouble\ncufftDoubleReal\n;\n3.15.5.4.\ncufftComplex\n\nA single-precision, floating-point complex data type that consists of interleaved real and imaginary components.\ntypedef\ncuComplex\ncufftComplex\n;\n3.15.5.5.\ncufftDoubleComplex\n\nA double-precision, floating-point complex data type that consists of interleaved real and imaginary components.\ntypedef\ncuDoubleComplex\ncufftDoubleComplex\n;\n3.16.\nCommon types\n\n3.16.1.\ncudaDataType\n\nThe\ncudaDataType\ndata type is an enumeration of the types supported by CUDA libraries.\ntypedef\nenum\ncudaDataType_t\n{\nCUDA_R_16F\n=\n2\n,\n// 16 bit real\nCUDA_C_16F\n=\n6\n,\n// 16 bit complex\nCUDA_R_32F\n=\n0\n,\n// 32 bit real\nCUDA_C_32F\n=\n4\n,\n// 32 bit complex\nCUDA_R_64F\n=\n1\n,\n// 64 bit real\nCUDA_C_64F\n=\n5\n,\n// 64 bit complex\nCUDA_R_8I\n=\n3\n,\n// 8 bit real as a signed integer\nCUDA_C_8I\n=\n7\n,\n// 8 bit complex as a pair of signed integers\nCUDA_R_8U\n=\n8\n,\n// 8 bit real as an unsigned integer\nCUDA_C_8U\n=\n9\n// 8 bit complex as a pair of unsigned integers\n}\ncudaDataType\n;\n3.16.2.\nlibraryPropertyType\n\nThe\nlibraryPropertyType\ndata type is an enumeration of library property types. (ie. CUDA version X.Y.Z would yield\nMAJOR_VERSION=X\n,\nMINOR_VERSION=Y\n,\nPATCH_LEVEL=Z\n)\ntypedef\nenum\nlibraryPropertyType_t\n{\nMAJOR_VERSION\n,\nMINOR_VERSION\n,\nPATCH_LEVEL\n}\nlibraryPropertyType\n;\n4.\nMultiple GPU Data Organization\n\nThis chapter explains how data are distributed between the GPUs, before and after a multiple GPU transform. For simplicity, it is assumed in this chapter that the caller has specified GPU 0 and GPU 1 to perform the transform.\n4.1.\nMultiple GPU Data Organization for Batched Transforms\n\nFor batches of transforms, each individual transform is executed on a single GPU. If possible the batches are evenly distributed among the GPUs. For a batch of size\nm\nperformed on\nn\nGPUs, where\nm\nis not divisible by\nn\n, the first\nm\n%\nn\nGPUs will perform\n\\(\\left\\lfloor \\frac{m}{n} \\right\\rfloor+\\ 1\\)\ntransforms. The remaining GPUs will perform\n\\(\\left\\lfloor \\frac{m}{n} \\right\\rfloor\\)\ntransforms. For example, in a batch of 15 transforms performed on 4 GPUs, the first three GPUs would perform 4 transforms, and the last GPU would perform 3 transforms. This approach removes the need for data exchange between the GPUs, and results in nearly perfect scaling for cases where the batch size is divisible by the number of GPUs.\n4.2.\nMultiple GPU Data Organization for Single 2D and 3D Transforms\n\nSingle transforms performed on multiple GPUs require the data to be divided between the GPUs. Then execution takes place in phases. For example with 2 GPUs, for 2D and 3D transforms with even sized dimensions, each GPU does half of the transform in (rank - 1) dimensions. Then data are exchanged between the GPUs so that the final dimension can be processed.\nSince 2D and 3D transforms support sizes other than powers of 2, it is possible that the data can not be evenly distributed among the GPUs. In general for the case of\nn\nGPUs, a dimension of size\nm\nthat is not a multiple of\nn\nwould be distributed such that the first\nm\n%\nn\nGPUs would get one extra row for 2D transforms, one extra plane for 3D transforms.\nTake for example, a 2D transform on 4 GPUs, using an array declared in C as\ndata[x][y]\n, where\nx\nis 65 and\ny\nis 99. The surface is distributed prior to the transform such that GPU 0 receives a surface with dimensions\n[17][99]\n, and GPUs 1…3 receive surfaces with dimensions\n[16][99]\n. After the transform, each GPU again has a portion of the surface, but divided in the y dimension. GPUs 0…2 have surfaces with dimensions\n[65][25]\n. GPU 3 has a surface with dimensions\n[65][24]\nFor a 3D transform on 4 GPUs consider an array declared in C as\ndata[x][y][z]\n, where\nx\nis 103,\ny\nis 122, and\nz\nis 64. The volume is distributed prior to the transform such that each GPUs 0…2 receive volumes with dimensions\n[26][122][64]\n, and GPU 3 receives a volume with dimensions\n[25][122][64]\n. After the transform, each GPU again has a portion of the surface, but divided in the y dimension. GPUs 0 and 1 have a volumes with dimensions\n[103][31][64]\n, and GPUs 2 and 3 have volumes with dimensions\n[103][30][64]\n.\n4.3.\nMultiple-GPU Data Organization for Single 1D Transforms\n\nBy default for 1D transforms, the initial distribution of data to the GPUs is similar to the 2D and 3D cases. For a transform of dimension x on two GPUs, GPU 0 receives data ranging from 0…(x/2-1). GPU 1 receives data ranging from (x/2)…(x-1). Similarly, with 4 GPUs, the data are evenly distributed among all 4 GPUs.\nBefore computation can begin, data are redistributed among the GPUs. It is possible to perform this redistribution in the copy from host memory, in cases where the application does not need to pre-process the data prior to the transform. To do this, the application can create the data descriptor with\ncufftXtMalloc\nusing the sub-format\nCUFFT_XT_FORMAT_1D_INPUT_SHUFFLED\n. This can significantly reduce the time it takes to execute the transform.\ncuFFT performs multiple GPU 1D transforms by decomposing the transform size into factors\nFactor1\nand\nFactor2\n, and treating the data as a grid of size\nFactor1\nx\nFactor2\n. The four steps done to calculate the 1D FFT are:\nFactor1\ntransforms of size\nFactor2\n, data exchange between the GPUs, a pointwise twiddle multiplication, and\nFactor2\ntransforms of size\nFactor1\n.\nTo gain efficiency by overlapping computation with data exchange, cuFFT breaks the whole transform into independent segments or strings, which can be processed while others are in flight. A side effect of this algorithm is that the output of the transform is not in linear order. The output in GPU memory is in strings, each of which is composed of\nFactor2\nsubstrings of equal size. Each substring contains contiguous results starting\nFactor1\nelements subsequent to start of the previous substring. Each string starts substring size elements after the start of the previous string. The strings appear in order, the first half on GPU 0, and the second half on GPU 1. See the example below:\ntransform\nsize\n=\n1024\nnumber\nof\nstrings\n=\n8\nFactor1\n=\n64\nFactor2\n=\n16\nsubstrings\nper\nstring\nfor\noutput\nlayout\nis\nFactor2\n(\n16\n)\nstring\nsize\n=\n1024\n/\n8\n=\n128\nsubstring\nsize\n=\n128\n/\n16\n=\n8\nstride\nbetween\nsubstrings\n=\n1024\n/\n16\n=\nFactor1\n(\n64\n)\nOn\nGPU\n0\n:\nstring\n0\nhas\nsubstrings\nwith\nindices\n0.\n.\n.7\n64.\n.\n.71\n128.\n.\n.135\n...\n960.\n.\n.967\nstring\n1\nhas\nsubstrings\nwith\nindices\n8.\n.\n.15\n72.\n.\n.79\n136.\n.\n.143\n...\n968.\n.\n.975\n...\nOn\nGPU\n1\n:\nstring\n4\nhas\nsubstrings\nwith\nindices\n32.\n.\n.39\n96.\n.\n.103\n160.\n.\n.167\n...\n992.\n.\n.999\n...\nstring\n7\nhas\nsubstrings\nwith\nindices\n56.\n.\n.63\n120.\n.\n.127\n184.\n.\n.191\n...\n1016.\n.\n.1023\nThe cufftXtQueryPlan API allows the caller to retrieve a structure containing the number of strings, the decomposition factors, and (in the case of power of 2 size) some useful mask and shift elements. The example below shows how cufftXtQueryPlan is invoked. It also shows how to translate from an index in the host input array to the corresponding index on the device, and vice versa.\n/*\n* These routines demonstrate the use of cufftXtQueryPlan to get the 1D\n* factorization and convert between permuted and linear indexes.\n*/\n/*\n* Set up a 1D plan that will execute on GPU 0 and GPU1, and query\n* the decomposition factors\n*/\nint\nmain\n(\nint\nargc\n,\nchar\n**\nargv\n){\ncufftHandle\nplan\n;\ncufftResult\nstat\n;\nint\nwhichGPUs\n[\n2\n]\n=\n{\n0\n,\n1\n};\ncufftXt1dFactors\nfactors\n;\nstat\n=\ncufftCreate\n(\n&\nplan\n);\nif\n(\nstat\n!=\nCUFFT_SUCCESS\n)\n{\nprintf\n(\n\"Create error %d\n\\n\n\"\n,\nstat\n);\nreturn\n1\n;\n}\nstat\n=\ncufftXtSetGPUs\n(\nplan\n,\n2\n,\nwhichGPUs\n);\nif\n(\nstat\n!=\nCUFFT_SUCCESS\n)\n{\nprintf\n(\n\"SetGPU error %d\n\\n\n\"\n,\nstat\n);\nreturn\n1\n;\n}\nstat\n=\ncufftMakePlan1d\n(\nplan\n,\nsize\n,\nCUFFT_C2C\n,\n1\n,\nworkSizes\n);\nif\n(\nstat\n!=\nCUFFT_SUCCESS\n)\n{\nprintf\n(\n\"MakePlan error %d\n\\n\n\"\n,\nstat\n);\nreturn\n1\n;\n}\nstat\n=\ncufftXtQueryPlan\n(\nplan\n,\n(\nvoid\n*\n)\n&\nfactors\n,\nCUFFT_QUERY_1D_FACTORS\n);\nif\n(\nstat\n!=\nCUFFT_SUCCESS\n)\n{\nprintf\n(\n\"QueryPlan error %d\n\\n\n\"\n,\nstat\n);\nreturn\n1\n;\n}\nprintf\n(\n\"Factor 1 %zd, Factor2 %zd\n\\n\n\"\n,\nfactors\n.\nfactor1\n,\nfactors\n.\nfactor2\n);\ncufftDestroy\n(\nplan\n);\nreturn\n0\n;\n}\n/*\n* Given an index into a permuted array, and the GPU index return the\n* corresponding linear index from the beginning of the input buffer.\n*\n* Parameters:\n*      factors     input:  pointer to cufftXt1dFactors as returned by\n*                          cufftXtQueryPlan\n*      permutedIx  input:  index of the desired element in the device output\n*                          array\n*      linearIx    output: index of the corresponding input element in the\n*                          host array\n*      GPUix       input:  index of the GPU containing the desired element\n*/\ncufftResult\npermuted2Linear\n(\ncufftXt1dFactors\n*\nfactors\n,\nsize_t\npermutedIx\n,\nsize_t\n*\nlinearIx\n,\nint\nGPUIx\n)\n{\nsize_t\nindexInSubstring\n;\nsize_t\nwhichString\n;\nsize_t\nwhichSubstring\n;\n// the low order bits of the permuted index match those of the linear index\nindexInSubstring\n=\npermutedIx\n&\nfactors\n->\nsubstringMask\n;\n// the next higher bits are the substring index\nwhichSubstring\n=\n(\npermutedIx\n>>\nfactors\n->\nsubstringShift\n)\n&\nfactors\n->\nfactor2Mask\n;\n// the next higher bits are the string index on this GPU\nwhichString\n=\n(\npermutedIx\n>>\nfactors\n->\nstringShift\n)\n&\nfactors\n->\nstringMask\n;\n// now adjust the index for the second GPU\nif\n(\nGPUIx\n)\n{\nwhichString\n+=\nfactors\n->\nstringCount\n/\n2\n;\n}\n// linear index low order bits are the same\n// next higher linear index bits are the string index\n*\nlinearIx\n=\nindexInSubstring\n+\n(\nwhichString\n<<\nfactors\n->\nsubstringShift\n);\n// next higher bits of linear address are the substring index\n*\nlinearIx\n+=\nwhichSubstring\n<<\nfactors\n->\nfactor1Shift\n;\nreturn\nCUFFT_SUCCESS\n;\n}\n/*\n* Given a linear index into a 1D array, return the GPU containing the permuted\n* result, and index from the start of the data buffer for that element.\n*\n* Parameters:\n*      factors     input:  pointer to cufftXt1dFactors as returned by\n*                          cufftXtQueryPlan\n*      linearIx    input:  index of the desired element in the host input\n*                          array\n*      permutedIx  output: index of the corresponding result in the device\n*                          output array\n*      GPUix       output: index of the GPU containing the result\n*/\ncufftResult\nlinear2Permuted\n(\ncufftXt1dFactors\n*\nfactors\n,\nsize_t\nlinearIx\n,\nsize_t\n*\npermutedIx\n,\nint\n*\nGPUIx\n)\n{\nsize_t\nindexInSubstring\n;\nsize_t\nwhichString\n;\nsize_t\nwhichSubstring\n;\nsize_t\nwhichStringMask\n;\nint\nwhichStringShift\n;\nif\n(\nlinearIx\n>=\nfactors\n->\nsize\n)\n{\nreturn\nCUFFT_INVALID_VALUE\n;\n}\n// get a useful additional mask and shift count\nwhichStringMask\n=\nfactors\n->\nstringCount\n-1\n;\nwhichStringShift\n=\n(\nfactors\n->\nfactor1Shift\n+\nfactors\n->\nfactor2Shift\n)\n-\nfactors\n->\nstringShift\n;\n// the low order bits identify the index within the substring\nindexInSubstring\n=\nlinearIx\n&\nfactors\n->\nsubstringMask\n;\n// first determine which string has our linear index.\n// the low order bits indentify the index within the substring.\n// the next higher order bits identify which string.\nwhichString\n=\n(\nlinearIx\n>>\nfactors\n->\nsubstringShift\n)\n&\nwhichStringMask\n;\n// the first stringCount/2 strings are in the first GPU,\n// the rest are in the second.\n*\nGPUIx\n=\nwhichString\n/\n(\nfactors\n->\nstringCount\n/\n2\n);\n// next determine which substring within the string has our index\n// the substring index is in the next higher order bits of the index\nwhichSubstring\n=\n(\nlinearIx\n>>\n(\nfactors\n->\nsubstringShift\n+\nwhichStringShift\n))\n&\nfactors\n->\nfactor2Mask\n;\n// now we can re-assemble the index\n*\npermutedIx\n=\nindexInSubstring\n;\n*\npermutedIx\n+=\nwhichSubstring\n<<\nfactors\n->\nsubstringShift\n;\nif\n(\n!*\nGPUIx\n)\n{\n*\npermutedIx\n+=\nwhichString\n<<\nfactors\n->\nstringShift\n;\n}\nelse\n{\n*\npermutedIx\n+=\n(\nwhichString\n-\n(\nfactors\n->\nstringCount\n/\n2\n)\n)\n<<\nfactors\n->\nstringShift\n;\n}\nreturn\nCUFFT_SUCCESS\n;\n}\n5.\nFFTW Conversion Guide\n\ncuFFT differs from FFTW in that FFTW has many plans and a single execute function while cuFFT has fewer plans, but multiple execute functions. The cuFFT execute functions determine the precision (single or double) and whether the input is complex or real valued. The following table shows the relationship between the two interfaces.\nFFTW function\ncuFFT function\nfftw_plan_dft_1d(),\nfftw_plan_dft_r2c_1d(),\nfftw_plan_dft_c2r_1d()\ncufftPlan1d()\nfftw_plan_dft_2d(),\nfftw_plan_dft_r2c_2d(),\nfftw_plan_dft_c2r_2d()\ncufftPlan2d()\nfftw_plan_dft_3d(),\nfftw_plan_dft_r2c_3d(),\nfftw_plan_dft_c2r_3d()\ncufftPlan3d()\nfftw_plan_dft(),\nfftw_plan_dft_r2c(),\nfftw_plan_dft_c2r()\ncufftPlanMany()\nfftw_plan_many_dft(),\nfftw_plan_many_dft_r2c(),\nfftw_plan_many_dft_c2r()\ncufftPlanMany()\nfftw_execute()\ncufftExecC2C(),\ncufftExecZ2Z(),\ncufftExecR2C(),\ncufftExecD2Z(),\ncufftExecC2R(),\ncufftExecZ2D()\nfftw_destroy_plan()\ncufftDestroy()\n6.\nFFTW Interface to cuFFT\n\nNVIDIA provides FFTW3 interfaces to the cuFFT library. This allows applications using FFTW to use NVIDIA GPUs with minimal modifications to program source code. To use the interface first do the following two steps\nIt is recommended that you replace the include file\nfftw3.h\nwith\ncufftw.h\nInstead of linking with the double/single precision libraries such as\nfftw3/fftw3f\nlibraries, link with both the cuFFT and cuFFTW libraries\nEnsure the search path includes the directory containing\ncuda_runtime_api.h\nAfter an application is working using the FFTW3 interface, users may want to modify their code to move data to and from the GPU and use the routines documented in the\nFFTW Conversion Guide\nfor the best performance.\nThe following tables show which components and functions of FFTW3 are supported in cuFFT.\nSection in FFTW manual\nSupported\nUnsupported\nComplex numbers\nfftw_complex,\nfftwf_complex\ntypes\nPrecision\ndouble\nfftw3\n, single\nfftwf3\nlong double\nfftw3l\n, quad precision\nfftw3q\nare not supported since CUDA functions operate on double and single precision floating-point quantities\nMemory Allocation\nfftw_malloc(),\nfftw_free(),\nfftw_alloc_real(),\nfftw_alloc_complex(),\nfftwf_alloc_real(),\nfftwf_alloc_complex()\nMulti-threaded FFTW\nfftw3_threads,\nfftw3_omp\nare not supported\nDistributed-memory FFTW with MPI\nfftw3_mpi,fftw3f_mpi\nare not supported\nNote that for each of the double precision functions below there is a corresponding single precision version with the letters\nfftw\nreplaced by\nfftwf\n.\nSection in FFTW manual\nSupported\nUnsupported\nUsing Plans\nfftw_execute(),\nfftw_destroy_plan(),\nfftw_cleanup()\nfftw_print_plan(),\nfftw_cost(),\nfftw_flops()\nexist but are not functional\nBasic Interface\nComplex DFTs\nfftw_plan_dft_1d(),\nfftw_plan_dft_2d(),\nfftw_plan_dft_3d(),\nfftw_plan_dft()\nPlanner Flags\nPlanner flags are ignored and the same plan is returned regardless\nReal-data DFTs\nfftw_plan_dft_r2c_1d(),\nfftw_plan_dft_r2c_2d(),\nfftw_plan_dft_r2c_3d(),\nfftw_plan_dft_r2c(),\nfftw_plan_dft_c2r_1d(),\nfftw_plan_dft_c2r_2d(),\nfftw_plan_dft_c2r_3d(),\nfftw_plan_dft_c2r()\nRead-data DFT Array Format\nNot supported\nRead-to-Real Transform\nNot supported\nRead-to-Real Transform Kinds\nNot supported\nAdvanced Interface\nAdvanced Complex DFTs\nfftw_plan_many_dft()\nwith multiple 1D, 2D, 3D transforms\nfftw_plan_many_dft()\nwith 4D or higher transforms or a 2D or higher batch of embedded transforms\nAdvanced Real-data DFTs\nfftw_plan_many_dft_r2c(),\nfftw_plan_many_dft_c2r()\nwith multiple 1D, 2D, 3D transforms\nfftw_plan_many_dft_r2c(),\nfftw_plan_many_dft_c2r()\nwith 4D or higher transforms or a 2D or higher batch of embedded transforms\nAdvanced Real-to-Real Transforms\nNot supported\nGuru Interface\nInterleaved and split arrays\nInterleaved format\nSplit format\nGuru vector and transform sizes\nfftw_iodim\nstruct\nGuru Complex DFTs\nfftw_plan_guru_dft(),\nfftw_plan_guru_dft_r2c(),\nfftw_plan_guru_dft_c2r()\nwith multiple 1D, 2D, 3D transforms\nfftw_plan_guru_dft(),\nfftw_plan_guru_dft_r2c(),\nfftw_plan_guru_dft_c2r()\nwith 4D or higher transforms or a 2D or higher batch of transforms\nGuru Real-data DFTs\nNot supported\nGuru Real-to-real Transforms\nNot supported\n64-bit Guru Interface\nfftw_plan_guru64_dft(),\nfftw_plan_guru64_dft_r2c(),\nfftw_plan_guru64_dft_c2r()\nwith multiple 1D, 2D, 3D transforms\nfftw_plan_guru64_dft(),\nfftw_plan_guru64_dft_r2c(),\nfftw_plan_guru64_dft_c2r()\nwith 4D or higher transforms or a 2D or higher batch of transforms\nNew-array Execute Functions\nfftw_execute_dft(),\nfftw_execute_dft_r2c(),\nfftw_execute_dft_c2r()\nwith interleaved format\nSplit format and real-to-real functions\nWisdom\nfftw_export_wisdom_to_file(),\nfftw_import_wisdom_from_file()\nexist but are not functional. Other wisdom functions do not have entry points in the library.\n7.\nDeprecated Functionality\n\nStarting from CUDA 13.0:\nThe cuFFT binary\nlibcufft_static_nocallback.a\nhas been removed.\nlibcufft_static.a\ncan be used as a replacement.\nThe following error codes have been removed:\nCUFFT_INCOMPLETE_PARAMETER_LIST\n,\nCUFFT_PARSE_ERROR\n,\nCUFFT_LICENSE_ERROR\n.\nMaxwell, Pascal, and Volta GPU architectures are no longer supported. The minimum required architecture is Turing.\nStarting from CUDA 12.9:\nThe following error codes are deprecated and will be removed in a future release:\nCUFFT_INCOMPLETE_PARAMETER_LIST\n,\nCUFFT_PARSE_ERROR\n,\nCUFFT_LICENSE_ERROR\n.\nStarting from CUDA 12.8:\nThe cuFFT binary\nlibcufft_static_nocallback.a\nis deprecated and will be removed in a future release.\nlibcufft_static.a\ncan be used as a replacement.\nStarting from CUDA 12.0:\nGPU architectures SM35 and SM37 are no longer supported. The minimum required architecture is SM50.\nStarting from CUDA 11.8:\nCUDA Graphs capture is no longer supported for legacy callback routines that load data in out-of-place mode transforms. Starting from CUDA 12.6 Update 2, LTO callbacks can be used as a replacement for legacy callbacks without this limitation.\nStarting from CUDA 11.4:\nSupport for callback functionality using separately compiled device code (legacy callbacks) is deprecated on all GPU architectures. Callback functionality will continue to be supported for all GPU architectures.\nStarting from CUDA 11.0:\nGPU architecture SM30 is no longer supported. The minimum required architecture is SM35.\nSupport for GPU architectures SM35, SM37 (Kepler), and SM50, SM52 (Maxwell) is deprecated.\nFunction\ncufftSetCompatibilityMode\nwas removed in version 9.1.\n8.\nNotices\n\n8.1.\nNotice\n\nThis document is provided for information purposes only and shall not be regarded as a warranty of a certain functionality, condition, or quality of a product. NVIDIA Corporation (“NVIDIA”) makes no representations or warranties, expressed or implied, as to the accuracy or completeness of the information contained in this document and assumes no responsibility for any errors contained herein. NVIDIA shall have no liability for the consequences or use of such information or for any infringement of patents or other rights of third parties that may result from its use. This document is not a commitment to develop, release, or deliver any Material (defined below), code, or functionality.\nNVIDIA reserves the right to make corrections, modifications, enhancements, improvements, and any other changes to this document, at any time without notice.\nCustomer should obtain the latest relevant information before placing orders and should verify that such information is current and complete.\nNVIDIA products are sold subject to the NVIDIA standard terms and conditions of sale supplied at the time of order acknowledgement, unless otherwise agreed in an individual sales agreement signed by authorized representatives of NVIDIA and customer (“Terms of Sale”). NVIDIA hereby expressly objects to applying any customer general terms and conditions with regards to the purchase of the NVIDIA product referenced in this document. No contractual obligations are formed either directly or indirectly by this document.\nNVIDIA products are not designed, authorized, or warranted to be suitable for use in medical, military, aircraft, space, or life support equipment, nor in applications where failure or malfunction of the NVIDIA product can reasonably be expected to result in personal injury, death, or property or environmental damage. NVIDIA accepts no liability for inclusion and/or use of NVIDIA products in such equipment or applications and therefore such inclusion and/or use is at customer’s own risk.\nNVIDIA makes no representation or warranty that products based on this document will be suitable for any specified use. Testing of all parameters of each product is not necessarily performed by NVIDIA. It is customer’s sole responsibility to evaluate and determine the applicability of any information contained in this document, ensure the product is suitable and fit for the application planned by customer, and perform the necessary testing for the application in order to avoid a default of the application or the product. Weaknesses in customer’s product designs may affect the quality and reliability of the NVIDIA product and may result in additional or different conditions and/or requirements beyond those contained in this document. NVIDIA accepts no liability related to any default, damage, costs, or problem which may be based on or attributable to: (i) the use of the NVIDIA product in any manner that is contrary to this document or (ii) customer product designs.\nNo license, either expressed or implied, is granted under any NVIDIA patent right, copyright, or other NVIDIA intellectual property right under this document. Information published by NVIDIA regarding third-party products or services does not constitute a license from NVIDIA to use such products or services or a warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual property rights of the third party, or a license from NVIDIA under the patents or other intellectual property rights of NVIDIA.\nReproduction of information in this document is permissible only if approved in advance by NVIDIA in writing, reproduced without alteration and in full compliance with all applicable export laws and regulations, and accompanied by all associated conditions, limitations, and notices.\nTHIS DOCUMENT AND ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, “MATERIALS”) ARE BEING PROVIDED “AS IS.” NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL NVIDIA BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Notwithstanding any damages that customer might incur for any reason whatsoever, NVIDIA’s aggregate and cumulative liability towards customer for the products described herein shall be limited in accordance with the Terms of Sale for the product.\n8.2.\nOpenCL\n\nOpenCL is a trademark of Apple Inc. used under license to the Khronos Group Inc.\n8.3.\nTrademarks\n\nNVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated.", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://docs.nvidia.com/cuda/cufft/index.html"}}
{"text": "1. Introduction — cuSPARSE 13.0 documentation\n»\n1.\nIntroduction\nv13.0 |\nPDF\n|\nArchive\ncuSPARSE\nThe API reference guide for cuSPARSE, the CUDA sparse matrix library.\n1.\nIntroduction\n\nThe cuSPARSE library contains a set of GPU-accelerated basic linear algebra subroutines used for handling sparse matrices that perform significantly faster than CPU-only alternatives. Depending on the specific operation, the library targets matrices with sparsity ratios in the range between 70%-99.9%.\nIt is implemented on top of the NVIDIA® CUDA™ runtime (which is part of the CUDA Toolkit) and is designed to be called from C and C++.\nSee also\ncuSPARSELt: A High-Performance CUDA Library for Sparse Matrix-Matrix Multiplication\ncuSPARSE Release Notes:\ncuda-toolkit-release-notes\ncuSPARSE GitHub Samples:\nCUDALibrarySamples\nNvidia Developer Forum:\nGPU-Accelerated Libraries\nProvide Feedback:\nMath-Libs-Feedback\n@\nnvidia\n.\ncom\nRecent cuSPARSE/cuSPARSELt Blog Posts and GTC presentations:\nExploiting NVIDIA Ampere Structured Sparsity with cuSPARSELt\nAccelerating Matrix Multiplication with Block Sparse Format and NVIDIA Tensor Cores\nJust-In-Time Link-Time Optimization Adoption in cuSPARSE/cuFFT: Use Case Overview\nStructured Sparsity in the NVIDIA Ampere Architecture and Applications in Search Engines\nMaking the Most of Structured Sparsity in the NVIDIA Ampere Architecture\nThe library routines provide the following functionalities:\nOperations between a\nsparse vector\nand a\ndense vector\n: sum, dot product, scatter, gather\nOperations between a\ndense matrix\nand a\nsparse vector\n: multiplication\nOperations between a\nsparse matrix\nand a\ndense vector\n: multiplication, triangular solver, tridiagonal solver, pentadiagonal solver\nOperations between a\nsparse matrix\nand a\ndense matrix\n: multiplication, triangular solver, tridiagonal solver, pentadiagonal solver\nOperations between a\nsparse matrix\nand a\nsparse matrix\n: sum, multiplication\nOperations between\ndense matrices\nwith output a\nsparse matrix\n: multiplication\nSparse matrix preconditioners\n: Incomplete Cholesky Factorization (level 0),  Incomplete LU Factorization (level 0)\nReordering and Conversion operations between different\nsparse matrix storage formats\n1.1.\nLibrary Organization and Features\n\nThe cuSPARSE library is organized in two set of APIs:\nThe\nLegacy APIs\n, inspired by the Sparse BLAS standard, provide a limited set of functionalities and\nwill not be improved in future releases\n, even if standard maintenance is still ensured. Some routines in this category could be deprecated and removed in the short-term. A replacement will be provided for the most important of them during the deprecation process.\nThe\nGeneric APIs\nprovide the\nstandard interface layer of cuSPARSE\n. They allow computing the most common sparse linear algebra operations, such as sparse matrix-vector (SpMV) and sparse matrix-matrix multiplication (SpMM), in a flexible way. The new APIs have the following capabilities and features:\nSet matrix data\nlayouts\n, number of\nbatches\n, and\nstorage formats\n(for example, CSR, COO, and so on).\nSet input/output/compute data types. This also allows\nmixed data-type computation\n.\nSet types of sparse vector/matrix\nindices\n(e.g. 32-bit, 64-bit).\nChoose the\nalgorithm\nfor the computation.\nGuarantee external device memory for internal operations.\nProvide extensive\nconsistency checks\nacross input matrices and vectors. This includes the validation of sizes, data types, layout, allowed operations, etc.\nProvide constant descriptors for vector and matrix inputs to support const-safe interface and guarantee that the APIs do not modify their inputs.\n1.2.\nStatic Library Support\n\nStarting with CUDA 6.5, the cuSPARSE library is also delivered in a\nstatic\nform as\nlibcusparse_static.a\non Linux.\nFor example, to compile a small application using cuSPARSE against the\ndynamic library\n, the following command can be used:\nnvcc\nmy_cusparse_app\n.\ncu\n-\nlcusparse\n-\no\nmy_cusparse_app\nWhereas to compile against the\nstatic library\n, the following command has to be used:\nnvcc\nmy_cusparse_app\n.\ncu\n-\nlcusparse_static\n-\no\nmy_cusparse_app\nIt is also possible to use the native Host C++ compiler. Depending on the Host Operating system, some additional libraries like\npthread\nor\ndl\nmight be needed on the linking line. The following command on Linux is suggested:\ngcc\nmy_cusparse_app\n.\nc\n-\nlcusparse_static\n-\nlcudart_static\n-\nlpthread\n-\nldl\n-\nI\n<\ncuda\n-\ntoolkit\n-\npath\n>/\ninclude\n-\nL\n<\ncuda\n-\ntoolkit\n-\npath\n>/\nlib64\n-\no\nmy_cusparse_app\nNote that in the latter case, the library\ncuda\nis not needed. The CUDA Runtime will try to open explicitly the\ncuda\nlibrary if needed. In the case of a system which does not have the CUDA driver installed, this allows the application to gracefully manage this issue and potentially run if a CPU-only path is available.\n1.3.\nLibrary Dependencies\n\nStarting with CUDA 12.0, cuSPARSE will depend on\nnvJitLink\nlibrary for JIT (Just-In-Time) LTO (Link-Time-Optimization) capabilities; refer to the\ncusparseSpMMOp()\nAPIs for more information.\nIf the user links to the\ndynamic library\n, the environment variables for loading the libraries at run-time (such as\nLD_LIBRARY_PATH\non Linux and\nPATH\non Windows) must include the path where\nlibnvjitlink.so\nis located. If it is in the same directory as cuSPARSE, the user doesn’t need to take any action.\nIf linking to the\nstatic library\n, the user needs to link with\n-lnvjitlink\nand set the environment variables for loading the libraries at compile-time\nLIBRARY_PATH/PATH\naccordingly.\n2.\nUsing the cuSPARSE API\n\nThis chapter describes how to use the cuSPARSE library API. It is not a reference for the cuSPARSE API data types and functions; that is provided in subsequent chapters.\n2.1.\nAPIs Usage Notes\n\nThe cuSPARSE library allows developers to access the computational resources of the NVIDIA graphics processing unit (GPU).\nThe cuSPARSE APIs assume that input and output data (vectors and matrices) reside in GPU (device) memory\n.\nThe input and output\nscalars\n(e.g.\n\\(\\alpha\\)\nand\n\\(\\beta\\)\n) can be passed by reference on the host or the device, instead of only being allowed to be passed by value on the host. This allows library functions to execute asynchronously using streams even when they are generated by a previous kernel resulting in maximum parallelism.\nThe handle to the\ncuSPARSE library context\nis initialized using the function and is explicitly passed to every subsequent library function call. This allows the user to have more control over the library setup when using multiple host threads and multiple GPUs.\nThe error status\ncusparseStatus_t\nis returned by all cuSPARSE library function calls.\nIt is the responsibility of the developer to allocate memory and to copy data between GPU memory and CPU memory using standard CUDA runtime API routines, such as\ncudaMalloc()\n,\ncudaFree()\n,\ncudaMemcpy()\n, and\ncudaMemcpyAsync()\n.\nThe cuSPARSE library functions are executed\nasynchronously\nwith respect to the host and may return control to the application on the host before the result is ready. Developers can use the\ncudaDeviceSynchronize()\nfunction to ensure that the execution of a particular cuSPARSE library routine has completed.\nA developer can also use the\ncudaMemcpy()\nroutine to copy data from the device to the host and vice versa, using the\ncudaMemcpyDeviceToHost\nand\ncudaMemcpyHostToDevice\nparameters, respectively. In this case there is no need to add a call to\ncudaDeviceSynchronize()\nbecause the call to\ncudaMemcpy()\nwith the above parameters is blocking and completes only when the results are ready on the host.\n2.2.\nDeprecated APIs\n\nThe cuSPARSE library documentation explicitly indicates the set of APIs/enumerators/data structures that are deprecated. The library policy for deprecated APIs is the following:\nAn API is marked\n[[DEPRECATED]]\non a release X.Y (e.g. 11.2)\nThe documentation indices a replacement if available\nOtherwise, the functionality will not be maintained in the future\nThe API will be removed in the release X+1.0 (e.g. 12.0)\nCorrectness bugs are still addressed even for deprecated APIs, while performance issues are not always ensured.\nIn addition to the documentation, deprecated APIs generate a\ncompile-time\nwarning for most platforms when used. Deprecation warnings can be disabled by defining the macro\nDISABLE_CUSPARSE_DEPRECATED\nbefore including\ncusparse.h\nor by passing the flag\n-DDISABLE_CUSPARSE_DEPRECATED\nto the compiler.\n2.3.\nThread Safety\n\nThe library is thread safe.\nIt is safe to call any function from any thread at any time,\nas long as none of the data it is using is being written to from another thread at the same time.\nWhether or not a cuSPARSE function writes to an object is typically indicated via\nconst\nparameters.\nIt is not recommended to share the same\ncuSPARSE handle\nacross multiple threads.\nIt is possible to do so, but changes to the handle\n(e.g.\nset stream\nor\ndestroy\n)\nwill affect all threads and introduce global synchronization issues.\n2.4.\nResult Reproducibility\n\nThe design of cuSPARSE prioritizes performance over bit-wise reproducibility.\nOperations using transpose or conjugate-transpose\ncusparseOperation_t\nhave no reproducibility guarantees.\nFor the remaining operations,\nperforming the same API call twice with the exact same arguments,\non the same machine, with the same executable will produce bit-wise identical results.\nThis bit-wise reproducibility can be disrupted by changes to:\nhardware, CUDA drivers, cuSPARSE version, memory alignment of the data, or algorithm selection.\n2.5.\nNaN and Inf Propagation\n\nFloating-point numbers have special values for NaN (not-a-number) and Inf (infinity).\nFunctions in cuSPARSE make no guarantees about the propagation of NaN and Inf.\nThe cuSPARSE algorithms evaluate assuming all finite floating-point values.\nNaN and Inf appear in the output only if the algorithms happen to generate or propagate them.\nBecause the algorithms are subject to change based on toolkit version and runtime considerations,\nso too are the propagation behaviours of NaN and Inf.\nNaN propagation is different in cuSPARSE than in\ntypical dense numerical linear algebra, such as cuBLAS.\nThe dot product between vectors\n[0,\n1,\n0]\nand\n[1,\n1,\nNaN]\nis NaN when using typical dense numerical algorithms,\nbut will be 1.0 with typical sparse numerical algorithms.\n2.6.\nParallelism with Streams\n\nIf the application performs several small independent computations, or if it makes data transfers in parallel with the computation, CUDA streams can be used to overlap these tasks.\nThe application can conceptually associate a stream with each task. To achieve the overlap of computation between the tasks, the developer should create CUDA streams using the function\ncudaStreamCreate()\nand set the stream to be used by each individual cuSPARSE library routine by calling\ncusparseSetStream()\njust before calling the actual cuSPARSE routine. Then, computations performed in separate streams would be overlapped automatically on the GPU, when possible. This approach is especially useful when the computation performed by a single task is relatively small and is not enough to fill the GPU with work, or when there is a data transfer that can be performed in parallel with the computation.\nWhen streams are used, we recommend using the new cuSPARSE API with scalar parameters and results passed by reference in the device memory to achieve maximum computational overlap.\nAlthough a developer can create many streams, in practice it is not possible to have more than 16 concurrent kernels executing at the same time.\n2.7.\nCompatibility and Versioning\n\nThe cuSPARSE APIs are intended to be backward compatible at the source level with future releases (unless stated otherwise in the release notes of a specific future release). In other words, if a program uses cuSPARSE, it should continue to compile and work correctly with newer versions of cuSPARSE without source code changes. cuSPARSE is not guaranteed to be backward compatible at the binary level. Using different versions of the\ncusparse.h\nheader file and shared library is not supported. Using different versions of cuSPARSE and the CUDA runtime is not supported.\nThe library uses the standard\nversion semantic\nconvention for identify different releases.\nThe\nversion\ntakes the form of four fields joined by periods:\nMAJOR.MINOR.PATCH.BUILD\nThese\nversion fields\nare incremented based on the following rules:\nMAJOR\n: API breaking changes or new CUDA major version (breaking changes at lower level, e.g. drivers, compilers, libraries)\nMINOR\n: new APIs and functionalities\nPATCH\n: Bug fixes or performance improvements (or\n*\nnew CUDA release)\nBUILD\n: Internal build number\n*\nDifferent CUDA toolkit releases ensure distinct library versions even if there are no changes at library level.\n2.8.\nOptimization Notes\n\nMost of the cuSPARSE routines can be optimized by exploiting\nCUDA Graphs capture\nand\nHardware Memory Compression\nfeatures.\nMore in details, a single cuSPARSE call or a sequence of calls can be captured by a\nCUDA Graph\nand executed in a second moment. This minimizes kernels launch overhead and allows the CUDA runtime to optimize the whole workflow. A full example of CUDA graphs capture applied to a cuSPARSE routine can be found in\ncuSPARSE Library Samples - CUDA Graph\n.\nSecondly, the data types and functionalities involved in cuSPARSE are suitable for\nHardware Memory Compression\navailable in Ampere GPU devices (compute capability 8.0) or above. The feature allows memory compression for data with enough zero bytes without no loss of information. The device memory must be allocation with the\nCUDA driver APIs\n. A full example of Hardware Memory Compression applied to a cuSPARSE routine can be found in\ncuSPARSE Library Samples - Memory Compression\n.\n3.\ncuSPARSE Storage Formats\n\nThe cuSPARSE library supports dense and sparse vector, and dense and sparse matrix formats.\n3.1.\nIndex Base\n\nThe library supports zero- and one-based indexing to ensure the compatibility with C/C++ and Fortran languages respectively. The index base is selected through the\ncusparseIndexBase_t\ntype.\n3.2.\nVector Formats\n\nThis section describes dense and sparse vector formats.\n3.2.1.\nDense Vector Format\n\nDense vectors are represented with a single data array that is stored linearly in memory, such as the following\n\\(7 \\times 1\\)\ndense vector.\nDense vector representation\n\n3.2.2.\nSparse Vector Format\n\nSparse vectors are represented with two arrays.\nThe\nvalues\narray stores the nonzero values from the equivalent array in dense format.\nThe\nindices\narray represent the positions of the corresponding nonzero values in the equivalent array in dense format.\nFor example, the dense vector in section 3.2.1 can be stored as a sparse vector with zero-based or one-based indexing.\nSparse vector representation\n\nNote\nThe cuSPARSE routines assume that the indices are provided in increasing order and that each index appears only once. In the opposite case, the correctness of the computation is not always ensured.\n3.3.\nMatrix Formats\n\nDense and several sparse formats for matrices are discussed in this section.\n3.3.1.\nDense Matrix Format\n\nA dense matrix can be stored in both\nrow-major\nand\ncolumn-major\nmemory layout (ordering) and it is represented by the following parameters.\nThe\nnumber of rows\nin the matrix.\nThe\nnumber of columns\nin the matrix.\nThe\nleading dimension\n, which must be\nGreater than or equal to the\nnumber of columns\nin the\nrow-major\nlayout\nGreater than or equal to the\nnumber of rows\nin the\ncolumn-major\nlayout\nThe pointers to the\nvalues\narray of length\n\\(rows \\times leading\\; dimension\\)\nin the\nrow-major\nlayout\n\\(columns \\times leading\\; dimension\\)\nin the\ncolumn-major\nlayout\nThe following figure represents a\n\\(5 \\times 2\\)\ndense matrix with both memory layouts\nDense matrix representations\n\nThe indices within the matrix represents the contiguous locations in memory.\nThe leading dimension is useful to represent a sub-matrix within the original one\nSub-matrix representations\n\n3.3.2.\nCoordinate (COO)\n\nA sparse matrix stored in\nCOO\nformat is represented by the following parameters.\nThe\nnumber of rows\nin the matrix.\nThe\nnumber of columns\nin the matrix.\nThe\nnumber of non-zero elements\n(\nnnz\n) in the matrix.\nThe pointers to the\nrow indices\narray of length\nnnz\nthat contains the row indices of the corresponding elements in the\nvalues array\n.\nThe pointers to the\ncolumn indices\narray of length\nnnz\nthat contains the column indices of the corresponding elements in the\nvalues array\n.\nThe pointers to the\nvalues\narray of length\nnnz\nthat holds all nonzero values of the matrix in row-major ordering.\nEach entry of the COO representation consists of a\n<row,\ncolumn>\npair.\nThe COO format is assumed to be sorted\nby row\n.\nThe following example shows a\n\\(5 \\times 4\\)\nmatrix represented in COO format.\nNote\ncuSPARSE supports both\nsorted\nand\nunsorted\ncolumn indices within a given row.\nNote\nIf the column indices within a given row are not unique, the correctness of the computation is not always ensured.\nGiven an entry in the COO format (zero-base), the corresponding position in the dense matrix is computed as:\n// row-major\nrows_indices\n[\ni\n]\n*\nleading_dimension\n+\ncolumn_indices\n[\ni\n]\n// column-major\ncolumn_indices\n[\ni\n]\n*\nleading_dimension\n+\nrows_indices\n[\ni\n]\n3.3.3.\nCompressed Sparse Row (CSR)\n\nThe\nCSR\nformat is similar to COO, where the\nrow indices\nare compressed and replaced by an array of\noffsets\n.\nA sparse matrix stored in CSR format is represented by the following parameters.\nThe\nnumber of rows\nin the matrix.\nThe\nnumber of columns\nin the matrix.\nThe\nnumber of non-zero elements\n(\nnnz\n) in the matrix.\nThe pointers to the\nrow offsets\narray of length\nnumber of rows + 1\nthat represents the starting position of each row in the\ncolumns and values arrays\n.\nThe pointers to the\ncolumn indices\narray of length\nnnz\nthat contains the column indices of the corresponding elements in the\nvalues array\n.\nThe pointers to the\nvalues\narray of length\nnnz\nthat holds all nonzero values of the matrix in row-major ordering.\nThe following example shows a\n\\(5 \\times 4\\)\nmatrix represented in CSR format.\nNote\ncuSPARSE supports both\nsorted\nand\nunsorted\ncolumn indices within a given row.\nNote\nIf the\ncolumn indices\nwithin a given\nrow\nare not unique, the correctness of the computation is not always ensured.\nGiven an entry in the CSR format (zero-base), the corresponding position in the dense matrix is computed as:\n// row-major\nrow\n*\nleading_dimension\n+\ncolumn_indices\n[\nrow_offsets\n[\nrow\n]\n+\nk\n]\n// column-major\ncolumn_indices\n[\nrow_offsets\n[\nrow\n]\n+\nk\n]\n*\nleading_dimension\n+\nrow\n3.3.4.\nCompressed Sparse Column (CSC)\n\nThe\nCSC\nformat is similar to COO, where the\ncolumn indices\nare compressed and replaced by an array of\noffsets\n.\nA sparse matrix stored in CSC format is represented by the following parameters.\nThe\nnumber of rows\nin the matrix.\nThe\nnumber of columns\nin the matrix.\nThe\nnumber of non-zero elements\n(\nnnz\n) in the matrix.\nThe pointers to the\ncolumn offsets\narray of length\nnumber of column + 1\nthat represents the starting position of each column in the\ncolumns and values arrays\n.\nThe pointers to the\nrow indices\narray of length\nnnz\nthat contains row indices of the corresponding elements in the\nvalues array\n.\nThe pointers to the\nvalues\narray of length\nnnz\nthat holds all nonzero values of the matrix in column-major ordering.\nThe following example shows a\n\\(5 \\times 4\\)\nmatrix represented in CSC format.\nNote\nThe CSR format has exactly the same memory layout as its transpose in CSC format (and vice versa).\nNote\ncuSPARSE supports both\nsorted\nand\nunsorted\nrow indices within a given column.\nNote\nIf the\nrow indices\nwithin a given\ncolumn\nare not unique, the correctness of the computation is not always ensured.\nGiven an entry in the CSC format (zero-base), the corresponding position in the dense matrix is computed as:\n// row-major\nrow_indices\n[\ncolumn_offsets\n[\ncolumn\n]\n+\nk\n]\n*\nleading_dimension\n+\ncolumn\n// column-major\ncolumn\n*\nleading_dimension\n+\nrow_indices\n[\ncolumn_offsets\n[\ncolumn\n]\n+\nk\n]\n3.3.5.\nSliced Ellpack (SELL)\n\nThe\nSliced Ellpack\nformat is standardized and well-known as the state of the art.\nThis format allows to significantly improve the performance of all problems that involve low variability in the number of nonzero elements per row.\nA matrix in the Sliced Ellpack format is divided into\nslices\nof an\nexact number of rows\n(\n\\(sliceSize\\)\n), defined by the user.\nThe maximum row length (i.e.,  the maximum non-zeros per row) is found for each slice, and every row in the slice is padded to the maximum row length.\nThe value\n-1\nis used for padding.\nA\n\\(m \\times n\\)\nsparse matrix\n\\(A\\)\nis equivalent to a\nsliced sparse matrix\n\\(A_{s}\\)\nwith\n\\(nslices = \\left \\lceil{\\frac{m}{sliceSize}}\\right \\rceil\\)\nslice rows and\n\\(n\\)\ncolumns.\nTo improve memory coalescing and memory utilization, each slice is stored in\ncolumn-major\norder.\nA sparse matrix stored in SELL format is represented by the following parameters.\nThe\nnumber of slices\n.\nThe\nnumber of rows\nin the matrix.\nThe\nnumber of columns\nin the matrix.\nThe\nnumber of non-zero elements\n(\nnnz\n) in the matrix.\nThe\ntotal number elements\n(\nsellValuesSize\n), including non-zero values and padded elements.\nThe pointer to the\nslice offsets\nof length\n\\(nslices + 1\\)\nthat holds offsets of the slides corresponding to the columns and values arrays.\nThe pointer to the\ncolumn indices\narray of length\nsellValuesSize\nthat contains column indices of the corresponding elements in the\nvalues\narray. The column indices are stored in\ncolumn-major\nlayout. Value\n-1\nrefers to padding.\nThe pointer to the\nvalues\narray of length\nsellValuesSize\nthat holds all non-zero values and padding in\ncolumn-major\nlayout.\nThe following example shows a\n\\(5 \\times 4\\)\nmatrix represented in SELL format.\n3.3.6.\nBlock Sparse Row (BSR)\n\nThe BSR format is similar to CSR, where the\ncolumn indices\nrepresent two-dimensional blocks instead of a single matrix entry.\nA matrix in the Block Sparse Row format is organized into blocks of size\n\\(blockSize\\)\n, defined by the user.\nA\n\\(m \\times n\\)\nsparse matrix\n\\(A\\)\nis equivalent to a\nblock sparse matrix\n\\(A_{B}\\)\n:\n\\(mb \\times nb\\)\nwith\n\\(mb = \\frac{m}{blockSize}\\)\nblock rows\nand\n\\(nb = \\frac{n}{blockSize}\\)\nblock columns\n.\nIf\n\\(m\\)\nor\n\\(n\\)\nis not multiple of\n\\(blockSize\\)\n, the user needs to pad the matrix with zeros.\nNote\ncuSPARSE currently supports only\nsquare\nblocks.\nThe BSR format stores the blocks in row-major ordering. However, the internal storage format of blocks can be\ncolumn-major\n(\ncusparseDirection_t=CUSPARSE_DIRECTION_COLUMN\n) or\nrow-major\n(\ncusparseDirection_t=CUSPARSE_DIRECTION_ROW\n), independently of the base index.\nA sparse matrix stored in BSR format is represented by the following parameters.\nThe\nblock size\n.\nThe\nnumber of row blocks\nin the matrix.\nThe\nnumber of column blocks\nin the matrix.\nThe\nnumber of non-zero blocks\n(\nnnzb\n) in the matrix.\nThe pointers to the\nrow block offsets\narray of length\nnumber of row blocks + 1\nthat represents the starting position of each row block in the\ncolumns and values arrays\n.\nThe pointers to the\ncolumn block indices\narray of length\nnnzb\nthat contains the location of the corresponding elements in the values array.\nThe pointers to the\nvalues array\nof length\nnnzb\nthat holds all nonzero values of the matrix.\nThe following example shows a\n\\(4 \\times 7\\)\nmatrix represented in BSR format.\n3.3.7.\nBlocked Ellpack (BLOCKED-ELL)\n\nThe Blocked Ellpack format is similar to the standard Ellpack, where the\ncolumn indices\nrepresent two-dimensional blocks instead of a single matrix entry.\nA matrix in the Blocked Ellpack format is organized into blocks of size\n\\(blockSize\\)\n, defined by the user. The number of columns per row\n\\(nEllCols\\)\nis also defined by the user (\n\\(nEllCols \\le n\\)\n).\nA\n\\(m \\times n\\)\nsparse matrix\n\\(A\\)\nis equivalent to a\nBlocked-ELL\nmatrix\n\\(A_{B}\\)\n:\n\\(mb \\times nb\\)\nwith\n\\(mb = \\left \\lceil{\\frac{m}{blockSize}}\\right \\rceil\\)\nblock rows\n, and\n\\(nb = \\left \\lceil{\\frac{nEllCols}{blockSize}}\\right \\rceil\\)\nblock columns.\nIf\n\\(m\\)\nor\n\\(n\\)\nis not multiple of\n\\(blockSize\\)\n, then the remaining elements are zero.\nA sparse matrix stored in Blocked-ELL format is represented by the following parameters.\nThe\nblock size\n.\nThe\nnumber of rows\nin the matrix.\nThe\nnumber of columns\nin the matrix.\nThe\nnumber of columns per row\n(\nnEllCols\n) in the matrix.\nThe pointers to the\ncolumn block indices\narray of length\n\\(mb \\times nb\\)\nthat contains the location of the corresponding elements in the values array. Empty blocks can be represented with\n-1\nindex.\nThe pointers to the\nvalues array\nof length\n\\(m \\times nEllCols\\)\nthat holds all nonzero values of the matrix in row-major ordering.\nThe following example shows a\n\\(9 \\times 9\\)\nmatrix represented in Blocked-ELL format.\n3.3.8.\nExtended BSR Format (BSRX) [DEPRECATED]\n\nBSRX is the same as the BSR format, but the array\nbsrRowPtrA\nis separated into two parts. The first nonzero block of each row is still specified by the array\nbsrRowPtrA\n, which is the same as in BSR, but the position next to the last nonzero block of each row is specified by the array\nbsrEndPtrA\n. Briefly, BSRX format is simply like a 4-vector variant of BSR format.\nMatrix\nA\nis represented in BSRX format by the following parameters.\nblockDim\n(integer)\nBlock dimension of matrix\nA\n.\nmb\n(integer)\nThe number of block rows of\nA\n.\nnb\n(integer)\nThe number of block columns of\nA\n.\nnnzb\n(integer)\nnumber of nonzero blocks in the matrix\nA\n.\nbsrValA\n(pointer)\nPoints to the data array of length\n\\(nnzb \\ast blockDim^{2}\\)\nthat holds all the elements of the nonzero blocks of\nA\n. The block elements are stored in either column-major order or row-major order.\nbsrRowPtrA\n(pointer)\nPoints to the integer array of length\nmb\nthat holds indices into the arrays\nbsrColIndA\nand\nbsrValA\n;\nbsrRowPtrA(i)\nis the position of the first nonzero block of the\ni\nth block row in\nbsrColIndA\nand\nbsrValA\n.\nbsrEndPtrA\n(pointer)\nPoints to the integer array of length\nmb\nthat holds indices into the arrays\nbsrColIndA\nand\nbsrValA\n;\nbsrRowPtrA(i)\nis the position next to the last nonzero block of the\ni\nth block row in\nbsrColIndA\nand\nbsrValA\n.\nbsrColIndA\n(pointer)\nPoints to the integer array of length\nnnzb\nthat contains the column indices of the corresponding blocks in array\nbsrValA\n.\nA simple conversion between BSR and BSRX can be done as follows. Suppose the developer has a\n\\(2 \\times 3\\)\nblock sparse matrix\n\\(A_{b}\\)\nrepresented as shown.\n\\[\\begin{split}A_{b} = \\begin{bmatrix}\nA_{00} & A_{01} & A_{02} \\\\\nA_{10} & A_{11} & A_{12} \\\\\n\\end{bmatrix}\\end{split}\\]\nAssume it has this BSR format:\n\\[\\begin{split}\\begin{matrix}\n\\text{bsrValA of BSR} & = & \\begin{bmatrix}\nA_{00} & A_{01} & A_{10} & A_{11} & A_{12} \\\\\n\\end{bmatrix} \\\\\n\\text{bsrRowPtrA of BSR} & = & \\begin{bmatrix}\n{0\\phantom{.0}} & {2\\phantom{.0}} & 5 \\\\\n\\end{bmatrix} \\\\\n\\text{bsrColIndA of BSR} & = & \\begin{bmatrix}\n{0\\phantom{.0}} & {1\\phantom{.0}} & {0\\phantom{.0}} & {1\\phantom{.0}} & 2 \\\\\n\\end{bmatrix} \\\\\n\\end{matrix}\\end{split}\\]\nThe\nbsrRowPtrA\nof the BSRX format is simply the first two elements of the\nbsrRowPtrA\nBSR format. The\nbsrEndPtrA\nof BSRX format is the last two elements of the\nbsrRowPtrA\nof BSR format.\n\\[\\begin{split}\\begin{matrix}\n\\text{bsrRowPtrA of BSRX} & = & \\begin{bmatrix}\n{0\\phantom{.0}} & 2 \\\\\n\\end{bmatrix} \\\\\n\\text{bsrEndPtrA of BSRX} & = & \\begin{bmatrix}\n{2\\phantom{.0}} & 5 \\\\\n\\end{bmatrix} \\\\\n\\end{matrix}\\end{split}\\]\nThe advantage of the BSRX format is that the developer can specify a submatrix in the original BSR format by modifying\nbsrRowPtrA\nand\nbsrEndPtrA\nwhile keeping\nbsrColIndA\nand\nbsrValA\nunchanged.\nFor example, to create another block matrix\n\\(\\widetilde{A} = \\begin{bmatrix}\nO & O & O \\\\\nO & A_{11} & O \\\\\n\\end{bmatrix}\\)\nthat is slightly different from\n\\(A\\)\n, the developer can keep\nbsrColIndA\nand\nbsrValA\n, but reconstruct\n\\(\\widetilde{A}\\)\nby properly setting of\nbsrRowPtrA\nand\nbsrEndPtrA\n. The following 4-vector characterizes\n\\(\\widetilde{A}\\)\n.\n\\[\\begin{split}\\begin{matrix}\n{\\text{bsrValA of }\\widetilde{A}} & = & \\begin{bmatrix}\nA_{00} & A_{01} & A_{10} & A_{11} & A_{12} \\\\\n\\end{bmatrix} \\\\\n{\\text{bsrColIndA of }\\widetilde{A}} & = & \\begin{bmatrix}\n{0\\phantom{.0}} & {1\\phantom{.0}} & {0\\phantom{.0}} & {1\\phantom{.0}} & 2 \\\\\n\\end{bmatrix} \\\\\n{\\text{bsrRowPtrA of }\\widetilde{A}} & = & \\begin{bmatrix}\n{0\\phantom{.0}} & 3 \\\\\n\\end{bmatrix} \\\\\n{\\text{bsrEndPtrA of }\\widetilde{A}} & = & \\begin{bmatrix}\n{0\\phantom{.0}} & 4 \\\\\n\\end{bmatrix} \\\\\n\\end{matrix}\\end{split}\\]\n4.\ncuSPARSE Basic APIs\n\n4.1.\ncuSPARSE Types Reference\n\n4.1.1.\ncudaDataType_t\n\nThe section describes the types shared by multiple CUDA Libraries and defined in the header file\nlibrary_types.h\n. The\ncudaDataType\ntype is an enumerator to specify the data precision. It is used when the data reference does not carry the type itself (e.g.\nvoid*\n). For example, it is used in the routine\ncusparseSpMM()\n.\nValue\nMeaning\nData Type\nHeader\nCUDA_R_16F\nThe data type is 16-bit IEEE-754 floating-point\n__half\ncuda_fp16.h\nCUDA_C_16F\nThe data type is 16-bit complex IEEE-754 floating-point\n__half2\ncuda_fp16.h\n[DEPRECATED]\nCUDA_R_16BF\nThe data type is 16-bit bfloat floating-point\n__nv_bfloat16\ncuda_bf16.h\nCUDA_C_16BF\nThe data type is 16-bit complex bfloat floating-point\n__nv_bfloat162\ncuda_bf16.h\n[DEPRECATED]\nCUDA_R_32F\nThe data type is 32-bit IEEE-754 floating-point\nfloat\nCUDA_C_32F\nThe data type is 32-bit complex IEEE-754 floating-point\ncuComplex\ncuComplex.h\nCUDA_R_64F\nThe data type is 64-bit IEEE-754 floating-point\ndouble\nCUDA_C_64F\nThe data type is 64-bit complex IEEE-754 floating-point\ncuDoubleComplex\ncuComplex.h\nCUDA_R_8I\nThe data type is 8-bit integer\nint8_t\nstdint.h\nCUDA_R_32I\nThe data type is 32-bit integer\nint32_t\nstdint.h\nIMPORTANT:\nThe Generic API routines allow all data types reported in the respective section of the documentation only on GPU architectures with\nnative\nsupport for them. If a specific GPU model does not provide\nnative\nsupport for a given data type, the routine returns\nCUSPARSE_STATUS_ARCH_MISMATCH\nerror.\nUnsupported data types and Compute Capability (CC):\n__half\non GPUs with\nCC\n<\n53\n(e.g. Kepler)\n__nv_bfloat16\non GPUs with\nCC\n<\n80\n(e.g. Kepler, Maxwell, Pascal, Volta, Turing)\nsee\nhttps://developer.nvidia.com/cuda-gpus\n4.1.2.\ncusparseStatus_t\n\nThis data type represents the status returned by the library functions and it can have the following values:\nValue\nDescription\nCUSPARSE_STATUS_SUCCESS\nThe operation completed successfully\nCUSPARSE_STATUS_NOT_INITIALIZED\nThe cuSPARSE library was not initialized. This is usually caused by the lack of a prior call, an error in the CUDA Runtime API called by the cuSPARSE routine, or an error in the hardware setup\nTo correct:\ncall\ncusparseCreate()\nprior to the function call; and check that the hardware, an appropriate version of the driver, and the cuSPARSE library are correctly installed\nThe error also applies to generic APIs (\ncuSPARSE Generic APIs\n) for indicating a matrix/vector descriptor not initialized\nCUSPARSE_STATUS_ALLOC_FAILED\nResource allocation failed inside the cuSPARSE library. This is usually caused by a device memory allocation (\ncudaMalloc()\n) or by a host memory allocation failure\nTo correct:\nprior to the function call, deallocate previously allocated memory as much as possible\nCUSPARSE_STATUS_INVALID_VALUE\nAn unsupported value or parameter was passed to the function (a negative vector size, for example)\nTo correct:\nensure that all the parameters being passed have valid values\nCUSPARSE_STATUS_ARCH_MISMATCH\nThe function requires a feature absent from the device architecture\nTo correct:\ncompile and run the application on a device with appropriate compute capability\nCUSPARSE_STATUS_EXECUTION_FAILED\nThe GPU program failed to execute. This is often caused by a launch failure of the kernel on the GPU, which can be caused by multiple reasons\nTo correct:\ncheck that the hardware, an appropriate version of the driver, and the cuSPARSE library are correctly installed\nCUSPARSE_STATUS_INTERNAL_ERROR\nAn internal cuSPARSE operation failed\nTo correct:\ncheck that the hardware, an appropriate version of the driver, and the cuSPARSE library are correctly installed. Also, check that the memory passed as a parameter to the routine is not being deallocated prior to the routine completion\nCUSPARSE_STATUS_MATRIX_TYPE_NOT_SUPPORTED\nThe matrix type is not supported by this function. This is usually caused by passing an invalid matrix descriptor to the function\nTo correct:\ncheck that the fields in\ncusparseMatDescr_t\ndescrA\nwere set correctly\nCUSPARSE_STATUS_NOT_SUPPORTED\nThe operation or data type combination is currently not supported by the function\nCUSPARSE_STATUS_INSUFFICIENT_RESOURCES\nThe resources for the computation, such as GPU global or shared memory, are not sufficient to complete the operation. The error can also indicate that the current computation mode (e.g. bit size of sparse matrix indices) does not allow to handle the given input\n4.1.3.\ncusparseHandle_t\n\nThis is a pointer type to an opaque cuSPARSE context, which the user must initialize by calling prior to calling\ncusparseCreate()\nany other library function. The handle created and returned by\ncusparseCreate()\nmust be passed to every cuSPARSE function.\n4.1.4.\ncusparsePointerMode_t\n\nThis type indicates whether the scalar values are passed by reference on the host or device. It is important to point out that if several scalar values are passed by reference in the function call, all of them will conform to the same single pointer mode. The pointer mode can be set and retrieved using\ncusparseSetPointerMode()\nand\ncusparseGetPointerMode()\nroutines, respectively.\nValue\nMeaning\nCUSPARSE_POINTER_MODE_HOST\nThe scalars are passed by reference on the host.\nCUSPARSE_POINTER_MODE_DEVICE\nThe scalars are passed by reference on the device.\n4.1.5.\ncusparseOperation_t\n\nThis type indicates which operations is applied to the related input (e.g. sparse matrix, or vector).\nValue\nMeaning\nCUSPARSE_OPERATION_NON_TRANSPOSE\nThe non-transpose operation is selected.\nCUSPARSE_OPERATION_TRANSPOSE\nThe transpose operation is selected.\nCUSPARSE_OPERATION_CONJUGATE_TRANSPOSE\nThe conjugate transpose operation is selected.\n4.1.6.\ncusparseDiagType_t\n\nThis type indicates if the matrix diagonal entries are unity. The diagonal elements are always assumed to be present, but if\nCUSPARSE_DIAG_TYPE_UNIT\nis passed to an API routine, then the routine assumes that all diagonal entries are unity and will not read or modify those entries. Note that in this case the routine assumes the diagonal entries are equal to one, regardless of what those entries are actually set to in memory.\nValue\nMeaning\nCUSPARSE_DIAG_TYPE_NON_UNIT\nThe matrix diagonal has non-unit elements.\nCUSPARSE_DIAG_TYPE_UNIT\nThe matrix diagonal has unit elements.\n4.1.7.\ncusparseFillMode_t\n\nThis type indicates if the lower or upper part of a matrix is stored in sparse storage.\nValue\nMeaning\nCUSPARSE_FILL_MODE_LOWER\nThe lower triangular part is stored.\nCUSPARSE_FILL_MODE_UPPER\nThe upper triangular part is stored.\n4.1.8.\ncusparseIndexBase_t\n\nThis type indicates if the base of the matrix indices is zero or one.\nValue\nMeaning\nCUSPARSE_INDEX_BASE_ZERO\nThe base index is zero (C compatibility).\nCUSPARSE_INDEX_BASE_ONE\nThe base index is one  (Fortran compatibility).\n4.1.9.\ncusparseDirection_t\n\nThis type indicates whether the elements of a dense matrix should be parsed by rows or by columns (assuming column-major storage in memory of the dense matrix) in function cusparse[S|D|C|Z]nnz. Besides storage format of blocks in BSR format is also controlled by this type.\nValue\nMeaning\nCUSPARSE_DIRECTION_ROW\nThe matrix should be parsed by rows.\nCUSPARSE_DIRECTION_COLUMN\nThe matrix should be parsed by columns.\n4.2.\ncuSPARSE Management API\n\nThe cuSPARSE functions for managing the library are described in this section.\n4.2.1.\ncusparseCreate()\n\ncusparseStatus_t\ncusparseCreate\n(\ncusparseHandle_t\n*\nhandle\n)\nThis function initializes the cuSPARSE library and creates a handle on the cuSPARSE context. It must be called before any other cuSPARSE API function is invoked. It allocates hardware resources necessary for accessing the GPU.\nParam.\nIn/out\nMeaning\nhandle\nIN\nThe pointer to the handle to the cuSPARSE context\nRefer to\ncusparseStatus_t\nfor the description of the return status.\n4.2.2.\ncusparseDestroy()\n\ncusparseStatus_t\ncusparseDestroy\n(\ncusparseHandle_t\nhandle\n)\nThis function releases CPU-side resources used by the cuSPARSE library. The release of GPU-side resources may be deferred until the application shuts down.\nParam.\nIn/out\nMeaning\nhandle\nIN\nThe handle to the cuSPARSE context\nRefer to\ncusparseStatus_t\nfor the description of the return status.\n4.2.3.\ncusparseGetErrorName()\n\nconst\nchar\n*\ncusparseGetErrorString\n(\ncusparseStatus_t\nstatus\n)\nThe function returns the string representation of an error code enum name. If the error code is not recognized, “unrecognized error code” is returned.\nParam.\nIn/out\nMeaning\nstatus\nIN\nError code to convert to string\nconst\nchar*\nOUT\nPointer to a NULL-terminated string\n4.2.4.\ncusparseGetErrorString()\n\nconst\nchar\n*\ncusparseGetErrorString\n(\ncusparseStatus_t\nstatus\n)\nReturns the description string for an error code. If the error code is not recognized, “unrecognized error code” is returned.\nParam.\nIn/out\nMeaning\nstatus\nIN\nError code to convert to string\nconst\nchar*\nOUT\nPointer to a NULL-terminated string\n4.2.5.\ncusparseGetProperty()\n\ncusparseStatus_t\ncusparseGetProperty\n(\nlibraryPropertyType\ntype\n,\nint\n*\nvalue\n)\nThe function returns the value of the requested property. Refer to\nlibraryPropertyType\nfor supported types.\nParam.\nIn/out\nMeaning\ntype\nIN\nRequested property\nvalue\nOUT\nValue of the requested property\nlibraryPropertyType\n(defined in\nlibrary_types.h\n):\nValue\nMeaning\nMAJOR_VERSION\nEnumerator to query the major version\nMINOR_VERSION\nEnumerator to query the minor version\nPATCH_LEVEL\nNumber to identify the patch level\nRefer to\ncusparseStatus_t\nfor the description of the return status.\n4.2.6.\ncusparseGetVersion()\n\ncusparseStatus_t\ncusparseGetVersion\n(\ncusparseHandle_t\nhandle\n,\nint\n*\nversion\n)\nThis function returns the version number of the cuSPARSE library.\nParam.\nIn/out\nMeaning\nhandle\nIN\ncuSPARSE handle\nversion\nOUT\nThe version number of the library\nRefer to\ncusparseStatus_t\nfor the description of the return status.\n4.2.7.\ncusparseGetPointerMode()\n\ncusparseStatus_t\ncusparseGetPointerMode\n(\ncusparseHandlet\nhandle\n,\ncusparsePointerMode_t\n*\nmode\n)\nThis function obtains the pointer mode used by the cuSPARSE library. Please see the section on the\ncusparsePointerMode_t\ntype for more details.\nParam.\nIn/out\nMeaning\nhandle\nIN\nThe handle to the cuSPARSE context\nmode\nOUT\nOne of the enumerated pointer mode types\nRefer to\ncusparseStatus_t\nfor the description of the return status.\n4.2.8.\ncusparseSetPointerMode()\n\ncusparseStatus_t\ncusparseSetPointerMode\n(\ncusparseHandle_t\nhandle\n,\ncusparsePointerMode_t\nmode\n)\nThis function sets the pointer mode used by the cuSPARSE library. The\ndefault\nis for the values to be passed by reference on the host. Please see the section on the\ncublasPointerMode_t\ntype for more details.\nParam.\nIn/out\nMeaning\nhandle\nIN\nThe handle to the cuSPARSE context\nmode\nIN\nOne of the enumerated pointer mode types\nRefer to\ncusparseStatus_t\nfor the description of the return status.\n4.2.9.\ncusparseGetStream()\n\ncusparseStatus_t\ncusparseGetStream\n(\ncusparseHandle_t\nhandle\n,\ncudaStream_t\n*\nstreamId\n)\nThis function gets the cuSPARSE library stream, which is being used to to execute all calls to the cuSPARSE library functions. If the cuSPARSE library stream is not set, all kernels use the default NULL stream.\nParam.\nIn/out\nMeaning\nhandle\nIN\nThe handle to the cuSPARSE context\nstreamId\nOUT\nThe stream used by the library\nRefer to\ncusparseStatus_t\nfor the description of the return status.\n4.2.10.\ncusparseSetStream()\n\ncusparseStatus_t\ncusparseSetStream\n(\ncusparseHandle_t\nhandle\n,\ncudaStream_t\nstreamId\n)\nThis function sets the stream to be used by the cuSPARSE library to execute its routines.\nParam.\nIn/out\nMeaning\nhandle\nIN\nThe handle to the cuSPARSE context\nstreamId\nIN\nThe stream to be used by the library\nRefer to\ncusparseStatus_t\nfor the description of the return status.\n4.3.\ncuSPARSE Logging API\n\ncuSPARSE logging mechanism can be enabled by setting the following environment variables before launching the target application:\nCUSPARSE_LOG_LEVEL=<level>\n- while level is one of the following levels:\n0\n-\nOff\n- logging is disabled (default)\n1\n-\nError\n- only errors will be logged\n2\n-\nTrace\n- API calls that launch CUDA kernels will log their parameters and important information\n3\n-\nHints\n- hints that can potentially improve the application’s performance\n4\n-\nInfo\n- provides general information about the library execution, may contain details about heuristic status\n5\n-\nAPI Trace\n- API calls will log their parameter and important information\nCUSPARSE_LOG_MASK=<mask>\n- while mask is a combination of the following masks:\n0\n-\nOff\n1\n-\nError\n2\n-\nTrace\n4\n-\nHints\n8\n-\nInfo\n16\n-\nAPI Trace\nCUSPARSE_LOG_FILE=<file_name>\n- while file name is a path to a logging file. File name may contain\n%i\n, that will be replaced with the process id. E.g\n<file_name>_%i.log\n.\nIf\nCUSPARSE_LOG_FILE\nis not defined, the log messages are printed to\nstdout\n.\nStarting from CUDA 12.3, it is also possible to dump sparse matrices (CSR, CSC, COO, SELL, BSR) in binary files during the creation by setting the environment variable\nCUSPARSE_STORE_INPUT_MATRIX\n. Later on, the binary files can be send to\nMath-Libs-Feedback\n@\nnvidia\n.\ncom\nfor debugging and reproducibility purposes of a specific correctness/performance issue.\nAnother option is to use the experimental cuSPARSE logging API. Refer to:\ncusparseLoggerSetCallback()\ncusparseLoggerSetFile()\ncusparseLoggerOpenFile()\ncusparseLoggerSetLevel()\ncusparseLoggerSetMask()\nNote\nThe logging mechanism is not available for the legacy APIs.\n4.3.1.\ncusparseLoggerSetCallback()\n\ncusparseStatus_t\ncusparseLoggerSetCallback\n(\ncusparseLoggerCallback_t\ncallback\n)\nExperimental\n: The function sets the logging callback function.\nParam.\nIn/out\nMeaning\ncallback\nIN\nPointer to a callback function\nwhere\ncusparseLoggerCallback_t\nhas the following signature:\nvoid\n(\n*\ncusparseLoggerCallback_t\n)(\nint\nlogLevel\n,\nconst\nchar\n*\nfunctionName\n,\nconst\nchar\n*\nmessage\n)\nParam.\nIn/out\nMeaning\nlogLevel\nIN\nSelected log level\nfunctionName\nIN\nThe name of the API that logged this message\nmessage\nIN\nThe log message\nSee\ncusparseStatus_t\nfor the description of the return status.\n4.3.2.\ncusparseLoggerSetFile()\n\ncusparseStatus_t\ncusparseLoggerSetFile\n(\nFILE\n*\nfile\n)\nExperimental\n: The function sets the logging output file. Note: once registered using this function call, the provided file handle must not be closed unless the function is called again to switch to a different file handle.\nParam.\nIn/out\nMeaning\nfile\nIN\nPointer to an open file. File should have write permission\nSee\ncusparseStatus_t\nfor the description of the return status.\n4.3.3.\ncusparseLoggerOpenFile()\n\ncusparseStatus_t\ncusparseLoggerOpenFile\n(\nconst\nchar\n*\nlogFile\n)\nExperimental\n: The function opens a logging output file in the given path.\nParam.\nIn/out\nMeaning\nlogFile\nIN\nPath of the logging output file\nSee\ncusparseStatus_t\nfor the description of the return status.\n4.3.4.\ncusparseLoggerSetLevel()\n\ncusparseStatus_t\ncusparseLoggerSetLevel\n(\nint\nlevel\n)\nExperimental\n: The function sets the value of the logging level. path.\nParam.\nIn/out\nMeaning\nlevel\nIN\nValue of the logging level\nSee\ncusparseStatus_t\nfor the description of the return status\n4.3.5.\ncusparseLoggerSetMask()\n\ncusparseStatus_t\ncusparseLoggerSetMask\n(\nint\nmask\n)\nExperimental\n: The function sets the value of the logging mask.\nParam.\nIn/out\nMeaning\nmask\nIN\nValue of the logging mask\nSee\ncusparseStatus_t\nfor the description of the return status\n5.\ncuSPARSE Legacy APIs\n\n5.1.\nNaming Conventions\n\nThe cuSPARSE legacy functions are available for data types\nfloat\n,\ndouble\n,\ncuComplex\n, and\ncuDoubleComplex\n. The sparse Level 2, and Level 3 functions follow this naming convention:\ncusparse\n<\nt\n>[<\nmatrix\ndata\nformat\n>]<\noperation\n>[<\noutput\nmatrix\ndata\nformat\n>]\nwhere <\nt\n> can be\nS\n,\nD\n,\nC\n,\nZ\n, or\nX\n, corresponding to the data types\nfloat\n,\ndouble\n,\ncuComplex\n,\ncuDoubleComplex\n, and the generic type, respectively.\nThe <\nmatrix\ndata\nformat\n> can be\ndense\n,\ncoo\n,\ncsr\n, or\ncsc\n, corresponding to the dense, coordinate, compressed sparse row, and compressed sparse column formats, respectively.\n5.2.\ncuSPARSE Legacy Types Reference\n\n5.2.1.\ncusparseAction_t\n\nThis type indicates whether the operation is performed only on indices or on data and indices.\nValue\nMeaning\nCUSPARSE_ACTION_SYMBOLIC\nthe operation is performed only on indices.\nCUSPARSE_ACTION_NUMERIC\nthe operation is performed on data and indices.\n5.2.2.\ncusparseMatDescr_t\n\nThis structure is used to describe the shape and properties of a matrix.\ntypedef\nstruct\n{\ncusparseMatrixType_t\nMatrixType\n;\ncusparseFillMode_t\nFillMode\n;\ncusparseDiagType_t\nDiagType\n;\ncusparseIndexBase_t\nIndexBase\n;\n}\ncusparseMatDescr_t\n;\n5.2.3.\ncusparseMatrixType_t\n\nThis type indicates the type of matrix stored in sparse storage. Notice that for symmetric, Hermitian and triangular matrices only their lower or upper part is assumed to be stored.\nThe whole idea of matrix type and fill mode is to keep minimum storage for symmetric/Hermitian matrix, and also to take advantage of symmetric property on SpMV (Sparse Matrix Vector multiplication). To compute\ny=A*x\nwhen\nA\nis symmetric and only lower triangular part is stored, two steps are needed. First step is to compute\ny=(L+D)*x\nand second step is to compute\ny=L^T*x\n+\ny\n. Given the fact that the transpose operation\ny=L^T*x\nis 10x slower than non-transpose version\ny=L*x\n, the symmetric property does not show up any performance gain. It is better for the user to extend the symmetric matrix to a general matrix and apply\ny=A*x\nwith matrix type\nCUSPARSE_MATRIX_TYPE_GENERAL\n.\nIn general, SpMV, preconditioners (incomplete Cholesky or incomplete LU) and triangular solver are combined together in iterative solvers, for example PCG and GMRES. If the user always uses general matrix (instead of symmetric matrix), there is no need to support other than general matrix in preconditioners. Therefore the new routines,\n[bsr|csr]sv2\n(triangular solver),\n[bsr|csr]ilu02\n(incomplete LU) and\n[bsr|csr]ic02\n(incomplete Cholesky), only support matrix type\nCUSPARSE_MATRIX_TYPE_GENERAL\n.\nValue\nMeaning\nCUSPARSE_MATRIX_TYPE_GENERAL\nthe matrix is general.\nCUSPARSE_MATRIX_TYPE_SYMMETRIC\nthe matrix is symmetric.\nCUSPARSE_MATRIX_TYPE_HERMITIAN\nthe matrix is Hermitian.\nCUSPARSE_MATRIX_TYPE_TRIANGULAR\nthe matrix is triangular.\n5.2.4.\ncusparseColorInfo_t [DEPRECATED]\n\nThis is a pointer type to an opaque structure holding the information used in\ncsrcolor()\n.\n5.2.5.\ncusparseSolvePolicy_t [DEPRECATED]\n\nThis type indicates whether level information is generated and used in\ncsrsv2,\ncsric02,\ncsrilu02,\nbsrsv2,\nbsric02\nand\nbsrilu02\n.\nValue\nMeaning\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\nno level information is generated and used.\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\ngenerate and use level information.\n5.2.6.\nbsric02Info_t [DEPRECATED]\n\nThis is a pointer type to an opaque structure holding the information used in\nbsric02_bufferSize()\n,\nbsric02_analysis()\n, and\nbsric02()\n.\n5.2.7.\nbsrilu02Info_t [DEPRECATED]\n\nThis is a pointer type to an opaque structure holding the information used in\nbsrilu02_bufferSize()\n,\nbsrilu02_analysis()\n, and\nbsrilu02()\n.\n5.2.8.\nbsrsm2Info_t [DEPRECATED]\n\nThis is a pointer type to an opaque structure holding the information used in\nbsrsm2_bufferSize()\n,\nbsrsm2_analysis()\n, and\nbsrsm2_solve()\n.\n5.2.9.\nbsrsv2Info_t [DEPRECATED]\n\nThis is a pointer type to an opaque structure holding the information used in\nbsrsv2_bufferSize()\n,\nbsrsv2_analysis()\n, and\nbsrsv2_solve()\n.\n5.2.10.\ncsric02Info_t [DEPRECATED]\n\nThis is a pointer type to an opaque structure holding the information used in\ncsric02_bufferSize()\n,\ncsric02_analysis()\n, and\ncsric02()\n.\n5.2.11.\ncsrilu02Info_t [DEPRECATED]\n\nThis is a pointer type to an opaque structure holding the information used in\ncsrilu02_bufferSize()\n,\ncsrilu02_analysis()\n, and\ncsrilu02()\n.\n5.3.\ncuSPARSE Helper Function Reference\n\nThe cuSPARSE helper functions are described in this section.\n5.3.1.\ncusparseCreateColorInfo() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseCreateColorInfo\n(\ncusparseColorInfo_t\n*\ninfo\n)\nThis function creates and initializes the\ncusparseColorInfo_t\nstructure to\ndefault\nvalues.\nInput\ninfo\nthe pointer to the\ncusparseColorInfo_t\nstructure\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.3.2.\ncusparseCreateMatDescr()\n\ncusparseStatus_t\ncusparseCreateMatDescr\n(\ncusparseMatDescr_t\n*\ndescrA\n)\nThis function initializes the matrix descriptor. It sets the fields\nMatrixType\nand\nIndexBase\nto the\ndefault\nvalues\nCUSPARSE_MATRIX_TYPE_GENERAL\nand\nCUSPARSE_INDEX_BASE_ZERO\n, respectively, while leaving other fields uninitialized.\nInput\ndescrA\nthe pointer to the matrix descriptor.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.3.3.\ncusparseDestroyColorInfo() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseDestroyColorInfo\n(\ncusparseColorInfo_t\ninfo\n)\nThis function destroys and releases any memory required by the structure.\nInput\ninfo\nthe pointer to the structure of\ncsrcolor()\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.3.4.\ncusparseDestroyMatDescr()\n\ncusparseStatus_t\ncusparseDestroyMatDescr\n(\ncusparseMatDescr_t\ndescrA\n)\nThis function releases the memory allocated for the matrix descriptor.\nInput\ndescrA\nthe matrix descriptor.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.3.5.\ncusparseGetMatDiagType()\n\ncusparseDiagType_t\ncusparseGetMatDiagType\n(\nconst\ncusparseMatDescr_t\ndescrA\n)\nThis function returns the\nDiagType\nfield of the matrix descriptor\ndescrA\n.\nInput\ndescrA\nthe matrix descriptor.\nReturned\nOne of the enumerated diagType types.\n5.3.6.\ncusparseGetMatFillMode()\n\ncusparseFillMode_t\ncusparseGetMatFillMode\n(\nconst\ncusparseMatDescr_t\ndescrA\n)\nThis function returns the\nFillMode\nfield of the matrix descriptor\ndescrA\n.\nInput\ndescrA\nthe matrix descriptor.\nReturned\nOne of the enumerated fillMode types.\n5.3.7.\ncusparseGetMatIndexBase()\n\ncusparseIndexBase_t\ncusparseGetMatIndexBase\n(\nconst\ncusparseMatDescr_t\ndescrA\n)\nThis function returns the\nIndexBase\nfield of the matrix descriptor\ndescrA\n.\nInput\ndescrA\nthe matrix descriptor.\nReturned\nOne of the enumerated indexBase types.\n5.3.8.\ncusparseGetMatType()\n\ncusparseMatrixType_t\ncusparseGetMatType\n(\nconst\ncusparseMatDescr_t\ndescrA\n)\nThis function returns the\nMatrixType\nfield of the matrix descriptor\ndescrA\n.\nInput\ndescrA\nthe matrix descriptor.\nReturned\nOne of the enumerated matrix types.\n5.3.9.\ncusparseSetMatDiagType()\n\ncusparseStatus_t\ncusparseSetMatDiagType\n(\ncusparseMatDescr_t\ndescrA\n,\ncusparseDiagType_t\ndiagType\n)\nThis function sets the\nDiagType\nfield of the matrix descriptor\ndescrA\n.\nInput\ndiagType\nOne of the enumerated diagType types.\nOutput\ndescrA\nthe matrix descriptor.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.3.10.\ncusparseSetMatFillMode()\n\ncusparseStatus_t\ncusparseSetMatFillMode\n(\ncusparseMatDescr_t\ndescrA\n,\ncusparseFillMode_t\nfillMode\n)\nThis function sets the\nFillMode\nfield of the matrix descriptor\ndescrA\n.\nInput\nfillMode\nOne of the enumerated fillMode types.\nOutput\ndescrA\nthe matrix descriptor.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.3.11.\ncusparseSetMatIndexBase()\n\ncusparseStatus_t\ncusparseSetMatIndexBase\n(\ncusparseMatDescr_t\ndescrA\n,\ncusparseIndexBase_t\nbase\n)\nThis function sets the\nIndexBase\nfield of the matrix descriptor\ndescrA\n.\nInput\nbase\nOne of the enumerated indexBase types.\nOutput\ndescrA\nthe matrix descriptor.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.3.12.\ncusparseSetMatType()\n\ncusparseStatus_t\ncusparseSetMatType\n(\ncusparseMatDescr_t\ndescrA\n,\ncusparseMatrixType_t\ntype\n)\nThis function sets the\nMatrixType\nfield of the matrix descriptor\ndescrA\n.\nInput\ntype\nOne of the enumerated matrix types.\nOutput\ndescrA\nthe matrix descriptor.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.3.13.\ncusparseCreateCsric02Info() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseCreateCsric02Info\n(\ncsric02Info_t\n*\ninfo\n);\nThis function creates and initializes the solve and analysis structure of incomplete Cholesky to\ndefault\nvalues.\nInput\ninfo\nthe pointer to the solve and analysis structure of incomplete Cholesky.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.3.14.\ncusparseDestroyCsric02Info() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseDestroyCsric02Info\n(\ncsric02Info_t\ninfo\n);\nThis function destroys and releases any memory required by the structure.\nInput\ninfo\nthe solve\n(csric02_solve)\nand analysis\n(csric02_analysis)\nstructure.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.3.15.\ncusparseCreateCsrilu02Info() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseCreateCsrilu02Info\n(\ncsrilu02Info_t\n*\ninfo\n);\nThis function creates and initializes the solve and analysis structure of incomplete LU to\ndefault\nvalues.\nInput\ninfo\nthe pointer to the solve and analysis structure of incomplete LU.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.3.16.\ncusparseDestroyCsrilu02Info() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseDestroyCsrilu02Info\n(\ncsrilu02Info_t\ninfo\n);\nThis function destroys and releases any memory required by the structure.\nInput\ninfo\nthe solve\n(csrilu02_solve)\nand analysis\n(csrilu02_analysis)\nstructure.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.3.17.\ncusparseCreateBsrsv2Info() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseCreateBsrsv2Info\n(\nbsrsv2Info_t\n*\ninfo\n);\nThis function creates and initializes the solve and analysis structure of bsrsv2 to\ndefault\nvalues.\nInput\ninfo\nthe pointer to the solve and analysis structure of bsrsv2.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.3.18.\ncusparseDestroyBsrsv2Info() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseDestroyBsrsv2Info\n(\nbsrsv2Info_t\ninfo\n);\nThis function destroys and releases any memory required by the structure.\nInput\ninfo\nthe solve\n(bsrsv2_solve)\nand analysis\n(bsrsv2_analysis)\nstructure.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.3.19.\ncusparseCreateBsrsm2Info() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseCreateBsrsm2Info\n(\nbsrsm2Info_t\n*\ninfo\n);\nThis function creates and initializes the solve and analysis structure of bsrsm2 to\ndefault\nvalues.\nInput\ninfo\nthe pointer to the solve and analysis structure of bsrsm2.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.3.20.\ncusparseDestroyBsrsm2Info() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseDestroyBsrsm2Info\n(\nbsrsm2Info_t\ninfo\n);\nThis function destroys and releases any memory required by the structure.\nInput\ninfo\nthe solve\n(bsrsm2_solve)\nand analysis\n(bsrsm2_analysis)\nstructure.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.3.21.\ncusparseCreateBsric02Info() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseCreateBsric02Info\n(\nbsric02Info_t\n*\ninfo\n);\nThis function creates and initializes the solve and analysis structure of block incomplete Cholesky to\ndefault\nvalues.\nInput\ninfo\nthe pointer to the solve and analysis structure of block incomplete Cholesky.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.3.22.\ncusparseDestroyBsric02Info() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseDestroyBsric02Info\n(\nbsric02Info_t\ninfo\n);\nThis function destroys and releases any memory required by the structure.\nInput\ninfo\nthe solve\n(bsric02_solve)\nand analysis\n(bsric02_analysis)\nstructure.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.3.23.\ncusparseCreateBsrilu02Info() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseCreateBsrilu02Info\n(\nbsrilu02Info_t\n*\ninfo\n);\nThis function creates and initializes the solve and analysis structure of block incomplete LU to\ndefault\nvalues.\nInput\ninfo\nthe pointer to the solve and analysis structure of block incomplete LU.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.3.24.\ncusparseDestroyBsrilu02Info() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseDestroyBsrilu02Info\n(\nbsrilu02Info_t\ninfo\n);\nThis function destroys and releases any memory required by the structure.\nInput\ninfo\nthe solve\n(bsrilu02_solve)\nand analysis\n(bsrilu02_analysis)\nstructure.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.3.25.\ncusparseCreatePruneInfo() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseCreatePruneInfo\n(\npruneInfo_t\n*\ninfo\n);\nThis function creates and initializes structure of\nprune\nto\ndefault\nvalues.\nInput\ninfo\nthe pointer to the structure of\nprune\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.3.26.\ncusparseDestroyPruneInfo() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseDestroyPruneInfo\n(\npruneInfo_t\ninfo\n);\nThis function destroys and releases any memory required by the structure.\nInput\ninfo\nthe structure of\nprune\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.4.\ncuSPARSE Level 2 Function Reference\n\nThis chapter describes the sparse linear algebra functions that perform operations between sparse matrices and dense vectors.\n5.4.1.\ncusparse<t>bsrmv() [DEPRECATED]\n\ncusparseStatus_t\ncusparseSbsrmv\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\ncusparseOperation_t\ntrans\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\nfloat\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescr\n,\nconst\nfloat\n*\nbsrVal\n,\nconst\nint\n*\nbsrRowPtr\n,\nconst\nint\n*\nbsrColInd\n,\nint\nblockDim\n,\nconst\nfloat\n*\nx\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\ny\n)\ncusparseStatus_t\ncusparseDbsrmv\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\ncusparseOperation_t\ntrans\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\ndouble\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescr\n,\nconst\ndouble\n*\nbsrVal\n,\nconst\nint\n*\nbsrRowPtr\n,\nconst\nint\n*\nbsrColInd\n,\nint\nblockDim\n,\nconst\ndouble\n*\nx\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\ny\n)\ncusparseStatus_t\ncusparseCbsrmv\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\ncusparseOperation_t\ntrans\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescr\n,\nconst\ncuComplex\n*\nbsrVal\n,\nconst\nint\n*\nbsrRowPtr\n,\nconst\nint\n*\nbsrColInd\n,\nint\nblockDim\n,\nconst\ncuComplex\n*\nx\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\ny\n)\ncusparseStatus_t\ncusparseZbsrmv\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\ncusparseOperation_t\ntrans\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescr\n,\nconst\ncuDoubleComplex\n*\nbsrVal\n,\nconst\nint\n*\nbsrRowPtr\n,\nconst\nint\n*\nbsrColInd\n,\nint\nblockDim\n,\nconst\ncuDoubleComplex\n*\nx\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\ny\n)\nThis function performs the matrix-vector operation\n\\[\\text{y} = \\alpha \\ast \\text{op}(A) \\ast \\text{x} + \\beta \\ast \\text{y}\\]\nwhere\n\\(A\\text{ is an }(mb \\ast blockDim) \\times (nb \\ast blockDim)\\)\nsparse matrix that is defined in BSR storage format by the three arrays\nbsrVal\n,\nbsrRowPtr\n, and\nbsrColInd\n);\nx\nand\ny\nare vectors;\n\\(\\alpha\\text{ and }\\beta\\)\nare scalars; and\nbsrmv()\nhas the following properties:\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nSeveral comments on\nbsrmv()\n:\nOnly\nblockDim\n>\n1\nis supported\nOnly\nCUSPARSE_OPERATION_NON_TRANSPOSE\nis supported, that is\n\\[\\text{y} = \\alpha \\ast A \\ast \\text{x} + \\beta{} \\ast \\text{y}\\]\nOnly\nCUSPARSE_MATRIX_TYPE_GENERAL\nis supported.\nThe size of vector\nx\nshould be\n\\((nb \\ast blockDim)\\)\nat least, and the size of vector\ny\nshould be\n\\((mb \\ast blockDim)\\)\nat least; otherwise, the kernel may return\nCUSPARSE_STATUS_EXECUTION_FAILED\nbecause of an out-of-bounds array.\nFor example, suppose the user has a CSR format and wants to try\nbsrmv()\n, the following code demonstrates how to use\ncsr2bsr()\nconversion and\nbsrmv()\nmultiplication in single precision.\n// Suppose that A is m x n sparse matrix represented by CSR format,\n// hx is a host vector of size n, and hy is also a host vector of size m.\n// m and n are not multiple of blockDim.\n// step 1: transform CSR to BSR with column-major order\nint\nbase\n,\nnnz\n;\nint\nnnzb\n;\ncusparseDirection_t\ndirA\n=\nCUSPARSE_DIRECTION_COLUMN\n;\nint\nmb\n=\n(\nm\n+\nblockDim\n-1\n)\n/\nblockDim\n;\nint\nnb\n=\n(\nn\n+\nblockDim\n-1\n)\n/\nblockDim\n;\ncudaMalloc\n((\nvoid\n**\n)\n&\nbsrRowPtrC\n,\nsizeof\n(\nint\n)\n*\n(\nmb\n+\n1\n));\ncusparseXcsr2bsrNnz\n(\nhandle\n,\ndirA\n,\nm\n,\nn\n,\ndescrA\n,\ncsrRowPtrA\n,\ncsrColIndA\n,\nblockDim\n,\ndescrC\n,\nbsrRowPtrC\n,\n&\nnnzb\n);\ncudaMalloc\n((\nvoid\n**\n)\n&\nbsrColIndC\n,\nsizeof\n(\nint\n)\n*\nnnzb\n);\ncudaMalloc\n((\nvoid\n**\n)\n&\nbsrValC\n,\nsizeof\n(\nfloat\n)\n*\n(\nblockDim\n*\nblockDim\n)\n*\nnnzb\n);\ncusparseScsr2bsr\n(\nhandle\n,\ndirA\n,\nm\n,\nn\n,\ndescrA\n,\ncsrValA\n,\ncsrRowPtrA\n,\ncsrColIndA\n,\nblockDim\n,\ndescrC\n,\nbsrValC\n,\nbsrRowPtrC\n,\nbsrColIndC\n);\n// step 2: allocate vector x and vector y large enough for bsrmv\ncudaMalloc\n((\nvoid\n**\n)\n&\nx\n,\nsizeof\n(\nfloat\n)\n*\n(\nnb\n*\nblockDim\n));\ncudaMalloc\n((\nvoid\n**\n)\n&\ny\n,\nsizeof\n(\nfloat\n)\n*\n(\nmb\n*\nblockDim\n));\ncudaMemcpy\n(\nx\n,\nhx\n,\nsizeof\n(\nfloat\n)\n*\nn\n,\ncudaMemcpyHostToDevice\n);\ncudaMemcpy\n(\ny\n,\nhy\n,\nsizeof\n(\nfloat\n)\n*\nm\n,\ncudaMemcpyHostToDevice\n);\n// step 3: perform bsrmv\ncusparseSbsrmv\n(\nhandle\n,\ndirA\n,\ntransA\n,\nmb\n,\nnb\n,\nnnzb\n,\n&\nalpha\n,\ndescrC\n,\nbsrValC\n,\nbsrRowPtrC\n,\nbsrColIndC\n,\nblockDim\n,\nx\n,\n&\nbeta\n,\ny\n);\nInput\nhandle\nhandle to the cuSPARSE library context.\ndir\nstorage format of blocks, either\nCUSPARSE_DIRECTION_ROW\nor\nCUSPARSE_DIRECTION_COLUMN\n.\ntrans\nthe operation\n\\(\\text{op}(A)\\)\n. Only\nCUSPARSE_OPERATION_NON_TRANSPOSE\nis supported.\nmb\nnumber of block rows of matrix\n\\(A\\)\n.\nnb\nnumber of block columns of matrix\n\\(A\\)\n.\nnnzb\nnumber of nonzero blocks of matrix\n\\(A\\)\n.\nalpha\n<type> scalar used for multiplication.\ndescr\nthe descriptor of matrix\n\\(A\\)\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\nbsrVal\n<type> array of\nnnz\n\\(( =\\)\ncsrRowPtrA(mb)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\nnonzero blocks of matrix\n\\(A\\)\n.\nbsrRowPtr\ninteger array of\nmb\n\\(+ 1\\)\nelements that contains the start of every block row and the end of the last block row plus one.\nbsrColInd\ninteger array of\nnnz\n\\(( =\\)\ncsrRowPtrA(mb)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero blocks of matrix\n\\(A\\)\n.\nblockDim\nblock dimension of sparse matrix\n\\(A\\)\n, larger than zero.\nx\n<type> vector of\n\\(nb \\ast blockDim\\)\nelements.\nbeta\n<type> scalar used for multiplication. If\nbeta\nis zero,\ny\ndoes not have to be a valid input.\ny\n<type> vector of\n\\(mb \\ast blockDim\\)\nelements.\nOutput\ny\n<type> updated vector.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.4.2.\ncusparse<t>bsrxmv() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseSbsrxmv\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\ncusparseOperation_t\ntrans\n,\nint\nsizeOfMask\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\nfloat\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescr\n,\nconst\nfloat\n*\nbsrVal\n,\nconst\nint\n*\nbsrMaskPtr\n,\nconst\nint\n*\nbsrRowPtr\n,\nconst\nint\n*\nbsrEndPtr\n,\nconst\nint\n*\nbsrColInd\n,\nint\nblockDim\n,\nconst\nfloat\n*\nx\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\ny\n)\ncusparseStatus_t\ncusparseDbsrxmv\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\ncusparseOperation_t\ntrans\n,\nint\nsizeOfMask\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\ndouble\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescr\n,\nconst\ndouble\n*\nbsrVal\n,\nconst\nint\n*\nbsrMaskPtr\n,\nconst\nint\n*\nbsrRowPtr\n,\nconst\nint\n*\nbsrEndPtr\n,\nconst\nint\n*\nbsrColInd\n,\nint\nblockDim\n,\nconst\ndouble\n*\nx\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\ny\n)\ncusparseStatus_t\ncusparseCbsrxmv\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\ncusparseOperation_t\ntrans\n,\nint\nsizeOfMask\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescr\n,\nconst\ncuComplex\n*\nbsrVal\n,\nconst\nint\n*\nbsrMaskPtr\n,\nconst\nint\n*\nbsrRowPtr\n,\nconst\nint\n*\nbsrEndPtr\n,\nconst\nint\n*\nbsrColInd\n,\nint\nblockDim\n,\nconst\ncuComplex\n*\nx\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\ny\n)\ncusparseStatus_t\ncusparseZbsrxmv\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\ncusparseOperation_t\ntrans\n,\nint\nsizeOfMask\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescr\n,\nconst\ncuDoubleComplex\n*\nbsrVal\n,\nconst\nint\n*\nbsrMaskPtr\n,\nconst\nint\n*\nbsrRowPtr\n,\nconst\nint\n*\nbsrEndPtr\n,\nconst\nint\n*\nbsrColInd\n,\nint\nblockDim\n,\nconst\ncuDoubleComplex\n*\nx\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\ny\n)\nThis function performs a\nbsrmv\nand a mask operation\n\\[\\text{y(mask)} = (\\alpha \\ast \\text{op}(A) \\ast \\text{x} + \\beta \\ast \\text{y})\\text{(mask)}\\]\nwhere\n\\(A\\text{ is an }(mb \\ast blockDim) \\times (nb \\ast blockDim)\\)\nsparse matrix that is defined in BSRX storage format by the four arrays\nbsrVal\n,\nbsrRowPtr\n,\nbsrEndPtr\n, and\nbsrColInd\n);\nx\nand\ny\nare vectors;\n\\(\\alpha\\text{~and~}\\beta\\)\nare scalars; and\nThe mask operation is defined by array\nbsrMaskPtr\nwhich contains updated block row indices of\n\\(y\\)\n. If row\n\\(i\\)\nis not specified in\nbsrMaskPtr\n, then\nbsrxmv()\ndoes not touch row block\n\\(i\\)\nof\n\\(A\\)\nand\n\\(y\\)\n.\nFor example, consider the\n\\(2 \\times 3\\)\nblock matrix\n\\(A\\)\n:\n\\[\\begin{split}\\begin{matrix}\n{A = \\begin{bmatrix}\nA_{11} & A_{12} & O \\\\\nA_{21} & A_{22} & A_{23} \\\\\n\\end{bmatrix}} \\\\\n\\end{matrix}\\end{split}\\]\nand its one-based BSR format (three vector form) is:\n\\[\\begin{split}\\begin{matrix}\n\\text{bsrVal} & = & \\begin{bmatrix}\nA_{11} & A_{12} & A_{21} & A_{22} & A_{23} \\\\\n\\end{bmatrix} \\\\\n\\text{bsrRowPtr} & = & \\begin{bmatrix}\n{1\\phantom{.0}} & {3\\phantom{.0}} & 6 \\\\\n\\end{bmatrix} \\\\\n\\text{bsrColInd} & = & \\begin{bmatrix}\n{1\\phantom{.0}} & {2\\phantom{.0}} & {1\\phantom{.0}} & {2\\phantom{.0}} & 3 \\\\\n\\end{bmatrix} \\\\\n\\end{matrix}\\end{split}\\]\nSuppose we want to do the following\nbsrmv\noperation on a matrix\n\\(\\bar{A}\\)\nwhich is slightly different from\n\\(A\\)\n.\n\\[\\begin{split}\\begin{bmatrix}\ny_{1} \\\\\ny_{2} \\\\\n\\end{bmatrix}:=alpha \\ast (\\widetilde{A} = \\begin{bmatrix}\nO & O & O \\\\\nO & A_{22} & O \\\\\n\\end{bmatrix}) \\ast \\begin{bmatrix}\nx_{1} \\\\\nx_{2} \\\\\nx_{3} \\\\\n\\end{bmatrix} + \\begin{bmatrix}\ny_{1} \\\\\n{beta \\ast y_{2}} \\\\\n\\end{bmatrix}\\end{split}\\]\nWe don’t need to create another BSR format for the new matrix\n\\(\\bar{A}\\)\n, all that we should do is to keep\nbsrVal\nand\nbsrColInd\nunchanged, but modify\nbsrRowPtr\nand add an additional array\nbsrEndPtr\nwhich points to the last nonzero elements per row of\n\\(\\bar{A}\\)\nplus 1.\nFor example, the following\nbsrRowPtr\nand\nbsrEndPtr\ncan represent matrix\n\\(\\bar{A}\\)\n:\n\\[\\begin{split}\\begin{matrix}\n\\text{bsrRowPtr} & = & \\begin{bmatrix}\n{1\\phantom{.0}} & 4 \\\\\n\\end{bmatrix} \\\\\n\\text{bsrEndPtr} & = & \\begin{bmatrix}\n{1\\phantom{.0}} & 5 \\\\\n\\end{bmatrix} \\\\\n\\end{matrix}\\end{split}\\]\nFurther we can use a mask operator (specified by array\nbsrMaskPtr\n) to update particular block row indices of\n\\(y\\)\nonly because\n\\(y_{1}\\)\nis never changed. In this case,\nbsrMaskPtr\n\\(=\\)\n[2] and\nsizeOfMask\n=1.\nThe mask operator is equivalent to the following operation:\n\\[\\begin{split}\\begin{bmatrix}\n? \\\\\ny_{2} \\\\\n\\end{bmatrix}:=alpha \\ast \\begin{bmatrix}\n? & ? & ? \\\\\nO & A_{22} & O \\\\\n\\end{bmatrix} \\ast \\begin{bmatrix}\nx_{1} \\\\\nx_{2} \\\\\nx_{3} \\\\\n\\end{bmatrix} + beta \\ast \\begin{bmatrix}\n? \\\\\ny_{2} \\\\\n\\end{bmatrix}\\end{split}\\]\nIf a block row is not present in the\nbsrMaskPtr\n, then no calculation is performed on that row, and the corresponding value in\ny\nis unmodified. The question mark “?” is used to inidcate row blocks not in\nbsrMaskPtr\n.\nIn this case, first row block is not present in\nbsrMaskPtr\n, so\nbsrRowPtr[0]\nand\nbsrEndPtr[0]\nare not touched also.\n\\[\\begin{split}\\begin{matrix}\n\\text{bsrRowPtr} & = & \\begin{bmatrix}\n{?\\phantom{.0}} & 4 \\\\\n\\end{bmatrix} \\\\\n\\text{bsrEndPtr} & = & \\begin{bmatrix}\n{?\\phantom{.0}} & 5 \\\\\n\\end{bmatrix} \\\\\n\\end{matrix}\\end{split}\\]\nbsrxmv()\nhas the following properties:\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nA couple of comments on\nbsrxmv()\n:\nOnly\nblockDim\n>\n1\nis supported\nOnly\nCUSPARSE_OPERATION_NON_TRANSPOSE\nand\nCUSPARSE_MATRIX_TYPE_GENERAL\nare supported.\nParameters\nbsrMaskPtr\n,\nbsrRowPtr\n,\nbsrEndPtr\nand\nbsrColInd\nare consistent with base index, either one-based or zero-based. The above example is one-based.\nInput\nhandle\nhandle to the cuSPARSE library context.\ndir\nstorage format of blocks, either\nCUSPARSE_DIRECTION_ROW\nor\nCUSPARSE_DIRECTION_COLUMN\n.\ntrans\nthe operation\n\\(\\text{op}(A)\\)\n. Only\nCUSPARSE_OPERATION_NON_TRANSPOSE\nis supported.\nsizeOfMask\nnumber of updated block rows of\n\\(y\\)\n.\nmb\nnumber of block rows of matrix\n\\(A\\)\n.\nnb\nnumber of block columns of matrix\n\\(A\\)\n.\nnnzb\nnumber of nonzero blocks of matrix\n\\(A\\)\n.\nalpha\n<type> scalar used for multiplication.\ndescr\nthe descriptor of matrix\n\\(A\\)\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\nbsrVal\n<type> array of\nnnz\nnonzero blocks of matrix\n\\(A\\)\n.\nbsrMaskPtr\ninteger array of\nsizeOfMask\nelements that contains the indices corresponding to updated block rows.\nbsrRowPtr\ninteger array of\nmb\nelements that contains the start of every block row.\nbsrEndPtr\ninteger array of\nmb\nelements that contains the end of the every block row plus one.\nbsrColInd\ninteger array of\nnnzb\ncolumn indices of the nonzero blocks of matrix\n\\(A\\)\n.\nblockDim\nblock dimension of sparse matrix\n\\(A\\)\n, larger than zero.\nx\n<type> vector of\n\\(nb \\ast blockDim\\)\nelements.\nbeta\n<type> scalar used for multiplication. If\nbeta\nis zero,\ny\ndoes not have to be a valid input.\ny\n<type> vector of\n\\(mb \\ast blockDim\\)\nelements.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.4.3.\ncusparse<t>bsrsv2_bufferSize() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseSbsrsv2_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nfloat\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrsv2Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseDbsrsv2_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ndouble\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrsv2Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseCbsrsv2_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrsv2Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseZbsrsv2_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuDoubleComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrsv2Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n)\nThis function returns size of the buffer used in\nbsrsv2\n, a new sparse triangular linear system\nop(A)*y\n=\n\\(\\alpha\\)\nx\n.\nA\nis an\n(mb*blockDim)x(mb*blockDim)\nsparse matrix that is defined in BSR storage format by the three arrays\nbsrValA\n,\nbsrRowPtrA\n, and\nbsrColIndA\n);\nx\nand\ny\nare the right-hand-side and the solution vectors;\n\\(\\alpha\\)\nis a scalar; and\nAlthough there are six combinations in terms of parameter\ntrans\nand the upper (lower) triangular part of\nA\n,\nbsrsv2_bufferSize()\nreturns the maximum size buffer among these combinations. The buffer size depends on the dimensions\nmb\n,\nblockDim\n, and the number of nonzero blocks of the matrix\nnnzb\n. If the user changes the matrix, it is necessary to call\nbsrsv2_bufferSize()\nagain to have the correct buffer size; otherwise a segmentation fault may occur.\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nhandle\nhandle to the cuSPARSE library context.\ndirA\nstorage format of blocks, either\nCUSPARSE_DIRECTION_ROW\nor\nCUSPARSE_DIRECTION_COLUMN\n.\ntransA\nthe operation\n\\(\\text{op}(A)\\)\n.\nmb\nnumber of block rows of matrix\nA\n.\nnnzb\nnumber of nonzero blocks of matrix\nA\n.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n, while the supported diagonal types are\nCUSPARSE_DIAG_TYPE_UNIT\nand\nCUSPARSE_DIAG_TYPE_NON_UNIT\n.\nbsrValA\n<type> array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\nnonzero blocks of matrix\nA\n.\nbsrRowPtrA\ninteger array of\nmb\n\\(+ 1\\)\nelements that contains the start of every block row and the end of the last block row plus one.\nbsrColIndA\ninteger array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero blocks of matrix\nA\n.\nblockDim\nblock dimension of sparse matrix A; must be larger than zero.\nOutput\ninfo\nrecord of internal states based on different algorithms.\npBufferSizeInBytes\nnumber of bytes of the buffer used in the\nbsrsv2_analysis()\nand\nbsrsv2_solve()\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.4.4.\ncusparse<t>bsrsv2_analysis() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseSbsrsv2_analysis\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrsv2Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDbsrsv2_analysis\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrsv2Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDbsrsv2_analysis\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrsv2Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZbsrsv2_analysis\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrsv2Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\nThis function performs the analysis phase of\nbsrsv2\n, a new sparse triangular linear system\nop(A)*y\n=\n\\(\\alpha\\)\nx\n.\nA\nis an\n(mb*blockDim)x(mb*blockDim)\nsparse matrix that is defined in BSR storage format by the three arrays\nbsrValA\n,\nbsrRowPtrA\n, and\nbsrColIndA\n);\nx\nand\ny\nare the right-hand side and the solution vectors;\n\\(\\alpha\\)\nis a scalar; and\nThe block of BSR format is of size\nblockDim*blockDim\n, stored as column-major or row-major as determined by parameter\ndirA\n, which is either\nCUSPARSE_DIRECTION_COLUMN\nor\nCUSPARSE_DIRECTION_ROW\n. The matrix type must be\nCUSPARSE_MATRIX_TYPE_GENERAL\n, and the fill mode and diagonal type are ignored.\nIt is expected that this function will be executed only once for a given matrix and a particular operation type.\nThis function requires a buffer size returned by\nbsrsv2_bufferSize()\n. The address of\npBuffer\nmust be multiple of 128 bytes. If it is not,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nFunction\nbsrsv2_analysis()\nreports a structural zero and computes level information, which stored in the opaque structure\ninfo\n. The level information can extract more parallelism for a triangular solver. However\nbsrsv2_solve()\ncan be done without level information. To disable level information, the user needs to specify the policy of the triangular solver as\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n.\nFunction\nbsrsv2_analysis()\nalways reports the first structural zero, even when parameter\npolicy\nis\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n. No structural zero is reported if\nCUSPARSE_DIAG_TYPE_UNIT\nis specified, even if block\nA(j,j)\nis missing for some\nj\n. The user needs to call\ncusparseXbsrsv2_zeroPivot()\nto know where the structural zero is.\nIt is the user’s choice whether to call\nbsrsv2_solve()\nif\nbsrsv2_analysis()\nreports a structural zero. In this case, the user can still call\nbsrsv2_solve()\n, which will return a numerical zero at the same position as a structural zero. However the result\nx\nis meaningless.\nThis function requires temporary extra storage that is allocated internally\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available\nInput\nhandle\nhandle to the cuSPARSE library context.\ndirA\nstorage format of blocks, either\nCUSPARSE_DIRECTION_ROW\nor\nCUSPARSE_DIRECTION_COLUMN\n.\ntransA\nthe operation\n\\(\\text{op}(A)\\)\n.\nmb\nnumber of block rows of matrix\nA\n.\nnnzb\nnumber of nonzero blocks of matrix\nA\n.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n, while the supported diagonal types are\nCUSPARSE_DIAG_TYPE_UNIT\nand\nCUSPARSE_DIAG_TYPE_NON_UNIT\n.\nbsrValA\n<type> array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\nnonzero blocks of matrix\nA\n.\nbsrRowPtrA\ninteger array of\nmb\n\\(+ 1\\)\nelements that contains the start of every block row and the end of the last block row plus one.\nbsrColIndA\ninteger array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero blocks of matrix\nA\n.\nblockDim\nblock dimension of sparse matrix A, larger than zero.\ninfo\nstructure initialized using\ncusparseCreateBsrsv2Info()\n.\npolicy\nthe supported policies are\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\nand\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n.\npBuffer\nbuffer allocated by the user, the size is return by\nbsrsv2_bufferSize()\n.\nOutput\ninfo\nstructure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.4.5.\ncusparse<t>bsrsv2_solve() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseSbsrsv2_solve\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\nfloat\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrsv2Info_t\ninfo\n,\nconst\nfloat\n*\nx\n,\nfloat\n*\ny\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDbsrsv2_solve\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ndouble\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrsv2Info_t\ninfo\n,\nconst\ndouble\n*\nx\n,\ndouble\n*\ny\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseCbsrsv2_solve\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrsv2Info_t\ninfo\n,\nconst\ncuComplex\n*\nx\n,\ncuComplex\n*\ny\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZbsrsv2_solve\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrsv2Info_t\ninfo\n,\nconst\ncuDoubleComplex\n*\nx\n,\ncuDoubleComplex\n*\ny\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\nThis function performs the solve phase of\nbsrsv2\n, a new sparse triangular linear system\nop(A)*y\n=\n\\(\\alpha\\)\nx\n.\nA\nis an\n(mb*blockDim)x(mb*blockDim)\nsparse matrix that is defined in BSR storage format by the three arrays\nbsrValA\n,\nbsrRowPtrA\n, and\nbsrColIndA\n);\nx\nand\ny\nare the right-hand-side and the solution vectors;\n\\(\\alpha\\)\nis a scalar; and\nThe block in BSR format is of size\nblockDim*blockDim\n, stored as column-major or row-major as determined by parameter\ndirA\n, which is either\nCUSPARSE_DIRECTION_COLUMN\nor\nCUSPARSE_DIRECTION_ROW\n. The matrix type must be\nCUSPARSE_MATRIX_TYPE_GENERAL\n, and the fill mode and diagonal type are ignored. Function\nbsrsv02_solve()\ncan support an arbitrary\nblockDim\n.\nThis function may be executed multiple times for a given matrix and a particular operation type.\nThis function requires a buffer size returned by\nbsrsv2_bufferSize()\n. The address of\npBuffer\nmust be multiple of 128 bytes. If it is not,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nAlthough\nbsrsv2_solve()\ncan be done without level information, the user still needs to be aware of consistency. If\nbsrsv2_analysis()\nis called with policy\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n,\nbsrsv2_solve()\ncan be run with or without levels. On the other hand, if\nbsrsv2_analysis()\nis called with\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n,\nbsrsv2_solve()\ncan only accept\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n; otherwise,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nThe level information may not improve the performance, but may spend extra time doing analysis. For example, a tridiagonal matrix has no parallelism. In this case,\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\nperforms better than\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n. If the user has an iterative solver, the best approach is to do\nbsrsv2_analysis()\nwith\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\nonce. Then do\nbsrsv2_solve()\nwith\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\nin the first run, and with\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\nin the second run, and pick the fastest one to perform the remaining iterations.\nFunction\nbsrsv02_solve()\nhas the same behavior as\ncsrsv02_solve()\n. That is,\nbsr2csr(bsrsv02(A))\n=\ncsrsv02(bsr2csr(A))\n. The numerical zero of\ncsrsv02_solve()\nmeans there exists some zero\nA(j,j)\n. The numerical zero of\nbsrsv02_solve()\nmeans there exists some block\nA(j,j)\nthat is not invertible.\nFunction\nbsrsv2_solve()\nreports the first numerical zero, including a structural zero. No numerical zero is reported if\nCUSPARSE_DIAG_TYPE_UNIT\nis specified, even if\nA(j,j)\nis not invertible for some\nj\n. The user needs to call\ncusparseXbsrsv2_zeroPivot()\nto know where the numerical zero is.\nThe function supports the following properties if\npBuffer\n!=\nNULL\n:\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nFor example, suppose L is a lower triangular matrix with unit diagonal, then the following code solves\nL*y=x\nby level information.\n// Suppose that L is m x m sparse matrix represented by BSR format,\n// The number of block rows/columns is mb, and\n// the number of nonzero blocks is nnzb.\n// L is lower triangular with unit diagonal.\n// Assumption:\n// - dimension of matrix L is m(=mb*blockDim),\n// - matrix L has nnz(=nnzb*blockDim*blockDim) nonzero elements,\n// - handle is already created by cusparseCreate(),\n// - (d_bsrRowPtr, d_bsrColInd, d_bsrVal) is BSR of L on device memory,\n// - d_x is right hand side vector on device memory.\n// - d_y is solution vector on device memory.\n// - d_x and d_y are of size m.\ncusparseMatDescr_t\ndescr\n=\n0\n;\nbsrsv2Info_t\ninfo\n=\n0\n;\nint\npBufferSize\n;\nvoid\n*\npBuffer\n=\n0\n;\nint\nstructural_zero\n;\nint\nnumerical_zero\n;\nconst\ndouble\nalpha\n=\n1.\n;\nconst\ncusparseSolvePolicy_t\npolicy\n=\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n;\nconst\ncusparseOperation_t\ntrans\n=\nCUSPARSE_OPERATION_NON_TRANSPOSE\n;\nconst\ncusparseDirection_t\ndir\n=\nCUSPARSE_DIRECTION_COLUMN\n;\n// step 1: create a descriptor which contains\n// - matrix L is base-1\n// - matrix L is lower triangular\n// - matrix L has unit diagonal, specified by parameter CUSPARSE_DIAG_TYPE_UNIT\n//   (L may not have all diagonal elements.)\ncusparseCreateMatDescr\n(\n&\ndescr\n);\ncusparseSetMatIndexBase\n(\ndescr\n,\nCUSPARSE_INDEX_BASE_ONE\n);\ncusparseSetMatFillMode\n(\ndescr\n,\nCUSPARSE_FILL_MODE_LOWER\n);\ncusparseSetMatDiagType\n(\ndescr\n,\nCUSPARSE_DIAG_TYPE_UNIT\n);\n// step 2: create a empty info structure\ncusparseCreateBsrsv2Info\n(\n&\ninfo\n);\n// step 3: query how much memory used in bsrsv2, and allocate the buffer\ncusparseDbsrsv2_bufferSize\n(\nhandle\n,\ndir\n,\ntrans\n,\nmb\n,\nnnzb\n,\ndescr\n,\nd_bsrVal\n,\nd_bsrRowPtr\n,\nd_bsrColInd\n,\nblockDim\n,\n&\npBufferSize\n);\n// pBuffer returned by cudaMalloc is automatically aligned to 128 bytes.\ncudaMalloc\n((\nvoid\n**\n)\n&\npBuffer\n,\npBufferSize\n);\n// step 4: perform analysis\ncusparseDbsrsv2_analysis\n(\nhandle\n,\ndir\n,\ntrans\n,\nmb\n,\nnnzb\n,\ndescr\n,\nd_bsrVal\n,\nd_bsrRowPtr\n,\nd_bsrColInd\n,\nblockDim\n,\ninfo\n,\npolicy\n,\npBuffer\n);\n// L has unit diagonal, so no structural zero is reported.\nstatus\n=\ncusparseXbsrsv2_zeroPivot\n(\nhandle\n,\ninfo\n,\n&\nstructural_zero\n);\nif\n(\nCUSPARSE_STATUS_ZERO_PIVOT\n==\nstatus\n){\nprintf\n(\n\"L(%d,%d) is missing\n\\n\n\"\n,\nstructural_zero\n,\nstructural_zero\n);\n}\n// step 5: solve L*y = x\ncusparseDbsrsv2_solve\n(\nhandle\n,\ndir\n,\ntrans\n,\nmb\n,\nnnzb\n,\n&\nalpha\n,\ndescr\n,\nd_bsrVal\n,\nd_bsrRowPtr\n,\nd_bsrColInd\n,\nblockDim\n,\ninfo\n,\nd_x\n,\nd_y\n,\npolicy\n,\npBuffer\n);\n// L has unit diagonal, so no numerical zero is reported.\nstatus\n=\ncusparseXbsrsv2_zeroPivot\n(\nhandle\n,\ninfo\n,\n&\nnumerical_zero\n);\nif\n(\nCUSPARSE_STATUS_ZERO_PIVOT\n==\nstatus\n){\nprintf\n(\n\"L(%d,%d) is zero\n\\n\n\"\n,\nnumerical_zero\n,\nnumerical_zero\n);\n}\n// step 6: free resources\ncudaFree\n(\npBuffer\n);\ncusparseDestroyBsrsv2Info\n(\ninfo\n);\ncusparseDestroyMatDescr\n(\ndescr\n);\ncusparseDestroy\n(\nhandle\n);\nInput\nhandle\nhandle to the cuSPARSE library context.\ndirA\nstorage format of blocks, either\nCUSPARSE_DIRECTION_ROW\nor\nCUSPARSE_DIRECTION_COLUMN\n.\ntransA\nthe operation\n\\(\\text{op}(A)\\)\n.\nmb\nnumber of block rows and block columns of matrix\nA\n.\nalpha\n<type> scalar used for multiplication.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n, while the supported diagonal types are\nCUSPARSE_DIAG_TYPE_UNIT\nand\nCUSPARSE_DIAG_TYPE_NON_UNIT\n.\nbsrValA\n<type> array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\nnonzero blocks of matrix\nA\n.\nbsrRowPtrA\ninteger array of\nmb\n\\(+ 1\\)\nelements that contains the start of every block row and the end of the last block row plus one.\nbsrColIndA\ninteger array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero blocks of matrix\nA\n.\nblockDim\nblock dimension of sparse matrix\nA\n, larger than zero.\ninfo\nstructure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).\nx\n<type> right-hand-side vector of size\nm\n.\npolicy\nthe supported policies are\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\nand\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n.\npBuffer\nbuffer allocated by the user, the size is returned by\nbsrsv2_bufferSize()\n.\nOutput\ny\n<type> solution vector of size\nm\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.4.6.\ncusparseXbsrsv2_zeroPivot() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseXbsrsv2_zeroPivot\n(\ncusparseHandle_t\nhandle\n,\nbsrsv2Info_t\ninfo\n,\nint\n*\nposition\n)\nIf the returned error code is\nCUSPARSE_STATUS_ZERO_PIVOT\n,\nposition=j\nmeans\nA(j,j)\nis either structural zero or numerical zero (singular block). Otherwise\nposition=-1\n.\nThe\nposition\ncan be 0-based or 1-based, the same as the matrix.\nFunction\ncusparseXbsrsv2_zeroPivot()\nis a blocking call. It calls\ncudaDeviceSynchronize()\nto make sure all previous kernels are done.\nThe\nposition\ncan be in the host memory or device memory. The user can set the proper mode with\ncusparseSetPointerMode()\n.\nThe routine requires no extra storage\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available\nInput\nhandle\nhandle to the cuSPARSE library context.\ninfo\ninfo\ncontains a structural zero or numerical zero if the user already called\nbsrsv2_analysis()\nor\nbsrsv2_solve()\n.\nOutput\nposition\nif no structural or numerical zero,\nposition\nis -1; otherwise if\nA(j,j)\nis missing or\nU(j,j)\nis zero,\nposition=j\n.\nSee\ncusparseStatus_t\nfor the description of the return status\n5.4.7.\ncusparse<t>gemvi() [DEPRECATED]\n\n>\nThis routine will be removed in a future major release.\ncusparseStatus_t\ncusparseSgemvi_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\ntransA\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nint\n*\npBufferSize\n)\ncusparseStatus_t\ncusparseDgemvi_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\ntransA\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nint\n*\npBufferSize\n)\ncusparseStatus_t\ncusparseCgemvi_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\ntransA\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nint\n*\npBufferSize\n)\ncusparseStatus_t\ncusparseZgemvi_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\ntransA\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nint\n*\npBufferSize\n)\ncusparseStatus_t\ncusparseSgemvi\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\ntransA\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nint\nnnz\n,\nconst\nfloat\n*\nx\n,\nconst\nint\n*\nxInd\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\ny\n,\ncusparseIndexBase_t\nidxBase\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDgemvi\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\ntransA\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nint\nnnz\n,\nconst\ndouble\n*\nx\n,\nconst\nint\n*\nxInd\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\ny\n,\ncusparseIndexBase_t\nidxBase\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseCgemvi\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\ntransA\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nint\nnnz\n,\nconst\ncuComplex\n*\nx\n,\nconst\nint\n*\nxInd\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\ny\n,\ncusparseIndexBase_t\nidxBase\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZgemvi\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\ntransA\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nint\nnnz\n,\nconst\ncuDoubleComplex\n*\nx\n,\nconst\nint\n*\nxInd\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\ny\n,\ncusparseIndexBase_t\nidxBase\n,\nvoid\n*\npBuffer\n)\nThis function performs the matrix-vector operation\n\\[\\text{y} = \\alpha \\ast \\text{op}(A) \\ast \\text{x} + \\beta \\ast \\text{y}\\]\nA\nis an\n\\(m \\times n\\)\ndense matrix and a sparse vector\nx\nthat is defined in a sparse storage format by the two arrays\nxVal,\nxInd\nof length\nnnz\n, and\ny\nis a dense vector;\n\\(\\alpha \\;\\)\nand\n\\(\\beta \\;\\)\nare scalars; and\nThe routine supports asynchronous execution\nThe routine supports CUDA graph capture\nThe function\ncusparse<t>gemvi_bufferSize()\nreturns the size of buffer used in\ncusparse<t>gemvi()\n.\nInput\nhandle\nHandle to the cuSPARSE library context.\ntrans\nThe operation\n\\(\\text{op}(A)\\)\n.\nm\nNumber of rows of matrix\nA\n.\nn\nNumber of columns of matrix\nA\n.\nalpha\n<type> scalar used for multiplication.\nA\nThe pointer to dense matrix\nA\n.\nlda\nSize of the leading dimension of\nA\n.\nnnz\nNumber of nonzero elements of vector\nx\n.\nx\n<type> sparse vector of\nnnz\nelements of size\nn\nif\n\\(\\text{op}(A)=A\\)\n, and size\nm\nif\n\\(\\text{op}(A)=A^{T}\\)\n.\nxInd\nIndices of non-zero values in\nx\n.\nbeta\n<type> scalar used for multiplication. If\nbeta\nis zero,\ny\ndoes not have to be a valid input.\ny\n<type> dense vector of\nm\nelements if\n\\(\\text{op}(A)=A\\)\n, and\nn\nelements if\n\\(\\text{op}(A)=A^{T}\\)\n.\nidxBase\n0 or 1, for 0 based or 1 based indexing, respectively.\npBufferSize\nNumber of elements needed the buffer used in\ncusparse<t>gemvi()\n.\npBuffer\nWorking space buffer.\nOutput\ny\n<type> updated dense vector.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.5.\ncuSPARSE Level 3 Function Reference\n\nThis chapter describes sparse linear algebra functions that perform operations between sparse and (usually tall) dense matrices.\n5.5.1.\ncusparse<t>bsrmm() [DEPRECATED]\n\n>\nThis routine will be removed in a future major release.\nUse cusparseSpMM() with BSR matrices instead.\ncusparseStatus_t\ncusparseSbsrmm\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\ncusparseOperation_t\ntransB\n,\nint\nmb\n,\nint\nn\n,\nint\nkb\n,\nint\nnnzb\n,\nconst\nfloat\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nconst\nfloat\n*\nB\n,\nint\nldb\n,\nconst\nfloat\n*\nbeta\n,\nfloat\n*\nC\n,\nint\nldc\n)\ncusparseStatus_t\ncusparseDbsrmm\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\ncusparseOperation_t\ntransB\n,\nint\nmb\n,\nint\nn\n,\nint\nkb\n,\nint\nnnzb\n,\nconst\ndouble\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nconst\ndouble\n*\nB\n,\nint\nldb\n,\nconst\ndouble\n*\nbeta\n,\ndouble\n*\nC\n,\nint\nldc\n)\ncusparseStatus_t\ncusparseCbsrmm\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\ncusparseOperation_t\ntransB\n,\nint\nmb\n,\nint\nn\n,\nint\nkb\n,\nint\nnnzb\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nconst\ncuComplex\n*\nB\n,\nint\nldb\n,\nconst\ncuComplex\n*\nbeta\n,\ncuComplex\n*\nC\n,\nint\nldc\n)\ncusparseStatus_t\ncusparseZbsrmm\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\ncusparseOperation_t\ntransB\n,\nint\nmb\n,\nint\nn\n,\nint\nkb\n,\nint\nnnzb\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nconst\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\ncuDoubleComplex\n*\nC\n,\nint\nldc\n)\nThis function performs one of the following matrix-matrix operations:\n\\[C = \\alpha \\ast \\text{op}(A) \\ast \\text{op}(B) + \\beta \\ast C\\]\nA\nis an\n\\(mb \\times kb\\)\nsparse matrix that is defined in BSR storage format by the three arrays\nbsrValA\n,\nbsrRowPtrA\n, and\nbsrColIndA\n;\nB\nand\nC\nare dense matrices;\n\\(\\alpha\\text{~and~}\\beta\\)\nare scalars; and\nand\nThe function has the following limitations:\nonly\nCUSPARSE_MATRIX_TYPE_GENERAL\nmatrix type is supported\nonly\nblockDim\n>\n1\nis supported\nif\nblockDim\n≤ 4, then max(mb)/max(n) = 524,272\nif 4 <\nblockDim\n≤ 8, then max(mb) = 524,272, max(n) = 262,136\nif\nblockDim\n> 8, then m < 65,535 and max(n) = 262,136\nThe motivation of\ntranspose(B)\nis to improve memory access of matrix\nB\n. The computational pattern of\nA*transpose(B)\nwith matrix\nB\nin column-major order is equivalent to\nA*B\nwith matrix\nB\nin row-major order.\nIn practice, no operation in an iterative solver or eigenvalue solver uses\nA*transpose(B)\n. However, we can perform\nA*transpose(transpose(B))\nwhich is the same as\nA*B\n. For example, suppose\nA\nis\nmb*kb\n,\nB\nis\nk*n\nand\nC\nis\nm*n\n, the following code shows usage of\ncusparseDbsrmm()\n.\n// A is mb*kb, B is k*n and C is m*n\nconst\nint\nm\n=\nmb\n*\nblockSize\n;\nconst\nint\nk\n=\nkb\n*\nblockSize\n;\nconst\nint\nldb_B\n=\nk\n;\n// leading dimension of B\nconst\nint\nldc\n=\nm\n;\n// leading dimension of C\n// perform C:=alpha*A*B + beta*C\ncusparseSetMatType\n(\ndescrA\n,\nCUSPARSE_MATRIX_TYPE_GENERAL\n);\ncusparseDbsrmm\n(\ncusparse_handle\n,\nCUSPARSE_DIRECTION_COLUMN\n,\nCUSPARSE_OPERATION_NON_TRANSPOSE\n,\nCUSPARSE_OPERATION_NON_TRANSPOSE\n,\nmb\n,\nn\n,\nkb\n,\nnnzb\n,\nalpha\n,\ndescrA\n,\nbsrValA\n,\nbsrRowPtrA\n,\nbsrColIndA\n,\nblockSize\n,\nB\n,\nldb_B\n,\nbeta\n,\nC\n,\nldc\n);\nInstead of using\nA*B\n, our proposal is to transpose\nB\nto\nBt\nby first calling\ncublas<t>geam()\n, and then to perform\nA*transpose(Bt)\n.\n// step 1: Bt := transpose(B)\nconst\nint\nm\n=\nmb\n*\nblockSize\n;\nconst\nint\nk\n=\nkb\n*\nblockSize\n;\ndouble\n*\nBt\n;\nconst\nint\nldb_Bt\n=\nn\n;\n// leading dimension of Bt\ncudaMalloc\n((\nvoid\n**\n)\n&\nBt\n,\nsizeof\n(\ndouble\n)\n*\nldb_Bt\n*\nk\n);\ndouble\none\n=\n1.0\n;\ndouble\nzero\n=\n0.0\n;\ncublasSetPointerMode\n(\ncublas_handle\n,\nCUBLAS_POINTER_MODE_HOST\n);\ncublasDgeam\n(\ncublas_handle\n,\nCUBLAS_OP_T\n,\nCUBLAS_OP_T\n,\nn\n,\nk\n,\n&\none\n,\nB\n,\nint\nldb_B\n,\n&\nzero\n,\nB\n,\nint\nldb_B\n,\nBt\n,\nldb_Bt\n);\n// step 2: perform C:=alpha*A*transpose(Bt) + beta*C\ncusparseDbsrmm\n(\ncusparse_handle\n,\nCUSPARSE_DIRECTION_COLUMN\n,\nCUSPARSE_OPERATION_NON_TRANSPOSE\n,\nCUSPARSE_OPERATION_TRANSPOSE\n,\nmb\n,\nn\n,\nkb\n,\nnnzb\n,\nalpha\n,\ndescrA\n,\nbsrValA\n,\nbsrRowPtrA\n,\nbsrColIndA\n,\nblockSize\n,\nBt\n,\nldb_Bt\n,\nbeta\n,\nC\n,\nldc\n);\nbsrmm()\nhas the following properties:\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nhandle\nhandle to the cuSPARSE library context.\ndir\nstorage format of blocks, either\nCUSPARSE_DIRECTION_ROW\nor\nCUSPARSE_DIRECTION_COLUMN\n.\ntransA\nthe operation\nop(A)\n.\ntransB\nthe operation\nop(B)\n.\nmb\nnumber of block rows of sparse matrix\nA\n.\nn\nnumber of columns of dense matrix\nop(B)\nand\nA\n.\nkb\nnumber of block columns of sparse matrix\nA\n.\nnnzb\nnumber of non-zero blocks of sparse matrix\nA\n.\nalpha\n<type> scalar used for multiplication.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\nbsrValA\n<type> array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\nnonzero blocks of matrix\nA\n.\nbsrRowPtrA\ninteger array of\nmb\n\\(+ 1\\)\nelements that contains the start of every block row and the end of the last block row plus one.\nbsrColIndA\ninteger array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero blocks of matrix\nA\n.\nblockDim\nblock dimension of sparse matrix\nA\n, larger than zero.\nB\narray of dimensions\n(ldb,\nn)\nif\nop(B)=B\nand\n(ldb,\nk)\notherwise.\nldb\nleading dimension of\nB\n. If\nop(B)=B\n, it must be at least\n\\(\\max\\text{(1,\\ k)}\\)\nIf\nop(B)\n!=\nB\n, it must be at least\nmax(1,\nn)\n.\nbeta\n<type> scalar used for multiplication. If\nbeta\nis zero,\nC\ndoes not have to be a valid input.\nC\narray of dimensions\n(ldc,\nn)\n.\nldc\nleading dimension of\nC\n. It must be at least\n\\(\\max\\text{(1,\\ m)}\\)\nif\nop(A)=A\nand at least\n\\(\\max\\text{(1,\\ k)}\\)\notherwise.\nOutput\nC\n<type> updated array of dimensions\n(ldc,\nn)\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.5.2.\ncusparse<t>bsrsm2_bufferSize() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseSbsrsm2_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\ncusparseOperation_t\ntransX\n,\nint\nmb\n,\nint\nn\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nfloat\n*\nbsrSortedValA\n,\nconst\nint\n*\nbsrSortedRowPtrA\n,\nconst\nint\n*\nbsrSortedColIndA\n,\nint\nblockDim\n,\nbsrsm2Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseDbsrsm2_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\ncusparseOperation_t\ntransX\n,\nint\nmb\n,\nint\nn\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ndouble\n*\nbsrSortedValA\n,\nconst\nint\n*\nbsrSortedRowPtrA\n,\nconst\nint\n*\nbsrSortedColIndA\n,\nint\nblockDim\n,\nbsrsm2Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseCbsrsm2_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\ncusparseOperation_t\ntransX\n,\nint\nmb\n,\nint\nn\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuComplex\n*\nbsrSortedValA\n,\nconst\nint\n*\nbsrSortedRowPtrA\n,\nconst\nint\n*\nbsrSortedColIndA\n,\nint\nblockDim\n,\nbsrsm2Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseZbsrsm2_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\ncusparseOperation_t\ntransX\n,\nint\nmb\n,\nint\nn\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuDoubleComplex\n*\nbsrSortedValA\n,\nconst\nint\n*\nbsrSortedRowPtrA\n,\nconst\nint\n*\nbsrSortedColIndA\n,\nint\nblockDim\n,\nbsrsm2Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n)\nThis function returns size of buffer used in\nbsrsm2()\n, a new sparse triangular linear system\nop(A)*op(X)=\n\\(\\alpha\\)\nop(B)\n.\nA\nis an\n(mb*blockDim)x(mb*blockDim)\nsparse matrix that is defined in BSR storage format by the three arrays\nbsrValA\n,\nbsrRowPtrA\n, and\nbsrColIndA\n);\nB\nand\nX\nare the right-hand-side and the solution matrices;\n\\(\\alpha\\)\nis a scalar; and\nAlthough there are six combinations in terms of parameter\ntrans\nand the upper (and lower) triangular part of\nA\n,\nbsrsm2_bufferSize()\nreturns the maximum size of the buffer among these combinations. The buffer size depends on dimension\nmb,blockDim\nand the number of nonzeros of the matrix,\nnnzb\n. If the user changes the matrix, it is necessary to call\nbsrsm2_bufferSize()\nagain to get the correct buffer size, otherwise a segmentation fault may occur.\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nhandle\nhandle to the cuSPARSE library context.\ndirA\nstorage format of blocks, either\nCUSPARSE_DIRECTION_ROW\nor\nCUSPARSE_DIRECTION_COLUMN\n.\ntransA\nthe operation\nop(A)\n.\ntransX\nthe operation\nop(X)\n.\nmb\nnumber of block rows of matrix\nA\n.\nn\nnumber of columns of matrix\nop(B)\nand\nop(X)\n.\nnnzb\nnumber of nonzero blocks of matrix\nA\n.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n, while the supported diagonal types are\nCUSPARSE_DIAG_TYPE_UNIT\nand\nCUSPARSE_DIAG_TYPE_NON_UNIT\n.\nbsrValA\n<type> array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\nnonzero blocks of matrix\nA\n.\nbsrRowPtrA\ninteger array of\nmb\n\\(+ 1\\)\nelements that contains the start of every block row and the end of the last block row plus one.\nbsrColIndA\ninteger array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero blocks of matrix\nA\n.\nblockDim\nblock dimension of sparse matrix\nA\n; larger than zero.\nOutput\ninfo\nrecord internal states based on different algorithms.\npBufferSizeInBytes\nnumber of bytes of the buffer used in\nbsrsm2_analysis()\nand\nbsrsm2_solve()\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.5.3.\ncusparse<t>bsrsm2_analysis() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseSbsrsm2_analysis\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\ncusparseOperation_t\ntransX\n,\nint\nmb\n,\nint\nn\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\nbsrSortedVal\n,\nconst\nint\n*\nbsrSortedRowPtr\n,\nconst\nint\n*\nbsrSortedColInd\n,\nint\nblockDim\n,\nbsrsm2Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDbsrsm2_analysis\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\ncusparseOperation_t\ntransX\n,\nint\nmb\n,\nint\nn\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\nbsrSortedVal\n,\nconst\nint\n*\nbsrSortedRowPtr\n,\nconst\nint\n*\nbsrSortedColInd\n,\nint\nblockDim\n,\nbsrsm2Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseCbsrsm2_analysis\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\ncusparseOperation_t\ntransX\n,\nint\nmb\n,\nint\nn\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\nbsrSortedVal\n,\nconst\nint\n*\nbsrSortedRowPtr\n,\nconst\nint\n*\nbsrSortedColInd\n,\nint\nblockDim\n,\nbsrsm2Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZbsrsm2_analysis\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\ncusparseOperation_t\ntransX\n,\nint\nmb\n,\nint\nn\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\nbsrSortedVal\n,\nconst\nint\n*\nbsrSortedRowPtr\n,\nconst\nint\n*\nbsrSortedColInd\n,\nint\nblockDim\n,\nbsrsm2Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\nThis function performs the analysis phase of\nbsrsm2()\n, a new sparse triangular linear system\nop(A)*op(X)\n=\n\\(\\alpha\\)\nop(B)\n.\nA\nis an\n(mb*blockDim)x(mb*blockDim)\nsparse matrix that is defined in BSR storage format by the three arrays\nbsrValA\n,\nbsrRowPtrA\n, and\nbsrColIndA\n);\nB\nand\nX\nare the right-hand-side and the solution matrices;\n\\(\\alpha\\)\nis a scalar; and\nand\nand\nop(B)\nand\nop(X)\nare equal.\nThe block of BSR format is of size\nblockDim*blockDim\n, stored in column-major or row-major as determined by parameter\ndirA\n, which is either\nCUSPARSE_DIRECTION_ROW\nor\nCUSPARSE_DIRECTION_COLUMN\n. The matrix type must be\nCUSPARSE_MATRIX_TYPE_GENERAL\n, and the fill mode and diagonal type are ignored.\nIt is expected that this function will be executed only once for a given matrix and a particular operation type.\nThis function requires the buffer size returned by\nbsrsm2_bufferSize()\n. The address of\npBuffer\nmust be multiple of 128 bytes. If not,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nFunction\nbsrsm2_analysis()\nreports a structural zero and computes the level information stored in opaque structure\ninfo\n. The level information can extract more parallelism during a triangular solver. However\nbsrsm2_solve()\ncan be done without level information. To disable level information, the user needs to specify the policy of the triangular solver as\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n.\nFunction\nbsrsm2_analysis()\nalways reports the first structural zero, even if the parameter\npolicy\nis\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n. Besides, no structural zero is reported if\nCUSPARSE_DIAG_TYPE_UNIT\nis specified, even if block\nA(j,j)\nis missing for some\nj\n. The user must call\ncusparseXbsrsm2_query_zero_pivot()\nto know where the structural zero is.\nIf\nbsrsm2_analysis()\nreports a structural zero, the solve will return a numerical zero in the same position as the structural zero but this result\nX\nis meaningless.\nThis function requires temporary extra storage that is allocated internally.\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available.\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available.\nInput\nhandle\nhandle to the cuSPARSE library context.\ndirA\nstorage format of blocks, either\nCUSPARSE_DIRECTION_ROW\nor\nCUSPARSE_DIRECTION_COLUMN\n.\ntransA\nthe operation\nop(A)\n.\ntransX\nthe operation\nop(B)\nand\nop(X)\n.\nmb\nnumber of block rows of matrix\nA\n.\nn\nnumber of columns of matrix\nop(B)\nand\nop(X)\n.\nnnzb\nnumber of non-zero blocks of matrix\nA\n.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n, while the supported diagonal types are\nCUSPARSE_DIAG_TYPE_UNIT\nand\nCUSPARSE_DIAG_TYPE_NON_UNIT\n.\nbsrValA\n<type> array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\nnonzero blocks of matrix\nA\n.\nbsrRowPtrA\ninteger array of\nmb\n\\(+ 1\\)\nelements that contains the start of every block row and the end of the last block row plus one.\nbsrColIndA\ninteger array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero blocks of matrix\nA\n.\nblockDim\nblock dimension of sparse matrix\nA\n; larger than zero.\ninfo\nstructure initialized using\ncusparseCreateBsrsm2Info\n.\npolicy\nThe supported policies are\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\nand\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n.\npBuffer\nbuffer allocated by the user; the size is return by\nbsrsm2_bufferSize()\n.\nOutput\ninfo\nstructure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.5.4.\ncusparse<t>bsrsm2_solve() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseSbsrsm2_solve\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\ncusparseOperation_t\ntransX\n,\nint\nmb\n,\nint\nn\n,\nint\nnnzb\n,\nconst\nfloat\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\nbsrSortedVal\n,\nconst\nint\n*\nbsrSortedRowPtr\n,\nconst\nint\n*\nbsrSortedColInd\n,\nint\nblockDim\n,\nbsrsm2Info_t\ninfo\n,\nconst\nfloat\n*\nB\n,\nint\nldb\n,\nfloat\n*\nX\n,\nint\nldx\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDbsrsm2_solve\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\ncusparseOperation_t\ntransX\n,\nint\nmb\n,\nint\nn\n,\nint\nnnzb\n,\nconst\ndouble\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\nbsrSortedVal\n,\nconst\nint\n*\nbsrSortedRowPtr\n,\nconst\nint\n*\nbsrSortedColInd\n,\nint\nblockDim\n,\nbsrsm2Info_t\ninfo\n,\nconst\ndouble\n*\nB\n,\nint\nldb\n,\ndouble\n*\nX\n,\nint\nldx\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseCbsrsm2_solve\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\ncusparseOperation_t\ntransX\n,\nint\nmb\n,\nint\nn\n,\nint\nnnzb\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\nbsrSortedVal\n,\nconst\nint\n*\nbsrSortedRowPtr\n,\nconst\nint\n*\nbsrSortedColInd\n,\nint\nblockDim\n,\nbsrsm2Info_t\ninfo\n,\nconst\ncuComplex\n*\nB\n,\nint\nldb\n,\ncuComplex\n*\nX\n,\nint\nldx\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZbsrsm2_solve\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\ncusparseOperation_t\ntransA\n,\ncusparseOperation_t\ntransX\n,\nint\nmb\n,\nint\nn\n,\nint\nnnzb\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\nbsrSortedVal\n,\nconst\nint\n*\nbsrSortedRowPtr\n,\nconst\nint\n*\nbsrSortedColInd\n,\nint\nblockDim\n,\nbsrsm2Info_t\ninfo\n,\nconst\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\ncuDoubleComplex\n*\nX\n,\nint\nldx\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\nThis function performs the solve phase of the solution of a sparse triangular linear system:\n\\[\\text{op}(A) \\ast \\text{op(X)} = \\alpha \\ast \\text{op(B)}\\]\nA\nis an\n(mb*blockDim)x(mb*blockDim)\nsparse matrix that is defined in BSR storage format by the three arrays\nbsrValA\n,\nbsrRowPtrA\n, and\nbsrColIndA\n);\nB\nand\nX\nare the right-hand-side and the solution matrices;\n\\(\\alpha\\)\nis a scalar, and\nand\nOnly\nop(A)=A\nis supported.\nop(B)\nand\nop(X)\nmust be performed in the same way. In other words, if\nop(B)=B\n,\nop(X)=X\n.\nThe block of BSR format is of size\nblockDim*blockDim\n, stored as column-major or row-major as determined by parameter\ndirA\n, which is either\nCUSPARSE_DIRECTION_ROW\nor\nCUSPARSE_DIRECTION_COLUMN\n. The matrix type must be\nCUSPARSE_MATRIX_TYPE_GENERAL\n, and the fill mode and diagonal type are ignored. Function\nbsrsm02_solve()\ncan support an arbitrary\nblockDim\n.\nThis function may be executed multiple times for a given matrix and a particular operation type.\nThis function requires the buffer size returned by\nbsrsm2_bufferSize()\n. The address of\npBuffer\nmust be multiple of 128 bytes. If it is not,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nAlthough\nbsrsm2_solve()\ncan be done without level information, the user still needs to be aware of consistency. If\nbsrsm2_analysis()\nis called with policy\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n,\nbsrsm2_solve()\ncan be run with or without levels. On the other hand, if\nbsrsm2_analysis()\nis called with\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n,\nbsrsm2_solve()\ncan only accept\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n; otherwise,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nFunction\nbsrsm02_solve()\nhas the same behavior as\nbsrsv02_solve()\n, reporting the first numerical zero, including a structural zero. The user must call\ncusparseXbsrsm2_query_zero_pivot()\nto know where the numerical zero is.\nThe motivation of\ntranspose(X)\nis to improve the memory access of matrix\nX\n. The computational pattern of\ntranspose(X)\nwith matrix\nX\nin column-major order is equivalent to\nX\nwith matrix\nX\nin row-major order.\nIn-place is supported and requires that\nB\nand\nX\npoint to the same memory block, and\nldb=ldx\n.\nThe function supports the following properties if\npBuffer\n!=\nNULL\n:\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nhandle\nhandle to the cuSPARSE library context.\ndirA\nstorage format of blocks, either\nCUSPARSE_DIRECTION_ROW\nor\nCUSPARSE_DIRECTION_COLUMN\n.\ntransA\nthe operation\nop(A)\n.\ntransX\nthe operation\nop(B)\nand\nop(X)\n.\nmb\nnumber of block rows of matrix\nA\n.\nn\nnumber of columns of matrix\nop(B)\nand\nop(X)\n.\nnnzb\nnumber of non-zero blocks of matrix\nA\n.\nalpha\n<type> scalar used for multiplication.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n, while the supported diagonal types are\nCUSPARSE_DIAG_TYPE_UNIT\nand\nCUSPARSE_DIAG_TYPE_NON_UNIT\n.\nbsrValA\n<type> array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\nnon-zero blocks of matrix\nA\n.\nbsrRowPtrA\ninteger array of\nmb\n\\(+ 1\\)\nelements that contains the start of every block row and the end of the last block row plus one.\nbsrColIndA\ninteger array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero blocks of matrix\nA\n.\nblockDim\nblock dimension of sparse matrix\nA\n; larger than zero.\ninfo\nstructure initialized using\ncusparseCreateBsrsm2Info()\n.\nB\n<type> right-hand-side array.\nldb\nleading dimension of\nB\n. If\nop(B)=B\n,\nldb\n>=\n(mb*blockDim)\n; otherwise,\nldb\n>=\nn\n.\nldx\nleading dimension of\nX\n. If\nop(X)=X\n, then\nldx\n>=\n(mb*blockDim)\n. otherwise\nldx\n>=\nn\n.\npolicy\nthe supported policies are\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\nand\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n.\npBuffer\nbuffer allocated by the user; the size is returned by\nbsrsm2_bufferSize()\n.\nOutput\nX\n<type> solution array with leading dimensions\nldx\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.5.5.\ncusparseXbsrsm2_zeroPivot() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseXbsrsm2_zeroPivot\n(\ncusparseHandle_t\nhandle\n,\nbsrsm2Info_t\ninfo\n,\nint\n*\nposition\n)\nIf the returned error code is\nCUSPARSE_STATUS_ZERO_PIVOT\n,\nposition=j\nmeans\nA(j,j)\nis either a structural zero or a numerical zero (singular block). Otherwise\nposition=-1\n.\nThe\nposition\ncan be 0-base or 1-base, the same as the matrix.\nFunction\ncusparseXbsrsm2_zeroPivot()\nis a blocking call. It calls\ncudaDeviceSynchronize()\nto make sure all previous kernels are done.\nThe\nposition\ncan be in the host memory or device memory. The user can set the proper mode with\ncusparseSetPointerMode()\n.\nThe routine requires no extra storage.\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available.\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available.\nInput\nhandle\nhandle to the cuSPARSE library context.\ninfo\ninfo\ncontains a structural zero or a numerical zero if the user already called\nbsrsm2_analysis()\nor\nbsrsm2_solve()\n.\nOutput\nposition\nif no structural or numerical zero,\nposition\nis -1; otherwise, if\nA(j,j)\nis missing or\nU(j,j)\nis zero,\nposition=j\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.6.\ncuSPARSE Extra Function Reference\n\nThis chapter describes the extra routines used to manipulate sparse matrices.\n5.6.1.\ncusparse<t>csrgeam2()\n\ncusparseStatus_t\ncusparseScsrgeam2_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nint\nnnzA\n,\nconst\nfloat\n*\ncsrSortedValA\n,\nconst\nint\n*\ncsrSortedRowPtrA\n,\nconst\nint\n*\ncsrSortedColIndA\n,\nconst\nfloat\n*\nbeta\n,\nconst\ncusparseMatDescr_t\ndescrB\n,\nint\nnnzB\n,\nconst\nfloat\n*\ncsrSortedValB\n,\nconst\nint\n*\ncsrSortedRowPtrB\n,\nconst\nint\n*\ncsrSortedColIndB\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nconst\nfloat\n*\ncsrSortedValC\n,\nconst\nint\n*\ncsrSortedRowPtrC\n,\nconst\nint\n*\ncsrSortedColIndC\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseDcsrgeam2_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nint\nnnzA\n,\nconst\ndouble\n*\ncsrSortedValA\n,\nconst\nint\n*\ncsrSortedRowPtrA\n,\nconst\nint\n*\ncsrSortedColIndA\n,\nconst\ndouble\n*\nbeta\n,\nconst\ncusparseMatDescr_t\ndescrB\n,\nint\nnnzB\n,\nconst\ndouble\n*\ncsrSortedValB\n,\nconst\nint\n*\ncsrSortedRowPtrB\n,\nconst\nint\n*\ncsrSortedColIndB\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nconst\ndouble\n*\ncsrSortedValC\n,\nconst\nint\n*\ncsrSortedRowPtrC\n,\nconst\nint\n*\ncsrSortedColIndC\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseCcsrgeam2_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nint\nnnzA\n,\nconst\ncuComplex\n*\ncsrSortedValA\n,\nconst\nint\n*\ncsrSortedRowPtrA\n,\nconst\nint\n*\ncsrSortedColIndA\n,\nconst\ncuComplex\n*\nbeta\n,\nconst\ncusparseMatDescr_t\ndescrB\n,\nint\nnnzB\n,\nconst\ncuComplex\n*\ncsrSortedValB\n,\nconst\nint\n*\ncsrSortedRowPtrB\n,\nconst\nint\n*\ncsrSortedColIndB\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nconst\ncuComplex\n*\ncsrSortedValC\n,\nconst\nint\n*\ncsrSortedRowPtrC\n,\nconst\nint\n*\ncsrSortedColIndC\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseZcsrgeam2_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nint\nnnzA\n,\nconst\ncuDoubleComplex\n*\ncsrSortedValA\n,\nconst\nint\n*\ncsrSortedRowPtrA\n,\nconst\nint\n*\ncsrSortedColIndA\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\nconst\ncusparseMatDescr_t\ndescrB\n,\nint\nnnzB\n,\nconst\ncuDoubleComplex\n*\ncsrSortedValB\n,\nconst\nint\n*\ncsrSortedRowPtrB\n,\nconst\nint\n*\ncsrSortedColIndB\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nconst\ncuDoubleComplex\n*\ncsrSortedValC\n,\nconst\nint\n*\ncsrSortedRowPtrC\n,\nconst\nint\n*\ncsrSortedColIndC\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseXcsrgeam2Nnz\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nint\nnnzA\n,\nconst\nint\n*\ncsrSortedRowPtrA\n,\nconst\nint\n*\ncsrSortedColIndA\n,\nconst\ncusparseMatDescr_t\ndescrB\n,\nint\nnnzB\n,\nconst\nint\n*\ncsrSortedRowPtrB\n,\nconst\nint\n*\ncsrSortedColIndB\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nint\n*\ncsrSortedRowPtrC\n,\nint\n*\nnnzTotalDevHostPtr\n,\nvoid\n*\nworkspace\n)\ncusparseStatus_t\ncusparseScsrgeam2\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nint\nnnzA\n,\nconst\nfloat\n*\ncsrSortedValA\n,\nconst\nint\n*\ncsrSortedRowPtrA\n,\nconst\nint\n*\ncsrSortedColIndA\n,\nconst\nfloat\n*\nbeta\n,\nconst\ncusparseMatDescr_t\ndescrB\n,\nint\nnnzB\n,\nconst\nfloat\n*\ncsrSortedValB\n,\nconst\nint\n*\ncsrSortedRowPtrB\n,\nconst\nint\n*\ncsrSortedColIndB\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nfloat\n*\ncsrSortedValC\n,\nint\n*\ncsrSortedRowPtrC\n,\nint\n*\ncsrSortedColIndC\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDcsrgeam2\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nint\nnnzA\n,\nconst\ndouble\n*\ncsrSortedValA\n,\nconst\nint\n*\ncsrSortedRowPtrA\n,\nconst\nint\n*\ncsrSortedColIndA\n,\nconst\ndouble\n*\nbeta\n,\nconst\ncusparseMatDescr_t\ndescrB\n,\nint\nnnzB\n,\nconst\ndouble\n*\ncsrSortedValB\n,\nconst\nint\n*\ncsrSortedRowPtrB\n,\nconst\nint\n*\ncsrSortedColIndB\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\ndouble\n*\ncsrSortedValC\n,\nint\n*\ncsrSortedRowPtrC\n,\nint\n*\ncsrSortedColIndC\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseCcsrgeam2\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nint\nnnzA\n,\nconst\ncuComplex\n*\ncsrSortedValA\n,\nconst\nint\n*\ncsrSortedRowPtrA\n,\nconst\nint\n*\ncsrSortedColIndA\n,\nconst\ncuComplex\n*\nbeta\n,\nconst\ncusparseMatDescr_t\ndescrB\n,\nint\nnnzB\n,\nconst\ncuComplex\n*\ncsrSortedValB\n,\nconst\nint\n*\ncsrSortedRowPtrB\n,\nconst\nint\n*\ncsrSortedColIndB\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\ncuComplex\n*\ncsrSortedValC\n,\nint\n*\ncsrSortedRowPtrC\n,\nint\n*\ncsrSortedColIndC\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZcsrgeam2\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nalpha\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nint\nnnzA\n,\nconst\ncuDoubleComplex\n*\ncsrSortedValA\n,\nconst\nint\n*\ncsrSortedRowPtrA\n,\nconst\nint\n*\ncsrSortedColIndA\n,\nconst\ncuDoubleComplex\n*\nbeta\n,\nconst\ncusparseMatDescr_t\ndescrB\n,\nint\nnnzB\n,\nconst\ncuDoubleComplex\n*\ncsrSortedValB\n,\nconst\nint\n*\ncsrSortedRowPtrB\n,\nconst\nint\n*\ncsrSortedColIndB\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\ncuDoubleComplex\n*\ncsrSortedValC\n,\nint\n*\ncsrSortedRowPtrC\n,\nint\n*\ncsrSortedColIndC\n,\nvoid\n*\npBuffer\n)\nThis function performs following matrix-matrix operation\n\\[C = \\alpha \\ast A + \\beta \\ast B\\]\nwhere\nA\n,\nB\n, and\nC\nare\n\\(m \\times n\\)\nsparse matrices (defined in CSR storage format by the three arrays\ncsrValA|csrValB|csrValC\n,\ncsrRowPtrA|csrRowPtrB|csrRowPtrC\n, and\ncsrColIndA|csrColIndB|csrcolIndC\nrespectively), and\n\\(\\alpha\\text{~and~}\\beta\\)\nare scalars. Since\nA\nand\nB\nhave different sparsity patterns, cuSPARSE adopts a two-step approach to complete sparse matrix\nC\n. In the first step, the user allocates\ncsrRowPtrC\nof\nm+1\nelements and uses function\ncusparseXcsrgeam2Nnz()\nto determine\ncsrRowPtrC\nand the total number of nonzero elements. In the second step, the user gathers\nnnzC\n(number of nonzero elements of matrix\nC\n) from either\n(nnzC=*nnzTotalDevHostPtr)\nor\n(nnzC=csrRowPtrC(m)-csrRowPtrC(0))\nand allocates\ncsrValC,\ncsrColIndC\nof\nnnzC\nelements respectively, then finally calls function\ncusparse[S|D|C|Z]csrgeam2()\nto complete matrix\nC\n.\nThe general procedure is as follows:\nint\nbaseC\n,\nnnzC\n;\n/* alpha, nnzTotalDevHostPtr points to host memory */\nsize_t\nBufferSizeInBytes\n;\nchar\n*\nbuffer\n=\nNULL\n;\nint\n*\nnnzTotalDevHostPtr\n=\n&\nnnzC\n;\ncusparseSetPointerMode\n(\nhandle\n,\nCUSPARSE_POINTER_MODE_HOST\n);\ncudaMalloc\n((\nvoid\n**\n)\n&\ncsrRowPtrC\n,\nsizeof\n(\nint\n)\n*\n(\nm\n+\n1\n));\n/* prepare buffer */\ncusparseScsrgeam2_bufferSizeExt\n(\nhandle\n,\nm\n,\nn\n,\nalpha\n,\ndescrA\n,\nnnzA\n,\ncsrValA\n,\ncsrRowPtrA\n,\ncsrColIndA\n,\nbeta\n,\ndescrB\n,\nnnzB\n,\ncsrValB\n,\ncsrRowPtrB\n,\ncsrColIndB\n,\ndescrC\n,\ncsrValC\n,\ncsrRowPtrC\n,\ncsrColIndC\n&\nbufferSizeInBytes\n);\ncudaMalloc\n((\nvoid\n**\n)\n&\nbuffer\n,\nsizeof\n(\nchar\n)\n*\nbufferSizeInBytes\n);\ncusparseXcsrgeam2Nnz\n(\nhandle\n,\nm\n,\nn\n,\ndescrA\n,\nnnzA\n,\ncsrRowPtrA\n,\ncsrColIndA\n,\ndescrB\n,\nnnzB\n,\ncsrRowPtrB\n,\ncsrColIndB\n,\ndescrC\n,\ncsrRowPtrC\n,\nnnzTotalDevHostPtr\n,\nbuffer\n);\nif\n(\nNULL\n!=\nnnzTotalDevHostPtr\n){\nnnzC\n=\n*\nnnzTotalDevHostPtr\n;\n}\nelse\n{\ncudaMemcpy\n(\n&\nnnzC\n,\ncsrRowPtrC\n+\nm\n,\nsizeof\n(\nint\n),\ncudaMemcpyDeviceToHost\n);\ncudaMemcpy\n(\n&\nbaseC\n,\ncsrRowPtrC\n,\nsizeof\n(\nint\n),\ncudaMemcpyDeviceToHost\n);\nnnzC\n-=\nbaseC\n;\n}\ncudaMalloc\n((\nvoid\n**\n)\n&\ncsrColIndC\n,\nsizeof\n(\nint\n)\n*\nnnzC\n);\ncudaMalloc\n((\nvoid\n**\n)\n&\ncsrValC\n,\nsizeof\n(\nfloat\n)\n*\nnnzC\n);\ncusparseScsrgeam2\n(\nhandle\n,\nm\n,\nn\n,\nalpha\n,\ndescrA\n,\nnnzA\n,\ncsrValA\n,\ncsrRowPtrA\n,\ncsrColIndA\n,\nbeta\n,\ndescrB\n,\nnnzB\n,\ncsrValB\n,\ncsrRowPtrB\n,\ncsrColIndB\n,\ndescrC\n,\ncsrValC\n,\ncsrRowPtrC\n,\ncsrColIndC\nbuffer\n);\nSeveral comments on\ncsrgeam2()\n:\nThe other three combinations, NT, TN, and TT, are not supported by cuSPARSE. In order to do any one of the three, the user should use the routine\ncsr2csc()\nto convert\n\\(A\\)\n|\n\\(B\\)\nto\n\\(A^{T}\\)\n|\n\\(B^{T}\\)\n.\nOnly\nCUSPARSE_MATRIX_TYPE_GENERAL\nis supported. If either\nA\nor\nB\nis symmetric or Hermitian, then the user must extend the matrix to a full one and reconfigure the\nMatrixType\nfield of the descriptor to\nCUSPARSE_MATRIX_TYPE_GENERAL\n.\nIf the sparsity pattern of matrix\nC\nis known, the user can skip the call to function\ncusparseXcsrgeam2Nnz()\n. For example, suppose that the user has an iterative algorithm which would update\nA\nand\nB\niteratively but keep the sparsity patterns. The user can call function\ncusparseXcsrgeam2Nnz()\nonce to set up the sparsity pattern of\nC\n, then call function\ncusparse[S|D|C|Z]geam()\nonly for each iteration.\nThe pointers\nalpha\nand\nbeta\nmust be valid.\nWhen\nalpha\nor\nbeta\nis zero, it is not considered a special case by cuSPARSE. The sparsity pattern of\nC\nis independent of the value of\nalpha\nand\nbeta\n. If the user wants\n\\(C = 0 \\times A + 1 \\times B^{T}\\)\n, then\ncsr2csc()\nis better than\ncsrgeam2()\n.\ncsrgeam2()\nis the same as\ncsrgeam()\nexcept\ncsrgeam2()\nneeds explicit buffer where\ncsrgeam()\nallocates the buffer internally.\nThis function requires temporary extra storage that is allocated internally.\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available.\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available.\nInput\nhandle\nhandle to the cuSPARSE library context.\nm\nnumber of rows of sparse matrix\nA,B,C\n.\nn\nnumber of columns of sparse matrix\nA,B,C\n.\nalpha\n<type> scalar used for multiplication.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\nonly.\nnnzA\nnumber of nonzero elements of sparse matrix\nA\n.\ncsrValA\n<type> array of\nnnzA\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\nnonzero elements of matrix\nA\n.\ncsrRowPtrA\ninteger array of\nm\n\\(+ 1\\)\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndA\ninteger array of\nnnzA\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero elements of matrix\nA\n.\nbeta\n<type> scalar used for multiplication. If\nbeta\nis zero,\ny\ndoes not have to be a valid input.\ndescrB\nthe descriptor of matrix\nB\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\nonly.\nnnzB\nnumber of nonzero elements of sparse matrix\nB\n.\ncsrValB\n<type> array of\nnnzB\n\\(( =\\)\ncsrRowPtrB(m)\n\\(-\\)\ncsrRowPtrB(0)\n\\()\\)\nnonzero elements of matrix\nB\n.\ncsrRowPtrB\ninteger array of\nm\n\\(+ 1\\)\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndB\ninteger array of\nnnzB\n\\(( =\\)\ncsrRowPtrB(m)\n\\(-\\)\ncsrRowPtrB(0)\n\\()\\)\ncolumn indices of the nonzero elements of matrix\nB\n.\ndescrC\nthe descriptor of matrix\nC\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\nonly.\nOutput\ncsrValC\n<type> array of\nnnzC\n\\(( =\\)\ncsrRowPtrC(m)\n\\(-\\)\ncsrRowPtrC(0)\n\\()\\)\nnonzero elements of matrix\nC\n.\ncsrRowPtrC\ninteger array of\nm\n\\(+ 1\\)\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndC\ninteger array of\nnnzC\n\\(( =\\)\ncsrRowPtrC(m)\n\\(-\\)\ncsrRowPtrC(0)\n\\()\\)\ncolumn indices of the nonzero elements of matrix\nC\n.\nnnzTotalDevHostPtr\ntotal number of nonzero elements in device or host memory. It is equal to\n(csrRowPtrC(m)-csrRowPtrC(0))\n.\nSee\ncusparseStatus_t\nfor the description of the return status\n5.7.\ncuSPARSE Preconditioners Reference\n\nThis chapter describes the routines that implement different preconditioners.\n5.7.1.\nIncomplete Cholesky Factorization: level 0 [DEPRECATED]\n\nDifferent algorithms for ic0 are discussed in this section.\n5.7.1.1.\ncusparse<t>csric02_bufferSize() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseScsric02_bufferSize\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nfloat\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsric02Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseDcsric02_bufferSize\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ndouble\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsric02Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseCcsric02_bufferSize\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsric02Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseZcsric02_bufferSize\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuDoubleComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsric02Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n)\nThis function returns size of buffer used in computing the incomplete-Cholesky factorization with\n\\(0\\)\nfill-in and no pivoting:\n\\[A \\approx LL^{H}\\]\nA\nis an\n\\(m \\times m\\)\nsparse matrix that is defined in CSR storage format by the three arrays\ncsrValA\n,\ncsrRowPtrA\n, and\ncsrColIndA\n.\nThe buffer size depends on dimension\nm\nand\nnnz\n, the number of nonzeros of the matrix. If the user changes the matrix, it is necessary to call\ncsric02_bufferSize()\nagain to have the correct buffer size; otherwise, a segmentation fault may occur.\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nhandle\nhandle to the cuSPARSE library context.\nm\nnumber of rows and columns of matrix\nA\n.\nnnz\nnumber of nonzeros of matrix\nA\n.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrValA\n<type> array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\nnonzero elements of matrix\nA\n.\ncsrRowPtrA\ninteger array of\nm\n\\(+ 1\\)\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndA\ninteger array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero elements of matrix\nA\n.\nOutput\ninfo\nrecord internal states based on different algorithms\npBufferSizeInBytes\nnumber of bytes of the buffer used in\ncsric02_analysis()\nand\ncsric02()\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.1.2.\ncusparse<t>csric02_analysis() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseScsric02_analysis\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsric02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDcsric02_analysis\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsric02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseCcsric02_analysis\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsric02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZcsric02_analysis\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsric02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\nThis function performs the analysis phase of the incomplete-Cholesky factorization with\n\\(0\\)\nfill-in and no pivoting:\n\\[A \\approx LL^{H}\\]\nA\nis an\n\\(m \\times m\\)\nsparse matrix that is defined in CSR storage format by the three arrays\ncsrValA\n,\ncsrRowPtrA\n, and\ncsrColIndA\n.\nThis function requires a buffer size returned by\ncsric02_bufferSize()\n. The address of\npBuffer\nmust be multiple of 128 bytes. If not,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nFunction\ncsric02_analysis()\nreports a structural zero and computes level information stored in the opaque structure\ninfo\n. The level information can extract more parallelism during incomplete Cholesky factorization. However\ncsric02()\ncan be done without level information. To disable level information, the user must specify the policy of\ncsric02_analysis()\nand\ncsric02()\nas\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n.\nFunction\ncsric02_analysis()\nalways reports the first structural zero, even if the policy is\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n. The user needs to call\ncusparseXcsric02_zeroPivot()\nto know where the structural zero is.\nIt is the user’s choice whether to call\ncsric02()\nif\ncsric02_analysis()\nreports a structural zero. In this case, the user can still call\ncsric02()\n, which will return a numerical zero at the same position as the structural zero. However the result is meaningless.\nThis function requires temporary extra storage that is allocated internally\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available\nInput\nhandle\nhandle to the cuSPARSE library context.\nm\nnumber of rows and columns of matrix\nA\n.\nnnz\nnumber of nonzeros of matrix\nA\n.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrValA\n<type> array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\nnonzero elements of matrix\nA\n.\ncsrRowPtrA\ninteger array of\nm\n\\(+ 1\\)\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndA\ninteger array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero elements of matrix\nA\n.\ninfo\nstructure initialized using\ncusparseCreateCsric02Info()\n.\npolicy\nthe supported policies are\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\nand\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n.\npBuffer\nbuffer allocated by the user; the size is returned by\ncsric02_bufferSize()\n.\nOutput\ninfo\nnumber of bytes of the buffer used in\ncsric02_analysis()\nand\ncsric02()\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.1.3.\ncusparse<t>csric02() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseScsric02\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nfloat\n*\ncsrValA_valM\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsric02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDcsric02\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ndouble\n*\ncsrValA_valM\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsric02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseCcsric02\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuComplex\n*\ncsrValA_valM\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsric02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZcsric02\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuDoubleComplex\n*\ncsrValA_valM\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsric02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\nThis function performs the solve phase of the computing the incomplete-Cholesky factorization with\n\\(0\\)\nfill-in and no pivoting:\n\\[A \\approx LL^{H}\\]\nThis function requires a buffer size returned by\ncsric02_bufferSize()\n. The address of\npBuffer\nmust be a multiple of 128 bytes. If not,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nAlthough\ncsric02()\ncan be done without level information, the user still needs to be aware of consistency. If\ncsric02_analysis()\nis called with policy\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n,\ncsric02()\ncan be run with or without levels. On the other hand, if\ncsric02_analysis()\nis called with\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n,\ncsric02()\ncan only accept\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n; otherwise,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nFunction\ncsric02()\nreports the first numerical zero, including a structural zero. The user must call\ncusparseXcsric02_zeroPivot()\nto know where the numerical zero is.\nFunction\ncsric02()\nonly takes the lower triangular part of matrix\nA\nto perform factorization. The matrix type must be\nCUSPARSE_MATRIX_TYPE_GENERAL\n, the fill mode and diagonal type are ignored, and the strictly upper triangular part is ignored and never touched. It does not matter if\nA\nis Hermitian or not. In other words, from the point of view of\ncsric02()\nA\nis Hermitian and only the lower triangular part is provided.\nNote\nIn practice, a positive definite matrix may not have incomplete cholesky factorization. To the best of our knowledge, only matrix\nM\ncan guarantee the existence of incomplete cholesky factorization. If\ncsric02()\nfailed cholesky factorization and reported a numerical zero, it is possible that incomplete cholesky factorization does not exist.\nFor example, suppose\nA\nis a real\nm times m\nmatrix, the following code solves the precondition system\nM*y\n=\nx\nwhere\nM\nis the product of Cholesky factorization\nL\nand its transpose.\n\\[M = LL^{H}\\]\n// Suppose that A is m x m sparse matrix represented by CSR format,\n// Assumption:\n// - handle is already created by cusparseCreate(),\n// - (d_csrRowPtr, d_csrColInd, d_csrVal) is CSR of A on device memory,\n// - d_x is right hand side vector on device memory,\n// - d_y is solution vector on device memory.\n// - d_z is intermediate result on device memory.\ncusparseMatDescr_t\ndescr_M\n=\n0\n;\ncusparseMatDescr_t\ndescr_L\n=\n0\n;\ncsric02Info_t\ninfo_M\n=\n0\n;\ncsrsv2Info_t\ninfo_L\n=\n0\n;\ncsrsv2Info_t\ninfo_Lt\n=\n0\n;\nint\npBufferSize_M\n;\nint\npBufferSize_L\n;\nint\npBufferSize_Lt\n;\nint\npBufferSize\n;\nvoid\n*\npBuffer\n=\n0\n;\nint\nstructural_zero\n;\nint\nnumerical_zero\n;\nconst\ndouble\nalpha\n=\n1.\n;\nconst\ncusparseSolvePolicy_t\npolicy_M\n=\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n;\nconst\ncusparseSolvePolicy_t\npolicy_L\n=\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n;\nconst\ncusparseSolvePolicy_t\npolicy_Lt\n=\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n;\nconst\ncusparseOperation_t\ntrans_L\n=\nCUSPARSE_OPERATION_NON_TRANSPOSE\n;\nconst\ncusparseOperation_t\ntrans_Lt\n=\nCUSPARSE_OPERATION_TRANSPOSE\n;\n// step 1: create a descriptor which contains\n// - matrix M is base-1\n// - matrix L is base-1\n// - matrix L is lower triangular\n// - matrix L has non-unit diagonal\ncusparseCreateMatDescr\n(\n&\ndescr_M\n);\ncusparseSetMatIndexBase\n(\ndescr_M\n,\nCUSPARSE_INDEX_BASE_ONE\n);\ncusparseSetMatType\n(\ndescr_M\n,\nCUSPARSE_MATRIX_TYPE_GENERAL\n);\ncusparseCreateMatDescr\n(\n&\ndescr_L\n);\ncusparseSetMatIndexBase\n(\ndescr_L\n,\nCUSPARSE_INDEX_BASE_ONE\n);\ncusparseSetMatType\n(\ndescr_L\n,\nCUSPARSE_MATRIX_TYPE_GENERAL\n);\ncusparseSetMatFillMode\n(\ndescr_L\n,\nCUSPARSE_FILL_MODE_LOWER\n);\ncusparseSetMatDiagType\n(\ndescr_L\n,\nCUSPARSE_DIAG_TYPE_NON_UNIT\n);\n// step 2: create a empty info structure\n// we need one info for csric02 and two info's for csrsv2\ncusparseCreateCsric02Info\n(\n&\ninfo_M\n);\ncusparseCreateCsrsv2Info\n(\n&\ninfo_L\n);\ncusparseCreateCsrsv2Info\n(\n&\ninfo_Lt\n);\n// step 3: query how much memory used in csric02 and csrsv2, and allocate the buffer\ncusparseDcsric02_bufferSize\n(\nhandle\n,\nm\n,\nnnz\n,\ndescr_M\n,\nd_csrVal\n,\nd_csrRowPtr\n,\nd_csrColInd\n,\ninfo_M\n,\n&\nbufferSize_M\n);\ncusparseDcsrsv2_bufferSize\n(\nhandle\n,\ntrans_L\n,\nm\n,\nnnz\n,\ndescr_L\n,\nd_csrVal\n,\nd_csrRowPtr\n,\nd_csrColInd\n,\ninfo_L\n,\n&\npBufferSize_L\n);\ncusparseDcsrsv2_bufferSize\n(\nhandle\n,\ntrans_Lt\n,\nm\n,\nnnz\n,\ndescr_L\n,\nd_csrVal\n,\nd_csrRowPtr\n,\nd_csrColInd\n,\ninfo_Lt\n,\n&\npBufferSize_Lt\n);\npBufferSize\n=\nmax\n(\nbufferSize_M\n,\nmax\n(\npBufferSize_L\n,\npBufferSize_Lt\n));\n// pBuffer returned by cudaMalloc is automatically aligned to 128 bytes.\ncudaMalloc\n((\nvoid\n**\n)\n&\npBuffer\n,\npBufferSize\n);\n// step 4: perform analysis of incomplete Cholesky on M\n//         perform analysis of triangular solve on L\n//         perform analysis of triangular solve on L'\n// The lower triangular part of M has the same sparsity pattern as L, so\n// we can do analysis of csric02 and csrsv2 simultaneously.\ncusparseDcsric02_analysis\n(\nhandle\n,\nm\n,\nnnz\n,\ndescr_M\n,\nd_csrVal\n,\nd_csrRowPtr\n,\nd_csrColInd\n,\ninfo_M\n,\npolicy_M\n,\npBuffer\n);\nstatus\n=\ncusparseXcsric02_zeroPivot\n(\nhandle\n,\ninfo_M\n,\n&\nstructural_zero\n);\nif\n(\nCUSPARSE_STATUS_ZERO_PIVOT\n==\nstatus\n){\nprintf\n(\n\"A(%d,%d) is missing\n\\n\n\"\n,\nstructural_zero\n,\nstructural_zero\n);\n}\ncusparseDcsrsv2_analysis\n(\nhandle\n,\ntrans_L\n,\nm\n,\nnnz\n,\ndescr_L\n,\nd_csrVal\n,\nd_csrRowPtr\n,\nd_csrColInd\n,\ninfo_L\n,\npolicy_L\n,\npBuffer\n);\ncusparseDcsrsv2_analysis\n(\nhandle\n,\ntrans_Lt\n,\nm\n,\nnnz\n,\ndescr_L\n,\nd_csrVal\n,\nd_csrRowPtr\n,\nd_csrColInd\n,\ninfo_Lt\n,\npolicy_Lt\n,\npBuffer\n);\n// step 5: M = L * L'\ncusparseDcsric02\n(\nhandle\n,\nm\n,\nnnz\n,\ndescr_M\n,\nd_csrVal\n,\nd_csrRowPtr\n,\nd_csrColInd\n,\ninfo_M\n,\npolicy_M\n,\npBuffer\n);\nstatus\n=\ncusparseXcsric02_zeroPivot\n(\nhandle\n,\ninfo_M\n,\n&\nnumerical_zero\n);\nif\n(\nCUSPARSE_STATUS_ZERO_PIVOT\n==\nstatus\n){\nprintf\n(\n\"L(%d,%d) is zero\n\\n\n\"\n,\nnumerical_zero\n,\nnumerical_zero\n);\n}\n// step 6: solve L*z = x\ncusparseDcsrsv2_solve\n(\nhandle\n,\ntrans_L\n,\nm\n,\nnnz\n,\n&\nalpha\n,\ndescr_L\n,\n// replace with cusparseSpSV\nd_csrVal\n,\nd_csrRowPtr\n,\nd_csrColInd\n,\ninfo_L\n,\nd_x\n,\nd_z\n,\npolicy_L\n,\npBuffer\n);\n// step 7: solve L'*y = z\ncusparseDcsrsv2_solve\n(\nhandle\n,\ntrans_Lt\n,\nm\n,\nnnz\n,\n&\nalpha\n,\ndescr_L\n,\n// replace with cusparseSpSV\nd_csrVal\n,\nd_csrRowPtr\n,\nd_csrColInd\n,\ninfo_Lt\n,\nd_z\n,\nd_y\n,\npolicy_Lt\n,\npBuffer\n);\n// step 6: free resources\ncudaFree\n(\npBuffer\n);\ncusparseDestroyMatDescr\n(\ndescr_M\n);\ncusparseDestroyMatDescr\n(\ndescr_L\n);\ncusparseDestroyCsric02Info\n(\ninfo_M\n);\ncusparseDestroyCsrsv2Info\n(\ninfo_L\n);\ncusparseDestroyCsrsv2Info\n(\ninfo_Lt\n);\ncusparseDestroy\n(\nhandle\n);\nThe function supports the following properties if\npBuffer\n!=\nNULL\n:\nThis function requires temporary extra storage that is allocated internally.\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available.\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available.\nInput\nhandle\nhandle to the cuSPARSE library context.\nm\nnumber of rows and columns of matrix\nA\n.\nnnz\nnumber of nonzeros of matrix\nA\n.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrValA_valM\n<type> array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\nnonzero elements of matrix\nA\n.\ncsrRowPtrA\ninteger array of\nm\n\\(+ 1\\)\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndA\ninteger array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero elements of matrix\nA\n.\ninfo\nstructure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).\npolicy\nthe supported policies are\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\nand\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n.\npBuffer\nbuffer allocated by the user; the size is returned by\ncsric02_bufferSize()\n.\nOutput\ncsrValA_valM\n<type> matrix containing the incomplete-Cholesky lower triangular factor.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.1.4.\ncusparseXcsric02_zeroPivot()  [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseXcsric02_zeroPivot\n(\ncusparseHandle_t\nhandle\n,\ncsric02Info_t\ninfo\n,\nint\n*\nposition\n)\nIf the returned error code is\nCUSPARSE_STATUS_ZERO_PIVOT\n,\nposition=j\nmeans\nA(j,j)\nhas either a structural zero or a numerical zero; otherwise,\nposition=-1\n.\nThe\nposition\ncan be 0-based or 1-based, the same as the matrix.\nFunction\ncusparseXcsric02_zeroPivot()\nis a blocking call. It calls\ncudaDeviceSynchronize()\nto make sure all previous kernels are done.\nThe\nposition\ncan be in the host memory or device memory. The user can set proper mode with\ncusparseSetPointerMode()\n.\nThe routine requires no extra storage.\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available.\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available.\nInput\nhandle\nhandle to the cuSPARSE library context.\ninfo\ninfo\ncontains structural zero or numerical zero if the user already called\ncsric02_analysis()\nor\ncsric02()\n.\nOutput\nposition\nif no structural or numerical zero,\nposition\nis -1; otherwise, if\nA(j,j)\nis missing or\nL(j,j)\nis zero,\nposition=j\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.1.5.\ncusparse<t>bsric02_bufferSize() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseSbsric02_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nfloat\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsric02Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseDbsric02_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ndouble\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsric02Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseCbsric02_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsric02Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseZbsric02_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuDoubleComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsric02Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n)\nThis function returns the size of a buffer used in computing the incomplete-Cholesky factorization with 0 fill-in and no pivoting\n\\[A \\approx LL^{H}\\]\nA\nis an\n(mb*blockDim)*(mb*blockDim)\nsparse matrix that is defined in BSR storage format by the three arrays\nbsrValA\n,\nbsrRowPtrA\n, and\nbsrColIndA\n.\nThe buffer size depends on the dimensions of\nmb\n,\nblockDim\n, and the number of nonzero blocks of the matrix\nnnzb\n. If the user changes the matrix, it is necessary to call\nbsric02_bufferSize()\nagain to have the correct buffer size; otherwise, a segmentation fault may occur.\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nhandle\nhandle to the cuSPARSE library context.\ndirA\nstorage format of blocks, either\nCUSPARSE_DIRECTION_ROW\nor\nCUSPARSE_DIRECTION_COLUMN\n.\nmb\nnumber of block rows and block columns of matrix\nA\n.\nnnzb\nnumber of nonzero blocks of matrix\nA\n.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\nbsrValA\n<type> array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\nnonzero blocks of matrix\nA\n.\nbsrRowPtrA\ninteger array of\nmb\n\\(+ 1\\)\nelements that contains the start of every block row and the end of the last block row plus one.\nbsrColIndA\ninteger array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero blocks of matrix\nA\n.\nblockDim\nblock dimension of sparse matrix A, larger than zero.\nOutput\ninfo\nrecord internal states based on different algorithms.\npBufferSizeInBytes\nnumber of bytes of the buffer used in\nbsric02_analysis()\nand\nbsric02()\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.1.6.\ncusparse<t>bsric02_analysis()  [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseSbsric02_analysis\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsric02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDbsric02_analysis\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsric02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseCbsric02_analysis\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsric02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZbsric02_analysis\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsric02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\nThis function performs the analysis phase of the incomplete-Cholesky factorization with 0 fill-in and no pivoting\n\\[A \\approx LL^{H}\\]\nA\nis an\n(mb*blockDim)x(mb*blockDim)\nsparse matrix that is defined in BSR storage format by the three arrays\nbsrValA\n,\nbsrRowPtrA\n, and\nbsrColIndA\n. The block in BSR format is of size\nblockDim*blockDim\n, stored as column-major or row-major as determined by parameter\ndirA\n, which is either\nCUSPARSE_DIRECTION_COLUMN\nor\nCUSPARSE_DIRECTION_ROW\n. The matrix type must be\nCUSPARSE_MATRIX_TYPE_GENERAL\n, and the fill mode and diagonal type are ignored.\nThis function requires a buffer size returned by\nbsric02_bufferSize90\n. The address of\npBuffer\nmust be a multiple of 128 bytes. If it is not,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nFunction\nbsric02_analysis()\nreports structural zero and computes level information stored in the opaque structure\ninfo\n. The level information can extract more parallelism during incomplete Cholesky factorization. However\nbsric02()\ncan be done without level information. To disable level information, the user needs to specify the parameter\npolicy\nof\nbsric02[_analysis|\n]\nas\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n.\nFunction\nbsric02_analysis\nalways reports the first structural zero, even when parameter\npolicy\nis\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n. The user must call\ncusparseXbsric02_zeroPivot()\nto know where the structural zero is.\nIt is the user’s choice whether to call\nbsric02()\nif\nbsric02_analysis()\nreports a structural zero. In this case, the user can still call\nbsric02()\n, which returns a numerical zero in the same position as the structural zero. However the result is meaningless.\nThis function requires temporary extra storage that is allocated internally.\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available.\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available.\nInput\nhandle\nhandle to the cuSPARSE library context.\ndirA\nstorage format of blocks, either\nCUSPARSE_DIRECTION_ROW\nor\nCUSPARSE_DIRECTION_COLUMN\n.\nmb\nnumber of block rows and block columns of matrix\nA\n.\nnnzb\nnumber of nonzero blocks of matrix\nA\n.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\nbsrValA\n<type> array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\nnonzero blocks of matrix\nA\n.\nbsrRowPtrA\ninteger array of\nmb\n\\(+ 1\\)\nelements that contains the start of every block row and the end of the last block row plus one.\nbsrColIndA\ninteger array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero blocks of matrix\nA\n.\nblockDim\nblock dimension of sparse matrix A; must be larger than zero.\ninfo\nstructure initialized using\ncusparseCreateBsric02Info()\n.\npolicy\nthe supported policies are\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\nand\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n.\npBuffer\nbuffer allocated by the user; the size is returned by\nbsric02_bufferSize()\n.\nOutput\ninfo\nStructure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.1.7.\ncusparse<t>bsric02()  [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseSbsric02\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nfloat\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsric02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDbsric02\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ndouble\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsric02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseCbsric02\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsric02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZbsric02\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuDoubleComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsric02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\nThis function performs the solve phase of the incomplete-Cholesky factorization with 0 fill-in and no pivoting.\n\\[A \\approx LL^{H}\\]\nA\nis an\n(mb*blockDim)x(mb*blockDim)\nsparse matrix that is defined in BSR storage format by the three arrays\nbsrValA\n,\nbsrRowPtrA\n, and\nbsrColIndA\n. The block in BSR format is of size\nblockDim*blockDim\n, stored as column-major or row-major as determined by parameter\ndirA\n, which is either\nCUSPARSE_DIRECTION_COLUMN\nor\nCUSPARSE_DIRECTION_ROW\n. The matrix type must be\nCUSPARSE_MATRIX_TYPE_GENERAL\n, and the fill mode and diagonal type are ignored.\nThis function requires a buffer size returned by\nbsric02_bufferSize()\n. The address of\npBuffer\nmust be a multiple of 128 bytes. If it is not,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nAlthough\nbsric02()\ncan be done without level information, the user must be aware of consistency. If\nbsric02_analysis()\nis called with policy\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n,\nbsric02()\ncan be run with or without levels. On the other hand, if\nbsric02_analysis()\nis called with\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n,\nbsric02()\ncan only accept\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n; otherwise,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nFunction\nbsric02()\nhas the same behavior as\ncsric02()\n. That is,\nbsr2csr(bsric02(A))\n=\ncsric02(bsr2csr(A))\n. The numerical zero of\ncsric02()\nmeans there exists some zero\nL(j,j)\n. The numerical zero of\nbsric02()\nmeans there exists some block\nLj,j)\nthat is not invertible.\nFunction\nbsric02\nreports the first numerical zero, including a structural zero. The user must call\ncusparseXbsric02_zeroPivot()\nto know where the numerical zero is.\nThe\nbsric02()\nfunction only takes the lower triangular part of matrix\nA\nto perform factorization. The strictly upper triangular part is ignored and never touched. It does not matter if\nA\nis Hermitian or not. In other words, from the point of view of\nbsric02()\n,\nA\nis Hermitian and only the lower triangular part is provided. Moreover, the imaginary part of diagonal elements of diagonal blocks is ignored.\nFor example, suppose\nA\nis a real m-by-m matrix, where\nm=mb*blockDim\n. The following code solves precondition system\nM*y\n=\nx\n, where\nM\nis the product of Cholesky factorization\nL\nand its transpose.\n\\[M = LL^{H}\\]\n// Suppose that A is m x m sparse matrix represented by BSR format,\n// The number of block rows/columns is mb, and\n// the number of nonzero blocks is nnzb.\n// Assumption:\n// - handle is already created by cusparseCreate(),\n// - (d_bsrRowPtr, d_bsrColInd, d_bsrVal) is BSR of A on device memory,\n// - d_x is right hand side vector on device memory,\n// - d_y is solution vector on device memory.\n// - d_z is intermediate result on device memory.\n// - d_x, d_y and d_z are of size m.\ncusparseMatDescr_t\ndescr_M\n=\n0\n;\ncusparseMatDescr_t\ndescr_L\n=\n0\n;\nbsric02Info_t\ninfo_M\n=\n0\n;\nbsrsv2Info_t\ninfo_L\n=\n0\n;\nbsrsv2Info_t\ninfo_Lt\n=\n0\n;\nint\npBufferSize_M\n;\nint\npBufferSize_L\n;\nint\npBufferSize_Lt\n;\nint\npBufferSize\n;\nvoid\n*\npBuffer\n=\n0\n;\nint\nstructural_zero\n;\nint\nnumerical_zero\n;\nconst\ndouble\nalpha\n=\n1.\n;\nconst\ncusparseSolvePolicy_t\npolicy_M\n=\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n;\nconst\ncusparseSolvePolicy_t\npolicy_L\n=\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n;\nconst\ncusparseSolvePolicy_t\npolicy_Lt\n=\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n;\nconst\ncusparseOperation_t\ntrans_L\n=\nCUSPARSE_OPERATION_NON_TRANSPOSE\n;\nconst\ncusparseOperation_t\ntrans_Lt\n=\nCUSPARSE_OPERATION_TRANSPOSE\n;\nconst\ncusparseDirection_t\ndir\n=\nCUSPARSE_DIRECTION_COLUMN\n;\n// step 1: create a descriptor which contains\n// - matrix M is base-1\n// - matrix L is base-1\n// - matrix L is lower triangular\n// - matrix L has non-unit diagonal\ncusparseCreateMatDescr\n(\n&\ndescr_M\n);\ncusparseSetMatIndexBase\n(\ndescr_M\n,\nCUSPARSE_INDEX_BASE_ONE\n);\ncusparseSetMatType\n(\ndescr_M\n,\nCUSPARSE_MATRIX_TYPE_GENERAL\n);\ncusparseCreateMatDescr\n(\n&\ndescr_L\n);\ncusparseSetMatIndexBase\n(\ndescr_L\n,\nCUSPARSE_INDEX_BASE_ONE\n);\ncusparseSetMatType\n(\ndescr_L\n,\nCUSPARSE_MATRIX_TYPE_GENERAL\n);\ncusparseSetMatFillMode\n(\ndescr_L\n,\nCUSPARSE_FILL_MODE_LOWER\n);\ncusparseSetMatDiagType\n(\ndescr_L\n,\nCUSPARSE_DIAG_TYPE_NON_UNIT\n);\n// step 2: create a empty info structure\n// we need one info for bsric02 and two info's for bsrsv2\ncusparseCreateBsric02Info\n(\n&\ninfo_M\n);\ncusparseCreateBsrsv2Info\n(\n&\ninfo_L\n);\ncusparseCreateBsrsv2Info\n(\n&\ninfo_Lt\n);\n// step 3: query how much memory used in bsric02 and bsrsv2, and allocate the buffer\ncusparseDbsric02_bufferSize\n(\nhandle\n,\ndir\n,\nmb\n,\nnnzb\n,\ndescr_M\n,\nd_bsrVal\n,\nd_bsrRowPtr\n,\nd_bsrColInd\n,\nblockDim\n,\ninfo_M\n,\n&\nbufferSize_M\n);\ncusparseDbsrsv2_bufferSize\n(\nhandle\n,\ndir\n,\ntrans_L\n,\nmb\n,\nnnzb\n,\ndescr_L\n,\nd_bsrVal\n,\nd_bsrRowPtr\n,\nd_bsrColInd\n,\nblockDim\n,\ninfo_L\n,\n&\npBufferSize_L\n);\ncusparseDbsrsv2_bufferSize\n(\nhandle\n,\ndir\n,\ntrans_Lt\n,\nmb\n,\nnnzb\n,\ndescr_L\n,\nd_bsrVal\n,\nd_bsrRowPtr\n,\nd_bsrColInd\n,\nblockDim\n,\ninfo_Lt\n,\n&\npBufferSize_Lt\n);\npBufferSize\n=\nmax\n(\nbufferSize_M\n,\nmax\n(\npBufferSize_L\n,\npBufferSize_Lt\n));\n// pBuffer returned by cudaMalloc is automatically aligned to 128 bytes.\ncudaMalloc\n((\nvoid\n**\n)\n&\npBuffer\n,\npBufferSize\n);\n// step 4: perform analysis of incomplete Cholesky on M\n//         perform analysis of triangular solve on L\n//         perform analysis of triangular solve on L'\n// The lower triangular part of M has the same sparsity pattern as L, so\n// we can do analysis of bsric02 and bsrsv2 simultaneously.\ncusparseDbsric02_analysis\n(\nhandle\n,\ndir\n,\nmb\n,\nnnzb\n,\ndescr_M\n,\nd_bsrVal\n,\nd_bsrRowPtr\n,\nd_bsrColInd\n,\nblockDim\n,\ninfo_M\n,\npolicy_M\n,\npBuffer\n);\nstatus\n=\ncusparseXbsric02_zeroPivot\n(\nhandle\n,\ninfo_M\n,\n&\nstructural_zero\n);\nif\n(\nCUSPARSE_STATUS_ZERO_PIVOT\n==\nstatus\n){\nprintf\n(\n\"A(%d,%d) is missing\n\\n\n\"\n,\nstructural_zero\n,\nstructural_zero\n);\n}\ncusparseDbsrsv2_analysis\n(\nhandle\n,\ndir\n,\ntrans_L\n,\nmb\n,\nnnzb\n,\ndescr_L\n,\nd_bsrVal\n,\nd_bsrRowPtr\n,\nd_bsrColInd\n,\nblockDim\n,\ninfo_L\n,\npolicy_L\n,\npBuffer\n);\ncusparseDbsrsv2_analysis\n(\nhandle\n,\ndir\n,\ntrans_Lt\n,\nmb\n,\nnnzb\n,\ndescr_L\n,\nd_bsrVal\n,\nd_bsrRowPtr\n,\nd_bsrColInd\n,\nblockDim\n,\ninfo_Lt\n,\npolicy_Lt\n,\npBuffer\n);\n// step 5: M = L * L'\ncusparseDbsric02_solve\n(\nhandle\n,\ndir\n,\nmb\n,\nnnzb\n,\ndescr_M\n,\nd_bsrVal\n,\nd_bsrRowPtr\n,\nd_bsrColInd\n,\nblockDim\n,\ninfo_M\n,\npolicy_M\n,\npBuffer\n);\nstatus\n=\ncusparseXbsric02_zeroPivot\n(\nhandle\n,\ninfo_M\n,\n&\nnumerical_zero\n);\nif\n(\nCUSPARSE_STATUS_ZERO_PIVOT\n==\nstatus\n){\nprintf\n(\n\"L(%d,%d) is not positive definite\n\\n\n\"\n,\nnumerical_zero\n,\nnumerical_zero\n);\n}\n// step 6: solve L*z = x\ncusparseDbsrsv2_solve\n(\nhandle\n,\ndir\n,\ntrans_L\n,\nmb\n,\nnnzb\n,\n&\nalpha\n,\ndescr_L\n,\nd_bsrVal\n,\nd_bsrRowPtr\n,\nd_bsrColInd\n,\nblockDim\n,\ninfo_L\n,\nd_x\n,\nd_z\n,\npolicy_L\n,\npBuffer\n);\n// step 7: solve L'*y = z\ncusparseDbsrsv2_solve\n(\nhandle\n,\ndir\n,\ntrans_Lt\n,\nmb\n,\nnnzb\n,\n&\nalpha\n,\ndescr_L\n,\nd_bsrVal\n,\nd_bsrRowPtr\n,\nd_bsrColInd\n,\nblockDim\n,\ninfo_Lt\n,\nd_z\n,\nd_y\n,\npolicy_Lt\n,\npBuffer\n);\n// step 6: free resources\ncudaFree\n(\npBuffer\n);\ncusparseDestroyMatDescr\n(\ndescr_M\n);\ncusparseDestroyMatDescr\n(\ndescr_L\n);\ncusparseDestroyBsric02Info\n(\ninfo_M\n);\ncusparseDestroyBsrsv2Info\n(\ninfo_L\n);\ncusparseDestroyBsrsv2Info\n(\ninfo_Lt\n);\ncusparseDestroy\n(\nhandle\n);\nThe function supports the following properties if\npBuffer\n!=\nNULL\n:\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nhandle\nhandle to the cuSPARSE library context.\ndirA\nstorage format of blocks, either\nCUSPARSE_DIRECTION_ROW\nor\nCUSPARSE_DIRECTION_COLUMN\n.\nmb\nnumber of block rows and block columns of matrix\nA\n.\nnnzb\nnumber of nonzero blocks of matrix\nA\n.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\nbsrValA\n<type> array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\nnonzero blocks of matrix\nA\n.\nbsrRowPtrA\ninteger array of\nmb\n\\(+ 1\\)\nelements that contains the start of every block row and the end of the last block row plus one.\nbsrColIndA\ninteger array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero blocks of matrix\nA\n.\nblockDim\nblock dimension of sparse matrix A, larger than zero.\ninfo\nstructure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).\npolicy\nthe supported policies are\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\nand\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n.\npBuffer\nbuffer allocated by the user, the size is returned by\nbsric02_bufferSize()\n.\nOutput\nbsrValA\n<type> matrix containing the incomplete-Cholesky lower triangular factor.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.1.8.\ncusparseXbsric02_zeroPivot()  [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseXbsric02_zeroPivot\n(\ncusparseHandle_t\nhandle\n,\nbsric02Info_t\ninfo\n,\nint\n*\nposition\n)\nIf the returned error code is\nCUSPARSE_STATUS_ZERO_PIVOT\n,\nposition=j\nmeans\nA(j,j)\nhas either a structural zero or a numerical zero (the block is not positive definite). Otherwise\nposition=-1\n.\nThe\nposition\ncan be 0-based or 1-based, the same as the matrix.\nFunction\ncusparseXbsric02_zeroPivot()\nis a blocking call. It calls\ncudaDeviceSynchronize()\nto make sure all previous kernels are done.\nThe\nposition\ncan be in the host memory or device memory. The user can set the proper mode with\ncusparseSetPointerMode()\n.\nThe routine requires no extra storage.\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available.\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available.\nInput\nhandle\nhandle to the cuSPARSE library context.\ninfo\ninfo\ncontains a structural zero or a numerical zero if the user already called\nbsric02_analysis()\nor\nbsric02()\n.\nOutput\nposition\nIf no structural or numerical zero,\nposition\nis -1, otherwise if\nA(j,j)\nis missing or\nL(j,j)\nis not positive definite,\nposition=j\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.2.\nIncomplete LU Factorization: level 0 [DEPRECATED]\n\nDifferent algorithms for ilu0 are discussed in this section.\n5.7.2.1.\ncusparse<t>csrilu02_numericBoost() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseScsrilu02_numericBoost\n(\ncusparseHandle_t\nhandle\n,\ncsrilu02Info_t\ninfo\n,\nint\nenable_boost\n,\ndouble\n*\ntol\n,\nfloat\n*\nboost_val\n)\ncusparseStatus_t\ncusparseDcsrilu02_numericBoost\n(\ncusparseHandle_t\nhandle\n,\ncsrilu02Info_t\ninfo\n,\nint\nenable_boost\n,\ndouble\n*\ntol\n,\ndouble\n*\nboost_val\n)\ncusparseStatus_t\ncusparseCcsrilu02_numericBoost\n(\ncusparseHandle_t\nhandle\n,\ncsrilu02Info_t\ninfo\n,\nint\nenable_boost\n,\ndouble\n*\ntol\n,\ncuComplex\n*\nboost_val\n)\ncusparseStatus_t\ncusparseZcsrilu02_numericBoost\n(\ncusparseHandle_t\nhandle\n,\ncsrilu02Info_t\ninfo\n,\nint\nenable_boost\n,\ndouble\n*\ntol\n,\ncuDoubleComplex\n*\nboost_val\n)\nThe user can use a boost value to replace a numerical value in incomplete LU factorization. The\ntol\nis used to determine a numerical zero, and the\nboost_val\nis used to replace a numerical zero. The behavior is\nif\ntol\n>=\nfabs(A(j,j))\n, then\nA(j,j)=boost_val\n.\nTo enable a boost value, the user has to set parameter\nenable_boost\nto 1 before calling\ncsrilu02()\n. To disable a boost value, the user can call\ncsrilu02_numericBoost()\nagain with parameter\nenable_boost=0\n.\nIf\nenable_boost=0\n,\ntol\nand\nboost_val\nare ignored.\nBoth\ntol\nand\nboost_val\ncan be in the host memory or device memory. The user can set the proper mode with\ncusparseSetPointerMode()\n.\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nhandle\nhandle to the cuSPARSE library context\ninfo\nstructure initialized using\ncusparseCreateCsrilu02Info()\nenable_boost\ndisable boost by\nenable_boost=0\n; otherwise, boost is enabled\ntol\ntolerance to determine a numerical zero\nboost_val\nboost value to replace a numerical zero\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.2.2.\ncusparse<t>csrilu02_bufferSize() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseScsrilu02_bufferSize\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nfloat\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsrilu02Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseDcsrilu02_bufferSize\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ndouble\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsrilu02Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseCcsrilu02_bufferSize\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsrilu02Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseZcsrilu02_bufferSize\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuDoubleComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsrilu02Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n)\nThis function returns size of the buffer used in computing the incomplete-LU factorization with\n\\(0\\)\nfill-in and no pivoting:\n\\[A \\approx LU\\]\nA\nis an\n\\(m \\times m\\)\nsparse matrix that is defined in CSR storage format by the three arrays\ncsrValA\n,\ncsrRowPtrA\n, and\ncsrColIndA\n.\nThe buffer size depends on the dimension\nm\nand\nnnz\n, the number of nonzeros of the matrix. If the user changes the matrix, it is necessary to call\ncsrilu02_bufferSize()\nagain to have the correct buffer size; otherwise, a segmentation fault may occur.\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nhandle\nhandle to the cuSPARSE library context.\nm\nnumber of rows and columns of matrix\nA\n.\nnnz\nnumber of nonzeros of matrix\nA\n.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrValA\n<type> array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\nnonzero elements of matrix\nA\n.\ncsrRowPtrA\ninteger array of\nm\n\\(+ 1\\)\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndA\ninteger array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero elements of matrix\nA\n.\nOutput\ninfo\nrecord internal states based on different algorithms\npBufferSizeInBytes\nnumber of bytes of the buffer used in\ncsrilu02_analysis()\nand\ncsrilu02()\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.2.3.\ncusparse<t>csrilu02_analysis() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseScsrilu02_analysis\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsrilu02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDcsrilu02_analysis\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsrilu02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseCcsrilu02_analysis\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsrilu02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZcsrilu02_analysis\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsrilu02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\nThis function performs the analysis phase of the incomplete-LU factorization with\n\\(0\\)\nfill-in and no pivoting:\n\\[A \\approx LU\\]\nA\nis an\n\\(m \\times m\\)\nsparse matrix that is defined in CSR storage format by the three arrays\ncsrValA\n,\ncsrRowPtrA\n, and\ncsrColIndA\n.\nThis function requires the buffer size returned by\ncsrilu02_bufferSize()\n. The address of\npBuffer\nmust be a multiple of 128 bytes. If not,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nFunction\ncsrilu02_analysis()\nreports a structural zero and computes level information stored in the opaque structure\ninfo\n. The level information can extract more parallelism during incomplete LU factorization; however\ncsrilu02()\ncan be done without level information. To disable level information, the user must specify the policy of\ncsrilu02()\nas\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n.\nIt is the user’s choice whether to call\ncsrilu02()\nif\ncsrilu02_analysis()\nreports a structural zero. In this case, the user can still call\ncsrilu02()\n, which will return a numerical zero at the same position as the structural zero. However, the result is meaningless.\nThis function requires temporary extra storage that is allocated internally.\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available.\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available.\nInput\nhandle\nhandle to the cuSPARSE library context.\nm\nnumber of rows and columns of matrix\nA\n.\nnnz\nnumber of nonzeros of matrix\nA\n.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrValA\n<type> array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\nnonzero elements of matrix\nA\n.\ncsrRowPtrA\ninteger array of\nm\n\\(+ 1\\)\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndA\ninteger array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero elements of matrix\nA\n.\ninfo\nstructure initialized using\ncusparseCreateCsrilu02Info()\n.\npolicy\nthe supported policies are\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\nand\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n.\npBuffer\nbuffer allocated by the user, the size is returned by\ncsrilu02_bufferSize()\n.\nOutput\ninfo\nStructure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.2.4.\ncusparse<t>csrilu02() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseScsrilu02\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nfloat\n*\ncsrValA_valM\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsrilu02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDcsrilu02\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ndouble\n*\ncsrValA_valM\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsrilu02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseCcsrilu02\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuComplex\n*\ncsrValA_valM\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsrilu02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZcsrilu02\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuDoubleComplex\n*\ncsrValA_valM\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsrilu02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\nThis function performs the solve phase of the incomplete-LU factorization with\n\\(0\\)\nfill-in and no pivoting:\n\\[A \\approx LU\\]\nA\nis an\n\\(m \\times m\\)\nsparse matrix that is defined in CSR storage format by the three arrays\ncsrValA_valM\n,\ncsrRowPtrA\n, and\ncsrColIndA\n.\nThis function requires a buffer size returned by\ncsrilu02_bufferSize()\n. The address of\npBuffer\nmust be a multiple of 128 bytes. If not,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nThe matrix type must be\nCUSPARSE_MATRIX_TYPE_GENERAL\n. The fill mode and diagonal type are ignored.\nAlthough\ncsrilu02()\ncan be done without level information, the user still needs to be aware of consistency. If\ncsrilu02_analysis()\nis called with policy\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n,\ncsrilu02()\ncan be run with or without levels. On the other hand, if\ncsrilu02_analysis()\nis called with\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n,\ncsrilu02()\ncan only accept\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n; otherwise,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nFunction\ncsrilu02()\nreports the first numerical zero, including a structural zero. The user must call\ncusparseXcsrilu02_zeroPivot()\nto know where the numerical zero is.\nFor example, suppose\nA\nis a real\n\\(m \\times m\\)\nmatrix, the following code solves precondition system\nM*y\n=\nx\nwhere\nM\nis the product of LU factors\nL\nand\nU\n.\n// Suppose that A is m x m sparse matrix represented by CSR format,\n// Assumption:\n// - handle is already created by cusparseCreate(),\n// - (d_csrRowPtr, d_csrColInd, d_csrVal) is CSR of A on device memory,\n// - d_x is right hand side vector on device memory,\n// - d_y is solution vector on device memory.\n// - d_z is intermediate result on device memory.\ncusparseMatDescr_t\ndescr_M\n=\n0\n;\ncusparseMatDescr_t\ndescr_L\n=\n0\n;\ncusparseMatDescr_t\ndescr_U\n=\n0\n;\ncsrilu02Info_t\ninfo_M\n=\n0\n;\ncsrsv2Info_t\ninfo_L\n=\n0\n;\ncsrsv2Info_t\ninfo_U\n=\n0\n;\nint\npBufferSize_M\n;\nint\npBufferSize_L\n;\nint\npBufferSize_U\n;\nint\npBufferSize\n;\nvoid\n*\npBuffer\n=\n0\n;\nint\nstructural_zero\n;\nint\nnumerical_zero\n;\nconst\ndouble\nalpha\n=\n1.\n;\nconst\ncusparseSolvePolicy_t\npolicy_M\n=\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n;\nconst\ncusparseSolvePolicy_t\npolicy_L\n=\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n;\nconst\ncusparseSolvePolicy_t\npolicy_U\n=\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n;\nconst\ncusparseOperation_t\ntrans_L\n=\nCUSPARSE_OPERATION_NON_TRANSPOSE\n;\nconst\ncusparseOperation_t\ntrans_U\n=\nCUSPARSE_OPERATION_NON_TRANSPOSE\n;\n// step 1: create a descriptor which contains\n// - matrix M is base-1\n// - matrix L is base-1\n// - matrix L is lower triangular\n// - matrix L has unit diagonal\n// - matrix U is base-1\n// - matrix U is upper triangular\n// - matrix U has non-unit diagonal\ncusparseCreateMatDescr\n(\n&\ndescr_M\n);\ncusparseSetMatIndexBase\n(\ndescr_M\n,\nCUSPARSE_INDEX_BASE_ONE\n);\ncusparseSetMatType\n(\ndescr_M\n,\nCUSPARSE_MATRIX_TYPE_GENERAL\n);\ncusparseCreateMatDescr\n(\n&\ndescr_L\n);\ncusparseSetMatIndexBase\n(\ndescr_L\n,\nCUSPARSE_INDEX_BASE_ONE\n);\ncusparseSetMatType\n(\ndescr_L\n,\nCUSPARSE_MATRIX_TYPE_GENERAL\n);\ncusparseSetMatFillMode\n(\ndescr_L\n,\nCUSPARSE_FILL_MODE_LOWER\n);\ncusparseSetMatDiagType\n(\ndescr_L\n,\nCUSPARSE_DIAG_TYPE_UNIT\n);\ncusparseCreateMatDescr\n(\n&\ndescr_U\n);\ncusparseSetMatIndexBase\n(\ndescr_U\n,\nCUSPARSE_INDEX_BASE_ONE\n);\ncusparseSetMatType\n(\ndescr_U\n,\nCUSPARSE_MATRIX_TYPE_GENERAL\n);\ncusparseSetMatFillMode\n(\ndescr_U\n,\nCUSPARSE_FILL_MODE_UPPER\n);\ncusparseSetMatDiagType\n(\ndescr_U\n,\nCUSPARSE_DIAG_TYPE_NON_UNIT\n);\n// step 2: create a empty info structure\n// we need one info for csrilu02 and two info's for csrsv2\ncusparseCreateCsrilu02Info\n(\n&\ninfo_M\n);\ncusparseCreateCsrsv2Info\n(\n&\ninfo_L\n);\ncusparseCreateCsrsv2Info\n(\n&\ninfo_U\n);\n// step 3: query how much memory used in csrilu02 and csrsv2, and allocate the buffer\ncusparseDcsrilu02_bufferSize\n(\nhandle\n,\nm\n,\nnnz\n,\ndescr_M\n,\nd_csrVal\n,\nd_csrRowPtr\n,\nd_csrColInd\n,\ninfo_M\n,\n&\npBufferSize_M\n);\ncusparseDcsrsv2_bufferSize\n(\nhandle\n,\ntrans_L\n,\nm\n,\nnnz\n,\ndescr_L\n,\nd_csrVal\n,\nd_csrRowPtr\n,\nd_csrColInd\n,\ninfo_L\n,\n&\npBufferSize_L\n);\ncusparseDcsrsv2_bufferSize\n(\nhandle\n,\ntrans_U\n,\nm\n,\nnnz\n,\ndescr_U\n,\nd_csrVal\n,\nd_csrRowPtr\n,\nd_csrColInd\n,\ninfo_U\n,\n&\npBufferSize_U\n);\npBufferSize\n=\nmax\n(\npBufferSize_M\n,\nmax\n(\npBufferSize_L\n,\npBufferSize_U\n));\n// pBuffer returned by cudaMalloc is automatically aligned to 128 bytes.\ncudaMalloc\n((\nvoid\n**\n)\n&\npBuffer\n,\npBufferSize\n);\n// step 4: perform analysis of incomplete Cholesky on M\n//         perform analysis of triangular solve on L\n//         perform analysis of triangular solve on U\n// The lower(upper) triangular part of M has the same sparsity pattern as L(U),\n// we can do analysis of csrilu0 and csrsv2 simultaneously.\ncusparseDcsrilu02_analysis\n(\nhandle\n,\nm\n,\nnnz\n,\ndescr_M\n,\nd_csrVal\n,\nd_csrRowPtr\n,\nd_csrColInd\n,\ninfo_M\n,\npolicy_M\n,\npBuffer\n);\nstatus\n=\ncusparseXcsrilu02_zeroPivot\n(\nhandle\n,\ninfo_M\n,\n&\nstructural_zero\n);\nif\n(\nCUSPARSE_STATUS_ZERO_PIVOT\n==\nstatus\n){\nprintf\n(\n\"A(%d,%d) is missing\n\\n\n\"\n,\nstructural_zero\n,\nstructural_zero\n);\n}\ncusparseDcsrsv2_analysis\n(\nhandle\n,\ntrans_L\n,\nm\n,\nnnz\n,\ndescr_L\n,\nd_csrVal\n,\nd_csrRowPtr\n,\nd_csrColInd\n,\ninfo_L\n,\npolicy_L\n,\npBuffer\n);\ncusparseDcsrsv2_analysis\n(\nhandle\n,\ntrans_U\n,\nm\n,\nnnz\n,\ndescr_U\n,\nd_csrVal\n,\nd_csrRowPtr\n,\nd_csrColInd\n,\ninfo_U\n,\npolicy_U\n,\npBuffer\n);\n// step 5: M = L * U\ncusparseDcsrilu02\n(\nhandle\n,\nm\n,\nnnz\n,\ndescr_M\n,\nd_csrVal\n,\nd_csrRowPtr\n,\nd_csrColInd\n,\ninfo_M\n,\npolicy_M\n,\npBuffer\n);\nstatus\n=\ncusparseXcsrilu02_zeroPivot\n(\nhandle\n,\ninfo_M\n,\n&\nnumerical_zero\n);\nif\n(\nCUSPARSE_STATUS_ZERO_PIVOT\n==\nstatus\n){\nprintf\n(\n\"U(%d,%d) is zero\n\\n\n\"\n,\nnumerical_zero\n,\nnumerical_zero\n);\n}\n// step 6: solve L*z = x\ncusparseDcsrsv2_solve\n(\nhandle\n,\ntrans_L\n,\nm\n,\nnnz\n,\n&\nalpha\n,\ndescr_L\n,\n// replace with cusparseSpSV\nd_csrVal\n,\nd_csrRowPtr\n,\nd_csrColInd\n,\ninfo_L\n,\nd_x\n,\nd_z\n,\npolicy_L\n,\npBuffer\n);\n// step 7: solve U*y = z\ncusparseDcsrsv2_solve\n(\nhandle\n,\ntrans_U\n,\nm\n,\nnnz\n,\n&\nalpha\n,\ndescr_U\n,\n// replace with cusparseSpSV\nd_csrVal\n,\nd_csrRowPtr\n,\nd_csrColInd\n,\ninfo_U\n,\nd_z\n,\nd_y\n,\npolicy_U\n,\npBuffer\n);\n// step 6: free resources\ncudaFree\n(\npBuffer\n);\ncusparseDestroyMatDescr\n(\ndescr_M\n);\ncusparseDestroyMatDescr\n(\ndescr_L\n);\ncusparseDestroyMatDescr\n(\ndescr_U\n);\ncusparseDestroyCsrilu02Info\n(\ninfo_M\n);\ncusparseDestroyCsrsv2Info\n(\ninfo_L\n);\ncusparseDestroyCsrsv2Info\n(\ninfo_U\n);\ncusparseDestroy\n(\nhandle\n);\nThe function supports the following properties if\npBuffer\n!=\nNULL\n:\nThe routine requires no extra storage\nThe routine supports asynchronous execution\nThe routine supports CUDA graph capture\nInput\nhandle\nhandle to the cuSPARSE library context.\nm\nnumber of rows and columns of matrix\nA\n.\nnnz\nnumber of nonzeros of matrix\nA\n.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrValA_valM\n<type> array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\nnonzero elements of matrix\nA\n.\ncsrRowPtrA\ninteger array of\nm\n\\(+ 1\\)\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndA\ninteger array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero elements of matrix\nA\n.\ninfo\nstructure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).\npolicy\nthe supported policies are\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\nand\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n.\npBuffer\nbuffer allocated by the user; the size is returned by\ncsrilu02_bufferSize()\n.\nOutput\ncsrValA_valM\n<type> matrix containing the incomplete-LU lower and upper triangular factors.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.2.5.\ncusparseXcsrilu02_zeroPivot() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseXcsrilu02_zeroPivot\n(\ncusparseHandle_t\nhandle\n,\ncsrilu02Info_t\ninfo\n,\nint\n*\nposition\n)\nIf the returned error code is\nCUSPARSE_STATUS_ZERO_PIVOT\n,\nposition=j\nmeans\nA(j,j)\nhas either a structural zero or a numerical zero; otherwise,\nposition=-1\n.\nThe\nposition\ncan be 0-based or 1-based, the same as the matrix.\nFunction\ncusparseXcsrilu02_zeroPivot()\nis a blocking call. It calls\ncudaDeviceSynchronize(\n) to make sure all previous kernels are done.\nThe\nposition\ncan be in the host memory or device memory. The user can set proper mode with\ncusparseSetPointerMode()\n.\nThe routine requires no extra storage\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available\nInput\nhandle\nHandle to the cuSPARSE library context.\ninfo\ninfo\ncontains structural zero or numerical zero if the user already called\ncsrilu02_analysis()\nor\ncsrilu02()\n.\nOutput\nposition\nIf no structural or numerical zero,\nposition\nis -1; otherwise if\nA(j,j)\nis missing or\nU(j,j)\nis zero,\nposition=j\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.2.6.\ncusparse<t>bsrilu02_numericBoost() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseSbsrilu02_numericBoost\n(\ncusparseHandle_t\nhandle\n,\nbsrilu02Info_t\ninfo\n,\nint\nenable_boost\n,\ndouble\n*\ntol\n,\nfloat\n*\nboost_val\n)\ncusparseStatus_t\ncusparseDbsrilu02_numericBoost\n(\ncusparseHandle_t\nhandle\n,\nbsrilu02Info_t\ninfo\n,\nint\nenable_boost\n,\ndouble\n*\ntol\n,\ndouble\n*\nboost_val\n)\ncusparseStatus_t\ncusparseCbsrilu02_numericBoost\n(\ncusparseHandle_t\nhandle\n,\nbsrilu02Info_t\ninfo\n,\nint\nenable_boost\n,\ndouble\n*\ntol\n,\ncuComplex\n*\nboost_val\n)\ncusparseStatus_t\ncusparseZbsrilu02_numericBoost\n(\ncusparseHandle_t\nhandle\n,\nbsrilu02Info_t\ninfo\n,\nint\nenable_boost\n,\ndouble\n*\ntol\n,\ncuDoubleComplex\n*\nboost_val\n)\nThe user can use a boost value to replace a numerical value in incomplete LU factorization. Parameter\ntol\nis used to determine a numerical zero, and\nboost_val\nis used to replace a numerical zero. The behavior is as follows:\nif\ntol\n>=\nfabs(A(j,j))\n, then reset each diagonal element of block\nA(j,j)\nby\nboost_val\n.\nTo enable a boost value, the user sets parameter\nenable_boost\nto 1 before calling\nbsrilu02()\n. To disable the boost value, the user can call\nbsrilu02_numericBoost()\nwith parameter\nenable_boost=0\n.\nIf\nenable_boost=0\n,\ntol\nand\nboost_val\nare ignored.\nBoth\ntol\nand\nboost_val\ncan be in host memory or device memory. The user can set the proper mode with\ncusparseSetPointerMode()\n.\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nhandle\nhandle to the cuSPARSE library context.\ninfo\nstructure initialized using\ncusparseCreateBsrilu02Info()\n.\nenable_boost\ndisable boost by setting\nenable_boost=0\n. Otherwise, boost is enabled.\ntol\ntolerance to determine a numerical zero.\nboost_val\nboost value to replace a numerical zero.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.2.7.\ncusparse<t>bsrilu02_bufferSize() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseSbsrilu02_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nfloat\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrilu02Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n);\ncusparseStatus_t\ncusparseDbsrilu02_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ndouble\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrilu02Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n);\ncusparseStatus_t\ncusparseCbsrilu02_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrilu02Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n);\ncusparseStatus_t\ncusparseZbsrilu02_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuDoubleComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrilu02Info_t\ninfo\n,\nint\n*\npBufferSizeInBytes\n);\nThis function returns the size of the buffer used in computing the incomplete-LU factorization with 0 fill-in and no pivoting.\n\\[A \\approx LU\\]\nA\nis an\n(mb*blockDim)x(mb*blockDim)\nsparse matrix that is defined in BSR storage format by the three arrays\nbsrValA\n,\nbsrRowPtrA\n, and\nbsrColIndA\n.\nThe buffer size depends on the dimensions of\nmb\n,\nblockDim\n, and the number of nonzero blocks of the matrix\nnnzb\n. If the user changes the matrix, it is necessary to call\nbsrilu02_bufferSize()\nagain to have the correct buffer size; otherwise, a segmentation fault may occur.\nInput\nhandle\nhandle to the cuSPARSE library context.\ndirA\nstorage format of blocks, either\nCUSPARSE_DIRECTION_ROW\nor\nCUSPARSE_DIRECTION_COLUMN\n.\nmb\nnumber of block rows and columns of matrix\nA\n.\nnnzb\nnumber of nonzero blocks of matrix\nA\n.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\nbsrValA\n<type> array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\nnonzero blocks of matrix\nA\n.\nbsrRowPtrA\ninteger array of\nmb\n\\(+ 1\\)\nelements that contains the start of every block row and the end of the last block row plus one.\nbsrColIndA\ninteger array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero blocks of matrix\nA\n.\nblockDim\nblock dimension of sparse matrix A, larger than zero.\nOutput\ninfo\nrecord internal states based on different algorithms.\npBufferSizeInBytes\nnumber of bytes of the buffer used in\nbsrilu02_analysis()\nand\nbsrilu02()\n.\nStatus Returned\nCUSPARSE_STATUS_SUCCESS\nthe operation completed successfully.\nCUSPARSE_STATUS_NOT_INITIALIZED\nthe library was not initialized.\nCUSPARSE_STATUS_ALLOC_FAILED\nthe resources could not be allocated.\nCUSPARSE_STATUS_INVALID_VALUE\ninvalid parameters were passed (\nmb,nnzb<=0\n), base index is not 0 or 1.\nCUSPARSE_STATUS_ARCH_MISMATCH\nthe device only supports compute capability 2.0 and above.\nCUSPARSE_STATUS_INTERNAL_ERROR\nan internal operation failed.\nCUSPARSE_STATUS_MATRIX_TYPE_NOT_SUPPORTED\nthe matrix type is not supported.\n5.7.2.8.\ncusparse<t>bsrilu02_analysis() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseSbsrilu02_analysis\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nfloat\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrilu02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDbsrilu02_analysis\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ndouble\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrilu02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseCbsrilu02_analysis\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrilu02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZbsrilu02_analysis\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuDoubleComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrilu02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\nThis function performs the analysis phase of the incomplete-LU factorization with 0 fill-in and no pivoting.\n\\(A \\approx LU\\)\nA\nis an\n(mb*blockDim)×(mb*blockDim)\nsparse matrix that is defined in BSR storage format by the three arrays\nbsrValA\n,\nbsrRowPtrA\n, and\nbsrColIndA\n. The block in BSR format is of size\nblockDim*blockDim\n, stored as column-major or row-major as determined by parameter\ndirA\n, which is either\nCUSPARSE_DIRECTION_COLUMN\nor\nCUSPARSE_DIRECTION_ROW\n. The matrix type must be\nCUSPARSE_MATRIX_TYPE_GENERAL\n, and the fill mode and diagonal type are ignored.\nThis function requires a buffer size returned by\nbsrilu02_bufferSize()\n. The address of\npBuffer\nmust be multiple of 128 bytes. If it is not,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nFunction\nbsrilu02_analysis()\nreports a structural zero and computes level information stored in the opaque structure\ninfo\n. The level information can extract more parallelism during incomplete LU factorization. However\nbsrilu02()\ncan be done without level information. To disable level information, the user needs to specify the parameter\npolicy\nof\nbsrilu02[_analysis|\n]\nas\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n.\nFunction\nbsrilu02_analysis()\nalways reports the first structural zero, even with parameter\npolicy\nis\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n. The user must call\ncusparseXbsrilu02_zeroPivot()\nto know where the structural zero is.\nIt is the user’s choice whether to call\nbsrilu02()\nif\nbsrilu02_analysis()\nreports a structural zero. In this case, the user can still call\nbsrilu02()\n, which will return a numerical zero at the same position as the structural zero. However the result is meaningless.\nThis function requires temporary extra storage that is allocated internally.\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available.\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available.\nInput\nhandle\nhandle to the cuSPARSE library context.\ndirA\nstorage format of blocks, either\nCUSPARSE_DIRECTION_ROW\nor\nCUSPARSE_DIRECTION_COLUMN\n.\nmb\nnumber of block rows and block columns of matrix\nA\n.\nnnzb\nnumber of nonzero blocks of matrix\nA\n.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\nbsrValA\n<type> array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\nnonzero blocks of matrix\nA\n.\nbsrRowPtrA\ninteger array of\nmb\n\\(+ 1\\)\nelements that contains the start of every block row and the end of the last block row plus one.\nbsrColIndA\ninteger array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero blocks of matrix\nA\n.\nblockDim\nblock dimension of sparse matrix A, larger than zero.\ninfo\nstructure initialized using\ncusparseCreateBsrilu02Info()\n.\npolicy\nthe supported policies are\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\nand\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n.\npBuffer\nbuffer allocated by the user, the size is returned by\nbsrilu02_bufferSize()\n.\nOutput\ninfo\nstructure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged)\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.2.9.\ncusparse<t>bsrilu02() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseSbsrilu02\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescry\n,\nfloat\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrilu02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDbsrilu02\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescry\n,\ndouble\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrilu02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseCbsrilu02\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescry\n,\ncuComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrilu02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZbsrilu02\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nmb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescry\n,\ncuDoubleComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nbsrilu02Info_t\ninfo\n,\ncusparseSolvePolicy_t\npolicy\n,\nvoid\n*\npBuffer\n)\nThis function performs the solve phase of the incomplete-LU factorization with 0 fill-in and no pivoting.\n\\[A \\approx LU\\]\nA\nis an\n(mb*blockDim)×(mb*blockDim)\nsparse matrix that is defined in BSR storage format by the three arrays\nbsrValA\n,\nbsrRowPtrA\n, and\nbsrColIndA\n. The block in BSR format is of size\nblockDim*blockDim\n, stored as column-major or row-major determined by parameter\ndirA\n, which is either\nCUSPARSE_DIRECTION_COLUMN\nor\nCUSPARSE_DIRECTION_ROW\n. The matrix type must be\nCUSPARSE_MATRIX_TYPE_GENERAL\n, and the fill mode and diagonal type are ignored. Function\nbsrilu02()\nsupports an arbitrary\nblockDim\n.\nThis function requires a buffer size returned by\nbsrilu02_bufferSize()\n. The address of\npBuffer\nmust be a multiple of 128 bytes. If it is not,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nAlthough\nbsrilu02()\ncan be used without level information, the user must be aware of consistency. If\nbsrilu02_analysis()\nis called with policy\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n,\nbsrilu02()\ncan be run with or without levels. On the other hand, if\nbsrilu02_analysis()\nis called with\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n,\nbsrilu02()\ncan only accept\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n; otherwise,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nFunction\nbsrilu02()\nhas the same behavior as\ncsrilu02()\n. That is,\nbsr2csr(bsrilu02(A))\n=\ncsrilu02(bsr2csr(A))\n. The numerical zero of\ncsrilu02()\nmeans there exists some zero\nU(j,j)\n. The numerical zero of\nbsrilu02()\nmeans there exists some block\nU(j,j)\nthat is not invertible.\nFunction\nbsrilu02\nreports the first numerical zero, including a structural zero. The user must call\ncusparseXbsrilu02_zeroPivot()\nto know where the numerical zero is.\nFor example, suppose\nA\nis a real m-by-m matrix where\nm=mb*blockDim\n. The following code solves precondition system\nM*y\n=\nx\n, where\nM\nis the product of LU factors\nL\nand\nU\n.\n// Suppose that A is m x m sparse matrix represented by BSR format,\n// The number of block rows/columns is mb, and\n// the number of nonzero blocks is nnzb.\n// Assumption:\n// - handle is already created by cusparseCreate(),\n// - (d_bsrRowPtr, d_bsrColInd, d_bsrVal) is BSR of A on device memory,\n// - d_x is right hand side vector on device memory.\n// - d_y is solution vector on device memory.\n// - d_z is intermediate result on device memory.\n// - d_x, d_y and d_z are of size m.\ncusparseMatDescr_t\ndescr_M\n=\n0\n;\ncusparseMatDescr_t\ndescr_L\n=\n0\n;\ncusparseMatDescr_t\ndescr_U\n=\n0\n;\nbsrilu02Info_t\ninfo_M\n=\n0\n;\nbsrsv2Info_t\ninfo_L\n=\n0\n;\nbsrsv2Info_t\ninfo_U\n=\n0\n;\nint\npBufferSize_M\n;\nint\npBufferSize_L\n;\nint\npBufferSize_U\n;\nint\npBufferSize\n;\nvoid\n*\npBuffer\n=\n0\n;\nint\nstructural_zero\n;\nint\nnumerical_zero\n;\nconst\ndouble\nalpha\n=\n1.\n;\nconst\ncusparseSolvePolicy_t\npolicy_M\n=\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n;\nconst\ncusparseSolvePolicy_t\npolicy_L\n=\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\n;\nconst\ncusparseSolvePolicy_t\npolicy_U\n=\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n;\nconst\ncusparseOperation_t\ntrans_L\n=\nCUSPARSE_OPERATION_NON_TRANSPOSE\n;\nconst\ncusparseOperation_t\ntrans_U\n=\nCUSPARSE_OPERATION_NON_TRANSPOSE\n;\nconst\ncusparseDirection_t\ndir\n=\nCUSPARSE_DIRECTION_COLUMN\n;\n// step 1: create a descriptor which contains\n// - matrix M is base-1\n// - matrix L is base-1\n// - matrix L is lower triangular\n// - matrix L has unit diagonal\n// - matrix U is base-1\n// - matrix U is upper triangular\n// - matrix U has non-unit diagonal\ncusparseCreateMatDescr\n(\n&\ndescr_M\n);\ncusparseSetMatIndexBase\n(\ndescr_M\n,\nCUSPARSE_INDEX_BASE_ONE\n);\ncusparseSetMatType\n(\ndescr_M\n,\nCUSPARSE_MATRIX_TYPE_GENERAL\n);\ncusparseCreateMatDescr\n(\n&\ndescr_L\n);\ncusparseSetMatIndexBase\n(\ndescr_L\n,\nCUSPARSE_INDEX_BASE_ONE\n);\ncusparseSetMatType\n(\ndescr_L\n,\nCUSPARSE_MATRIX_TYPE_GENERAL\n);\ncusparseSetMatFillMode\n(\ndescr_L\n,\nCUSPARSE_FILL_MODE_LOWER\n);\ncusparseSetMatDiagType\n(\ndescr_L\n,\nCUSPARSE_DIAG_TYPE_UNIT\n);\ncusparseCreateMatDescr\n(\n&\ndescr_U\n);\ncusparseSetMatIndexBase\n(\ndescr_U\n,\nCUSPARSE_INDEX_BASE_ONE\n);\ncusparseSetMatType\n(\ndescr_U\n,\nCUSPARSE_MATRIX_TYPE_GENERAL\n);\ncusparseSetMatFillMode\n(\ndescr_U\n,\nCUSPARSE_FILL_MODE_UPPER\n);\ncusparseSetMatDiagType\n(\ndescr_U\n,\nCUSPARSE_DIAG_TYPE_NON_UNIT\n);\n// step 2: create a empty info structure\n// we need one info for bsrilu02 and two info's for bsrsv2\ncusparseCreateBsrilu02Info\n(\n&\ninfo_M\n);\ncusparseCreateBsrsv2Info\n(\n&\ninfo_L\n);\ncusparseCreateBsrsv2Info\n(\n&\ninfo_U\n);\n// step 3: query how much memory used in bsrilu02 and bsrsv2, and allocate the buffer\ncusparseDbsrilu02_bufferSize\n(\nhandle\n,\ndir\n,\nmb\n,\nnnzb\n,\ndescr_M\n,\nd_bsrVal\n,\nd_bsrRowPtr\n,\nd_bsrColInd\n,\nblockDim\n,\ninfo_M\n,\n&\npBufferSize_M\n);\ncusparseDbsrsv2_bufferSize\n(\nhandle\n,\ndir\n,\ntrans_L\n,\nmb\n,\nnnzb\n,\ndescr_L\n,\nd_bsrVal\n,\nd_bsrRowPtr\n,\nd_bsrColInd\n,\nblockDim\n,\ninfo_L\n,\n&\npBufferSize_L\n);\ncusparseDbsrsv2_bufferSize\n(\nhandle\n,\ndir\n,\ntrans_U\n,\nmb\n,\nnnzb\n,\ndescr_U\n,\nd_bsrVal\n,\nd_bsrRowPtr\n,\nd_bsrColInd\n,\nblockDim\n,\ninfo_U\n,\n&\npBufferSize_U\n);\npBufferSize\n=\nmax\n(\npBufferSize_M\n,\nmax\n(\npBufferSize_L\n,\npBufferSize_U\n));\n// pBuffer returned by cudaMalloc is automatically aligned to 128 bytes.\ncudaMalloc\n((\nvoid\n**\n)\n&\npBuffer\n,\npBufferSize\n);\n// step 4: perform analysis of incomplete LU factorization on M\n//         perform analysis of triangular solve on L\n//         perform analysis of triangular solve on U\n// The lower(upper) triangular part of M has the same sparsity pattern as L(U),\n// we can do analysis of bsrilu0 and bsrsv2 simultaneously.\ncusparseDbsrilu02_analysis\n(\nhandle\n,\ndir\n,\nmb\n,\nnnzb\n,\ndescr_M\n,\nd_bsrVal\n,\nd_bsrRowPtr\n,\nd_bsrColInd\n,\nblockDim\n,\ninfo_M\n,\npolicy_M\n,\npBuffer\n);\nstatus\n=\ncusparseXbsrilu02_zeroPivot\n(\nhandle\n,\ninfo_M\n,\n&\nstructural_zero\n);\nif\n(\nCUSPARSE_STATUS_ZERO_PIVOT\n==\nstatuss\n){\nprintf\n(\n\"A(%d,%d) is missing\n\\n\n\"\n,\nstructural_zero\n,\nstructural_zero\n);\n}\ncusparseDbsrsv2_analysis\n(\nhandle\n,\ndir\n,\ntrans_L\n,\nmb\n,\nnnzb\n,\ndescr_L\n,\nd_bsrVal\n,\nd_bsrRowPtr\n,\nd_bsrColInd\n,\nblockDim\n,\ninfo_L\n,\npolicy_L\n,\npBuffer\n);\ncusparseDbsrsv2_analysis\n(\nhandle\n,\ndir\n,\ntrans_U\n,\nmb\n,\nnnzb\n,\ndescr_U\n,\nd_bsrVal\n,\nd_bsrRowPtr\n,\nd_bsrColInd\n,\nblockDim\n,\ninfo_U\n,\npolicy_U\n,\npBuffer\n);\n// step 5: M = L * U\ncusparseDbsrilu02\n(\nhandle\n,\ndir\n,\nmb\n,\nnnzb\n,\ndescr_M\n,\nd_bsrVal\n,\nd_bsrRowPtr\n,\nd_bsrColInd\n,\nblockDim\n,\ninfo_M\n,\npolicy_M\n,\npBuffer\n);\nstatus\n=\ncusparseXbsrilu02_zeroPivot\n(\nhandle\n,\ninfo_M\n,\n&\nnumerical_zero\n);\nif\n(\nCUSPARSE_STATUS_ZERO_PIVOT\n==\nstatuss\n){\nprintf\n(\n\"block U(%d,%d) is not invertible\n\\n\n\"\n,\nnumerical_zero\n,\nnumerical_zero\n);\n}\n// step 6: solve L*z = x\ncusparseDbsrsv2_solve\n(\nhandle\n,\ndir\n,\ntrans_L\n,\nmb\n,\nnnzb\n,\n&\nalpha\n,\ndescr_L\n,\nd_bsrVal\n,\nd_bsrRowPtr\n,\nd_bsrColInd\n,\nblockDim\n,\ninfo_L\n,\nd_x\n,\nd_z\n,\npolicy_L\n,\npBuffer\n);\n// step 7: solve U*y = z\ncusparseDbsrsv2_solve\n(\nhandle\n,\ndir\n,\ntrans_U\n,\nmb\n,\nnnzb\n,\n&\nalpha\n,\ndescr_U\n,\nd_bsrVal\n,\nd_bsrRowPtr\n,\nd_bsrColInd\n,\nblockDim\n,\ninfo_U\n,\nd_z\n,\nd_y\n,\npolicy_U\n,\npBuffer\n);\n// step 6: free resources\ncudaFree\n(\npBuffer\n);\ncusparseDestroyMatDescr\n(\ndescr_M\n);\ncusparseDestroyMatDescr\n(\ndescr_L\n);\ncusparseDestroyMatDescr\n(\ndescr_U\n);\ncusparseDestroyBsrilu02Info\n(\ninfo_M\n);\ncusparseDestroyBsrsv2Info\n(\ninfo_L\n);\ncusparseDestroyBsrsv2Info\n(\ninfo_U\n);\ncusparseDestroy\n(\nhandle\n);\nThe function supports the following properties if\npBuffer\n!=\nNULL\n:\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nhandle\nhandle to the cuSPARSE library context.\ndirA\nstorage format of blocks: either\nCUSPARSE_DIRECTION_ROW\nor\nCUSPARSE_DIRECTION_COLUMN\n.\nmb\nnumber of block rows and block columns of matrix\nA\n.\nnnzb\nnumber of nonzero blocks of matrix\nA\n.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\nbsrValA\n<type> array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\nnonzero blocks of matrix\nA\n.\nbsrRowPtrA\ninteger array of\nmb\n\\(+ 1\\)\nelements that contains the start of every block row and the end of the last block row plus one.\nbsrColIndA\ninteger array of\nnnzb\n\\(( =\\)\nbsrRowPtrA(mb)\n\\(-\\)\nbsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero blocks of matrix\nA\n.\nblockDim\nblock dimension of sparse matrix A; must be larger than zero.\ninfo\nstructure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).\npolicy\nthe supported policies are\nCUSPARSE_SOLVE_POLICY_NO_LEVEL\nand\nCUSPARSE_SOLVE_POLICY_USE_LEVEL\n.\npBuffer\nbuffer allocated by the user; the size is returned by\nbsrilu02_bufferSize()\n.\nOutput\nbsrValA\n<type> matrix containing the incomplete-LU lower and upper triangular factors\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.2.10.\ncusparseXbsrilu02_zeroPivot() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseXbsrilu02_zeroPivot\n(\ncusparseHandle_t\nhandle\n,\nbsrilu02Info_t\ninfo\n,\nint\n*\nposition\n)\nIf the returned error code is\nCUSPARSE_STATUS_ZERO_PIVOT\n,\nposition=j\nmeans\nA(j,j)\nhas either a structural zero or a numerical zero (the block is not invertible). Otherwise\nposition=-1\n.\nThe\nposition\ncan be 0-based or 1-based, the same as the matrix.\nFunction\ncusparseXbsrilu02_zeroPivot()\nis a blocking call. It calls\ncudaDeviceSynchronize()\nto make sure all previous kernels are done.\nThe\nposition\ncan be in the host memory or device memory. The user can set proper the mode with\ncusparseSetPointerMode()\n.\nThe routine requires no extra storage.\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available.\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available.\nInput\nhandle\nhandle to the cuSPARSE library context.\ninfo\ninfo\ncontains structural zero or numerical zero if the user already called\nbsrilu02_analysis()\nor\nbsrilu02()\n.\nOutput\nposition\nif no structural or numerical zero,\nposition\nis -1; otherwise if\nA(j,j)\nis missing or\nU(j,j)\nis not invertible,\nposition=j\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.3.\nTridiagonal Solve\n\nDifferent algorithms for tridiagonal solve are discussed in this section.\n5.7.3.1.\ncusparse<t>gtsv2_buffSizeExt()\n\ncusparseStatus_t\ncusparseSgtsv2_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\ndl\n,\nconst\nfloat\n*\nd\n,\nconst\nfloat\n*\ndu\n,\nconst\nfloat\n*\nB\n,\nint\nldb\n,\nsize_t\n*\nbufferSizeInBytes\n)\ncusparseStatus_t\ncusparseDgtsv2_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\ndl\n,\nconst\ndouble\n*\nd\n,\nconst\ndouble\n*\ndu\n,\nconst\ndouble\n*\nB\n,\nint\nldb\n,\nsize_t\n*\nbufferSizeInBytes\n)\ncusparseStatus_t\ncusparseCgtsv2_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\ndl\n,\nconst\ncuComplex\n*\nd\n,\nconst\ncuComplex\n*\ndu\n,\nconst\ncuComplex\n*\nB\n,\nint\nldb\n,\nsize_t\n*\nbufferSizeInBytes\n)\ncusparseStatus_t\ncusparseZgtsv2_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\ndl\n,\nconst\ncuDoubleComplex\n*\nd\n,\nconst\ncuDoubleComplex\n*\ndu\n,\nconst\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\nsize_t\n*\nbufferSizeInBytes\n)\nThis function returns the size of the buffer used in\ngtsv2\nwhich computes the solution of a tridiagonal linear system with multiple right-hand sides.\n\\[A \\ast X = B\\]\nThe coefficient matrix\nA\nof each of these tri-diagonal linear system is defined with three vectors corresponding to its lower (\ndl\n), main (\nd\n), and upper (\ndu\n) matrix diagonals; the right-hand sides are stored in the dense matrix\nB\n. Notice that solution\nX\noverwrites right-hand-side matrix\nB\non exit.\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nhandle\nhandle to the cuSPARSE library context.\nm\nthe size of the linear system (must be ≥ 3).\nn\nnumber of right-hand sides, columns of matrix\nB\n.\ndl\n<type> dense array containing the lower diagonal of the tri-diagonal linear system. The first element of each lower diagonal must be zero.\nd\n<type> dense array containing the main diagonal of the tri-diagonal linear system.\ndu\n<type> dense array containing the upper diagonal of the tri-diagonal linear system. The last element of each upper diagonal must be zero.\nB\n<type> dense right-hand-side array of dimensions\n(ldb,\nn)\n.\nldb\nleading dimension of\nB\n(that is ≥\n\\(\\max\\text{(1,\\ m))}\\)\n.\nOutput\npBufferSizeInBytes\nnumber of bytes of the buffer used in the\ngtsv2\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.3.2.\ncusparse<t>gtsv2()\n\ncusparseStatus_t\ncusparseSgtsv2\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\ndl\n,\nconst\nfloat\n*\nd\n,\nconst\nfloat\n*\ndu\n,\nfloat\n*\nB\n,\nint\nldb\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDgtsv2\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\ndl\n,\nconst\ndouble\n*\nd\n,\nconst\ndouble\n*\ndu\n,\ndouble\n*\nB\n,\nint\nldb\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseCgtsv2\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\ndl\n,\nconst\ncuComplex\n*\nd\n,\nconst\ncuComplex\n*\ndu\n,\ncuComplex\n*\nB\n,\nint\nldb\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZgtsv2\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\ndl\n,\nconst\ncuDoubleComplex\n*\nd\n,\nconst\ncuDoubleComplex\n*\ndu\n,\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\nvoid\n*\npBuffer\n)\nThis function computes the solution of a tridiagonal linear system with multiple right-hand sides:\n\\[A \\ast X = B\\]\nThe coefficient matrix\nA\nof each of these tri-diagonal linear system is defined with three vectors corresponding to its lower (\ndl\n), main (\nd\n), and upper (\ndu\n) matrix diagonals; the right-hand sides are stored in the dense matrix\nB\n. Notice that solution\nX\noverwrites right-hand-side matrix\nB\non exit.\nAssuming\nA\nis of size\nm\nand base-1,\ndl\n,\nd\nand\ndu\nare defined by the following formula:\ndl(i)\n:=\nA(i,\ni-1)\nfor\ni=1,2,...,m\nThe first element of dl is out-of-bound (\ndl(1)\n:=\nA(1,0)\n), so\ndl(1)\n=\n0\n.\nd(i)\n=\nA(i,i)\nfor\ni=1,2,...,m\ndu(i)\n=\nA(i,i+1)\nfor\ni=1,2,...,m\nThe last element of du is out-of-bound (\ndu(m)\n:=\nA(m,m+1)\n), so\ndu(m)\n=\n0\n.\nThe routine does perform pivoting, which usually results in more accurate and more stable results than\ncusparse<t>gtsv_nopivot()\nor\ncusparse<t>gtsv2_nopivot()\nat the expense of some execution time.\nThis function requires a buffer size returned by\ngtsv2_bufferSizeExt()\n. The address of\npBuffer\nmust be multiple of 128 bytes. If it is not,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nhandle\nhandle to the cuSPARSE library context.\nm\nthe size of the linear system (must be ≥ 3).\nn\nnumber of right-hand sides, columns of matrix\nB\n.\ndl\n<type> dense array containing the lower diagonal of the tri-diagonal linear system. The first element of each lower diagonal must be zero.\nd\n<type> dense array containing the main diagonal of the tri-diagonal linear system.\ndu\n<type> dense array containing the upper diagonal of the tri-diagonal linear system. The last element of each upper diagonal must be zero.\nB\n<type> dense right-hand-side array of dimensions\n(ldb,\nn)\n.\nldb\nleading dimension of\nB\n(that is ≥\n\\(\\max\\text{(1,\\ m))}\\)\n.\npBuffer\nbuffer allocated by the user, the size is return by\ngtsv2_bufferSizeExt\n.\nOutput\nB\n<type> dense solution array of dimensions\n(ldb,\nn)\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.3.3.\ncusparse<t>gtsv2_nopivot_bufferSizeExt()\n\ncusparseStatus_t\ncusparseSgtsv2_nopivot_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\ndl\n,\nconst\nfloat\n*\nd\n,\nconst\nfloat\n*\ndu\n,\nconst\nfloat\n*\nB\n,\nint\nldb\n,\nsize_t\n*\nbufferSizeInBytes\n)\ncusparseStatus_t\ncusparseDgtsv2_nopivot_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\ndl\n,\nconst\ndouble\n*\nd\n,\nconst\ndouble\n*\ndu\n,\nconst\ndouble\n*\nB\n,\nint\nldb\n,\nsize_t\n*\nbufferSizeInBytes\n)\ncusparseStatus_t\ncusparseCgtsv2_nopivot_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\ndl\n,\nconst\ncuComplex\n*\nd\n,\nconst\ncuComplex\n*\ndu\n,\nconst\ncuComplex\n*\nB\n,\nint\nldb\n,\nsize_t\n*\nbufferSizeInBytes\n)\ncusparseStatus_t\ncusparseZgtsv2_nopivot_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\ndl\n,\nconst\ncuDoubleComplex\n*\nd\n,\nconst\ncuDoubleComplex\n*\ndu\n,\nconst\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\nsize_t\n*\nbufferSizeInBytes\n)\nThis function returns the size of the buffer used in\ngtsv2_nopivot\nwhich computes the solution of a tridiagonal linear system with multiple right-hand sides.\n\\[A \\ast X = B\\]\nThe coefficient matrix\nA\nof each of these tri-diagonal linear system is defined with three vectors corresponding to its lower (\ndl\n), main (\nd\n), and upper (\ndu\n) matrix diagonals; the right-hand sides are stored in the dense matrix\nB\n. Notice that solution\nX\noverwrites right-hand-side matrix\nB\non exit.\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nhandle\nhandle to the cuSPARSE library context.\nm\nthe size of the linear system (must be ≥ 3).\nn\nnumber of right-hand sides, columns of matrix\nB\n.\ndl\n<type> dense array containing the lower diagonal of the tri-diagonal linear system. The first element of each lower diagonal must be zero.\nd\n<type> dense array containing the main diagonal of the tri-diagonal linear system.\ndu\n<type> dense array containing the upper diagonal of the tri-diagonal linear system. The last element of each upper diagonal must be zero.\nB\n<type> dense right-hand-side array of dimensions\n(ldb,\nn)\n.\nldb\nleading dimension of\nB\n. (that is ≥\n\\(\\max\\text{(1,\\ m))}\\)\n.\nOutput\npBufferSizeInBytes\nnumber of bytes of the buffer used in the\ngtsv2_nopivot\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.3.4.\ncusparse<t>gtsv2_nopivot()\n\ncusparseStatus_t\ncusparseSgtsv2_nopivot\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\ndl\n,\nconst\nfloat\n*\nd\n,\nconst\nfloat\n*\ndu\n,\nfloat\n*\nB\n,\nint\nldb\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDgtsv2_nopivot\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\ndl\n,\nconst\ndouble\n*\nd\n,\nconst\ndouble\n*\ndu\n,\ndouble\n*\nB\n,\nint\nldb\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseCgtsv2_nopivot\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\ndl\n,\nconst\ncuComplex\n*\nd\n,\nconst\ncuComplex\n*\ndu\n,\ncuComplex\n*\nB\n,\nint\nldb\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZgtsv2_nopivot\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\ndl\n,\nconst\ncuDoubleComplex\n*\nd\n,\nconst\ncuDoubleComplex\n*\ndu\n,\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\nvoid\n*\npBuffer\n)\nThis function computes the solution of a tridiagonal linear system with multiple right-hand sides:\n\\[A \\ast X = B\\]\nThe coefficient matrix\nA\nof each of these tri-diagonal linear system is defined with three vectors corresponding to its lower (\ndl\n), main (\nd\n), and upper (\ndu\n) matrix diagonals; the right-hand sides are stored in the dense matrix\nB\n. Notice that solution\nX\noverwrites right-hand-side matrix\nB\non exit.\nThe routine does not perform any pivoting and uses a combination of the Cyclic Reduction (CR) and the Parallel Cyclic Reduction (PCR) algorithms to find the solution. It achieves better performance when\nm\nis a power of 2.\nThis function requires a buffer size returned by\ngtsv2_nopivot_bufferSizeExt()\n. The address of\npBuffer\nmust be multiple of 128 bytes. If it is not,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nhandle\nhandle to the cuSPARSE library context.\nm\nthe size of the linear system (must be ≥ 3).\nn\nnumber of right-hand sides, columns of matrix\nB\n.\ndl\n<type> dense array containing the lower diagonal of the tri-diagonal linear system. The first element of each lower diagonal must be zero.\nd\n<type> dense array containing the main diagonal of the tri-diagonal linear system.\ndu\n<type> dense array containing the upper diagonal of the tri-diagonal linear system. The last element of each upper diagonal must be zero.\nB\n<type> dense right-hand-side array of dimensions\n(ldb,\nn)\n.\nldb\nleading dimension of\nB\n. (that is ≥\n\\(\\max\\text{(1,\\ m))}\\)\n.\npBuffer\nbuffer allocated by the user, the size is return by\ngtsv2_nopivot_bufferSizeExt\n.\nOutput\nB\n<type> dense solution array of dimensions\n(ldb,\nn)\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.4.\nBatched Tridiagonal Solve\n\nDifferent algorithms for batched tridiagonal solve are discussed in this section.\n5.7.4.1.\ncusparse<t>gtsv2StridedBatch_bufferSizeExt()\n\ncusparseStatus_t\ncusparseSgtsv2StridedBatch_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nconst\nfloat\n*\ndl\n,\nconst\nfloat\n*\nd\n,\nconst\nfloat\n*\ndu\n,\nconst\nfloat\n*\nx\n,\nint\nbatchCount\n,\nint\nbatchStride\n,\nsize_t\n*\nbufferSizeInBytes\n)\ncusparseStatus_t\ncusparseDgtsv2StridedBatch_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nconst\ndouble\n*\ndl\n,\nconst\ndouble\n*\nd\n,\nconst\ndouble\n*\ndu\n,\nconst\ndouble\n*\nx\n,\nint\nbatchCount\n,\nint\nbatchStride\n,\nsize_t\n*\nbufferSizeInBytes\n)\ncusparseStatus_t\ncusparseCgtsv2StridedBatch_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nconst\ncuComplex\n*\ndl\n,\nconst\ncuComplex\n*\nd\n,\nconst\ncuComplex\n*\ndu\n,\nconst\ncuComplex\n*\nx\n,\nint\nbatchCount\n,\nint\nbatchStride\n,\nsize_t\n*\nbufferSizeInBytes\n)\ncusparseStatus_t\ncusparseZgtsv2StridedBatch_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nconst\ncuDoubleComplex\n*\ndl\n,\nconst\ncuDoubleComplex\n*\nd\n,\nconst\ncuDoubleComplex\n*\ndu\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nbatchCount\n,\nint\nbatchStride\n,\nsize_t\n*\nbufferSizeInBytes\n)\nThis function returns the size of the buffer used in\ngtsv2StridedBatch\nwhich computes the solution of multiple tridiagonal linear systems for\ni\n=0,…,\nbatchCount\n:\n\\[A^{(i)} \\ast \\text{y}^{(i)} = \\text{x}^{(i)}\\]\nThe coefficient matrix\nA\nof each of these tri-diagonal linear system is defined with three vectors corresponding to its lower (\ndl\n), main (\nd\n), and upper (\ndu\n) matrix diagonals; the right-hand sides are stored in the dense matrix\nX\n. Notice that solution\nY\noverwrites right-hand-side matrix\nX\non exit. The different matrices are assumed to be of the same size and are stored with a fixed\nbatchStride\nin memory.\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nhandle\nhandle to the cuSPARSE library context.\nm\nthe size of the linear system (must be ≥ 3).\ndl\n<type> dense array containing the lower diagonal of the tri-diagonal linear system. The lower diagonal\n\\(dl^{(i)}\\)\nthat corresponds to the\ni\nth\nlinear system starts at location\ndl+batchStride×i\nin memory. Also, the first element of each lower diagonal must be zero.\nd\n<type> dense array containing the main diagonal of the tri-diagonal linear system. The main diagonal\n\\(d^{(i)}\\)\nthat corresponds to the\ni\nth\nlinear system starts at location\nd+batchStride×i\nin memory.\ndu\n<type> dense array containing the upper diagonal of the tri-diagonal linear system. The upper diagonal\n\\(du^{(i)}\\)\nthat corresponds to the\ni\nth\nlinear system starts at location\ndu+batchStride×i\nin memory. Also, the last element of each upper diagonal must be zero.\nx\n<type> dense array that contains the right-hand-side of the tri-diagonal linear system. The right-hand-side\n\\(x^{(i)}\\)\nthat corresponds to the\ni\nth\nlinear system starts at location\nx+batchStride×i\nin memory.\nbatchCount\nnumber of systems to solve.\nbatchStride\nstride (number of elements) that separates the vectors of every system (must be at least\nm\n).\nOutput\npBufferSizeInBytes\nnumber of bytes of the buffer used in the\ngtsv2StridedBatch\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.4.2.\ncusparse<t>gtsv2StridedBatch()\n\ncusparseStatus_t\ncusparseSgtsv2StridedBatch\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nconst\nfloat\n*\ndl\n,\nconst\nfloat\n*\nd\n,\nconst\nfloat\n*\ndu\n,\nfloat\n*\nx\n,\nint\nbatchCount\n,\nint\nbatchStride\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDgtsv2StridedBatch\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nconst\ndouble\n*\ndl\n,\nconst\ndouble\n*\nd\n,\nconst\ndouble\n*\ndu\n,\ndouble\n*\nx\n,\nint\nbatchCount\n,\nint\nbatchStride\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseCgtsv2StridedBatch\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nconst\ncuComplex\n*\ndl\n,\nconst\ncuComplex\n*\nd\n,\nconst\ncuComplex\n*\ndu\n,\ncuComplex\n*\nx\n,\nint\nbatchCount\n,\nint\nbatchStride\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZgtsv2StridedBatch\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nconst\ncuDoubleComplex\n*\ndl\n,\nconst\ncuDoubleComplex\n*\nd\n,\nconst\ncuDoubleComplex\n*\ndu\n,\ncuDoubleComplex\n*\nx\n,\nint\nbatchCount\n,\nint\nbatchStride\n,\nvoid\n*\npBuffer\n)\nThis function computes the solution of multiple tridiagonal linear systems for\ni\n=0,…,\nbatchCount\n:\n\\[A^{(i)} \\ast \\text{y}^{(i)} = \\text{x}^{(i)}\\]\nThe coefficient matrix\nA\nof each of these tri-diagonal linear system is defined with three vectors corresponding to its lower (\ndl\n), main (\nd\n), and upper (\ndu\n) matrix diagonals; the right-hand sides are stored in the dense matrix\nX\n. Notice that solution\nY\noverwrites right-hand-side matrix\nX\non exit. The different matrices are assumed to be of the same size and are stored with a fixed\nbatchStride\nin memory.\nThe routine does not perform any pivoting and uses a combination of the Cyclic Reduction (CR) and the Parallel Cyclic Reduction (PCR) algorithms to find the solution. It achieves better performance when\nm\nis a power of 2.\nThis function requires a buffer size returned by\ngtsv2StridedBatch_bufferSizeExt()\n. The address of\npBuffer\nmust be multiple of 128 bytes. If it is not,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nhandle\nhandle to the cuSPARSE library context.\nn\nthe size of the linear system (must be ≥ 3).\ndl\n<type> dense array containing the lower diagonal of the tri-diagonal linear system. The lower diagonal\n\\(dl^{(i)}\\)\nthat corresponds to the\ni\nth\nlinear system starts at location\ndl+batchStride×i\nin memory. Also, the first element of each lower diagonal must be zero.\nd\n<type> dense array containing the main diagonal of the tri-diagonal linear system. The main diagonal\n\\(d^{(i)}\\)\nthat corresponds to the\ni\nth\nlinear system starts at location\nd+batchStride×i\nin memory.\ndu\n<type> dense array containing the upper diagonal of the tri-diagonal linear system. The upper diagonal\n\\(du^{(i)}\\)\nthat corresponds to the\ni\nth\nlinear system starts at location\ndu+batchStride×i\nin memory. Also, the last element of each upper diagonal must be zero.\nx\n<type> dense array that contains the right-hand-side of the tri-diagonal linear system. The right-hand-side\n\\(x^{(i)}\\)\nthat corresponds to the\ni\nth\nlinear system starts at location\nx+batchStride×i\nin memory.\nbatchCount\nnumber of systems to solve.\nbatchStride\nstride (number of elements) that separates the vectors of every system (must be at least\nn\n).\npBuffer\nbuffer allocated by the user, the size is return by\ngtsv2StridedBatch_bufferSizeExt\n.\nOutput\nx\n<type> dense array that contains the solution of the tri-diagonal linear system. The solution\n\\(x^{(i)}\\)\nthat corresponds to the\ni\nth\nlinear system starts at location\nx+batchStride×i\nin memory.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.4.3.\ncusparse<t>gtsvInterleavedBatch()\n\ncusparseStatus_t\ncusparseSgtsvInterleavedBatch_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nalgo\n,\nint\nm\n,\nconst\nfloat\n*\ndl\n,\nconst\nfloat\n*\nd\n,\nconst\nfloat\n*\ndu\n,\nconst\nfloat\n*\nx\n,\nint\nbatchCount\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseDgtsvInterleavedBatch_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nalgo\n,\nint\nm\n,\nconst\ndouble\n*\ndl\n,\nconst\ndouble\n*\nd\n,\nconst\ndouble\n*\ndu\n,\nconst\ndouble\n*\nx\n,\nint\nbatchCount\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseCgtsvInterleavedBatch_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nalgo\n,\nint\nm\n,\nconst\ncuComplex\n*\ndl\n,\nconst\ncuComplex\n*\nd\n,\nconst\ncuComplex\n*\ndu\n,\nconst\ncuComplex\n*\nx\n,\nint\nbatchCount\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseZgtsvInterleavedBatch_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nalgo\n,\nint\nm\n,\nconst\ncuDoubleComplex\n*\ndl\n,\nconst\ncuDoubleComplex\n*\nd\n,\nconst\ncuDoubleComplex\n*\ndu\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nbatchCount\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseSgtsvInterleavedBatch\n(\ncusparseHandle_t\nhandle\n,\nint\nalgo\n,\nint\nm\n,\nfloat\n*\ndl\n,\nfloat\n*\nd\n,\nfloat\n*\ndu\n,\nfloat\n*\nx\n,\nint\nbatchCount\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDgtsvInterleavedBatch\n(\ncusparseHandle_t\nhandle\n,\nint\nalgo\n,\nint\nm\n,\ndouble\n*\ndl\n,\ndouble\n*\nd\n,\ndouble\n*\ndu\n,\ndouble\n*\nx\n,\nint\nbatchCount\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseCgtsvInterleavedBatch\n(\ncusparseHandle_t\nhandle\n,\nint\nalgo\n,\nint\nm\n,\ncuComplex\n*\ndl\n,\ncuComplex\n*\nd\n,\ncuComplex\n*\ndu\n,\ncuComplex\n*\nx\n,\nint\nbatchCount\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZgtsvInterleavedBatch\n(\ncusparseHandle_t\nhandle\n,\nint\nalgo\n,\nint\nm\n,\ncuDoubleComplex\n*\ndl\n,\ncuDoubleComplex\n*\nd\n,\ncuDoubleComplex\n*\ndu\n,\ncuDoubleComplex\n*\nx\n,\nint\nbatchCount\n,\nvoid\n*\npBuffer\n)\nThis function computes the solution of multiple tridiagonal linear systems for\ni\n=0,…,\nbatchCount\n:\n\\[A^{(i)} \\ast \\text{x}^{(i)} = \\text{b}^{(i)}\\]\nThe coefficient matrix\nA\nof each of these tri-diagonal linear system is defined with three vectors corresponding to its lower (\ndl\n), main (\nd\n), and upper (\ndu\n) matrix diagonals; the right-hand sides are stored in the dense matrix\nB\n. Notice that solution\nX\noverwrites right-hand-side matrix\nB\non exit.\nAssuming\nA\nis of size\nm\nand base-1,\ndl\n,\nd\nand\ndu\nare defined by the following formula:\ndl(i)\n:=\nA(i,\ni-1)\nfor\ni=1,2,...,m\nThe first element of dl is out-of-bound (\ndl(1)\n:=\nA(1,0)\n), so\ndl(1)\n=\n0\n.\nd(i)\n=\nA(i,i)\nfor\ni=1,2,...,m\ndu(i)\n=\nA(i,i+1)\nfor\ni=1,2,...,m\nThe last element of du is out-of-bound (\ndu(m)\n:=\nA(m,m+1)\n), so\ndu(m)\n=\n0\n.\nThe data layout is different from\ngtsvStridedBatch\nwhich aggregates all matrices one after another. Instead,\ngtsvInterleavedBatch\ngathers different matrices of the same element in a continous manner. If\ndl\nis regarded as a 2-D array of size\nm-by-batchCount\n,\ndl(:,j)\nto store\nj-th\nmatrix.\ngtsvStridedBatch\nuses column-major while\ngtsvInterleavedBatch\nuses row-major.\nThe routine provides three different algorithms, selected by parameter\nalgo\n. The first algorithm is\ncuThomas\nprovided by\nBarcelona\nSupercomputing\nCenter\n. The second algorithm is LU with partial pivoting and last algorithm is QR. From stability perspective, cuThomas is not numerically stable because it does not have pivoting. LU with partial pivoting and QR are stable. From performance perspective, LU with partial pivoting and QR is about 10% to 20% slower than cuThomas.\nThis function requires a buffer size returned by\ngtsvInterleavedBatch_bufferSizeExt()\n. The address of\npBuffer\nmust be multiple of 128 bytes. If it is not,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nIf the user prepares aggregate format, one can use\ncublasXgeam\nto get interleaved format. However such transformation takes time comparable to solver itself. To reach best performance, the user must prepare interleaved format explicitly.\nThis function requires temporary extra storage that is allocated internally.\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available.\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available.\nInput\nhandle\nhandle to the cuSPARSE library context.\nalgo\nalgo = 0: cuThomas (unstable algorithm); algo = 1: LU with pivoting (stable algorithm); algo = 2: QR (stable algorithm)\nm\nthe size of the linear system.\ndl\n<type> dense array containing the lower diagonal of the tri-diagonal linear system. The first element of each lower diagonal must be zero.\nd\n<type> dense array containing the main diagonal of the tri-diagonal linear system.\ndu\n<type> dense array containing the upper diagonal of the tri-diagonal linear system. The last element of each upper diagonal must be zero.\nx\n<type> dense right-hand-side array of dimensions\n(batchCount,\nn)\n.\npBuffer\nbuffer allocated by the user, the size is return by\ngtsvInterleavedBatch_bufferSizeExt\n.\nOutput\nx\n<type> dense solution array of dimensions\n(batchCount,\nn)\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.7.5.\nBatched Pentadiagonal Solve\n\nDifferent algorithms for batched pentadiagonal solve are discussed in this section.\n5.7.5.1.\ncusparse<t>gpsvInterleavedBatch()\n\ncusparseStatus_t\ncusparseSgpsvInterleavedBatch_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nalgo\n,\nint\nm\n,\nconst\nfloat\n*\nds\n,\nconst\nfloat\n*\ndl\n,\nconst\nfloat\n*\nd\n,\nconst\nfloat\n*\ndu\n,\nconst\nfloat\n*\ndw\n,\nconst\nfloat\n*\nx\n,\nint\nbatchCount\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseDgpsvInterleavedBatch_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nalgo\n,\nint\nm\n,\nconst\ndouble\n*\nds\n,\nconst\ndouble\n*\ndl\n,\nconst\ndouble\n*\nd\n,\nconst\ndouble\n*\ndu\n,\nconst\ndouble\n*\ndw\n,\nconst\ndouble\n*\nx\n,\nint\nbatchCount\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseCgpsvInterleavedBatch_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nalgo\n,\nint\nm\n,\nconst\ncuComplex\n*\nds\n,\nconst\ncuComplex\n*\ndl\n,\nconst\ncuComplex\n*\nd\n,\nconst\ncuComplex\n*\ndu\n,\nconst\ncuComplex\n*\ndw\n,\nconst\ncuComplex\n*\nx\n,\nint\nbatchCount\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseZgpsvInterleavedBatch_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nalgo\n,\nint\nm\n,\nconst\ncuDoubleComplex\n*\nds\n,\nconst\ncuDoubleComplex\n*\ndl\n,\nconst\ncuDoubleComplex\n*\nd\n,\nconst\ncuDoubleComplex\n*\ndu\n,\nconst\ncuDoubleComplex\n*\ndw\n,\nconst\ncuDoubleComplex\n*\nx\n,\nint\nbatchCount\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseSgpsvInterleavedBatch\n(\ncusparseHandle_t\nhandle\n,\nint\nalgo\n,\nint\nm\n,\nfloat\n*\nds\n,\nfloat\n*\ndl\n,\nfloat\n*\nd\n,\nfloat\n*\ndu\n,\nfloat\n*\ndw\n,\nfloat\n*\nx\n,\nint\nbatchCount\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDgpsvInterleavedBatch\n(\ncusparseHandle_t\nhandle\n,\nint\nalgo\n,\nint\nm\n,\ndouble\n*\nds\n,\ndouble\n*\ndl\n,\ndouble\n*\nd\n,\ndouble\n*\ndu\n,\ndouble\n*\ndw\n,\ndouble\n*\nx\n,\nint\nbatchCount\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseCgpsvInterleavedBatch\n(\ncusparseHandle_t\nhandle\n,\nint\nalgo\n,\nint\nm\n,\ncuComplex\n*\nds\n,\ncuComplex\n*\ndl\n,\ncuComplex\n*\nd\n,\ncuComplex\n*\ndu\n,\ncuComplex\n*\ndw\n,\ncuComplex\n*\nx\n,\nint\nbatchCount\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZgpsvInterleavedBatch\n(\ncusparseHandle_t\nhandle\n,\nint\nalgo\n,\nint\nm\n,\ncuDoubleComplex\n*\nds\n,\ncuDoubleComplex\n*\ndl\n,\ncuDoubleComplex\n*\nd\n,\ncuDoubleComplex\n*\ndu\n,\ncuDoubleComplex\n*\ndw\n,\ncuDoubleComplex\n*\nx\n,\nint\nbatchCount\n,\nvoid\n*\npBuffer\n)\nThis function computes the solution of multiple penta-diagonal linear systems for\ni\n=0,…,\nbatchCount\n:\n\\[A^{(i)} \\ast \\text{x}^{(i)} = \\text{b}^{(i)}\\]\nThe coefficient matrix\nA\nof each of these penta-diagonal linear system is defined with five vectors corresponding to its lower (\nds,\ndl\n), main (\nd\n), and upper (\ndu,\ndw\n) matrix diagonals; the right-hand sides are stored in the dense matrix\nB\n. Notice that solution\nX\noverwrites right-hand-side matrix\nB\non exit.\nAssuming\nA\nis of size\nm\nand base-1,\nds\n,\ndl\n,\nd\n,\ndu\nand\ndw\nare defined by the following formula:\nds(i)\n:=\nA(i,\ni-2)\nfor\ni=1,2,...,m\nThe first two elements of ds is out-of-bound (\nds(1)\n:=\nA(1,-1)\n,\nds(2)\n:=\nA(2,0)\n), so\nds(1)\n=\n0\nand\nds(2)\n=\n0\n.\ndl(i)\n:=\nA(i,\ni-1)\nfor\ni=1,2,...,m\nThe first element of dl is out-of-bound (\ndl(1)\n:=\nA(1,0)\n), so\ndl(1)\n=\n0\n.\nd(i)\n=\nA(i,i)\nfor\ni=1,2,...,m\ndu(i)\n=\nA(i,i+1)\nfor\ni=1,2,...,m\nThe last element of du is out-of-bound (\ndu(m)\n:=\nA(m,m+1)\n), so\ndu(m)\n=\n0\n.\ndw(i)\n=\nA(i,i+2)\nfor\ni=1,2,...,m\nThe last two elements of dw is out-of-bound (\ndw(m-1)\n:=\nA(m-1,m+1)\n,\ndw(m)\n:=\nA(m,m+2)\n), so\ndw(m-1)\n=\n0\nand\ndw(m)\n=\n0\n.\nThe data layout is the same as\ngtsvStridedBatch\n.\nThe routine is numerically stable because it uses QR to solve the linear system.\nThis function requires a buffer size returned by\ngpsvInterleavedBatch_bufferSizeExt()\n. The address of\npBuffer\nmust be multiple of 128 bytes. If it is not,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nThe function supports the following properties if\npBuffer\n!=\nNULL\n:\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nhandle\nhandle to the cuSPARSE library context.\nalgo\nonly support algo = 0 (QR)\nm\nthe size of the linear system.\nds\n<type> dense array containing the lower diagonal (distance 2 to the diagonal) of the penta-diagonal linear system. The first two elements must be zero.\ndl\n<type> dense array containing the lower diagonal (distance 1 to the diagonal) of the penta-diagonal linear system. The first element must be zero.\nd\n<type> dense array containing the main diagonal of the penta-diagonal linear system.\ndu\n<type> dense array containing the upper diagonal (distance 1 to the diagonal) of the penta-diagonal linear system. The last element must be zero.\ndw\n<type> dense array containing the upper diagonal (distance 2 to the diagonal) of the penta-diagonal linear system. The last two elements must be zero.\nx\n<type> dense right-hand-side array of dimensions\n(batchCount,\nn)\n.\npBuffer\nbuffer allocated by the user, the size is return by\ngpsvInterleavedBatch_bufferSizeExt\n.\nOutput\nx\n<type> dense solution array of dimensions\n(batchCount,\nn)\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\nPlease visit\ncuSPARSE Library Samples - cusparseSgpsvInterleavedBatch\nfor a code example.\n5.8.\ncuSPARSE Reorderings Reference\n\nThis chapter describes the reordering routines used to manipulate sparse matrices.\n5.8.1.\ncusparse<t>csrcolor() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseScsrcolor\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\nfloat\n*\nfractionToColor\n,\nint\n*\nncolors\n,\nint\n*\ncoloring\n,\nint\n*\nreordering\n,\ncusparseColorInfo_t\ninfo\n)\ncusparseStatus_t\ncusparseDcsrcolor\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\ndouble\n*\nfractionToColor\n,\nint\n*\nncolors\n,\nint\n*\ncoloring\n,\nint\n*\nreordering\n,\ncusparseColorInfo_t\ninfo\n)\ncusparseStatus_t\ncusparseCcsrcolor\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\ncuComplex\n*\nfractionToColor\n,\nint\n*\nncolors\n,\nint\n*\ncoloring\n,\nint\n*\nreordering\n,\ncusparseColorInfo_t\ninfo\n)\ncusparseStatus_t\ncusparseZcsrcolor\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\ncuDoubleComplex\n*\nfractionToColor\n,\nint\n*\nncolors\n,\nint\n*\ncoloring\n,\nint\n*\nreordering\n,\ncusparseColorInfo_t\ninfo\n)\nThis function performs the coloring of the adjacency graph associated with the matrix A stored in CSR format. The coloring is an assignment of colors (integer numbers) to nodes, such that neighboring nodes have distinct colors. An approximate coloring algorithm is used in this routine, and is stopped when a certain percentage of nodes has been colored. The rest of the nodes are assigned distinct colors (an increasing sequence of integers numbers, starting from the last integer used previously). The last two auxiliary routines can be used to extract the resulting number of colors, their assignment and the associated reordering. The reordering is such that nodes that have been assigned the same color are reordered to be next to each other.\nThe matrix A passed to this routine, must be stored as a general matrix and have a symmetric sparsity pattern. If the matrix is nonsymmetric the user should pass A+A^T as a parameter to this routine.\nThis function requires temporary extra storage that is allocated internally.\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available.\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available.\nInput\nhandle\nhandle to the cuSPARSE library context.\nm\nnumber of rows of matrix\nA\n.\nnnz\nnumber of nonzero elements of matrix\nA\n.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrValA\n<type> array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\nnonzero elements of matrix\nA\n.\ncsrRowPtrA\ninteger array of\nm+1\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndA\ninteger array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero elements of matrix\nA\n.\nfractionToColor\nfraction of nodes to be colored, which should be in the interval [0.0,1.0], for example 0.8 implies that 80 percent of nodes will be colored.\ninfo\nstructure with information to be passed to the coloring.\nOutput\nncolors\nThe number of distinct colors used (at most the size of the matrix, but likely much smaller).\ncoloring\nThe resulting coloring permutation\nreordering\nThe resulting reordering permutation (untouched if NULL)\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.9.\ncuSPARSE Format Conversion Reference\n\nThis chapter describes the conversion routines between different sparse and dense storage formats.\ncoosort\n,\ncsrsort\n,\ncscsort\n, and\ncsru2csr\nare sorting routines without malloc inside, the following table estimates the buffer size.\nroutine\nbuffer\nsize\nmaximum\nproblem\nsize\nif\nbuffer\nis\nlimited\nby\n2GB\ncoosort\n>\n16*n\nbytes\n125M\ncsrsort\nor\ncscsort\n>\n20*n\nbytes\n100M\ncsru2csr\n'd'\n>\n28*n\nbytes\n;\n'z'\n>\n36*n\nbytes\n71M for ‘d’ and 55M for ‘z’\n5.9.1.\ncusparse<t>bsr2csr() [DEPRECATED]\n\n>\nThis routine will be removed in a future major release.\ncusparseStatus_t\ncusparseSbsr2csr\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nmb\n,\nint\nnb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nfloat\n*\ncsrValC\n,\nint\n*\ncsrRowPtrC\n,\nint\n*\ncsrColIndC\n)\ncusparseStatus_t\ncusparseDbsr2csr\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nmb\n,\nint\nnb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\ndouble\n*\ncsrValC\n,\nint\n*\ncsrRowPtrC\n,\nint\n*\ncsrColIndC\n)\ncusparseStatus_t\ncusparseCbsr2csr\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nmb\n,\nint\nnb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\ncuComplex\n*\ncsrValC\n,\nint\n*\ncsrRowPtrC\n,\nint\n*\ncsrColIndC\n)\ncusparseStatus_t\ncusparseZbsr2csr\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nmb\n,\nint\nnb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nblockDim\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\ncuDoubleComplex\n*\ncsrValC\n,\nint\n*\ncsrRowPtrC\n,\nint\n*\ncsrColIndC\n)\nThis function converts a sparse matrix in BSR format that is defined by the three arrays\nbsrValA\n,\nbsrRowPtrA\n, and\nbsrColIndA\n) into a sparse matrix in CSR format that is defined by arrays\ncsrValC\n,\ncsrRowPtrC\n, and\ncsrColIndC\n.\nLet\nm(=mb*blockDim)\nbe the number of rows of\nA\nand\nn(=nb*blockDim)\nbe number of columns of\nA\n, then\nA\nand\nC\nare\nm*n\nsparse matrices. The BSR format of\nA\ncontains\nnnzb(=bsrRowPtrA[mb]\n-\nbsrRowPtrA[0])\nnonzero blocks, whereas the sparse matrix\nA\ncontains\nnnz(=nnzb*blockDim*blockDim)\nelements. The user must allocate enough space for arrays\ncsrRowPtrC\n,\ncsrColIndC\n, and\ncsrValC\n. The requirements are as follows:\ncsrRowPtrC\nof\nm+1\nelements\ncsrValC\nof\nnnz\nelements\ncsrColIndC\nof\nnnz\nelements\nThe general procedure is as follows:\n// Given BSR format (bsrRowPtrA, bsrcolIndA, bsrValA) and\n// blocks of BSR format are stored in column-major order.\ncusparseDirection_t\ndir\n=\nCUSPARSE_DIRECTION_COLUMN\n;\nint\nm\n=\nmb\n*\nblockDim\n;\nint\nnnzb\n=\nbsrRowPtrA\n[\nmb\n]\n-\nbsrRowPtrA\n[\n0\n];\n// number of blocks\nint\nnnz\n=\nnnzb\n*\nblockDim\n*\nblockDim\n;\n// number of elements\ncudaMalloc\n((\nvoid\n**\n)\n&\ncsrRowPtrC\n,\nsizeof\n(\nint\n)\n*\n(\nm\n+\n1\n));\ncudaMalloc\n((\nvoid\n**\n)\n&\ncsrColIndC\n,\nsizeof\n(\nint\n)\n*\nnnz\n);\ncudaMalloc\n((\nvoid\n**\n)\n&\ncsrValC\n,\nsizeof\n(\nfloat\n)\n*\nnnz\n);\ncusparseSbsr2csr\n(\nhandle\n,\ndir\n,\nmb\n,\nnb\n,\ndescrA\n,\nbsrValA\n,\nbsrRowPtrA\n,\nbsrColIndA\n,\nblockDim\n,\ndescrC\n,\ncsrValC\n,\ncsrRowPtrC\n,\ncsrColIndC\n);\nThe routine requires no extra storage\nThe routine supports asynchronous execution if\nblockDim\n!=\n1\nor the Stream Ordered Memory Allocator is available\nThe routine supports CUDA graph capture if\nblockDim\n!=\n1\nor the Stream Ordered Memory Allocator is available\nInput\nhandle\nhandle to the cuSPARSE library context.\ndir\nstorage format of blocks, either\nCUSPARSE_DIRECTION_ROW\nor\nCUSPARSE_DIRECTION_COLUMN\n.\nmb\nnumber of block rows of sparse matrix\nA\n.\nnb\nnumber of block columns of sparse matrix\nA\n.\ndescrA\nthe descriptor of matrix\nA\n.\nbsrValA\n<type> array of\nnnzb*blockDim*blockDim\nnonzero elements of matrix\nA\n.\nbsrRowPtrA\ninteger array of\nmb+1\nelements that contains the start of every block row and the end of the last block row plus one of matrix\nA\n.\nbsrColIndA\ninteger array of\nnnzb\ncolumn indices of the nonzero blocks of matrix\nA\n.\nblockDim\nblock dimension of sparse matrix\nA\n.\ndescrC\nthe descriptor of matrix\nC\n.\nOutput\ncsrValC\n<type> array of\nnnz(=csrRowPtrC[m]-csrRowPtrC[0])\nnonzero elements of matrix\nC\n.\ncsrRowPtrC\ninteger array of\nm+1\nelements that contains the start of every row and the end of the last row plus one of matrix\nC\n.\ncsrColIndC\ninteger array of\nnnz\ncolumn indices of the nonzero elements of matrix\nC\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.9.2.\ncusparse<t>gebsr2gebsc()\n\ncusparseStatus_t\ncusparseSgebsr2gebsc_bufferSize\n(\ncusparseHandle_t\nhandle\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\nfloat\n*\nbsrVal\n,\nconst\nint\n*\nbsrRowPtr\n,\nconst\nint\n*\nbsrColInd\n,\nint\nrowBlockDim\n,\nint\ncolBlockDim\n,\nint\n*\npBufferSize\n)\ncusparseStatus_t\ncusparseDgebsr2gebsc_bufferSize\n(\ncusparseHandle_t\nhandle\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\ndouble\n*\nbsrVal\n,\nconst\nint\n*\nbsrRowPtr\n,\nconst\nint\n*\nbsrColInd\n,\nint\nrowBlockDim\n,\nint\ncolBlockDim\n,\nint\n*\npBufferSize\n)\ncusparseStatus_t\ncusparseCgebsr2gebsc_bufferSize\n(\ncusparseHandle_t\nhandle\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\ncuComplex\n*\nbsrVal\n,\nconst\nint\n*\nbsrRowPtr\n,\nconst\nint\n*\nbsrColInd\n,\nint\nrowBlockDim\n,\nint\ncolBlockDim\n,\nint\n*\npBufferSize\n)\ncusparseStatus_t\ncusparseZgebsr2gebsc_bufferSize\n(\ncusparseHandle_t\nhandle\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\ncuDoubleComplex\n*\nbsrVal\n,\nconst\nint\n*\nbsrRowPtr\n,\nconst\nint\n*\nbsrColInd\n,\nint\nrowBlockDim\n,\nint\ncolBlockDim\n,\nint\n*\npBufferSize\n)\ncusparseStatus_t\ncusparseSgebsr2gebsc\n(\ncusparseHandle_t\nhandle\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\nfloat\n*\nbsrVal\n,\nconst\nint\n*\nbsrRowPtr\n,\nconst\nint\n*\nbsrColInd\n,\nint\nrowBlockDim\n,\nint\ncolBlockDim\n,\nfloat\n*\nbscVal\n,\nint\n*\nbscRowInd\n,\nint\n*\nbscColPtr\n,\ncusparseAction_t\ncopyValues\n,\ncusparseIndexBase_t\nbaseIdx\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDgebsr2gebsc\n(\ncusparseHandle_t\nhandle\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\ndouble\n*\nbsrVal\n,\nconst\nint\n*\nbsrRowPtr\n,\nconst\nint\n*\nbsrColInd\n,\nint\nrowBlockDim\n,\nint\ncolBlockDim\n,\ndouble\n*\nbscVal\n,\nint\n*\nbscRowInd\n,\nint\n*\nbscColPtr\n,\ncusparseAction_t\ncopyValues\n,\ncusparseIndexBase_t\nbaseIdx\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseCgebsr2gebsc\n(\ncusparseHandle_t\nhandle\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\ncuComplex\n*\nbsrVal\n,\nconst\nint\n*\nbsrRowPtr\n,\nconst\nint\n*\nbsrColInd\n,\nint\nrowBlockDim\n,\nint\ncolBlockDim\n,\ncuComplex\n*\nbscVal\n,\nint\n*\nbscRowInd\n,\nint\n*\nbscColPtr\n,\ncusparseAction_t\ncopyValues\n,\ncusparseIndexBase_t\nbaseIdx\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZgebsr2gebsc\n(\ncusparseHandle_t\nhandle\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\ncuDoubleComplex\n*\nbsrVal\n,\nconst\nint\n*\nbsrRowPtr\n,\nconst\nint\n*\nbsrColInd\n,\nint\nrowBlockDim\n,\nint\ncolBlockDim\n,\ncuDoubleComplex\n*\nbscVal\n,\nint\n*\nbscRowInd\n,\nint\n*\nbscColPtr\n,\ncusparseAction_t\ncopyValues\n,\ncusparseIndexBase_t\nbaseIdx\n,\nvoid\n*\npBuffer\n)\nThis function can be seen as the same as\ncsr2csc()\nwhen each block of size\nrowBlockDim*colBlockDim\nis regarded as a scalar.\nThis sparsity pattern of the result matrix can also be seen as the transpose of the original sparse matrix, but the memory layout of a block does not change.\nThe user must call\ngebsr2gebsc_bufferSize()\nto determine the size of the buffer required by\ngebsr2gebsc()\n, allocate the buffer, and pass the buffer pointer to\ngebsr2gebsc()\n.\nThe routine requires no extra storage if\npBuffer\n!=\nNULL\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available\nInput\nhandle\nhandle to the cuSPARSE library context.\nmb\nnumber of block rows of sparse matrix\nA\n.\nnb\nnumber of block columns of sparse matrix\nA\n.\nnnzb\nnumber of nonzero blocks of matrix\nA\n.\nbsrVal\n<type> array of\nnnzb*rowBlockDim*colBlockDim\nnonzero elements of matrix\nA\n.\nbsrRowPtr\ninteger array of\nmb+1\nelements that contains the start of every block row and the end of the last block row plus one.\nbsrColInd\ninteger array of\nnnzb\ncolumn indices of the non-zero blocks of matrix\nA\n.\nrowBlockDim\nnumber of rows within a block of\nA\n.\ncolBlockDim\nnumber of columns within a block of\nA\n.\ncopyValues\nCUSPARSE_ACTION_SYMBOLIC\nor\nCUSPARSE_ACTION_NUMERIC\n.\nbaseIdx\nCUSPARSE_INDEX_BASE_ZERO\nor\nCUSPARSE_INDEX_BASE_ONE\n.\npBufferSize\nhost pointer containing number of bytes of the buffer used in\ngebsr2gebsc()\n.\npBuffer\nbuffer allocated by the user; the size is return by\ngebsr2gebsc_bufferSize()\n.\nOutput\nbscVal\n<type> array of\nnnzb*rowBlockDim*colBlockDim\nnon-zero elements of matrix\nA\n. It is only filled-in if\ncopyValues\nis set to\nCUSPARSE_ACTION_NUMERIC\n.\nbscRowInd\ninteger array of\nnnzb\nrow indices of the non-zero blocks of matrix\nA\n.\nbscColPtr\ninteger array of\nnb+1\nelements that contains the start of every block column and the end of the last block column plus one.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.9.3.\ncusparse<t>gebsr2gebsr() [DEPRECATED]\n\n>\nThis routine will be removed in a future major release.\ncusparseStatus_t\ncusparseSgebsr2gebsr_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nrowBlockDimA\n,\nint\ncolBlockDimA\n,\nint\nrowBlockDimC\n,\nint\ncolBlockDimC\n,\nint\n*\npBufferSize\n)\ncusparseStatus_t\ncusparseDgebsr2gebsr_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nrowBlockDimA\n,\nint\ncolBlockDimA\n,\nint\nrowBlockDimC\n,\nint\ncolBlockDimC\n,\nint\n*\npBufferSize\n)\ncusparseStatus_t\ncusparseCgebsr2gebsr_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nrowBlockDimA\n,\nint\ncolBlockDimA\n,\nint\nrowBlockDimC\n,\nint\ncolBlockDimC\n,\nint\n*\npBufferSize\n)\ncusparseStatus_t\ncusparseZgebsr2gebsr_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nrowBlockDimA\n,\nint\ncolBlockDimA\n,\nint\nrowBlockDimC\n,\nint\ncolBlockDimC\n,\nint\n*\npBufferSize\n)\ncusparseStatus_t\ncusparseXgebsr2gebsrNnz\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nrowBlockDimA\n,\nint\ncolBlockDimA\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nint\n*\nbsrRowPtrC\n,\nint\nrowBlockDimC\n,\nint\ncolBlockDimC\n,\nint\n*\nnnzTotalDevHostPtr\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseSgebsr2gebsr\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nrowBlockDimA\n,\nint\ncolBlockDimA\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nfloat\n*\nbsrValC\n,\nint\n*\nbsrRowPtrC\n,\nint\n*\nbsrColIndC\n,\nint\nrowBlockDimC\n,\nint\ncolBlockDimC\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDgebsr2gebsr\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nrowBlockDimA\n,\nint\ncolBlockDimA\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\ndouble\n*\nbsrValC\n,\nint\n*\nbsrRowPtrC\n,\nint\n*\nbsrColIndC\n,\nint\nrowBlockDimC\n,\nint\ncolBlockDimC\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseCgebsr2gebsr\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nrowBlockDimA\n,\nint\ncolBlockDimA\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\ncuComplex\n*\nbsrValC\n,\nint\n*\nbsrRowPtrC\n,\nint\n*\nbsrColIndC\n,\nint\nrowBlockDimC\n,\nint\ncolBlockDimC\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZgebsr2gebsr\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nmb\n,\nint\nnb\n,\nint\nnnzb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nrowBlockDimA\n,\nint\ncolBlockDimA\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\ncuDoubleComplex\n*\nbsrValC\n,\nint\n*\nbsrRowPtrC\n,\nint\n*\nbsrColIndC\n,\nint\nrowBlockDimC\n,\nint\ncolBlockDimC\n,\nvoid\n*\npBuffer\n)\nThis function converts a sparse matrix in general BSR format that is defined by the three arrays\nbsrValA\n,\nbsrRowPtrA\n, and\nbsrColIndA\ninto a sparse matrix in another general BSR format that is defined by arrays\nbsrValC\n,\nbsrRowPtrC\n, and\nbsrColIndC\n.\nIf\nrowBlockDimA=1\nand\ncolBlockDimA=1\n,\ncusparse[S|D|C|Z]gebsr2gebsr()\nis the same as\ncusparse[S|D|C|Z]csr2gebsr()\n.\nIf\nrowBlockDimC=1\nand\ncolBlockDimC=1\n,\ncusparse[S|D|C|Z]gebsr2gebsr()\nis the same as\ncusparse[S|D|C|Z]gebsr2csr()\n.\nA\nis an\nm*n\nsparse matrix where\nm(=mb*rowBlockDim)\nis the number of rows of\nA\n, and\nn(=nb*colBlockDim)\nis the number of columns of\nA\n. The general BSR format of\nA\ncontains\nnnzb(=bsrRowPtrA[mb]\n-\nbsrRowPtrA[0])\nnonzero blocks. The matrix\nC\nis also general BSR format with a different block size,\nrowBlockDimC*colBlockDimC\n. If\nm\nis not a multiple of\nrowBlockDimC\n, or\nn\nis not a multiple of\ncolBlockDimC\n, zeros are filled in. The number of block rows of\nC\nis\nmc(=(m+rowBlockDimC-1)/rowBlockDimC)\n. The number of block rows of\nC\nis\nnc(=(n+colBlockDimC-1)/colBlockDimC)\n. The number of nonzero blocks of\nC\nis\nnnzc\n.\nThe implementation adopts a two-step approach to do the conversion. First, the user allocates\nbsrRowPtrC\nof\nmc+1\nelements and uses function\ncusparseXgebsr2gebsrNnz()\nto determine the number of nonzero block columns per block row of matrix\nC\n. Second, the user gathers\nnnzc\n(number of non-zero block columns of matrix\nC\n) from either\n(nnzc=*nnzTotalDevHostPtr)\nor\n(nnzc=bsrRowPtrC[mc]-bsrRowPtrC[0])\nand allocates\nbsrValC\nof\nnnzc*rowBlockDimC*colBlockDimC\nelements and\nbsrColIndC\nof\nnnzc\nintegers. Finally the function\ncusparse[S|D|C|Z]gebsr2gebsr()\nis called to complete the conversion.\nThe user must call\ngebsr2gebsr_bufferSize()\nto know the size of the buffer required by\ngebsr2gebsr()\n, allocate the buffer, and pass the buffer pointer to\ngebsr2gebsr()\n.\nThe general procedure is as follows:\n// Given general BSR format (bsrRowPtrA, bsrColIndA, bsrValA) and\n// blocks of BSR format are stored in column-major order.\ncusparseDirection_t\ndir\n=\nCUSPARSE_DIRECTION_COLUMN\n;\nint\nbase\n,\nnnzc\n;\nint\nm\n=\nmb\n*\nrowBlockDimA\n;\nint\nn\n=\nnb\n*\ncolBlockDimA\n;\nint\nmc\n=\n(\nm\n+\nrowBlockDimC\n-1\n)\n/\nrowBlockDimC\n;\nint\nnc\n=\n(\nn\n+\ncolBlockDimC\n-1\n)\n/\ncolBlockDimC\n;\nint\nbufferSize\n;\nvoid\n*\npBuffer\n;\ncusparseSgebsr2gebsr_bufferSize\n(\nhandle\n,\ndir\n,\nmb\n,\nnb\n,\nnnzb\n,\ndescrA\n,\nbsrValA\n,\nbsrRowPtrA\n,\nbsrColIndA\n,\nrowBlockDimA\n,\ncolBlockDimA\n,\nrowBlockDimC\n,\ncolBlockDimC\n,\n&\nbufferSize\n);\ncudaMalloc\n((\nvoid\n**\n)\n&\npBuffer\n,\nbufferSize\n);\ncudaMalloc\n((\nvoid\n**\n)\n&\nbsrRowPtrC\n,\nsizeof\n(\nint\n)\n*\n(\nmc\n+\n1\n));\n// nnzTotalDevHostPtr points to host memory\nint\n*\nnnzTotalDevHostPtr\n=\n&\nnnzc\n;\ncusparseXgebsr2gebsrNnz\n(\nhandle\n,\ndir\n,\nmb\n,\nnb\n,\nnnzb\n,\ndescrA\n,\nbsrRowPtrA\n,\nbsrColIndA\n,\nrowBlockDimA\n,\ncolBlockDimA\n,\ndescrC\n,\nbsrRowPtrC\n,\nrowBlockDimC\n,\ncolBlockDimC\n,\nnnzTotalDevHostPtr\n,\npBuffer\n);\nif\n(\nNULL\n!=\nnnzTotalDevHostPtr\n){\nnnzc\n=\n*\nnnzTotalDevHostPtr\n;\n}\nelse\n{\ncudaMemcpy\n(\n&\nnnzc\n,\nbsrRowPtrC\n+\nmc\n,\nsizeof\n(\nint\n),\ncudaMemcpyDeviceToHost\n);\ncudaMemcpy\n(\n&\nbase\n,\nbsrRowPtrC\n,\nsizeof\n(\nint\n),\ncudaMemcpyDeviceToHost\n);\nnnzc\n-=\nbase\n;\n}\ncudaMalloc\n((\nvoid\n**\n)\n&\nbsrColIndC\n,\nsizeof\n(\nint\n)\n*\nnnzc\n);\ncudaMalloc\n((\nvoid\n**\n)\n&\nbsrValC\n,\nsizeof\n(\nfloat\n)\n*\n(\nrowBlockDimC\n*\ncolBlockDimC\n)\n*\nnnzc\n);\ncusparseSgebsr2gebsr\n(\nhandle\n,\ndir\n,\nmb\n,\nnb\n,\nnnzb\n,\ndescrA\n,\nbsrValA\n,\nbsrRowPtrA\n,\nbsrColIndA\n,\nrowBlockDimA\n,\ncolBlockDimA\n,\ndescrC\n,\nbsrValC\n,\nbsrRowPtrC\n,\nbsrColIndC\n,\nrowBlockDimC\n,\ncolBlockDimC\n,\npBuffer\n);\nThe routines require no extra storage if\npBuffer\n!=\nNULL\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available\nThe routines do\nnot\nsupport CUDA graph capture\nInput\nhandle\nhandle to the cuSPARSE library context.\ndir\nstorage format of blocks, either\nCUSPARSE_DIRECTION_ROW\nor\nCUSPARSE_DIRECTION_COLUMN\n.\nmb\nnumber of block rows of sparse matrix\nA\n.\nnb\nnumber of block columns of sparse matrix\nA\n.\nnnzb\nnumber of nonzero blocks of matrix\nA\n.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\nbsrValA\n<type> array of\nnnzb*rowBlockDimA*colBlockDimA\nnon-zero elements of matrix\nA\n.\nbsrRowPtrA\ninteger array of\nmb+1\nelements that contains the start of every block row and the end of the last block row plus one of matrix\nA\n.\nbsrColIndA\ninteger array of\nnnzb\ncolumn indices of the non-zero blocks of matrix\nA\n.\nrowBlockDimA\nnumber of rows within a block of\nA\n.\ncolBlockDimA\nnumber of columns within a block of\nA\n.\ndescrC\nthe descriptor of matrix\nC\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\nrowBlockDimC\nnumber of rows within a block of\nC\n.\ncolBlockDimC\nnumber of columns within a block of\nC\n.\npBufferSize\nhost pointer containing number of bytes of the buffer used in\ngebsr2gebsr()\n.\npBuffer\nbuffer allocated by the user; the size is return by\ngebsr2gebsr_bufferSize()\n.\nOutput\nbsrValC\n<type> array of\nnnzc*rowBlockDimC*colBlockDimC\nnon-zero elements of matrix\nC\n.\nbsrRowPtrC\ninteger array of\nmc+1\nelements that contains the start of every block row and the end of the last block row plus one of matrix\nC\n.\nbsrColIndC\ninteger array of\nnnzc\nblock column indices of the nonzero blocks of matrix\nC\n.\nnnzTotalDevHostPtr\ntotal number of nonzero blocks of\nC\n.\n*nnzTotalDevHostPtr\nis the same as\nbsrRowPtrC[mc]-bsrRowPtrC[0]\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.9.4.\ncusparse<t>gebsr2csr() [DEPRECATED]\n\n>\nThis routine will be removed in a future major release.\ncusparseStatus_t\ncusparseSgebsr2csr\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nmb\n,\nint\nnb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nrowBlockDim\n,\nint\ncolBlockDim\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nfloat\n*\ncsrValC\n,\nint\n*\ncsrRowPtrC\n,\nint\n*\ncsrColIndC\n)\ncusparseStatus_t\ncusparseDgebsr2csr\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nmb\n,\nint\nnb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nrowBlockDim\n,\nint\ncolBlockDim\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\ndouble\n*\ncsrValC\n,\nint\n*\ncsrRowPtrC\n,\nint\n*\ncsrColIndC\n)\ncusparseStatus_t\ncusparseCgebsr2csr\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nmb\n,\nint\nnb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nrowBlockDim\n,\nint\ncolBlockDim\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\ncuComplex\n*\ncsrValC\n,\nint\n*\ncsrRowPtrC\n,\nint\n*\ncsrColIndC\n)\ncusparseStatus_t\ncusparseZgebsr2csr\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nmb\n,\nint\nnb\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\nbsrValA\n,\nconst\nint\n*\nbsrRowPtrA\n,\nconst\nint\n*\nbsrColIndA\n,\nint\nrowBlockDim\n,\nint\ncolBlockDim\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\ncuDoubleComplex\n*\ncsrValC\n,\nint\n*\ncsrRowPtrC\n,\nint\n*\ncsrColIndC\n)\nThis function converts a sparse matrix in general BSR format that is defined by the three arrays\nbsrValA\n,\nbsrRowPtrA\n, and\nbsrColIndA\ninto a sparse matrix in CSR format that is defined by arrays\ncsrValC\n,\ncsrRowPtrC\n, and\ncsrColIndC\n.\nLet\nm(=mb*rowBlockDim)\nbe number of rows of\nA\nand\nn(=nb*colBlockDim)\nbe number of columns of\nA\n, then\nA\nand\nC\nare\nm*n\nsparse matrices. The general BSR format of\nA\ncontains\nnnzb(=bsrRowPtrA[mb]\n-\nbsrRowPtrA[0])\nnon-zero blocks, whereas sparse matrix\nA\ncontains\nnnz(=nnzb*rowBlockDim*colBlockDim)\nelements. The user must allocate enough space for arrays\ncsrRowPtrC\n,\ncsrColIndC\n, and\ncsrValC\n. The requirements are as follows:\ncsrRowPtrC\nof\nm+1\nelements\ncsrValC\nof\nnnz\nelements\ncsrColIndC\nof\nnnz\nelements\nThe general procedure is as follows:\n// Given general BSR format (bsrRowPtrA, bsrColIndA, bsrValA) and\n// blocks of BSR format are stored in column-major order.\ncusparseDirection_t\ndir\n=\nCUSPARSE_DIRECTION_COLUMN\n;\nint\nm\n=\nmb\n*\nrowBlockDim\n;\nint\nn\n=\nnb\n*\ncolBlockDim\n;\nint\nnnzb\n=\nbsrRowPtrA\n[\nmb\n]\n-\nbsrRowPtrA\n[\n0\n];\n// number of blocks\nint\nnnz\n=\nnnzb\n*\nrowBlockDim\n*\ncolBlockDim\n;\n// number of elements\ncudaMalloc\n((\nvoid\n**\n)\n&\ncsrRowPtrC\n,\nsizeof\n(\nint\n)\n*\n(\nm\n+\n1\n));\ncudaMalloc\n((\nvoid\n**\n)\n&\ncsrColIndC\n,\nsizeof\n(\nint\n)\n*\nnnz\n);\ncudaMalloc\n((\nvoid\n**\n)\n&\ncsrValC\n,\nsizeof\n(\nfloat\n)\n*\nnnz\n);\ncusparseSgebsr2csr\n(\nhandle\n,\ndir\n,\nmb\n,\nnb\n,\ndescrA\n,\nbsrValA\n,\nbsrRowPtrA\n,\nbsrColIndA\n,\nrowBlockDim\n,\ncolBlockDim\n,\ndescrC\n,\ncsrValC\n,\ncsrRowPtrC\n,\ncsrColIndC\n);\nThe routine requires no extra storage\nThe routine supports asynchronous execution\nThe routine supports CUDA graph capture\nInput\nhandle\nhandle to the cuSPARSE library context.\ndir\nstorage format of blocks, either\nCUSPARSE_DIRECTION_ROW\nor\nCUSPARSE_DIRECTION_COLUMN\n.\nmb\nnumber of block rows of sparse matrix\nA\n.\nnb\nnumber of block columns of sparse matrix\nA\n.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\nbsrValA\n<type> array of\nnnzb*rowBlockDim*colBlockDim\nnon-zero elements of matrix\nA\n.\nbsrRowPtrA\ninteger array of\nmb+1\nelements that contains the start of every block row and the end of the last block row plus one of matrix\nA\n.\nbsrColIndA\ninteger array of\nnnzb\ncolumn indices of the non-zero blocks of matrix\nA\n.\nrowBlockDim\nnumber of rows within a block of\nA\n.\ncolBlockDim\nnumber of columns within a block of\nA\n.\ndescrC\nthe descriptor of matrix\nC\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\nOutput\ncsrValC\n<type> array of\nnnz\nnon-zero elements of matrix\nC\n.\ncsrRowPtrC\ninteger array of\nm+1\nelements that contains the start of every row and the end of the last row plus one of matrix\nC\n.\ncsrColIndC\ninteger array of\nnnz\ncolumn indices of the non-zero elements of matrix\nC\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.9.5.\ncusparse<t>csr2gebsr()\n\ncusparseStatus_t\ncusparseScsr2gebsr_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nm\n,\nint\nn\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nint\nrowBlockDim\n,\nint\ncolBlockDim\n,\nint\n*\npBufferSize\n)\ncusparseStatus_t\ncusparseDcsr2gebsr_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nm\n,\nint\nn\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nint\nrowBlockDim\n,\nint\ncolBlockDim\n,\nint\n*\npBufferSize\n)\ncusparseStatus_t\ncusparseCcsr2gebsr_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nm\n,\nint\nn\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nint\nrowBlockDim\n,\nint\ncolBlockDim\n,\nint\n*\npBufferSize\n)\ncusparseStatus_t\ncusparseZcsr2gebsr_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nm\n,\nint\nn\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nint\nrowBlockDim\n,\nint\ncolBlockDim\n,\nint\n*\npBufferSize\n)\ncusparseStatus_t\ncusparseXcsr2gebsrNnz\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nm\n,\nint\nn\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nint\n*\nbsrRowPtrC\n,\nint\nrowBlockDim\n,\nint\ncolBlockDim\n,\nint\n*\nnnzTotalDevHostPtr\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseScsr2gebsr\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nm\n,\nint\nn\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nfloat\n*\nbsrValC\n,\nint\n*\nbsrRowPtrC\n,\nint\n*\nbsrColIndC\n,\nint\nrowBlockDim\n,\nint\ncolBlockDim\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDcsr2gebsr\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nm\n,\nint\nn\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\ndouble\n*\nbsrValC\n,\nint\n*\nbsrRowPtrC\n,\nint\n*\nbsrColIndC\n,\nint\nrowBlockDim\n,\nint\ncolBlockDim\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseCcsr2gebsr\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nm\n,\nint\nn\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\ncuComplex\n*\nbsrValC\n,\nint\n*\nbsrRowPtrC\n,\nint\n*\nbsrColIndC\n,\nint\nrowBlockDim\n,\nint\ncolBlockDim\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZcsr2gebsr\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndir\n,\nint\nm\n,\nint\nn\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\ncuDoubleComplex\n*\nbsrValC\n,\nint\n*\nbsrRowPtrC\n,\nint\n*\nbsrColIndC\n,\nint\nrowBlockDim\n,\nint\ncolBlockDim\n,\nvoid\n*\npBuffer\n)\nThis function converts a sparse matrix\nA\nin CSR format (that is defined by arrays\ncsrValA\n,\ncsrRowPtrA\n, and\ncsrColIndA\n) into a sparse matrix\nC\nin general BSR format (that is defined by the three arrays\nbsrValC\n,\nbsrRowPtrC\n, and\nbsrColIndC\n).\nThe matrix A is an :math:\nm times n\nsparse matrix and matrix\nC\nis a\n(mb*rowBlockDim)*(nb*colBlockDim)\nsparse matrix, where\nmb(=(m+rowBlockDim-1)/rowBlockDim)\nis the number of block rows of\nC\n, and\nnb(=(n+colBlockDim-1)/colBlockDim)\nis the number of block columns of\nC\n.\nThe block of\nC\nis of size\nrowBlockDim*colBlockDim\n. If\nm\nis not multiple of\nrowBlockDim\nor\nn\nis not multiple of\ncolBlockDim\n, zeros are filled in.\nThe implementation adopts a two-step approach to do the conversion. First, the user allocates\nbsrRowPtrC\nof\nmb+1\nelements and uses function\ncusparseXcsr2gebsrNnz()\nto determine the number of nonzero block columns per block row. Second, the user gathers\nnnzb\n(number of nonzero block columns of matrix\nC\n) from either\n(nnzb=*nnzTotalDevHostPtr)\nor\n(nnzb=bsrRowPtrC[mb]-bsrRowPtrC[0])\nand allocates\nbsrValC\nof\nnnzb*rowBlockDim*colBlockDim\nelements and\nbsrColIndC\nof\nnnzb\nintegers. Finally function\ncusparse[S|D|C|Z]csr2gebsr()\nis called to complete the conversion.\nThe user must obtain the size of the buffer required by\ncsr2gebsr()\nby calling\ncsr2gebsr_bufferSize()\n, allocate the buffer, and pass the buffer pointer to\ncsr2gebsr()\n.\nThe general procedure is as follows:\n// Given CSR format (csrRowPtrA, csrColIndA, csrValA) and\n// blocks of BSR format are stored in column-major order.\ncusparseDirection_t\ndir\n=\nCUSPARSE_DIRECTION_COLUMN\n;\nint\nbase\n,\nnnzb\n;\nint\nmb\n=\n(\nm\n+\nrowBlockDim\n-1\n)\n/\nrowBlockDim\n;\nint\nnb\n=\n(\nn\n+\ncolBlockDim\n-1\n)\n/\ncolBlockDim\n;\nint\nbufferSize\n;\nvoid\n*\npBuffer\n;\ncusparseScsr2gebsr_bufferSize\n(\nhandle\n,\ndir\n,\nm\n,\nn\n,\ndescrA\n,\ncsrValA\n,\ncsrRowPtrA\n,\ncsrColIndA\n,\nrowBlockDim\n,\ncolBlockDim\n,\n&\nbufferSize\n);\ncudaMalloc\n((\nvoid\n**\n)\n&\npBuffer\n,\nbufferSize\n);\ncudaMalloc\n((\nvoid\n**\n)\n&\nbsrRowPtrC\n,\nsizeof\n(\nint\n)\n*\n(\nmb\n+\n1\n));\n// nnzTotalDevHostPtr points to host memory\nint\n*\nnnzTotalDevHostPtr\n=\n&\nnnzb\n;\ncusparseXcsr2gebsrNnz\n(\nhandle\n,\ndir\n,\nm\n,\nn\n,\ndescrA\n,\ncsrRowPtrA\n,\ncsrColIndA\n,\ndescrC\n,\nbsrRowPtrC\n,\nrowBlockDim\n,\ncolBlockDim\n,\nnnzTotalDevHostPtr\n,\npBuffer\n);\nif\n(\nNULL\n!=\nnnzTotalDevHostPtr\n){\nnnzb\n=\n*\nnnzTotalDevHostPtr\n;\n}\nelse\n{\ncudaMemcpy\n(\n&\nnnzb\n,\nbsrRowPtrC\n+\nmb\n,\nsizeof\n(\nint\n),\ncudaMemcpyDeviceToHost\n);\ncudaMemcpy\n(\n&\nbase\n,\nbsrRowPtrC\n,\nsizeof\n(\nint\n),\ncudaMemcpyDeviceToHost\n);\nnnzb\n-=\nbase\n;\n}\ncudaMalloc\n((\nvoid\n**\n)\n&\nbsrColIndC\n,\nsizeof\n(\nint\n)\n*\nnnzb\n);\ncudaMalloc\n((\nvoid\n**\n)\n&\nbsrValC\n,\nsizeof\n(\nfloat\n)\n*\n(\nrowBlockDim\n*\ncolBlockDim\n)\n*\nnnzb\n);\ncusparseScsr2gebsr\n(\nhandle\n,\ndir\n,\nm\n,\nn\n,\ndescrA\n,\ncsrValA\n,\ncsrRowPtrA\n,\ncsrColIndA\n,\ndescrC\n,\nbsrValC\n,\nbsrRowPtrC\n,\nbsrColIndC\n,\nrowBlockDim\n,\ncolBlockDim\n,\npBuffer\n);\nThe routine\ncusparseXcsr2gebsrNnz()\nhas the following properties:\nThe routine requires no extra storage.\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available.\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available.\nThe routine\ncusparse<t>csr2gebsr()\nhas the following properties:\nThe routine requires no extra storage if\npBuffer\n!=\nNULL\n.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nhandle\nhandle to the cuSPARSE library context.\ndir\nstorage format of blocks, either\nCUSPARSE_DIRECTION_ROW\nor\nCUSPARSE_DIRECTION_COLUMN\n.\nm\nnumber of rows of sparse matrix\nA\n.\nn\nnumber of columns of sparse matrix\nA\n.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrValA\n<type> array of\nnnz\nnonzero elements of matrix\nA\n.\ncsrRowPtrA\ninteger array of\nm+1\nelements that contains the start of every row and the end of the last row plus one of matrix\nA\n.\ncsrColIndA\ninteger array of\nnnz\ncolumn indices of the nonzero elements of matrix\nA\n.\ndescrC\nthe descriptor of matrix\nC\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\nrowBlockDim\nnumber of rows within a block of\nC\n.\ncolBlockDim\nnumber of columns within a block of\nC\n.\npBuffer\nbuffer allocated by the user, the size is return by\ncsr2gebsr_bufferSize()\n.\nOutput\nbsrValC\n<type> array of\nnnzb*rowBlockDim*colBlockDim\nnonzero elements of matrix\nC\n.\nbsrRowPtrC\ninteger array of\nmb+1\nelements that contains the start of every block row and the end of the last block row plus one of matrix\nC\n.\nbsrColIndC\ninteger array of\nnnzb\ncolumn indices of the nonzero blocks of matrix\nC\n.\nnnzTotalDevHostPtr\ntotal number of nonzero blocks of matrix\nC\n. Pointer\nnnzTotalDevHostPtr\ncan point to a device memory or host memory.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.9.6.\ncusparse<t>coo2csr()\n\ncusparseStatus_t\ncusparseXcoo2csr\n(\ncusparseHandle_t\nhandle\n,\nconst\nint\n*\ncooRowInd\n,\nint\nnnz\n,\nint\nm\n,\nint\n*\ncsrRowPtr\n,\ncusparseIndexBase_t\nidxBase\n)\nThis function converts the array containing the uncompressed row indices (corresponding to COO format) into an array of compressed row pointers (corresponding to CSR format).\nIt can also be used to convert the array containing the uncompressed column indices (corresponding to COO format) into an array of column pointers (corresponding to CSC format).\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nhandle\nhandle to the cuSPARSE library context.\ncooRowInd\ninteger array of\nnnz\nuncompressed row indices.\nnnz\nnumber of non-zeros of the sparse matrix (that is also the length of array\ncooRowInd\n).\nm\nnumber of rows of matrix\nA\n.\nidxBase\nCUSPARSE_INDEX_BASE_ZERO\nor\nCUSPARSE_INDEX_BASE_ONE\n.\nOutput\ncsrRowPtr\ninteger array of\nm+1\nelements that contains the start of every row and the end of the last row plus one.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.9.7.\ncusparse<t>csr2coo()\n\ncusparseStatus_t\ncusparseXcsr2coo\n(\ncusparseHandle_t\nhandle\n,\nconst\nint\n*\ncsrRowPtr\n,\nint\nnnz\n,\nint\nm\n,\nint\n*\ncooRowInd\n,\ncusparseIndexBase_t\nidxBase\n)\nThis function converts the array containing the compressed row pointers (corresponding to CSR format) into an array of uncompressed row indices (corresponding to COO format).\nIt can also be used to convert the array containing the compressed column indices (corresponding to CSC format) into an array of uncompressed column indices (corresponding to COO format).\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nhandle\nhandle to the cuSPARSE library context.\ncsrRowPtr\ninteger array of\nm+1\nelements that contains the start of every row and the end of the last row plus one.\nnnz\nnumber of nonzeros of the sparse matrix (that is also the length of array\ncooRowInd\n).\nm\nnumber of rows of matrix\nA\n.\nidxBase\nCUSPARSE_INDEX_BASE_ZERO\nor\nCUSPARSE_INDEX_BASE_ONE\n.\nOutput\ncooRowInd\ninteger array of\nnnz\nuncompressed row indices.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.9.8.\ncusparseCsr2cscEx2()\n\ncusparseStatus_t\ncusparseCsr2cscEx2_bufferSize\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nconst\nvoid\n*\ncsrVal\n,\nconst\nint\n*\ncsrRowPtr\n,\nconst\nint\n*\ncsrColInd\n,\nvoid\n*\ncscVal\n,\nint\n*\ncscColPtr\n,\nint\n*\ncscRowInd\n,\ncudaDataType\nvalType\n,\ncusparseAction_t\ncopyValues\n,\ncusparseIndexBase_t\nidxBase\n,\ncusparseCsr2CscAlg_t\nalg\n,\nsize_t\n*\nbufferSize\n)\ncusparseStatus_t\ncusparseCsr2cscEx2\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nconst\nvoid\n*\ncsrVal\n,\nconst\nint\n*\ncsrRowPtr\n,\nconst\nint\n*\ncsrColInd\n,\nvoid\n*\ncscVal\n,\nint\n*\ncscColPtr\n,\nint\n*\ncscRowInd\n,\ncudaDataType\nvalType\n,\ncusparseAction_t\ncopyValues\n,\ncusparseIndexBase_t\nidxBase\n,\ncusparseCsr2CscAlg_t\nalg\n,\nvoid\n*\nbuffer\n)\nThis function converts a sparse matrix in CSR format (that is defined by the three arrays\ncsrVal\n,\ncsrRowPtr\n, and\ncsrColInd\n) into a sparse matrix in CSC format (that is defined by arrays\ncscVal\n,\ncscRowInd\n, and\ncscColPtr\n). The resulting matrix can also be seen as the transpose of the original sparse matrix. Notice that this routine can also be used to convert a matrix in CSC format into a matrix in CSR format.\nThe routine requires extra storage proportional to the number of nonzero values\nnnz\n. It provides in output always the same matrix.\nIt is executed asynchronously with respect to the host, and it may return control to the application on the host before the result is ready.\nThe function\ncusparseCsr2cscEx2_bufferSize()\nreturns the size of the workspace needed by\ncusparseCsr2cscEx2()\n. User needs to allocate a buffer of this size and give that buffer to\ncusparseCsr2cscEx2()\nas an argument.\nIf\nnnz\n==\n0\n, then\ncsrColInd\n,\ncsrVal\n,\ncscVal\n, and\ncscRowInd\ncould have\nNULL\nvalue. In this case,\ncscColPtr\nis set to\nidxBase\nfor all values.\nIf\nm\n==\n0\nor\nn\n==\n0\n, the pointers are not checked and the routine returns\nCUSPARSE_STATUS_SUCCESS\n.\nInput\nhandle\nHandle to the cuSPARSE library context\nm\nNumber of rows of the CSR input matrix; number of columns of the CSC ouput matrix\nn\nNumber of columns of the CSR input matrix; number of rows of the CSC ouput matrix\nnnz\nNumber of nonzero elements of the CSR and CSC matrices\ncsrVal\nValue array of size\nnnz\nof the CSR matrix; of same type as\nvalType\ncsrRowPtr\nInteger array of size\nm\n+\n1\nthat containes the CSR row offsets\ncsrColInd\nInteger array of size\nnnz\nthat containes the CSR column indices\ncscVal\nValue array of size\nnnz\nof the CSC matrix; of same type as\nvalType\ncscColPtr\nInteger array of size\nn\n+\n1\nthat containes the CSC column offsets\ncscRowInd\nInteger array of size\nnnz\nthat containes the CSC row indices\nvalType\nValue type for both CSR and CSC matrices\ncopyValues\nCUSPARSE_ACTION_SYMBOLIC\nor\nCUSPARSE_ACTION_NUMERIC\nidxBase\nIndex base\nCUSPARSE_INDEX_BASE_ZERO\nor\nCUSPARSE_INDEX_BASE_ONE\nalg\nAlgorithm implementation. see\ncusparseCsr2CscAlg_t\nfor possible values.\nbufferSize\nNumber of bytes of workspace needed by\ncusparseCsr2cscEx2()\nbuffer\nPointer to workspace buffer\ncusparseCsr2cscEx2()\nsupports the following data types:\nX\n/\nY\nCUDA_R_8I\nCUDA_R_16F\nCUDA_R_16BF\nCUDA_R_32F\nCUDA_R_64F\nCUDA_C_16F\n[DEPRECATED]\nCUDA_C_16BF\n[DEPRECATED]\nCUDA_C_32F\nCUDA_C_64F\ncusparseCsr2cscEx2()\nsupports the following algorithms (\ncusparseCsr2CscAlg_t\n):\nAlgorithm\nNotes\nCUSPARSE_CSR2CSC_ALG_DEFAULT\n,\nCUSPARSE_CSR2CSC_ALG1\nDefault algorithm\nAction\nNotes\nCUSPARSE_ACTION_SYMBOLIC\nCompute the “structure” of the CSC output matrix (offset, row indices)\nCUSPARSE_ACTION_NUMERIC\nCompute the “structure” of the CSC output matrix and copy the values\ncusparseCsr2cscEx2()\nhas the following properties:\nThe routine requires no extra storage\nThe routine supports asynchronous execution\ncusparseCsr2cscEx2()\nsupports the following\noptimizations\n:\nCUDA graph capture\nHardware Memory Compression\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.9.9.\ncusparse<t>nnz()\n\ncusparseStatus_t\ncusparseSnnz\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nm\n,\nint\nn\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nint\n*\nnnzPerRowColumn\n,\nint\n*\nnnzTotalDevHostPtr\n)\ncusparseStatus_t\ncusparseDnnz\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nm\n,\nint\nn\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nint\n*\nnnzPerRowColumn\n,\nint\n*\nnnzTotalDevHostPtr\n)\ncusparseStatus_t\ncusparseCnnz\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nm\n,\nint\nn\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nint\n*\nnnzPerRowColumn\n,\nint\n*\nnnzTotalDevHostPtr\n)\ncusparseStatus_t\ncusparseZnnz\n(\ncusparseHandle_t\nhandle\n,\ncusparseDirection_t\ndirA\n,\nint\nm\n,\nint\nn\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nint\n*\nnnzPerRowColumn\n,\nint\n*\nnnzTotalDevHostPtr\n)\nThis function computes the number of nonzero elements per row or column and the total number of nonzero elements in a dense matrix.\nThis function requires temporary extra storage that is allocated internally.\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available.\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available.\nInput\nhandle\nhandle to the cuSPARSE library context.\ndirA\ndirection that specifies whether to count nonzero elements by\nCUSPARSE_DIRECTION_ROW\nor by\nCUSPARSE_DIRECTION_COLUMN\n.\nm\nnumber of rows of matrix\nA\n.\nn\nnumber of columns of matrix\nA\n.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\nA\narray of dimensions\n(lda,\nn)\n.\nlda\nleading dimension of dense array\nA\n.\nOutput\nnnzPerRowColumn\narray of size\nm\nor\nn\ncontaining the number of nonzero elements per row or column, respectively\nnnzTotalDevHostPtr\ntotal number of nonzero elements in device or host memory\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.9.10.\ncusparseCreateIdentityPermutation() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseCreateIdentityPermutation\n(\ncusparseHandle_t\nhandle\n,\nint\nn\n,\nint\n*\np\n);\nThis function creates an identity map. The output parameter\np\nrepresents such map by\np\n=\n0:1:(n-1)\n.\nThis function is typically used with\ncoosort\n,\ncsrsort\n,\ncscsort\n.\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nparameter\ndevice\nor\nhost\ndescription\nhandle\nhost\nhandle to the cuSPARSE library context.\nn\nhost\nsize of the map.\nOutput\nparameter\ndevice\nor\nhost\ndescription\np\ndevice\ninteger array of dimensions\nn\n.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.9.11.\ncusparseXcoosort()\n\ncusparseStatus_t\ncusparseXcoosort_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nconst\nint\n*\ncooRows\n,\nconst\nint\n*\ncooCols\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseXcoosortByRow\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nint\n*\ncooRows\n,\nint\n*\ncooCols\n,\nint\n*\nP\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseXcoosortByColumn\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nint\n*\ncooRows\n,\nint\n*\ncooCols\n,\nint\n*\nP\n,\nvoid\n*\npBuffer\n);\nThis function sorts COO format. The sorting is in-place. Also the user can sort by row or sort by column.\nA\nis an\n\\(m \\times n\\)\nsparse matrix that is defined in COO storage format by the three arrays\ncooVals\n,\ncooRows\n, and\ncooCols\n.\nThere is no assumption for the base index of the matrix.\ncoosort\nuses stable sort on signed integer, so the value of\ncooRows\nor\ncooCols\ncan be negative.\nThis function\ncoosort()\nrequires buffer size returned by\ncoosort_bufferSizeExt()\n. The address of\npBuffer\nmust be multiple of 128 bytes. If not,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nThe parameter\nP\nis both input and output. If the user wants to compute sorted\ncooVal\n,\nP\nmust be set as 0:1:(nnz-1) before\ncoosort()\n, and after\ncoosort()\n, new sorted value array satisfies\ncooVal_sorted\n=\ncooVal(P)\n.\nRemark: the dimension\nm\nand\nn\nare not used. If the user does not know the value of\nm\nor\nn\n, just passes a value positive. This usually happens if the user only reads a COO array first and needs to decide the dimension\nm\nor\nn\nlater.\nThe routine requires no extra storage if\npBuffer\n!=\nNULL\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available\nInput\nparameter\ndevice\nor\nhost\ndescription\nhandle\nhost\nhandle to the cuSPARSE library context.\nm\nhost\nnumber of rows of matrix\nA\n.\nn\nhost\nnumber of columns of matrix\nA\n.\nnnz\nhost\nnumber of nonzero elements of matrix\nA\n.\ncooRows\ndevice\ninteger array of\nnnz\nunsorted row indices of\nA\n.\ncooCols\ndevice\ninteger array of\nnnz\nunsorted column indices of\nA\n.\nP\ndevice\ninteger array of\nnnz\nunsorted map indices. To construct\ncooVal\n, the user has to set\nP=0:1:(nnz-1)\n.\npBuffer\ndevice\nbuffer allocated by the user; the size is returned by\ncoosort_bufferSizeExt()\n.\nOutput\nparameter\ndevice\nor\nhost\ndescription\ncooRows\ndevice\ninteger array of\nnnz\nsorted row indices of\nA\n.\ncooCols\ndevice\ninteger array of\nnnz\nsorted column indices of\nA\n.\nP\ndevice\ninteger array of\nnnz\nsorted map indices.\npBufferSizeInBytes\nhost\nnumber of bytes of the buffer.\nSee\ncusparseStatus_t\nfor the description of the return status\nPlease visit\ncuSPARSE Library Samples - cusparseXcoosortByRow\nfor a code example.\n5.9.12.\ncusparseXcsrsort()\n\ncusparseStatus_t\ncusparseXcsrsort_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nconst\nint\n*\ncsrRowPtr\n,\nconst\nint\n*\ncsrColInd\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseXcsrsort\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nint\n*\ncsrRowPtr\n,\nint\n*\ncsrColInd\n,\nint\n*\nP\n,\nvoid\n*\npBuffer\n)\nThis function sorts CSR format. The stable sorting is in-place.\nThe matrix type is regarded as\nCUSPARSE_MATRIX_TYPE_GENERAL\nimplicitly. In other words, any symmetric property is ignored.\nThis function\ncsrsort()\nrequires buffer size returned by\ncsrsort_bufferSizeExt()\n. The address of\npBuffer\nmust be multiple of 128 bytes. If not,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nThe parameter\nP\nis both input and output. If the user wants to compute sorted\ncsrVal\n,\nP\nmust be set as 0:1:(nnz-1) before\ncsrsort()\n, and after\ncsrsort()\n, new sorted value array satisfies\ncsrVal_sorted\n=\ncsrVal(P)\n.\nThe general procedure is as follows:\n// A is a 3x3 sparse matrix, base-0\n//     | 1 2 3 |\n// A = | 4 5 6 |\n//     | 7 8 9 |\nconst\nint\nm\n=\n3\n;\nconst\nint\nn\n=\n3\n;\nconst\nint\nnnz\n=\n9\n;\ncsrRowPtr\n[\nm\n+\n1\n]\n=\n{\n0\n,\n3\n,\n6\n,\n9\n};\n// on device\ncsrColInd\n[\nnnz\n]\n=\n{\n2\n,\n1\n,\n0\n,\n0\n,\n2\n,\n1\n,\n1\n,\n2\n,\n0\n};\n// on device\ncsrVal\n[\nnnz\n]\n=\n{\n3\n,\n2\n,\n1\n,\n4\n,\n6\n,\n5\n,\n8\n,\n9\n,\n7\n};\n// on device\nsize_t\npBufferSizeInBytes\n=\n0\n;\nvoid\n*\npBuffer\n=\nNULL\n;\nint\n*\nP\n=\nNULL\n;\n// step 1: allocate buffer\ncusparseXcsrsort_bufferSizeExt\n(\nhandle\n,\nm\n,\nn\n,\nnnz\n,\ncsrRowPtr\n,\ncsrColInd\n,\n&\npBufferSizeInBytes\n);\ncudaMalloc\n(\n&\npBuffer\n,\nsizeof\n(\nchar\n)\n*\npBufferSizeInBytes\n);\n// step 2: setup permutation vector P to identity\ncudaMalloc\n(\n(\nvoid\n**\n)\n&\nP\n,\nsizeof\n(\nint\n)\n*\nnnz\n);\ncusparseCreateIdentityPermutation\n(\nhandle\n,\nnnz\n,\nP\n);\n// step 3: sort CSR format\ncusparseXcsrsort\n(\nhandle\n,\nm\n,\nn\n,\nnnz\n,\ndescrA\n,\ncsrRowPtr\n,\ncsrColInd\n,\nP\n,\npBuffer\n);\n// step 4: gather sorted csrVal\ncusparseDgthr\n(\nhandle\n,\nnnz\n,\ncsrVal\n,\ncsrVal_sorted\n,\nP\n,\nCUSPARSE_INDEX_BASE_ZERO\n);\nThe routine requires no extra storage if\npBuffer\n!=\nNULL\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available\nInput\nparameter\ndevice\nor\nhost\ndescription\nhandle\nhost\nhandle to the cuSPARSE library context.\nm\nhost\nnumber of rows of matrix\nA\n.\nn\nhost\nnumber of columns of matrix\nA\n.\nnnz\nhost\nnumber of nonzero elements of matrix\nA\n.\ncsrRowsPtr\ndevice\ninteger array of\nm+1\nelements that contains the start of every row and the end of the last row plus one.\ncsrColInd\ndevice\ninteger array of\nnnz\nunsorted column indices of\nA\n.\nP\ndevice\ninteger array of\nnnz\nunsorted map indices. To construct\ncsrVal\n, the user has to set\nP=0:1:(nnz-1)\n.\npBuffer\ndevice\nbuffer allocated by the user; the size is returned by\ncsrsort_bufferSizeExt()\n.\nOutput\nparameter\ndevice\nor\nhost\ndescription\ncsrColInd\ndevice\ninteger array of\nnnz\nsorted column indices of\nA\n.\nP\ndevice\ninteger array of\nnnz\nsorted map indices.\npBufferSizeInBytes\nhost\nnumber of bytes of the buffer.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.9.13.\ncusparseXcscsort()\n\ncusparseStatus_t\ncusparseXcscsort_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nconst\nint\n*\ncscColPtr\n,\nconst\nint\n*\ncscRowInd\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseXcscsort\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nint\n*\ncscColPtr\n,\nint\n*\ncscRowInd\n,\nint\n*\nP\n,\nvoid\n*\npBuffer\n)\nThis function sorts CSC format. The stable sorting is in-place.\nThe matrix type is regarded as\nCUSPARSE_MATRIX_TYPE_GENERAL\nimplicitly. In other words, any symmetric property is ignored.\nThis function\ncscsort()\nrequires buffer size returned by\ncscsort_bufferSizeExt()\n. The address of\npBuffer\nmust be multiple of 128 bytes. If not,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nThe parameter\nP\nis both input and output. If the user wants to compute sorted\ncscVal\n,\nP\nmust be set as 0:1:(nnz-1) before\ncscsort()\n, and after\ncscsort()\n, new sorted value array satisfies\ncscVal_sorted\n=\ncscVal(P)\n.\nThe general procedure is as follows:\n// A is a 3x3 sparse matrix, base-0\n//     | 1 2  |\n// A = | 4 0  |\n//     | 0 8  |\nconst\nint\nm\n=\n3\n;\nconst\nint\nn\n=\n2\n;\nconst\nint\nnnz\n=\n4\n;\ncscColPtr\n[\nn\n+\n1\n]\n=\n{\n0\n,\n2\n,\n4\n};\n// on device\ncscRowInd\n[\nnnz\n]\n=\n{\n1\n,\n0\n,\n2\n,\n0\n};\n// on device\ncscVal\n[\nnnz\n]\n=\n{\n4.0\n,\n1.0\n,\n8.0\n,\n2.0\n};\n// on device\nsize_t\npBufferSizeInBytes\n=\n0\n;\nvoid\n*\npBuffer\n=\nNULL\n;\nint\n*\nP\n=\nNULL\n;\n// step 1: allocate buffer\ncusparseXcscsort_bufferSizeExt\n(\nhandle\n,\nm\n,\nn\n,\nnnz\n,\ncscColPtr\n,\ncscRowInd\n,\n&\npBufferSizeInBytes\n);\ncudaMalloc\n(\n&\npBuffer\n,\nsizeof\n(\nchar\n)\n*\npBufferSizeInBytes\n);\n// step 2: setup permutation vector P to identity\ncudaMalloc\n(\n(\nvoid\n**\n)\n&\nP\n,\nsizeof\n(\nint\n)\n*\nnnz\n);\ncusparseCreateIdentityPermutation\n(\nhandle\n,\nnnz\n,\nP\n);\n// step 3: sort CSC format\ncusparseXcscsort\n(\nhandle\n,\nm\n,\nn\n,\nnnz\n,\ndescrA\n,\ncscColPtr\n,\ncscRowInd\n,\nP\n,\npBuffer\n);\n// step 4: gather sorted cscVal\ncusparseDgthr\n(\nhandle\n,\nnnz\n,\ncscVal\n,\ncscVal_sorted\n,\nP\n,\nCUSPARSE_INDEX_BASE_ZERO\n);\nThe routine requires no extra storage if\npBuffer\n!=\nNULL\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available\nInput\nparameter\ndevice\nor\nhost\ndescription\nhandle\nhost\nhandle to the cuSPARSE library context.\nm\nhost\nnumber of rows of matrix\nA\n.\nn\nhost\nnumber of columns of matrix\nA\n.\nnnz\nhost\nnumber of nonzero elements of matrix\nA\n.\ncscColPtr\ndevice\ninteger array of\nn+1\nelements that contains the start of every column and the end of the last column plus one.\ncscRowInd\ndevice\ninteger array of\nnnz\nunsorted row indices of\nA\n.\nP\ndevice\ninteger array of\nnnz\nunsorted map indices. To construct\ncscVal\n, the user has to set\nP=0:1:(nnz-1)\n.\npBuffer\ndevice\nbuffer allocated by the user; the size is returned by\ncscsort_bufferSizeExt()\n.\nOutput\nparameter\ndevice\nor\nhost\ndescription\ncscRowInd\ndevice\ninteger array of\nnnz\nsorted row indices of\nA\n.\nP\ndevice\ninteger array of\nnnz\nsorted map indices.\npBufferSizeInBytes\nhost\nnumber of bytes of the buffer.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.9.14.\ncusparseXcsru2csr() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseCreateCsru2csrInfo\n(\ncsru2csrInfo_t\n*\ninfo\n);\ncusparseStatus_t\ncusparseDestroyCsru2csrInfo\n(\ncsru2csrInfo_t\ninfo\n);\ncusparseStatus_t\ncusparseScsru2csr_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nfloat\n*\ncsrVal\n,\nconst\nint\n*\ncsrRowPtr\n,\nint\n*\ncsrColInd\n,\ncsru2csrInfo_t\ninfo\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseDcsru2csr_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\ndouble\n*\ncsrVal\n,\nconst\nint\n*\ncsrRowPtr\n,\nint\n*\ncsrColInd\n,\ncsru2csrInfo_t\ninfo\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseCcsru2csr_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\ncuComplex\n*\ncsrVal\n,\nconst\nint\n*\ncsrRowPtr\n,\nint\n*\ncsrColInd\n,\ncsru2csrInfo_t\ninfo\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseZcsru2csr_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\ncuDoubleComplex\n*\ncsrVal\n,\nconst\nint\n*\ncsrRowPtr\n,\nint\n*\ncsrColInd\n,\ncsru2csrInfo_t\ninfo\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseScsru2csr\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nfloat\n*\ncsrVal\n,\nconst\nint\n*\ncsrRowPtr\n,\nint\n*\ncsrColInd\n,\ncsru2csrInfo_t\ninfo\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDcsru2csr\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ndouble\n*\ncsrVal\n,\nconst\nint\n*\ncsrRowPtr\n,\nint\n*\ncsrColInd\n,\ncsru2csrInfo_t\ninfo\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseCcsru2csr\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuComplex\n*\ncsrVal\n,\nconst\nint\n*\ncsrRowPtr\n,\nint\n*\ncsrColInd\n,\ncsru2csrInfo_t\ninfo\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZcsru2csr\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuDoubleComplex\n*\ncsrVal\n,\nconst\nint\n*\ncsrRowPtr\n,\nint\n*\ncsrColInd\n,\ncsru2csrInfo_t\ninfo\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseScsr2csru\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nfloat\n*\ncsrVal\n,\nconst\nint\n*\ncsrRowPtr\n,\nint\n*\ncsrColInd\n,\ncsru2csrInfo_t\ninfo\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDcsr2csru\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ndouble\n*\ncsrVal\n,\nconst\nint\n*\ncsrRowPtr\n,\nint\n*\ncsrColInd\n,\ncsru2csrInfo_t\ninfo\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseCcsr2csru\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuComplex\n*\ncsrVal\n,\nconst\nint\n*\ncsrRowPtr\n,\nint\n*\ncsrColInd\n,\ncsru2csrInfo_t\ninfo\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseZcsr2csru\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\ncuDoubleComplex\n*\ncsrVal\n,\nconst\nint\n*\ncsrRowPtr\n,\nint\n*\ncsrColInd\n,\ncsru2csrInfo_t\ninfo\n,\nvoid\n*\npBuffer\n)\nThis function transfers unsorted CSR format to CSR format, and vice versa. The operation is in-place.\nThis function is a wrapper of\ncsrsort\nand\ngthr\n. The usecase is the following scenario.\nIf the user has a matrix\nA\nof CSR format which is unsorted, and implements his own code (which can be CPU or GPU kernel) based on this special order (for example, diagonal first, then lower triangle, then upper triangle), and wants to convert it to CSR format when calling CUSPARSE library, and then convert it back when doing something else on his/her kernel. For example, suppose the user wants to solve a linear system\nAx=b\nby the following iterative scheme\n\\[x^{(k+1)} = x^{(k)} + L^{(-1)}*(b - Ax^{(k)})\\]\nThe code heavily uses SpMV and triangular solve. Assume that the user has an in-house design of SpMV (Sparse Matrix-Vector multiplication) based on special order of\nA\n. However the user wants to use the cuSPARSE library for triangular solver. Then the following code can work:\ndo\nstep 1: compute residual vector\n\\(r = b - A x^k\\)\nby in-house SpMV\nstep 2: B := sort(A), and L is lower triangular part of B\n(only sort A once and keep the permutation vector)\nstep 3: solve\n\\(z = L (-1) * ( b - A x^k )\\)\nby cusparseXcsrsv\nstep 4: add correction\n\\(x^{k+1} = x^k+z\\)\nstep 5: A := unsort(B)\n(use permutation vector to get back the unsorted CSR)\nuntil convergence\nThe requirements of step 2 and step 5 are\nIn-place operation.\nThe permutation vector\nP\nis hidden in an opaque structure.\nNo\ncudaMalloc\ninside the conversion routine. Instead, the user has to provide the buffer explicitly.\nThe conversion between unsorted CSR and sorted CSR may needs several times, but the function only generates the permutation vector\nP\nonce.\nThe function is based on\ncsrsort\n,\ngather\nand\nscatter\noperations.\nThe operation is called\ncsru2csr\n, which means unsorted CSR to sorted CSR. Also we provide the inverse operation, called\ncsr2csru\n.\nIn order to keep the permutation vector invisible, we need an opaque structure called\ncsru2csrInfo\n. Then two functions (\ncusparseCreateCsru2csrInfo\n,\ncusparseDestroyCsru2csrInfo\n) are used to initialize and to destroy the opaque structure.\ncusparse[S|D|C|Z]csru2csr_bufferSizeExt\nreturns the size of the buffer. The permutation vector\nP\nis also allcated inside\ncsru2csrInfo\n. The lifetime of the permutation vector is the same as the lifetime of\ncsru2csrInfo\n.\ncusparse[S|D|C|Z]csru2csr\nperforms forward transformation from unsorted CSR to sorted CSR. First call uses csrsort to generate the permutation vector\nP\n, and subsequent call uses\nP\nto do transformation.\ncusparse[S|D|C|Z]csr2csru\nperforms backward transformation from sorted CSR to unsorted CSR.\nP\nis used to get unsorted form back.\nThe routine\ncusparse<t>csru2csr()\nhas the following properties:\nThe routine requires no extra storage if\npBuffer\n!=\nNULL\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available\nThe routine\ncusparse<t>csr2csru()\nhas the following properties if\npBuffer\n!=\nNULL\n:\nThe routine requires no extra storage\nThe routine supports asynchronous execution\nThe routine supports CUDA graph capture\nThe following tables describe parameters of\ncsr2csru_bufferSizeExt\nand\ncsr2csru\n.\nInput\nparameter\ndevice\nor\nhost\ndescription\nhandle\nhost\nhandle to the cuSPARSE library context.\nm\nhost\nnumber of rows of matrix\nA\n.\nn\nhost\nnumber of columns of matrix\nA\n.\nnnz\nhost\nnumber of nonzero elements of matrix\nA\n.\ndescrA\nhost\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n, Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrVal\ndevice\n<type> array of nnz unsorted nonzero elements of matrix\nA\n.\ncsrRowsPtr\ndevice\ninteger array of\nm+1\nelements that contains the start of every row and the end of the last row plus one.\ncsrColInd\ndevice\ninteger array of\nnnz\nunsorted column indices of\nA\n.\ninfo\nhost\nopaque structure initialized using\ncusparseCreateCsru2csrInfo()\n.\npBuffer\ndevice\nbuffer allocated by the user; the size is returned by\ncsru2csr_bufferSizeExt()\n.\nOutput\nparameter\ndevice\nor\nhost\ndescription\ncsrVal\ndevice\n<type> array of nnz sorted nonzero elements of matrix\nA\n.\ncsrColInd\ndevice\ninteger array of\nnnz\nsorted column indices of\nA\n.\npBufferSizeInBytes\nhost\nnumber of bytes of the buffer.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.9.15.\ncusparseXpruneDense2csr() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseHpruneDense2csr_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\n__half\n*\nA\n,\nint\nlda\n,\nconst\n__half\n*\nthreshold\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nconst\n__half\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nconst\nint\n*\ncsrColIndC\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseSpruneDense2csr_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nthreshold\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nconst\nfloat\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nconst\nint\n*\ncsrColIndC\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseDpruneDense2csr_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nthreshold\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nconst\ndouble\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nconst\nint\n*\ncsrColIndC\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseHpruneDense2csrNnz\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\n__half\n*\nA\n,\nint\nlda\n,\nconst\n__half\n*\nthreshold\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nint\n*\ncsrRowPtrC\n,\nint\n*\nnnzTotalDevHostPtr\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseSpruneDense2csrNnz\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nthreshold\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nint\n*\ncsrRowPtrC\n,\nint\n*\nnnzTotalDevHostPtr\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDpruneDense2csrNnz\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nthreshold\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nint\n*\ncsrRowPtrC\n,\nint\n*\nnnzTotalDevHostPtr\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseHpruneDense2csr\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\n__half\n*\nA\n,\nint\nlda\n,\nconst\n__half\n*\nthreshold\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\n__half\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nint\n*\ncsrColIndC\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseSpruneDense2csr\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nthreshold\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nfloat\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nint\n*\ncsrColIndC\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDpruneDense2csr\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nthreshold\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\ndouble\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nint\n*\ncsrColIndC\n,\nvoid\n*\npBuffer\n)\nThis function prunes a dense matrix to a sparse matrix with CSR format.\nGiven a dense matrix\nA\nand a non-negative value\nthreshold\n, the function returns a sparse matrix\nC\n, defined by\n\\[\\begin{split}\\begin{matrix}\n{{C(i,j)} = {A(i,j)}} & \\text{if\\ |A(i,j)|\\ >\\ threshold} \\\\\n\\end{matrix}\\end{split}\\]\nThe implementation adopts a two-step approach to do the conversion. First, the user allocates\ncsrRowPtrC\nof\nm+1\nelements and uses function\npruneDense2csrNnz()\nto determine the number of nonzeros columns per row. Second, the user gathers\nnnzC\n(number of nonzeros of matrix\nC\n) from either\n(nnzC=*nnzTotalDevHostPtr)\nor\n(nnzC=csrRowPtrC[m]-csrRowPtrC[0])\nand allocates\ncsrValC\nof\nnnzC\nelements and\ncsrColIndC\nof\nnnzC\nintegers. Finally function\npruneDense2csr()\nis called to complete the conversion.\nThe user must obtain the size of the buffer required by\npruneDense2csr()\nby calling\npruneDense2csr_bufferSizeExt()\n, allocate the buffer, and pass the buffer pointer to\npruneDense2csr()\n.\nThe routine\ncusparse<t>pruneDense2csrNnz()\nhas the following properties:\nThis function requires temporary extra storage that is allocated internally.\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available.\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available.\nThe routine\ncusparse<t>DpruneDense2csr()\nhas the following properties:\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nparameter\ndevice\nor\nhost\ndescription\nhandle\nhost\nhandle to the cuSPARSE library context.\nm\nhost\nnumber of rows of matrix\nA\n.\nn\nhost\nnumber of columns of matrix\nA\n.\nA\ndevice\narray of dimension (lda, n).\nlda\ndevice\nleading dimension of\nA\n. It must be at least max(1, m).\nthreshold\nhost\nor\ndevice\na value to drop the entries of A.\nthreshold\ncan point to a device memory or host memory.\ndescrC\nhost\nthe descriptor of matrix\nC\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n, Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\npBuffer\ndevice\nbuffer allocated by the user; the size is returned by\npruneDense2csr_bufferSizeExt()\n.\nOutput\nparameter\ndevice\nor\nhost\ndescription\nnnzTotalDevHostPtr\ndevice\nor\nhost\ntotal number of nonzero of matrix\nC\n.\nnnzTotalDevHostPtr\ncan point to a device memory or host memory.\ncsrValC\ndevice\n<type> array of\nnnzC\nnonzero elements of matrix\nC\n.\ncsrRowsPtrC\ndevice\ninteger array of\nm+1\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndC\ndevice\ninteger array of\nnnzC\ncolumn indices of\nC\n.\npBufferSizeInBytes\nhost\nnumber of bytes of the buffer.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.9.16.\ncusparseXpruneCsr2csr()  [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseHpruneCsr2csr_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\n__half\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\n__half\n*\nthreshold\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nconst\n__half\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nconst\nint\n*\ncsrColIndC\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseSpruneCsr2csr_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\nfloat\n*\nthreshold\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nconst\nfloat\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nconst\nint\n*\ncsrColIndC\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseDpruneCsr2csr_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\ndouble\n*\nthreshold\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nconst\ndouble\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nconst\nint\n*\ncsrColIndC\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseHpruneCsr2csrNnz\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\n__half\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\n__half\n*\nthreshold\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nint\n*\ncsrRowPtrC\n,\nint\n*\nnnzTotalDevHostPtr\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseSpruneCsr2csrNnz\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\nfloat\n*\nthreshold\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nint\n*\ncsrRowPtrC\n,\nint\n*\nnnzTotalDevHostPtr\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDpruneCsr2csrNnz\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\ndouble\n*\nthreshold\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nint\n*\ncsrRowPtrC\n,\nint\n*\nnnzTotalDevHostPtr\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseHpruneCsr2csr\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\n__half\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\n__half\n*\nthreshold\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\n__half\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nint\n*\ncsrColIndC\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseSpruneCsr2csr\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\nfloat\n*\nthreshold\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nfloat\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nint\n*\ncsrColIndC\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDpruneCsr2csr\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\ndouble\n*\nthreshold\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\ndouble\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nint\n*\ncsrColIndC\n,\nvoid\n*\npBuffer\n)\nThis function prunes a sparse matrix to a sparse matrix with CSR format.\nGiven a sparse matrix\nA\nand a non-negative value\nthreshold\n, the function returns a sparse matrix\nC\n, defined by\n\\[\\begin{split}\\begin{matrix}\n{{C(i,j)} = {A(i,j)}} & \\text{if |A(i,j)| > threshold} \\\\\n\\end{matrix}\\end{split}\\]\nThe implementation adopts a two-step approach to do the conversion. First, the user allocates\ncsrRowPtrC\nof\nm+1\nelements and uses function\npruneCsr2csrNnz()\nto determine the number of nonzeros columns per row. Second, the user gathers\nnnzC\n(number of nonzeros of matrix\nC\n) from either\n(nnzC=*nnzTotalDevHostPtr)\nor\n(nnzC=csrRowPtrC[m]-csrRowPtrC[0])\nand allocates\ncsrValC\nof\nnnzC\nelements and\ncsrColIndC\nof\nnnzC\nintegers. Finally function\npruneCsr2csr()\nis called to complete the conversion.\nThe user must obtain the size of the buffer required by\npruneCsr2csr()\nby calling\npruneCsr2csr_bufferSizeExt()\n, allocate the buffer, and pass the buffer pointer to\npruneCsr2csr()\n.\nThe routine\ncusparse<t>pruneCsr2csrNnz()\nhas the following properties:\nThis function requires temporary extra storage that is allocated internally.\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available.\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available.\nThe routine\ncusparse<t>pruneCsr2csr()\nhas the following properties:\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nparameter\ndevice\nor\nhost\ndescription\nhandle\nhost\nhandle to the cuSPARSE library context.\nm\nhost\nnumber of rows of matrix\nA\n.\nn\nhost\nnumber of columns of matrix\nA\n.\nnnzA\nhost\nnumber of nonzeros of matrix\nA\n.\ndescrA\nhost\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n, Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrValA\ndevice\n<type> array of\nnnzA\nnonzero elements of matrix\nA\n.\ncsrRowsPtrA\ndevice\ninteger array of\nm+1\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndA\ndevice\ninteger array of\nnnzA\ncolumn indices of\nA\n.\nthreshold\nhost\nor\ndevice\na value to drop the entries of A.\nthreshold\ncan point to a device memory or host memory.\ndescrC\nhost\nthe descriptor of matrix\nC\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n, Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\npBuffer\ndevice\nbuffer allocated by the user; the size is returned by\npruneCsr2csr_bufferSizeExt()\n.\nOutput\nparameter\ndevice\nor\nhost\ndescription\nnnzTotalDevHostPtr\ndevice\nor\nhost\ntotal number of nonzero of matrix\nC\n.\nnnzTotalDevHostPtr\ncan point to a device memory or host memory.\ncsrValC\ndevice\n<type> array of\nnnzC\nnonzero elements of matrix\nC\n.\ncsrRowsPtrC\ndevice\ninteger array of\nm+1\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndC\ndevice\ninteger array of\nnnzC\ncolumn indices of\nC\n.\npBufferSizeInBytes\nhost\nnumber of bytes of the buffer.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.9.17.\ncusparseXpruneDense2csrPercentage()  [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseHpruneDense2csrByPercentage_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\n__half\n*\nA\n,\nint\nlda\n,\nfloat\npercentage\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nconst\n__half\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nconst\nint\n*\ncsrColIndC\n,\npruneInfo_t\ninfo\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseSpruneDense2csrByPercentage_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\npercentage\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nconst\nfloat\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nconst\nint\n*\ncsrColIndC\n,\npruneInfo_t\ninfo\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseDpruneDense2csrByPercentage_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nfloat\npercentage\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nconst\ndouble\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nconst\nint\n*\ncsrColIndC\n,\npruneInfo_t\ninfo\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseHpruneDense2csrNnzByPercentage\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\n__half\n*\nA\n,\nint\nlda\n,\nfloat\npercentage\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nint\n*\ncsrRowPtrC\n,\nint\n*\nnnzTotalDevHostPtr\n,\npruneInfo_t\ninfo\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseSpruneDense2csrNnzByPercentage\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\npercentage\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nint\n*\ncsrRowPtrC\n,\nint\n*\nnnzTotalDevHostPtr\n,\npruneInfo_t\ninfo\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDpruneDense2csrNnzByPercentage\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nfloat\npercentage\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nint\n*\ncsrRowPtrC\n,\nint\n*\nnnzTotalDevHostPtr\n,\npruneInfo_t\ninfo\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseHpruneDense2csrByPercentage\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\n__half\n*\nA\n,\nint\nlda\n,\nfloat\npercentage\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\n__half\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nint\n*\ncsrColIndC\n,\npruneInfo_t\ninfo\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseSpruneDense2csrByPercentage\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\npercentage\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nfloat\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nint\n*\ncsrColIndC\n,\npruneInfo_t\ninfo\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDpruneDense2csrByPercentage\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nfloat\npercentage\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\ndouble\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nint\n*\ncsrColIndC\n,\npruneInfo_t\ninfo\n,\nvoid\n*\npBuffer\n)\nThis function prunes a dense matrix to a sparse matrix by percentage.\nGiven a dense matrix\nA\nand a non-negative value\npercentage\n, the function computes sparse matrix\nC\nby the following three steps:\nStep 1: sort absolute value of\nA\nin ascending order.\n\\[\\begin{split}\\begin{matrix}\n{key\\ :=\\ sort(\\ |A|\\ )} \\\\\n\\end{matrix}\\end{split}\\]\nStep 2: choose threshold by the parameter\npercentage\n\\[\\begin{split}\\begin{matrix}\n{pos\\ =\\ ceil(m*n*(percentage/100))\\ -\\ 1} \\\\\n{pos\\ =\\ min(pos,\\ m*n-1)} \\\\\n{pos\\ =\\ max(pos,\\ 0)} \\\\\n{threshold\\ =\\ key\\lbrack pos\\rbrack} \\\\\n\\end{matrix}\\end{split}\\]\nStep 3: call\npruneDense2csr()\nby with the parameter\nthreshold\n.\nThe implementation adopts a two-step approach to do the conversion. First, the user allocates\ncsrRowPtrC\nof\nm+1\nelements and uses function\npruneDense2csrNnzByPercentage()\nto determine the number of nonzeros columns per row. Second, the user gathers\nnnzC\n(number of nonzeros of matrix\nC\n) from either\n(nnzC=*nnzTotalDevHostPtr)\nor\n(nnzC=csrRowPtrC[m]-csrRowPtrC[0])\nand allocates\ncsrValC\nof\nnnzC\nelements and\ncsrColIndC\nof\nnnzC\nintegers. Finally function\npruneDense2csrByPercentage()\nis called to complete the conversion.\nThe user must obtain the size of the buffer required by\npruneDense2csrByPercentage()\nby calling\npruneDense2csrByPercentage_bufferSizeExt()\n, allocate the buffer, and pass the buffer pointer to\npruneDense2csrByPercentage()\n.\nRemark 1: the value of\npercentage\nmust be not greater than 100. Otherwise,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nRemark 2: the zeros of\nA\nare not ignored. All entries are sorted, including zeros. This is different from\npruneCsr2csrByPercentage()\nThe routine\ncusparse<t>pruneDense2csrNnzByPercentage()\nhas the following properties:\nThis function requires temporary extra storage that is allocated internally.\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available.\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available.\nThe routine\ncusparse<t>pruneDense2csrByPercentage()\nhas the following properties:\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nparameter\ndevice\nor\nhost\ndescription\nhandle\nhost\nhandle to the cuSPARSE library context.\nm\nhost\nnumber of rows of matrix\nA\n.\nn\nhost\nnumber of columns of matrix\nA\n.\nA\ndevice\narray of dimension (lda, n).\nlda\ndevice\nleading dimension of\nA\n. It must be at least max(1, m).\npercentage\nhost\npercentage <=100 and percentage >= 0\ndescrC\nhost\nthe descriptor of matrix\nC\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n, Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\npBuffer\ndevice\nbuffer allocated by the user; the size is returned by\npruneDense2csrByPercentage_bufferSizeExt()\n.\nOutput\nparameter\ndevice\nor\nhost\ndescription\nnnzTotalDevHostPtr\ndevice\nor\nhost\ntotal number of nonzero of matrix\nC\n.\nnnzTotalDevHostPtr\ncan point to a device memory or host memory.\ncsrValC\ndevice\n<type> array of\nnnzC\nnonzero elements of matrix\nC\n.\ncsrRowsPtrC\ndevice\ninteger array of\nm+1\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndC\ndevice\ninteger array of\nnnzC\ncolumn indices of\nC\n.\npBufferSizeInBytes\nhost\nnumber of bytes of the buffer.\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.9.18.\ncusparseXpruneCsr2csrByPercentage() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseHpruneCsr2csrByPercentage_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\n__half\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nfloat\npercentage\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nconst\n__half\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nconst\nint\n*\ncsrColIndC\n,\npruneInfo_t\ninfo\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseSpruneCsr2csrByPercentage_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nfloat\npercentage\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nconst\nfloat\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nconst\nint\n*\ncsrColIndC\n,\npruneInfo_t\ninfo\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseDpruneCsr2csrByPercentage_bufferSizeExt\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nfloat\npercentage\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nconst\ndouble\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nconst\nint\n*\ncsrColIndC\n,\npruneInfo_t\ninfo\n,\nsize_t\n*\npBufferSizeInBytes\n)\ncusparseStatus_t\ncusparseHpruneCsr2csrNnzByPercentage\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\n__half\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nfloat\npercentage\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nint\n*\ncsrRowPtrC\n,\nint\n*\nnnzTotalDevHostPtr\n,\npruneInfo_t\ninfo\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseSpruneCsr2csrNnzByPercentage\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nfloat\npercentage\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nint\n*\ncsrRowPtrC\n,\nint\n*\nnnzTotalDevHostPtr\n,\npruneInfo_t\ninfo\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDpruneCsr2csrNnzByPercentage\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nfloat\npercentage\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nint\n*\ncsrRowPtrC\n,\nint\n*\nnnzTotalDevHostPtr\n,\npruneInfo_t\ninfo\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseHpruneCsr2csrByPercentage\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\n__half\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nfloat\npercentage\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\n__half\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nint\n*\ncsrColIndC\n,\npruneInfo_t\ninfo\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseSpruneCsr2csrByPercentage\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nfloat\npercentage\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\nfloat\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nint\n*\ncsrColIndC\n,\npruneInfo_t\ninfo\n,\nvoid\n*\npBuffer\n)\ncusparseStatus_t\ncusparseDpruneCsr2csrByPercentage\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nfloat\npercentage\n,\nconst\ncusparseMatDescr_t\ndescrC\n,\ndouble\n*\ncsrValC\n,\nconst\nint\n*\ncsrRowPtrC\n,\nint\n*\ncsrColIndC\n,\npruneInfo_t\ninfo\n,\nvoid\n*\npBuffer\n)\nThis function prunes a sparse matrix to a sparse matrix by percentage.\nGiven a sparse matrix\nA\nand a non-negative value\npercentage\n, the function computes sparse matrix\nC\nby the following three steps:\nStep 1: Sort absolute value of\nA\nin ascending order:\n\\[\\begin{split}\\begin{matrix}\n{key\\ :=\\ sort(\\ \\|csrValA\\|\\ )} \\\\\n\\end{matrix}\\end{split}\\]\nStep 2: Choose threshold by the parameter\npercentage\n:\n\\[\\begin{split}\\begin{matrix}\n{pos\\ =\\ ceil(nnzA*(percentage/100))\\ -\\ 1} \\\\\n{pos\\ =\\ min(pos,\\ nnzA-1)} \\\\\n{pos\\ =\\ max(pos,\\ 0)} \\\\\n{threshold\\ =\\ key\\lbrack pos\\rbrack} \\\\\n\\end{matrix}\\end{split}\\]\nStep 3: Call\npruneCsr2csr()\nby with the parameter\nthreshold\n.\nThe implementation adopts a two-step approach to do the conversion. First, the user allocates\ncsrRowPtrC\nof\nm+1\nelements and uses function\npruneCsr2csrNnzByPercentage()\nto determine the number of nonzeros columns per row. Second, the user gathers\nnnzC\n(number of nonzeros of matrix\nC\n) from either\n(nnzC=*nnzTotalDevHostPtr)\nor\n(nnzC=csrRowPtrC[m]-csrRowPtrC[0])\nand allocates\ncsrValC\nof\nnnzC\nelements and\ncsrColIndC\nof\nnnzC\nintegers. Finally function\npruneCsr2csrByPercentage()\nis called to complete the conversion.\nThe user must obtain the size of the buffer required by\npruneCsr2csrByPercentage()\nby calling\npruneCsr2csrByPercentage_bufferSizeExt()\n, allocate the buffer, and pass the buffer pointer to\npruneCsr2csrByPercentage()\n.\nRemark 1: the value of\npercentage\nmust be not greater than 100. Otherwise,\nCUSPARSE_STATUS_INVALID_VALUE\nis returned.\nThe routine\ncusparse<t>pruneCsr2csrNnzByPercentage()\nhas the following properties:\nThis function requires temporary extra storage that is allocated internally.\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available.\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available.\nThe routine\ncusparse<t>pruneCsr2csrByPercentage()\nhas the following properties:\nThe routine requires no extra storage.\nThe routine supports asynchronous execution.\nThe routine supports CUDA graph capture.\nInput\nparameter\ndevice\nor\nhost\ndescription\nhandle\nhost\nhandle to the cuSPARSE library context.\nm\nhost\nnumber of rows of matrix\nA\n.\nn\nhost\nnumber of columns of matrix\nA\n.\nnnzA\nhost\nnumber of nonzeros of matrix\nA\n.\ndescrA\nhost\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n, Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrValA\ndevice\n<type> array of\nnnzA\nnonzero elements of matrix\nA\n.\ncsrRowsPtrA\ndevice\ninteger array of\nm+1\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndA\ndevice\ninteger array of\nnnzA\ncolumn indices of\nA\n.\npercentage\nhost\npercentage <=100 and percentage >= 0\ndescrC\nhost\nthe descriptor of matrix\nC\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n, Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\npBuffer\ndevice\nbuffer allocated by the user; the size is returned by\npruneCsr2csrByPercentage_bufferSizeExt()\n.\nOutput\nparameter\ndevice\nor\nhost\ndescription\nnnzTotalDevHostPtr\ndevice\nor\nhost\ntotal number of nonzero of matrix\nC\n.\nnnzTotalDevHostPtr\ncan point to a device memory or host memory\ncsrValC\ndevice\n<type> array of\nnnzC\nnonzero elements of matrix\nC\n.\ncsrRowsPtrC\ndevice\ninteger array of\nm+1\nelements that contains the start of every row and the end of the last row plus one\ncsrColIndC\ndevice\ninteger array of\nnnzC\ncolumn indices of\nC\npBufferSizeInBytes\nhost\nnumber of bytes of the buffer\nSee\ncusparseStatus_t\nfor the description of the return status.\n5.9.19.\ncusparse<t>nnz_compress() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseSnnz_compress\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nconst\ncusparseMatDescr_t\ndescr\n,\nconst\nfloat\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nint\n*\nnnzPerRow\n,\nint\n*\nnnzC\n,\nfloat\ntol\n)\ncusparseStatus_t\ncusparseDnnz_compress\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nconst\ncusparseMatDescr_t\ndescr\n,\nconst\ndouble\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nint\n*\nnnzPerRow\n,\nint\n*\nnnzC\n,\ndouble\ntol\n)\ncusparseStatus_t\ncusparseCnnz_compress\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nconst\ncusparseMatDescr_t\ndescr\n,\nconst\ncuComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nint\n*\nnnzPerRow\n,\nint\n*\nnnzC\n,\ncuComplex\ntol\n)\ncusparseStatus_t\ncusparseZnnz_compress\n(\ncusparseHandle_t\nhandle\n,\nint\nm\n,\nconst\ncusparseMatDescr_t\ndescr\n,\nconst\ncuDoubleComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nint\n*\nnnzPerRow\n,\nint\n*\nnnzC\n,\ncuDoubleComplex\ntol\n)\nThis function is the step one to convert from csr format to compressed csr format.\nGiven a sparse matrix A and a non-negative value threshold, the function returns nnzPerRow(the number of nonzeros columns per row) and nnzC(the total number of nonzeros) of a sparse matrix C, defined by\n\\[\\begin{split}\\begin{matrix}\n{{C(i,j)} = {A(i,j)}} & \\text{if\\ |A(i,j)|\\ >\\ threshold} \\\\\n\\end{matrix}\\end{split}\\]\nA key assumption for the cuComplex and cuDoubleComplex case is that this tolerance is given as the real part. For example\ntol\n=\n1e-8\n+\n0*i\nand we extract cureal, that is the x component of this struct.\nThis function requires temporary extra storage that is allocated internally.\nThe routine supports asynchronous execution if the Stream Ordered Memory Allocator is available.\nThe routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available.\nInput\nhandle\nhandle to the cuSPARSE library context.\nm\nnumber of rows of matrix\nA\n.\ndescrA\nthe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrValA\ncsr noncompressed values array\ncsrRowPtrA\nthe corresponding input noncompressed row pointer.\ntol\nnon-negative tolerance to determine if a number less than or equal to it.\nOutput\nnnzPerRow\nthis array contains the number of elements whose absolute values are greater than tol per row.\nnnzC\nhost/device pointer of the total number of elements whose absolute values are greater than tol.\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.\ncuSPARSE Generic APIs\n\nThe cuSPARSE Generic APIs allow computing the most common sparse linear algebra operations, such as sparse matrix-vector (SpMV) and sparse matrix-matrix multiplication (SpMM), in a flexible way. The new APIs have the following capabilities and features:\nSet matrix data layouts, number of batches, and storage formats (for example, CSR, COO, and so on).\nSet input/output/compute data types. This also allows mixed data-type computation.\nSet types of sparse vector/matrix indices (for example, 32-bit, 64-bit).\nChoose the algorithm for the computation.\nGuarantee external device memory for internal operations.\nProvide extensive consistency checks across input matrices and vectors. This includes the validation of sizes, data types, layout, allowed operations, etc.\nProvide constant descriptors for vector and matrix inputs to support const-safe interface and guarantee that the APIs do not modify their inputs.\n6.1.\nGeneric Types Reference\n\nThe cuSPARSE generic type references are described in this section.\n6.1.1.\ncusparseFormat_t\n\nThis type indicates the format of the sparse matrix.\nSee\ncuSPARSE Storage Formats\nfor their description.\nValue\nMeaning\nCUSPARSE_FORMAT_COO\nThe matrix is stored in Coordinate (COO) format organized in\nStructure of Arrays (SoA)\nlayout\nCUSPARSE_FORMAT_CSR\nThe matrix is stored in Compressed Sparse Row (CSR) format\nCUSPARSE_FORMAT_CSC\nThe matrix is stored in Compressed Sparse Column (CSC) format\nCUSPARSE_FORMAT_BLOCKED_ELL\nThe matrix is stored in Blocked-Ellpack (Blocked-ELL) format\nCUSPARSE_FORMAT_SLICED_ELL\nThe matrix is stored in Sliced-Ellpack (Sliced-ELL) format\nCUSPARSE_FORMAT_BSR\nThe matrix is stored in Block Sparse Row (BSR) format\n6.1.2.\ncusparseOrder_t\n\nThis type indicates the memory layout of a dense matrix.\nValue\nMeaning\nCUSPARSE_ORDER_ROW\nThe matrix is stored in row-major\nCUSPARSE_ORDER_COL\nThe matrix is stored in column-major\n6.1.3.\ncusparseIndexType_t\n\nThis type indicates the index type for representing the sparse matrix indices.\nValue\nMeaning\nCUSPARSE_INDEX_32I\n32-bit signed integer [0, 2^31 - 1]\nCUSPARSE_INDEX_64I\n64-bit signed integer [0, 2^63 - 1]\n6.2.\nDense Vector APIs\n\nThe cuSPARSE helper functions for dense vector descriptor are described in this section.\nSee the\nDense Vector Format\nsection for the detailed description of the storage format.\n6.2.1.\ncusparseCreateDnVec()\n\ncusparseStatus_t\ncusparseCreateDnVec\n(\ncusparseDnVecDescr_t\n*\ndnVecDescr\n,\nint64_t\nsize\n,\nvoid\n*\nvalues\n,\ncudaDataType\nvalueType\n)\ncusparseStatus_t\ncusparseCreateConstDnVec\n(\ncusparseConstDnVecDescr_t\n*\ndnVecDescr\n,\nint64_t\nsize\n,\nconst\nvoid\n*\nvalues\n,\ncudaDataType\nvalueType\n)\nThis function initializes the dense vector descriptor\ndnVecDescr\n.\nParam.\nMemory\nIn/out\nMeaning\ndnVecDescr\nHOST\nOUT\nDense vector descriptor\nsize\nHOST\nIN\nSize of the dense vector\nvalues\nDEVICE\nIN\nValues of the dense vector. Array with\nsize\nelements\nvalueType\nHOST\nIN\nEnumerator specifying the datatype of\nvalues\ncusparseCreateDnVec()\nhas the following constraints:\nvalues\nmust be aligned to the size of the datatype specified by\nvalueType\n. Refer to\ncudaDataType_t\nfor the description of the datatypes.\nRefer to\ncusparseStatus_t\nfor the description of the return status.\n6.2.2.\ncusparseDestroyDnVec()\n\ncusparseStatus_t\ncusparseDestroyDnVec\n(\ncusparseConstDnVecDescr_t\ndnVecDescr\n)\n// non-const descriptor supported\nThis function releases the host memory allocated for the dense vector descriptor\ndnVecDescr\n.\nParam.\nMemory\nIn/out\nMeaning\ndnVecDescr\nHOST\nIN\nDense vector descriptor\nRefer to\ncusparseStatus_t\nfor the description of the return status.\n6.2.3.\ncusparseDnVecGet()\n\ncusparseStatus_t\ncusparseDnVecGet\n(\ncusparseDnVecDescr_t\ndnVecDescr\n,\nint64_t\n*\nsize\n,\nvoid\n**\nvalues\n,\ncudaDataType\n*\nvalueType\n)\ncusparseStatus_t\ncusparseConstDnVecGet\n(\ncusparseConstDnVecDescr_t\ndnVecDescr\n,\nint64_t\n*\nsize\n,\nconst\nvoid\n**\nvalues\n,\ncudaDataType\n*\nvalueType\n)\nThis function returns the fields of the dense vector descriptor\ndnVecDescr\n.\nParam.\nMemory\nIn/out\nMeaning\ndnVecDescr\nHOST\nIN\nDense vector descriptor\nsize\nHOST\nOUT\nSize of the dense vector\nvalues\nDEVICE\nOUT\nValues of the dense vector. Array with\nnnz\nelements\nvalueType\nHOST\nOUT\nEnumerator specifying the datatype of\nvalues\nRefer to\ncusparseStatus_t\nfor the description of the return status.\n6.2.4.\ncusparseDnVecGetValues()\n\ncusparseStatus_t\ncusparseDnVecGetValues\n(\ncusparseDnVecDescr_t\ndnVecDescr\n,\nvoid\n**\nvalues\n)\ncusparseStatus_t\ncusparseConstDnVecGetValues\n(\ncusparseConstDnVecDescr_t\ndnVecDescr\n,\nconst\nvoid\n**\nvalues\n)\nThis function returns the\nvalues\nfield of the dense vector descriptor\ndnVecDescr\n.\nParam.\nMemory\nIn/out\nMeaning\ndnVecDescr\nHOST\nIN\nDense vector descriptor\nvalues\nDEVICE\nOUT\nValues of the dense vector\nRefer to\ncusparseStatus_t\nfor the description of the return status.\n6.2.5.\ncusparseDnVecSetValues()\n\ncusparseStatus_t\ncusparseDnVecSetValues\n(\ncusparseDnVecDescr_t\ndnVecDescr\n,\nvoid\n*\nvalues\n)\nThis function set the\nvalues\nfield of the dense vector descriptor\ndnVecDescr\n.\nParam.\nMemory\nIn/out\nMeaning\ndnVecDescr\nHOST\nIN\nDense vector descriptor\nvalues\nDEVICE\nIN\nValues of the dense vector. Array with\nsize\nelements\ncusparseDnVecSetValues()\nhas the following constraints:\nvalues\nmust be aligned to the size of the datatype specified in\ndnVecDescr\n. Refer to\ncudaDataType_t\nfor the description of the datatypes.\nRefer to\ncusparseStatus_t\nfor the description of the return status.\n6.3.\nSparse Vector APIs\n\nThe cuSPARSE helper functions for sparse vector descriptor are described in this section.\nSee the\nSparse Vector Format\nsection for the detailed description of the storage format.\n6.3.1.\ncusparseCreateSpVec()\n\ncusparseStatus_t\ncusparseCreateSpVec\n(\ncusparseSpVecDescr_t\n*\nspVecDescr\n,\nint64_t\nsize\n,\nint64_t\nnnz\n,\nvoid\n*\nindices\n,\nvoid\n*\nvalues\n,\ncusparseIndexType_t\nidxType\n,\ncusparseIndexBase_t\nidxBase\n,\ncudaDataType\nvalueType\n)\ncusparseStatus_t\ncusparseCreateConstSpVec\n(\ncusparseConstSpVecDescr_t\n*\nspVecDescr\n,\nint64_t\nsize\n,\nint64_t\nnnz\n,\nconst\nvoid\n*\nindices\n,\nconst\nvoid\n*\nvalues\n,\ncusparseIndexType_t\nidxType\n,\ncusparseIndexBase_t\nidxBase\n,\ncudaDataType\nvalueType\n)\nThis function initializes the sparse matrix descriptor\nspVecDescr\n.\nParam.\nMemory\nIn/out\nMeaning\nspVecDescr\nHOST\nOUT\nSparse vector descriptor\nsize\nHOST\nIN\nSize of the sparse vector\nnnz\nHOST\nIN\nNumber of non-zero entries of the sparse vector\nindices\nDEVICE\nIN\nIndices of the sparse vector. Array with\nnnz\nelements\nvalues\nDEVICE\nIN\nValues of the sparse vector. Array with\nnnz\nelements\nidxType\nHOST\nIN\nEnumerator specifying the data type of\nindices\nidxBase\nHOST\nIN\nEnumerator specifying the the index base of\nindices\nvalueType\nHOST\nIN\nEnumerator specifying the datatype of\nvalues\ncusparseCreateSpVec()\nhas the following constraints:\nindices\nand\nvalues\nmust be aligned to the size of the datatypes specified by\nidxType\nand\nvalueType\n, respectively. See\ncudaDataType_t\nfor the description of the datatypes.\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.3.2.\ncusparseDestroySpVec()\n\ncusparseStatus_t\ncusparseDestroySpVec\n(\ncusparseConstSpVecDescr_t\nspVecDescr\n)\n// non-const descriptor supported\nThis function releases the host memory allocated for the sparse vector descriptor\nspVecDescr\n.\nParam.\nMemory\nIn/out\nMeaning\nspVecDescr\nHOST\nIN\nSparse vector descriptor\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.3.3.\ncusparseSpVecGet()\n\ncusparseStatus_t\ncusparseSpVecGet\n(\ncusparseSpVecDescr_t\nspVecDescr\n,\nint64_t\n*\nsize\n,\nint64_t\n*\nnnz\n,\nvoid\n**\nindices\n,\nvoid\n**\nvalues\n,\ncusparseIndexType_t\n*\nidxType\n,\ncusparseIndexBase_t\n*\nidxBase\n,\ncudaDataType\n*\nvalueType\n)\ncusparseStatus_t\ncusparseConstSpVecGet\n(\ncusparseConstSpVecDescr_t\nspVecDescr\n,\nint64_t\n*\nsize\n,\nint64_t\n*\nnnz\n,\nconst\nvoid\n**\nindices\n,\nconst\nvoid\n**\nvalues\n,\ncusparseIndexType_t\n*\nidxType\n,\ncusparseIndexBase_t\n*\nidxBase\n,\ncudaDataType\n*\nvalueType\n)\nThis function returns the fields of the sparse vector descriptor\nspVecDescr\n.\nParam.\nMemory\nIn/out\nMeaning\nspVecDescr\nHOST\nIN\nSparse vector descriptor\nsize\nHOST\nOUT\nSize of the sparse vector\nnnz\nHOST\nOUT\nNumber of non-zero entries of the sparse vector\nindices\nDEVICE\nOUT\nIndices of the sparse vector. Array with\nnnz\nelements\nvalues\nDEVICE\nOUT\nValues of the sparse vector. Array with\nnnz\nelements\nidxType\nHOST\nOUT\nEnumerator specifying the data type of\nindices\nidxBase\nHOST\nOUT\nEnumerator specifying the the index base of\nindices\nvalueType\nHOST\nOUT\nEnumerator specifying the datatype of\nvalues\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.3.4.\ncusparseSpVecGetIndexBase()\n\ncusparseStatus_t\ncusparseSpVecGetIndexBase\n(\ncusparseConstSpVecDescr_t\nspVecDescr\n,\n// non-const descriptor supported\ncusparseIndexBase_t\n*\nidxBase\n)\nThis function returns the\nidxBase\nfield of the sparse vector descriptor\nspVecDescr\n.\nParam.\nMemory\nIn/out\nMeaning\nspVecDescr\nHOST\nIN\nSparse vector descriptor\nidxBase\nHOST\nOUT\nEnumerator specifying the the index base of\nindices\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.3.5.\ncusparseSpVecGetValues()\n\ncusparseStatus_t\ncusparseSpVecGetValues\n(\ncusparseSpVecDescr_t\nspVecDescr\n,\nvoid\n**\nvalues\n)\ncusparseStatus_t\ncusparseConstSpVecGetValues\n(\ncusparseConstSpVecDescr_t\nspVecDescr\n,\nconst\nvoid\n**\nvalues\n)\nThis function returns the\nvalues\nfield of the sparse vector descriptor\nspVecDescr\n.\nParam.\nMemory\nIn/out\nMeaning\nspVecDescr\nHOST\nIN\nSparse vector descriptor\nvalues\nDEVICE\nOUT\nValues of the sparse vector. Array with\nnnz\nelements\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.3.6.\ncusparseSpVecSetValues()\n\ncusparseStatus_t\ncusparseSpVecSetValues\n(\ncusparseSpVecDescr_t\nspVecDescr\n,\nvoid\n*\nvalues\n)\nThis function set the\nvalues\nfield of the sparse vector descriptor\nspVecDescr\n.\nParam.\nMemory\nIn/out\nMeaning\nspVecDescr\nHOST\nIN\nSparse vector descriptor\nvalues\nDEVICE\nIN\nValues of the sparse vector. Array with\nnnz\nelements\ncusparseDnVecSetValues()\nhas the following constraints:\nvalues\nmust be aligned to the size of the datatype specified in\nspVecDescr\n. See\ncudaDataType_t\nfor the description of the datatypes.\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.4.\nDense Matrix APIs\n\nThe cuSPARSE helper functions for dense matrix descriptor are described in this section.\nSee the\nDense Matrix Format\nsection for the detailed description of the storage format.\n6.4.1.\ncusparseCreateDnMat()\n\ncusparseStatus_t\ncusparseCreateDnMat\n(\ncusparseDnMatDescr_t\n*\ndnMatDescr\n,\nint64_t\nrows\n,\nint64_t\ncols\n,\nint64_t\nld\n,\nvoid\n*\nvalues\n,\ncudaDataType\nvalueType\n,\ncusparseOrder_t\norder\n)\ncusparseStatus_t\ncusparseCreateConstDnMat\n(\ncusparseConstDnMatDescr_t\n*\ndnMatDescr\n,\nint64_t\nrows\n,\nint64_t\ncols\n,\nint64_t\nld\n,\nconst\nvoid\n*\nvalues\n,\ncudaDataType\nvalueType\n,\ncusparseOrder_t\norder\n)\nThe function initializes the dense matrix descriptor\ndnMatDescr\n.\nParam.\nMemory\nIn/out\nMeaning\ndnMatDescr\nHOST\nOUT\nDense matrix descriptor\nrows\nHOST\nIN\nNumber of rows of the dense matrix\ncols\nHOST\nIN\nNumber of columns of the dense matrix\nld\nHOST\nIN\nLeading dimension of the dense matrix\nvalues\nDEVICE\nIN\nValues of the dense matrix. Array with\nsize\nelements\nvalueType\nHOST\nIN\nEnumerator specifying the datatype of\nvalues\norder\nHOST\nIN\nEnumerator specifying the memory layout of the dense matrix\ncusparseCreateDnMat()\nhas the following constraints:\nvalues\nmust be aligned to the size of the datatype specified by\nvalueType\n. See\ncudaDataType_t\nfor the description of the datatypes.\nRefer to\ncusparseStatus_t\nfor the description of the return status.\n6.4.2.\ncusparseDestroyDnMat()\n\ncusparseStatus_t\ncusparseDestroyDnMat\n(\ncusparseConstDnMatDescr_t\ndnMatDescr\n)\n// non-const descriptor supported\nThis function releases the host memory allocated for the dense matrix descriptor\ndnMatDescr\n.\nParam.\nMemory\nIn/out\nMeaning\ndnMatDescr\nHOST\nIN\nDense matrix descriptor\nRefer to\ncusparseStatus_t\nfor the description of the return status.\n6.4.3.\ncusparseDnMatGet()\n\ncusparseStatus_t\ncusparseDnMatGet\n(\ncusparseDnMatDescr_t\ndnMatDescr\n,\nint64_t\n*\nrows\n,\nint64_t\n*\ncols\n,\nint64_t\n*\nld\n,\nvoid\n**\nvalues\n,\ncudaDataType\n*\ntype\n,\ncusparseOrder_t\n*\norder\n)\ncusparseStatus_t\ncusparseConstDnMatGet\n(\ncusparseConstDnMatDescr_t\ndnMatDescr\n,\nint64_t\n*\nrows\n,\nint64_t\n*\ncols\n,\nint64_t\n*\nld\n,\nconst\nvoid\n**\nvalues\n,\ncudaDataType\n*\ntype\n,\ncusparseOrder_t\n*\norder\n)\nThis function returns the fields of the dense matrix descriptor\ndnMatDescr\n.\nParam.\nMemory\nIn/out\nMeaning\ndnMatDescr\nHOST\nIN\nDense matrix descriptor\nrows\nHOST\nOUT\nNumber of rows of the dense matrix\ncols\nHOST\nOUT\nNumber of columns of the dense matrix\nld\nHOST\nOUT\nLeading dimension of the dense matrix\nvalues\nDEVICE\nOUT\nValues of the dense matrix. Array with\nld\n*\ncols\nelements\nvalueType\nHOST\nOUT\nEnumerator specifying the datatype of\nvalues\norder\nHOST\nOUT\nEnumerator specifying the memory layout of the dense matrix\nRefer to\ncusparseStatus_t\nfor the description of the return status.\n6.4.4.\ncusparseDnMatGetValues()\n\ncusparseStatus_t\ncusparseDnMatGetValues\n(\ncusparseDnMatDescr_t\ndnMatDescr\n,\nvoid\n**\nvalues\n)\ncusparseStatus_t\ncusparseConstDnMatGetValues\n(\ncusparseConstDnMatDescr_t\ndnMatDescr\n,\nconst\nvoid\n**\nvalues\n)\nThis function returns the\nvalues\nfield of the dense matrix descriptor\ndnMatDescr\n.\nParam.\nMemory\nIn/out\nMeaning\ndnMatDescr\nHOST\nIN\nDense matrix descriptor\nvalues\nDEVICE\nOUT\nValues of the dense matrix. Array with\nld\n*\ncols\nelements\nRefer to\ncusparseStatus_t\nfor the description of the return status.\n6.4.5.\ncusparseDnMatSetValues()\n\ncusparseStatus_t\ncusparseDnMatSetValues\n(\ncusparseDnMatDescr_t\ndnMatDescr\n,\nvoid\n*\nvalues\n)\nThis function sets the\nvalues\nfield of the dense matrix descriptor\ndnMatDescr\n.\nParam.\nMemory\nIn/out\nMeaning\ndnMatDescr\nHOST\nIN\nDense matrix descriptor\nvalues\nDEVICE\nIN\nValues of the dense matrix. Array with\nld\n*\ncols\nelements\ncusparseDnMatSetValues()\nhas the following constraints:\nvalues\nmust be aligned to the size of the datatype specified in\ndnMatDescr\n. See\ncudaDataType_t\nfor the description of the datatypes.\nRefer to\ncusparseStatus_t\nfor the description of the return status.\n6.4.6.\ncusparseDnMatGetStridedBatch()\n\ncusparseStatus_t\ncusparseDnMatGetStridedBatch\n(\ncusparseConstDnMatDescr_t\ndnMatDescr\n,\n// non-const descriptor supported\nint\n*\nbatchCount\n,\nint64_t\n*\nbatchStride\n)\nThe function returns the number of batches and the batch stride of the dense matrix descriptor\ndnMatDescr\n.\nParam.\nMemory\nIn/out\nMeaning\ndnMatDescr\nHOST\nIN\nDense matrix descriptor\nbatchCount\nHOST\nOUT\nNumber of batches of the dense matrix\nbatchStride\nHOST\nOUT\nAddress offset between a matrix and the next one in the batch\nRefer to\ncusparseStatus_t\nfor the description of the return status.\n6.4.7.\ncusparseDnMatSetStridedBatch()\n\ncusparseStatus_t\ncusparseDnMatSetStridedBatch\n(\ncusparseDnMatDescr_t\ndnMatDescr\n,\nint\nbatchCount\n,\nint64_t\nbatchStride\n)\nThe function sets the number of batches and the batch stride of the dense matrix descriptor\ndnMatDescr\n.\nParam.\nMemory\nIn/out\nMeaning\ndnMatDescr\nHOST\nIN\nDense matrix descriptor\nbatchCount\nHOST\nIN\nNumber of batches of the dense matrix\nbatchStride\nHOST\nIN\nAddress offset between a matrix and the next one in the batch.\nbatchStride\n≥\nld\n*\ncols\nif the matrix uses column-major layout,\nbatchStride\n≥\nld\n*\nrows\notherwise\nRefer to\ncusparseStatus_t\nfor the description of the return status.\n6.5.\nSparse Matrix APIs\n\nThe cuSPARSE helper functions for sparse matrix descriptor are described in this section.\nSee the\nCOO\n,\nCSR\n,\nCSC\n,\nSELL\n,\nBSR\n,\nBlocked-Ell\nsections for the detailed description of the storage formats.\n6.5.1.\nCoordinate (COO)\n\n6.5.1.1.\ncusparseCreateCoo()\n\ncusparseStatus_t\ncusparseCreateCoo\n(\ncusparseSpMatDescr_t\n*\nspMatDescr\n,\nint64_t\nrows\n,\nint64_t\ncols\n,\nint64_t\nnnz\n,\nvoid\n*\ncooRowInd\n,\nvoid\n*\ncooColInd\n,\nvoid\n*\ncooValues\n,\ncusparseIndexType_t\ncooIdxType\n,\ncusparseIndexBase_t\nidxBase\n,\ncudaDataType\nvalueType\n)\ncusparseStatus_t\ncusparseCreateConstCoo\n(\ncusparseConstSpMatDescr_t\n*\nspMatDescr\n,\nint64_t\nrows\n,\nint64_t\ncols\n,\nint64_t\nnnz\n,\nconst\nvoid\n*\ncooRowInd\n,\nconst\nvoid\n*\ncooColInd\n,\nconst\nvoid\n*\ncooValues\n,\ncusparseIndexType_t\ncooIdxType\n,\ncusparseIndexBase_t\nidxBase\n,\ncudaDataType\nvalueType\n)\nThis function initializes the sparse matrix descriptor\nspMatDescr\nin the COO format (Structure of Arrays layout).\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nOUT\nSparse matrix descriptor\nrows\nHOST\nIN\nNumber of rows of the sparse matrix\ncols\nHOST\nIN\nNumber of columns of the sparse matrix\nnnz\nHOST\nIN\nNumber of non-zero entries of the sparse matrix\ncooRowInd\nDEVICE\nIN\nRow indices of the sparse matrix. Array with\nnnz\nelements\ncooColInd\nDEVICE\nIN\nColumn indices of the sparse matrix. Array with\nnnz\nelements\ncooValues\nDEVICE\nIN\nValues of the sparse matrix. Array with\nnnz\nelements\ncooIdxType\nHOST\nIN\nData type of\ncooRowInd\nand\ncooColInd\nidxBase\nHOST\nIN\nIndex base of\ncooRowInd\nand\ncooColInd\nvalueType\nHOST\nIN\nDatatype of\ncooValues\ncusparseCreateCoo()\nhas the following constraints:\ncooRowInd\n,\ncooColInd\n, and\ncooValues\nmust be aligned to the size of the datatypes specified by\ncooIdxType\n,\ncooIdxType\n, and\nvalueType\n. respectively. See\ncudaDataType_t\nfor the description of the datatypes.\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.1.2.\ncusparseCooGet()\n\ncusparseStatus_t\ncusparseCooGet\n(\ncusparseSpMatDescr_t\nspMatDescr\n,\nint64_t\n*\nrows\n,\nint64_t\n*\ncols\n,\nint64_t\n*\nnnz\n,\nvoid\n**\ncooRowInd\n,\nvoid\n**\ncooColInd\n,\nvoid\n**\ncooValues\n,\ncusparseIndexType_t\n*\nidxType\n,\ncusparseIndexBase_t\n*\nidxBase\n,\ncudaDataType\n*\nvalueType\n)\ncusparseStatus_t\ncusparseConstCooGet\n(\ncusparseConstSpMatDescr_t\nspMatDescr\n,\nint64_t\n*\nrows\n,\nint64_t\n*\ncols\n,\nint64_t\n*\nnnz\n,\nconst\nvoid\n**\ncooRowInd\n,\nconst\nvoid\n**\ncooColInd\n,\nconst\nvoid\n**\ncooValues\n,\ncusparseIndexType_t\n*\nidxType\n,\ncusparseIndexBase_t\n*\nidxBase\n,\ncudaDataType\n*\nvalueType\n)\nThis function returns the fields of the sparse matrix descriptor\nspMatDescr\nstored in COO format (Array of Structures layout).\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nIN\nSparse matrix descriptor\nrows\nHOST\nOUT\nNumber of rows of the sparse matrix\ncols\nHOST\nOUT\nNumber of columns of the sparse matrix\nnnz\nHOST\nOUT\nNumber of non-zero entries of the sparse matrix\ncooRowInd\nDEVICE\nOUT\nRow indices of the sparse matrix. Array\nnnz\nelements\ncooColInd\nDEVICE\nOUT\nColumn indices of the sparse matrix. Array\nnnz\nelements\ncooValues\nDEVICE\nOUT\nValues of the sparse matrix. Array\nnnz\nelements\ncooIdxType\nHOST\nOUT\nData type of\ncooRowInd\nand\ncooColInd\nidxBase\nHOST\nOUT\nIndex base of\ncooRowInd\nand\ncooColInd\nvalueType\nHOST\nOUT\nDatatype of\ncooValues\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.1.3.\ncusparseCooSetPointers()\n\ncusparseStatus_t\ncusparseCooSetPointers\n(\ncusparseSpMatDescr_t\nspMatDescr\n,\nvoid\n*\ncooRows\n,\nvoid\n*\ncooColumns\n,\nvoid\n*\ncooValues\n)\nThis function sets the pointers of the sparse matrix descriptor\nspMatDescr\n.\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nIN\nSparse matrix descriptor\ncooRows\nDEVICE\nIN\nRow indices of the sparse matrix. Array with\nnnz\nelements\ncooColumns\nDEVICE\nIN\nColumn indices of the sparse matrix. Array with\nnnz\nelements\ncooValues\nDEVICE\nIN\nValues of the sparse matrix. Array with\nnnz\nelements\ncusparseCooSetPointers()\nhas the following constraints:\ncooRows\n,\ncooColumns\n, and\ncooValues\nmust be aligned to the size of their corresponding datatypes specified in\nspMatDescr\n. See\ncudaDataType_t\nfor the description of the datatypes.\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.1.4.\ncusparseCooSetStridedBatch()\n\ncusparseStatus_t\ncusparseCooSetStridedBatch\n(\ncusparseSpMatDescr_t\nspMatDescr\n,\nint\nbatchCount\n,\nint64_t\nbatchStride\n)\nThis function sets the\nbatchCount\nand the\nbatchStride\nfields of the sparse matrix descriptor\nspMatDescr\n.\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nIN\nSparse matrix descriptor\nbatchCount\nHOST\nIN\nNumber of batches of the sparse matrix\nbatchStride\nHOST\nIN\naddress offset between consecutive batches\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.2.\nCompressed Sparse Row (CSR)\n\n6.5.2.1.\ncusparseCreateCsr()\n\ncusparseStatus_t\ncusparseCreateCsr\n(\ncusparseSpMatDescr_t\n*\nspMatDescr\n,\nint64_t\nrows\n,\nint64_t\ncols\n,\nint64_t\nnnz\n,\nvoid\n*\ncsrRowOffsets\n,\nvoid\n*\ncsrColInd\n,\nvoid\n*\ncsrValues\n,\ncusparseIndexType_t\ncsrRowOffsetsType\n,\ncusparseIndexType_t\ncsrColIndType\n,\ncusparseIndexBase_t\nidxBase\n,\ncudaDataType\nvalueType\n)\ncusparseStatus_t\ncusparseCreateConstCsr\n(\ncusparseConstSpMatDescr_t\n*\nspMatDescr\n,\nint64_t\nrows\n,\nint64_t\ncols\n,\nint64_t\nnnz\n,\nconst\nvoid\n*\ncsrRowOffsets\n,\nconst\nvoid\n*\ncsrColInd\n,\nconst\nvoid\n*\ncsrValues\n,\ncusparseIndexType_t\ncsrRowOffsetsType\n,\ncusparseIndexType_t\ncsrColIndType\n,\ncusparseIndexBase_t\nidxBase\n,\ncudaDataType\nvalueType\n)\nThis function initializes the sparse matrix descriptor\nspMatDescr\nin the CSR format.\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nOUT\nSparse matrix descriptor\nrows\nHOST\nIN\nNumber of rows of the sparse matrix\ncols\nHOST\nIN\nNumber of columns of the sparse matrix\nnnz\nHOST\nIN\nNumber of non-zero entries of the sparse matrix\ncsrRowOffsets\nDEVICE\nIN\nRow offsets of the sparse matrix. Array with\nrows\n+\n1\nelements\ncsrColInd\nDEVICE\nIN\nColumn indices of the sparse matrix. Array with\nnnz\nelements\ncsrValues\nDEVICE\nIN\nValues of the sparse matrix. Array with\nnnz\nelements\ncsrRowOffsetsType\nHOST\nIN\nData type of\ncsrRowOffsets\ncsrColIndType\nHOST\nIN\nData type of\ncsrColInd\nidxBase\nHOST\nIN\nIndex base of\ncsrRowOffsets\nand\ncsrColInd\nvalueType\nHOST\nIN\nDatatype of\ncsrValues\ncusparseCreateCsr()\nhas the following constraints:\ncsrRowOffsets\n,\ncsrColInd\n, and\ncsrValues\nmust be aligned to the size of the datatypes specified by\ncsrRowOffsetsType\n,\ncsrColIndType\n, and\nvalueType\n, respectively. See\ncudaDataType_t\nfor the description of the datatypes.\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.2.2.\ncusparseCsrGet()\n\ncusparseStatus_t\ncusparseCsrGet\n(\ncusparseSpMatDescr_t\nspMatDescr\n,\nint64_t\n*\nrows\n,\nint64_t\n*\ncols\n,\nint64_t\n*\nnnz\n,\nvoid\n**\ncsrRowOffsets\n,\nvoid\n**\ncsrColInd\n,\nvoid\n**\ncsrValues\n,\ncusparseIndexType_t\n*\ncsrRowOffsetsType\n,\ncusparseIndexType_t\n*\ncsrColIndType\n,\ncusparseIndexBase_t\n*\nidxBase\n,\ncudaDataType\n*\nvalueType\n)\ncusparseStatus_t\ncusparseConstCsrGet\n(\ncusparseConstSpMatDescr_t\nspMatDescr\n,\nint64_t\n*\nrows\n,\nint64_t\n*\ncols\n,\nint64_t\n*\nnnz\n,\nconst\nvoid\n**\ncsrRowOffsets\n,\nconst\nvoid\n**\ncsrColInd\n,\nconst\nvoid\n**\ncsrValues\n,\ncusparseIndexType_t\n*\ncsrRowOffsetsType\n,\ncusparseIndexType_t\n*\ncsrColIndType\n,\ncusparseIndexBase_t\n*\nidxBase\n,\ncudaDataType\n*\nvalueType\n)\nThis function returns the fields of the sparse matrix descriptor\nspMatDescr\nstored in CSR format.\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nIN\nSparse matrix descriptor\nrows\nHOST\nOUT\nNumber of rows of the sparse matrix\ncols\nHOST\nOUT\nNumber of columns of the sparse matrix\nnnz\nHOST\nOUT\nNumber of non-zero entries of the sparse matrix\ncsrRowOffsets\nDEVICE\nOUT\nRow offsets of the sparse matrix. Array with\nrows\n+\n1\nelements\ncsrColInd\nDEVICE\nOUT\nColumn indices of the sparse matrix. Array with\nnnz\nelements\ncsrValues\nDEVICE\nOUT\nValues of the sparse matrix. Array with\nnnz\nelements\ncsrRowOffsetsType\nHOST\nOUT\nData type of\ncsrRowOffsets\ncsrColIndType\nHOST\nOUT\nData type of\ncsrColInd\nidxBase\nHOST\nOUT\nIndex base of\ncsrRowOffsets\nand\ncsrColInd\nvalueType\nHOST\nOUT\nDatatype of\ncsrValues\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.2.3.\ncusparseCsrSetPointers()\n\ncusparseStatus_t\ncusparseCsrSetPointers\n(\ncusparseSpMatDescr_t\nspMatDescr\n,\nvoid\n*\ncsrRowOffsets\n,\nvoid\n*\ncsrColInd\n,\nvoid\n*\ncsrValues\n)\nThis function sets the pointers of the sparse matrix descriptor\nspMatDescr\n.\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nIN\nSparse matrix descriptor\ncsrRowOffsets\nDEVICE\nIN\nRow offsets of the sparse matrix. Array with\nrows\n+\n1\nelements\ncsrColInd\nDEVICE\nIN\nColumn indices of the sparse matrix. Array with\nnnz\nelements\ncsrValues\nDEVICE\nIN\nValues of the sparse matrix. Array with\nnnz\nelements\ncusparseCsrSetPointers()\nhas the following constraints:\ncsrRowOffsets\n,\ncsrColInd\n, and\ncsrValues\nmust be aligned to the size of their corresponding datatypes specified in\nspMatDescr\n. See\ncudaDataType_t\nfor the description of the datatypes.\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.2.4.\ncusparseCsrSetStridedBatch()\n\ncusparseStatus_t\ncusparseCsrSetStridedBatch\n(\ncusparseSpMatDescr_t\nspMatDescr\n,\nint\nbatchCount\n,\nint64_t\noffsetsBatchStride\n,\nint64_t\ncolumnsValuesBatchStride\n)\nThis function sets the\nbatchCount\nand the\nbatchStride\nfields of the sparse matrix descriptor\nspMatDescr\n.\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nIN\nSparse matrix descriptor\nbatchCount\nHOST\nIN\nNumber of batches of the sparse matrix\noffsetsBatchStride\nHOST\nIN\nAddress offset between consecutive batches for the row offset array\ncolumnsValuesBatchStride\nHOST\nIN\nAddress offset between consecutive batches for the column and value arrays\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.3.\nCompressed Sparse Column (CSC)\n\n6.5.3.1.\ncusparseCreateCsc()\n\ncusparseStatus_t\ncusparseCreateCsc\n(\ncusparseSpMatDescr_t\n*\nspMatDescr\n,\nint64_t\nrows\n,\nint64_t\ncols\n,\nint64_t\nnnz\n,\nvoid\n*\ncscColOffsets\n,\nvoid\n*\ncscRowInd\n,\nvoid\n*\ncscValues\n,\ncusparseIndexType_t\ncscColOffsetsType\n,\ncusparseIndexType_t\ncscRowIndType\n,\ncusparseIndexBase_t\nidxBase\n,\ncudaDataType\nvalueType\n)\ncusparseStatus_t\ncusparseCreateConstCsc\n(\ncusparseConstSpMatDescr_t\n*\nspMatDescr\n,\nint64_t\nrows\n,\nint64_t\ncols\n,\nint64_t\nnnz\n,\nconst\nvoid\n*\ncscColOffsets\n,\nconst\nvoid\n*\ncscRowInd\n,\nconst\nvoid\n*\ncscValues\n,\ncusparseIndexType_t\ncscColOffsetsType\n,\ncusparseIndexType_t\ncscRowIndType\n,\ncusparseIndexBase_t\nidxBase\n,\ncudaDataType\nvalueType\n)\nThis function initializes the sparse matrix descriptor\nspMatDescr\nin the CSC format.\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nOUT\nSparse matrix descriptor\nrows\nHOST\nIN\nNumber of rows of the sparse matrix\ncols\nHOST\nIN\nNumber of columns of the sparse matrix\nnnz\nHOST\nIN\nNumber of non-zero entries of the sparse matrix\ncscColOffsets\nDEVICE\nIN\nColumn offsets of the sparse matrix. Array with\ncols\n+\n1\nelements\ncscRowInd\nDEVICE\nIN\nRow indices of the sparse matrix. Array with\nnnz\nelements\ncscValues\nDEVICE\nIN\nValues of the sparse matrix. Array with\nnnz\nelements\ncscColOffsetsType\nHOST\nIN\nData type of\ncscColOffsets\ncscRowIndType\nHOST\nIN\nData type of\ncscRowInd\nidxBase\nHOST\nIN\nIndex base of\ncscColOffsets\nand\ncscRowInd\nvalueType\nHOST\nIN\nDatatype of\ncscValues\ncusparseCreateCsc()\nhas the following constraints:\ncscColOffsets\n,\ncscRowInd\n, and\ncscValues\nmust be aligned to the size of the datatypes specified by\ncscColOffsetsType\n,\ncscRowIndType\n, and\nvalueType\n, respectively. See\ncudaDataType_t\nfor the description of the datatypes.\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.3.2.\ncusparseCscGet()\n\ncusparseStatus_t\ncusparseCscGet\n(\ncusparseSpMatDescr_t\nspMatDescr\n,\nint64_t\n*\nrows\n,\nint64_t\n*\ncols\n,\nint64_t\n*\nnnz\n,\nvoid\n**\ncscColOffsets\n,\nvoid\n**\ncscRowInd\n,\nvoid\n**\ncscValues\n,\ncusparseIndexType_t\n*\ncscColOffsetsType\n,\ncusparseIndexType_t\n*\ncscRowIndType\n,\ncusparseIndexBase_t\n*\nidxBase\n,\ncudaDataType\n*\nvalueType\n)\ncusparseStatus_t\ncusparseConstCscGet\n(\ncusparseConstSpMatDescr_t\nspMatDescr\n,\nint64_t\n*\nrows\n,\nint64_t\n*\ncols\n,\nint64_t\n*\nnnz\n,\nconst\nvoid\n**\ncscColOffsets\n,\nconst\nvoid\n**\ncscRowInd\n,\nconst\nvoid\n**\ncscValues\n,\ncusparseIndexType_t\n*\ncscColOffsetsType\n,\ncusparseIndexType_t\n*\ncscRowIndType\n,\ncusparseIndexBase_t\n*\nidxBase\n,\ncudaDataType\n*\nvalueType\n)\nThis function returns the fields of the sparse matrix descriptor\nspMatDescr\nstored in CSC format.\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nIN\nSparse matrix descriptor\nrows\nHOST\nOUT\nNumber of rows of the sparse matrix\ncols\nHOST\nOUT\nNumber of columns of the sparse matrix\nnnz\nHOST\nOUT\nNumber of non-zero entries of the sparse matrix\ncscColOffsets\nDEVICE\nOUT\nCol offsets of the sparse matrix. Array with\ncols\n+\n1\nelements\ncscRowInd\nDEVICE\nOUT\nRow indices of the sparse matrix. Array with\nnnz\nelements\ncscValues\nDEVICE\nOUT\nValues of the sparse matrix. Array with\nnnz\nelements\ncscColOffsetsType\nHOST\nOUT\nData type of\ncscColOffsets\ncscRowIndType\nHOST\nOUT\nData type of\ncscRowInd\nidxBase\nHOST\nOUT\nIndex base of\ncscColOffsets\nand\ncscRowInd\nvalueType\nHOST\nOUT\nDatatype of\ncscValues\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.3.3.\ncusparseCscSetPointers()\n\ncusparseStatus_t\ncusparseCscSetPointers\n(\ncusparseSpMatDescr_t\nspMatDescr\n,\nvoid\n*\ncscColOffsets\n,\nvoid\n*\ncscRowInd\n,\nvoid\n*\ncscValues\n)\nThis function sets the pointers of the sparse matrix descriptor\nspMatDescr\n.\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nIN\nSparse matrix descriptor\ncscColOffsets\nDEVICE\nIN\nCol offsets of the sparse matrix. Array with\ncols\n+\n1\nelements\ncscRowInd\nDEVICE\nIN\nRow indices of the sparse matrix. Array with\nnnz\nelements\ncscValues\nDEVICE\nIN\nValues of the sparse matrix. Array with\nnnz\nelements\ncusparseCscSetPointers()\nhas the following constraints:\ncscColOffsets\n,\ncscRowInd\n, and\ncscValues\nmust be aligned to the size of their corresponding datatypes specified in\nspMatDescr\n. See\ncudaDataType_t\nfor the description of the datatypes.\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.4.\nBlocked-Ellpack (Blocked-ELL)\n\n6.5.4.1.\ncusparseCreateBlockedEll()\n\ncusparseStatus_t\ncusparseCreateBlockedEll\n(\ncusparseSpMatDescr_t\n*\nspMatDescr\n,\nint64_t\nrows\n,\nint64_t\ncols\n,\nint64_t\nellBlockSize\n,\nint64_t\nellCols\n,\nvoid\n*\nellColInd\n,\nvoid\n*\nellValue\n,\ncusparseIndexType_t\nellIdxType\n,\ncusparseIndexBase_t\nidxBase\n,\ncudaDataType\nvalueType\n)\ncusparseStatus_t\ncusparseCreateConstBlockedEll\n(\ncusparseConstSpMatDescr_t\n*\nspMatDescr\n,\nint64_t\nrows\n,\nint64_t\ncols\n,\nint64_t\nellBlockSize\n,\nint64_t\nellCols\n,\nconst\nvoid\n*\nellColInd\n,\nconst\nvoid\n*\nellValue\n,\ncusparseIndexType_t\nellIdxType\n,\ncusparseIndexBase_t\nidxBase\n,\ncudaDataType\nvalueType\n)\nThis function initializes the sparse matrix descriptor\nspMatDescr\nfor the Blocked-Ellpack (ELL) format.\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nOUT\nSparse matrix descriptor\nrows\nHOST\nIN\nNumber of rows of the sparse matrix\ncols\nHOST\nIN\nNumber of columns of the sparse matrix\nellBlockSize\nHOST\nIN\nSize of the ELL-Block\nellCols\nHOST\nIN\nActual number of columns of the Blocked-Ellpack format (\nellValue\ncolumns)\nellColInd\nDEVICE\nIN\nBlocked-ELL Column indices. Array with\n[ellCols\n/\nellBlockSize][rows\n/\nellBlockSize]\nelements\nellValue\nDEVICE\nIN\nValues of the sparse matrix. Array with\nrows\n*\nellCols\nelements\nellIdxType\nHOST\nIN\nData type of\nellColInd\nidxBase\nHOST\nIN\nIndex base of\nellColInd\nvalueType\nHOST\nIN\nData type of\nellValue\nBlocked-ELL Column indices (\nellColInd\n) are in the range\n[0,\ncols\n/\nellBlockSize\n-1]\n. The array can contain\n-1\nvalues for indicating empty blocks.\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.4.2.\ncusparseBlockedEllGet()\n\ncusparseStatus_t\ncusparseBlockedEllGet\n(\ncusparseSpMatDescr_t\nspMatDescr\n,\nint64_t\n*\nrows\n,\nint64_t\n*\ncols\n,\nint64_t\n*\nellBlockSize\n,\nint64_t\n*\nellCols\n,\nvoid\n**\nellColInd\n,\nvoid\n**\nellValue\n,\ncusparseIndexType_t\n*\nellIdxType\n,\ncusparseIndexBase_t\n*\nidxBase\n,\ncudaDataType\n*\nvalueType\n)\ncusparseStatus_t\ncusparseConstBlockedEllGet\n(\ncusparseConstSpMatDescr_t\nspMatDescr\n,\nint64_t\n*\nrows\n,\nint64_t\n*\ncols\n,\nint64_t\n*\nellBlockSize\n,\nint64_t\n*\nellCols\n,\nconst\nvoid\n**\nellColInd\n,\nconst\nvoid\n**\nellValue\n,\ncusparseIndexType_t\n*\nellIdxType\n,\ncusparseIndexBase_t\n*\nidxBase\n,\ncudaDataType\n*\nvalueType\n)\nThis function returns the fields of the sparse matrix descriptor\nspMatDescr\nstored in Blocked-Ellpack (ELL) format.\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nIN\nSparse matrix descriptor\nrows\nHOST\nOUT\nNumber of rows of the sparse matrix\ncols\nHOST\nOUT\nNumber of columns of the sparse matrix\nellBlockSize\nHOST\nOUT\nSize of the ELL-Block\nellCols\nHOST\nOUT\nActual number of columns of the Blocked-Ellpack format\nellColInd\nDEVICE\nOUT\nColumn indices for the ELL-Block. Array with\n[cols\n/\nellBlockSize][rows\n/\nellBlockSize]\nelements\nellValue\nDEVICE\nOUT\nValues of the sparse matrix. Array with\nrows\n*\nellCols\nelements\nellIdxType\nHOST\nOUT\nData type of\nellColInd\nidxBase\nHOST\nOUT\nIndex base of\nellColInd\nvalueType\nHOST\nOUT\nDatatype of\nellValue\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.5.\nSliced-Ellpack (SELL)\n\n6.5.5.1.\ncusparseCreateSlicedEll()\n\ncusparseStatus_t\ncusparseCreateSlicedEll\n(\ncusparseSpMatDescr_t\n*\nspMatDescr\n,\nint64_t\nrows\n,\nint64_t\ncols\n,\nint64_t\nnnz\n,\nint64_t\nsellValuesSize\n,\nint64_t\nsliceSize\n,\nvoid\n*\nsellSliceOffsets\n,\nvoid\n*\nsellColInd\n,\nvoid\n*\nsellValues\n,\ncusparseIndexType_t\nsellSliceOffsetsType\n,\ncusparseIndexType_t\nsellColIndType\n,\ncusparseIndexBase_t\nidxBase\n,\ncudaDataType\nvalueType\n)\ncusparseStatus_t\ncusparseCreateConstSlicedEll\n(\ncusparseConstSpMatDescr_t\n*\nspMatDescr\n,\nint64_t\nrows\n,\nint64_t\ncols\n,\nint64_t\nnnz\n,\nint64_t\nsellValuesSize\n,\nint64_t\nsliceSize\n,\nconst\nvoid\n*\nsellSliceOffsets\n,\nconst\nvoid\n*\nsellColInd\n,\nconst\nvoid\n*\nsellValues\n,\ncusparseIndexType_t\nsellSliceOffsetsType\n,\ncusparseIndexType_t\nsellColIndType\n,\ncusparseIndexBase_t\nidxBase\n,\ncudaDataType\nvalueType\n)\nThis function initializes the sparse matrix descriptor\nspMatDescr\nfor the Sliced Ellpack (SELL) format.\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nOUT\nSparse matrix descriptor\nrows\nHOST\nIN\nNumber of rows of the sparse matrix\ncols\nHOST\nIN\nNumber of columns of the sparse matrix\nnnz\nHOST\nIN\nNumber of nonzero elements in the sparse matrix\nsellValuesSize\nHOST\nIN\nTotal number of elements in\nsellValues\narray (nonzero and padding)\nsliceSize\nHOST\nIN\nThe number of rows per slice\nsellSliceOffsets\nDEVICE\nIN\nSlice offsets of the sparse matrix. Array of size\n\\(\\left \\lceil{\\frac{rows}{sliceSize}}\\right \\rceil + 1\\)\nsellColInd\nDEVICE\nIN\nColumn indexes of the sparse matrix. Array of size\nsellValuesSize\nsellValues\nDEVICE\nIN\nValues of the sparse matrix. Array of size\nsellValuesSize\nelements\nsellSliceOffsetsType\nHOST\nIN\nData type of\nsellSliceOffsets\nsellColIndType\nHOST\nIN\nData type of\nsellColInd\nidxBase\nHOST\nIN\nIndex base of\nsellColInd\nvalueType\nHOST\nIN\nData type of\nsellValues\nNote\nSliced Ellpack Column array\nsellColInd\ncontains\n-1\nvalues for indicating padded entries.\ncusparseCreateSlicedEll()\nhas the following constraints:\nsellSliceOffsets\n,\nsellColInd\n, and\nsellValues\nmust be aligned to the size of the datatypes specified by\nsellSliceOffsetsType\n,\nsellColIndType\n, and\nvalueType\n, respectively. See\ncudaDataType_t\nfor the description of the datatypes.\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.6.\nBlock Sparse Row (BSR)\n\n6.5.6.1.\ncusparseCreateBsr()\n\ncusparseStatus_t\ncusparseCreateBsr\n(\ncusparseSpMatDescr_t\n*\nspMatDescr\n,\nint64_t\nbrows\n,\nint64_t\nbcols\n,\nint64_t\nbnnz\n,\nint64_t\nrowBlockSize\n,\nint64_t\ncolBlockSize\n,\nvoid\n*\nbsrRowOffsets\n,\nvoid\n*\nbsrColInd\n,\nvoid\n*\nbsrValues\n,\ncusparseIndexType_t\nbsrRowOffsetsType\n,\ncusparseIndexType_t\nbsrColIndType\n,\ncusparseIndexBase_t\nidxBase\n,\ncudaDataType\nvalueType\n,\ncusparseOrder_t\norder\n)\ncusparseStatus_t\ncusparseCreateConstBsr\n(\ncusparseConstSpMatDescr_t\n*\nspMatDescr\n,\nint64_t\nbrows\n,\nint64_t\nbcols\n,\nint64_t\nbnnz\n,\nint64_t\nrowBlockSize\n,\nint64_t\ncolBlockSize\n,\nconst\nvoid\n*\nbsrRowOffsets\n,\nconst\nvoid\n*\nbsrColInd\n,\nconst\nvoid\n*\nbsrValues\n,\ncusparseIndexType_t\nbsrRowOffsetsType\n,\ncusparseIndexType_t\nbsrColIndType\n,\ncusparseIndexBase_t\nidxBase\n,\ncudaDataType\nvalueType\n,\ncusparseOrder_t\norder\n)\nThis function initializes the sparse matrix descriptor\nspMatDescr\nfor the Block Compressed Row (BSR) format.\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nOUT\nSparse matrix descriptor\nbrows\nHOST\nIN\nNumber of block rows of the sparse matrix\nbcols\nHOST\nIN\nNumber of block columns of the sparse matrix\nbnnz\nHOST\nIN\nNumber of blocks of the sparse matrix\nrowBlockSize\nHOST\nIN\nNumber of rows of each block\ncolBlockSize\nHOST\nIN\nNumber of columns of each block\nbsrRowOffsets\nDEVICE\nIN\nBlock row offsets of the sparse matrix. Array of size\nbrows\n+\n1\nbsrColInd\nDEVICE\nIN\nBlock column indices of the sparse matrix. Array of size\nbnnz\nbsrValues\nDEVICE\nIN\nValues of the sparse matrix. Array of size\nbnnz\n*\nrowBlockSize\n*\ncolBlockSize\nbsrRowOffsetsType\nHOST\nIN\nData type of\nbsrRowOffsets\nbsrColIndType\nHOST\nIN\nData type of\nbsrColInd\nidxBase\nHOST\nIN\nBase index of\nbsrRowOffsets\nand\nbsrColInd\nvalueType\nHOST\nIN\nDatatype of\nbsrValues\norder\nHOST\nIN\nEnumerator specifying the memory layout of values in each block\ncusparseCreateBsr()\nhas the following constraints:\nbsrRowOffsets\n,\nbsrColInd\n, and\nbsrValues\nmust be aligned to the size of the datatypes specified by\nbsrRowOffsetsType\n,\nbsrColIndType\n, and\nvalueType\n, respectively. See\ncudaDataType_t\nfor the description of the datatypes.\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.6.2.\ncusparseBsrSetStridedBatch()\n\ncusparseStatus_t\ncusparseBsrSetStridedBatch\n(\ncusparseSpMatDescr_t\nspMatDescr\n,\nint\nbatchCount\n,\nint64_t\noffsetsBatchStride\n,\nint64_t\ncolumnsBatchStride\n,\nint64_t\nvaluesBatchStride\n)\nThis function sets the\nbatchCount\nand the\nbatchStride\nfields of the sparse matrix descriptor\nspMatDescr\n.\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nIN\nSparse matrix descriptor\nbatchCount\nHOST\nIN\nNumber of batches of the sparse matrix\noffsetsBatchStride\nHOST\nIN\nAddress offset between consecutive batches for the row offset array\ncolumnsBatchStride\nHOST\nIN\nAddress offset between consecutive batches for the column array\nvaluesBatchStride\nHOST\nIN\nAddress offset between consecutive batches for the values array\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.7.\nAll Sparse Formats\n\n6.5.7.1.\ncusparseDestroySpMat()\n\ncusparseStatus_t\ncusparseDestroySpMat\n(\ncusparseConstSpMatDescr_t\nspMatDescr\n)\n// non-const descriptor supported\nThis function releases the host memory allocated for the sparse matrix descriptor\nspMatDescr\n.\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nIN\nSparse matrix descriptor\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.7.2.\ncusparseSpMatGetSize()\n\ncusparseStatus_t\ncusparseSpMatGetSize\n(\ncusparseConstSpMatDescr_t\nspMatDescr\n,\n// non-const descriptor supported\nint64_t\n*\nrows\n,\nint64_t\n*\ncols\n,\nint64_t\n*\nnnz\n)\nThis function returns the sizes of the sparse matrix\nspMatDescr\n.\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nIN\nSparse matrix descriptor\nrows\nHOST\nOUT\nNumber of rows of the sparse matrix\ncols\nHOST\nOUT\nNumber of columns of the sparse matrix\nnnz\nHOST\nOUT\nNumber of non-zero entries of the sparse matrix\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.7.3.\ncusparseSpMatGetFormat()\n\ncusparseStatus_t\ncusparseSpMatGetFormat\n(\ncusparseConstSpMatDescr_t\nspMatDescr\n,\n// non-const descriptor supported\ncusparseFormat_t\n*\nformat\n)\nThis function returns the\nformat\nfield of the sparse matrix descriptor\nspMatDescr\n.\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nIN\nSparse matrix descriptor\nformat\nHOST\nOUT\nStorage format of the sparse matrix\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.7.4.\ncusparseSpMatGetIndexBase()\n\ncusparseStatus_t\ncusparseSpMatGetIndexBase\n(\ncusparseConstSpMatDescr_t\nspMatDescr\n,\n// non-const descriptor supported\ncusparseIndexBase_t\n*\nidxBase\n)\nThis function returns the\nidxBase\nfield of the sparse matrix descriptor\nspMatDescr\n.\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nIN\nSparse matrix descriptor\nidxBase\nHOST\nOUT\nIndex base of the sparse matrix\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.7.5.\ncusparseSpMatGetValues()\n\ncusparseStatus_t\ncusparseSpMatGetValues\n(\ncusparseSpMatDescr_t\nspMatDescr\n,\nvoid\n**\nvalues\n)\ncusparseStatus_t\ncusparseConstSpMatGetValues\n(\ncusparseConstSpMatDescr_t\nspMatDescr\n,\nconst\nvoid\n**\nvalues\n)\nThis function returns the\nvalues\nfield of the sparse matrix descriptor\nspMatDescr\n.\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nIN\nSparse matrix descriptor\nvalues\nDEVICE\nOUT\nValues of the sparse matrix. Array with\nnnz\nelements\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.7.6.\ncusparseSpMatSetValues()\n\ncusparseStatus_t\ncusparseSpMatSetValues\n(\ncusparseSpMatDescr_t\nspMatDescr\n,\nvoid\n*\nvalues\n)\nThis function sets the\nvalues\nfield of the sparse matrix descriptor\nspMatDescr\n.\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nIN\nSparse matrix descriptor\nvalues\nDEVICE\nIN\nValues of the sparse matrix. Array with\nnnz\nelements\ncusparseSpMatSetValues()\nhas the following constraints:\nvalues\nmust be aligned to the size of its corresponding datatype specified in\nspMatDescr\n. See\ncudaDataType_t\nfor the description of the datatypes.\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.7.7.\ncusparseSpMatGetStridedBatch()\n\ncusparseStatus_t\ncusparseSpMatGetStridedBatch\n(\ncusparseConstSpMatDescr_t\nspMatDescr\n,\n// non-const descriptor supported\nint\n*\nbatchCount\n)\nThis function returns the\nbatchCount\nfield of the sparse matrix descriptor\nspMatDescr\n.\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nIN\nSparse matrix descriptor\nbatchCount\nHOST\nOUT\nNumber of batches of the sparse matrix\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.7.8.\ncusparseSpMatGetAttribute()\n\ncusparseStatus_t\ncusparseSpMatGetAttribute\n(\ncusparseConstSpMatDescr_t\nspMatDescr\n,\n// non-const descriptor supported\ncusparseSpMatAttribute_t\nattribute\n,\nvoid\n*\ndata\n,\nsize_t\ndataSize\n)\nThe function gets the attributes of the sparse matrix descriptor\nspMatDescr\n.\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nIN\nSparse matrix descriptor\nattribute\nHOST\nIN\nAttribute enumerator\ndata\nHOST\nOUT\nAttribute value\ndataSize\nHOST\nIN\nSize of the attribute in bytes for safety\nAttribute\nMeaning\nPossible Values\nCUSPARSE_SPMAT_FILL_MODE\nIndicates if the lower or upper part of a matrix is stored in sparse storage\nCUSPARSE_FILL_MODE_LOWER\nCUSPARSE_FILL_MODE_UPPER\nCUSPARSE_SPMAT_DIAG_TYPE\nIndicates if the matrix diagonal entries are unity\nCUSPARSE_DIAG_TYPE_NON_UNIT\nCUSPARSE_DIAG_TYPE_UNIT\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.5.7.9.\ncusparseSpMatSetAttribute()\n\ncusparseStatus_t\ncusparseSpMatSetAttribute\n(\ncusparseSpMatDescr_t\nspMatDescr\n,\ncusparseSpMatAttribute_t\nattribute\n,\nconst\nvoid\n*\ndata\n,\nsize_t\ndataSize\n)\nThe function sets the attributes of the sparse matrix descriptor\nspMatDescr\nParam.\nMemory\nIn/out\nMeaning\nspMatDescr\nHOST\nOUT\nSparse matrix descriptor\nattribute\nHOST\nIN\nAttribute enumerator\ndata\nHOST\nIN\nAttribute value\ndataSize\nHOST\nIN\nSize of the attribute in bytes for safety\nAttribute\nMeaning\nPossible Values\nCUSPARSE_SPMAT_FILL_MODE\nIndicates if the lower or upper part of a matrix is stored in sparse storage\nCUSPARSE_FILL_MODE_LOWER\nCUSPARSE_FILL_MODE_UPPER\nCUSPARSE_SPMAT_DIAG_TYPE\nIndicates if the matrix diagonal entries are unity\nCUSPARSE_DIAG_TYPE_NON_UNIT\nCUSPARSE_DIAG_TYPE_UNIT\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.6.\nGeneric API Functions\n\n6.6.1.\ncusparseAxpby() [DEPRECATED]\n\n>\nThis routine will be removed in a future major release.\ncusparseStatus_t\ncusparseAxpby\n(\ncusparseHandle_t\nhandle\n,\nconst\nvoid\n*\nalpha\n,\ncusparseConstSpVecDescr_t\nvecX\n,\n// non-const descriptor supported\nconst\nvoid\n*\nbeta\n,\ncusparseDnVecDescr_t\nvecY\n)\nThe function computes the sum of a sparse vector\nvecX\nand a dense vector\nvecY\n.\n\\[\\mathbf{Y} = \\alpha\\mathbf{X} + \\beta\\mathbf{Y}\\]\nIn other words,\nfor\ni\n=\n0\nto\nn\n-1\nY\n[\ni\n]\n=\nbeta\n*\nY\n[\ni\n]\nfor\ni\n=\n0\nto\nnnz\n-1\nY\n[\nX_indices\n[\ni\n]]\n+=\nalpha\n*\nX_values\n[\ni\n]\nParam.\nMemory\nIn/out\nMeaning\nhandle\nHOST\nIN\nHandle to the cuSPARSE library context\nalpha\nHOST or DEVICE\nIN\n\\(\\alpha\\)\nscalar used for multiplication of compute type\nvecX\nHOST\nIN\nSparse vector\nX\nbeta\nHOST or DEVICE\nIN\n\\(\\beta\\)\nscalar used for multiplication of compute type\nvecY\nHOST\nIN/OUT\nDense vector\nY\ncusparseAxpby\nsupports the following index type for representing the sparse vector\nvecX\n:\n32-bit indices (\nCUSPARSE_INDEX_32I\n)\n64-bit indices (\nCUSPARSE_INDEX_64I\n)\ncusparseAxpby\nsupports the following data types:\nUniform-precision computation:\nX\n/\nY\n/\ncompute\nCUDA_R_32F\nCUDA_R_64F\nCUDA_C_32F\nCUDA_C_64F\nMixed-precision computation:\nX\n/\nY\ncompute\nCUDA_R_16F\nCUDA_R_32F\nCUDA_R_16BF\nCUDA_C_16F\nCUDA_C_32F\n[DEPRECATED]\nCUDA_C_16BF\n[DEPRECATED]\ncusparseAxpby()\nhas the following constraints:\nThe arrays representing the sparse vector\nvecX\nmust be aligned to 16 bytes\ncusparseAxpby()\nhas the following properties:\nThe routine requires no extra storage\nThe routine supports asynchronous execution\nProvides deterministic (bit-wise) results for each run if the the sparse vector\nvecX\nindices are distinct\nThe routine allows\nindices\nof\nvecX\nto be unsorted\ncusparseAxpby()\nsupports the following\noptimizations\n:\nCUDA graph capture\nHardware Memory Compression\nSee\ncusparseStatus_t\nfor the description of the return status.\nPlease visit\ncuSPARSE Library Samples - cusparseAxpby\nfor a code example.\n6.6.2.\ncusparseGather()\n\ncusparseStatus_t\ncusparseGather\n(\ncusparseHandle_t\nhandle\n,\ncusparseConstDnVecDescr_t\nvecY\n,\n// non-const descriptor supported\ncusparseSpVecDescr_t\nvecX\n)\nThe function gathers the elements of the dense vector\nvecY\ninto the sparse vector\nvecX\nIn other words,\nfor\ni\n=\n0\nto\nnnz\n-1\nX_values\n[\ni\n]\n=\nY\n[\nX_indices\n[\ni\n]]\nParam.\nMemory\nIn/out\nMeaning\nhandle\nHOST\nIN\nHandle to the cuSPARSE library context\nvecX\nHOST\nOUT\nSparse vector\nX\nvecY\nHOST\nIN\nDense vector\nY\ncusparseGather\nsupports the following index type for representing the sparse vector\nvecX\n:\n32-bit indices (\nCUSPARSE_INDEX_32I\n)\n64-bit indices (\nCUSPARSE_INDEX_64I\n)\ncusparseGather\nsupports the following data types:\nX\n/\nY\nCUDA_R_16F\nCUDA_R_16BF\nCUDA_R_32F\nCUDA_R_64F\nCUDA_C_16F\n[DEPRECATED]\nCUDA_C_16BF\n[DEPRECATED]\nCUDA_C_32F\nCUDA_C_64F\ncusparseGather()\nhas the following constraints:\nThe arrays representing the sparse vector\nvecX\nmust be aligned to 16 bytes\ncusparseGather()\nhas the following properties:\nThe routine requires no extra storage\nThe routine supports asynchronous execution\nProvides deterministic (bit-wise) results for each run if the the sparse vector\nvecX\nindices are distinct\nThe routine allows\nindices\nof\nvecX\nto be unsorted\ncusparseGather()\nsupports the following\noptimizations\n:\nCUDA graph capture\nHardware Memory Compression\nSee\ncusparseStatus_t\nfor the description of the return status.\nPlease visit\ncuSPARSE Library Samples - cusparseGather\nfor a code example.\n6.6.3.\ncusparseScatter()\n\ncusparseStatus_t\ncusparseScatter\n(\ncusparseHandle_t\nhandle\n,\ncusparseConstSpVecDescr_t\nvecX\n,\n// non-const descriptor supported\ncusparseDnVecDescr_t\nvecY\n)\nThe function scatters the elements of the sparse vector\nvecX\ninto the dense vector\nvecY\nIn other words,\nfor\ni\n=\n0\nto\nnnz\n-1\nY\n[\nX_indices\n[\ni\n]]\n=\nX_values\n[\ni\n]\nParam.\nMemory\nIn/out\nMeaning\nhandle\nHOST\nIN\nHandle to the cuSPARSE library context\nvecX\nHOST\nIN\nSparse vector\nX\nvecY\nHOST\nOUT\nDense vector\nY\ncusparseScatter\nsupports the following index type for representing the sparse vector\nvecX\n:\n32-bit indices (\nCUSPARSE_INDEX_32I\n)\n64-bit indices (\nCUSPARSE_INDEX_64I\n)\ncusparseScatter\nsupports the following data types:\nX\n/\nY\nCUDA_R_8I\nCUDA_R_16F\nCUDA_R_16BF\nCUDA_R_32F\nCUDA_R_64F\nCUDA_C_16F\n[DEPRECATED]\nCUDA_C_16BF\n[DEPRECATED]\nCUDA_C_32F\nCUDA_C_64F\ncusparseScatter()\nhas the following constraints:\nThe arrays representing the sparse vector\nvecX\nmust be aligned to 16 bytes\ncusparseScatter()\nhas the following properties:\nThe routine requires no extra storage\nThe routine supports asynchronous execution\nProvides deterministic (bit-wise) results for each run if the the sparse vector\nvecX\nindices are distinct\nThe routine allows\nindices\nof\nvecX\nto be unsorted\ncusparseScatter()\nsupports the following\noptimizations\n:\nCUDA graph capture\nHardware Memory Compression\nSee\ncusparseStatus_t\nfor the description of the return status.\nPlease visit\ncuSPARSE Library Samples - cusparseScatter\nfor a code example.\n6.6.4.\ncusparseRot() [DEPRECATED]\n\n>\nThe routine will be removed in the next major release\ncusparseStatus_t\ncusparseRot\n(\ncusparseHandle_t\nhandle\n,\nconst\nvoid\n*\nc_coeff\n,\nconst\nvoid\n*\ns_coeff\n,\ncusparseSpVecDescr_t\nvecX\n,\ncusparseDnVecDescr_t\nvecY\n)\nThe function computes the Givens rotation matrix\n\\[\\begin{split}G = \\begin{bmatrix}\nc & s \\\\\n{- s} & c \\\\\n\\end{bmatrix}\\end{split}\\]\nto a sparse\nvecX\nand a dense vector\nvecY\nIn other words,\nfor\ni\n=\n0\nto\nnnz\n-1\nY\n[\nX_indices\n[\ni\n]]\n=\nc\n*\nY\n[\nX_indices\n[\ni\n]]\n-\ns\n*\nX_values\n[\ni\n]\nX_values\n[\ni\n]\n=\nc\n*\nX_values\n[\ni\n]\n+\ns\n*\nY\n[\nX_indices\n[\ni\n]]\nParam.\nMemory\nIn/out\nMeaning\nhandle\nHOST\nIN\nHandle to the cuSPARSE library context\nc_coeff\nHOST or DEVICE\nIN\ncosine element of the rotation matrix\nvecX\nHOST\nIN/OUT\nSparse vector\nX\ns_coeff\nHOST or DEVICE\nIN\nsine element of the rotation matrix\nvecY\nHOST\nIN/OUT\nDense vector\nY\ncusparseRot\nsupports the following index type for representing the sparse vector\nvecX\n:\n32-bit indices (\nCUSPARSE_INDEX_32I\n)\n64-bit indices (\nCUSPARSE_INDEX_64I\n)\ncusparseRot\nsupports the following data types:\nUniform-precision computation:\nX\n/\nY\n/\ncompute\nCUDA_R_32F\nCUDA_R_64F\nCUDA_C_32F\nCUDA_C_64F\nMixed-precision computation:\nX\n/\nY\ncompute\nCUDA_R_16F\nCUDA_R_32F\nCUDA_R_16BF\nCUDA_C_16F\nCUDA_C_32F\n[DEPRECATED]\nCUDA_C_16BF\n[DEPRECATED]\ncusparseRot()\nhas the following constraints:\nThe arrays representing the sparse vector\nvecX\nmust be aligned to 16 bytes\ncusparseRot()\nhas the following properties:\nThe routine requires no extra storage\nThe routine supports asynchronous execution\nProvides deterministic (bit-wise) results for each run if the the sparse vector\nvecX\nindices are distinct\ncusparseRot()\nsupports the following\noptimizations\n:\nCUDA graph capture\nHardware Memory Compression\nSee\ncusparseStatus_t\nfor the description of the return status.\nPlease visit\ncuSPARSE Library Samples - cusparseRot\nfor a code example.\n6.6.5.\ncusparseSpVV() [DEPRECATED]\n\n>\nThis routine will be removed in a future major release.\ncusparseStatus_t\ncusparseSpVV_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopX\n,\ncusparseConstSpVecDescr_t\nvecX\n,\n// non-const descriptor supported\ncusparseConstDnVecDescr_t\nvecY\n,\n// non-const descriptor supported\nvoid\n*\nresult\n,\ncudaDataType\ncomputeType\n,\nsize_t\n*\nbufferSize\n)\ncusparseStatus_t\ncusparseSpVV\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopX\n,\ncusparseConstSpVecDescr_t\nvecX\n,\n// non-const descriptor supported\ncusparseConstDnVecDescr_t\nvecY\n,\n// non-const descriptor supported\nvoid\n*\nresult\n,\ncudaDataType\ncomputeType\n,\nvoid\n*\nexternalBuffer\n)\nThe function computes the inner dot product of a sparse vector\nvecX\nand a dense vector\nvecY\n\\[result = op\\left(\\mathbf{X}\\right) \\cdot \\mathbf{Y}\\]\nIn other words,\nresult\n=\n0\n;\nfor\ni\n=\n0\nto\nnnz\n-1\nresult\n+=\nop\n(\nX_values\n[\ni\n])\n*\nY\n[\nX_indices\n[\ni\n]]\nThe function\ncusparseSpVV_bufferSize()\nreturns the size of the workspace needed by\ncusparseSpVV()\nParam.\nMemory\nIn/out\nMeaning\nhandle\nHOST\nIN\nHandle to the cuSPARSE library context\nopX\nHOST\nIN\nOperation\nop(X)\nthat is non-transpose or conjugate transpose\nvecX\nHOST\nIN\nSparse vector\nX\nvecY\nHOST\nIN\nDense vector\nY\nresult\nHOST or DEVICE\nOUT\nThe resulting dot product\ncomputeType\nHOST\nIN\nDatatype in which the computation is executed\nbufferSize\nHOST\nOUT\nNumber of bytes of workspace needed by\ncusparseSpVV\nexternalBuffer\nDEVICE\nIN\nPointer to a workspace buffer of at least\nbufferSize\nbytes\ncusparseSpVV\nsupports the following index type for representing the sparse vector\nvecX\n:\n32-bit indices (\nCUSPARSE_INDEX_32I\n)\n64-bit indices (\nCUSPARSE_INDEX_64I\n)\nThe data types combinations currently supported for\ncusparseSpVV\nare listed below:\nUniform-precision computation:\nX\n/\nY\n/\ncomputeType\nCUDA_R_32F\nCUDA_R_64F\nCUDA_C_32F\nCUDA_C_64F\nMixed-precision computation:\nX\n/\nY\ncomputeType\n/\nresult\nNotes\nCUDA_R_8I\nCUDA_R_32I\nCUDA_R_8I\nCUDA_R_32F\nCUDA_R_16F\nCUDA_R_32F\nCUDA_R_16BF\nCUDA_R_32F\nCUDA_C_16F\nCUDA_C_32F\n[DEPRECATED]\nCUDA_C_16BF\nCUDA_C_32F\n[DEPRECATED]\ncusparseSpVV()\nhas the following constraints:\nThe arrays representing the sparse vector\nvecX\nmust be aligned to 16 bytes\ncusparseSpVV()\nhas the following properties:\nThe routine requires no extra storage\nThe routine supports asynchronous execution\nProvides deterministic (bit-wise) results for each run if the the sparse vector\nvecX\nindices are distinct\nThe routine allows\nindices\nof\nvecX\nto be unsorted\ncusparseSpVV()\nsupports the following\noptimizations\n:\nCUDA graph capture\nHardware Memory Compression\nSee\ncusparseStatus_t\nfor the description of the return status.\nPlease visit\ncuSPARSE Library Samples - cusparseSpVV\nfor a code example.\n6.6.6.\ncusparseSpMV()\n\ncusparseStatus_t\ncusparseSpMV_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopA\n,\nconst\nvoid\n*\nalpha\n,\ncusparseConstSpMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseConstDnVecDescr_t\nvecX\n,\n// non-const descriptor supported\nconst\nvoid\n*\nbeta\n,\ncusparseDnVecDescr_t\nvecY\n,\ncudaDataType\ncomputeType\n,\ncusparseSpMVAlg_t\nalg\n,\nsize_t\n*\nbufferSize\n)\ncusparseStatus_t\ncusparseSpMV_preprocess\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopA\n,\nconst\nvoid\n*\nalpha\n,\ncusparseConstSpMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseConstDnVecDescr_t\nvecX\n,\n// non-const descriptor supported\nconst\nvoid\n*\nbeta\n,\ncusparseDnVecDescr_t\nvecY\n,\ncudaDataType\ncomputeType\n,\ncusparseSpMVAlg_t\nalg\n,\nvoid\n*\nexternalBuffer\n)\ncusparseStatus_t\ncusparseSpMV\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopA\n,\nconst\nvoid\n*\nalpha\n,\ncusparseConstSpMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseConstDnVecDescr_t\nvecX\n,\n// non-const descriptor supported\nconst\nvoid\n*\nbeta\n,\ncusparseDnVecDescr_t\nvecY\n,\ncudaDataType\ncomputeType\n,\ncusparseSpMVAlg_t\nalg\n,\nvoid\n*\nexternalBuffer\n)\nThis function performs the multiplication of a sparse matrix\nmatA\nand a dense vector\nvecX\n\\[\\mathbf{Y} = \\alpha op\\left( \\mathbf{A} \\right) \\cdot \\mathbf{X} + \\beta\\mathbf{Y}\\]\nwhere\nop(A)\nis a sparse matrix of size\n\\(m \\times k\\)\nX\nis a dense vector of size\n\\(k\\)\nY\nis a dense vector of size\n\\(m\\)\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars\nAlso, for matrix\nA\nThe function\ncusparseSpMV_bufferSize()\nreturns the size of the workspace needed by\ncusparseSpMV_preprocess()\nand\ncusparseSpMV()\nParam.\nMemory\nIn/out\nMeaning\nhandle\nHOST\nIN\nHandle to the cuSPARSE library context\nopA\nHOST\nIN\nOperation\nop(A)\nalpha\nHOST or DEVICE\nIN\n\\(\\alpha\\)\nscalar used for multiplication of type\ncomputeType\nmatA\nHOST\nIN\nSparse matrix\nA\nvecX\nHOST\nIN\nDense vector\nX\nbeta\nHOST or DEVICE\nIN\n\\(\\beta\\)\nscalar used for multiplication of type\ncomputeType\nvecY\nHOST\nIN/OUT\nDense vector\nY\ncomputeType\nHOST\nIN\nDatatype in which the computation is executed\nalg\nHOST\nIN\nAlgorithm for the computation\nbufferSize\nHOST\nOUT\nNumber of bytes of workspace needed by\ncusparseSpMV\nexternalBuffer\nDEVICE\nIN\nPointer to a workspace buffer of at least\nbufferSize\nbytes\nThe sparse matrix formats currently supported are listed below:\nCUSPARSE_FORMAT_COO\nCUSPARSE_FORMAT_CSR\nCUSPARSE_FORMAT_CSC\nCUSPARSE_FORMAT_BSR\nCUSPARSE_FORMAT_SLICED_ELL\ncusparseSpMV\nsupports the following index type for representing the sparse matrix\nmatA\n:\n32-bit indices (\nCUSPARSE_INDEX_32I\n)\n64-bit indices (\nCUSPARSE_INDEX_64I\n)\ncusparseSpMV\nsupports the following data types:\nUniform-precision computation:\nA\n/\nX\n/\nY\n/\ncomputeType\nCUDA_R_32F\nCUDA_R_64F\nCUDA_C_32F\nCUDA_C_64F\nMixed-precision computation:\nA\n/\nX\nY\ncomputeType\nNotes\nCUDA_R_8I\nCUDA_R_32I\nCUDA_R_32I\nCUDA_R_8I\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_16F\nCUDA_R_16BF\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_16BF\nCUDA_R_16BF\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_16F\nCUDA_C_16F\n[DEPRECATED]\nCUDA_C_16BF\nCUDA_C_16BF\n[DEPRECATED]\nA\nX\n/\nY\n/\ncomputeType\nCUDA_R_32F\nCUDA_R_64F\nMixed Regular/Complex computation:\nA\nX\n/\nY\n/\ncomputeType\nCUDA_R_32F\nCUDA_C_32F\nCUDA_R_64F\nCUDA_C_64F\nNOTE:\nCUDA_R_16F\n,\nCUDA_R_16BF\n,\nCUDA_C_16F\n, and\nCUDA_C_16BF\ndata types always imply mixed-precision computation.\ncusparseSpMV()\nsupports the following algorithms:\nAlgorithm\nNotes\nCUSPARSE_SPMV_ALG_DEFAULT\nDefault algorithm for any sparse matrix format.\nCUSPARSE_SPMV_COO_ALG1\nDefault algorithm for COO sparse matrix format. May produce slightly different results during different runs with the same input parameters.\nCUSPARSE_SPMV_COO_ALG2\nProvides deterministic (bit-wise) results for each run. If\nopA\n!=\nCUSPARSE_OPERATION_NON_TRANSPOSE\n, it is identical to\nCUSPARSE_SPMV_COO_ALG1\n.\nCUSPARSE_SPMV_CSR_ALG1\nDefault algorithm for CSR/CSC sparse matrix format. May produce slightly different results during different runs with the same input parameters.\nCUSPARSE_SPMV_CSR_ALG2\nProvides deterministic (bit-wise) results for each run. If\nopA\n!=\nCUSPARSE_OPERATION_NON_TRANSPOSE\n, it is identical to\nCUSPARSE_SPMV_CSR_ALG1\n.\nCUSPARSE_SPMV_SELL_ALG1\nDefault algorithm for Sliced Ellpack sparse matrix format. Provides deterministic (bit-wise) results for each run.\nCUSPARSE_SPMV_BSR_ALG1\nDefault algorithm for BSR sparse matrix format. Provides deterministic (bit-wise) results for each run.\nSupports only\nopA\n==\nCUSPARSE_OPERATION_NON_TRANSPOSE\n. Supports both row-major and column-major block layouts in\nA\n.\nCalling\ncusparseSpMV_preprocess()\nis optional.\nIt may accelerate subsequent calls to\ncusparseSpMV()\n.\nIt is useful when\ncusparseSpMV()\nis called multiple times with the same sparsity pattern (\nmatA\n).\nCalling\ncusparseSpMV_preprocess()\nwith\nbuffer\nmakes that buffer “active” for\nmatA\nSpMV calls.\nSubsequent calls to\ncusparseSpMV()\nwith\nmatA\nand the active buffer\nmust use the same values for all parameters as the call to\ncusparseSpMV_preprocess()\n.\nThe exceptions are:\nalpha\n,\nbeta\n,\nvecX\n,\nvecY\n, and the values (but not indices) of\nmatA\nmay be different.\nImportantly, the buffer contents must be unmodified since the call to\ncusparseSpMV_preprocess()\n.\nWhen\ncusparseSpMV()\nis called with\nmatA\nand its active buffer, it may read acceleration data from the buffer.\nCalling\ncusparseSpMV_preprocess()\nagain with\nmatA\nand a new buffer will make the new buffer active,\nforgetting about the previously-active buffer and making it inactive.\nFor\ncusparseSpMV()\n, there can only be one active buffer per sparse matrix at a time.\nTo get the effect of multiple active buffers for a single sparse matrix,\ncreate multiple matrix handles that all point to the same index and value buffers,\nand call\ncusparseSpMV_preprocess()\nonce per handle with different workspace buffers.\nCalling\ncusparseSpMV()\nwith an inactive buffer is always permitted.\nHowever, there may be no acceleration from the preprocessing in that case.\nFor the purposes of\nthread safety\n,\ncusparseSpMV_preprocess()\nis writing to\nmatA\ninternal state.\nPerformance notes:\nCUSPARSE_SPMV_COO_ALG1\nand\nCUSPARSE_SPMV_CSR_ALG1\nprovide higher performance than\nCUSPARSE_SPMV_COO_ALG2\nand\nCUSPARSE_SPMV_CSR_ALG2\n.\nIn general,\nopA\n==\nCUSPARSE_OPERATION_NON_TRANSPOSE\nis 3x faster than\nopA\n!=\nCUSPARSE_OPERATION_NON_TRANSPOSE\n.\nUsing\ncusparseSpMV_preprocess()\nhelps improve performance of\ncusparseSpMV()\nin CSR. It is beneficial when we need to run\ncusparseSpMV()\nmultiple times with a same matrix (\ncusparseSpMV_preprocess()\nis executed only once).\ncusparseSpMV()\nhas the following properties:\nThe routine requires extra storage for CSR/CSC format (all algorithms) and for COO format with\nCUSPARSE_SPMV_COO_ALG2\nalgorithm.\nProvides deterministic (bit-wise) results for each run only for\nCUSPARSE_SPMV_COO_ALG2\n,\nCUSPARSE_SPMV_CSR_ALG2\nand\nCUSPARSE_SPMV_BSR_ALG1\nalgorithms, and\nopA\n==\nCUSPARSE_OPERATION_NON_TRANSPOSE\n.\nThe routine supports asynchronous execution.\ncompute-sanitizer could report false race conditions for this routine when\nbeta\n==\n0\n. This is for optimization purposes and does not affect the correctness of the computation.\nThe routine allows the indices of\nmatA\nto be unsorted.\ncusparseSpMV()\nsupports the following\noptimizations\n:\nCUDA graph capture\nHardware Memory Compression\nSee\ncusparseStatus_t\nfor the description of the return status.\nPlease visit\ncuSPARSE Library Samples - cusparseSpMV CSR\nand\ncusparseSpMV COO\nfor a code example.\n6.6.7.\ncusparseSpSV()\n\ncusparseStatus_t\ncusparseSpSV_createDescr\n(\ncusparseSpSVDescr_t\n*\nspsvDescr\n);\ncusparseStatus_t\ncusparseSpSV_destroyDescr\n(\ncusparseSpSVDescr_t\nspsvDescr\n);\ncusparseStatus_t\ncusparseSpSV_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopA\n,\nconst\nvoid\n*\nalpha\n,\ncusparseConstSpMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseConstDnVecDescr_t\nvecX\n,\n// non-const descriptor supported\ncusparseDnVecDescr_t\nvecY\n,\ncudaDataType\ncomputeType\n,\ncusparseSpSVAlg_t\nalg\n,\ncusparseSpSVDescr_t\nspsvDescr\n,\nsize_t\n*\nbufferSize\n)\ncusparseStatus_t\ncusparseSpSV_analysis\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopA\n,\nconst\nvoid\n*\nalpha\n,\ncusparseConstSpMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseConstDnVecDescr_t\nvecX\n,\n// non-const descriptor supported\ncusparseDnVecDescr_t\nvecY\n,\ncudaDataType\ncomputeType\n,\ncusparseSpSVAlg_t\nalg\n,\ncusparseSpSVDescr_t\nspsvDescr\nvoid\n*\nexternalBuffer\n)\ncusparseStatus_t\ncusparseSpSV_solve\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopA\n,\nconst\nvoid\n*\nalpha\n,\ncusparseConstSpMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseConstDnVecDescr_t\nvecX\n,\n// non-const descriptor supported\ncusparseDnVecDescr_t\nvecY\n,\ncudaDataType\ncomputeType\n,\ncusparseSpSVAlg_t\nalg\n,\ncusparseSpSVDescr_t\nspsvDescr\n)\ncusparseStatus_t\ncusparseSpSV_updateMatrix\n(\ncusparseHandle_t\nhandle\n,\ncusparseSpSVDescr_t\nspsvDescr\n,\nvoid\n*\nnewValues\n,\ncusparseSpSVUpdate_t\nupdatePart\n)\nThe function solves a system of linear equations whose coefficients are represented in a sparse triangular matrix:\n\\[op\\left( \\mathbf{A} \\right) \\cdot \\mathbf{Y} = \\alpha\\mathbf{X}\\]\nwhere\nop(A)\nis a sparse square matrix of size\n\\(m \\times m\\)\nX\nis a dense vector of size\n\\(m\\)\nY\nis a dense vector of size\n\\(m\\)\n\\(\\alpha\\)\nis a scalar\nAlso, for matrix\nA\nThe function\ncusparseSpSV_bufferSize()\nreturns the size of the workspace needed by\ncusparseSpSV_analysis()\nand\ncusparseSpSV_solve()\n.\nThe function\ncusparseSpSV_analysis()\nperforms the analysis phase, while\ncusparseSpSV_solve()\nexecutes the solve phase for a sparse triangular linear system.\nThe opaque data structure\nspsvDescr\nis used to share information among all functions.\nThe function\ncusparseSpSV_updateMatrix()\nupdates\nspsvDescr\nwith new matrix values.\nThe routine supports arbitrary sparsity for the input matrix, but only the upper or lower triangular part is taken into account in the computation.\nNOTE:\nall parameters must be consistent across\ncusparseSpSV\nAPI calls and the matrix descriptions and\nexternalBuffer\nmust not be modified between\ncusparseSpSV_analysis()\nand\ncusparseSpSV_solve()\n. The function\ncusparseSpSV_updateMatrix()\ncan be used to update the values on the sparse matrix stored inside the opaque data structure\nspsvDescr\nParam.\nMemory\nIn/out\nMeaning\nhandle\nHOST\nIN\nHandle to the cuSPARSE library context\nopA\nHOST\nIN\nOperation\nop(A)\nalpha\nHOST or DEVICE\nIN\n\\(\\alpha\\)\nscalar used for multiplication of type\ncomputeType\nmatA\nHOST\nIN\nSparse matrix\nA\nvecX\nHOST\nIN\nDense vector\nX\nvecY\nHOST\nIN/OUT\nDense vector\nY\ncomputeType\nHOST\nIN\nDatatype in which the computation is executed\nalg\nHOST\nIN\nAlgorithm for the computation\nbufferSize\nHOST\nOUT\nNumber of bytes of workspace needed by\ncusparseSpSV_analysis()\nand\ncusparseSpSV_solve()\nexternalBuffer\nDEVICE\nIN/OUT\nPointer to a workspace buffer of at least\nbufferSize\nbytes. It is used by\ncusparseSpSV_analysis\nand\ncusparseSpSV_solve()\nspsvDescr\nHOST\nIN/OUT\nOpaque descriptor for storing internal data used across the three steps\nThe sparse matrix formats currently supported are listed below:\nCUSPARSE_FORMAT_CSR\nCUSPARSE_FORMAT_COO\nCUSPARSE_FORMAT_SLICED_ELL\nThe\ncusparseSpSV()\nsupports the following shapes and properties:\nCUSPARSE_FILL_MODE_LOWER\nand\nCUSPARSE_FILL_MODE_UPPER\nfill modes\nCUSPARSE_DIAG_TYPE_NON_UNIT\nand\nCUSPARSE_DIAG_TYPE_UNIT\ndiagonal types\nThe fill mode and diagonal type can be set by\ncusparseSpMatSetAttribute()\n.\ncusparseSpSV()\nsupports the following index type for representing the sparse matrix\nmatA\n:\n32-bit indices (\nCUSPARSE_INDEX_32I\n)\n64-bit indices (\nCUSPARSE_INDEX_64I\n)\ncusparseSpSV()\nsupports the following data types:\nUniform-precision computation:\nA\n/\nX\n/\nY\n/\ncomputeType\nCUDA_R_32F\nCUDA_R_64F\nCUDA_C_32F\nCUDA_C_64F\ncusparseSpSV()\nsupports the following algorithms:\nAlgorithm\nNotes\nCUSPARSE_SPSV_ALG_DEFAULT\nDefault algorithm\ncusparseSpSV()\nhas the following properties:\nThe routine requires extra storage for the analysis phase which is proportional to number of non-zero entries of the sparse matrix\nProvides deterministic (bit-wise) results for each run for the solving phase\ncusparseSpSV_solve()\nThe routine supports in-place operation\nThe\ncusparseSpSV_solve()\nroutine supports asynchronous execution\ncusparseSpSV_bufferSize()\nand\ncusparseSpSV_analysis()\nroutines accept\nNULL\nfor\nvecX\nand\nvecY\nThe routine allows the indices of\nmatA\nto be unsorted\ncusparseSpSV()\nsupports the following\noptimizations\n:\nCUDA graph capture\nHardware Memory Compression\ncusparseSpSV_updateMatrix()\nupdates the sparse matrix after calling the analysis phase. This functions supports the following update strategies (\nupdatePart\n):\nStrategy\nNotes\nCUSPARSE_SPSV_UPDATE_GENERAL\nUpdates the sparse matrix values with values of\nnewValues\narray\nCUSPARSE_SPSV_UPDATE_DIAGONAL\nUpdates the diagonal part of the matrix with diagonal values stored in\nnewValues\narray. That is,\nnewValues\nhas the new diagonal values only\nSee\ncusparseStatus_t\nfor the description of the return status.\nPlease visit\ncuSPARSE Library Samples - cusparseSpSV CSR\nand\ncuSPARSE Library Samples - cusparseSpSV COO\nfor code examples.\n6.6.8.\ncusparseSpMM()\n\ncusparseStatus_t\ncusparseSpMM_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopA\n,\ncusparseOperation_t\nopB\n,\nconst\nvoid\n*\nalpha\n,\ncusparseConstSpMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseConstDnMatDescr_t\nmatB\n,\n// non-const descriptor supported\nconst\nvoid\n*\nbeta\n,\ncusparseDnMatDescr_t\nmatC\n,\ncudaDataType\ncomputeType\n,\ncusparseSpMMAlg_t\nalg\n,\nsize_t\n*\nbufferSize\n)\ncusparseStatus_t\ncusparseSpMM_preprocess\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopA\n,\ncusparseOperation_t\nopB\n,\nconst\nvoid\n*\nalpha\n,\ncusparseConstSpMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseConstDnMatDescr_t\nmatB\n,\n// non-const descriptor supported\nconst\nvoid\n*\nbeta\n,\ncusparseDnMatDescr_t\nmatC\n,\ncudaDataType\ncomputeType\n,\ncusparseSpMMAlg_t\nalg\n,\nvoid\n*\nexternalBuffer\n)\ncusparseStatus_t\ncusparseSpMM\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopA\n,\ncusparseOperation_t\nopB\n,\nconst\nvoid\n*\nalpha\n,\ncusparseConstSpMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseConstDnMatDescr_t\nmatB\n,\n// non-const descriptor supported\nconst\nvoid\n*\nbeta\n,\ncusparseDnMatDescr_t\nmatC\n,\ncudaDataType\ncomputeType\n,\ncusparseSpMMAlg_t\nalg\n,\nvoid\n*\nexternalBuffer\n)\nThe function performs the multiplication of a sparse matrix\nmatA\nand a dense matrix\nmatB\n.\n\\[\\mathbf{C} = \\alpha op\\left( \\mathbf{A} \\right) \\cdot op\\left( \\mathbf{B} \\right) + \\beta\\mathbf{C}\\]\nwhere\nop(A)\nis a sparse matrix of size\n\\(m \\times k\\)\nop(B)\nis a dense matrix of size\n\\(k \\times n\\)\nC\nis a dense matrix of size\n\\(m \\times n\\)\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars\nThe routine can be also used to perform the multiplication of a dense matrix and a sparse matrix by switching the dense matrices layout:\n\\[\\begin{split}\\begin{array}{l}\n\\left. \\mathbf{C}_{C} = \\mathbf{B}_{C} \\cdot \\mathbf{A} + \\beta\\mathbf{C}_{C}\\rightarrow \\right. \\\\\n{\\mathbf{C}_{R} = \\mathbf{A}^{T} \\cdot \\mathbf{B}_{R} + \\beta\\mathbf{C}_{R}} \\\\\n\\end{array}\\end{split}\\]\nwhere\n\\(\\mathbf{B}_{C}\\)\n,\n\\(\\mathbf{C}_{C}\\)\nindicate column-major layout, while\n\\(\\mathbf{B}_{R}\\)\n,\n\\(\\mathbf{C}_{R}\\)\nrefer to row-major layout\nAlso, for matrix\nA\nand\nB\nWhen using the (conjugate) transpose of the sparse matrix\nA\n, this routine may produce slightly different results during different runs with the same input parameters.\nThe function\ncusparseSpMM_bufferSize()\nreturns the size of the workspace needed by\ncusparseSpMM()\nCalling\ncusparseSpMM_preprocess()\nis optional.\nIt may accelerate subsequent calls to\ncusparseSpMM()\n.\nIt is useful when\ncusparseSpMM()\nis called multiple times with the same sparsity pattern (\nmatA\n).\nIt provides performance advantages with\nCUSPARSE_SPMM_CSR_ALG1\nor\nCUSPARSE_SPMM_CSR_ALG3\n.\nFor all other formats and algorithms have no effect.\nCalling\ncusparseSpMM_preprocess()\nwith\nbuffer\nmakes that buffer “active” for\nmatA\nSpMM calls.\nSubsequent calls to\ncusparseSpMM()\nwith\nmatA\nand the active buffer\nmust use the same values for all parameters as the call to\ncusparseSpMM_preprocess()\n.\nThe exceptions are:\nalpha\n,\nbeta\n,\nmatX\n,\nmatY\n, and the values (but not indices) of\nmatA\nmay be different.\nImportantly, the buffer contents must be unmodified since the call to\ncusparseSpMM_preprocess()\n.\nWhen\ncusparseSpMM()\nis called with\nmatA\nand its active buffer, it may read acceleration data from the buffer.\nCalling\ncusparseSpMM_preprocess()\nagain with\nmatA\nand a new buffer will make the new buffer active,\nforgetting about the previously-active buffer and making it inactive.\nFor\ncusparseSpMM()\n, there can only be one active buffer per sparse matrix at a time.\nTo get the effect of multiple active buffers for a single sparse matrix,\ncreate multiple matrix handles that all point to the same index and value buffers,\nand call\ncusparseSpMM_preprocess()\nonce per handle with different workspace buffers.\nCalling\ncusparseSpMM()\nwith an inactive buffer is always permitted.\nHowever, there may be no acceleration from the preprocessing in that case.\nFor the purposes of\nthread safety\n,\ncusparseSpMM_preprocess()\nis writing to\nmatA\ninternal state.\nParam.\nMemory\nIn/out\nMeaning\nhandle\nHOST\nIN\nHandle to the cuSPARSE library context\nopA\nHOST\nIN\nOperation\nop(A)\nopB\nHOST\nIN\nOperation\nop(B)\nalpha\nHOST or DEVICE\nIN\n\\(\\alpha\\)\nscalar used for multiplication of type\ncomputeType\nmatA\nHOST\nIN\nSparse matrix\nA\nmatB\nHOST\nIN\nDense matrix\nB\nbeta\nHOST or DEVICE\nIN\n\\(\\beta\\)\nscalar used for multiplication of type\ncomputeType\nmatC\nHOST\nIN/OUT\nDense matrix\nC\ncomputeType\nHOST\nIN\nDatatype in which the computation is executed\nalg\nHOST\nIN\nAlgorithm for the computation\nbufferSize\nHOST\nOUT\nNumber of bytes of workspace needed by\ncusparseSpMM\nexternalBuffer\nDEVICE\nIN\nPointer to workspace buffer of at least\nbufferSize\nbytes\ncusparseSpMM\nsupports the following sparse matrix formats:\nCUSPARSE_FORMAT_COO\nCUSPARSE_FORMAT_CSR\nCUSPARSE_FORMAT_CSC\nCUSPARSE_FORMAT_BSR\nCUSPARSE_FORMAT_BLOCKED_ELL\n(1)\nCOO/CSR/CSC/BSR FORMATS\ncusparseSpMM\nsupports the following index type for representing the sparse matrix\nmatA\n:\n32-bit indices (\nCUSPARSE_INDEX_32I\n)\n64-bit indices (\nCUSPARSE_INDEX_64I\n)\ncusparseSpMM\nsupports the following data types:\nUniform-precision computation:\nA\n/\nB\n/\nC\n/\ncomputeType\nCUDA_R_32F\nCUDA_R_64F\nCUDA_C_32F\nCUDA_C_64F\nMixed-precision computation:\nA\n/\nB\nC\ncomputeType\nCUDA_R_8I\nCUDA_R_32I\nCUDA_R_32I\nCUDA_R_8I\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_16F\nCUDA_R_16BF\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_16BF\nCUDA_R_16BF\nCUDA_C_16F\nCUDA_C_16F\nCUDA_C_32F\n[DEPRECATED]\nCUDA_C_16BF\nCUDA_C_16BF\n[DEPRECATED]\nNOTE:\nCUDA_R_16F\n,\nCUDA_R_16BF\n,\nCUDA_C_16F\n, and\nCUDA_C_16BF\ndata types always imply mixed-precision computation.\ncusparseSpMM\nsupports the following algorithms:\nAlgorithm\nNotes\nCUSPARSE_SPMM_ALG_DEFAULT\nDefault algorithm for any sparse matrix format\nCUSPARSE_SPMM_COO_ALG1\nAlgorithm 1 for COO sparse matrix format\nMay provide better performance for small number of nnz\nProvides the best performance with column-major layout\nIt supports batched computation\nMay produce slightly different results during different runs with the same input parameters\nCUSPARSE_SPMM_COO_ALG2\nAlgorithm 2 for COO sparse matrix format\nIt provides deterministic result\nProvides the best performance with column-major layout\nIn general, slower than Algorithm 1\nIt supports batched computation\nIt requires additional memory\nIf\nopA\n!=\nCUSPARSE_OPERATION_NON_TRANSPOSE\n, it is identical to\nCUSPARSE_SPMM_COO_ALG1\nCUSPARSE_SPMM_COO_ALG3\nAlgorithm 3 for COO sparse matrix format\nMay provide better performance for large number of nnz\nMay produce slightly different results during different runs with the same input parameters\nCUSPARSE_SPMM_COO_ALG4\nAlgorithm 4 for COO sparse matrix format\nProvides better performance with row-major layout\nIt supports batched computation\nMay produce slightly different results during different runs with the same input parameters\nCUSPARSE_SPMM_CSR_ALG1\nAlgorithm 1 for CSR/CSC sparse matrix format\nProvides the best performance with column-major layout\nIt supports batched computation\nIt requires additional memory\nMay produce slightly different results during different runs with the same input parameters\nCUSPARSE_SPMM_CSR_ALG2\nAlgorithm 2 for CSR/CSC sparse matrix format\nProvides the best performance with row-major layout\nIt supports batched computation\nIt requires additional memory\nMay produce slightly different results during different runs with the same input parameters\nCUSPARSE_SPMM_CSR_ALG3\nAlgorithm 3 for CSR/CSC sparse matrix format\nIt provides deterministic result\nIt requires additional memory\nIt supports only\nopA\n==\nCUSPARSE_OPERATION_NON_TRANSPOSE\nIt does not support\nopB\n==\nCUSPARSE_OPERATION_CONJUGATE_TRANSPOSE\nIt does not support\nCUDA_C_16F\nand\nCUDA_C_16BF\ndata types\nCUSPARSE_SPMM_BSR_ALG1\nAlgorithm 1 for BSR sparse matrix format\nIt provides deterministic result\nIt requires no additional memory\nIt supports only\nopA\n==\nCUSPARSE_OPERATION_NON_TRANSPOSE\nIt does not support\nCUDA_C_16F\nand\nCUDA_C_16BF\ndata types\nIt does not support column-major blocks in\nA\nPerformance notes:\nRow-major layout provides higher performance than column-major\nCUSPARSE_SPMM_COO_ALG4\nand\nCUSPARSE_SPMM_CSR_ALG2\nshould be used with row-major layout, while\nCUSPARSE_SPMM_COO_ALG1\n,\nCUSPARSE_SPMM_COO_ALG2\n,\nCUSPARSE_SPMM_COO_ALG3\n, and\nCUSPARSE_SPMM_CSR_ALG1\nwith column-major layout\nFor\nbeta\n!=\n1\n, most algorithms scale the output matrix before the main computation\nFor\nn\n==\n1\n, the routine may use\ncusparseSpMV()\ncusparseSpMM()\nwith all algorithms support the following batch modes except for\nCUSPARSE_SPMM_CSR_ALG3\n:\n\\(C_{i} = A \\cdot B_{i}\\)\n\\(C_{i} = A_{i} \\cdot B\\)\n\\(C_{i} = A_{i} \\cdot B_{i}\\)\nThe number of batches and their strides can be set by using\ncusparseCooSetStridedBatch\n,\ncusparseCsrSetStridedBatch\n, and\ncusparseDnMatSetStridedBatch\n. The maximum number of batches for\ncusparseSpMM()\nis 65,535.\ncusparseSpMM()\nhas the following properties:\nThe routine requires no extra storage for\nCUSPARSE_SPMM_COO_ALG1\n,\nCUSPARSE_SPMM_COO_ALG3\n,\nCUSPARSE_SPMM_COO_ALG4\n,\nCUSPARSE_SPMM_BSR_ALG1\nThe routine supports asynchronous execution\nProvides deterministic (bit-wise) results for each run only for\nCUSPARSE_SPMM_COO_ALG2\n,\nCUSPARSE_SPMM_CSR_ALG3\n, and\nCUSPARSE_SPMM_BSR_ALG1\nalgorithms\ncompute-sanitizer\ncould report false race conditions for this routine. This is for optimization purposes and does not affect the correctness of the computation\nThe routine allows the indices of\nmatA\nto be unsorted\ncusparseSpMM()\nsupports the following\noptimizations\n:\nCUDA graph capture\nHardware Memory Compression\nPlease visit\ncuSPARSE Library Samples - cusparseSpMM CSR\nand\ncusparseSpMM COO\nfor a code example. For batched computation please visit\ncusparseSpMM CSR Batched\nand\ncusparseSpMM COO Batched\n.\n(2)\nBLOCKED-ELLPACK FORMAT\ncusparseSpMM\nsupports the following data types for\nCUSPARSE_FORMAT_BLOCKED_ELL\nformat and the following GPU architectures for exploiting NVIDIA Tensor Cores:\nA\n/\nB\nC\ncomputeType\nopB\nCompute\nCapability\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_16F\nN\n,\nT\n≥\n70\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_32F\nN\n,\nT\n≥\n70\nCUDA_R_16F\nCUDA_R_32F\nCUDA_R_32F\nN\n,\nT\n≥\n70\nCUDA_R_8I\nCUDA_R_32I\nCUDA_R_32I\nN\ncolumn-major\n≥\n75\nT\nrow-major\nCUDA_R_16BF\nCUDA_R_16BF\nCUDA_R_32F\nN\n,\nT\n≥\n80\nCUDA_R_16BF\nCUDA_R_32F\nCUDA_R_32F\nN\n,\nT\n≥\n80\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nN\n,\nT\n≥\n80\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nN\n,\nT\n≥\n80\ncusparseSpMM\nsupports the following algorithms with\nCUSPARSE_FORMAT_BLOCKED_ELL\nformat:\nAlgorithm\nNotes\nCUSPARSE_SPMM_ALG_DEFAULT\nDefault algorithm for any sparse matrix format\nCUSPARSE_SPMM_BLOCKED_ELL_ALG1\nDefault algorithm for Blocked-ELL format\nPerformance notes:\nBlocked-ELL SpMM provides the best performance with Power-of-2 Block-Sizes.\nLarge Block-Sizes (e.g. ≥ 64) provide the best performance.\nThe function has the following limitations:\nThe pointer mode must be equal to\nCUSPARSE_POINTER_MODE_HOST\nOnly\nopA\n==\nCUSPARSE_OPERATION_NON_TRANSPOSE\nis supported.\nopB\n==\nCUSPARSE_OPERATION_CONJUGATE_TRANSPOSE\nis not supported.\nOnly\nCUSPARSE_INDEX_32I\nis supported.\nPlease visit\ncuSPARSE Library Samples - cusparseSpMM Blocked-ELL\nfor a code example.\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.6.9.\ncusparseSpMMOp()\n\ncusparseStatus_t\nCUSPARSEAPI\ncusparseSpMMOp_createPlan\n(\ncusparseHandle_t\nhandle\n,\ncusparseSpMMOpPlan_t\n*\nplan\n,\ncusparseOperation_t\nopA\n,\ncusparseOperation_t\nopB\n,\ncusparseConstSpMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseConstDnMatDescr_t\nmatB\n,\n// non-const descriptor supported\ncusparseDnMatDescr_t\nmatC\n,\ncudaDataType\ncomputeType\n,\ncusparseSpMMOpAlg_t\nalg\n,\nconst\nvoid\n*\naddOperationNvvmBuffer\n,\nsize_t\naddOperationBufferSize\n,\nconst\nvoid\n*\nmulOperationNvvmBuffer\n,\nsize_t\nmulOperationBufferSize\n,\nconst\nvoid\n*\nepilogueNvvmBuffer\n,\nsize_t\nepilogueBufferSize\n,\nsize_t\n*\nSpMMWorkspaceSize\n)\ncusparseStatus_t\ncusparseSpMMOp_destroyPlan\n(\ncusparseSpMMOpPlan_t\nplan\n)\ncusparseStatus_t\ncusparseSpMMOp\n(\ncusparseSpMMOpPlan_t\nplan\n,\nvoid\n*\nexternalBuffer\n)\nNOTE 1:\nNVRTC and nvJitLink are not currently available on Arm64 Android platforms.\nNOTE 2:\nThe routine does not support Android and Tegra platforms except Judy (sm87).\nExperimental\n: The function performs the multiplication of a sparse matrix\nmatA\nand a dense matrix\nmatB\nwith custom operators.\n\\[{C^{\\prime}}_{ij} = \\text{epilogue}\\left( {\\sum_{k}^{\\oplus}{op\\left( A_{ik} \\right) \\otimes op\\left( B_{kj} \\right),C_{ij}}} \\right)\\]\nwhere\nop(A)\nis a sparse matrix of size\n\\(m \\times k\\)\nop(B)\nis a dense matrix of size\n\\(k \\times n\\)\nC\nis a dense matrix of size\n\\(m \\times n\\)\n\\(\\oplus\\)\n,\n\\(\\otimes\\)\n, and\n\\(\\text{epilogue}\\)\nare custom\nadd\n,\nmul\n, and\nepilogue\noperators respectively.\nAlso, for matrix\nA\nand\nB\nOnly\nopA\n==\nCUSPARSE_OPERATION_NON_TRANSPOSE\nis currently supported\nThe function\ncusparseSpMMOp_createPlan()\nreturns the size of the workspace and the compiled kernel needed by\ncusparseSpMMOp()\nParam.\nMemory\nIn/out\nMeaning\nhandle\nHOST\nIN\nHandle to the cuSPARSE library context\nopA\nHOST\nIN\nOperation\nop(A)\nopB\nHOST\nIN\nOperation\nop(B)\nmatA\nHOST\nIN\nSparse matrix\nA\nmatB\nHOST\nIN\nDense matrix\nB\nmatC\nHOST\nIN/OUT\nDense matrix\nC\ncomputeType\nHOST\nIN\nDatatype in which the computation is executed\nalg\nHOST\nIN\nAlgorithm for the computation\naddOperationNvvmBuffer\nHOST\nIN\nPointer to the NVVM buffer containing the custom\nadd\noperator\naddOperationBufferSize\nHOST\nIN\nSize in bytes of\naddOperationNvvmBuffer\nmulOperationNvvmBuffer\nHOST\nIN\nPointer to the NVVM buffer containing the custom\nmul\noperator\nmulOperationBufferSize\nHOST\nIN\nSize in bytes of\nmulOperationNvvmBuffer\nepilogueNvvmBuffer\nHOST\nIN\nPointer to the NVVM buffer containing the custom\nepilogue\noperator\nepilogueBufferSize\nHOST\nIN\nSize in bytes of\nepilogueNvvmBuffer\nSpMMWorkspaceSize\nHOST\nOUT\nNumber of bytes of workspace needed by\ncusparseSpMMOp\nThe operators must have the following signature and return type\n__device__\n<\ncomputetype\n>\nadd_op\n(\n<\ncomputetype\n>\nvalue1\n,\n<\ncomputetype\n>\nvalue2\n);\n__device__\n<\ncomputetype\n>\nmul_op\n(\n<\ncomputetype\n>\nvalue1\n,\n<\ncomputetype\n>\nvalue2\n);\n__device__\n<\ncomputetype\n>\nepilogue\n(\n<\ncomputetype\n>\nvalue1\n,\n<\ncomputetype\n>\nvalue2\n);\n<computetype>\nis one of\nfloat\n,\ndouble\n,\ncuComplex\n,\ncuDoubleComplex\n, or\nint\n,\ncusparseSpMMOp\nsupports the following sparse matrix formats:\nCUSPARSE_FORMAT_CSR\ncusparseSpMMOp\nsupports the following index type for representing the sparse matrix\nmatA\n:\n32-bit indices (\nCUSPARSE_INDEX_32I\n)\n64-bit indices (\nCUSPARSE_INDEX_64I\n)\ncusparseSpMMOp\nsupports the following data types:\nUniform-precision computation:\nA\n/\nB\n/\nC\n/\ncomputeType\nCUDA_R_32F\nCUDA_R_64F\nCUDA_C_32F\nCUDA_C_64F\nMixed-precision computation:\nA\n/\nB\nC\ncomputeType\nCUDA_R_8I\nCUDA_R_32I\nCUDA_R_32I\nCUDA_R_8I\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_16F\nCUDA_R_16BF\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_16BF\nCUDA_R_16BF\ncusparseSpMMOp\nsupports the following algorithms:\nAlgorithm\nNotes\nCUSPARSE_SPMM_OP_ALG_DEFAULT\nDefault algorithm for any sparse matrix format\nPerformance notes:\nRow-major layout provides higher performance than column-major.\ncusparseSpMMOp()\nhas the following properties:\nThe routine requires extra storage\nThe routine supports asynchronous execution\nProvides deterministic (bit-wise) results for each run\nThe routine allows the indices of\nmatA\nto be unsorted\ncusparseSpMMOp()\nsupports the following\noptimizations\n:\nCUDA graph capture\nHardware Memory Compression\nPlease visit\ncuSPARSE Library Samples - cusparseSpMMOp\nSee\ncusparseStatus_t\nfor the description of the return status.\n6.6.10.\ncusparseSpSM()\n\ncusparseStatus_t\ncusparseSpSM_createDescr\n(\ncusparseSpSMDescr_t\n*\nspsmDescr\n);\ncusparseStatus_t\ncusparseSpSM_destroyDescr\n(\ncusparseSpSMDescr_t\nspsmDescr\n);\ncusparseStatus_t\ncusparseSpSM_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopA\n,\ncusparseOperation_t\nopB\n,\nconst\nvoid\n*\nalpha\n,\ncusparseConstSpMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseConstDnMatDescr_t\nmatB\n,\n// non-const descriptor supported\ncusparseDnMatDescr_t\nmatC\n,\ncudaDataType\ncomputeType\n,\ncusparseSpSMAlg_t\nalg\n,\ncusparseSpSMDescr_t\nspsmDescr\n,\nsize_t\n*\nbufferSize\n)\ncusparseStatus_t\ncusparseSpSM_analysis\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopA\n,\ncusparseOperation_t\nopB\n,\nconst\nvoid\n*\nalpha\n,\ncusparseConstSpMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseConstDnMatDescr_t\nmatB\n,\n// non-const descriptor supported\ncusparseDnMatDescr_t\nmatC\n,\ncudaDataType\ncomputeType\n,\ncusparseSpSMAlg_t\nalg\n,\ncusparseSpSMDescr_t\nspsmDescr\n,\nvoid\n*\nexternalBuffer\n)\ncusparseStatus_t\ncusparseSpSM_solve\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopA\n,\ncusparseOperation_t\nopB\n,\nconst\nvoid\n*\nalpha\n,\ncusparseConstSpMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseConstDnMatDescr_t\nmatB\n,\n// non-const descriptor supported\ncusparseDnMatDescr_t\nmatC\n,\ncudaDataType\ncomputeType\n,\ncusparseSpSMAlg_t\nalg\n,\ncusparseSpSMDescr_t\nspsmDescr\n)\ncusparseStatus_t\ncusparseSpSM_updateMatrix\n(\ncusparseHandle_t\nhandle\n,\ncusparseSpSMDescr_t\nspsmDescr\n,\nvoid\n*\nnewValues\n,\ncusparseSpSMUpdate_t\nupdatePart\n)\nThe function solves a system of linear equations whose coefficients are represented in a sparse triangular matrix:\n\\[op\\left( \\mathbf{A} \\right) \\cdot \\mathbf{C} = \\mathbf{\\alpha}op\\left( \\mathbf{B} \\right)\\]\nwhere\nop(A)\nis a sparse square matrix of size\n\\(m \\times m\\)\nop(B)\nis a dense matrix of size\n\\(m \\times n\\)\nC\nis a dense matrix of size\n\\(m \\times n\\)\n\\(\\alpha\\)\nis a scalar\nAlso, for matrix\nA\nThe function\ncusparseSpSM_bufferSize()\nreturns the size of the workspace needed by\ncusparseSpSM_analysis()\nand\ncusparseSpSM_solve()\n.\nThe function\ncusparseSpSM_analysis()\nperforms the analysis phase, while\ncusparseSpSM_solve()\nexecutes the solve phase for a sparse triangular linear system.\nThe opaque data structure\nspsmDescr\nis used to share information among all functions.\nThe function\ncusparseSpSM_updateMatrix()\nupdates\nspsmDescr\nwith new matrix values.\nThe routine supports arbitrary sparsity for the input matrix, but only the upper or lower triangular part is taken into account in the computation.\ncusparseSpSM_bufferSize()\nrequires a buffer size for the analysis phase which is proportional to number of non-zero entries of the sparse matrix\nThe\nexternalBuffer\nis stored into\nspsmDescr\nand used by\ncusparseSpSM_solve()\n. For this reason, the device memory buffer must be deallocated only after\ncusparseSpSM_solve()\nNOTE:\nall parameters must be consistent across\ncusparseSpSM\nAPI calls and the matrix descriptions and\nexternalBuffer\nmust not be modified between\ncusparseSpSM_analysis()\nand\ncusparseSpSM_solve()\nParam.\nMemory\nIn/out\nMeaning\nhandle\nHOST\nIN\nHandle to the cuSPARSE library context\nopA\nHOST\nIN\nOperation\nop(A)\nopB\nHOST\nIN\nOperation\nop(B)\nalpha\nHOST or DEVICE\nIN\n\\(\\alpha\\)\nscalar used for multiplication of type\ncomputeType\nmatA\nHOST\nIN\nSparse matrix\nA\nmatB\nHOST\nIN\nDense matrix\nB\nmatC\nHOST\nIN/OUT\nDense matrix\nC\ncomputeType\nHOST\nIN\nDatatype in which the computation is executed\nalg\nHOST\nIN\nAlgorithm for the computation\nbufferSize\nHOST\nOUT\nNumber of bytes of workspace needed by\ncusparseSpSM_analysis()\nand\ncusparseSpSM_solve()\nexternalBuffer\nDEVICE\nIN/OUT\nPointer to a workspace buffer of at least\nbufferSize\nbytes. It is used by\ncusparseSpSM_analysis\nand\ncusparseSpSM_solve()\nspsmDescr\nHOST\nIN/OUT\nOpaque descriptor for storing internal data used across the three steps\nThe sparse matrix formats currently supported are listed below:\nCUSPARSE_FORMAT_CSR\nCUSPARSE_FORMAT_COO\nThe\ncusparseSpSM()\nsupports the following shapes and properties:\nCUSPARSE_FILL_MODE_LOWER\nand\nCUSPARSE_FILL_MODE_UPPER\nfill modes\nCUSPARSE_DIAG_TYPE_NON_UNIT\nand\nCUSPARSE_DIAG_TYPE_UNIT\ndiagonal types\nThe fill mode and diagonal type can be set by\ncusparseSpMatSetAttribute()\n.\ncusparseSpSM()\nsupports the following index type for representing the sparse matrix\nmatA\n:\n32-bit indices (\nCUSPARSE_INDEX_32I\n)\n64-bit indices (\nCUSPARSE_INDEX_64I\n)\ncusparseSpSM()\nsupports the following data types:\nUniform-precision computation:\nA\n/\nB\n/\nC\n/\ncomputeType\nCUDA_R_32F\nCUDA_R_64F\nCUDA_C_32F\nCUDA_C_64F\ncusparseSpSM()\nsupports the following algorithms:\nAlgorithm\nNotes\nCUSPARSE_SPSM_ALG_DEFAULT\nDefault algorithm\ncusparseSpSM()\nhas the following properties:\nThe routine requires no extra storage\nProvides deterministic (bit-wise) results for each run for the solving phase\ncusparseSpSM_solve()\nThe\ncusparseSpSM_solve()\nroutine supports asynchronous execution\nThe routine supports in-place operation. The same device pointer must be provided to the\nvalues\nparameter of the dense matrices\nmatB\nand\nmatC\n. All other dense matrix descriptor parameters (e.g.,\norder\n) can be set independently\ncusparseSpSM_bufferSize()\nand\ncusparseSpSM_analysis()\nroutines accept descriptors of\nNULL\nvalues for\nmatB\nand\nmatC\n. These two routines do not accept\nNULL\ndescriptors\nThe routine allows the indices of\nmatA\nto be unsorted\ncusparseSpSM()\nsupports the following\noptimizations\n:\nCUDA graph capture\nHardware Memory Compression\ncusparseSpSM_updateMatrix()\nupdates the sparse matrix after calling the analysis phase. This functions supports the following update strategies (\nupdatePart\n):\nStrategy\nNotes\nCUSPARSE_SPSM_UPDATE_GENERAL\nUpdates the sparse matrix values with values of\nnewValues\narray\nCUSPARSE_SPSM_UPDATE_DIAGONAL\nUpdates the diagonal part of the matrix with diagonal values stored in\nnewValues\narray. That is,\nnewValues\nhas the new diagonal values only\nSee\ncusparseStatus_t\nfor the description of the return status.\nPlease visit\ncuSPARSE Library Samples - cusparseSpSM CSR\nand\ncuSPARSE Library Samples - cusparseSpSM COO\nfor code examples.\n6.6.11.\ncusparseSDDMM()\n\ncusparseStatus_t\ncusparseSDDMM_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopA\n,\ncusparseOperation_t\nopB\n,\nconst\nvoid\n*\nalpha\n,\ncusparseConstDnMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseConstDnMatDescr_t\nmatB\n,\n// non-const descriptor supported\nconst\nvoid\n*\nbeta\n,\ncusparseSpMatDescr_t\nmatC\n,\ncudaDataType\ncomputeType\n,\ncusparseSDDMMAlg_t\nalg\n,\nsize_t\n*\nbufferSize\n)\ncusparseStatus_t\ncusparseSDDMM_preprocess\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopA\n,\ncusparseOperation_t\nopB\n,\nconst\nvoid\n*\nalpha\n,\ncusparseConstDnMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseConstDnMatDescr_t\nmatB\n,\n// non-const descriptor supported\nconst\nvoid\n*\nbeta\n,\ncusparseSpMatDescr_t\nmatC\n,\ncudaDataType\ncomputeType\n,\ncusparseSDDMMAlg_t\nalg\n,\nvoid\n*\nexternalBuffer\n)\ncusparseStatus_t\ncusparseSDDMM\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopA\n,\ncusparseOperation_t\nopB\n,\nconst\nvoid\n*\nalpha\n,\ncusparseConstDnMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseConstDnMatDescr_t\nmatB\n,\n// non-const descriptor supported\nconst\nvoid\n*\nbeta\n,\ncusparseSpMatDescr_t\nmatC\n,\ncudaDataType\ncomputeType\n,\ncusparseSDDMMAlg_t\nalg\n,\nvoid\n*\nexternalBuffer\n)\nThis function performs the multiplication of\nmatA\nand\nmatB\n, followed by an element-wise multiplication with the sparsity pattern of\nmatC\n. Formally, it performs the following operation:\n\\[\\mathbf{C} = \\alpha({op}(\\mathbf{A}) \\cdot {op}(\\mathbf{B})) \\circ {spy}(\\mathbf{C}) + \\beta\\mathbf{C}\\]\nwhere\nop(A)\nis a dense matrix of size\n\\(m \\times k\\)\nop(B)\nis a dense matrix of size\n\\(k \\times n\\)\nC\nis a sparse matrix of size\n\\(m \\times n\\)\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars\n\\(\\circ\\)\ndenotes the Hadamard (entry-wise) matrix product, and\n\\({spy}\\left( \\mathbf{C} \\right)\\)\nis the structural sparsity pattern matrix of\nC\ndefined as:\nAlso, for matrix\nA\nand\nB\nThe function\ncusparseSDDMM_bufferSize()\nreturns the size of the workspace needed by\ncusparseSDDMM\nor\ncusparseSDDMM_preprocess\n.\nCalling\ncusparseSDDMM_preprocess()\nis optional.\nIt may accelerate subsequent calls to\ncusparseSDDMM()\n.\nIt is useful when\ncusparseSDDMM()\nis called multiple times with the same sparsity pattern (\nmatC\n).\nCalling\ncusparseSDDMM_preprocess()\nwith\nbuffer\nmakes that buffer “active” for\nmatC\nSDDMM calls.\nSubsequent calls to\ncusparseSDDMM()\nwith\nmatC\nand the active buffer\nmust use the same values for all parameters as the call to\ncusparseSDDMM_preprocess()\n.\nThe exceptions are:\nalpha\n,\nbeta\n,\nmatA\n,\nmatB\n, and the values (but not indices) of\nmatC\nmay be different.\nImportantly, the buffer contents must be unmodified since the call to\ncusparseSDDMM_preprocess()\n.\nWhen\ncusparseSDDMM()\nis called with\nmatC\nand its active buffer, it may read acceleration data from the buffer.\nCalling\ncusparseSDDMM_preprocess()\nagain with\nmatC\nand a new buffer will make the new buffer active,\nforgetting about the previously-active buffer and making it inactive.\nFor\ncusparseSDDMM()\n, there can only be one active buffer per sparse matrix at a time.\nTo get the effect of multiple active buffers for a single sparse matrix,\ncreate multiple matrix handles that all point to the same index and value buffers,\nand call\ncusparseSDDMM_preprocess()\nonce per handle with different workspace buffers.\nCalling\ncusparseSDDMM()\nwith an inactive buffer is always permitted.\nHowever, there may be no acceleration from the preprocessing in that case.\nFor the purposes of\nthread safety\n,\ncusparseSDDMM_preprocess()\nis writing to\nmatC\ninternal state.\nParam.\nMemory\nIn/out\nMeaning\nhandle\nHOST\nIN\nHandle to the cuSPARSE library context\nopA\nHOST\nIN\nOperation\nop(A)\nopB\nHOST\nIN\nOperation\nop(B)\nalpha\nHOST or DEVICE\nIN\n\\(\\alpha\\)\nscalar used for multiplication of type\ncomputeType\nmatA\nHOST\nIN\nDense matrix\nmatA\nmatB\nHOST\nIN\nDense matrix\nmatB\nbeta\nHOST or DEVICE\nIN\n\\(\\beta\\)\nscalar used for multiplication of type\ncomputeType\nmatC\nHOST\nIN/OUT\nSparse matrix\nmatC\ncomputeType\nHOST\nIN\nDatatype in which the computation is executed\nalg\nHOST\nIN\nAlgorithm for the computation\nbufferSize\nHOST\nOUT\nNumber of bytes of workspace needed by\ncusparseSDDMM\nexternalBuffer\nDEVICE\nIN\nPointer to a workspace buffer of at least\nbufferSize\nbytes\nCurrently supported sparse matrix formats:\nCUSPARSE_FORMAT_CSR\nCUSPARSE_FORMAT_BSR\ncusparseSDDMM()\nsupports the following index type for representing the sparse matrix\nmatA\n:\n32-bit indices (\nCUSPARSE_INDEX_32I\n)\n64-bit indices (\nCUSPARSE_INDEX_64I\n)\nThe data types combinations currently supported for\ncusparseSDDMM\nare listed below:\nUniform-precision computation:\nA\n/\nX\n/\nY\n/\ncomputeType\nCUDA_R_32F\nCUDA_R_64F\nCUDA_C_32F\nCUDA_C_64F\nMixed-precision computation:\nA\n/\nB\nC\ncomputeType\nCUDA_R_16F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_16F\nCUDA_R_16F\ncusparseSDDMM\nfor\nCUSPARSE_FORMAT_BSR\nalso supports the following mixed-precision computation:\nA\n/\nB\nC\ncomputeType\nCUDA_R_16BF\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_16BF\nCUDA_R_16BF\nNOTE:\nCUDA_R_16F\n,\nCUDA_R_16BF\ndata types always imply mixed-precision computation.\ncusparseSDDMM()\nfor\nCUSPASRE_FORMAT_BSR\nsupports block sizes of 2, 4, 8, 16, 32, 64 and 128.\ncusparseSDDMM()\nsupports the following algorithms:\nAlgorithm\nNotes\nCUSPARSE_SDDMM_ALG_DEFAULT\nDefault algorithm. It supports batched computation.\nPerformance notes:\ncusparseSDDMM()\nfor\nCUSPARSE_FORMAT_CSR\nprovides the best performance when\nmatA\nand\nmatB\nsatisfy:\nmatA\n:\nmatA\nis in row-major order and\nopA\nis\nCUSPARSE_OPERATION_NON_TRANSPOSE\n, or\nmatA\nis in col-major order and\nopA\nis not\nCUSPARSE_OPERATION_NON_TRANSPOSE\nmatB\n:\nmatB\nis in col-major order and\nopB\nis\nCUSPARSE_OPERATION_NON_TRANSPOSE\n, or\nmatB\nis in row-major order and\nopB\nis not\nCUSPARSE_OPERATION_NON_TRANSPOSE\ncusparseSDDMM()\nfor\nCUSPARSE_FORMAT_BSR\nprovides the best performance when\nmatA\nand\nmatB\nsatisfy:\nmatA\n:\nmatA\nis in row-major order and\nopA\nis\nCUSPARSE_OPERATION_NON_TRANSPOSE\n, or\nmatA\nis in col-major order and\nopA\nis not\nCUSPARSE_OPERATION_NON_TRANSPOSE\nmatB\n:\nmatB\nis in row-major order and\nopB\nis\nCUSPARSE_OPERATION_NON_TRANSPOSE\n, or\nmatB\nis in col-major order and\nopB\nis not\nCUSPARSE_OPERATION_NON_TRANSPOSE\ncusparseSDDMM()\nsupports the following batch modes:\n\\(C_{i} = (A \\cdot B) \\circ C_{i}\\)\n\\(C_{i} = \\left( A_{i} \\cdot B \\right) \\circ C_{i}\\)\n\\(C_{i} = \\left( A \\cdot B_{i} \\right) \\circ C_{i}\\)\n\\(C_{i} = \\left( A_{i} \\cdot B_{i} \\right) \\circ C_{i}\\)\nThe number of batches and their strides can be set by using\ncusparseCsrSetStridedBatch\nand\ncusparseDnMatSetStridedBatch\n. The maximum number of batches for\ncusparseSDDMM()\nis 65,535.\ncusparseSDDMM()\nhas the following properties:\nThe routine requires no extra storage\nProvides deterministic (bit-wise) results for each run\nThe routine supports asynchronous execution\nThe routine allows the indices of\nmatC\nto be unsorted\ncusparseSDDMM()\nsupports the following\noptimizations\n:\nCUDA graph capture\nHardware Memory Compression\nSee\ncusparseStatus_t\nfor the description of the return status.\nPlease visit\ncuSPARSE Library Samples - cusparseSDDMM\nfor a code example. For batched computation please visit\ncusparseSDDMM CSR Batched\n.\n6.6.12.\ncusparseSpGEMM()\n\ncusparseStatus_t\ncusparseSpGEMM_createDescr\n(\ncusparseSpGEMMDescr_t\n*\ndescr\n)\ncusparseStatus_t\ncusparseSpGEMM_destroyDescr\n(\ncusparseSpGEMMDescr_t\ndescr\n)\ncusparseStatus_t\ncusparseSpGEMM_workEstimation\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopA\n,\ncusparseOperation_t\nopB\n,\nconst\nvoid\n*\nalpha\n,\ncusparseConstSpMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseConstSpMatDescr_t\nmatB\n,\n// non-const descriptor supported\nconst\nvoid\n*\nbeta\n,\ncusparseSpMatDescr_t\nmatC\n,\ncudaDataType\ncomputeType\n,\ncusparseSpGEMMAlg_t\nalg\n,\ncusparseSpGEMMDescr_t\nspgemmDescr\n,\nsize_t\n*\nbufferSize1\n,\nvoid\n*\nexternalBuffer1\n)\ncusparseStatus_t\ncusparseSpGEMM_getNumProducts\n(\ncusparseSpGEMMDescr_t\nspgemmDescr\n,\nint64_t\n*\nnum_prods\n)\ncusparseStatus_t\ncusparseSpGEMM_estimateMemory\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopA\n,\ncusparseOperation_t\nopB\n,\nconst\nvoid\n*\nalpha\n,\ncusparseConstSpMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseConstSpMatDescr_t\nmatB\n,\n// non-const descriptor supported\nconst\nvoid\n*\nbeta\n,\ncusparseSpMatDescr_t\nmatC\n,\ncudaDataType\ncomputeType\n,\ncusparseSpGEMMAlg_t\nalg\n,\ncusparseSpGEMMDescr_t\nspgemmDescr\n,\nfloat\nchunk_fraction\n,\nsize_t\n*\nbufferSize3\n,\nvoid\n*\nexternalBuffer3\n,\nsize_t\n*\nbufferSize2\n)\ncusparseStatus_t\ncusparseSpGEMM_compute\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopA\n,\ncusparseOperation_t\nopB\n,\nconst\nvoid\n*\nalpha\n,\ncusparseConstSpMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseConstSpMatDescr_t\nmatB\n,\n// non-const descriptor supported\nconst\nvoid\n*\nbeta\n,\ncusparseSpMatDescr_t\nmatC\n,\ncudaDataType\ncomputeType\n,\ncusparseSpGEMMAlg_t\nalg\n,\ncusparseSpGEMMDescr_t\nspgemmDescr\n,\nsize_t\n*\nbufferSize2\n,\nvoid\n*\nexternalBuffer2\n)\ncusparseStatus_t\ncusparseSpGEMM_copy\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopA\n,\ncusparseOperation_t\nopB\n,\nconst\nvoid\n*\nalpha\n,\ncusparseConstSpMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseConstSpMatDescr_t\nmatB\n,\n// non-const descriptor supported\nconst\nvoid\n*\nbeta\n,\ncusparseSpMatDescr_t\nmatC\n,\ncudaDataType\ncomputeType\n,\ncusparseSpGEMMAlg_t\nalg\n,\ncusparseSpGEMMDescr_t\nspgemmDescr\n)\nThis function performs the multiplication of two sparse matrices\nmatA\nand\nmatB\n.\n\\[\\mathbf{C^{\\prime}} = \\alpha op\\left( \\mathbf{A} \\right) \\cdot op\\left( \\mathbf{B} \\right) + \\beta\\mathbf{C}\\]\nwhere\n\\(\\alpha,\\)\n\\(\\beta\\)\nare scalars, and\n\\(\\mathbf{C},\\)\n\\(\\mathbf{C^{\\prime}}\\)\nhave the same sparsity pattern.\nThe functions\ncusparseSpGEMM_workEstimation()\n,\ncusparseSpGEMM_estimateMemory()\n, and\ncusparseSpGEMM_compute()\nare used for both determining the buffer size and performing the actual computation.\nParam.\nMemory\nIn/out\nMeaning\nhandle\nHOST\nIN\nHandle to the cuSPARSE library context\nopA\nHOST\nIN\nOperation\nop(A)\nopB\nHOST\nIN\nOperation\nop(B)\nalpha\nHOST or DEVICE\nIN\n\\(\\alpha\\)\nscalar used for multiplication\nmatA\nHOST\nIN\nSparse matrix\nA\nmatB\nHOST\nIN\nSparse matrix\nB\nbeta\nHOST or DEVICE\nIN\n\\(\\beta\\)\nscalar used for multiplication\nmatC\nHOST\nIN/OUT\nSparse matrix\nC\ncomputeType\nHOST\nIN\nEnumerator specifying the datatype in which the computation is executed\nalg\nHOST\nIN\nEnumerator specifying the algorithm for the computation\nspgemmDescr\nHOST\nIN/OUT\nOpaque descriptor for storing internal data used across the three steps\nnum_prods\nHOST\nOUT\nPointer to a 64-bit integer that stores the number of intermediate products calculated by\ncusparseSpGEMM_workEstimation\nchunk_fraction\nHOST\nIN\nThe fraction of total intermediate products being computed in a chunk. Used by\nCUSPARSE_SPGEMM_ALG3\nonly. Value is in range (0,1].\nbufferSize1\nHOST\nIN/OUT\nNumber of bytes of workspace requested by\ncusparseSpGEMM_workEstimation\nbufferSize2\nHOST\nIN/OUT\nNumber of bytes of workspace requested by\ncusparseSpGEMM_compute\nbufferSize3\nHOST\nIN/OUT\nNumber of bytes of workspace requested by\ncusparseSpGEMM_estimateMemory\nexternalBuffer1\nDEVICE\nIN\nPointer to workspace buffer needed by\ncusparseSpGEMM_workEstimation\nand\ncusparseSpGEMM_compute\nexternalBuffer2\nDEVICE\nIN\nPointer to workspace buffer needed by\ncusparseSpGEMM_compute\nand\ncusparseSpGEMM_copy\nexternalBuffer3\nDEVICE\nIN\nPointer to workspace buffer needed by\ncusparseSpGEMM_estimateMemory\ncusparseSpGEMM\nsupports the following index type for representing the sparse matrix\nA\n,\nB\nand\nC\n(all matrices must have the same index type):\n32-bit indices (\nCUSPARSE_INDEX_32I\n)\n64-bit indices (\nCUSPARSE_INDEX_64I\n)\nCurrently, the function has the following limitations:\nOnly CSR format\nCUSPARSE_FORMAT_CSR\nis supported\nOnly\nopA\n,\nopB\nequal to\nCUSPARSE_OPERATION_NON_TRANSPOSE\nare supported\nThe data types combinations currently supported for\ncusparseSpGEMM\nare listed below :\nUniform-precision computation:\nA\n/\nB\n/\nC\n/\ncomputeType\nCUDA_R_16F\n[DEPRECATED]\nCUDA_R_16BF\n[DEPRECATED]\nCUDA_R_32F\nCUDA_R_64F\nCUDA_C_16F\n[DEPRECATED]\nCUDA_C_16BF\n[DEPRECATED]\nCUDA_C_32F\nCUDA_C_64F\ncusparseSpGEMM\nroutine runs for the following algorithms:\nAlgorithm\nNotes\nCUSPARSE_SPGEMM_DEFAULT\nDefault algorithm. Currently, it is\nCUSPARSE_SPGEMM_ALG1\n.\nCUSPARSE_SPGEMM_ALG1\nAlgorithm 1\nInvokes\ncusparseSpGEMM_compute\ntwice. The first invocation provides an upper bound of the memory required for the computation.\nThe required memory is generally several times larger of the actual memory used.\nThe user can provide an arbitrary buffer size bufferSize2 in the second invocation. If it is not sufficient, the routine will returns\nCUSPARSE_STATUS_INSUFFICIENT_RESOURCES\nstatus.\nProvides better performance than other algorithms.\nProvides deterministic (bit-wise) results for each run.\nCUSPARSE_SPGEMM_ALG2\nAlgorithm 2\nInvokes\ncusparseSpGEMM_estimateMemory\nto get the amount of the memory required for the computation.\nRequires less memory for the computation than Algorithm 1.\nPerformance is lower than Algorithm 1, higher than Algorithm 3.\nProvides deterministic (bit-wise) results for each run.\nCUSPARSE_SPGEMM_ALG3\nAlgorithm 3\nComputes the intermediate products in chunks, one chunk at a time.\nInvokes\ncusparseSpGEMM_estimateMemory\nto get the amount of the memory required for the computation.\nThe user can control the amount of required memory by changing the chunk size via\nchunk_fraction\n.\nThe chunk size is a fraction of total intermediate products:\nchunk_fraction\n*\n(*num_prods)\n.\nProvides deterministic (bit-wise) results for each run.\ncusparseSpGEMM()\nhas the following properties:\nThe routine requires no extra storage\nThe routine supports asynchronous execution\nThe routine allows the indices of\nmatA\nand\nmatB\nto be unsorted\nThe routine guarantees the indices of\nmatC\nto be sorted\ncusparseSpGEMM()\nsupports the following\noptimizations\n:\nCUDA graph capture\nHardware Memory Compression\nSee\ncusparseStatus_t\nfor the description of the return status.\nPlease visit\ncuSPARSE Library Samples - cusparseSpGEMM\nfor a code example for\nCUSPARSE_SPGEMM_DEFAULT\nand\nCUSPARSE_SPGEMM_ALG1\n, and\ncuSPARSE Library Samples - memory-optimzed cusparseSpGEMM\nfor a code example for\nCUSPARSE_SPGEMM_ALG2\nand\nCUSPARSE_SPGEMM_ALG3\n.\n6.6.13.\ncusparseSpGEMMreuse()\n\ncusparseStatus_t\ncusparseSpGEMM_createDescr\n(\ncusparseSpGEMMDescr_t\n*\ndescr\n)\ncusparseStatus_t\ncusparseSpGEMM_destroyDescr\n(\ncusparseSpGEMMDescr_t\ndescr\n)\ncusparseStatus_t\ncusparseSpGEMMreuse_workEstimation\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopA\n,\ncusparseOperation_t\nopB\n,\ncusparseSpMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseSpMatDescr_t\nmatB\n,\n// non-const descriptor supported\ncusparseSpMatDescr_t\nmatC\n,\ncusparseSpGEMMAlg_t\nalg\n,\ncusparseSpGEMMDescr_t\nspgemmDescr\n,\nsize_t\n*\nbufferSize1\n,\nvoid\n*\nexternalBuffer1\n)\ncusparseStatus_t\ncusparseSpGEMMreuse_nnz\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopA\n,\ncusparseOperation_t\nopB\n,\ncusparseSpMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseSpMatDescr_t\nmatB\n,\n// non-const descriptor supported\ncusparseSpMatDescr_t\nmatC\n,\ncusparseSpGEMMAlg_t\nalg\n,\ncusparseSpGEMMDescr_t\nspgemmDescr\n,\nsize_t\n*\nbufferSize2\n,\nvoid\n*\nexternalBuffer2\n,\nsize_t\n*\nbufferSize3\n,\nvoid\n*\nexternalBuffer3\n,\nsize_t\n*\nbufferSize4\n,\nvoid\n*\nexternalBuffer4\n)\ncusparseStatus_t\nCUSPARSEAPI\ncusparseSpGEMMreuse_copy\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopA\n,\ncusparseOperation_t\nopB\n,\ncusparseSpMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseSpMatDescr_t\nmatB\n,\n// non-const descriptor supported\ncusparseSpMatDescr_t\nmatC\n,\ncusparseSpGEMMAlg_t\nalg\n,\ncusparseSpGEMMDescr_t\nspgemmDescr\n,\nsize_t\n*\nbufferSize5\n,\nvoid\n*\nexternalBuffer5\n)\ncusparseStatus_t\nCUSPARSEAPI\ncusparseSpGEMMreuse_compute\n(\ncusparseHandle_t\nhandle\n,\ncusparseOperation_t\nopA\n,\ncusparseOperation_t\nopB\n,\nconst\nvoid\n*\nalpha\n,\ncusparseSpMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseSpMatDescr_t\nmatB\n,\n// non-const descriptor supported\nconst\nvoid\n*\nbeta\n,\ncusparseSpMatDescr_t\nmatC\n,\ncudaDataType\ncomputeType\n,\ncusparseSpGEMMAlg_t\nalg\n,\ncusparseSpGEMMDescr_t\nspgemmDescr\n)\nThis function performs the multiplication of two sparse matrices\nmatA\nand\nmatB\nwhere the structure of the output matrix\nmatC\ncan be reused for multiple computations with different values.\n\\[\\mathbf{C^{\\prime}} = \\alpha op\\left( \\mathbf{A} \\right) \\cdot op\\left( \\mathbf{B} \\right) + \\beta\\mathbf{C}\\]\nwhere\n\\(\\alpha\\)\nand\n\\(\\beta\\)\nare scalars.\nThe functions\ncusparseSpGEMMreuse_workEstimation()\n,\ncusparseSpGEMMreuse_nnz()\n, and\ncusparseSpGEMMreuse_copy()\nare used for determining the buffer size and performing the actual computation.\nNote:\ncusparseSpGEMMreuse()\noutput CSR matrix (\nmatC\n) is sorted by column indices.\nMEMORY REQUIREMENT:\ncusparseSpGEMMreuse\nrequires to keep in memory all intermediate products to reuse the structure of the output matrix. On the other hand, the number of intermediate products is orders of magnitude higher than the number of non-zero entries in general. In order to minimize the memory requirements, the routine uses multiple buffers that can be deallocated after they are no more needed. If the number of intermediate product exceeds\n2^31-1\n, the routine will returns\nCUSPARSE_STATUS_INSUFFICIENT_RESOURCES\nstatus.\nCurrently, the function has the following limitations:\nOnly 32-bit indices\nCUSPARSE_INDEX_32I\nis supported\nOnly CSR format\nCUSPARSE_FORMAT_CSR\nis supported\nOnly\nopA\n,\nopB\nequal to\nCUSPARSE_OPERATION_NON_TRANSPOSE\nare supported\nThe data types combinations currently supported for\ncusparseSpGEMMreuse\nare listed below.\nUniform-precision computation:\nA\n/\nB\n/\nC\n/\ncomputeType\nCUDA_R_32F\nCUDA_R_64F\nCUDA_C_16F\n[DEPRECATED]\nCUDA_C_16BF\n[DEPRECATED]\nCUDA_C_32F\nCUDA_C_64F\nMixed-precision computation: [DEPRECATED]\nA\n/\nB\nC\ncomputeType\nCUDA_R_16F\nCUDA_R_16F\nCUDA_R_32F\nCUDA_R_16BF\nCUDA_R_16BF\nCUDA_R_32F\ncusparseSpGEMMreuse\nroutine runs for the following algorithm:\nAlgorithm\nNotes\nCUSPARSE_SPGEMM_DEFAULT\nCUSPARSE_SPGEMM_CSR_ALG_NONDETERMINITIC\nDefault algorithm. Provides deterministic (bit-wise) structure for the output matrix for each run, while value computation is not deterministic.\nCUSPARSE_SPGEMM_CSR_ALG_DETERMINITIC\nProvides deterministic (bit-wise) structure for the output matrix and value computation for each run.\ncusparseSpGEMMreuse()\nhas the following properties:\nThe routine requires no extra storage\nThe routine supports asynchronous execution\nThe routine allows the indices of\nmatA\nand\nmatB\nto be unsorted\nThe routine guarantees the indices of\nmatC\nto be sorted\ncusparseSpGEMMreuse()\nsupports the following\noptimizations\n:\nCUDA graph capture\nHardware Memory Compression\nRefer to\ncusparseStatus_t\nfor the description of the return status.\nPlease visit\ncuSPARSE Library Samples - cusparseSpGEMMreuse\nfor a code example.\n6.6.14.\ncusparseSparseToDense()\n\ncusparseStatus_t\ncusparseSparseToDense_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseConstSpMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseDnMatDescr_t\nmatB\n,\ncusparseSparseToDenseAlg_t\nalg\n,\nsize_t\n*\nbufferSize\n)\ncusparseStatus_t\ncusparseSparseToDense\n(\ncusparseHandle_t\nhandle\n,\ncusparseConstSpMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseDnMatDescr_t\nmatB\n,\ncusparseSparseToDenseAlg_t\nalg\n,\nvoid\n*\nbuffer\n)\nThe function converts the sparse matrix\nmatA\nin CSR, CSC, or COO format into its dense representation\nmatB\n. Blocked-ELL is not currently supported.\nThe function\ncusparseSparseToDense_bufferSize()\nreturns the size of the workspace needed by\ncusparseSparseToDense()\n.\nParam.\nMemory\nIn/out\nMeaning\nhandle\nHOST\nIN\nHandle to the cuSPARSE library context\nmatA\nHOST\nIN\nSparse matrix\nA\nmatB\nHOST\nOUT\nDense matrix\nB\nalg\nHOST\nIN\nAlgorithm for the computation\nbufferSize\nHOST\nOUT\nNumber of bytes of workspace needed by\ncusparseSparseToDense()\nbuffer\nDEVICE\nIN\nPointer to workspace buffer\ncusparseSparseToDense()\nsupports the following index type for representing the sparse matrix\nmatA\n:\n32-bit indices (\nCUSPARSE_INDEX_32I\n)\n64-bit indices (\nCUSPARSE_INDEX_64I\n)\ncusparseSparseToDense()\nsupports the following data types:\nA\n/\nB\nCUDA_R_8I\nCUDA_R_16F\nCUDA_R_16BF\nCUDA_R_32F\nCUDA_R_64F\nCUDA_C_16F\n[DEPRECATED]\nCUDA_C_16BF\n[DEPRECATED]\nCUDA_C_32F\nCUDA_C_64F\ncusparseSparse2Dense()\nsupports the following algorithm:\nAlgorithm\nNotes\nCUSPARSE_SPARSETODENSE_ALG_DEFAULT\nDefault algorithm\ncusparseSparseToDense()\nhas the following properties:\nThe routine requires no extra storage\nThe routine supports asynchronous execution\nProvides deterministic (bit-wise) results for each run\nThe routine allows the indices of\nmatA\nto be unsorted\ncusparseSparseToDense()\nsupports the following\noptimizations\n:\nCUDA graph capture\nHardware Memory Compression\nSee\ncusparseStatus_t\nfor the description of the return status.\nPlease visit\ncuSPARSE Library Samples - cusparseSparseToDense\nfor a code example.\n6.6.15.\ncusparseDenseToSparse()\n\ncusparseStatus_t\ncusparseDenseToSparse_bufferSize\n(\ncusparseHandle_t\nhandle\n,\ncusparseConstDnMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseSpMatDescr_t\nmatB\n,\ncusparseDenseToSparseAlg_t\nalg\n,\nsize_t\n*\nbufferSize\n)\ncusparseStatus_t\ncusparseDenseToSparse_analysis\n(\ncusparseHandle_t\nhandle\n,\ncusparseConstDnMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseSpMatDescr_t\nmatB\n,\ncusparseDenseToSparseAlg_t\nalg\n,\nvoid\n*\nbuffer\n)\ncusparseStatus_t\ncusparseDenseToSparse_convert\n(\ncusparseHandle_t\nhandle\n,\ncusparseConstDnMatDescr_t\nmatA\n,\n// non-const descriptor supported\ncusparseSpMatDescr_t\nmatB\n,\ncusparseDenseToSparseAlg_t\nalg\n,\nvoid\n*\nbuffer\n)\nThe function converts the dense matrix\nmatA\ninto a sparse matrix\nmatB\nin CSR, CSC, COO, or Blocked-ELL format.\nThe function\ncusparseDenseToSparse_bufferSize()\nreturns the size of the workspace needed by\ncusparseDenseToSparse_analysis()\n.\nThe function\ncusparseDenseToSparse_analysis()\nupdates the number of non-zero elements in the sparse matrix descriptor\nmatB\n. The user is responsible to allocate the memory required by the sparse matrix:\nRow/Column indices and value arrays for CSC and CSR respectively\nRow, column, value arrays for COO\nColumn (\nellColInd\n), value (\nellValue\n) arrays for Blocked-ELL\nFinally, we call\ncusparseDenseToSparse_convert()\nfor filling the arrays allocated in the previous step.\nParam.\nMemory\nIn/out\nMeaning\nhandle\nHOST\nIN\nHandle to the cuSPARSE library context\nmatA\nHOST\nIN\nDense matrix\nA\nmatB\nHOST\nOUT\nSparse matrix\nB\nalg\nHOST\nIN\nAlgorithm for the computation\nbufferSize\nHOST\nOUT\nNumber of bytes of workspace needed by\ncusparseDenseToSparse_analysis()\nbuffer\nDEVICE\nIN\nPointer to workspace buffer\ncusparseDenseToSparse()\nsupports the following index type for representing the sparse vector\nmatB\n:\n32-bit indices (\nCUSPARSE_INDEX_32I\n)\n64-bit indices (\nCUSPARSE_INDEX_64I\n)\ncusparseDenseToSparse()\nsupports the following data types:\nA\n/\nB\nCUDA_R_*8I\nCUDA_R_16F\nCUDA_R_16BF\nCUDA_R_32F\nCUDA_R_64F\nCUDA_C_16F\n[DEPRECATED]\nCUDA_C_16BF\n[DEPRECATED]\nCUDA_C_32F\nCUDA_C_64F\ncusparseDense2Sparse()\nsupports the following algorithm:\nAlgorithm\nNotes\nCUSPARSE_DENSETOSPARSE_ALG_DEFAULT\nDefault algorithm\ncusparseDenseToSparse()\nhas the following properties:\nThe routine requires no extra storage\nThe routine supports asynchronous execution\nProvides deterministic (bit-wise) results for each run\nThe routine does not guarantee the indices of\nmatB\nto be sorted\ncusparseDenseToSparse()\nsupports the following\noptimizations\n:\nCUDA graph capture\nHardware Memory Compression\nSee\ncusparseStatus_t\nfor the description of the return status.\nPlease visit\ncuSPARSE Library Samples - cusparseDenseToSparse (CSR)\nand\ncuSPARSE Library Samples - cusparseDenseToSparse (Blocked-ELL)\nfor code examples.\n7.\ncuSPARSE Fortran Bindings\n\nThe cuSPARSE library is implemented using the C-based CUDA toolchain, and it thus provides a C-style API that makes interfacing to applications written in C or C++ trivial. There are also many applications implemented in Fortran that would benefit from using cuSPARSE, and therefore a cuSPARSE Fortran interface has been developed.\nUnfortunately, Fortran-to-C calling conventions are not standardized and differ by platform and toolchain. In particular, differences may exist in the following areas:\nSymbol names (capitalization, name decoration)\nArgument passing (by value or reference)\nPassing of pointer arguments (size of the pointer)\nTo provide maximum flexibility in addressing those differences, the cuSPARSE Fortran interface is provided in the form of wrapper functions, which are written in C and are located in the file\ncusparse_fortran.c\n. This file also contains a few additional wrapper functions (for\ncudaMalloc()\n,\ncudaMemset\n, and so on) that can be used to allocate memory on the GPU.\nThe cuSPARSE Fortran wrapper code is provided as an example only and needs to be compiled into an application for it to call the cuSPARSE API functions. Providing this source code allows users to make any changes necessary for a particular platform and toolchain.\nThe cuSPARSE Fortran wrapper code has been used to demonstrate interoperability with the compilers g95 0.91 (on 32-bit and 64-bit Linux) and g95 0.92 (on 32-bit and 64-bit Mac OS X). In order to use other compilers, users have to make any changes to the wrapper code that may be required.\nThe direct wrappers, intended for production code, substitute device pointers for vector and matrix arguments in all cuSPARSE functions. To use these interfaces, existing applications need to be modified slightly to allocate and deallocate data structures in GPU memory space (using\nCUDA_MALLOC()\nand\nCUDA_FREE()\n) and to copy data between GPU and CPU memory spaces (using the\nCUDA_MEMCPY()\nroutines). The sample wrappers provided in\ncusparse_fortran.c\nmap device pointers to the OS-dependent type\nsize_t\n, which is 32 bits wide on 32-bit platforms and 64 bits wide on a 64-bit platforms.\nOne approach to dealing with index arithmetic on device pointers in Fortran code is to use C-style macros and to use the C preprocessor to expand them. On Linux and Mac OS X, preprocessing can be done by using the option\n'-cpp'\nwith g95 or gfortran. The function\nGET_SHIFTED_ADDRESS()\n, provided with the cuSPARSE Fortran wrappers, can also be used, as shown in example B.\nExample B shows the the C++ of example A implemented in Fortran 77 on the host. This example should be compiled with\nARCH_64\ndefined as 1 on a 64-bit OS system and as undefined on a 32-bit OS system. For example, on g95 or gfortran, it can be done directly on the command line using the option\n-cpp\n-DARCH_64=1\n.\n7.1.\nFortran Application\n\nc     #define ARCH_64 0\nc     #define ARCH_64 1\nprogram cusparse_fortran_example\nimplicit none\ninteger cuda_malloc\nexternal cuda_free\ninteger cuda_memcpy_c2fort_int\ninteger cuda_memcpy_c2fort_real\ninteger cuda_memcpy_fort2c_int\ninteger cuda_memcpy_fort2c_real\ninteger cuda_memset\ninteger cusparse_create\nexternal cusparse_destroy\ninteger cusparse_get_version\ninteger cusparse_create_mat_descr\nexternal cusparse_destroy_mat_descr\ninteger cusparse_set_mat_type\ninteger cusparse_get_mat_type\ninteger cusparse_get_mat_fill_mode\ninteger cusparse_get_mat_diag_type\ninteger cusparse_set_mat_index_base\ninteger cusparse_get_mat_index_base\ninteger cusparse_xcoo2csr\ninteger cusparse_dsctr\ninteger cusparse_dcsrmv\ninteger cusparse_dcsrmm\nexternal get_shifted_address\n#if ARCH_64\ninteger*8 handle\ninteger*8 descrA\ninteger*8 cooRowIndex\ninteger*8 cooColIndex\ninteger*8 cooVal\ninteger*8 xInd\ninteger*8 xVal\ninteger*8 y\ninteger*8 z\ninteger*8 csrRowPtr\ninteger*8 ynp1\n#else\ninteger*4 handle\ninteger*4 descrA\ninteger*4 cooRowIndex\ninteger*4 cooColIndex\ninteger*4 cooVal\ninteger*4 xInd\ninteger*4 xVal\ninteger*4 y\ninteger*4 z\ninteger*4 csrRowPtr\ninteger*4 ynp1\n#endif\ninteger status\ninteger cudaStat1,cudaStat2,cudaStat3\ninteger cudaStat4,cudaStat5,cudaStat6\ninteger n, nnz, nnz_vector\nparameter (n=4, nnz=9, nnz_vector=3)\ninteger cooRowIndexHostPtr(nnz)\ninteger cooColIndexHostPtr(nnz)\nreal*8  cooValHostPtr(nnz)\ninteger xIndHostPtr(nnz_vector)\nreal*8  xValHostPtr(nnz_vector)\nreal*8  yHostPtr(2*n)\nreal*8  zHostPtr(2*(n+1))\ninteger i, j\ninteger version, mtype, fmode, dtype, ibase\nreal*8  dzero,dtwo,dthree,dfive\nreal*8  epsilon\nwrite(*,*) \"testing fortran example\"\nc     predefined constants (need to be careful with them)\ndzero = 0.0\ndtwo  = 2.0\ndthree= 3.0\ndfive = 5.0\nc     create the following sparse test matrix in COO format\nc     (notice one-based indexing)\nc     |1.0     2.0 3.0|\nc     |    4.0        |\nc     |5.0     6.0 7.0|\nc     |    8.0     9.0|\ncooRowIndexHostPtr(1)=1\ncooColIndexHostPtr(1)=1\ncooValHostPtr(1)     =1.0\ncooRowIndexHostPtr(2)=1\ncooColIndexHostPtr(2)=3\ncooValHostPtr(2)     =2.0\ncooRowIndexHostPtr(3)=1\ncooColIndexHostPtr(3)=4\ncooValHostPtr(3)     =3.0\ncooRowIndexHostPtr(4)=2\ncooColIndexHostPtr(4)=2\ncooValHostPtr(4)     =4.0\ncooRowIndexHostPtr(5)=3\ncooColIndexHostPtr(5)=1\ncooValHostPtr(5)     =5.0\ncooRowIndexHostPtr(6)=3\ncooColIndexHostPtr(6)=3\ncooValHostPtr(6)     =6.0\ncooRowIndexHostPtr(7)=3\ncooColIndexHostPtr(7)=4\ncooValHostPtr(7)     =7.0\ncooRowIndexHostPtr(8)=4\ncooColIndexHostPtr(8)=2\ncooValHostPtr(8)     =8.0\ncooRowIndexHostPtr(9)=4\ncooColIndexHostPtr(9)=4\ncooValHostPtr(9)     =9.0\nc     print the matrix\nwrite(*,*) \"Input data:\"\ndo i=1,nnz\nwrite(*,*) \"cooRowIndexHostPtr[\",i,\"]=\",cooRowIndexHostPtr(i)\nwrite(*,*) \"cooColIndexHostPtr[\",i,\"]=\",cooColIndexHostPtr(i)\nwrite(*,*) \"cooValHostPtr[\",     i,\"]=\",cooValHostPtr(i)\nenddo\nc     create a sparse and dense vector\nc     xVal= [100.0 200.0 400.0]   (sparse)\nc     xInd= [0     1     3    ]\nc     y   = [10.0 20.0 30.0 40.0 | 50.0 60.0 70.0 80.0] (dense)\nc     (notice one-based indexing)\nyHostPtr(1) = 10.0\nyHostPtr(2) = 20.0\nyHostPtr(3) = 30.0\nyHostPtr(4) = 40.0\nyHostPtr(5) = 50.0\nyHostPtr(6) = 60.0\nyHostPtr(7) = 70.0\nyHostPtr(8) = 80.0\nxIndHostPtr(1)=1\nxValHostPtr(1)=100.0\nxIndHostPtr(2)=2\nxValHostPtr(2)=200.0\nxIndHostPtr(3)=4\nxValHostPtr(3)=400.0\nc     print the vectors\ndo j=1,2\ndo i=1,n\nwrite(*,*) \"yHostPtr[\",i,\",\",j,\"]=\",yHostPtr(i+n*(j-1))\nenddo\nenddo\ndo i=1,nnz_vector\nwrite(*,*) \"xIndHostPtr[\",i,\"]=\",xIndHostPtr(i)\nwrite(*,*) \"xValHostPtr[\",i,\"]=\",xValHostPtr(i)\nenddo\nc     allocate GPU memory and copy the matrix and vectors into it\nc     cudaSuccess=0\nc     cudaMemcpyHostToDevice=1\ncudaStat1 = cuda_malloc(cooRowIndex,nnz*4)\ncudaStat2 = cuda_malloc(cooColIndex,nnz*4)\ncudaStat3 = cuda_malloc(cooVal,     nnz*8)\ncudaStat4 = cuda_malloc(y,          2*n*8)\ncudaStat5 = cuda_malloc(xInd,nnz_vector*4)\ncudaStat6 = cuda_malloc(xVal,nnz_vector*8)\nif ((cudaStat1 /= 0) .OR.\n$    (cudaStat2 /= 0) .OR.\n$    (cudaStat3 /= 0) .OR.\n$    (cudaStat4 /= 0) .OR.\n$    (cudaStat5 /= 0) .OR.\n$    (cudaStat6 /= 0)) then\nwrite(*,*) \"Device malloc failed\"\nwrite(*,*) \"cudaStat1=\",cudaStat1\nwrite(*,*) \"cudaStat2=\",cudaStat2\nwrite(*,*) \"cudaStat3=\",cudaStat3\nwrite(*,*) \"cudaStat4=\",cudaStat4\nwrite(*,*) \"cudaStat5=\",cudaStat5\nwrite(*,*) \"cudaStat6=\",cudaStat6\nstop 2\nendif\ncudaStat1 = cuda_memcpy_fort2c_int(cooRowIndex,cooRowIndexHostPtr,\n$                                   nnz*4,1)\ncudaStat2 = cuda_memcpy_fort2c_int(cooColIndex,cooColIndexHostPtr,\n$                                   nnz*4,1)\ncudaStat3 = cuda_memcpy_fort2c_real(cooVal,    cooValHostPtr,\n$                                    nnz*8,1)\ncudaStat4 = cuda_memcpy_fort2c_real(y,      yHostPtr,\n$                                    2*n*8,1)\ncudaStat5 = cuda_memcpy_fort2c_int(xInd,       xIndHostPtr,\n$                                   nnz_vector*4,1)\ncudaStat6 = cuda_memcpy_fort2c_real(xVal,      xValHostPtr,\n$                                    nnz_vector*8,1)\nif ((cudaStat1 /= 0) .OR.\n$    (cudaStat2 /= 0) .OR.\n$    (cudaStat3 /= 0) .OR.\n$    (cudaStat4 /= 0) .OR.\n$    (cudaStat5 /= 0) .OR.\n$    (cudaStat6 /= 0)) then\nwrite(*,*) \"Memcpy from Host to Device failed\"\nwrite(*,*) \"cudaStat1=\",cudaStat1\nwrite(*,*) \"cudaStat2=\",cudaStat2\nwrite(*,*) \"cudaStat3=\",cudaStat3\nwrite(*,*) \"cudaStat4=\",cudaStat4\nwrite(*,*) \"cudaStat5=\",cudaStat5\nwrite(*,*) \"cudaStat6=\",cudaStat6\ncall cuda_free(cooRowIndex)\ncall cuda_free(cooColIndex)\ncall cuda_free(cooVal)\ncall cuda_free(xInd)\ncall cuda_free(xVal)\ncall cuda_free(y)\nstop 1\nendif\nc     initialize cusparse library\nc     CUSPARSE_STATUS_SUCCESS=0\nstatus = cusparse_create(handle)\nif (status /= 0) then\nwrite(*,*) \"CUSPARSE Library initialization failed\"\ncall cuda_free(cooRowIndex)\ncall cuda_free(cooColIndex)\ncall cuda_free(cooVal)\ncall cuda_free(xInd)\ncall cuda_free(xVal)\ncall cuda_free(y)\nstop 1\nendif\nc     get version\nc     CUSPARSE_STATUS_SUCCESS=0\nstatus = cusparse_get_version(handle,version)\nif (status /= 0) then\nwrite(*,*) \"CUSPARSE Library initialization failed\"\ncall cuda_free(cooRowIndex)\ncall cuda_free(cooColIndex)\ncall cuda_free(cooVal)\ncall cuda_free(xInd)\ncall cuda_free(xVal)\ncall cuda_free(y)\ncall cusparse_destroy(handle)\nstop 1\nendif\nwrite(*,*) \"CUSPARSE Library version\",version\nc     create and setup the matrix descriptor\nc     CUSPARSE_STATUS_SUCCESS=0\nc     CUSPARSE_MATRIX_TYPE_GENERAL=0\nc     CUSPARSE_INDEX_BASE_ONE=1\nstatus= cusparse_create_mat_descr(descrA)\nif (status /= 0) then\nwrite(*,*) \"Creating matrix descriptor failed\"\ncall cuda_free(cooRowIndex)\ncall cuda_free(cooColIndex)\ncall cuda_free(cooVal)\ncall cuda_free(xInd)\ncall cuda_free(xVal)\ncall cuda_free(y)\ncall cusparse_destroy(handle)\nstop 1\nendif\nstatus = cusparse_set_mat_type(descrA,0)\nstatus = cusparse_set_mat_index_base(descrA,1)\nc     print the matrix descriptor\nmtype = cusparse_get_mat_type(descrA)\nfmode = cusparse_get_mat_fill_mode(descrA)\ndtype = cusparse_get_mat_diag_type(descrA)\nibase = cusparse_get_mat_index_base(descrA)\nwrite (*,*) \"matrix descriptor:\"\nwrite (*,*) \"t=\",mtype,\"m=\",fmode,\"d=\",dtype,\"b=\",ibase\nc     exercise conversion routines (convert matrix from COO 2 CSR format)\nc     cudaSuccess=0\nc     CUSPARSE_STATUS_SUCCESS=0\nc     CUSPARSE_INDEX_BASE_ONE=1\ncudaStat1 = cuda_malloc(csrRowPtr,(n+1)*4)\nif (cudaStat1 /= 0) then\ncall cuda_free(cooRowIndex)\ncall cuda_free(cooColIndex)\ncall cuda_free(cooVal)\ncall cuda_free(xInd)\ncall cuda_free(xVal)\ncall cuda_free(y)\ncall cusparse_destroy_mat_descr(descrA)\ncall cusparse_destroy(handle)\nwrite(*,*) \"Device malloc failed (csrRowPtr)\"\nstop 2\nendif\nstatus= cusparse_xcoo2csr(handle,cooRowIndex,nnz,n,\n$                          csrRowPtr,1)\nif (status /= 0) then\ncall cuda_free(cooRowIndex)\ncall cuda_free(cooColIndex)\ncall cuda_free(cooVal)\ncall cuda_free(xInd)\ncall cuda_free(xVal)\ncall cuda_free(y)\ncall cuda_free(csrRowPtr)\ncall cusparse_destroy_mat_descr(descrA)\ncall cusparse_destroy(handle)\nwrite(*,*) \"Conversion from COO to CSR format failed\"\nstop 1\nendif\nc     csrRowPtr = [0 3 4 7 9]\nc     exercise Level 1 routines (scatter vector elements)\nc     CUSPARSE_STATUS_SUCCESS=0\nc     CUSPARSE_INDEX_BASE_ONE=1\ncall get_shifted_address(y,n*8,ynp1)\nstatus= cusparse_dsctr(handle, nnz_vector, xVal, xInd,\n$                       ynp1, 1)\nif (status /= 0) then\ncall cuda_free(cooRowIndex)\ncall cuda_free(cooColIndex)\ncall cuda_free(cooVal)\ncall cuda_free(xInd)\ncall cuda_free(xVal)\ncall cuda_free(y)\ncall cuda_free(csrRowPtr)\ncall cusparse_destroy_mat_descr(descrA)\ncall cusparse_destroy(handle)\nwrite(*,*) \"Scatter from sparse to dense vector failed\"\nstop 1\nendif\nc     y = [10 20 30 40 | 100 200 70 400]\nc     exercise Level 2 routines (csrmv)\nc     CUSPARSE_STATUS_SUCCESS=0\nc     CUSPARSE_OPERATION_NON_TRANSPOSE=0\nstatus= cusparse_dcsrmv(handle, 0, n, n, nnz, dtwo,\n$                       descrA, cooVal, csrRowPtr, cooColIndex,\n$                       y, dthree, ynp1)\nif (status /= 0) then\ncall cuda_free(cooRowIndex)\ncall cuda_free(cooColIndex)\ncall cuda_free(cooVal)\ncall cuda_free(xInd)\ncall cuda_free(xVal)\ncall cuda_free(y)\ncall cuda_free(csrRowPtr)\ncall cusparse_destroy_mat_descr(descrA)\ncall cusparse_destroy(handle)\nwrite(*,*) \"Matrix-vector multiplication failed\"\nstop 1\nendif\nc     print intermediate results (y)\nc     y = [10 20 30 40 | 680 760 1230 2240]\nc     cudaSuccess=0\nc     cudaMemcpyDeviceToHost=2\ncudaStat1 = cuda_memcpy_c2fort_real(yHostPtr, y, 2*n*8, 2)\nif (cudaStat1 /= 0) then\ncall cuda_free(cooRowIndex)\ncall cuda_free(cooColIndex)\ncall cuda_free(cooVal)\ncall cuda_free(xInd)\ncall cuda_free(xVal)\ncall cuda_free(y)\ncall cuda_free(csrRowPtr)\ncall cusparse_destroy_mat_descr(descrA)\ncall cusparse_destroy(handle)\nwrite(*,*) \"Memcpy from Device to Host failed\"\nstop 1\nendif\nwrite(*,*) \"Intermediate results:\"\ndo j=1,2\ndo i=1,n\nwrite(*,*) \"yHostPtr[\",i,\",\",j,\"]=\",yHostPtr(i+n*(j-1))\nenddo\nenddo\nc     exercise Level 3 routines (csrmm)\nc     cudaSuccess=0\nc     CUSPARSE_STATUS_SUCCESS=0\nc     CUSPARSE_OPERATION_NON_TRANSPOSE=0\ncudaStat1 = cuda_malloc(z, 2*(n+1)*8)\nif (cudaStat1 /= 0) then\ncall cuda_free(cooRowIndex)\ncall cuda_free(cooColIndex)\ncall cuda_free(cooVal)\ncall cuda_free(xInd)\ncall cuda_free(xVal)\ncall cuda_free(y)\ncall cuda_free(csrRowPtr)\ncall cusparse_destroy_mat_descr(descrA)\ncall cusparse_destroy(handle)\nwrite(*,*) \"Device malloc failed (z)\"\nstop 2\nendif\ncudaStat1 = cuda_memset(z, 0, 2*(n+1)*8)\nif (cudaStat1 /= 0) then\ncall cuda_free(cooRowIndex)\ncall cuda_free(cooColIndex)\ncall cuda_free(cooVal)\ncall cuda_free(xInd)\ncall cuda_free(xVal)\ncall cuda_free(y)\ncall cuda_free(z)\ncall cuda_free(csrRowPtr)\ncall cusparse_destroy_mat_descr(descrA)\ncall cusparse_destroy(handle)\nwrite(*,*) \"Memset on Device failed\"\nstop 1\nendif\nstatus= cusparse_dcsrmm(handle, 0, n, 2, n, nnz, dfive,\n$                        descrA, cooVal, csrRowPtr, cooColIndex,\n$                        y, n, dzero, z, n+1)\nif (status /= 0) then\ncall cuda_free(cooRowIndex)\ncall cuda_free(cooColIndex)\ncall cuda_free(cooVal)\ncall cuda_free(xInd)\ncall cuda_free(xVal)\ncall cuda_free(y)\ncall cuda_free(z)\ncall cuda_free(csrRowPtr)\ncall cusparse_destroy_mat_descr(descrA)\ncall cusparse_destroy(handle)\nwrite(*,*) \"Matrix-matrix multiplication failed\"\nstop 1\nendif\nc     print final results (z)\nc     cudaSuccess=0\nc     cudaMemcpyDeviceToHost=2\ncudaStat1 = cuda_memcpy_c2fort_real(zHostPtr, z, 2*(n+1)*8, 2)\nif (cudaStat1 /= 0) then\ncall cuda_free(cooRowIndex)\ncall cuda_free(cooColIndex)\ncall cuda_free(cooVal)\ncall cuda_free(xInd)\ncall cuda_free(xVal)\ncall cuda_free(y)\ncall cuda_free(z)\ncall cuda_free(csrRowPtr)\ncall cusparse_destroy_mat_descr(descrA)\ncall cusparse_destroy(handle)\nwrite(*,*) \"Memcpy from Device to Host failed\"\nstop 1\nendif\nc     z = [950 400 2550 2600 0 | 49300 15200 132300 131200 0]\nwrite(*,*) \"Final results:\"\ndo j=1,2\ndo i=1,n+1\nwrite(*,*) \"z[\",i,\",\",j,\"]=\",zHostPtr(i+(n+1)*(j-1))\nenddo\nenddo\nc     check the results\nepsilon = 0.00000000000001\nif ((DABS(zHostPtr(1) - 950.0)   .GT. epsilon)  .OR.\n$    (DABS(zHostPtr(2) - 400.0)   .GT. epsilon)  .OR.\n$    (DABS(zHostPtr(3) - 2550.0)  .GT. epsilon)  .OR.\n$    (DABS(zHostPtr(4) - 2600.0)  .GT. epsilon)  .OR.\n$    (DABS(zHostPtr(5) - 0.0)     .GT. epsilon)  .OR.\n$    (DABS(zHostPtr(6) - 49300.0) .GT. epsilon)  .OR.\n$    (DABS(zHostPtr(7) - 15200.0) .GT. epsilon)  .OR.\n$    (DABS(zHostPtr(8) - 132300.0).GT. epsilon)  .OR.\n$    (DABS(zHostPtr(9) - 131200.0).GT. epsilon)  .OR.\n$    (DABS(zHostPtr(10) - 0.0)    .GT. epsilon)  .OR.\n$    (DABS(yHostPtr(1) - 10.0)    .GT. epsilon)  .OR.\n$    (DABS(yHostPtr(2) - 20.0)    .GT. epsilon)  .OR.\n$    (DABS(yHostPtr(3) - 30.0)    .GT. epsilon)  .OR.\n$    (DABS(yHostPtr(4) - 40.0)    .GT. epsilon)  .OR.\n$    (DABS(yHostPtr(5) - 680.0)   .GT. epsilon)  .OR.\n$    (DABS(yHostPtr(6) - 760.0)   .GT. epsilon)  .OR.\n$    (DABS(yHostPtr(7) - 1230.0)  .GT. epsilon)  .OR.\n$    (DABS(yHostPtr(8) - 2240.0)  .GT. epsilon)) then\nwrite(*,*) \"fortran example test FAILED\"\nelse\nwrite(*,*) \"fortran example test PASSED\"\nendif\nc      deallocate GPU memory and exit\ncall cuda_free(cooRowIndex)\ncall cuda_free(cooColIndex)\ncall cuda_free(cooVal)\ncall cuda_free(xInd)\ncall cuda_free(xVal)\ncall cuda_free(y)\ncall cuda_free(z)\ncall cuda_free(csrRowPtr)\ncall cusparse_destroy_mat_descr(descrA)\ncall cusparse_destroy(handle)\nstop 0\nend\n8.\nAcknowledgements\n\nNVIDIA would like to thank the following individuals and institutions for their contributions:\nThe cusparse<t>gtsv implementation is derived from a version developed by Li-Wen Chang from the University of Illinois.\nThe cusparse<t>gtsvInterleavedBatch adopts cuThomasBatch developed by Pedro Valero-Lara and Ivan Martínez-Pérez from Barcelona Supercomputing Center and BSC/UPC NVIDIA GPU Center of Excellence.\nThis product includes {fmt} - A modern formatting library\nhttps://fmt.dev\nCopyright (c) 2012 - present, Victor Zverovich.\n9.\nBibliography\n\n[1] N. Bell and M. Garland,\n“Implementing Sparse Matrix-Vector Multiplication on Throughput-Oriented Processors”\n, Supercomputing, 2009.\n[2] R. Grimes, D. Kincaid, and D. Young, “ITPACK 2.0 User’s Guide”, Technical Report CNA-150, Center for Numerical Analysis, University of Texas, 1979.\n[3] M. Naumov,\n“Incomplete-LU and Cholesky Preconditioned Iterative Methods Using cuSPARSE and cuBLAS”\n, Technical Report and White Paper, 2011.\n[4] Pedro Valero-Lara, Ivan Martínez-Pérez, Raül Sirvent, Xavier Martorell, and Antonio J. Peña. NVIDIA GPUs Scalability to Solve Multiple (Batch) Tridiagonal Systems. Implementation of cuThomasBatch. In Parallel Processing and Applied Mathematics - 12th International Conference (PPAM), 2017.\n10.\nNotices\n\n10.1.\nNotice\n\nThis document is provided for information purposes only and shall not be regarded as a warranty of a certain functionality, condition, or quality of a product. NVIDIA Corporation (“NVIDIA”) makes no representations or warranties, expressed or implied, as to the accuracy or completeness of the information contained in this document and assumes no responsibility for any errors contained herein. NVIDIA shall have no liability for the consequences or use of such information or for any infringement of patents or other rights of third parties that may result from its use. This document is not a commitment to develop, release, or deliver any Material (defined below), code, or functionality.\nNVIDIA reserves the right to make corrections, modifications, enhancements, improvements, and any other changes to this document, at any time without notice.\nCustomer should obtain the latest relevant information before placing orders and should verify that such information is current and complete.\nNVIDIA products are sold subject to the NVIDIA standard terms and conditions of sale supplied at the time of order acknowledgement, unless otherwise agreed in an individual sales agreement signed by authorized representatives of NVIDIA and customer (“Terms of Sale”). NVIDIA hereby expressly objects to applying any customer general terms and conditions with regards to the purchase of the NVIDIA product referenced in this document. No contractual obligations are formed either directly or indirectly by this document.\nNVIDIA products are not designed, authorized, or warranted to be suitable for use in medical, military, aircraft, space, or life support equipment, nor in applications where failure or malfunction of the NVIDIA product can reasonably be expected to result in personal injury, death, or property or environmental damage. NVIDIA accepts no liability for inclusion and/or use of NVIDIA products in such equipment or applications and therefore such inclusion and/or use is at customer’s own risk.\nNVIDIA makes no representation or warranty that products based on this document will be suitable for any specified use. Testing of all parameters of each product is not necessarily performed by NVIDIA. It is customer’s sole responsibility to evaluate and determine the applicability of any information contained in this document, ensure the product is suitable and fit for the application planned by customer, and perform the necessary testing for the application in order to avoid a default of the application or the product. Weaknesses in customer’s product designs may affect the quality and reliability of the NVIDIA product and may result in additional or different conditions and/or requirements beyond those contained in this document. NVIDIA accepts no liability related to any default, damage, costs, or problem which may be based on or attributable to: (i) the use of the NVIDIA product in any manner that is contrary to this document or (ii) customer product designs.\nNo license, either expressed or implied, is granted under any NVIDIA patent right, copyright, or other NVIDIA intellectual property right under this document. Information published by NVIDIA regarding third-party products or services does not constitute a license from NVIDIA to use such products or services or a warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual property rights of the third party, or a license from NVIDIA under the patents or other intellectual property rights of NVIDIA.\nReproduction of information in this document is permissible only if approved in advance by NVIDIA in writing, reproduced without alteration and in full compliance with all applicable export laws and regulations, and accompanied by all associated conditions, limitations, and notices.\nTHIS DOCUMENT AND ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, “MATERIALS”) ARE BEING PROVIDED “AS IS.” NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL NVIDIA BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Notwithstanding any damages that customer might incur for any reason whatsoever, NVIDIA’s aggregate and cumulative liability towards customer for the products described herein shall be limited in accordance with the Terms of Sale for the product.\n10.2.\nOpenCL\n\nOpenCL is a trademark of Apple Inc. used under license to the Khronos Group Inc.\n10.3.\nTrademarks\n\nNVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated.", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://docs.nvidia.com/cuda/cusparse/index.html"}}
{"text": "1. Introduction — cuSOLVER 13.0 documentation\n»\n1.\nIntroduction\nv13.0 |\nPDF\n|\nArchive\ncuSOLVER API Reference\nThe API reference guide for cuSOLVER, a GPU accelerated library for decompositions and linear system solutions for both dense and sparse matrices.\n1.\nIntroduction\n\nThe cuSolver library is a high-level package based on the cuBLAS and cuSPARSE libraries. It consists of two modules corresponding to two sets of API:\nThe cuSolver API on a single GPU\nThe cuSolverMG API on a single node multiGPU\nEach of these can be used independently or in concert with other toolkit libraries. To simplify the notation, cuSolver denotes single GPU API and cuSolverMg denotes multiGPU API.\nThe intent of cuSolver is to provide useful LAPACK-like features, such as common matrix factorization and triangular solve routines for dense matrices, a sparse least-squares solver and an eigenvalue solver. In addition cuSolver provides a new refactorization library useful for solving sequences of matrices with a shared sparsity pattern.\ncuSolver combines three separate components under a single umbrella. The first part of cuSolver is called cuSolverDN, and deals with dense matrix factorization and solve routines such as LU, QR, SVD and LDLT, as well as useful utilities such as matrix and vector permutations.\nNext, cuSolverSP provides a new set of sparse routines based on a sparse QR factorization. Not all matrices have a good sparsity pattern for parallelism in factorization, so the cuSolverSP library also provides a CPU path to handle those sequential-like matrices. For those matrices with abundant parallelism, the GPU path will deliver higher performance. The library is designed to be called from C and C++.\nThe final part is cuSolverRF, a sparse re-factorization package that can provide very good performance when solving a sequence of matrices where only the coefficients are changed but the sparsity pattern remains the same.\nThe GPU path of the cuSolver library assumes data is already in the device memory. It is the responsibility of the developer to allocate memory and to copy data between GPU memory and CPU memory using standard CUDA runtime API routines, such as\ncudaMalloc()\n,\ncudaFree()\n,\ncudaMemcpy()\n, and\ncudaMemcpyAsync()\n.\ncuSolverMg is GPU-accelerated ScaLAPACK. By now, cuSolverMg supports 1-D column block cyclic layout and provides symmetric eigenvalue solver.\nNote\nThe cuSolver library requires hardware with a CUDA Compute Capability (CC) of 5.0 or higher. Please see the\nCUDA C++ Programming Guide\nfor a list of the\nCompute Capabilities\ncorresponding to all NVIDIA GPUs.\nNote\ncuSolverMG is deprecated. Users are encouraged to use\ncuSOLVERMp\nfor multi-GPU functionality, both single- and multi-node.\n1.1.\ncuSolverDN: Dense LAPACK\n\nThe cuSolverDN library was designed to solve dense linear systems of the form\n\\[Ax = b\\]\nwhere the coefficient matrix\n\\(A\\in R^{nxn}\\)\n, right-hand-side vector\n\\(b\\in R^{n}\\)\nand solution vector\n\\(x\\in R^{n}\\)\nThe cuSolverDN library provides QR factorization and LU with partial pivoting to handle a general matrix\nA\n, which may be non-symmetric. Cholesky factorization is also provided for symmetric/Hermitian matrices. For symmetric indefinite matrices, we provide Bunch-Kaufman (LDL) factorization.\nThe cuSolverDN library also provides a helpful bidiagonalization routine and singular value decomposition (SVD).\nThe cuSolverDN library targets computationally-intensive and popular routines in LAPACK, and provides an API compatible with LAPACK. The user can accelerate these time-consuming routines with cuSolverDN and keep others in LAPACK without a major change to existing code.\n1.2.\ncuSolverSP: Sparse LAPACK\n\nThe cuSolverSP library was mainly designed to a solve sparse linear system\n\\[Ax = b\\]\nand the least-squares problem\n\\[x = {argmin}{||}A*z - b{||}\\]\nwhere sparse matrix\n\\(A\\in R^{mxn}\\)\n, right-hand-side vector\n\\(b\\in R^{m}\\)\nand solution vector\n\\(x\\in R^{n}\\)\n. For a linear system, we require\nm=n\n.\nThe core algorithm is based on sparse QR factorization. The matrix\nA\nis accepted in CSR format. If matrix\nA\nis symmetric/Hermitian, the user has to provide a full matrix, ie fill missing lower or upper part.\nIf matrix\nA\nis symmetric positive definite and the user only needs to solve\n\\(Ax = b\\)\n, Cholesky factorization can work and the user only needs to provide the lower triangular part of\nA\n.\nOn top of the linear and least-squares solvers, the\ncuSolverSP\nlibrary provides a simple eigenvalue solver based on shift-inverse power method, and a function to count the number of eigenvalues contained in a box in the complex plane.\nNote\ncuSolverSp is deprecated and will be removed in a future major release. It is recommended migrating to a new sparse direct solver package,\ncuDSS\n, and you can find a transition example in\nCUDALibrarySamples/cuSOLVERSp2cuDSS\nfor reference.\n1.3.\ncuSolverRF: Refactorization\n\nThe cuSolverRF library was designed to accelerate solution of sets of linear systems by fast re-factorization when given new coefficients in the same sparsity pattern\n\\[A_{i}x_{i} = f_{i}\\]\nwhere a sequence of coefficient matrices\n\\(A_{i}\\in R^{nxn}\\)\n, right-hand-sides\n\\(f_{i}\\in R^{n}\\)\nand solutions\n\\(x_{i}\\in R^{n}\\)\nare given for\ni=1,...,k\n.\nThe cuSolverRF library is applicable when the sparsity pattern of the coefficient matrices\n\\(A_{i}\\)\nas well as the reordering to minimize fill-in and the pivoting used during the LU factorization remain the same across these linear systems. In that case, the first linear system (\ni=1\n) requires a full LU factorization, while the subsequent linear systems (\ni=2,...,k\n) require only the LU re-factorization. The later can be performed using the cuSolverRF library.\nNotice that because the sparsity pattern of the coefficient matrices, the reordering and pivoting remain the same, the sparsity pattern of the resulting triangular factors\n\\(L_{i}\\)\nand\n\\(U_{i}\\)\nalso remains the same. Therefore, the real difference between the full LU factorization and LU re-factorization is that the required memory is known ahead of time.\nNote\ncuSolverRf is deprecated and will be removed in a future major release. It is recommended migrating to a new sparse direct solver package,\ncuDSS\n, and you can find a transition example in\nCUDALibrarySamples/cuSOLVERSp2cuDSS\nfor reference.\n1.4.\nNaming Conventions\n\nThe cuSolverDN library provides two different APIs;\nlegacy\nand\ngeneric\n.\nThe functions in the legacy API are available for data types\nfloat\n,\ndouble\n,\ncuComplex\n, and\ncuDoubleComplex\n. The naming convention for the legacy API is as follows:\ncusolverDn\n<\nt\n><\noperation\n>\nwhere <\nt\n> can be\nS\n,\nD\n,\nC\n,\nZ\n, or\nX\n, corresponding to the data types\nfloat\n,\ndouble\n,\ncuComplex\n,\ncuDoubleComplex\n, and the generic type, respectively. <\noperation\n> can be Cholesky factorization (\npotrf\n), LU with partial pivoting (\ngetrf\n), QR factorization (\ngeqrf\n) and Bunch-Kaufman factorization (\nsytrf\n).\nThe functions in the generic API provide a single entry point for each routine and support for 64-bit integers to define matrix and vector dimensions. The naming convention for the generic API is data-agnostic and is as follows:\ncusolverDn\n<\noperation\n>\nwhere <\noperation\n> can be Cholesky factorization (\npotrf\n), LU with partial pivoting (\ngetrf\n) and QR factorization (\ngeqrf\n).\nThe cuSolverSP library functions are available for data types\nfloat\n,\ndouble\n,\ncuComplex\n, and\ncuDoubleComplex\n. The naming convention is as follows:\ncusolverSp[Host]\n<\nt\n>[<\nmatrix\ndata\nformat\n>]<\noperation\n>[<\noutput\nmatrix\ndata\nformat\n>]<\nbased\non\n>\nwhere\ncuSolverSp\nis the GPU path and\ncusolverSpHost\nis the corresponding CPU path. <\nt\n> can be\nS\n,\nD\n,\nC\n,\nZ\n, or\nX\n, corresponding to the data types\nfloat\n,\ndouble\n,\ncuComplex\n,\ncuDoubleComplex\n, and the generic type, respectively.\nThe <\nmatrix\ndata\nformat\n> is\ncsr\n, compressed sparse row format.\nThe <\noperation\n> can be\nls\n,\nlsq\n,\neig\n,\neigs\n, corresponding to linear solver, least-square solver, eigenvalue solver and number of eigenvalues in a box, respectively.\nThe <\noutput\nmatrix\ndata\nformat\n> can be\nv\nor\nm\n, corresponding to a vector or a matrix.\n<\nbased\non\n> describes which algorithm is used. For example,\nqr\n(sparse QR factorization) is used in linear solver and least-square solver.\nAll of the functions have the return type\ncusolverStatus_t\nand are explained in more detail in the chapters that follow.\ncuSolverSP API\n\nRoutine\nData format\nOperation\nOutput format\nBased on\ncsrlsvlu\ncsr\nlinear\nsolver\n(ls)\nvector\n(v)\nLU\n(lu)\nwith\npartial\npivoting\ncsrlsvqr\ncsr\nlinear\nsolver\n(ls)\nvector\n(v)\nQR\nfactorization\n(qr)\ncsrlsvchol\ncsr\nlinear\nsolver\n(ls)\nvector\n(v)\nCholesky\nfactorization\n(chol)\ncsrlsqvqr\ncsr\nleast-square\nsolver\n(lsq)\nvector\n(v)\nQR\nfactorization\n(qr)\ncsreigvsi\ncsr\neigenvalue\nsolver\n(eig)\nvector\n(v)\nshift-inverse\ncsreigs\ncsr\nnumber\nof\neigenvalues\nin\na\nbox\n(eigs)\ncsrsymrcm\ncsr\nSymmetric\nReverse\nCuthill-McKee\n(symrcm)\nThe cuSolverRF library routines are available for data type\ndouble\n. Most of the routines follow the naming convention:\ncusolverRf\n_<\noperation\n>_[\n[Host]\n](…)\nwhere the trailing optional Host qualifier indicates the data is accessed on the host versus on the device, which is the default. The <\noperation\n> can be\nSetup\n,\nAnalyze\n,\nRefactor\n,\nSolve\n,\nResetValues\n,\nAccessBundledFactors\nand\nExtractSplitFactors\n.\nFinally, the return type of the cuSolverRF library routines is\ncusolverStatus_t\n.\n1.5.\nAsynchronous Execution\n\nThe cuSolver library functions prefer to keep asynchronous execution as much as possible. Developers can always use the\ncudaDeviceSynchronize()\nfunction to ensure that the execution of a particular cuSolver library routine has completed.\nA developer can also use the\ncudaMemcpy()\nroutine to copy data from the device to the host and vice versa, using the\ncudaMemcpyDeviceToHost\nand\ncudaMemcpyHostToDevice\nparameters, respectively. In this case there is no need to add a call to\ncudaDeviceSynchronize()\nbecause the call to\ncudaMemcpy()\nwith the above parameters is blocking and completes only when the results are ready on the host.\n1.6.\nLibrary Property\n\nThe\nlibraryPropertyType\ndata type is an enumeration of library property types (that is, CUDA version X.Y.Z would yield\nMAJOR_VERSION=X\n,\nMINOR_VERSION=Y\n,\nPATCH_LEVEL=Z\n).\ntypedef\nenum\nlibraryPropertyType_t\n{\nMAJOR_VERSION\n,\nMINOR_VERSION\n,\nPATCH_LEVEL\n}\nlibraryPropertyType\n;\nThe following code can show the version of cusolver library.\nint\nmajor\n=\n-1\n,\nminor\n=\n-1\n,\npatch\n=\n-1\n;\ncusolverGetProperty\n(\nMAJOR_VERSION\n,\n&\nmajor\n);\ncusolverGetProperty\n(\nMINOR_VERSION\n,\n&\nminor\n);\ncusolverGetProperty\n(\nPATCH_LEVEL\n,\n&\npatch\n);\nprintf\n(\n\"CUSOLVER Version (Major,Minor,PatchLevel): %d.%d.%d\n\\n\n\"\n,\nmajor\n,\nminor\n,\npatch\n);\n1.7.\nHigh Precision Package\n\nThe\ncusolver\nlibrary uses high precision for iterative refinement when necessary.\n2.\nUsing the CUSOLVER API\n\n2.1.\nGeneral Description\n\nThis chapter describes how to use the cuSolver library API. It is not a reference for the cuSolver API data types and functions; that is provided in subsequent chapters.\n2.1.1.\nThread Safety\n\nThe library is thread-safe, and its functions can be called from multiple host threads.\n2.1.2.\nScalar Parameters\n\nIn the cuSolver API, the scalar parameters can be passed by reference on the host.\n2.1.3.\nParallelism with Streams\n\nIf the application performs several small independent computations, or if it makes data transfers in parallel with the computation, then CUDA streams can be used to overlap these tasks.\nThe application can conceptually associate a stream with each task. To achieve the overlap of computation between the tasks, the developer should:\nCreate CUDA streams using the function\ncudaStreamCreate()\n, and\nSet the stream to be used by each individual cuSolver library routine by calling, for example,\ncusolverDnSetStream()\n, just prior to calling the actual cuSolverDN routine.\nThe computations performed in separate streams would then be overlapped automatically on the GPU, when possible. This approach is especially useful when the computation performed by a single task is relatively small, and is not enough to fill the GPU with work, or when there is a data transfer that can be performed in parallel with the computation.\n2.1.4.\nHow to Link cusolver Library\n\ncusolver\nlibrary provides dynamic library\nlibcusolver.so\nand static library\nlibcusolver_static.a\n. If the user links the application with\nlibcusolver.so\n,\nlibcublas.so\n,\nlibcublasLt.so\nand\nlibcusparse.so\nare also required. If the user links the application with\nlibcusolver_static.a\n, the following libraries are also needed,\nlibcudart_static.a\n,\nlibculibos.a\n,\nlibcusolver_lapack_static.a\n,\nlibcusolver_metis_static.a\n,\nlibcublas_static.a\nand\nlibcusparse_static.a\n.\n2.1.5.\nLink Third-party LAPACK Library\n\nStarting with CUDA 10.1 update 2, NVIDIA LAPACK library\nlibcusolver_lapack_static.a\nis a subset of LAPACK and only contains GPU accelerated\nstedc\nand\nbdsqr\n. The user has to link\nlibcusolver_static.a\nwith\nlibcusolver_lapack_static.a\nin order to build the application successfully. Prior to CUDA 10.1 update 2, the user can replace\nlibcusolver_lapack_static.a\nwith a third-party LAPACK library, for example, MKL. In CUDA 10.1 update 2, the third-party LAPACK library no longer affects the behavior of cusolver library, neither functionality nor performance. Furthermore the user cannot use\nlibcusolver_lapack_static.a\nas a standalone LAPACK library because it is only a subset of LAPACK.\nIf you use\nlibcusolver_static.a\n, then you must link with\nlibcusolver_lapack_static.a\nexplicitly, otherwise the linker will report missing symbols. There are no symbol conflicts between\nlibcusolver_lapack_static.a\nand other third-party LAPACK libraries, which allows linking the same application to\nlibcusolver_lapack_static.a\nand another third-party LAPACK library.\nThe\nlibcusolver_lapack_static.a\nis built inside\nlibcusolver.so\n. Hence, if you use\nlibcusolver.so\n, then you don’t need to specify a LAPACK library. The\nlibcusolver.so\nwill not pick up any routines from the third-party LAPACK library even if you link the application with it.\n2.1.6.\nConvention of info\n\nEach LAPACK routine returns an\ninfo\nwhich indicates the position of invalid parameter. If\ninfo\n=\n-i\n, then i-th parameter is invalid. To be consistent with base-1 in LAPACK,\ncusolver\ndoes not report invalid\nhandle\ninto\ninfo\n. Instead,\ncusolver\nreturns\nCUSOLVER_STATUS_NOT_INITIALIZED\nfor invalid\nhandle\n.\n2.1.7.\nUsage of _bufferSize\n\nThere is no cudaMalloc inside\ncuSolver\nlibrary, the user must allocate the device workspace explicitly. The routine\nxyz_bufferSize\nis to query the size of workspace of the routine\nxyz\n, for example\nxyz\n=\npotrf\n. To make the API simple,\nxyz_bufferSize\nfollows almost the same signature of\nxyz\neven it only depends on some parameters, for example, device pointer is not used to decide the size of workspace. In most cases,\nxyz_bufferSize\nis called in the beginning before actual device data (pointed to by a device pointer) is prepared or before the device pointer is allocated. In such case, the user can pass null pointer to\nxyz_bufferSize\nwithout breaking the functionality.\n2.1.8.\ncuSOLVERDn Logging\n\ncuSOLVERDn logging mechanism can be enabled by setting the following environment variables before launching the target application:\nCUSOLVERDN_LOG_LEVEL=<level>\n- where\n<level>\nis one of the following levels:\n0\n- Off - logging is disabled (default)\n1\n- Error - only errors will be logged\n2\n- Trace - API calls that launch CUDA kernels will log their parameters and important information\n3\n- Hints - hints that can potentially improve the application’s performance\n4\n- Info - provides general information about the library execution, may contain details about heuristic status\n5\n- API Trace - API calls will log their parameter and important information\nCUSOLVERDN_LOG_MASK=<mask>\n- where mask is a combination of the following masks:\n0\n- Off\n1\n- Error\n2\n- Trace\n4\n- Hints\n8\n- Info\n16\n- API Trace\nCUSOLVERDN_LOG_FILE=<file_name>\n- where file name is a path to a log file. File name may contain\n%i\n, that will be replaced with the process ID, for example\n<file_name>_%i.log\n. If\nCUSOLVERDN_LOG_FILE\nis not defined, the log messages are printed to stdout.\nAnother option is to use the experimental cusolverDn logging API. See:\ncusolverDnLoggerSetCallback()\n,\ncusolverDnLoggerSetFile()\n,\ncusolverDnLoggerOpenFile()\n,\ncusolverDnLoggerSetLevel()\n,\ncusolverDnLoggerSetMask()\n,\ncusolverDnLoggerForceDisable()\n.\n2.1.9.\nDeterministic Results\n\nThroughout this documentation, a function is declared as\ndeterministic\nif it computes the exact same bitwise results for every execution with the same input parameters, hard- and software environment. Conversely, a\nnon-deterministic\nfunction might compute bitwise different results due to a varying order of floating point operations, e.g., a sum\ns\nof four values\na\n,\nb\n,\nc\n,\nd\ncan be computed in different orders:\ns\n=\n(a\n+\nb)\n+\n(c\n+\nd)\ns\n=\n(a\n+\n(b\n+\nc))\n+\nd\ns\n=\na\n+\n(b\n+\n(c\n+\nd))\n…\nDue to the non-associativity of floating point arithmetic, all results might be bitwise different.\nBy default, cuSolverDN computes deterministic results. For improved performance of some functions, it is possible to allow non-deterministic results with\ncusolverDnSetDeterministicMode()\n.\n2.1.10.\nFloating Point Emulation\n\ncuSOLVERDn leverages techniques for floating point emulation as described in\ncuBLAS 1.5 Floating Point Emulation\nfor improved performance. Please note that all\ncusolverDn{Get,Set}Emulation*\nAPIs only affect execution, if a math mode, which allows floating point emulated math, is enabled. However, the corresponding configuration options, which affect floating point emulated math, can be set, regardless of the current math mode. Example:\ncusolverDnSetMathMode\n(\nhandle\n,\nCUSOLVER_DEFAULT_MATH\n);\ncusolverDnSetEmulationStrategy\n(\nhandle\n,\nEMULATION_STRATEGY_EAGER\n);\ncusolverDnXgetrf\n(\nhandle\n,\n...);\n// default math\ncusolverDnSetMathMode\n(\nhandle\n,\nCUSOLVER_FP32_EMULATED_BF16X9_MATH\n);\ncusolverDnXgetrf\n(\nhandle\n,\n...);\n// FP32 emulated math with eager emulation strategy\nNote\nPlease note that cuBLAS environment variables, enabling floating point emulated math, won’t affect the cuSOLVERDn internal cuBLAS handles.\nNote\nPlease note that the workspace sizes returned by\n*_bufferSize\nAPIs may depend on the math mode and emulation strategy.\n2.2.\ncuSolver Types Reference\n\n2.2.1.\ncuSolverDN Types\n\nThe\nfloat\n,\ndouble\n,\ncuComplex\n, and\ncuDoubleComplex\ndata types are supported. The first two are standard C data types, while the last two are exported from\ncuComplex.h\n. In addition, cuSolverDN uses some familiar types from cuBLAS.\n2.2.1.1.\ncusolverDnHandle_t\n\nThis is a pointer type to an opaque cuSolverDN context, which the user must initialize by calling\ncusolverDnCreate()\nprior to calling any other library function. An uninitialized Handle object will lead to unexpected behavior, including crashes of cuSolverDN. The handle created and returned by\ncusolverDnCreate()\nmust be passed to every cuSolverDN function.\n2.2.1.2.\ncublasFillMode_t\n\nThe type indicates which part (lower or upper) of the dense matrix was filled and consequently should be used by the function.\nValue\nMeaning\nCUBLAS_FILL_MODE_LOWER\nThe lower part of the matrix is filled.\nCUBLAS_FILL_MODE_UPPER\nThe upper part of the matrix is filled.\nCUBLAS_FILL_MODE_FULL\nThe full matrix is filled.\nNotice that BLAS implementations often use Fortran characters\n‘L’\nor\n‘l’\n(lower) and\n‘U’\nor\n‘u’\n(upper) to describe which part of the matrix is filled.\n2.2.1.3.\ncublasOperation_t\n\nThe\ncublasOperation_t\ntype indicates which operation needs to be performed with the dense matrix.\nValue\nMeaning\nCUBLAS_OP_N\nThe non-transpose operation is selected.\nCUBLAS_OP_T\nThe transpose operation is selected.\nCUBLAS_OP_C\nThe conjugate transpose operation is selected.\nNotice that BLAS implementations often use Fortran characters\n‘N’\nor\n‘n’\n(non-transpose),\n‘T’\nor\n‘t’\n(transpose) and\n‘C’\nor\n‘c’\n(conjugate transpose) to describe which operations need to be performed      with the dense matrix.\n2.2.1.4.\ncusolverEigType_t\n\nThe\ncusolverEigType_t\ntype indicates which type of eigenvalue the solver is.\nValue\nMeaning\nCUSOLVER_EIG_TYPE_1\nA*x = lambda*B*x\nCUSOLVER_EIG_TYPE_2\nA*B*x = lambda*x\nCUSOLVER_EIG_TYPE_3\nB*A*x = lambda*x\nNotice that LAPACK implementations often use Fortran integer\n1\n(A*x = lambda*B*x),\n2\n(A*B*x = lambda*x),\n3\n(B*A*x = lambda*x) to indicate which type of eigenvalue the solver is.\n2.2.1.5.\ncusolverEigMode_t\n\nThe\ncusolverEigMode_t\ntype indicates whether or not eigenvectors are computed.\nValue\nMeaning\nCUSOLVER_EIG_MODE_NOVECTOR\nOnly eigenvalues are computed.\nCUSOLVER_EIG_MODE_VECTOR\nBoth eigenvalues and eigenvectors are computed.\nNotice that LAPACK implementations often use Fortran character\n'N'\n(only eigenvalues are computed),\n'V'\n(both eigenvalues and eigenvectors are computed) to indicate whether or not eigenvectors        are computed.\n2.2.1.6.\ncusolverIRSRefinement_t\n\nThe\ncusolverIRSRefinement_t\ntype indicates which solver type would be used for the specific cusolver function. Most of our experimentation shows that CUSOLVER_IRS_REFINE_GMRES is the best option.\nMore details about the refinement process can be found in Azzam Haidar, Stanimire Tomov, Jack Dongarra, and Nicholas J. Higham. 2018. Harnessing GPU tensor cores for fast FP16 arithmetic to speed up mixed-precision iterative refinement solvers. In Proceedings of the International Conference for High Performance Computing, Networking, Storage, and Analysis (SC ‘18). IEEE Press, Piscataway, NJ, USA, Article 47, 11 pages.\nCUSOLVER_IRS_REFINE_NOT_SET\nSolver is not set; this value is what is set when creating the\nparams\nstructure. IRS solver will return an error.\nCUSOLVER_IRS_REFINE_NONE\nNo refinement solver, the IRS solver performs a factorization followed by a solve without any refinement. For example if the IRS solver was\ncusolverDnIRSXgesv()\n, this is equivalent to a Xgesv routine without refinement and where the factorization is carried out in the lowest precision. If for example the main precision was CUSOLVER_R_64F and the lowest was CUSOLVER_R_64F as well, then this is equivalent to a call to\ncusolverDnDgesv()\n.\nCUSOLVER_IRS_REFINE_CLASSICAL\nClassical iterative refinement solver. Similar to the one used in LAPACK routines.\nCUSOLVER_IRS_REFINE_GMRES\nGMRES (Generalized Minimal Residual) based iterative refinement solver. In recent study, the GMRES method has drawn the scientific community attention for its ability to be used as refinement solver that outperforms the classical iterative refinement method. Based on our experimentation, we recommend this setting.\nCUSOLVER_IRS_REFINE_CLASSICAL_GMRES\nClassical iterative refinement solver that uses the GMRES (Generalized Minimal Residual) internally to solve the correction equation at each iteration. We call the\nclassical refinement iteration\nthe outer iteration while the\nGMRES\nis called inner iteration. Note that if the tolerance of the inner GMRES is set very low, lets say to machine precision, then the outer\nclassical refinement iteration\nwill performs only one iteration and thus this option will behave like\nCUSOLVER_IRS_REFINE_GMRES\n.\nCUSOLVER_IRS_REFINE_GMRES_GMRES\nSimilar to\nCUSOLVER_IRS_REFINE_CLASSICAL_GMRES\nwhich consists of classical refinement process that uses GMRES to solve the inner correction system; here it is a GMRES (Generalized Minimal Residual) based iterative refinement solver that uses another GMRES internally to solve the preconditioned system.\n2.2.1.7.\ncusolverDnIRSParams_t\n\nThis is a pointer type to an opaque\ncusolverDnIRSParams_t\nstructure, which holds parameters for the iterative refinement linear solvers such as\ncusolverDnXgesv()\n. Use corresponding helper functions described below to either Create/Destroy this structure or Set/Get solver parameters.\n2.2.1.8.\ncusolverDnIRSInfos_t\n\nThis is a pointer type to an opaque\ncusolverDnIRSInfos_t\nstructure, which holds information about the performed call to an iterative refinement linear solver (such as\ncusolverDnXgesv()\n). Use corresponding helper functions described below to either Create/Destroy this structure or retrieve solve information.\n2.2.1.9.\ncusolverDnFunction_t\n\nThe\ncusolverDnFunction_t\ntype indicates which routine needs to be configured by\ncusolverDnSetAdvOptions()\n. The value\nCUSOLVERDN_GETRF\ncorresponds to the routine\nGetrf\n.\nValue\nMeaning\nCUSOLVERDN_GETRF\nCorresponds to\nGetrf\n.\n2.2.1.10.\ncusolverAlgMode_t\n\nThe\ncusolverAlgMode_t\ntype indicates which algorithm is selected by\ncusolverDnSetAdvOptions()\n. The set of algorithms supported for each routine is described in detail along with the routine’s documentation.\nThe default algorithm is\nCUSOLVER_ALG_0\n. The user can also provide\nNULL\nto use the default algorithm.\n2.2.1.11.\ncusolverStatus_t\n\nThis is the same as\ncusolverStatus_t\nin the sparse LAPACK section.\n2.2.1.12.\ncusolverDnLoggerCallback_t\n\ncusolverDnLoggerCallback_t\nis a callback function pointer type.\nParameters\nParameter\nMemory\nIn/out\nDescription\nlogLevel\noutput\nSee\ncuSOLVERDn Logging\nfunctionName\noutput\nThe name of the API that logged this message.\nmessage\noutput\nThe log message.\nUse the below function to set the callback function:\ncusolverDnLoggerSetCallback()\n.\n2.2.1.13.\ncusolverDeterministicMode_t\n\nThe\ncusolverDeterministicMode_t\ntype indicates whether multiple cuSolver function executions with the same input have the same bitwise equal result (deterministic) or might have bitwise different results (non-deterministic). In comparison to\ncublasAtomicsMode_t\n, which only includes the usage of atomic functions,\ncusolverDeterministicMode_t\nincludes all non-deterministic programming patterns.  The deterministic mode can be set and queried using\ncusolverDnSetDeterministicMode()\nand\ncusolverDnGetDeterministicMode()\nroutines, respectively.\nValue\nMeaning\nCUSOLVER_DETERMINISTIC_RESULTS\nCompute deterministic results.\nCUSOLVER_ALLOW_NON_DETERMINISTIC_RESULTS\nAllow non-deterministic results.\n2.2.1.14.\ncusolverMathMode_t\n\nThe\ncusolverMathMode_t\ntype is used in\ncusolverDnSetMathMode()\nto choose compute precision modes as defined in the following table:\nValue\nMeaning\nCUSOLVER_DEFAULT_MATH\nThis is the default math mode. Tensor Cores will be used whenever possible.\nCUSOLVER_FP32_EMULATED_BF16X9_MATH\nUse FP32 emulation according to the configured emulation strategy (see\ncusolverDnSetEmulationStrategy()\n).\n2.2.1.15.\ncusolverStorevMode_t\n\nSpecifies how the vectors which define the elementary reflectors are stored.\nValue\nMeaning\nCUBLAS_STOREV_COLUMNWISE\nColumnwise.\nCUBLAS_STOREV_ROWWISE\nRowwise.\n2.2.1.16.\ncusolverDirectMode_t\n\nSpecifies the order in which the elementary reflectors are multiplied to form the block reflector.\nValue\nMeaning\nCUBLAS_DIRECT_FORWARD\nForward.\nCUBLAS_DIRECT_BACKWARD\nBackward.\n2.2.2.\ncuSolverSP Types\n\nThe\nfloat\n,\ndouble\n,\ncuComplex\n, and\ncuDoubleComplex\ndata types are supported. The first two are standard C data types, while the last two are exported from\ncuComplex.h\n.\n2.2.2.1.\ncusolverSpHandle_t\n\nThis is a pointer type to an opaque cuSolverSP context, which the user must initialize by calling\ncusolverSpCreate()\nprior to calling any other library function. An uninitialized Handle object will lead to unexpected behavior, including crashes of cuSolverSP. The handle created and returned by\ncusolverSpCreate()\nmust be passed to every cuSolverSP function.\n2.2.2.2.\ncusparseMatDescr_t\n\nWe have chosen to keep the same structure as exists in cuSPARSE to describe the shape and properties of a matrix. This enables calls to either cuSPARSE or cuSOLVER using the same matrix description.\ntypedef\nstruct\n{\ncusparseMatrixType_t\nMatrixType\n;\ncusparseFillMode_t\nFillMode\n;\ncusparseDiagType_t\nDiagType\n;\ncusparseIndexBase_t\nIndexBase\n;\n}\ncusparseMatDescr_t\n;\nPlease read documentation of the cuSPARSE Library to understand each field of\ncusparseMatDescr_t\n.\n2.2.2.3.\ncusolverStatus_t\n\nThis is a status type returned by the library functions and it can have the following values.\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe cuSolver library was not initialized. This is usually caused by the lack of a prior call, an error in the CUDA Runtime API called by the cuSolver routine, or an error in the hardware setup.\nTo correct:\ncall\ncusolverDnCreate()\nprior to the function call; and check that the hardware, an appropriate version of the driver, and the cuSolver library are correctly installed.\nCUSOLVER_STATUS_ALLOC_FAILED\nResource allocation failed inside the cuSolver library. This is usually caused by a\ncudaMalloc()\nfailure.\nTo correct:\nprior to the function call, deallocate previously allocated memory as much as possible.\nCUSOLVER_STATUS_INVALID_VALUE\nAn unsupported value or parameter was passed to the function (a negative vector size, for example).\nTo correct:\nensure that all the parameters being passed have valid values.\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe function requires a feature absent from the device architecture; usually caused by the lack of support for atomic operations or double precision.\nTo correct:\ncompile and run the application on a device with compute capability 5.0 or above.\nCUSOLVER_STATUS_EXECUTION_FAILED\nThe GPU program failed to execute. This is often caused by a launch failure of the kernel on the GPU, which can be caused by multiple reasons.\nTo correct:\ncheck that the hardware, an appropriate version of the driver, and the cuSolver library are correctly installed.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal cuSolver operation failed. This error is usually caused by a\ncudaMemcpyAsync()\nfailure.\nTo correct:\ncheck that the hardware, an appropriate version of the driver, and the cuSolver library are correctly installed. Also, check that the memory passed as a parameter to the routine is not being deallocated prior to the routine’s completion.\nCUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED\nThe matrix type is not supported by this function. This is usually caused by passing an invalid matrix descriptor to the function.\nTo correct:\ncheck that the fields in\ndescrA\nwere set correctly.\nCUSOLVER_STATUS_NOT_SUPPORTED\nThe parameter combination is not supported, for example batched version is not supported or\nM\n<\nN\nis not supported.\nTo correct:\nconsult the documentation, and use a supported configuration.\n2.2.3.\ncuSolverRF Types\n\ncuSolverRF only supports\ndouble\n.\n2.2.3.1.\ncusolverRfHandle_t\n\nThe\ncusolverRfHandle_t\nis a pointer to an opaque data structure that contains the cuSolverRF library handle. The user must initialize the handle by calling\ncusolverRfCreate()\nprior to any other cuSolverRF library calls. The handle is passed to all other cuSolverRF library calls.\n2.2.3.2.\ncusolverRfMatrixFormat_t\n\nThe\ncusolverRfMatrixFormat_t\nis an enum that indicates the input/output matrix format assumed by the\ncusolverRfSetupDevice()\n,\ncusolverRfSetupHost()\n,\ncusolverRfResetValues()\n,\ncusolveRfExtractBundledFactorsHost()\nand\ncusolverRfExtractSplitFactorsHost()\nroutines.\nValue\nMeaning\nCUSOLVER_MATRIX_FORMAT_CSR\nMatrix format CSR is assumed. (default)\nCUSOLVER_MATRIX_FORMAT_CSC\nMatrix format CSC is assumed.\n2.2.3.3.\ncusolverRfNumericBoostReport_t\n\nThe\ncusolverRfNumericBoostReport_t\nis an enum that indicates whether numeric boosting (of the pivot) was used during the\ncusolverRfRefactor()\nand\ncusolverRfSolve()\nroutines. The numeric boosting is disabled by default.\nValue\nMeaning\nCUSOLVER_NUMERIC_BOOST_NOT_USED\nNumeric boosting not used. (default)\nCUSOLVER_NUMERIC_BOOST_USED\nNumeric boosting used.\n2.2.3.4.\ncusolverRfResetValuesFastMode_t\n\nThe\ncusolverRfResetValuesFastMode_t\nis an enum that indicates the mode used for the\ncusolverRfResetValues()\nroutine. The fast mode requires extra memory and is recommended only if very fast calls to\ncusolverRfResetValues()\nare needed.\nValue\nMeaning\nCUSOLVER_RESET_VALUES_FAST_MODE_OFF\nFast mode disabled. (default)\nCUSOLVER_RESET_VALUES_FAST_MODE_ON\nFast mode enabled.\n2.2.3.5.\ncusolverRfFactorization_t\n\nThe\ncusolverRfFactorization_t\nis an enum that indicates which (internal) algorithm is used for refactorization in the\ncusolverRfRefactor()\nroutine.\nValue\nMeaning\nCUSOLVER_FACTORIZATION_ALG0\nAlgorithm 0. (default)\nCUSOLVER_FACTORIZATION_ALG1\nAlgorithm 1.\nCUSOLVER_FACTORIZATION_ALG2\nAlgorithm 2. Domino-based scheme.\n2.2.3.6.\ncusolverRfTriangularSolve_t\n\nThe\ncusolverRfTriangularSolve_t\nis an enum that indicates which (internal) algorithm is used for triangular solve in the\ncusolverRfSolve()\nroutine.\nValue\nMeaning\nCUSOLVER_TRIANGULAR_SOLVE_ALG1\nAlgorithm 1. (default)\nCUSOLVER_TRIANGULAR_SOLVE_ALG2\nAlgorithm 2. Domino-based scheme.\nCUSOLVER_TRIANGULAR_SOLVE_ALG3\nAlgorithm 3. Domino-based scheme.\n2.2.3.7.\ncusolverRfUnitDiagonal_t\n\nThe\ncusolverRfUnitDiagonal_t\nis an enum that indicates whether and where the unit diagonal is stored in the input/output triangular factors in the\ncusolverRfSetupDevice()\n,\ncusolverRfSetupHost()\nand\ncusolverRfExtractSplitFactorsHost()\nroutines.\nValue\nMeaning\nCUSOLVER_UNIT_DIAGONAL_STORED_L\nUnit diagonal is stored in lower triangular factor (default).\nCUSOLVER_UNIT_DIAGONAL_STORED_U\nUnit diagonal is stored in upper triangular factor.\nCUSOLVER_UNIT_DIAGONAL_ASSUMED_L\nUnit diagonal is assumed in lower triangular factor.\nCUSOLVER_UNIT_DIAGONAL_ASSUMED_U\nUnit diagonal is assumed in upper triangular factor.\n2.2.3.8.\ncusolverStatus_t\n\nThe\ncusolverStatus_t\nis an enum that indicates success or failure of the cuSolverRF library call. It is returned by all the cuSolver library routines, and it uses the same enumerated values as the sparse and dense Lapack routines.\n2.3.\ncuSolver Formats Reference\n\n2.3.1.\nIndex Base Format\n\nBoth one-based and zero-based indexing are supported in cuSolver.\n2.3.2.\nVector (Dense) Format\n\nThe vectors are assumed to be stored linearly in memory. For example, the vector\n\\[\\begin{split}x =\n\\begin{pmatrix}\nx_1 \\\\\nx_2 \\\\\n\\vdots \\\\\nx_n\n\\end{pmatrix}\\end{split}\\]\nis represented as\n\\[\\begin{split}\\begin{pmatrix}\nx_1 & x_2 & \\ldots & x_n \\\\\n\\end{pmatrix}\\end{split}\\]\n2.3.3.\nMatrix (Dense) Format\n\nThe dense matrices are assumed to be stored in column-major order in memory. The sub-matrix can be accessed using the leading dimension of the original matrix. For example, the\nm*n\n(sub-)matrix\n\\[\\begin{split}\\begin{pmatrix}\na_{1,1} & \\cdots & a_{1,n} \\\\\na_{2,1} & \\cdots & a_{2,n} \\\\\n\\vdots \\\\\na_{m,1} & \\cdots & a_{m,n} \\\\\n\\end{pmatrix}\\end{split}\\]\nis represented as\n\\[\\begin{split}\\begin{pmatrix}\na_{1,1} & \\ldots & a_{1,n} \\\\\na_{2,1} & \\ldots & a_{2,n} \\\\\n\\vdots & \\ddots & \\vdots \\\\\na_{m,1} & \\ldots & a_{m,n} \\\\\n\\vdots & \\ddots & \\vdots \\\\\na_{{lda},1} & \\ldots & a_{{lda},n} \\\\\n\\end{pmatrix}\\end{split}\\]\nwith its elements arranged linearly in memory as\n\\[\\begin{split}\\begin{pmatrix}\na_{1,1} \\quad a_{2,1} \\quad \\ldots \\quad a_{m,1} \\quad \\ldots \\quad a_{lda,1} \\quad \\ldots \\quad a_{1,n} \\quad a_{2,n} \\quad \\ldots \\quad a_{m,n} \\quad \\ldots \\quad a_{lda,n} \\\\\n\\end{pmatrix}\\end{split}\\]\nwhere\nlda\n\\(\\geq\\)\nm\nis the leading dimension of\nA\n.\n2.3.4.\nMatrix (CSR) Format\n\nIn CSR format the matrix is represented by the following parameters:\nParameter\nType\nSize\nMeaning\nn\n(int)\nThe number of rows (and columns) in the matrix.\nnnz\n(int)\nThe number of non-zero elements in the matrix.\ncsrRowPtr\n(int\n*)\nn+1\nThe array of offsets corresponding to the start of each row in the arrays\ncsrColInd\nand\ncsrVal\n. This array has also an extra entry at the end that stores the number of non-zero elements in the matrix.\ncsrColInd\n(int\n*)\nnnz\nThe array of column indices corresponding to the non-zero elements in the matrix.\nIt is assumed that this array is sorted by row and by column within each row.\ncsrVal\n(S|D|C|Z)*\nnnz\nThe array of values corresponding to the non-zero elements in the matrix.\nIt is assumed that this array is sorted by row and by column within each row.\nNote that in our CSR format, sparse matrices are assumed to be stored in row-major order, in other words, the index arrays are first sorted by row indices and then within each row by column indices. Also it is assumed that each pair of row and column indices appears only once.\nFor example, the\n4x4\nmatrix\n\\[\\begin{split}A = \\begin{pmatrix}\n{1.0} & {3.0} & {0.0} & {0.0} \\\\\n{0.0} & {4.0} & {6.0} & {0.0} \\\\\n{2.0} & {5.0} & {7.0} & {8.0} \\\\\n{0.0} & {0.0} & {0.0} & {9.0} \\\\\n\\end{pmatrix}\\end{split}\\]\nis represented as\n\\[\\begin{split}{csrRowPtr} = \\begin{pmatrix}\n0 & 2 & 4 & 8 & 9 \\\\\n\\end{pmatrix}\\end{split}\\]\n\\[\\begin{split}{csrColInd} = \\begin{pmatrix}\n0 & 1 & 1 & 2 & 0 & 1 & 2 & 3 & 3 \\\\\n\\end{pmatrix}\\end{split}\\]\n\\[\\begin{split}{csrVal} = \\begin{pmatrix}\n1.0 & 3.0 & 4.0 & 6.0 & 2.0 & 5.0 & 7.0 & 8.0 & 9.0 \\\\\n\\end{pmatrix}\\end{split}\\]\n2.3.5.\nMatrix (CSC) Format\n\nIn CSC format the matrix is represented by the following parameters:\nParameter\nType\nSize\nMeaning\nn\n(int)\nThe number of rows (and columns) in the matrix.\nnnz\n(int)\nThe number of non-zero elements in the matrix.\ncscColPtr\n(int\n*)\nn+1\nThe array of offsets corresponding to the start of each column in the arrays\ncscRowInd\nand\ncscVal\n. This array has also an extra entry at the end that stores the number of non-zero elements in the matrix.\ncscRowInd\n(int\n*)\nnnz\nThe array of row indices corresponding to the non-zero elements in the matrix.\nIt is assumed that this array is sorted by column and by row within each column.\ncscVal\n(S|D|C|Z)*\nnnz\nThe array of values corresponding to the non-zero elements in the matrix.\nIt is assumed that this array is sorted by column and by row within each column.\nNote that in our CSC format, sparse matrices are assumed to be stored in column-major order, in other words, the index arrays are first sorted by column indices and then within each column by row indices. Also it is assumed that each pair of row and column indices appears only once.\nFor example, the\n4x4\nmatrix\n\\[\\begin{split}A = \\begin{pmatrix}\n{1.0} & {3.0} & {0.0} & {0.0} \\\\\n{0.0} & {4.0} & {6.0} & {0.0} \\\\\n{2.0} & {5.0} & {7.0} & {8.0} \\\\\n{0.0} & {0.0} & {0.0} & {9.0} \\\\\n\\end{pmatrix}\\end{split}\\]\nis represented as\n\\[\\begin{split}{cscColPtr} = \\begin{pmatrix}\n0 & 2 & 5 & 7 & 9 \\\\\n\\end{pmatrix}\\end{split}\\]\n\\[\\begin{split}{cscRowInd} = \\begin{pmatrix}\n0 & 2 & 0 & 1 & 2 & 1 & 2 & 2 & 3 \\\\\n\\end{pmatrix}\\end{split}\\]\n\\[\\begin{split}{cscVal} = \\begin{pmatrix}\n1.0 & 2.0 & 3.0 & 4.0 & 5.0 & 6.0 & 7.0 & 8.0 & 9.0 \\\\\n\\end{pmatrix}\\end{split}\\]\n2.4.\ncuSolverDN: dense LAPACK Function Reference\n\nThis section describes the API of cuSolverDN, which provides a subset of dense LAPACK functions.\n2.4.1.\ncuSolverDN Helper Function Reference\n\nThe cuSolverDN helper functions are described in this section.\n2.4.1.1.\ncusolverDnCreate()\n\ncusolverStatus_t\ncusolverDnCreate\n(\ncusolverDnHandle_t\n*\nhandle\n);\nThis function initializes the cuSolverDN library and creates a handle on the cuSolverDN context. It must be called before any other cuSolverDN API function is invoked. It allocates hardware resources necessary for accessing the GPU.\nThis function allocates 4 MiB or 32 MiB of memory (for GPUs with Compute Capability of 9.0 and higher), which will be used as the cuBLAS workspace for the first user-defined stream on which\ncusolverDnSetStream()\nis called.\nFor the default stream and in all the other cases, cuBLAS will manage its own workspace.\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\noutput\nThe pointer to the handle to the cuSolverDN context.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe initialization succeeded.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe CUDA Runtime initialization failed.\nCUSOLVER_STATUS_ALLOC_FAILED\nThe resources could not be allocated.\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\n2.4.1.2.\ncusolverDnDestroy()\n\ncusolverStatus_t\ncusolverDnDestroy\n(\ncusolverDnHandle_t\nhandle\n);\nThis function releases CPU-side resources used by the cuSolverDN library.\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe shutdown succeeded.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\n2.4.1.3.\ncusolverDnSetStream()\n\ncusolverStatus_t\ncusolverDnSetStream\n(\ncusolverDnHandle_t\nhandle\n,\ncudaStream_t\nstreamId\n)\nThis function sets the stream to be used by the cuSolverDN library to execute its routines.\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nstreamId\nhost\ninput\nThe stream to be used by the library.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe stream was set successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\n2.4.1.4.\ncusolverDnGetStream()\n\ncusolverStatus_t\ncusolverDnGetStream\n(\ncusolverDnHandle_t\nhandle\n,\ncudaStream_t\n*\nstreamId\n)\nThis function queries the stream to be used by the cuSolverDN library to execute its routines.\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nstreamId\nhost\noutput\nThe stream which is used by\nhandle\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe stream was set successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\n2.4.1.5.\ncusolverDnLoggerSetCallback()\n\ncusolverStatus_t\ncusolverDnLoggerSetCallback\n(\ncusolverDnLoggerCallback_t\ncallback\n);\nThis function sets the logging callback function.\nParameters\nParameter\nMemory\nIn/out\nMeaning\ncallback\ninput\nPointer to a callback function. See\ncusolverDnLoggerCallback_t\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nIf the callback function was successfully set.\nSee\ncusolverStatus_t\nfor a complete list of valid return codes.\n2.4.1.6.\ncusolverDnLoggerSetFile()\n\ncusolverStatus_t\ncusolverDnLoggerSetFile\n(\nFILE\n*\nfile\n);\nThis function sets the logging output file. Note: once registered using this function call, the provided file handle must not be closed unless the function is called again to switch to a different file handle.\nParameters\nParameter\nMemory\nIn/out\nMeaning\nfile\ninput\nPointer to an open file. File should have write permission.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nIf logging file was successfully set.\nSee\ncusolverStatus_t\nfor a complete list of valid return codes.\n2.4.1.7.\ncusolverDnLoggerOpenFile()\n\ncusolverStatus_t\ncusolverDnLoggerOpenFile\n(\nconst\nchar\n*\nlogFile\n);\nThis function opens a logging output file in the given path.\nParameters\nParameter\nMemory\nIn/out\nMeaning\nlogFile\ninput\nPath of the logging output file.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nIf the logging file was successfully opened.\nSee\ncusolverStatus_t\nfor a complete list of valid return codes.\n2.4.1.8.\ncusolverDnLoggerSetLevel()\n\ncusolverStatus_t\ncusolverDnLoggerSetLevel\n(\nint\nlevel\n);\nThis function sets the value of the logging level.\nParameters\nParameter\nMemory\nIn/out\nMeaning\nlevel\ninput\nValue of the logging level. See\ncuSOLVERDn Logging\n.\nStatus Returned\nCUSOLVER_STATUS_INVALID_VALUE\nIf the value was not a valid logging level. See\ncuSOLVERDn Logging\n.\nCUSOLVER_STATUS_SUCCESS\nIf the logging level was successfully set.\nSee\ncusolverStatus_t\nfor a complete list of valid return codes.\n2.4.1.9.\ncusolverDnLoggerSetMask()\n\ncusolverStatus_t\ncusolverDnLoggerSetMask\n(\nint\nmask\n);\nThis function sets the value of the logging mask.\nParameters\nParameter\nMemory\nIn/out\nMeaning\nmask\ninput\nValue of the logging mask. See\ncuSOLVERDn Logging\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nIf the logging mask was successfully set.\nSee\ncusolverStatus_t\nfor a complete list of valid return codes.\n2.4.1.10.\ncusolverDnLoggerForceDisable()\n\ncusolverStatus_t\ncusolverDnLoggerForceDisable\n();\nThis function disables logging for the entire run.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nIf logging was successfully disabled.\nSee\ncusolverStatus_t\nfor a complete list of valid return codes.\n2.4.1.11.\ncusolverDnSetDeterministicMode()\n\ncusolverStatus_t\ncusolverDnSetDeterministicMode\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDeterministicMode_t\nmode\n)\nThis function sets the deterministic mode of all cuSolverDN functions for\nhandle\n. For improved performance,\nnon-deterministic results can be allowed. Affected functions are\ncusolverDn<t>geqrf()\n,\ncusolverDn<t>syevd()\n,\ncusolverDn<t>syevdx()\n,\ncusolverDn<t>gesvd()\n(if\nm\n>\nn\n),\ncusolverDn<t>gesvdj()\n,\ncusolverDnXgeqrf()\n,\ncusolverDnXsyevd()\n,\ncusolverDnXsyevdx()\n,\ncusolverDnXgesvd()\n(if\nm\n>\nn\n),\ncusolverDnXgesvdr()\nand\ncusolverDnXgesvdp()\n.\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nmode\nhost\ninput\nThe deterministic mode to be used with\nhandle\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe mode was set successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal error occurred.\n2.4.1.12.\ncusolverDnGetDeterministicMode()\n\ncusolverStatus_t\ncusolverDnGetDeterministicMode\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDeterministicMode_t\n*\nmode\n)\nThis function queries the deterministic mode which is set for\nhandle\n.\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nmode\nhost\noutput\nThe deterministic mode of\nhandle\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe mode was set successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nmode\nis a\nNULL\npointer.\n2.4.1.13.\ncusolverDnSetMathMode()\n\ncusolverStatus_t\ncusolverDnSetMathMode\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverMathMode_t\nmode\n);\nThis function sets the math mode of all cuSolverDN functions for\nhandle\n. For more information about the effects of the corresponding math mode, please refer to\ncusolverMathMode_t\n.\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nmode\nhost\ninput\nThe math mode to be used with\nhandle\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe mode was set successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nAn invalid mode was given.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal error occurred.\nNote\nPlease note that the workspace sizes returned by\n*_bufferSize\nAPIs may depend on the math mode.\n2.4.1.14.\ncusolverDnGetMathMode()\n\ncusolverStatus_t\ncusolverDnGetMathMode\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverMathMode_t\n*\nmode\n);\nThis function queries the math mode which is set for\nhandle\n.\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nmode\nhost\noutput\nThe math mode of\nhandle\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe mode was set successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nmode\nis a\nNULL\npointer.\n2.4.1.15.\ncusolverDnSetEmulationStrategy()\n\ncusolverStatus_t\ncusolverDnSetEmulationStrategy\n(\ncusolverHandle_t\nhandle\n,\ncudaEmulationStrategy_t\nstrategy\n);\nThis function sets the emulation strategy of all cuSolverDN functions for\nhandle\n. For more information about the effects of the corresponding strategies, please refer to the analogous definition of\ncublasEmulationStrategy_t\n.\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nstrategy\nhost\ninput\nThe emulation strategy to be used with\nhandle\n.\nThe emulation strategy set by this API only has an effect,\nonce\nthe following math mode is enabled (see also\ncusolverMathMode_t\n):\nCUSOLVER_FP32_EMULATED_BF16X9_MATH\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe strategy was set successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nstrategy was not a supported emulation strategy\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal error occurred.\nNote\nPlease note that the workspace sizes returned by\n*_bufferSize\nAPIs may depend on the emulation strategy.\n2.4.1.16.\ncusolverDnGetEmulationStrategy()\n\ncusolverStatus_t\ncusolverDnGetEmulationStrategy\n(\ncusolverHandle_t\nhandle\n,\ncudaEmulationStrategy_t\n*\nemulationStrategy\n);\nThis function queries the emulation strategy which is set for\nhandle\n.\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nstrategy\nhost\noutput\nThe emulation strategy of\nhandle\n.\nThe emulation strategy returned by this API only has an effect,\nonce\nthe following math mode is enabled (see also\ncusolverMathMode_t\n):\nCUSOLVER_FP32_EMULATED_BF16X9_MATH\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe strategy was queried successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nemulationStrategy\nis a\nNULL\npointer.\n2.4.1.17.\ncusolverDnCreateSyevjInfo()\n\ncusolverStatus_t\ncusolverDnCreateSyevjInfo\n(\nsyevjInfo_t\n*\ninfo\n);\nThis function creates and initializes the structure of\nsyevj\n,\nsyevjBatched\nand\nsygvj\nto default values.\nParameter\nMemory\nIn/out\nMeaning\ninfo\nhost\noutput\nThe pointer to the structure of\nsyevj\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe structure was initialized successfully.\nCUSOLVER_STATUS_ALLOC_FAILED\nThe resources could not be allocated.\n2.4.1.18.\ncusolverDnDestroySyevjInfo()\n\ncusolverStatus_t\ncusolverDnDestroySyevjInfo\n(\nsyevjInfo_t\ninfo\n);\nThis function destroys and releases any memory required by the structure.\nParameter\nMemory\nIn/out\nMeaning\ninfo\nhost\ninput\nThe structure of\nsyevj\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe resources were released successfully.\n2.4.1.19.\ncusolverDnXsyevjSetTolerance()\n\ncusolverStatus_t\ncusolverDnXsyevjSetTolerance\n(\nsyevjInfo_t\ninfo\n,\ndouble\ntolerance\n)\nThis function configures tolerance of\nsyevj\n.\nParameter\nMemory\nIn/out\nMeaning\ninfo\nhost\nin/out\nThe pointer to the structure of\nsyevj\n.\ntolerance\nhost\ninput\nAccuracy of numerical eigenvalues.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\n2.4.1.20.\ncusolverDnXsyevjSetMaxSweeps()\n\ncusolverStatus_t\ncusolverDnXsyevjSetMaxSweeps\n(\nsyevjInfo_t\ninfo\n,\nint\nmax_sweeps\n)\nThis function configures maximum number of sweeps in\nsyevj\n. The default value is 100.\nParameter\nMemory\nIn/out\nMeaning\ninfo\nhost\nin/out\nThe pointer to the structure of\nsyevj\n.\nmax_sweeps\nhost\ninput\nMaximum number of sweeps.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\n2.4.1.21.\ncusolverDnXsyevjSetSortEig()\n\ncusolverStatus_t\ncusolverDnXsyevjSetSortEig\n(\nsyevjInfo_t\ninfo\n,\nint\nsort_eig\n)\nIf\nsort_eig\nis zero, the eigenvalues are not sorted. This function only works for\nsyevjBatched\n.\nsyevj\nand\nsygvj\nalways sort eigenvalues in ascending order. By default, eigenvalues are always sorted in ascending order.\nParameter\nMemory\nIn/out\nMeaning\ninfo\nhost\nin/out\nThe pointer to the structure of syevj.\nsort_eig\nhost\ninput\nIf\nsort_eig\nis zero, the eigenvalues are not sorted.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\n2.4.1.22.\ncusolverDnXsyevjGetResidual()\n\ncusolverStatus_t\ncusolverDnXsyevjGetResidual\n(\ncusolverDnHandle_t\nhandle\n,\nsyevjInfo_t\ninfo\n,\ndouble\n*\nresidual\n)\nThis function reports residual of\nsyevj\nor\nsygvj\n. It does not support\nsyevjBatched\n. If the user calls this function after\nsyevjBatched\n, the error\nCUSOLVER_STATUS_NOT_SUPPORTED\nis returned.\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\ninfo\nhost\ninput\nThe pointer to the structure of\nsyevj\n.\nresidual\nhost\noutput\nResidual of\nsyevj\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_SUPPORTED\nDoes not support batched version.\n2.4.1.23.\ncusolverDnXsyevjGetSweeps()\n\ncusolverStatus_t\ncusolverDnXsyevjGetSweeps\n(\ncusolverDnHandle_t\nhandle\n,\nsyevjInfo_t\ninfo\n,\nint\n*\nexecuted_sweeps\n)\nThis function reports number of executed sweeps of\nsyevj\nor\nsygvj\n. It does not support\nsyevjBatched\n. If the user calls this function after\nsyevjBatched\n, the error\nCUSOLVER_STATUS_NOT_SUPPORTED\nis returned.\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\ninfo\nhost\ninput\nThe pointer to the structure of\nsyevj\n.\nexecuted_sweeps\nhost\noutput\nNumber of executed sweeps.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_SUPPORTED\nDoes not support batched version.\n2.4.1.24.\ncusolverDnCreateGesvdjInfo()\n\ncusolverStatus_t\ncusolverDnCreateGesvdjInfo\n(\ngesvdjInfo_t\n*\ninfo\n);\nThis function creates and initializes the structure of\ngesvdj\nand\ngesvdjBatched\nto default values.\nParameter\nMemory\nIn/out\nMeaning\ninfo\nhost\noutput\nThe pointer to the structure of\ngesvdj\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe structure was initialized successfully.\nCUSOLVER_STATUS_ALLOC_FAILED\nThe resources could not be allocated.\n2.4.1.25.\ncusolverDnDestroyGesvdjInfo()\n\ncusolverStatus_t\ncusolverDnDestroyGesvdjInfo\n(\ngesvdjInfo_t\ninfo\n);\nThis function destroys and releases any memory required by the structure.\nParameter\nMemory\nIn/out\nMeaning\ninfo\nhost\ninput\nThe structure of\ngesvdj\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe resources were released successfully.\n2.4.1.26.\ncusolverDnXgesvdjSetTolerance()\n\ncusolverStatus_t\ncusolverDnXgesvdjSetTolerance\n(\ngesvdjInfo_t\ninfo\n,\ndouble\ntolerance\n)\nThis function configures tolerance of\ngesvdj\n.\nParameter\nMemory\nIn/out\nMeaning\ninfo\nhost\nin/out\nThe pointer to the structure of\ngesvdj\n.\ntolerance\nhost\ninput\nAccuracy of numerical singular values.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\n2.4.1.27.\ncusolverDnXgesvdjSetMaxSweeps()\n\ncusolverStatus_t\ncusolverDnXgesvdjSetMaxSweeps\n(\ngesvdjInfo_t\ninfo\n,\nint\nmax_sweeps\n)\nThis function configures the maximum number of sweeps in\ngesvdj\n. The default value is 100.\nParameter\nMemory\nIn/out\nMeaning\ninfo\nhost\nin/out\nThe pointer to the structure of\ngesvdj\n.\nmax_sweeps\nhost\ninput\nMaximum number of sweeps.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\n2.4.1.28.\ncusolverDnXgesvdjSetSortEig()\n\ncusolverStatus_t\ncusolverDnXgesvdjSetSortEig\n(\ngesvdjInfo_t\ninfo\n,\nint\nsort_svd\n)\nIf\nsort_svd\nis zero, the singular values are not sorted. This function only works for\ngesvdjBatched\n.\ngesvdj\nalways sorts singular values in descending order. By default, singular values are always sorted in descending order.\nParameter\nMemory\nIn/out\nMeaning\ninfo\nhost\nin/out\nThe pointer to the structure of\ngesvdj\n.\nsort_svd\nhost\ninput\nIf\nsort_svd\nis zero, the singular values are not sorted.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\n2.4.1.29.\ncusolverDnXgesvdjGetResidual()\n\ncusolverStatus_t\ncusolverDnXgesvdjGetResidual\n(\ncusolverDnHandle_t\nhandle\n,\ngesvdjInfo_t\ninfo\n,\ndouble\n*\nresidual\n)\nThis function reports the Frobenius norm of the internal residual returned by\ngesvdj\n. Note that this is\nnot\nthe Frobenious norm of the exact residual calculated as\n\\[{\\|{S} - {U}^{H}*{A}*{V}\\|}_{F}\\]\nThis function does not support\ngesvdjBatched\n. If the user calls this function after\ngesvdjBatched\n, the error\nCUSOLVER_STATUS_NOT_SUPPORTED\nis returned.\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\ninfo\nhost\ninput\nThe pointer to the structure of\ngesvdj\n.\nresidual\nhost\noutput\nResidual of\ngesvdj\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_SUPPORTED\nDoes not support batched version\n2.4.1.30.\ncusolverDnXgesvdjGetSweeps()\n\ncusolverStatus_t\ncusolverDnXgesvdjGetSweeps\n(\ncusolverDnHandle_t\nhandle\n,\ngesvdjInfo_t\ninfo\n,\nint\n*\nexecuted_sweeps\n)\nThis function reports number of executed sweeps of\ngesvdj\n. It does not support\ngesvdjBatched\n. If the user calls this function after\ngesvdjBatched\n, the error\nCUSOLVER_STATUS_NOT_SUPPORTED\nis returned.\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\ninfo\nhost\ninput\nThe pointer to the structure of\ngesvdj\n.\nexecuted_sweeps\nhost\noutput\nNumber of executed sweeps.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_SUPPORTED\nDoes not support batched version\n2.4.1.31.\ncusolverDnIRSParamsCreate()\n\ncusolverStatus_t\ncusolverDnIRSParamsCreate\n(\ncusolverDnIRSParams_t\n*\nparams\n);\nThis function creates and initializes the structure of parameters for an IRS solver such as the\ncusolverDnIRSXgesv()\nor the\ncusolverDnIRSXgels()\nfunctions to default values. The params structure created by this function can be used by one or more call to the same or to a different IRS solver. Note that in CUDA 10.2, the behavior was different and a new\nparams\nstructure was needed to be created per each call to an IRS solver. Also note that the user can also change configurations of the params and then call a new IRS instance, but be careful that the previous call was done because any change to the configuration before the previous call was done could affect it.\nParameter\nMemory\nIn/out\nMeaning\nparams\nhost\noutput\nPointer to the\ncusolverDnIRSParams_t\nParams\nstructure\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe structure was created and initialized successfully.\nCUSOLVER_STATUS_ALLOC_FAILED\nThe resources could not be allocated.\n2.4.1.32.\ncusolverDnIRSParamsDestroy()\n\ncusolverStatus_t\ncusolverDnIRSParamsDestroy\n(\ncusolverDnIRSParams_t\nparams\n);\nThis function destroys and releases any memory required by the Params structure.\nParameter\nMemory\nIn/out\nMeaning\nparams\nhost\ninput\nThe\ncusolverDnIRSParams_t\nParams\nstructure.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe resources were released successfully.\nCUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED\nThe\nParams\nstructure was not created.\nCUSOLVER_STATUS_IRS_INFOS_NOT_DESTROYED\nNot all the\nInfos\nstructure associated with this\nParams\nstructure have been destroyed yet.\n2.4.1.33.\ncusolverDnIRSParamsSetSolverPrecisions()\n\ncusolverStatus_t\ncusolverDnIRSParamsSetSolverPrecisions\n(\ncusolverDnIRSParams_t\nparams\n,\ncusolverPrecType_t\nsolver_main_precision\n,\ncusolverPrecType_t\nsolver_lowest_precision\n);\nThis function sets both the main and the lowest precision for the Iterative Refinement Solver (IRS). By main precision, we mean the precision of the Input and Output datatype. By lowest precision, we mean the solver is allowed to use as lowest computational precision during the LU factorization process. Note that the user has to set both the main and lowest precision before the first call to the IRS solver because they are NOT set by default with the\nparams\nstructure creation, as it depends on the Input Output data type and user request. It is a wrapper to both\ncusolverDnIRSParamsSetSolverMainPrecision()\nand\ncusolverDnIRSParamsSetSolverLowestPrecision()\n. All possible combinations of main/lowest precision are described in the table below. Usually the lowest precision defines the speedup that can be achieved. The ratio of the performance of the lowest precision over the main precision (e.g., Inputs/Outputs datatype) define the upper bound of the speedup that could be obtained. More precisely, it depends on many factors, but for large matrices sizes, it is the ratio of the matrix-matrix rank-k product (e.g., GEMM where K is 256 and M=N=size of the matrix) that define the possible speedup. For instance, if the inout precision is real double precision CUSOLVER_R_64F and the lowest precision is CUSOLVER_R_32F, then we can expect a speedup of at most 2X for large problem sizes. If the lowest precision was CUSOLVER_R_16F, then we can expect 3X-4X. A reasonable strategy should take the number of right-hand sides, the size of the matrix as well as the convergence rate into account.\nParameter\nMemory\nIn/out\nMeaning\nparams\nhost\nin/out\nThe\ncusolverDnIRSParams_t\nParams\nstructure.\nsolver_main_precision\nhost\ninput\nAllowed Inputs/Outputs datatype (for example CUSOLVER_R_FP64 for a real double precision data). See the table below for the supported precisions.\nsolver_lowest_precision\nhost\ninput\nAllowed lowest compute type (for example CUSOLVER_R_16F for half precision computation). See the table below for the supported precisions.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED\nThe\nParams\nstructure was not created.\nSupported Inputs/Outputs data type and lower precision for the IRS solver\n\nInputs/Outputs Data Type (e.g., main precision)\nSupported values for the lowest precision\nCUSOLVER_C_64F\nCUSOLVER_C_64F,\nCUSOLVER_C_32F,\nCUSOLVER_C_16F,\nCUSOLVER_C_16BF,\nCUSOLVER_C_TF32\nCUSOLVER_C_32F\nCUSOLVER_C_32F,\nCUSOLVER_C_16F,\nCUSOLVER_C_16BF,\nCUSOLVER_C_TF32\nCUSOLVER_R_64F\nCUSOLVER_R_64F,\nCUSOLVER_R_32F,\nCUSOLVER_R_16F,\nCUSOLVER_R_16BF,\nCUSOLVER_R_TF32\nCUSOLVER_R_32F\nCUSOLVER_R_32F,\nCUSOLVER_R_16F,\nCUSOLVER_R_16BF,\nCUSOLVER_R_TF32\n2.4.1.34.\ncusolverDnIRSParamsSetSolverMainPrecision()\n\ncusolverStatus_t\ncusolverDnIRSParamsSetSolverMainPrecision\n(\ncusolverDnIRSParams_t\nparams\n,\ncusolverPrecType_t\nsolver_main_precision\n);\nThis function sets the main precision for the Iterative Refinement Solver (IRS). By main precision, we mean, the type of the Input and Output data. Note that the user has to set both the main and lowest precision before a first call to the IRS solver because they are NOT set by default with the\nparams\nstructure creation, as it depends on the Input Output data type and user request. user can set it by either calling this function or by calling\ncusolverDnIRSParamsSetSolverPrecisions()\nwhich set both the main and the lowest precision together. All possible combinations of main/lowest precision are described in the\ntable\nin the\ncusolverDnIRSParamsSetSolverPrecisions()\nsection above.\nParameter\nMemory\nIn/out\nMeaning\nparams\nhost\nin/out\nThe\ncusolverDnIRSParams_t\nParams\nstructure.\nsolver_main_precision\nhost\ninput\nAllowed Inputs/Outputs datatype (for example CUSOLVER_R_FP64 for a real double precision data). See the table in the\ncusolverDnIRSParamsSetSolverPrecisions()\nsection above for the supported precisions.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED\nThe\nParams\nstructure was not created.\n2.4.1.35.\ncusolverDnIRSParamsSetSolverLowestPrecision()\n\ncusolverStatus_t\ncusolverDnIRSParamsSetSolverLowestPrecision\n(\ncusolverDnIRSParams_t\nparams\n,\ncusolverPrecType_t\nlowest_precision_type\n);\nThis function sets the lowest precision that will be used by Iterative Refinement Solver. By lowest precision, we mean the solver is allowed to use as lowest computational precision during the LU factorization process. Note that the user has to set both the main and lowest precision before a first call to the IRS solver because they are NOT set by default with the\nparams\nstructure creation, as it depends on the Input Output data type and user request. Usually the lowest precision defines the speedup that can be achieved. The ratio of the performance of the lowest precision over the main precision (e.g., Inputs/Outputs datatype) define somehow the upper bound of the speedup that could be obtained. More precisely, it depends on many factors, but for large matrices sizes, it is the ratio of the matrix-matrix rank-k product (e.g., GEMM where K is 256 and M=N=size of the matrix) that define the possible speedup. For instance, if the inout precision is real double precision CUSOLVER_R_64F and the lowest precision is CUSOLVER_R_32F, then we can expect a speedup of at most 2X for large problem sizes. If the lowest precision was CUSOLVER_R_16F, then we can expect 3X-4X. A reasonable strategy should take the number of right-hand sides, the size of the matrix as well as the convergence rate into account.\nParameter\nMemory\nIn/out\nMeaning\nparams\nhost\nin/out\nThe\ncusolverDnIRSParams_t\nParams\nstructure.\nlowest_precision_type\nhost\ninput\nAllowed lowest compute type (for example CUSOLVER_R_16F for half precision computation). See the table in the\ncusolverDnIRSParamsSetSolverPrecisions()\nsection above for the supported precisions.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED\nThe Params structure was not created.\n2.4.1.36.\ncusolverDnIRSParamsSetRefinementSolver()\n\ncusolverStatus_t\ncusolverDnIRSParamsSetRefinementSolver\n(\ncusolverDnIRSParams_t\nparams\n,\ncusolverIRSRefinement_t\nsolver\n);\nThis function sets the refinement solver to be used in the Iterative Refinement Solver functions such as the\ncusolverDnIRSXgesv()\nor the\ncusolverDnIRSXgels()\nfunctions. Note that the user has to set the refinement algorithm before a first call to the IRS solver because it is NOT set by default with the creating of params. Details about values that can be set to and theirs meaning are described in the table below.\nParameter\nMemory\nIn/out\nMeaning\nparams\nhost\nin/out\nThe\ncusolverDnIRSParams_t\nParams\nstructure\nsolver\nhost\ninput\nType of the refinement solver to be used by the IRS solver such as\ncusolverDnIRSXgesv()\nor\ncusolverDnIRSXgels()\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED\nThe\nParams\nstructure was not created.\nCUSOLVER_IRS_REFINE_NOT_SET\nSolver is not set, this value is what is set when creating the params structure. IRS solver will return an error.\nCUSOLVER_IRS_REFINE_NONE\nNo refinement solver; the IRS solver performs a factorization followed by a solve without any refinement. For example, if the IRS solver was\ncusolverDnIRSXgesv()\n, this is equivalent to a Xgesv routine without refinement and where the factorization is carried out in the lowest precision. If for example the main precision was CUSOLVER_R_64F and the lowest was CUSOLVER_R_64F as well, then this is equivalent to a call to\ncusolverDnDgesv()\n.\nCUSOLVER_IRS_REFINE_CLASSICAL\nClassical iterative refinement solver. Similar to the one used in LAPACK routines.\nCUSOLVER_IRS_REFINE_GMRES\nGMRES (Generalized Minimal Residual) based iterative refinement solver. In recent study, the GMRES method has drawn the scientific community attention for its ability to be used as refinement solver that outperforms the classical iterative refinement method. Based on our experimentation, we recommend this setting.\nCUSOLVER_IRS_REFINE_CLASSICAL_GMRES\nClassical iterative refinement solver that uses the GMRES (Generalized Minimal Residual) internally to solve the correction equation at each iteration. We call the\nclassical refinement iteration\nthe outer iteration while the\nGMRES\nis called inner iteration. Note that if the tolerance of the inner GMRES is set very low, let say to machine precision, then the outer\nclassical refinement iteration\nwill performs only one iteration and thus this option will behaves like\nCUSOLVER_IRS_REFINE_GMRES\n.\nCUSOLVER_IRS_REFINE_GMRES_GMRES\nSimilar to\nCUSOLVER_IRS_REFINE_CLASSICAL_GMRES\nwhich consists of classical refinement process that uses GMRES to solve the inner correction system, here it is a GMRES (Generalized Minimal Residual) based iterative refinement solver that uses another GMRES internally to solve the preconditioned system.\n2.4.1.37.\ncusolverDnIRSParamsSetTol()\n\ncusolverStatus_t\ncusolverDnIRSParamsSetTol\n(\ncusolverDnIRSParams_t\nparams\n,\ndouble\nval\n);\nThis function sets the tolerance for the refinement solver. By default it is such that all the RHS satisfy:\nRNRM\n<\nSQRT(N)*XNRM*ANRM*EPS*BWDMAX\nwhere\nRNRM is the infinity-norm of the residual\nXNRM is the infinity-norm of the solution\nANRM is the infinity-operator-norm of the matrix A\nEPS is the machine epsilon for the Inputs/Outputs datatype that matches LAPACK <X>LAMCH(‘Epsilon’)\nBWDMAX, the value BWDMAX is fixed to 1.0\nThe user can use this function to change the tolerance to a lower or higher value. Our goal is to give the user more control such a way he can investigate and control every detail of the IRS solver. Note that the tolerance value is always in\nreal double precision\nwhatever the Inputs/Outputs datatype is.\nParameter\nMemory\nIn/out\nMeaning\nparams\nhost\nin/out\nThe\ncusolverDnIRSParams_t\nParams\nstructure.\nval\nhost\ninput\nDouble precision real value to which the refinement tolerance will be set.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED\nThe\nParams\nstructure was not created.\n2.4.1.38.\ncusolverDnIRSParamsSetTolInner()\n\ncusolverStatus_t\ncusolverDnIRSParamsSetTolInner\n(\ncusolverDnIRSParams_t\nparams\n,\ndouble\nval\n);\nThis function sets the tolerance for the inner refinement solver when the refinement solver consists of two-levels solver (for example, CUSOLVER_IRS_REFINE_CLASSICAL_GMRES or CUSOLVER_IRS_REFINE_GMRES_GMRES cases). It is not referenced in case of one level refinement solver such as CUSOLVER_IRS_REFINE_CLASSICAL or CUSOLVER_IRS_REFINE_GMRES. It is set to 1e-4 by default. This function set the tolerance for the inner solver (e.g. the inner GMRES). For example, if the Refinement Solver was set to CUSOLVER_IRS_REFINE_CLASSICAL_GMRES, setting this tolerance mean that the inner GMRES solver will converge to that tolerance at each outer iteration of the classical refinement solver. Our goal is to give the user more control such a way he can investigate and control every detail of the IRS solver. Note the, the tolerance value is always in\nreal double precision\nwhatever the Inputs/Outputs datatype is.\nParameter\nMemory\nIn/out\nMeaning\nparams\nhost\nin/out\nThe\ncusolverDnIRSParams_t\nParams\nstructure.\nval\nhost\ninput\nDouble precision real value to which the tolerance of the inner refinement solver will be set.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED\nThe\nParams\nstructure was not created.\n2.4.1.39.\ncusolverDnIRSParamsSetMaxIters()\n\ncusolverStatus_t\ncusolverDnIRSParamsSetMaxIters\n(\ncusolverDnIRSParams_t\nparams\n,\nint\nmax_iters\n);\nThis function sets the total number of allowed refinement iterations after which the solver will stop. Total means any iteration which means the sum of the outer and the inner iterations (inner is meaningful when two-levels refinement solver is set). Default value is set to 50. Our goal is to give the user more control such a way he can investigate and control every detail of the IRS solver.\nParameter\nMemory\nIn/out\nMeaning\nparams\nhost\nin/out\nThe\ncusolverDnIRSParams_t\nParams\nstructure.\nmax_iters\nhost\ninput\nMaximum total number of iterations allowed for the refinement solver.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED\nThe\nParams\nstructure was not created.\n2.4.1.40.\ncusolverDnIRSParamsSetMaxItersInner()\n\ncusolverStatus_t\ncusolverDnIRSParamsSetMaxItersInner\n(\ncusolverDnIRSParams_t\nparams\n,\ncusolver_int_t\nmaxiters_inner\n);\nThis function sets the maximal number of iterations allowed for the inner refinement solver. It is not referenced in case of one level refinement solver such as CUSOLVER_IRS_REFINE_CLASSICAL or CUSOLVER_IRS_REFINE_GMRES. The inner refinement solver will stop after reaching either the inner tolerance or the MaxItersInner value. By default, it is set to 50. Note that this value could not be larger than the MaxIters since MaxIters is the total number of allowed iterations. Note that if the user calls\ncusolverDnIRSParamsSetMaxIters\nafter calling this function,\nSetMaxIters\nhas priority and will overwrite\nMaxItersInner\nto the minimum value of\n(MaxIters,\nMaxItersInner)\n.\nParameter\nMemory\nIn/out\nMeaning\nparams\nhost\nin/out\nThe\ncusolverDnIRSParams_t\nParams\nstructure\nmaxiters_inner\nhost\ninput\nMaximum number of allowed inner iterations for the inner refinement solver. Meaningful when the refinement solver is a two-levels solver such as CUSOLVER_IRS_REFINE_CLASSICAL_GMRES or CUSOLVER_IRS_REFINE_GMRES_GMRES. Value should be less or equal to\nMaxIters\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED\nThe\nParams\nstructure was not created.\nCUSOLVER_STATUS_IRS_PARAMS_INVALID\nIf the value was larger than\nMaxIters\n.\n2.4.1.41.\ncusolverDnIRSParamsEnableFallback()\n\ncusolverStatus_t\ncusolverDnIRSParamsEnableFallback\n(\ncusolverDnIRSParams_t\nparams\n);\nThis function enable the fallback to the main precision in case the Iterative Refinement Solver (IRS) failed to converge. In other term, if the IRS solver failed to converge, the solver will return a no convergence code (e.g.,\nniter\n< 0), but can either return the non-convergent solution as it is (e.g., disable fallback) or can fallback (e.g., enable fallback) to the main precision (which is the precision of the Inputs/Outputs data) and solve the problem from scratch returning the good solution. This is the behavior by default, and it will guarantee that the IRS solver always provide the good solution. This function is provided because we provided\ncusolverDnIRSParamsDisableFallback\nwhich allows the user to disable the fallback and thus this function allow the user to re-enable it.\nParameter\nMemory\nIn/out\nMeaning\nparams\nhost\nin/out\nThe\ncusolverDnIRSParams_t\nParams\nstructure\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED\nThe\nParams\nstructure was not created.\n2.4.1.42.\ncusolverDnIRSParamsDisableFallback()\n\ncusolverStatus_t\ncusolverDnIRSParamsDisableFallback\n(\ncusolverDnIRSParams_t\nparams\n);\nThis function disables the fallback to the main precision in case the Iterative Refinement Solver (IRS) failed to converge. In other term, if the IRS solver failed to converge, the solver will return a no convergence code (e.g.,\nniter\n< 0), but can either return the non-convergent solution as it is (e.g., disable fallback) or can fallback (e.g., enable fallback) to the main precision (which is the precision of the Inputs/Outputs data) and solve the problem from scratch returning the good solution. This function disables the fallback and the returned solution is whatever the refinement solver was able to reach before it returns. Disabling fallback does not guarantee that the solution is the good one. However, if users want to keep getting the solution of the lower precision in case the IRS did not converge after certain number of iterations, they need to disable the fallback. The user can re-enable it by calling\ncusolverDnIRSParamsEnableFallback\n.\nParameter\nMemory\nIn/out\nMeaning\nparams\nhost\nin/out\nThe\ncusolverDnIRSParams_t\nParams\nstructure\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED\nThe\nParams\nstructure was not created.\n2.4.1.43.\ncusolverDnIRSParamsGetMaxIters()\n\ncusolverStatus_t\ncusolverDnIRSParamsGetMaxIters\n(\ncusolverDnIRSParams_t\nparams\n,\ncusolver_int_t\n*\nmaxiters\n);\nThis function returns the current setting in the\nparams\nstructure for the maximal allowed number of iterations (for example, either the default\nMaxIters\n, or the one set by the user in case he set it using\ncusolverDnIRSParamsSetMaxIters\n). Note that this function returns the current setting in the\nparams\nconfiguration and not to be confused with the\ncusolverDnIRSInfosGetMaxIters\nwhich return the maximal allowed number of iterations for a particular call to an IRS solver. To be clearer, the\nparams\nstructure can be used for many calls to an IRS solver. A user can change the allowed\nMaxIters\nbetween calls while the\nInfos\nstructure in\ncusolverDnIRSInfosGetMaxIters\ncontains information about a particular call and cannot be reused for different calls, and thus,\ncusolverDnIRSInfosGetMaxIters\nreturns the allowed\nMaxIters\nfor that call.\nParameter\nMemory\nIn/out\nMeaning\nparams\nhost\nin\nThe\ncusolverDnIRSParams_t\nParams\nstructure.\nmaxiters\nhost\noutput\nThe maximal number of iterations that is currently set.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED\nThe\nParams\nstructure was not created.\n2.4.1.44.\ncusolverDnIRSInfosCreate()\n\ncusolverStatus_t\ncusolverDnIRSInfosCreate\n(\ncusolverDnIRSInfos_t\n*\ninfos\n)\nThis function creates and initializes the\nInfos\nstructure that will hold the refinement information of an Iterative Refinement Solver (IRS) call. Such information includes the total number of iterations that was needed to converge (\nNiters\n), the outer number of iterations (meaningful when two-levels preconditioner such as CUSOLVER_IRS_REFINE_CLASSICAL_GMRES is used ), the maximal number of iterations that was allowed for that call, and a pointer to the matrix of the convergence history residual norms. The\nInfos\nstructure needs to be created before a call to an IRS solver. The\nInfos\nstructure is valid for only one call to an IRS solver, since it holds info about that solve and thus each solve will requires its own\nInfos\nstructure.\nParameter\nMemory\nIn/out\nMeaning\ninfo\nhost\noutput\nPointer to the\ncusolverDnIRSInfos_t\nInfos\nstructure.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe structure was initialized successfully.\nCUSOLVER_STATUS_ALLOC_FAILED\nThe resources could not be allocated.\n2.4.1.45.\ncusolverDnIRSInfosDestroy()\n\ncusolverStatus_t\ncusolverDnIRSInfosDestroy\n(\ncusolverDnIRSInfos_t\ninfos\n);\nThis function destroys and releases any memory required by the\nInfos\nstructure. This function destroys all the information (for example, Niters performed, OuterNiters performed, residual history etc.) about a solver call; thus, this function should only be called after the user is finished with the information.\nParameter\nMemory\nIn/out\nMeaning\ninfo\nhost\nin/out\nThe\ncusolverDnIRSInfos_t\nInfos\nstructure.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe resources were released successfully.\nCUSOLVER_STATUS_IRS_INFOS_NOT_INITIALIZED\nThe\nInfos\nstructure was not created.\n2.4.1.46.\ncusolverDnIRSInfosGetMaxIters()\n\ncusolverStatus_t\ncusolverDnIRSInfosGetMaxIters\n(\ncusolverDnIRSInfos_t\ninfos\n,\ncusolver_int_t\n*\nmaxiters\n);\nThis function returns the maximal allowed number of iterations that was set for the corresponding call to the IRS solver. Note that this function returns the setting that was set when that call happened and is not to be confused with the\ncusolverDnIRSParamsGetMaxIters\nwhich returns the current setting in the\nparams\nconfiguration structure. To be clearer, the\nparams\nstructure can be used for many calls to an IRS solver. A user can change the allowed\nMaxIters\nbetween calls while the\nInfos\nstructure in\ncusolverDnIRSInfosGetMaxIters\ncontains information about a particular call and cannot be reused for different calls, thus\ncusolverDnIRSInfosGetMaxIters\nreturns the allowed\nMaxIters\nfor that call.\nParameter\nMemory\nIn/out\nMeaning\ninfos\nhost\nin\nThe\ncusolverDnIRSInfos_t\nInfos\nstructure.\nmaxiters\nhost\noutput\nThe maximal number of iterations that is currently set.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_IRS_INFOS_NOT_INITIALIZED\nThe\nInfos\nstructure was not created.\n2.4.1.47.\ncusolverDnIRSInfosGetNiters()\n\ncusolverStatus_t\ncusolverDnIRSInfosGetNiters\n(\ncusolverDnIRSInfos_t\ninfos\n,\ncusolver_int_t\n*\nniters\n);\nThis function returns the total number of iterations performed by the IRS solver. If it was negative, it means that the IRS solver did not converge and if the user did not disable the fallback to full precision, then the fallback to a full precision solution happened and solution is good. Please refer to the description of negative\nniters\nvalues in the corresponding IRS linear solver functions such as\ncusolverDnXgesv()\nor\ncusolverDnXgels()\n.\nParameter\nMemory\nIn/out\nMeaning\ninfos\nhost\nin\nThe\ncusolverDnIRSInfos_t\nInfos\nstructure.\nniters\nhost\noutput\nThe total number of iterations performed by the IRS solver.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_IRS_INFOS_NOT_INITIALIZED\nThe\nInfos\nstructure was not created.\n2.4.1.48.\ncusolverDnIRSInfosGetOuterNiters()\n\ncusolverStatus_t\ncusolverDnIRSInfosGetOuterNiters\n(\ncusolverDnIRSInfos_t\ninfos\n,\ncusolver_int_t\n*\nouter_niters\n);\nThis function returns the number of iterations performed by the outer refinement loop of the IRS solver. When the refinement solver consists of a one-level solver such as\nCUSOLVER_IRS_REFINE_CLASSICAL\nor\nCUSOLVER_IRS_REFINE_GMRES\n, it is the same as\nNiters\n. When the refinement solver consists of a two-levels solver such as\nCUSOLVER_IRS_REFINE_CLASSICAL_GMRES\nor\nCUSOLVER_IRS_REFINE_GMRES_GMRES\n, it is the number of iterations of the outer loop. Refer to the description of the\ncusolverIRSRefinement_t\nfor more details.\nParameter\nMemory\nIn/out\nMeaning\ninfos\nhost\nin\nThe\ncusolverDnIRSInfos_t\nInfos\nstructure.\nouter_niters\nhost\noutput\nThe number of iterations of the outer refinement loop of the IRS solver.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_IRS_INFOS_NOT_INITIALIZED\nThe\nInfos\nstructure was not created.\n2.4.1.49.\ncusolverDnIRSInfosRequestResidual()\n\ncusolverStatus_t\ncusolverDnIRSInfosRequestResidual\n(\ncusolverDnIRSInfos_t\ninfos\n);\nThis function tells the IRS solver to store the convergence history (residual norms) of the refinement phase in a matrix that can be accessed via a pointer returned by the\ncusolverDnIRSInfosGetResidualHistory()\nfunction.\nParameter\nMemory\nIn/out\nMeaning\ninfos\nhost\nin\nThe\ncusolverDnIRSInfos_t\nInfos\nstructure\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_IRS_INFOS_NOT_INITIALIZED\nThe\nInfos\nstructure was not created.\n2.4.1.50.\ncusolverDnIRSInfosGetResidualHistory()\n\ncusolverStatus_t\ncusolverDnIRSInfosGetResidualHistory\n(\ncusolverDnIRSInfos_t\ninfos\n,\nvoid\n**\nresidual_history\n);\nIf the user called\ncusolverDnIRSInfosRequestResidual()\nbefore the call to the IRS function, then the IRS solver will store the convergence history (residual norms) of the refinement phase in a matrix that can be accessed via a pointer returned by this function. The datatype of the residual norms depends on the input and output data type. If the Inputs/Outputs datatype is double precision real or complex (CUSOLVER_R_FP64 or CUSOLVER_C_FP64), this residual will be of type real double precision (FP64)\ndouble\n, otherwise if the Inputs/Outputs datatype is single precision real or complex (CUSOLVER_R_FP32 or CUSOLVER_C_FP32), this residual will be real single precision FP32\nfloat\n.\nThe residual history matrix consists of two columns (even for the multiple right-hand side case NRHS) of\nMaxIters+1\nrow, thus a matrix of size (\nMaxIters+1,2\n). Only the first\nOuterNiters+1\nrows contains the residual norms the other (e.g., OuterNiters+2:Maxiters+1) are garbage. On the first column, each row\n“i”\nspecify the total number of iterations happened till this outer iteration\n“i”\nand on the second columns the residual norm corresponding to this outer iteration\n“i”\n. Thus, the first row (e.g., outer iteration\n“0”\n) consists of the initial residual (e.g., the residual before the refinement loop start) then the consecutive rows are the residual obtained at each outer iteration of the refinement loop. Note, it only consists of the history of the outer loop.\nIf the refinement solver was\nCUSOLVER_IRS_REFINE_CLASSICAL\nor\nCUSOLVER_IRS_REFINE_GMRES\n, then OuterNiters=Niters (Niters is the total number of iterations performed) and there is Niters+1 rows of norms that correspond to the Niters outer iterations.\nIf the refinement solver was\nCUSOLVER_IRS_REFINE_CLASSICAL_GMRES\nor\nCUSOLVER_IRS_REFINE_GMRES_GMRES\n, then OuterNiters <= Niters corresponds to the outer iterations performed by the outer refinement loop. Thus, there is OuterNiters+1 residual norms where row\n“i”\ncorrespond to the outer iteration\n“i”\nand the first column specify the total number of iterations (outer and inner) that were performed till this step the second columns correspond to the residual norm at this step.\nFor example, let’s say the user specifies\nCUSOLVER_IRS_REFINE_CLASSICAL_GMRES\nas a refinement solver and say it needed 3 outer iterations to converge and 4,3,3 inner iterations at each outer, respectively. This consists of 10 total iterations. Row 0 corresponds to the first residual before the refinement start, so it has 0 in its first column. On row 1 which corresponds to the outer iteration 1, it will be 4 (4 is the total number of iterations that were performed till now), on row 2 it will be 7, and on row 3 it will be 10.\nIn summary, let’s define\nldh=Maxiters+1\n, the leading dimension of the residual matrix. then\nresidual_history[i]\nshows the total number of iterations performed at the outer iteration\n“i”\nand\nresidual_history[i+ldh]\ncorresponds to the norm of the residual at this outer iteration.\nParameter\nMemory\nIn/out\nMeaning\ninfos\nhost\nin\nThe\ncusolverDnIRSInfos_t\nInfos\nstructure.\nresidual_history\nhost\noutput\nReturns a void pointer to the matrix of the convergence history residual norms. See the description above for the relation between the residual norm datatype and the inout datatype.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_IRS_INFOS_NOT_INITIALIZED\nThe\nInfos\nstructure was not created\nCUSOLVER_STATUS_INVALID_VALUE\nThis function was called without calling\ncusolverDnIRSInfosRequestResidual()\nin advance.\n2.4.1.51.\ncusolverDnCreateParams()\n\ncusolverStatus_t\ncusolverDnCreateParams\n(\ncusolverDnParams_t\n*\nparams\n);\nThis function creates and initializes the structure of\n64-bit\nAPI\nto default values.\nParameter\nMemory\nIn/out\nMeaning\nparams\nhost\noutput\nThe pointer to the structure of\n64-bit\nAPI\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe structure was initialized successfully.\nCUSOLVER_STATUS_ALLOC_FAILED\nThe resources could not be allocated.\n2.4.1.52.\ncusolverDnDestroyParams()\n\ncusolverStatus_t\ncusolverDnDestroyParams\n(\ncusolverDnParams_t\nparams\n);\nThis function destroys and releases any memory required by the structure.\nParameter\nMemory\nIn/out\nMeaning\nparams\nhost\ninput\nThe structure of\n64-bit\nAPI\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe resources were released successfully.\n2.4.1.53.\ncusolverDnSetAdvOptions()\n\ncusolverStatus_t\ncusolverDnSetAdvOptions\n(\ncusolverDnParams_t\nparams\n,\ncusolverDnFunction_t\nfunction\n,\ncusolverAlgMode_t\nalgo\n);\nThis function configures algorithm\nalgo\nof\nfunction\n, a\n64-bit\nAPI\nroutine.\nParameter\nMemory\nIn/out\nMeaning\nparams\nhost\nin/out\nThe pointer to the structure of\n64-bit\nAPI\n.\nfunction\nhost\ninput\nThe routine to be configured.\nalgo\nhost\ninput\nThe algorithm to be configured.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_INVALID_VALUE\nWrong combination of\nfunction\nand\nalgo\n.\n2.4.2.\nDense Linear Solver Reference (legacy)\n\nThis section describes linear solver API of cuSolverDN, including Cholesky factorization, LU with partial pivoting, QR factorization and Bunch-Kaufman (LDLT) factorization.\n2.4.2.1.\ncusolverDn<t>potrf()\n\nThese helper functions calculate the necessary size of work buffers.\ncusolverStatus_t\ncusolverDnSpotrf_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nint\n*\nLwork\n);\ncusolverStatus_t\ncusolverDnDpotrf_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\nint\n*\nLwork\n);\ncusolverStatus_t\ncusolverDnCpotrf_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\nint\n*\nLwork\n);\ncusolverStatus_t\ncusolverDnZpotrf_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nint\n*\nLwork\n);\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnSpotrf\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\n*\nWorkspace\n,\nint\nLwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnDpotrf\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\n*\nWorkspace\n,\nint\nLwork\n,\nint\n*\ndevInfo\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnCpotrf\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\ncuComplex\n*\nWorkspace\n,\nint\nLwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnZpotrf\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ncuDoubleComplex\n*\nWorkspace\n,\nint\nLwork\n,\nint\n*\ndevInfo\n);\nThis function computes the Cholesky factorization of a Hermitian positive-definite matrix.\nA\nis an\n\\(n \\times n\\)\nHermitian matrix, only the lower or upper part is meaningful. The input parameter\nuplo\nindicates which part of the matrix is used. The function will leave the other part untouched.\nIf input parameter\nuplo\nis\nCUBLAS_FILL_MODE_LOWER\n, only the lower triangular part of\nA\nis processed, and replaced by the lower triangular Cholesky factor\nL\n.\n\\[A = L*L^{H}\\]\nIf input parameter\nuplo\nis\nCUBLAS_FILL_MODE_UPPER\n, only upper triangular part of\nA\nis processed, and replaced by upper triangular Cholesky factor\nU\n.\n\\[A = U^{H}*U\\]\nThe user has to provide working space which is pointed by input parameter\nWorkspace\n. The input parameter\nLwork\nis size of the working space, and it is returned by\npotrf_bufferSize()\n.\nIf Cholesky factorization failed, i.e. some leading minor of\nA\nis not positive definite, or equivalently some diagonal elements of\nL\nor\nU\nis not a real number. The output parameter\ndevInfo\nwould indicate smallest leading minor of\nA\nwhich is not positive definite.\nIf output parameter\ndevInfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nAPI of potrf\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nuplo\nhost\ninput\nIndicates if matrix\nA\nlower or upper part is stored; the other part is not referenced.\nn\nhost\ninput\nNumber of rows and columns of matrix\nA\n.\nA\ndevice\nin/out\n<type> array of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,n)\n.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nWorkspace\ndevice\nin/out\nWorking space, <type> array of size\nLwork\n.\nLwork\nhost\ninput\nSize of\nWorkspace\n, returned by\npotrf_bufferSize\n.\ndevInfo\ndevice\noutput\nIf\ndevInfo\n=\n0\n, the Cholesky factorization is successful. if\ndevInfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle). if\ndevInfo\n=\ni\n, the leading minor of order i is not positive definite.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\nor\nlda<max(1,n)\n).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.2.2.\ncusolverDn<t>potrs()\n\ncusolverStatus_t\ncusolverDnSpotrs\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nint\nnrhs\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\n*\nB\n,\nint\nldb\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnDpotrs\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nint\nnrhs\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\n*\nB\n,\nint\nldb\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnCpotrs\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nint\nnrhs\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\ncuComplex\n*\nB\n,\nint\nldb\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnZpotrs\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nint\nnrhs\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\nint\n*\ndevInfo\n);\nThis function solves a system of linear equations\n\\[A*X = B\\]\nwhere\nA\nis an\n\\(n \\times n\\)\nHermitian matrix, only lower or upper part is meaningful. The input parameter\nuplo\nindicates which part of the matrix is used. The function will leave the other part untouched.\nThe user has to call\npotrf\nfirst to factorize matrix\nA\n. If input parameter\nuplo\nis\nCUBLAS_FILL_MODE_LOWER\n,\nA\nis lower triangular Cholesky factor\nL\ncorresponding to\n\\(A = L*L^H\\)\n. If input parameter\nuplo\nis\nCUBLAS_FILL_MODE_UPPER\n,\nA\nis upper triangular Cholesky factor\nU\ncorresponding to\n\\(A = U^{H}*U\\)\n.\nThe operation is in-place, i.e. matrix\nX\noverwrites matrix\nB\nwith the same leading dimension\nldb\n.\nIf output parameter\ndevInfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nAPI of potrs\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nuplo\nhost\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other part is not referenced.\nn\nhost\ninput\nNumber of rows and columns of matrix\nA\n.\nnrhs\nhost\ninput\nNumber of columns of matrix\nX\nand\nB\n.\nA\ndevice\ninput\n<type> array of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,n)\n.\nA\nis either lower Cholesky factor\nL\nor upper Cholesky factor\nU\n.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nB\ndevice\nin/out\n<type> array of dimension\nldb\n*\nnrhs\n.\nldb\nis not less than\nmax(1,n)\n. As an input,\nB\nis right hand side matrix. As an output,\nB\nis the solution matrix.\ndevInfo\ndevice\noutput\nIf\ndevInfo\n=\n0\n, the Cholesky factorization is successful. if\ndevInfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle).\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\n,\nnrhs<0\n,\nlda<max(1,n)\nor\nldb<max(1,n)\n).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.2.3.\ncusolverDn<t>potri()\n\nThese helper functions calculate the necessary size of work buffers.\ncusolverStatus_t\ncusolverDnSpotri_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nint\n*\nLwork\n);\ncusolverStatus_t\ncusolverDnDpotri_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\nint\n*\nLwork\n);\ncusolverStatus_t\ncusolverDnCpotri_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\nint\n*\nLwork\n);\ncusolverStatus_t\ncusolverDnZpotri_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nint\n*\nLwork\n);\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnSpotri\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\n*\nWorkspace\n,\nint\nLwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnDpotri\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\n*\nWorkspace\n,\nint\nLwork\n,\nint\n*\ndevInfo\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnCpotri\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\ncuComplex\n*\nWorkspace\n,\nint\nLwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnZpotri\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ncuDoubleComplex\n*\nWorkspace\n,\nint\nLwork\n,\nint\n*\ndevInfo\n);\nThis function computes the inverse of a positive-definite matrix\nA\nusing the Cholesky factorization\n\\[A = L*L^H = U^{H}*U\\]\ncomputed by\npotrf()\n.\nA\nis an\n\\(n \\times n\\)\nmatrix containing the triangular factor\nL\nor\nU\ncomputed by the Cholesky factorization. Only lower or upper part is meaningful and the input parameter\nuplo\nindicates which part of the matrix is used. The function would leave the other part untouched.\nIf the input parameter\nuplo\nis\nCUBLAS_FILL_MODE_LOWER\n, only lower triangular part of\nA\nis processed, and replaced the by lower triangular part of the inverse of\nA\n.\nIf the input parameter\nuplo\nis\nCUBLAS_FILL_MODE_UPPER\n, only upper triangular part of\nA\nis processed, and replaced by the upper triangular part of the inverse of\nA\n.\nThe user has to provide the working space which is pointed to by input parameter\nWorkspace\n. The input parameter\nLwork\nis the size of the working space, returned by\npotri_bufferSize()\n.\nIf the computation of the inverse fails, i.e. some leading minor of\nL\nor\nU\n, is null, the output parameter\ndevInfo\nwould indicate the smallest leading minor of\nL\nor\nU\nwhich is not positive definite.\nIf the output parameter\ndevInfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting the handle).\nAPI of potri\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nuplo\nhost\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other part is not referenced.\nn\nhost\ninput\nNumber of rows and columns of matrix\nA\n.\nA\ndevice\nin/out\n<type> array of dimension\nlda\n*\nn\nwhere\nlda\nis not less than\nmax(1,n)\n.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nWorkspace\ndevice\nin/out\nWorking space, <type> array of size\nLwork\n.\nLwork\nhost\ninput\nSize of\nWorkspace\n, returned by\npotri_bufferSize\n.\ndevInfo\ndevice\noutput\nIf\ndevInfo\n=\n0\n, the computation of the inverse is successful. if\ndevInfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle). if\ndevInfo\n=\ni\n, the leading minor of order\ni\nis zero.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\nor\nlda<max(1,n)\n).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.2.4.\ncusolverDn<t>getrf()\n\nThese helper functions calculate the size of work buffers needed.\nPlease visit\ncuSOLVER Library Samples - getrf\nfor a code example.\ncusolverStatus_t\ncusolverDnSgetrf_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nint\n*\nLwork\n);\ncusolverStatus_t\ncusolverDnDgetrf_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\nint\n*\nLwork\n);\ncusolverStatus_t\ncusolverDnCgetrf_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\nint\n*\nLwork\n);\ncusolverStatus_t\ncusolverDnZgetrf_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nint\n*\nLwork\n);\nThe S and D data types are real single and double precision, respectively.\ncusolverStatus_t\ncusolverDnSgetrf\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\n*\nWorkspace\n,\nint\n*\ndevIpiv\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnDgetrf\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\n*\nWorkspace\n,\nint\n*\ndevIpiv\n,\nint\n*\ndevInfo\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnCgetrf\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\ncuComplex\n*\nWorkspace\n,\nint\n*\ndevIpiv\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnZgetrf\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ncuDoubleComplex\n*\nWorkspace\n,\nint\n*\ndevIpiv\n,\nint\n*\ndevInfo\n);\nThis function computes the LU factorization of an\n\\(m \\times n\\)\nmatrix\n\\[P*A = L*U\\]\nwhere\nA\nis an\n\\(m \\times n\\)\nmatrix,\nP\nis a permutation matrix,\nL\nis a lower triangular matrix with unit diagonal, and\nU\nis an upper triangular matrix.\nThe user has to provide working space which is pointed by input parameter\nWorkspace\n. The input parameter\nLwork\nis size of the working space, and it is returned by\ngetrf_bufferSize()\n.\nIf LU factorization failed, i.e. matrix\nA\n(\nU\n) is singular, The output parameter\ndevInfo=i\nindicates\nU(i,i)\n=\n0\n.\nIf output parameter\ndevInfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nIf\ndevIpiv\nis null, no pivoting is performed. The factorization is\nA=L*U\n, which is not numerically stable.\nNo matter LU factorization failed or not, the output parameter\ndevIpiv\ncontains pivoting sequence, row\ni\nis interchanged with row\ndevIpiv(i)\n.\nThe user can combine\ngetrf\nand\ngetrs\nto complete a linear solver.\nRemark:\ngetrf\nuses fastest implementation with large workspace of size\nm*n\n. The user can choose the legacy implementation with minimal workspace by\nGetrf\nand\ncusolverDnSetAdvOptions(params,\nCUSOLVERDN_GETRF,\nCUSOLVER_ALG_1)\n.\nAPI of getrf\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nm\nhost\ninput\nNumber of rows of matrix\nA\n.\nn\nhost\ninput\nNumber of columns of matrix\nA\n.\nA\ndevice\nin/out\n<type> array of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,m)\n.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nWorkspace\ndevice\nin/out\nWorking space, <type> array of size\nLwork\n.\ndevIpiv\ndevice\noutput\nArray of size at least\nmin(m,n)\n, containing pivot indices.\ndevInfo\ndevice\noutput\nIf\ndevInfo\n=\n0\n, the LU factorization is successful. if\ndevInfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle). if\ndevInfo\n=\ni\n, the\nU(i,i)\n=\n0\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,n<0\nor\nlda<max(1,m)\n).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.2.5.\ncusolverDn<t>getrs()\n\nPlease visit\ncuSOLVER Library Samples - getrf\nfor a code example.\ncusolverStatus_t\ncusolverDnSgetrs\n(\ncusolverDnHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nnrhs\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nint\n*\ndevIpiv\n,\nfloat\n*\nB\n,\nint\nldb\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnDgetrs\n(\ncusolverDnHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nnrhs\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\nint\n*\ndevIpiv\n,\ndouble\n*\nB\n,\nint\nldb\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnCgetrs\n(\ncusolverDnHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nnrhs\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\nint\n*\ndevIpiv\n,\ncuComplex\n*\nB\n,\nint\nldb\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnZgetrs\n(\ncusolverDnHandle_t\nhandle\n,\ncublasOperation_t\ntrans\n,\nint\nn\n,\nint\nnrhs\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\nint\n*\ndevIpiv\n,\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\nint\n*\ndevInfo\n);\nThis function solves a linear system of multiple right-hand sides\n\\[op(A)*X = B\\]\nwhere\nA\nis an\n\\(n \\times n\\)\nmatrix, and was LU-factored by\ngetrf\n, that is, lower triangular part of A is\nL\n, and upper triangular part (including diagonal elements) of\nA\nis\nU\n.\nB\nis an\n\\(n\\times {nrhs}\\)\nright-hand side matrix.\nThe input parameter\ntrans\nis defined by\nThe input parameter\ndevIpiv\nis an output of\ngetrf\n. It contains pivot indices, which are used to permutate right-hand sides.\nIf output parameter\ndevInfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nThe user can combine\ngetrf\nand\ngetrs\nto complete a linear solver.\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\ntrans\nhost\ninput\nOperation\nop(A)\nthat is non- or (conj.) transpose.\nn\nhost\ninput\nNumber of rows and columns of matrix\nA\n.\nnrhs\nhost\ninput\nNumber of right-hand sides.\nA\ndevice\ninput\n<type> array of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,n)\n.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\ndevIpiv\ndevice\ninput\nArray of size at least\nn\n, containing pivot indices.\nB\ndevice\noutput\n<type> array of dimension\nldb\n*\nnrhs\nwith\nldb\nis not less than\nmax(1,n)\n.\nldb\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nB\n.\ndevInfo\ndevice\noutput\nIf\ndevInfo\n=\n0\n, the operation is successful. if\ndevInfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle).\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\nor\nlda<max(1,n)\nor\nldb<max(1,n)\n).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.2.6.\ncusolverDn<t1><t2>gesv()\n\nThese functions are modelled after functions DSGESV and ZCGESV from LAPACK. They compute the solution of a system of linear equations with one or multiple right hand sides using mixed precision iterative refinement techniques based on the LU factorization\nXgesv\n. These functions are similar in term of functionalities to the full precision LU solver (\nXgesv\n, where X denotes Z,C,D,S) but it uses lower precision internally in order to provide faster time to solution, from here comes the name mixed precision. Mixed precision iterative refinement techniques means that the solver compute an LU factorization in lower precision and then iteratively refine the solution to achieve the accuracy of the Inputs/Outputs datatype precision. The <t1> corresponds to the Inputs/Outputs datatype precision while <t2> represent the internal lower precision at which the factorization will be carried on.\n\\[A \\times X = B\\]\nWhere\nA\nis\nn-by-n\nmatrix and\nX\nand\nB\nare\nn-by-nrhs\nmatrices.\nFunctions API are designed to be as close as possible to LAPACK API to be considered as a quick and easy drop-in replacement. Parameters and behavior are mostly the same as LAPACK counterparts. Description of these functions and differences from LAPACK is given below.\n<t1><t2>gesv()\nfunctions are designated by two floating point precisions The <t1> corresponds to the main precision (e.g., Inputs/Outputs datatype precision) and the <t2> represent the internal lower precision at which the factorization will be carried on.\ncusolver<t1><t2>gesv()\nfirst attempts to factorize the matrix in lower precision and use this factorization within an iterative refinement procedure to obtain a solution with same normwise backward error as the main precision <t1>. If the approach fails to converge, then the method fallback to the main precision factorization and solve (Xgesv) such a way that there is always a good solution at the output of these functions. If <t2> is equal to <t1>, then it is not a mixed precision process but rather a full one precision factorization, solve and refinement within the same main precision.\nThe iterative refinement process is stopped if\nITER\n>\nITERMAX\nor for all the RHS we have:\nRNRM\n<\nSQRT(N)*XNRM*ANRM*EPS*BWDMAX\nwhere\nITER is the number of the current iteration in the iterative refinement process\nRNRM is the infinity-norm of the residual\nXNRM is the infinity-norm of the solution\nANRM is the infinity-operator-norm of the matrix A\nEPS is the machine epsilon that matches LAPACK <t1>LAMCH(‘Epsilon’)\nThe value ITERMAX and BWDMAX are fixed to 50 and 1.0 respectively.\nThe function returns value describes the results of the solving process. A\nCUSOLVER_STATUS_SUCCESS\nindicates that the function finished with success otherwise, it indicates if one of the API arguments is incorrect, or if the function did not finish with success. More details about the error will be in the\nniters\nand the\ndinfo\nAPI parameters. See their description below for more details. User should provide the required workspace allocated on device memory. The amount of bytes required can be queried by calling the respective function\n<t1><t2>gesv_bufferSize()\n.\nNote that in addition to the two mixed precision functions available in LAPACK (for example,\ndsgesv\nand\nzcgesv\n), we provide a large set of mixed precision functions that include half, bfloat and tensorfloat as a lower precision as well as same precision functions (, main and lowest precision are equal <t2> is equal to <t1>). The following table specifies which precisions will be used for which interface function.\nTensor Float (TF32), introduced with NVIDIA Ampere Architecture GPUs, is the most robust tensor core accelerated compute mode for the iterative refinement solver. It is able to solve the widest range of problems in HPC arising from different applications and provides up to 4X and 5X speedup for real and complex systems, respectively. On Volta and Turing architecture GPUs, half precision tensor core acceleration is recommended. In cases where the iterative refinement solver fails to converge to the desired accuracy (main precision, INOUT data precision), it is recommended to use main precision as internal lowest precision (i.e.,\ncusolverDn[DD,ZZ]gesv\nfor the FP64 case).\nSupported combinations of floating point precisions for cusolver <t1><t2>gesv() functions\n\nInterface function\nMain precision\n(matrix, rhs and solution datatype)\nLowest precision allowed\nto be used internally\ncusolverDnZZgesv\ncuDoubleComplex\ndouble\ncomplex\ncusolverDnZCgesv\n*\ncuDoubleComplex\nsingle\ncomplex\ncusolverDnZKgesv\ncuDoubleComplex\nhalf\ncomplex\ncusolverDnZEgesv\ncuDoubleComplex\nbfloat\ncomplex\ncusolverDnZYgesv\ncuDoubleComplex\ntensorfloat\ncomplex\ncusolverDnCCgesv\ncuComplex\nsingle\ncomplex\ncusolverDnCKgesv\ncuComplex\nhalf\ncomplex\ncusolverDnCEgesv\ncuComplex\nbfloat\ncomplex\ncusolverDnCYgesv\ncuComplex\ntensorfloat\ncomplex\ncusolverDnDDgesv\ndouble\ndouble\ncusolverDnDSgesv\n*\ndouble\nsingle\ncusolverDnDHgesv\ndouble\nhalf\ncusolverDnDBgesv\ndouble\nbfloat\ncusolverDnDXgesv\ndouble\ntensorfloat\ncusolverDnSSgesv\nfloat\nsingle\ncusolverDnSHgesv\nfloat\nhalf\ncusolverDnSBgesv\nfloat\nbfloat\ncusolverDnSXgesv\nfloat\ntensorfloat\n* Has LAPACK counterparts\ncusolverDn<t1><t2>gesv_bufferSize()\nfunctions will return workspace buffer size in bytes required for the corresponding\ncusolverDn<t1><t2>gesv()\nfunction.\ncusolverStatus_t\ncusolverDnZZgesv_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ncuDoubleComplex\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ncuDoubleComplex\n*\ndB\n,\nint\nlddb\n,\ncuDoubleComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnZCgesv_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ncuDoubleComplex\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ncuDoubleComplex\n*\ndB\n,\nint\nlddb\n,\ncuDoubleComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnZKgesv_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ncuDoubleComplex\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ncuDoubleComplex\n*\ndB\n,\nint\nlddb\n,\ncuDoubleComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnZEgesv_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ncuDoubleComplex\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ncuDoubleComplex\n*\ndB\n,\nint\nlddb\n,\ncuDoubleComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnZYgesv_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ncuDoubleComplex\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ncuDoubleComplex\n*\ndB\n,\nint\nlddb\n,\ncuDoubleComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnCCgesv_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ncuComplex\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ncuComplex\n*\ndB\n,\nint\nlddb\n,\ncuComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnCKgesv_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ncuComplex\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ncuComplex\n*\ndB\n,\nint\nlddb\n,\ncuComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnCEgesv_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ncuComplex\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ncuComplex\n*\ndB\n,\nint\nlddb\n,\ncuComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnCYgesv_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ncuComplex\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ncuComplex\n*\ndB\n,\nint\nlddb\n,\ncuComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnDDgesv_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ndouble\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ndouble\n*\ndB\n,\nint\nlddb\n,\ndouble\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnDSgesv_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ndouble\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ndouble\n*\ndB\n,\nint\nlddb\n,\ndouble\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnDHgesv_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ndouble\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ndouble\n*\ndB\n,\nint\nlddb\n,\ndouble\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnDBgesv_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ndouble\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ndouble\n*\ndB\n,\nint\nlddb\n,\ndouble\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnDXgesv_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ndouble\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ndouble\n*\ndB\n,\nint\nlddb\n,\ndouble\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnSSgesv_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\nfloat\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\nfloat\n*\ndB\n,\nint\nlddb\n,\nfloat\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnSHgesv_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\nfloat\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\nfloat\n*\ndB\n,\nint\nlddb\n,\nfloat\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnSBgesv_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\nfloat\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\nfloat\n*\ndB\n,\nint\nlddb\n,\nfloat\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnSXgesv_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\nfloat\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\nfloat\n*\ndB\n,\nint\nlddb\n,\nfloat\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\nParameters of cusolverDn<T1><T2>gesv_bufferSize() functions\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cusolverDN library context.\nn\nhost\ninput\nNumber of rows and columns of square matrix\nA\n. Should be non-negative.\nnrhs\nhost\ninput\nNumber of right hand sides to solve. Should be non-negative.\ndA\ndevice\nNone\nMatrix\nA\nwith size\nn-by-n\n. Can be\nNULL\n.\nldda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nlda\n>=\nn\n.\ndipiv\ndevice\nNone\nPivoting sequence. Not used and can be\nNULL\n.\ndB\ndevice\nNone\nSet of right hand sides\nB\nof size\nn-by-nrhs\n. Can be\nNULL\n.\nlddb\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix of right hand sides\nB\n.\nldb\n>=\nn\n.\ndX\ndevice\nNone\nSet of solution vectors\nX\nof size\nn-by-nrhs\n. Can be\nNULL\n.\nlddx\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix of solution vectors\nX\n.\nldx\n>=\nn\n.\ndwork\ndevice\nnone\nPointer to device workspace. Not used and can be\nNULL\n.\nlwork_bytes\nhost\noutput\nPointer to a variable where required size of temporary workspace in bytes will be stored. Can’t be NULL.\ncusolverStatus_t\ncusolverDnZZgesv\n(\ncusolverDnHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ncuDoubleComplex\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ncuDoubleComplex\n*\ndB\n,\nint\nlddb\n,\ncuDoubleComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnZCgesv\n(\ncusolverDnHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ncuDoubleComplex\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ncuDoubleComplex\n*\ndB\n,\nint\nlddb\n,\ncuDoubleComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnZKgesv\n(\ncusolverDnHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ncuDoubleComplex\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ncuDoubleComplex\n*\ndB\n,\nint\nlddb\n,\ncuDoubleComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnZEgesv\n(\ncusolverDnHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ncuDoubleComplex\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ncuDoubleComplex\n*\ndB\n,\nint\nlddb\n,\ncuDoubleComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnZYgesv\n(\ncusolverDnHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ncuDoubleComplex\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ncuDoubleComplex\n*\ndB\n,\nint\nlddb\n,\ncuDoubleComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnCCgesv\n(\ncusolverDnHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ncuComplex\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ncuComplex\n*\ndB\n,\nint\nlddb\n,\ncuComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnCKgesv\n(\ncusolverDnHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ncuComplex\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ncuComplex\n*\ndB\n,\nint\nlddb\n,\ncuComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnCEgesv\n(\ncusolverDnHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ncuComplex\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ncuComplex\n*\ndB\n,\nint\nlddb\n,\ncuComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnCYgesv\n(\ncusolverDnHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ncuComplex\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ncuComplex\n*\ndB\n,\nint\nlddb\n,\ncuComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnDDgesv\n(\ncusolverDnHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ndouble\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ndouble\n*\ndB\n,\nint\nlddb\n,\ndouble\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnDSgesv\n(\ncusolverDnHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ndouble\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ndouble\n*\ndB\n,\nint\nlddb\n,\ndouble\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnDHgesv\n(\ncusolverDnHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ndouble\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ndouble\n*\ndB\n,\nint\nlddb\n,\ndouble\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnDBgesv\n(\ncusolverDnHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ndouble\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ndouble\n*\ndB\n,\nint\nlddb\n,\ndouble\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnDXgesv\n(\ncusolverDnHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\ndouble\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\ndouble\n*\ndB\n,\nint\nlddb\n,\ndouble\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnSSgesv\n(\ncusolverDnHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\nfloat\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\nfloat\n*\ndB\n,\nint\nlddb\n,\nfloat\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnSHgesv\n(\ncusolverDnHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\nfloat\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\nfloat\n*\ndB\n,\nint\nlddb\n,\nfloat\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnSBgesv\n(\ncusolverDnHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\nfloat\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\nfloat\n*\ndB\n,\nint\nlddb\n,\nfloat\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnSXgesv\n(\ncusolverDnHandle_t\nhandle\n,\nint\nn\n,\nint\nnrhs\n,\nfloat\n*\ndA\n,\nint\nldda\n,\nint\n*\ndipiv\n,\nfloat\n*\ndB\n,\nint\nlddb\n,\nfloat\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\nParameters of cusolverDn<T1><T2>gesv() functions\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cusolverDN library context.\nn\nhost\ninput\nNumber of rows and columns of square matrix\nA\n. Should be non-negative.\nnrhs\nhost\ninput\nNumber of right hand sides to solve. Should be non-negative.\ndA\ndevice\nin/out\nMatrix\nA\nwith size\nn-by-n\n. Can’t be\nNULL\n. On return - unchanged if the iterative refinement process converged. If not - will contains the factorization of the matrix A in the main precision <T1> (\nA\n=\nP\n*\nL\n*\nU\n, where P - permutation matrix defined by vector ipiv, L and U - lower and upper triangular matrices).\nldda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nlda\n>=\nn\n.\ndipiv\ndevice\noutput\nVector that defines permutation for the factorization - row\ni\nwas interchanged with row\nipiv[i]\ndB\ndevice\ninput\nSet of right hand sides\nB\nof size\nn-by-nrhs\n. Can’t be\nNULL\n.\nlddb\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix of right hand sides\nB\n.\nldb\n>=\nn\n.\ndX\ndevice\noutput\nSet of solution vectors\nX\nof size\nn-by-nrhs\n. Can’t be\nNULL\n.\nlddx\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix of solution vectors\nX\n.\nldx\n>=\nn\n.\ndWorkspace\ndevice\ninput\nPointer to an allocated workspace in device memory of size\nlwork_bytes\n.\nlwork_bytes\nhost\ninput\nSize of the allocated device workspace. Should be at least what was returned by\ncusolverDn<T1><T2>gesv_bufferSize()\nfunction.\nniters\nhost\noutput\nIf\niter\nis\n<0 : iterative refinement has failed, main precision (Inputs/Outputs precision) factorization has been performed\n-1 : taking into account machine parameters, n, nrhs, it is a priori not worth working in lower precision\n-2 : overflow of an entry when moving from main to lower precision\n-3 : failure during the factorization\n-5 : overflow occurred during computation\n-50: solver stopped the iterative refinement after reaching maximum allowed iterations\n>0 : iter is a number of iterations solver performed to reach convergence criteria\ndinfo\ndevice\noutput\nStatus of the IRS solver on the return. If 0 - solve was successful. If\ndinfo\n= -\ni\nthen\ni\n-th argument is not valid. If\ndinfo\n=\ni\n, then\nU(i,i)\ncomputed in main precision is exactly zero. The factorization has been completed, but the factor U is exactly singular, so the solution could not be computed.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed, for example:\nn<0\nlda<max(1,n)\nldb<max(1,n)\nldx<max(1,n)\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe IRS solver supports compute capability 7.0 and above. The lowest precision options CUSOLVER_[CR]_16BF and CUSOLVER_[CR]_TF32 are only available on compute capability 8.0 and above.\nCUSOLVER_STATUS_INVALID_WORKSPACE\nlwork_bytes\nis smaller than the required workspace.\nCUSOLVER_STATUS_IRS_OUT_OF_RANGE\nNumerical error related to niters <0, see\nniters\ndescription for more details.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal error occurred, check the\ndinfo\nand the\nniters\narguments for more details.\n2.4.2.7.\ncusolverDnIRSXgesv()\n\nThis function is designed to perform same functionality as\ncusolverDn<T1><T2>gesv()\nfunctions, but wrapped in a more generic and expert interface that gives user more control to parametrize the function as well as it provides more information on output.\ncusolverDnIRSXgesv()\nallows additional control of the solver parameters such as setting:\nthe main precision (Inputs/Outputs precision) of the solver\nthe lowest precision to be used internally by the solver\nthe refinement solver type\nthe maximum allowed number of iterations in the refinement phase\nthe tolerance of the refinement solver\nthe fallback to main precision\nand more\nthrough the configuration parameters structure\ngesv_irs_params\nand its helper functions. For more details about what configuration can be set and its meaning please refer to all the functions in the cuSolverDN Helper Function Section that start with\ncusolverDnIRSParamsxxxx()\n. Moreover,\ncusolverDnIRSXgesv()\nprovides additional information on the output such as the convergence history (e.g., the residual norms) at each iteration and the number of iterations needed to converge. For more details about what information can be retrieved and its meaning please refer to all the functions in the cuSolverDN Helper Function Section that start with\ncusolverDnIRSInfosxxxx()\nThe function returns value describes the results of the solving process. A CUSOLVER_STATUS_SUCCESS indicates that the function finished with success otherwise, it indicates if one of the API arguments is incorrect, or if the configurations of params/infos structure is incorrect or if the function did not finish with success. More details about the error can be found by checking the\nniters\nand the\ndinfo\nAPI parameters. See their description below for further details. User should provide the required workspace allocated on device for the\ncusolverDnIRSXgesv()\nfunction. The amount of bytes required for the function can be queried by calling the respective function\ncusolverDnIRSXgesv_bufferSize()\n. Note that, if the user would like a particular configuration to be set via the params structure, it should be set before the call to\ncusolverDnIRSXgesv_bufferSize()\nto get the size of the required workspace.\nTensor Float (TF32), introduced with NVIDIA Ampere architecture GPUs, is the most robust tensor core accelerated compute mode for the iterative refinement solver. It is able to solve the widest range of problems in HPC arising from different applications and provides up to 4X and 5X speedup for real and complex systems, respectively. On Volta and Turing architecture GPUs, half precision tensor core acceleration is recommended. In cases where the iterative refinement solver fails to converge to the desired accuracy (main precision, INOUT data precision), it is recommended to use main precision as internal lowest precision.\nThe following table provides all possible combinations values for the lowest precision corresponding to the Inputs/Outputs data type. Note that if the lowest precision matches the Inputs/Outputs datatype, then the main precision factorization will be used.\nSupported Inputs/Outputs data type and lower precision for the IRS solver\n\nInputs/Outputs Data Type (e.g., main precision)\nSupported values for the lowest precision\nCUSOLVER_C_64F\nCUSOLVER_C_64F,\nCUSOLVER_C_32F,\nCUSOLVER_C_16F,\nCUSOLVER_C_16BF,\nCUSOLVER_C_TF32\nCUSOLVER_C_32F\nCUSOLVER_C_32F,\nCUSOLVER_C_16F,\nCUSOLVER_C_16BF,\nCUSOLVER_C_TF32\nCUSOLVER_R_64F\nCUSOLVER_R_64F,\nCUSOLVER_R_32F,\nCUSOLVER_R_16F,\nCUSOLVER_R_16BF,\nCUSOLVER_R_TF32\nCUSOLVER_R_32F\nCUSOLVER_R_32F,\nCUSOLVER_R_16F,\nCUSOLVER_R_16BF,\nCUSOLVER_R_TF32\nThe\ncusolverDnIRSXgesv_bufferSize()\nfunction returns the required workspace buffer size in bytes for the corresponding\ncusolverDnXgesv()\ncall with the given\ngesv_irs_params\nconfiguration.\ncusolverStatus_t\ncusolverDnIRSXgesv_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnIRSParams_t\ngesv_irs_params\n,\ncusolver_int_t\nn\n,\ncusolver_int_t\nnrhs\n,\nsize_t\n*\nlwork_bytes\n);\nParameters of cusolverDnIRSXgesv_bufferSize() functions\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cusolverDn library context.\nparams\nhost\ninput\nXgesv\nconfiguration parameters\nn\nhost\ninput\nNumber of rows and columns of the square matrix\nA\n. Should be non-negative.\nnrhs\nhost\ninput\nNumber of right hand sides to solve. Should be non-negative. Note that\nnrhs\nis limited to 1 if the selected IRS refinement solver is CUSOLVER_IRS_REFINE_GMRES, CUSOLVER_IRS_REFINE_GMRES_GMRES, CUSOLVER_IRS_REFINE_CLASSICAL_GMRES.\nlwork_bytes\nhost\nout\nPointer to a variable, where the required size in bytes, of the workspace will be stored after a call to\ncusolverDnIRSXgesv_bufferSize\n. Can’t be NULL.\ncusolverStatus_t\ncusolverDnIRSXgesv\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnIRSParams_t\ngesv_irs_params\n,\ncusolverDnIRSInfos_t\ngesv_irs_infos\n,\nint\nn\n,\nint\nnrhs\n,\nvoid\n*\ndA\n,\nint\nldda\n,\nvoid\n*\ndB\n,\nint\nlddb\n,\nvoid\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\ndinfo\n);\nParameters of cusolverDnIRSXgesv() functions\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cusolverDn library context.\ngesv_irs_params\nhost\ninput\nConfiguration parameters structure, can serve one or more calls to any IRS solver\ngesv_irs_infos\nhost\nin/out\nInfo structure, where information about a particular solve will be stored. The\ngesv_irs_infos\nstructure correspond to a particular call. Thus different calls requires different\ngesv_irs_infos\nstructure otherwise, it will be overwritten.\nn\nhost\ninput\nNumber of rows and columns of square matrix\nA\n. Should be non-negative.\nnrhs\nhost\ninput\nNumber of right hand sides to solve. Should be non-negative. Note that,\nnrhs\nis limited to 1 if the selected IRS refinement solver is CUSOLVER_IRS_REFINE_GMRES, CUSOLVER_IRS_REFINE_GMRES_GMRES, CUSOLVER_IRS_REFINE_CLASSICAL_GMRES.\ndA\ndevice\nin/out\nMatrix\nA\nwith size\nn-by-n\n. Can’t be\nNULL\n. On return - will contain the factorization of the matrix A in the main precision (\nA\n=\nP\n*\nL\n*\nU\n, where P - permutation matrix defined by vector ipiv, L and U - lower and upper triangular matrices) if the iterative refinement solver was set to CUSOLVER_IRS_REFINE_NONE and the lowest precision is equal to the main precision (Inputs/Outputs datatype), or if the iterative refinement solver did not converge and the fallback to main precision was enabled (fallback enabled is the default setting); unchanged otherwise.\nldda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nlda\n>=\nn\n.\ndB\ndevice\ninput\nSet of right hand sides\nB\nof size\nn-by-nrhs\n. Can’t be\nNULL\n.\nlddb\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix of right hand sides\nB\n.\nldb\n>=\nn\n.\ndX\ndevice\noutput\nSet of solution vectors\nX\nof size\nn-by-nrhs\n. Can’t be\nNULL\n.\nlddx\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix of solution vectors\nX\n.\nldx\n>=\nn\n.\ndWorkspace\ndevice\ninput\nPointer to an allocated workspace in device memory of size lwork_bytes.\nlwork_bytes\nhost\ninput\nSize of the allocated device workspace. Should be at least what was returned by\ncusolverDnIRSXgesv_bufferSize()\nfunction\nniters\nhost\noutput\nIf iter is\n<0 : iterative refinement has failed, main precision (Inputs/Outputs precision) factorization has been performed if fallback is enabled.\n-1 : taking into account machine parameters, n, nrhs, it is a priori not worth working in lower precision\n-2 : overflow of an entry when moving from main to lower precision\n-3 : failure during the factorization\n-5 : overflow occurred during computation\n-maxiter: solver stopped the iterative refinement after reaching maximum allowed iterations.\n>0 : iter is a number of iterations solver performed to reach convergence criteria\ndinfo\ndevice\noutput\nStatus of the IRS solver on the return. If 0 - solve was successful. If dinfo = -\ni\nthen\ni\n-th argument is not valid. If dinfo =\ni\n, then\nU(i,i)\ncomputed in main precision is exactly zero. The factorization has been completed, but the factor U is exactly singular, so the solution could not be computed.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed, for example:\nn<0\nlda<max(1,n)\nldb<max(1,n)\nldx<max(1,n)\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe IRS solver supports compute capability 7.0 and above. The lowest precision options CUSOLVER_[CR]_16BF and CUSOLVER_[CR]_TF32 are only available on compute capability 8.0 and above.\nCUSOLVER_STATUS_INVALID_WORKSPACE\nlwork_bytes\nis smaller than the required workspace. Could happen if the users called\ncusolverDnIRSXgesv_bufferSize()\nfunction, then changed some of the configurations setting such as the lowest precision.\nCUSOLVER_STATUS_IRS_OUT_OF_RANGE\nNumerical error related to niters <0, see niters description for more details.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal error occurred, check the\ndinfo\nand the\nniters\narguments for more details.\nCUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED\nThe configuration parameter\ngesv_irs_params\nstructure was not created.\nCUSOLVER_STATUS_IRS_PARAMS_INVALID\nOne of the configuration parameter in the\ngesv_irs_params\nstructure is not valid.\nCUSOLVER_STATUS_IRS_PARAMS_INVALID_PREC\nThe main and/or the lowest precision configuration parameter in the\ngesv_irs_params\nstructure is not valid, check the table above for the supported combinations.\nCUSOLVER_STATUS_IRS_PARAMS_INVALID_MAXITER\nThe maxiter configuration parameter in the\ngesv_irs_params\nstructure is not valid.\nCUSOLVER_STATUS_IRS_PARAMS_INVALID_REFINE\nThe refinement solver configuration parameter in the\ngesv_irs_params\nstructure is not valid.\nCUSOLVER_STATUS_IRS_NOT_SUPPORTED\nOne of the configuration parameter in the\ngesv_irs_params\nstructure is not supported. For example if nrhs >1, and refinement solver was set to\nCUSOLVER_IRS_REFINE_GMRES\n.\nCUSOLVER_STATUS_IRS_INFOS_NOT_INITIALIZED\nThe information structure\ngesv_irs_infos\nwas not created.\nCUSOLVER_STATUS_ALLOC_FAILED\nCPU memory allocation failed, most likely during the allocation of the residual array that store the residual norms.\n2.4.2.8.\ncusolverDn<t>geqrf()\n\nThese helper functions calculate the size of work buffers needed.\ncusolverStatus_t\ncusolverDnSgeqrf_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nint\n*\nLwork\n);\ncusolverStatus_t\ncusolverDnDgeqrf_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\nint\n*\nLwork\n);\ncusolverStatus_t\ncusolverDnCgeqrf_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\nint\n*\nLwork\n);\ncusolverStatus_t\ncusolverDnZgeqrf_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nint\n*\nLwork\n);\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnSgeqrf\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\n*\nTAU\n,\nfloat\n*\nWorkspace\n,\nint\nLwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnDgeqrf\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\n*\nTAU\n,\ndouble\n*\nWorkspace\n,\nint\nLwork\n,\nint\n*\ndevInfo\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnCgeqrf\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\ncuComplex\n*\nTAU\n,\ncuComplex\n*\nWorkspace\n,\nint\nLwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnZgeqrf\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ncuDoubleComplex\n*\nTAU\n,\ncuDoubleComplex\n*\nWorkspace\n,\nint\nLwork\n,\nint\n*\ndevInfo\n);\nThis function computes the QR factorization of an\n\\(m \\times n\\)\nmatrix\n\\[A = Q*R\\]\nwhere\nA\nis an\n\\(m \\times n\\)\nmatrix,\nQ\nis an\n\\(m \\times n\\)\nmatrix, and\nR\nis a\n\\(n \\times n\\)\nupper triangular matrix.\nThe user has to provide working space which is pointed by input parameter\nWorkspace\n. The input parameter\nLwork\nis size of the working space, and it is returned by\ngeqrf_bufferSize()\n.\nThe matrix\nR\nis overwritten in upper triangular part of\nA\n, including diagonal elements.\nThe matrix\nQ\nis not formed explicitly, instead, a sequence of householder vectors are stored in lower triangular part of\nA\n. The leading nonzero element of householder vector is assumed to be 1 such that output parameter\nTAU\ncontains the scaling factor\nτ\n. If\nv\nis original householder vector,\nq\nis the new householder vector corresponding to\nτ\n, satisfying the following relation\n\\[I - 2*v*v^{H} = I - \\tau*q*q^{H}\\]\nIf output parameter\ndevInfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nAPI of geqrf\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nm\nhost\ninput\nNumber of rows of matrix\nA\n.\nn\nhost\ninput\nNumber of columns of matrix\nA\n.\nA\ndevice\nin/out\n<type> array of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,m)\n.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nTAU\ndevice\noutput\n<type> array of dimension at least\nmin(m,n)\n.\nWorkspace\ndevice\nin/out\nWorking space, <type> array of size\nLwork\n.\nLwork\nhost\ninput\nSize of working array\nWorkspace\n.\ndevInfo\ndevice\noutput\nIf\ndevInfo\n=\n0\n, the LU factorization is successful. if\ndevInfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle).\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,n<0\nor\nlda<max(1,m)\n).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.2.9.\ncusolverDn<t1><t2>gels()\n\nThese functions compute the solution of a system of linear equations with one or multiple right hand sides using mixed precision iterative refinement techniques based on the QR factorization Xgels. These functions are similar in term of functionalities to the full precision LAPACK QR (least squares) solver (Xgels, where X denotes Z,C,D,S) but it uses lower precision internally in order to provide faster time to solution, from here comes the name mixed precision. Mixed precision iterative refinement techniques means that the solver compute an QR factorization in lower precision and then iteratively refine the solution to achieve the accuracy of the Inputs/Outputs datatype precision. The <t1> corresponds to the Inputs/Outputs datatype precision while <t2> represent the internal lower precision at which the factorization will be carried on.\n\\[A \\times X = B\\]\nWhere\nA\nis\nm-by-n\nmatrix and\nX\nis\nn-by-nrhs\nand\nB\nis\nm-by-nrhs\nmatrices.\nFunctions API are designed to be as close as possible to LAPACK API to be considered as a quick and easy drop-in replacement. Description of these functions is given below.\n<t1><t2>gels()\nfunctions are designated by two floating point precisions The\n<t1>\ncorresponds to the main precision (e.g., Inputs/Outputs datatype precision) and the\n<t2>\nrepresent the internal lower precision at which the factorization will be carried on.\ncusolver<t1><t2>gels()\nfirst attempts to factorize the matrix in lower precision and use this factorization within an iterative refinement procedure to obtain a solution with same normwise backward error as the main precision\n<t1>\n. If the approach fails to converge, then the method fallback to the main precision factorization and solve (Xgels) such a way that there is always a good solution at the output of these functions. If\n<t2>\nis equal to\n<t1>\n, then it is not a mixed precision process but rather a full one precision factorization, solve and refinement within the same main precision.\nThe iterative refinement process is stopped if:\nITER\n>\nITERMAX\nor for all the RHS we have:\nRNRM\n<\nSQRT(N)*XNRM*ANRM*EPS*BWDMAX\nwhere\nITER is the number of the current iteration in the iterative refinement process\nRNRM is the infinity-norm of the residual\nXNRM is the infinity-norm of the solution\nANRM is the infinity-operator-norm of the matrix A\nEPS is the machine epsilon that matches\nLAPACK<t1>LAMCH('Epsilon')\nThe values ITERMAX and BWDMAX are fixed to 50 and 1.0 respectively.\nThe function returns value describes the results of the solving process. A\nCUSOLVER_STATUS_SUCCESS\nindicates that the function finished with success otherwise, it indicates if one of the API arguments is incorrect, or if the function did not finish with success. More details about the error will be in the\nniters\nand the\ndinfo\nAPI parameters. See their description below for more details. User should provide the required workspace allocated on device memory. The amount of bytes required can be queried by calling the respective function\n<t1><t2>gels_bufferSize()\n.\nWe provide a large set of mixed precision functions that include half, bfloat and tensorfloat as a lower precision as well as same precision functions (e.g., main and lowest precision are equal\n<t2>\nis equal to\n<t1>\n). The following table specifies which precisions will be used for which interface function:\nTensor Float (TF32), introduced with NVIDIA Ampere Architecture GPUs, is the most robust tensor core accelerated compute mode for the iterative refinement solver. It is able to solve the widest range of problems in HPC arising from different applications and provides up to 4X and 5X speedup for real and complex systems, respectively. On Volta and Turing architecture GPUs, half precision tensor core acceleration is recommended. In cases where the iterative refinement solver fails to converge to the desired accuracy (main precision, INOUT data precision), it is recommended to use main precision as internal lowest precision (i.e.,\ncusolverDn[DD,ZZ]gels\nfor the FP64 case).\nSupported combinations of floating point precisions for cusolver <t1><t2>gels() functions\n\nInterface function\nMain precision (matrix, rhs and solution datatype)\nLowest precision allowed to be used internally\ncusolverDnZZgels\ncuDoubleComplex\ndouble\ncomplex\ncusolverDnZCgels\ncuDoubleComplex\nsingle\ncomplex\ncusolverDnZKgels\ncuDoubleComplex\nhalf\ncomplex\ncusolverDnZEgels\ncuDoubleComplex\nbfloat\ncomplex\ncusolverDnZYgels\ncuDoubleComplex\ntensorfloat\ncomplex\ncusolverDnCCgels\ncuComplex\nsingle\ncomplex\ncusolverDnCKgels\ncuComplex\nhalf\ncomplex\ncusolverDnCEgels\ncuComplex\nbfloat\ncomplex\ncusolverDnCYgels\ncuComplex\ntensorfloat\ncomplex\ncusolverDnDDgels\ndouble\ndouble\ncusolverDnDSgels\ndouble\nsingle\ncusolverDnDHgels\ndouble\nhalf\ncusolverDnDBgels\ndouble\nbfloat\ncusolverDnDXgels\ndouble\ntensorfloat\ncusolverDnSSgels\nfloat\nsingle\ncusolverDnSHgels\nfloat\nhalf\ncusolverDnSBgels\nfloat\nbfloat\ncusolverDnSXgels\nfloat\ntensorfloat\ncusolverDn<t1><t2>gels_bufferSize()\nfunctions will return workspace buffer size in bytes required for the corresponding\ncusolverDn<t1><t2>gels()\nfunction.\ncusolverStatus_t\ncusolverDnZZgels_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ncuDoubleComplex\n*\ndA\n,\nint\nldda\n,\ncuDoubleComplex\n*\ndB\n,\nint\nlddb\n,\ncuDoubleComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnZCgels_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ncuDoubleComplex\n*\ndA\n,\nint\nldda\n,\ncuDoubleComplex\n*\ndB\n,\nint\nlddb\n,\ncuDoubleComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnZKgels_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ncuDoubleComplex\n*\ndA\n,\nint\nldda\n,\ncuDoubleComplex\n*\ndB\n,\nint\nlddb\n,\ncuDoubleComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnZEgels_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ncuDoubleComplex\n*\ndA\n,\nint\nldda\n,\ncuDoubleComplex\n*\ndB\n,\nint\nlddb\n,\ncuDoubleComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnZYgels_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ncuDoubleComplex\n*\ndA\n,\nint\nldda\n,\ncuDoubleComplex\n*\ndB\n,\nint\nlddb\n,\ncuDoubleComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnCCgels_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ncuComplex\n*\ndA\n,\nint\nldda\n,\ncuComplex\n*\ndB\n,\nint\nlddb\n,\ncuComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnCKgels_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ncuComplex\n*\ndA\n,\nint\nldda\n,\ncuComplex\n*\ndB\n,\nint\nlddb\n,\ncuComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnCEgels_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ncuComplex\n*\ndA\n,\nint\nldda\n,\ncuComplex\n*\ndB\n,\nint\nlddb\n,\ncuComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnCYgels_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ncuComplex\n*\ndA\n,\nint\nldda\n,\ncuComplex\n*\ndB\n,\nint\nlddb\n,\ncuComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnDDgels_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ndouble\n*\ndA\n,\nint\nldda\n,\ndouble\n*\ndB\n,\nint\nlddb\n,\ndouble\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnDSgels_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ndouble\n*\ndA\n,\nint\nldda\n,\ndouble\n*\ndB\n,\nint\nlddb\n,\ndouble\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnDHgels_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ndouble\n*\ndA\n,\nint\nldda\n,\ndouble\n*\ndB\n,\nint\nlddb\n,\ndouble\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnDBgels_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ndouble\n*\ndA\n,\nint\nldda\n,\ndouble\n*\ndB\n,\nint\nlddb\n,\ndouble\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnDXgels_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ndouble\n*\ndA\n,\nint\nldda\n,\ndouble\n*\ndB\n,\nint\nlddb\n,\ndouble\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnSSgels_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\nfloat\n*\ndA\n,\nint\nldda\n,\nfloat\n*\ndB\n,\nint\nlddb\n,\nfloat\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnSHgels_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\nfloat\n*\ndA\n,\nint\nldda\n,\nfloat\n*\ndB\n,\nint\nlddb\n,\nfloat\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnSBgels_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\nfloat\n*\ndA\n,\nint\nldda\n,\nfloat\n*\ndB\n,\nint\nlddb\n,\nfloat\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\ncusolverStatus_t\ncusolverDnSXgels_bufferSize\n(\ncusolverHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\nfloat\n*\ndA\n,\nint\nldda\n,\nfloat\n*\ndB\n,\nint\nlddb\n,\nfloat\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndwork\n,\nsize_t\n*\nlwork_bytes\n);\nParameters of cusolverDn<T1><T2>gels_bufferSize() functions\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cusolverDN library context.\nm\nhost\ninput\nNumber of rows of the matrix\nA\n. Should be non-negative and n<=m\nn\nhost\ninput\nNumber of columns of the matrix\nA\n. Should be non-negative and n<=m.\nnrhs\nhost\ninput\nNumber of right hand sides to solve. Should be non-negative.\ndA\ndevice\nNone\nMatrix\nA\nwith size\nm-by-n\n. Can be\nNULL\n.\nldda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nldda\n>=\nm\n.\ndB\ndevice\nNone\nSet of right hand sides\nB\nof size\nm-by-nrhs\n. Can be\nNULL\n.\nlddb\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix of right hand sides\nB\n.\nlddb\n>=\nmax(1,m)\n.\ndX\ndevice\nNone\nSet of solution vectors\nX\nof size\nn-by-nrhs\n. Can be\nNULL\n.\nlddx\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix of solution vectors\nX\n.\nlddx\n>=\nmax(1,n)\n.\ndwork\ndevice\nnone\nPointer to device workspace. Not used and can be\nNULL\n.\nlwork_bytes\nhost\noutput\nPointer to a variable where required size of temporary workspace in bytes will be stored. Can’t be NULL.\ncusolverStatus_t\ncusolverDnZZgels\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ncuDoubleComplex\n*\ndA\n,\nint\nldda\n,\ncuDoubleComplex\n*\ndB\n,\nint\nlddb\n,\ncuDoubleComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnZCgels\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ncuDoubleComplex\n*\ndA\n,\nint\nldda\n,\ncuDoubleComplex\n*\ndB\n,\nint\nlddb\n,\ncuDoubleComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnZKgels\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ncuDoubleComplex\n*\ndA\n,\nint\nldda\n,\ncuDoubleComplex\n*\ndB\n,\nint\nlddb\n,\ncuDoubleComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnZEgels\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ncuDoubleComplex\n*\ndA\n,\nint\nldda\n,\ncuDoubleComplex\n*\ndB\n,\nint\nlddb\n,\ncuDoubleComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnZYgels\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ncuDoubleComplex\n*\ndA\n,\nint\nldda\n,\ncuDoubleComplex\n*\ndB\n,\nint\nlddb\n,\ncuDoubleComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnCCgels\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ncuComplex\n*\ndA\n,\nint\nldda\n,\ncuComplex\n*\ndB\n,\nint\nlddb\n,\ncuComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnCKgels\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ncuComplex\n*\ndA\n,\nint\nldda\n,\ncuComplex\n*\ndB\n,\nint\nlddb\n,\ncuComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnCEgels\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ncuComplex\n*\ndA\n,\nint\nldda\n,\ncuComplex\n*\ndB\n,\nint\nlddb\n,\ncuComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnCYgels\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ncuComplex\n*\ndA\n,\nint\nldda\n,\ncuComplex\n*\ndB\n,\nint\nlddb\n,\ncuComplex\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnDDgels\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ndouble\n*\ndA\n,\nint\nldda\n,\ndouble\n*\ndB\n,\nint\nlddb\n,\ndouble\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnDSgels\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ndouble\n*\ndA\n,\nint\nldda\n,\ndouble\n*\ndB\n,\nint\nlddb\n,\ndouble\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnDHgels\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ndouble\n*\ndA\n,\nint\nldda\n,\ndouble\n*\ndB\n,\nint\nlddb\n,\ndouble\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnDBgels\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ndouble\n*\ndA\n,\nint\nldda\n,\ndouble\n*\ndB\n,\nint\nlddb\n,\ndouble\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnDXgels\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\ndouble\n*\ndA\n,\nint\nldda\n,\ndouble\n*\ndB\n,\nint\nlddb\n,\ndouble\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnSSgels\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\nfloat\n*\ndA\n,\nint\nldda\n,\nfloat\n*\ndB\n,\nint\nlddb\n,\nfloat\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnSHgels\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\nfloat\n*\ndA\n,\nint\nldda\n,\nfloat\n*\ndB\n,\nint\nlddb\n,\nfloat\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnSBgels\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\nfloat\n*\ndA\n,\nint\nldda\n,\nfloat\n*\ndB\n,\nint\nlddb\n,\nfloat\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\ncusolverStatus_t\ncusolverDnSXgels\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\nfloat\n*\ndA\n,\nint\nldda\n,\nfloat\n*\ndB\n,\nint\nlddb\n,\nfloat\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\nniter\n,\nint\n*\ndinfo\n);\nParameters of cusolverDn<T1><T2>gels() functions\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cusolverDN library context.\nm\nhost\ninput\nNumber of rows of the matrix\nA\n. Should be non-negative and n<=m\nn\nhost\ninput\nNumber of columns of the matrix\nA\n. Should be non-negative and n<=m.\nnrhs\nhost\ninput\nNumber of right hand sides to solve. Should be non-negative.\ndA\ndevice\nin/out\nMatrix\nA\nwith size\nm-by-n\n. Can’t be\nNULL\n. On return - unchanged if the lowest precision is not equal to the main precision and the iterative refinement solver converged, - garbage otherwise.\nldda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nldda\n>=\nm\n.\ndB\ndevice\ninput\nSet of right hand sides\nB\nof size\nm-by-nrhs\n. Can’t be\nNULL\n.\nlddb\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix of right hand sides\nB\n.\nlddb\n>=\nmax(1,m)\n.\ndX\ndevice\noutput\nSet of solution vectors\nX\nof size\nn-by-nrhs\n. Can’t be\nNULL\n.\nlddx\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix of solution vectors\nX\n.\nlddx\n>=\nmax(1,n)\n.\ndWorkspace\ndevice\ninput\nPointer to an allocated workspace in device memory of size lwork_bytes.\nlwork_bytes\nhost\ninput\nSize of the allocated device workspace. Should be at least what was returned by\ncusolverDn<T1><T2>gels_bufferSize()\nfunction\nniters\nhost\noutput\nIf iter is\n<0 : iterative refinement has failed, main precision (Inputs/Outputs precision) factorization has been performed.\n-1 : taking into account machine parameters, n, nrhs, it is a priori not worth working in lower precision\n-2 : overflow of an entry when moving from main to lower precision\n-3 : failure during the factorization\n-5 : overflow occurred during computation\n-50: solver stopped the iterative refinement after reaching maximum allowed iterations.\n>0 : iter is a number of iterations solver performed to reach convergence criteria\ndinfo\ndevice\noutput\nStatus of the IRS solver on the return. If 0 - solve was successful. If dinfo = -\ni\nthen\ni\n-th argument is not valid.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed, for example:\nn<0\nldda<max(1,m)\nlddb<max(1,m)\nlddx<max(1,n)\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe IRS solver supports compute capability 7.0 and above. The lowest precision options CUSOLVER_[CR]_16BF and CUSOLVER_[CR]_TF32 are only available on compute capability 8.0 and above.\nCUSOLVER_STATUS_INVALID_WORKSPACE\nlwork_bytes\nis smaller than the required workspace.\nCUSOLVER_STATUS_IRS_OUT_OF_RANGE\nNumerical error related to niters <0, see niters description for more details.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal error occurred; check the\ndinfo\nand the\nniters\narguments for more details.\n2.4.2.10.\ncusolverDnIRSXgels()\n\nThis function is designed to perform same functionality as\ncusolverDn<T1><T2>gels()\nfunctions, but wrapped in a more generic and expert interface that gives user more control to parametrize the function as well as it provides more information on output.\ncusolverDnIRSXgels()\nallows additional control of the solver parameters such as setting:\nthe main precision (Inputs/Outputs precision) of the solver,\nthe lowest precision to be used internally by the solver,\nthe refinement solver type\nthe maximum allowed number of iterations in the refinement phase\nthe tolerance of the refinement solver\nthe fallback to main precision\nand others\nthrough the configuration parameters structure\ngels_irs_params\nand its helper functions. For more details about what configuration can be set and its meaning please refer to all the functions in the cuSolverDN Helper Function Section that start with\ncusolverDnIRSParamsxxxx()\n. Moreover,\ncusolverDnIRSXgels()\nprovides additional information on the output such as the convergence history (e.g., the residual norms) at each iteration and the number of iterations needed to converge. For more details about what information can be retrieved and its meaning please refer to all the functions in the cuSolverDN Helper Function Section that start with\ncusolverDnIRSInfosxxxx()\n.\nThe function returns value describes the results of the solving process. A CUSOLVER_STATUS_SUCCESS indicates that the function finished with success otherwise, it indicates if one of the API arguments is incorrect, or if the configurations of params/infos structure is incorrect or if the function did not finish with success. More details about the error can be found by checking the\nniters\nand the\ndinfo\nAPI parameters. See their description below for further details. Users should provide the required workspace allocated on device for the\ncusolverDnIRSXgels()\nfunction. The amount of bytes required for the function can be queried by calling the respective function\ncusolverDnIRSXgels_bufferSize()\n. Note that, if the user would like a particular configuration to be set via the params structure, it should be set before the call to\ncusolverDnIRSXgels_bufferSize()\nto get the size of the required workspace.\nThe following table provides all possible combinations values for the lowest precision corresponding to the Inputs/Outputs data type. Note that if the lowest precision matches the Inputs/Outputs datatype, then main precision factorization will be used\nTensor Float (TF32), introduced with NVIDIA Ampere Architecture GPUs, is the most robust tensor core accelerated compute mode for the iterative refinement solver. It is able to solve the widest range of problems in HPC arising from different applications and provides up to 4X and 5X speedup for real and complex systems, respectively. On Volta and Turing architecture GPUs, half precision tensor core acceleration is recommended. In cases where the iterative refinement solver fails to converge to the desired accuracy (main precision, INOUT data precision), it is recommended to use main precision as internal lowest precision.\nSupported Inputs/Outputs data type and lower precision for the IRS solver\n\nInputs/Outputs Data Type (e.g., main precision)\nSupported values for the lowest precision\nCUSOLVER_C_64F\nCUSOLVER_C_64F,\nCUSOLVER_C_32F,\nCUSOLVER_C_16F,\nCUSOLVER_C_16BF,\nCUSOLVER_C_TF32\nCUSOLVER_C_32F\nCUSOLVER_C_32F,\nCUSOLVER_C_16F,\nCUSOLVER_C_16BF,\nCUSOLVER_C_TF32\nCUSOLVER_R_64F\nCUSOLVER_R_64F,\nCUSOLVER_R_32F,\nCUSOLVER_R_16F,\nCUSOLVER_R_16BF,\nCUSOLVER_R_TF32\nCUSOLVER_R_32F\nCUSOLVER_R_32F,\nCUSOLVER_R_16F,\nCUSOLVER_R_16BF,\nCUSOLVER_R_TF32\nThe\ncusolverDnIRSXgels_bufferSize()\nfunction return the required workspace buffer size in bytes for the corresponding\ncusolverDnXgels()\ncall with given\ngels_irs_params\nconfiguration.\ncusolverStatus_t\ncusolverDnIRSXgels_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnIRSParams_t\ngels_irs_params\n,\ncusolver_int_t\nm\n,\ncusolver_int_t\nn\n,\ncusolver_int_t\nnrhs\n,\nsize_t\n*\nlwork_bytes\n);\nParameters of cusolverDnIRSXgels_bufferSize() functions\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cusolverDn library context.\nparams\nhost\ninput\nXgels configuration parameters\nm\nhost\ninput\nNumber of rows of the matrix\nA\n. Should be non-negative and n<=m\nn\nhost\ninput\nNumber of columns of the matrix\nA\n. Should be non-negative and n<=m.\nnrhs\nhost\ninput\nNumber of right hand sides to solve. Should be non-negative. Note that,\nnrhs\nis limited to 1 if the selected IRS refinement solver is\nCUSOLVER_IRS_REFINE_GMRES\n,\nCUSOLVER_IRS_REFINE_GMRES_GMRES\n,\nCUSOLVER_IRS_REFINE_CLASSICAL_GMRES\n.\nlwork_bytes\nhost\nout\nPointer to a variable, where the required size in bytes, of the workspace will be stored after a call to\ncusolverDnIRSXgels_bufferSize\n. Can’t be NULL.\ncusolverStatus_t\ncusolverDnIRSXgels\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnIRSParams_t\ngels_irs_params\n,\ncusolverDnIRSInfos_t\ngels_irs_infos\n,\nint\nm\n,\nint\nn\n,\nint\nnrhs\n,\nvoid\n*\ndA\n,\nint\nldda\n,\nvoid\n*\ndB\n,\nint\nlddb\n,\nvoid\n*\ndX\n,\nint\nlddx\n,\nvoid\n*\ndWorkspace\n,\nsize_t\nlwork_bytes\n,\nint\n*\ndinfo\n);\nParameters of cusolverDnIRSXgels() functions\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cusolverDn library context.\ngels_irs_params\nhost\ninput\nConfiguration parameters structure, can serve one or more calls to any IRS solver\ngels_irs_infos\nhost\nin/out\nInfo structure, where information about a particular solve will be stored. The\ngels_irs_infos\nstructure correspond to a particular call. Thus different calls requires different\ngels_irs_infos\nstructure otherwise, it will be overwritten.\nm\nhost\ninput\nNumber of rows of the matrix\nA\n. Should be non-negative and n<=m\nn\nhost\ninput\nNumber of columns of the matrix\nA\n. Should be non-negative and n<=m.\nnrhs\nhost\ninput\nNumber of right hand sides to solve. Should be non-negative. Note that,\nnrhs\nis limited to 1 if the selected IRS refinement solver is CUSOLVER_IRS_REFINE_GMRES, CUSOLVER_IRS_REFINE_GMRES_GMRES, CUSOLVER_IRS_REFINE_CLASSICAL_GMRES.\ndA\ndevice\nin/out\nMatrix\nA\nwith size\nm-by-n\n. Can’t be\nNULL\n. On return - unchanged if the lowest precision is not equal to the main precision and the iterative refinement solver converged, - garbage otherwise.\nldda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nldda\n>=\nm\n.\ndB\ndevice\ninput\nSet of right hand sides\nB\nof size\nm-by-nrhs\n. Can’t be\nNULL\n.\nlddb\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix of right hand sides\nB\n.\nlddb\n>=\nmax(1,m)\n.\ndX\ndevice\noutput\nSet of solution vectors\nX\nof size\nn-by-nrhs\n. Can’t be\nNULL\n.\nlddx\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix of solution vectors\nX\n.\nlddx\n>=\nmax(1,n)\n.\ndWorkspace\ndevice\ninput\nPointer to an allocated workspace in device memory of size lwork_bytes.\nlwork_bytes\nhost\ninput\nSize of the allocated device workspace. Should be at least what was returned by\ncusolverDnIRSXgels_bufferSize()\nfunction.\nniters\nhost\noutput\nIf\niter\nis\n<0 : iterative refinement has failed, main precision (Inputs/Outputs precision) factorization has been performed if fallback is enabled\n-1 : taking into account machine parameters, n, nrhs, it is a priori not worth working in lower precision\n-2 : overflow of an entry when moving from main to lower precision\n-3 : failure during the factorization\n-5 : overflow occurred during computation\n-maxiter\n: solver stopped the iterative refinement after reaching maximum allowed iterations\n>0 : iter is a number of iterations solver performed to reach convergence criteria\ndinfo\ndevice\noutput\nStatus of the IRS solver on the return. If 0 - solve was successful. If dinfo = -\ni\nthen\ni\n-th argument is not valid.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed, for example:\nn<0\nldda<max(1,m)\nlddb<max(1,m)\nlddx<max(1,n)\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe IRS solver supports compute capability 7.0 and above. The lowest precision options CUSOLVER_[CR]_16BF and CUSOLVER_[CR]_TF32 are only available on compute capability 8.0 and above.\nCUSOLVER_STATUS_INVALID_WORKSPACE\nlwork_bytes\nis smaller than the required workspace. Could happen if the users called\ncusolverDnIRSXgels_bufferSize()\nfunction, then changed some of the configurations setting such as the lowest precision.\nCUSOLVER_STATUS_IRS_OUT_OF_RANGE\nNumerical error related to\nniters\n<0; see\nniters\ndescription for more details.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal error occurred, check the\ndinfo\nand the\nniters\narguments for more details.\nCUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED\nThe configuration parameter\ngels_irs_params\nstructure was not created.\nCUSOLVER_STATUS_IRS_PARAMS_INVALID\nOne of the configuration parameter in the\ngels_irs_params\nstructure is not valid.\nCUSOLVER_STATUS_IRS_PARAMS_INVALID_PREC\nThe main and/or the lowest precision configuration parameter in the\ngels_irs_params\nstructure is not valid, check the table above for the supported combinations.\nCUSOLVER_STATUS_IRS_PARAMS_INVALID_MAXITER\nThe maxiter configuration parameter in the\ngels_irs_params\nstructure is not valid.\nCUSOLVER_STATUS_IRS_PARAMS_INVALID_REFINE\nThe refinement solver configuration parameter in the\ngels_irs_params\nstructure is not valid.\nCUSOLVER_STATUS_IRS_NOT_SUPPORTED\nOne of the configuration parameter in the\ngels_irs_params\nstructure is not supported. For example if nrhs >1, and refinement solver was set to\nCUSOLVER_IRS_REFINE_GMRES\n.\nCUSOLVER_STATUS_IRS_INFOS_NOT_INITIALIZED\nThe information structure\ngels_irs_infos\nwas not created.\nCUSOLVER_STATUS_ALLOC_FAILED\nCPU memory allocation failed, most likely during the allocation of the residual array that store the residual norms.\n2.4.2.11.\ncusolverDn<t>ormqr()\n\nThese helper functions calculate the size of work buffers needed. Please visit\ncuSOLVER Library Samples - ormqr\nfor a code example.\ncusolverStatus_t\ncusolverDnSormqr_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\ntau\n,\nconst\nfloat\n*\nC\n,\nint\nldc\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnDormqr_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\ntau\n,\nconst\ndouble\n*\nC\n,\nint\nldc\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnCunmqr_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\ntau\n,\nconst\ncuComplex\n*\nC\n,\nint\nldc\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnZunmqr_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\ntau\n,\nconst\ncuDoubleComplex\n*\nC\n,\nint\nldc\n,\nint\n*\nlwork\n);\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnSormqr\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\ntau\n,\nfloat\n*\nC\n,\nint\nldc\n,\nfloat\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnDormqr\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\ntau\n,\ndouble\n*\nC\n,\nint\nldc\n,\ndouble\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnCunmqr\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\ntau\n,\ncuComplex\n*\nC\n,\nint\nldc\n,\ncuComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnZunmqr\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\ntau\n,\ncuDoubleComplex\n*\nC\n,\nint\nldc\n,\ncuDoubleComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\nThis function overwrites\n\\(m \\times n\\)\nmatrix\nC\nby\nThe operation of\nQ\nis defined by\nQ\nis a unitary matrix formed by a sequence of elementary reflection vectors from QR factorization (\ngeqrf\n) of\nA\n.\nQ\n=\nH(1)\nH(2)\n…\nH(k)\nQ\nis of order\nm\nif\nside\n=\nCUBLAS_SIDE_LEFT\nand of order\nn\nif\nside\n=\nCUBLAS_SIDE_RIGHT\n.\nThe user has to provide working space which is pointed by input parameter\nwork\n. The input parameter\nlwork\nis size of the working space, and it is returned by\ngeqrf_bufferSize()\nor\normqr_bufferSize()\n. Please note that the size in bytes of the working space is equal to\nsizeof(<type>)\n*\nlwork\n.\nIf output parameter\ndevInfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nThe user can combine\ngeqrf\n,\normqr\nand\ntrsm\nto complete a linear solver or a least-square solver.\nAPI of ormqr\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDn library context.\nside\nhost\ninput\nIndicates if matrix\nQ\nis on the left or right of\nC\n.\ntrans\nhost\ninput\nOperation\nop(Q)\nthat is non- or (conj.) transpose.\nm\nhost\ninput\nNumber of rows of matrix\nC\n.\nn\nhost\ninput\nNumber of columns of matrix\nC\n.\nk\nhost\ninput\nNumber of elementary reflections whose product defines the matrix Q. If\nside\nis\nCUBLAS_SIDE_LEFT\n,\nm\n>=\nk\n>=\n0\n; if\nside\nis\nCUBLAS_SIDE_RIGHT\n,\nn\n>=\nk\n>=\n0\n.\nA\ndevice\nin\n<type> array of dimension\nlda\n*\nk\nwith\nlda\nis not less than\nmax(1,m)\n. The matrix\nA\nis from\ngeqrf\n, so i-th column contains elementary reflection vector.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n. If\nside\nis\nCUBLAS_SIDE_LEFT\n, lda >= max(1,m); if\nside\nis\nCUBLAS_SIDE_RIGHT\n, lda >= max(1,n).\ntau\ndevice\ninput\n<type> array of dimension\nk\n. The vector\ntau\nis from\ngeqrf\n, so\ntau(i)\nis the scalar of the i-th elementary reflection vector.\nC\ndevice\nin/out\n<type> array of size\nldc\n*\nn\n. On exit,\nC\nis overwritten by\nop(Q)*C\nor\nC*op(Q)\n.\nldc\nhost\ninput\nLeading dimension of two-dimensional array of matrix\nC\n. ldc >= max(1,m).\nwork\ndevice\nin/out\nWorking space, <type> array of size\nlwork\n.\nlwork\nhost\ninput\nSize of working array\nwork\n.\ndevInfo\ndevice\noutput\nIf\ndevInfo\n=\n0\n, the ormqr is successful. If\ndevInfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle).\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,n,k<0\n,\nk\n>\nm\nif\nCUBLAS_SIDE_LEFT\n,\nk\n>\nn\nif\nCUBLAS_SIDE_RIGHT\n, wrong\nlda\nor\nldc\nor invalid\ntrans\n).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.2.12.\ncusolverDn<t>orgqr()\n\nThese helper functions calculate the size of work buffers needed. Please visit\ncuSOLVER Library Samples - orgqr\nfor a code example.\ncusolverStatus_t\ncusolverDnSorgqr_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\ntau\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnDorgqr_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\ntau\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnCungqr_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\ntau\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnZungqr_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\ntau\n,\nint\n*\nlwork\n);\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnSorgqr\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\ntau\n,\nfloat\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnDorgqr\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\ntau\n,\ndouble\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnCungqr\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\ntau\n,\ncuComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnZungqr\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\ntau\n,\ncuDoubleComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\nThis function overwrites\n\\(m \\times n\\)\nmatrix\nA\nby\n\\[Q = {H(1)}*{H(2)}*{...}*{H(k)}\\]\nwhere\nQ\nis a unitary matrix formed by a sequence of elementary reflection vectors stored in\nA\n.\nThe user has to provide working space which is pointed by input parameter\nwork\n. The input parameter\nlwork\nis size of the working space, and it is returned by\norgqr_bufferSize()\n. Please note that the size in bytes of the working space is equal to\nsizeof(<type>)\n*\nlwork\n.\nIf output parameter\ndevInfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nThe user can combine\ngeqrf\n,\norgqr\nto complete orthogonalization.\nAPI of orgqr\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nm\nhost\ninput\nNumber of rows of matrix\nQ\n. m >= 0;\nn\nhost\ninput\nNumber of columns of matrix\nQ\n. m >= n >= 0;\nk\nhost\ninput\nNumber of elementary reflections whose product defines the matrix\nQ\n. n >= k >= 0;\nA\ndevice\nin/out\n<type> array of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,m)\n. i-th column of\nA\ncontains elementary reflection vector.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n. lda >= max(1,m).\ntau\ndevice\ninput\n<type> array of dimension\nk\n.\ntau(i)\nis the scalar of i-th elementary reflection vector.\nwork\ndevice\nin/out\nWorking space, <type> array of size\nlwork\n.\nlwork\nhost\ninput\nSize of working array\nwork\n.\ndevInfo\ndevice\noutput\nIf\ninfo\n=\n0\n, the orgqr is successful. if\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle).\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,n,k<0\n,\nn>m\n,\nk>n\nor\nlda<m\n).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.2.13.\ncusolverDn<t>sytrf()\n\nThese helper functions calculate the size of the needed buffers.\ncusolverStatus_t\ncusolverDnSsytrf_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnDsytrf_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnCsytrf_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnZsytrf_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nint\n*\nlwork\n);\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnSsytrf\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nint\n*\ndevIpiv\n,\nfloat\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnDsytrf\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\nint\n*\ndevIpiv\n,\ndouble\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnCsytrf\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\nint\n*\ndevIpiv\n,\ncuComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnZsytrf\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nint\n*\ndevIpiv\n,\ncuDoubleComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\nThis function computes the factorization of a symmetric indefinite matrix using the Bunch-Kaufman diagonal pivoting.\nA\nis a\n\\(n \\times n\\)\nsymmetric matrix, only lower or upper part is meaningful. The input parameter\nuplo\nindicates which part of the matrix is used. If\ndevIpiv\nis null, no pivoting is performed, which is not numerically stable.\nIf input parameter\nuplo\nis\nCUBLAS_FILL_MODE_LOWER\n, only lower triangular part of\nA\nis processed, and replaced by lower triangular factor\nL\nand block diagonal matrix\nD\n. Each block of\nD\nis either 1x1 or 2x2 block, depending on pivoting.\n\\[P*A*P^{T} = L*D*L^{T}\\]\nIf input parameter\nuplo\nis\nCUBLAS_FILL_MODE_UPPER\n, only upper triangular part of\nA\nis processed, and replaced by upper triangular factor\nU\nand block diagonal matrix\nD\n.\n\\[P*A*P^{T} = U*D*U^{T}\\]\nThe user has to provide working space which is pointed by input parameter\nwork\n. The input parameter\nlwork\nis size of the working space, and it is returned by\nsytrf_bufferSize()\n. Please note that the size in bytes of the working space is equal to\nsizeof(<type>)\n*\nlwork\n. When no pivoting is performed, the other triangular part of the input matrix\nA\nis used as workspace.\nIf Bunch-Kaufman factorization failed, i.e.\nA\nis singular. The output parameter\ndevInfo\n=\ni\nwould indicate\nD(i,i)=0\n.\nIf output parameter\ndevInfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nThe output parameter\ndevIpiv\ncontains pivoting sequence. If\ndevIpiv(i)\n=\nk\n>\n0\n,\nD(i,i)\nis 1x1 block, and\ni-th\nrow/column of\nA\nis interchanged with\nk-th\nrow/column of\nA\n. If\nuplo\nis\nCUBLAS_FILL_MODE_UPPER\nand\ndevIpiv(i-1)\n=\ndevIpiv(i)\n=\n-m\n<\n0\n,\nD(i-1:i,i-1:i)\nis a 2x2 block, and\n(i-1)-th\nrow/column is interchanged with\nm-th\nrow/column. If\nuplo\nis\nCUBLAS_FILL_MODE_LOWER\nand\ndevIpiv(i+1)\n=\ndevIpiv(i)\n=\n-m\n<\n0\n,\nD(i:i+1,i:i+1)\nis a 2x2 block, and\n(i+1)-th\nrow/column is interchanged with\nm-th\nrow/column.\nAPI of sytrf\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nuplo\nhost\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other part is not referenced.\nn\nhost\ninput\nNumber of rows and columns of matrix\nA\n.\nA\ndevice\nin/out\n<type> array of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,n)\n.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\ndevIpiv\ndevice\noutput\nArray of size at least\nn\n, containing pivot indices. To perform no pivoting, set the argument\nNULL\n.\nwork\ndevice\nin/out\nWorking space, <type> array of size\nlwork\n.\nlwork\nhost\ninput\nSize of working space\nwork\n.\ndevInfo\ndevice\noutput\nIf\ndevInfo\n=\n0\n, the LU factorization is successful. if\ndevInfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle). if\ndevInfo\n=\ni\n, the\nD(i,i)\n=\n0\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\nor\nlda<max(1,n)\n).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.2.14.\ncusolverDn<t>potrfBatched()\n\nThe S and D data types are real valued single and double precision, respectively. Please visit\ncuSOLVER Library Samples - potrfBatched\nfor a code example.\ncusolverStatus_t\ncusolverDnSpotrfBatched\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nfloat\n*\nAarray\n[],\nint\nlda\n,\nint\n*\ninfoArray\n,\nint\nbatchSize\n);\ncusolverStatus_t\ncusolverDnDpotrfBatched\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ndouble\n*\nAarray\n[],\nint\nlda\n,\nint\n*\ninfoArray\n,\nint\nbatchSize\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnCpotrfBatched\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuComplex\n*\nAarray\n[],\nint\nlda\n,\nint\n*\ninfoArray\n,\nint\nbatchSize\n);\ncusolverStatus_t\ncusolverDnZpotrfBatched\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuDoubleComplex\n*\nAarray\n[],\nint\nlda\n,\nint\n*\ninfoArray\n,\nint\nbatchSize\n);\nThis function computes the Cholesky factorization of a sequence of Hermitian positive-definite matrices.\nEach\nAarray[i]\nfor\ni=0,1,...,\nbatchSize-1\nis a\n\\(n \\times n\\)\nHermitian matrix, only lower or upper part is meaningful. The input parameter\nuplo\nindicates which part of the matrix is used.\nIf input parameter\nuplo\nis\nCUBLAS_FILL_MODE_LOWER\n, only lower triangular part of\nA\nis processed, and replaced by lower triangular Cholesky factor\nL\n.\n\\[A = L*L^{H}\\]\nIf input parameter\nuplo\nis\nCUBLAS_FILL_MODE_UPPER\n, only upper triangular part of\nA\nis processed, and replaced by upper triangular Cholesky factor\nU\n.\n\\[A = U^{H}*U\\]\nIf Cholesky factorization failed, i.e. some leading minor of\nA\nis not positive definite, or equivalently some diagonal elements of\nL\nor\nU\nis not a real number. The output parameter\ninfoArray\nwould indicate smallest leading minor of\nA\nwhich is not positive definite.\ninfoArray\nis an integer array of size\nbatchsize\n. If\npotrfBatched\nreturns\nCUSOLVER_STATUS_INVALID_VALUE\n,\ninfoArray[0]\n=\n-i\n(less than zero), meaning that the\ni-th\nparameter is wrong (not counting handle). If\npotrfBatched\nreturns\nCUSOLVER_STATUS_SUCCESS\nbut\ninfoArray[i]\n=\nk\nis positive, then\ni-th\nmatrix is not positive definite and the Cholesky factorization failed at row\nk\n.\nRemark: the other part of\nA\nis used as a workspace. For example, if\nuplo\nis\nCUBLAS_FILL_MODE_UPPER\n, upper triangle of\nA\ncontains Cholesky factor\nU\nand lower triangle of\nA\nis destroyed after\npotrfBatched\n.\nAPI of potrfBatched\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nuplo\nhost\ninput\nIndicates if lower or upper part is stored; the other part is used as a workspace.\nn\nhost\ninput\nNumber of rows and columns of matrix\nA\n.\nAarray\ndevice\nin/out\nArray of pointers to <type> array of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,n)\n.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store each matrix\nAarray[i]\n.\ninfoArray\ndevice\noutput\nArray of size\nbatchSize\n.\ninfoArray[i]\ncontains information of factorization of\nAarray[i]\n. if\npotrfBatched\nreturns\nCUSOLVER_STATUS_INVALID_VALUE\n,\ninfoArray[0]\n=\n-i\n(less than zero) means the\ni-th\nparameter is wrong (not counting handle). if\npotrfBatched\nreturns\nCUSOLVER_STATUS_SUCCESS\n,\ninfoArray[i]\n=\n0\nmeans the Cholesky factorization of\ni-th\nmatrix is successful, and\ninfoArray[i]\n=\nk\nmeans the leading submatrix of order k of\ni-th\nmatrix is not positive definite.\nbatchSize\nhost\ninput\nNumber of pointers in\nAarray\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\nor\nlda<max(1,n)\nor\nbatchSize<1\n).\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.2.15.\ncusolverDn<t>potrsBatched()\n\ncusolverStatus_t\ncusolverDnSpotrsBatched\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nint\nnrhs\n,\nfloat\n*\nAarray\n[],\nint\nlda\n,\nfloat\n*\nBarray\n[],\nint\nldb\n,\nint\n*\ninfo\n,\nint\nbatchSize\n);\ncusolverStatus_t\ncusolverDnDpotrsBatched\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nint\nnrhs\n,\ndouble\n*\nAarray\n[],\nint\nlda\n,\ndouble\n*\nBarray\n[],\nint\nldb\n,\nint\n*\ninfo\n,\nint\nbatchSize\n);\ncusolverStatus_t\ncusolverDnCpotrsBatched\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nint\nnrhs\n,\ncuComplex\n*\nAarray\n[],\nint\nlda\n,\ncuComplex\n*\nBarray\n[],\nint\nldb\n,\nint\n*\ninfo\n,\nint\nbatchSize\n);\ncusolverStatus_t\ncusolverDnZpotrsBatched\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nint\nnrhs\n,\ncuDoubleComplex\n*\nAarray\n[],\nint\nlda\n,\ncuDoubleComplex\n*\nBarray\n[],\nint\nldb\n,\nint\n*\ninfo\n,\nint\nbatchSize\n);\nThis function solves a sequence of linear systems\n\\[{A\\lbrack i\\rbrack}*{X\\lbrack i\\rbrack} = {B\\lbrack i\\rbrack}\\]\nwhere each\nAarray[i]\nfor\ni=0,1,...,\nbatchSize-1\nis a\n\\(n \\times n\\)\nHermitian matrix, only lower or upper part is meaningful. The input parameter\nuplo\nindicates which part of the matrix is used.\nThe user has to call\npotrfBatched\nfirst to factorize matrix\nAarray[i]\n. If input parameter\nuplo\nis\nCUBLAS_FILL_MODE_LOWER\n,\nA\nis lower triangular Cholesky factor\nL\ncorresponding to\n\\(A = L*L^{H}\\)\n. If input parameter\nuplo\nis\nCUBLAS_FILL_MODE_UPPER\n,\nA\nis upper triangular Cholesky factor\nU\ncorresponding to\n\\(A = U^{H}*U\\)\n.\nThe operation is in-place, i.e. matrix\nX\noverwrites matrix\nB\nwith the same leading dimension\nldb\n.\nThe output parameter\ninfo\nis a scalar. If\ninfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nRemark 1: only\nnrhs=1\nis supported.\nRemark 2:\ninfoArray\nfrom\npotrfBatched\nindicates if the matrix is positive definite.\ninfo\nfrom\npotrsBatched\nonly shows which input parameter is wrong (not counting handle).\nRemark 3: the other part of\nA\nis used as a workspace. For example, if\nuplo\nis\nCUBLAS_FILL_MODE_UPPER\n, upper triangle of\nA\ncontains Cholesky factor\nU\nand lower triangle of\nA\nis destroyed after\npotrsBatched\n.\nPlease visit\ncuSOLVER Library Samples - potrfBatched\nfor a code example.\nAPI of potrsBatched\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nuplo\nhost\ninput\nIndicates if matrix\nA\nlower or upper part is stored.\nn\nhost\ninput\nNumber of rows and columns of matrix\nA\n.\nnrhs\nhost\ninput\nNumber of columns of matrix\nX\nand\nB\n.\nAarray\ndevice\nin/out\nArray of pointers to <type> array of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,n)\n.\nAarray[i]\nis either lower Cholesky factor\nL\nor upper Cholesky factor\nU\n.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store each matrix\nAarray[i]\n.\nBarray\ndevice\nin/out\nArray of pointers to <type> array of dimension\nldb\n*\nnrhs\n.\nldb\nis not less than\nmax(1,n)\n. As an input,\nBarray[i]\nis right hand side matrix. As an output,\nBarray[i]\nis the solution matrix.\nldb\nhost\ninput\nLeading dimension of two-dimensional array used to store each matrix\nBarray[i]\n.\ninfo\ndevice\noutput\nIf\ninfo\n=\n0\n, all parameters are correct. if\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle).\nbatchSize\nhost\ninput\nNumber of pointers in\nAarray\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\n,\nnrhs<0\n,\nlda<max(1,n)\n,\nldb<max(1,n)\nor\nbatchSize<0\n).\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.3.\nDense Eigenvalue Solver Reference (legacy)\n\nThis chapter describes eigenvalue solver API of cuSolverDN, including bidiagonalization and SVD.\n2.4.3.1.\ncusolverDn<t>gebrd()\n\nThese helper functions calculate the size of work buffers needed.\ncusolverStatus_t\ncusolverDnSgebrd_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\n*\nLwork\n);\ncusolverStatus_t\ncusolverDnDgebrd_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\n*\nLwork\n);\ncusolverStatus_t\ncusolverDnCgebrd_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\n*\nLwork\n);\ncusolverStatus_t\ncusolverDnZgebrd_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\n*\nLwork\n);\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnSgebrd\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\n*\nD\n,\nfloat\n*\nE\n,\nfloat\n*\nTAUQ\n,\nfloat\n*\nTAUP\n,\nfloat\n*\nWork\n,\nint\nLwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnDgebrd\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\n*\nD\n,\ndouble\n*\nE\n,\ndouble\n*\nTAUQ\n,\ndouble\n*\nTAUP\n,\ndouble\n*\nWork\n,\nint\nLwork\n,\nint\n*\ndevInfo\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnCgebrd\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\nfloat\n*\nD\n,\nfloat\n*\nE\n,\ncuComplex\n*\nTAUQ\n,\ncuComplex\n*\nTAUP\n,\ncuComplex\n*\nWork\n,\nint\nLwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnZgebrd\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ndouble\n*\nD\n,\ndouble\n*\nE\n,\ncuDoubleComplex\n*\nTAUQ\n,\ncuDoubleComplex\n*\nTAUP\n,\ncuDoubleComplex\n*\nWork\n,\nint\nLwork\n,\nint\n*\ndevInfo\n);\nThis function reduces a general\n\\(m \\times n\\)\nmatrix\nA\nto a real upper or lower bidiagonal form\nB\nby an orthogonal transformation:\n\\(Q^{H}*A*P = B\\)\nIf\nm>=n\n,\nB\nis upper bidiagonal; if\nm<n\n,\nB\nis lower bidiagonal.\nThe matrix\nQ\nand\nP\nare overwritten into matrix\nA\nin the following sense:\nif\nm>=n\n, the diagonal and the first superdiagonal are overwritten with the upper bidiagonal matrix\nB\n; the elements below the diagonal, with the array\nTAUQ\n, represent the orthogonal matrix\nQ\nas a product of elementary reflectors, and the elements above the first superdiagonal, with the array\nTAUP\n, represent the orthogonal matrix\nP\nas a product of elementary reflectors.\nif\nm<n\n, the diagonal and the first subdiagonal are overwritten with the lower bidiagonal matrix\nB\n; the elements below the first subdiagonal, with the array\nTAUQ\n, represent the orthogonal matrix\nQ\nas a product of elementary reflectors, and the elements above the diagonal, with the array\nTAUP\n, represent the orthogonal matrix\nP\nas a product of elementary reflectors.\nThe user has to provide working space which is pointed by input parameter\nWork\n. The input parameter\nLwork\nis size of the working space, and it is returned by\ngebrd_bufferSize()\n.\nIf output parameter\ndevInfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nRemark:\ngebrd\nonly supports\nm>=n\n.\nAPI of gebrd\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nm\nhost\ninput\nNumber of rows of matrix\nA\n.\nn\nhost\ninput\nNumber of columns of matrix\nA\n.\nA\ndevice\nin/out\n<type> array of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,n)\n.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nD\ndevice\noutput\nReal array of dimension\nmin(m,n)\n. The diagonal elements of the bidiagonal matrix\nB\n:\nD(i)\n=\nA(i,i)\n.\nE\ndevice\noutput\nReal array of dimension\nmin(m,n)\n. The off-diagonal elements of the bidiagonal matrix\nB\n: if\nm>=n\n,\nE(i)\n=\nA(i,i+1)\nfor\ni\n=\n1,2,...,n-1\n; if\nm<n\n,\nE(i)\n=\nA(i+1,i)\nfor\ni\n=\n1,2,...,m-1\n.\nTAUQ\ndevice\noutput\n<type> array of dimension\nmin(m,n)\n. The scalar factors of the elementary reflectors which represent the orthogonal matrix\nQ\n.\nTAUP\ndevice\noutput\n<type> array of dimension\nmin(m,n)\n. The scalar factors of the elementary reflectors which represent the orthogonal matrix\nP\n.\nWork\ndevice\nin/out\nWorking space, <type> array of size\nLwork\n.\nLwork\nhost\ninput\nSize of\nWork\n, returned by\ngebrd_bufferSize\n.\ndevInfo\ndevice\noutput\nIf\ndevInfo\n=\n0\n, the operation is successful. if\ndevInfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle).\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,n<0\n, or\nlda<max(1,m)\n).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.3.2.\ncusolverDn<t>orgbr()\n\nThese helper functions calculate the size of work buffers needed.\ncusolverStatus_t\ncusolverDnSorgbr_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\ntau\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnDorgbr_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\ntau\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnCungbr_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\ntau\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnZungbr_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\ntau\n,\nint\n*\nlwork\n);\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnSorgbr\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\ntau\n,\nfloat\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnDorgbr\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\ntau\n,\ndouble\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnCungbr\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\ntau\n,\ncuComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnZungbr\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\nint\nm\n,\nint\nn\n,\nint\nk\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\ntau\n,\ncuDoubleComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\nThis function generates one of the unitary matrices\nQ\nor\nP**H\ndetermined by\ngebrd\nwhen reducing a matrix A to bidiagonal form:\n\\(Q^{H}*A*P = B\\)\nQ\nand\nP**H\nare defined as products of elementary reflectors H(i) or G(i) respectively.\nThe user has to provide working space which is pointed by input parameter\nwork\n. The input parameter\nlwork\nis size of the working space, and it is returned by\norgbr_bufferSize()\n. Please note that the size in bytes of the working space is equal to\nsizeof(<type>)\n*\nlwork\n.\nIf output parameter\ndevInfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nAPI of orgbr\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nside\nhost\ninput\nIf\nside\n=\nCUBLAS_SIDE_LEFT\n, generate Q. if\nside\n=\nCUBLAS_SIDE_RIGHT\n, generate P**T.\nm\nhost\ninput\nNumber of rows of matrix\nQ\nor\nP**T\n.\nn\nhost\ninput\nIf\nside\n=\nCUBLAS_SIDE_LEFT\n, m>= n>= min(m,k). if\nside\n=\nCUBLAS_SIDE_RIGHT\n, n>= m>= min(n,k).\nk\nhost\ninput\nIf\nside\n=\nCUBLAS_SIDE_LEFT\n, the number of columns in the original m-by-k matrix reduced by\ngebrd\n. if\nside\n=\nCUBLAS_SIDE_RIGHT\n, the number of rows in the original k-by-n matrix reduced by\ngebrd\n.\nA\ndevice\nin/out\n<type> array of dimension\nlda\n*\nn\nOn entry, the vectors which define the elementary reflectors, as returned by\ngebrd\n. On exit, the m-by-n matrix\nQ\nor\nP**T\n.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n. lda >= max(1,m);\ntau\ndevice\ninput\n<type> array of dimension\nmin(m,k)\nif\nside\nis\nCUBLAS_SIDE_LEFT\n; of dimension\nmin(n,k)\nif\nside\nis\nCUBLAS_SIDE_RIGHT\n; tau(i) must contain the scalar factor of the elementary reflector H(i) or G(i), which determines Q or P**T, as returned by\ngebrd\nin its array argument\nTAUQ\nor\nTAUP\n.\nwork\ndevice\nin/out\nWorking space, <type> array of size\nlwork\n.\nlwork\nhost\ninput\nSize of working array\nwork\n.\ndevInfo\ndevice\noutput\nIf\ninfo\n=\n0\n, the ormqr is successful. if\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle).\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,n<0\nor wrong\nlda\n).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.3.3.\ncusolverDn<t>sytrd()\n\nThese helper functions calculate the size of work buffers needed.\ncusolverStatus_t\ncusolverDnSsytrd_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nd\n,\nconst\nfloat\n*\ne\n,\nconst\nfloat\n*\ntau\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnDsytrd_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nd\n,\nconst\ndouble\n*\ne\n,\nconst\ndouble\n*\ntau\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnChetrd_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nd\n,\nconst\nfloat\n*\ne\n,\nconst\ncuComplex\n*\ntau\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnZhetrd_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nd\n,\nconst\ndouble\n*\ne\n,\nconst\ncuDoubleComplex\n*\ntau\n,\nint\n*\nlwork\n);\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnSsytrd\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\n*\nd\n,\nfloat\n*\ne\n,\nfloat\n*\ntau\n,\nfloat\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnDsytrd\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\n*\nd\n,\ndouble\n*\ne\n,\ndouble\n*\ntau\n,\ndouble\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnChetrd\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\nfloat\n*\nd\n,\nfloat\n*\ne\n,\ncuComplex\n*\ntau\n,\ncuComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\nCUDENSEAPI\ncusolverDnZhetrd\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ndouble\n*\nd\n,\ndouble\n*\ne\n,\ncuDoubleComplex\n*\ntau\n,\ncuDoubleComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\nThis function reduces a general symmetric (Hermitian)\n\\(n \\times n\\)\nmatrix\nA\nto real symmetric tridiagonal form\nT\nby an orthogonal transformation:\n\\(Q^{H}*A*Q = T\\)\nAs an output,\nA\ncontains\nT\nand householder reflection vectors. If\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n, the diagonal and first superdiagonal of\nA\nare overwritten by the corresponding elements of the tridiagonal matrix\nT\n, and the elements above the first superdiagonal, with the array\ntau\n, represent the orthogonal matrix\nQ\nas a product of elementary reflectors; If\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n, the diagonal and first subdiagonal of\nA\nare overwritten by the corresponding elements of the tridiagonal matrix\nT\n, and the elements below the first subdiagonal, with the array\ntau\n, represent the orthogonal matrix\nQ\nas a product of elementary reflectors.\nThe user has to provide working space which is pointed by input parameter\nwork\n. The input parameter\nlwork\nis size of the working space, and it is returned by\nsytrd_bufferSize()\n. Please note that the size in bytes of the working space is equal to\nsizeof(<type>)\n*\nlwork\n.\nIf output parameter\ndevInfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle). Note that the problem size\nn\nis limited by a condition\nn*lda\n<\nINT32_MAX\nprimarily due to the current implementation constraints.\nAPI of sytrd\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nuplo\nhost\ninput\nSpecifies which part of\nA\nis stored.\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n: Lower triangle of\nA\nis stored.\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n: Upper triangle of\nA\nis stored.\nn\nhost\ninput\nNumber of rows (columns) of matrix\nA\n.\nA\ndevice\nin/out\n<type> array of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,n)\n. If\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n, the leading n-by-n upper triangular part of\nA\ncontains the upper triangular part of the matrix\nA\n, and the strictly lower triangular part of\nA\nis not referenced. If\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n, the leading n-by-n lower triangular part of\nA\ncontains the lower triangular part of the matrix\nA\n, and the strictly upper triangular part of\nA\nis not referenced. On exit,\nA\nis overwritten by\nT\nand householder reflection vectors.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nlda\n>=\nmax(1,n)\n.\nD\ndevice\noutput\nReal array of dimension\nn\n. The diagonal elements of the tridiagonal matrix\nT\n:\nD(i)\n=\nA(i,i)\n.\nE\ndevice\noutput\nReal array of dimension\n(n-1)\n. The off-diagonal elements of the tridiagonal matrix\nT\n: if\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n,\nE(i)\n=\nA(i,i+1)\n. if\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\nE(i)\n=\nA(i+1,i)\n.\ntau\ndevice\noutput\n<type> array of dimension\n(n-1)\n. The scalar factors of the elementary reflectors which represent the orthogonal matrix\nQ\n.\nwork\ndevice\nin/out\nWorking space, <type> array of size\nlwork\n.\nlwork\nhost\ninput\nSize of\nwork\n, returned by\nsytrd_bufferSize\n.\ndevInfo\ndevice\noutput\nIf\ndevInfo\n=\n0\n, the operation is successful. if\ndevInfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle).\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\n, or\nlda<max(1,n)\n, or\nuplo\nis not\nCUBLAS_FILL_MODE_LOWER\nor\nCUBLAS_FILL_MODE_UPPER\n).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.3.4.\ncusolverDn<t>ormtr()\n\nThese helper functions calculate the size of work buffers needed.\ncusolverStatus_t\ncusolverDnSormtr_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\ntau\n,\nconst\nfloat\n*\nC\n,\nint\nldc\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnDormtr_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\ntau\n,\nconst\ndouble\n*\nC\n,\nint\nldc\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnCunmtr_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\ntau\n,\nconst\ncuComplex\n*\nC\n,\nint\nldc\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnZunmtr_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\ntau\n,\nconst\ncuDoubleComplex\n*\nC\n,\nint\nldc\n,\nint\n*\nlwork\n);\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnSormtr\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\n*\ntau\n,\nfloat\n*\nC\n,\nint\nldc\n,\nfloat\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnDormtr\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\n*\ntau\n,\ndouble\n*\nC\n,\nint\nldc\n,\ndouble\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnCunmtr\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\ncuComplex\n*\ntau\n,\ncuComplex\n*\nC\n,\nint\nldc\n,\ncuComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnZunmtr\n(\ncusolverDnHandle_t\nhandle\n,\ncublasSideMode_t\nside\n,\ncublasFillMode_t\nuplo\n,\ncublasOperation_t\ntrans\n,\nint\nm\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ncuDoubleComplex\n*\ntau\n,\ncuDoubleComplex\n*\nC\n,\nint\nldc\n,\ncuDoubleComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\nThis function overwrites\n\\(m \\times n\\)\nmatrix\nC\nby\nwhere\nQ\nis a unitary matrix formed by a sequence of elementary reflection vectors from\nsytrd\n.\nThe operation on\nQ\nis defined by\nThe user has to provide working space which is pointed by input parameter\nwork\n. The input parameter\nlwork\nis size of the working space, and it is returned by\normtr_bufferSize()\n. Please note that the size in bytes of the working space is equal to\nsizeof(<type>)\n*\nlwork\n.\nIf output parameter\ndevInfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nAPI of ormtr\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nside\nhost\ninput\nside\n=\nCUBLAS_SIDE_LEFT\n, apply Q or Q**T from the Left;\nside\n=\nCUBLAS_SIDE_RIGHT\n, apply Q or Q**T from the Right.\nuplo\nhost\ninput\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n: Lower triangle of\nA\ncontains elementary reflectors from\nsytrd\n.\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n: Upper triangle of\nA\ncontains elementary reflectors from\nsytrd\n.\ntrans\nhost\ninput\nOperation\nop(Q)\nthat is non- or (conj.) transpose.\nm\nhost\ninput\nNumber of rows of matrix\nC\n.\nn\nhost\ninput\nNumber of columns of matrix\nC\n.\nA\ndevice\nin/out\n<type> array of dimension\nlda\n*\nm\nif\nside\n=\nCUBLAS_SIDE_LEFT\n;\nlda\n*\nn\nif\nside\n=\nCUBLAS_SIDE_RIGHT\n. The matrix\nA\nfrom\nsytrd\ncontains the elementary reflectors.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n. if\nside\nis\nCUBLAS_SIDE_LEFT\n, lda >= max(1,m); if\nside\nis\nCUBLAS_SIDE_RIGHT\n, lda >= max(1,n).\ntau\ndevice\noutput\n<type> array of dimension\n(m-1)\nif\nside\nis\nCUBLAS_SIDE_LEFT\n; of dimension\n(n-1)\nif\nside\nis\nCUBLAS_SIDE_RIGHT\n; The vector\ntau\nis from\nsytrd\n, so\ntau(i)\nis the scalar of i-th elementary reflection vector.\nC\ndevice\nin/out\n<type> array of size\nldc\n*\nn\n. On exit,\nC\nis overwritten by\nop(Q)*C\nor\nC*op(Q)\n.\nldc\nhost\ninput\nLeading dimension of two-dimensional array of matrix\nC\n. ldc >= max(1,m).\nwork\ndevice\nin/out\nWorking space, <type> array of size\nlwork\n.\nlwork\nhost\ninput\nSize of working array\nwork\n.\ndevInfo\ndevice\noutput\nIf\ndevInfo\n=\n0\n, the ormqr is successful. if\ndevInfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle).\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,n<0\nor wrong\nlda\nor\nldc\n).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.3.5.\ncusolverDn<t>orgtr()\n\nThese helper functions calculate the size of work buffers needed.\ncusolverStatus_t\ncusolverDnSorgtr_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\ntau\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnDorgtr_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\ntau\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnCungtr_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\ntau\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnZungtr_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\ntau\n,\nint\n*\nlwork\n);\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnSorgtr\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\ntau\n,\nfloat\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnDorgtr\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\ntau\n,\ndouble\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnCungtr\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\ntau\n,\ncuComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnZungtr\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\ntau\n,\ncuDoubleComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\nThis function generates a unitary matrix\nQ\nwhich is defined as the product of n-1 elementary reflectors of order n, as returned by\nsytrd\n:\nThe user has to provide working space which is pointed by input parameter\nwork\n. The input parameter\nlwork\nis size of the working space, and it is returned by\norgtr_bufferSize()\n. Please note that the size in bytes of the working space is equal to\nsizeof(<type>)\n*\nlwork\n.\nIf output parameter\ndevInfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nAPI of orgtr\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nuplo\nhost\ninput\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n: Lower triangle of\nA\ncontains elementary reflectors from\nsytrd\n.\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n: Upper triangle of\nA\ncontains elementary reflectors from\nsytrd\n.\nn\nhost\ninput\nNumber of rows (columns) of matrix\nQ\n.\nA\ndevice\nin/out\n<type> array of dimension\nlda\n*\nn\nOn entry, matrix\nA\nfrom\nsytrd\ncontains the elementary reflectors. On exit, matrix\nA\ncontains the n-by-n orthogonal matrix\nQ\n.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n. lda >= max(1,n).\ntau\ndevice\ninput\n<type> array of dimension\n(n-1)\ntau(i)\nis the scalar of i-th elementary reflection vector.\nwork\ndevice\nin/out\nWorking space, <type> array of size\nlwork\n.\nlwork\nhost\ninput\nSize of working array\nwork\n.\ndevInfo\ndevice\noutput\nIf\ndevInfo\n=\n0\n, the orgtr is successful. if\ndevInfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle).\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\nor wrong\nlda\n).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.3.6.\ncusolverDn<t>gesvd()\n\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverDnSgesvd_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnDgesvd_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnCgesvd_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnZgesvd_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\n*\nlwork\n);\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnSgesvd\n(\ncusolverDnHandle_t\nhandle\n,\nsigned\nchar\njobu\n,\nsigned\nchar\njobvt\n,\nint\nm\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\n*\nS\n,\nfloat\n*\nU\n,\nint\nldu\n,\nfloat\n*\nVT\n,\nint\nldvt\n,\nfloat\n*\nwork\n,\nint\nlwork\n,\nfloat\n*\nrwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnDgesvd\n(\ncusolverDnHandle_t\nhandle\n,\nsigned\nchar\njobu\n,\nsigned\nchar\njobvt\n,\nint\nm\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\n*\nS\n,\ndouble\n*\nU\n,\nint\nldu\n,\ndouble\n*\nVT\n,\nint\nldvt\n,\ndouble\n*\nwork\n,\nint\nlwork\n,\ndouble\n*\nrwork\n,\nint\n*\ndevInfo\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnCgesvd\n(\ncusolverDnHandle_t\nhandle\n,\nsigned\nchar\njobu\n,\nsigned\nchar\njobvt\n,\nint\nm\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\nfloat\n*\nS\n,\ncuComplex\n*\nU\n,\nint\nldu\n,\ncuComplex\n*\nVT\n,\nint\nldvt\n,\ncuComplex\n*\nwork\n,\nint\nlwork\n,\nfloat\n*\nrwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnZgesvd\n(\ncusolverDnHandle_t\nhandle\n,\nsigned\nchar\njobu\n,\nsigned\nchar\njobvt\n,\nint\nm\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ndouble\n*\nS\n,\ncuDoubleComplex\n*\nU\n,\nint\nldu\n,\ncuDoubleComplex\n*\nVT\n,\nint\nldvt\n,\ncuDoubleComplex\n*\nwork\n,\nint\nlwork\n,\ndouble\n*\nrwork\n,\nint\n*\ndevInfo\n);\nThis function computes the singular value decomposition (SVD) of an\n\\(m \\times n\\)\nmatrix\nA\nand corresponding the left and/or right singular vectors. The SVD is written\n\\[A = U*\\Sigma*V^{H}\\]\nwhere\nΣ\nis an\n\\(m \\times n\\)\nmatrix which is zero except for its\nmin(m,n)\ndiagonal elements,\nU\nis an\n\\(m \\times m\\)\nunitary matrix, and\nV\nis an\n\\(n \\times n\\)\nunitary matrix. The diagonal elements of\nΣ\nare the singular values of\nA\n; they are real and non-negative, and are returned in descending order. The first\nmin(m,n)\ncolumns of\nU\nand\nV\nare the left and right singular vectors of\nA\n.\nThe user has to provide working space which is pointed by input parameter\nwork\n. The input parameter\nlwork\nis size of the working space, and it is returned by\ngesvd_bufferSize()\n. Please note that the size in bytes of the working space is equal to\nsizeof(<type>)\n*\nlwork\n.\nIf output parameter\ndevInfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle). if\nbdsqr\ndid not converge,\ndevInfo\nspecifies how many superdiagonals of an intermediate bidiagonal form did not converge to zero.\nThe\nrwork\nis real array of dimension (min(m,n)-1). If\ndevInfo\n>0 and\nrwork\nis not NULL,\nrwork\ncontains the unconverged superdiagonal elements of an upper bidiagonal matrix. This is slightly different from LAPACK which puts unconverged superdiagonal elements in\nwork\nif type is\nreal\n; in\nrwork\nif type is\ncomplex\n.\nrwork\ncan be a NULL pointer if the user does not want the information from superdiagonal.\nPlease visit\ncuSOLVER Library Samples - gesvd\nfor a code example.\nRemark 1:\ngesvd\nonly supports\nm>=n\n.\nRemark 2: the routine returns\n\\(V^{H}\\)\n, not\nV\n.\nAPI of gesvd\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\njobu\nhost\ninput\nSpecifies options for computing all or part of the matrix\nU\n: = ‘A’: all m columns of U are returned in array U: = ‘S’: the first min(m,n) columns of U (the left singular vectors) are returned in the array U; = ‘O’: the first min(m,n) columns of U (the left singular vectors) are overwritten on the array A; = ‘N’: no columns of U (no left singular vectors) are computed.\njobvt\nhost\ninput\nSpecifies options for computing all or part of the matrix V**T: = ‘A’: all N rows of V**T are returned in the array VT; = ‘S’: the first min(m,n) rows of V**T (the right singular vectors) are returned in the array VT; = ‘O’: the first min(m,n) rows of V**T (the right singular vectors) are overwritten on the array A; = ‘N’: no rows of V**T (no right singular vectors) are computed.\nm\nhost\ninput\nNumber of rows of matrix\nA\n.\nn\nhost\ninput\nNumber of columns of matrix\nA\n.\nA\ndevice\nin/out\n<type> array of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,m)\n. On exit, the contents of\nA\nare destroyed.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nS\ndevice\noutput\nReal array of dimension\nmin(m,n)\n. The singular values of A, sorted so that\nS(i)\n>=\nS(i+1)\n.\nU\ndevice\noutput\n<type> array of dimension\nldu\n*\nm\nwith\nldu\nis not less than\nmax(1,m)\n.\nU\ncontains the\n\\(m \\times m\\)\nunitary matrix\nU\n.\nldu\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nU\n.\nVT\ndevice\noutput\n<type> array of dimension\nldvt\n*\nn\nwith\nldvt\nis not less than\nmax(1,n)\n.\nVT\ncontains the\n\\(n \\times n\\)\nunitary matrix V**T.\nldvt\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nVt\n.\nwork\ndevice\nin/out\nWorking space, <type> array of size\nlwork\n.\nlwork\nhost\ninput\nSize of\nwork\n, returned by\ngesvd_bufferSize\n.\nrwork\ndevice\ninput\nReal array of dimension min(m,n)-1. It contains the unconverged superdiagonal elements of an upper bidiagonal matrix if\ndevInfo\n>\n0\n.\ndevInfo\ndevice\noutput\nIf\ndevInfo\n=\n0\n, the operation is successful. if\ndevInfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle). If\ndevInfo\n>\n0\n,\ndevInfo\nindicates how many superdiagonals of an intermediate bidiagonal form did not converge to zero.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,n<0\nor\nlda<max(1,m)\nor\nldu<max(1,m)\nor\nldvt<max(1,n)\n).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.3.7.\ncusolverDn<t>gesvdj()\n\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverDnSgesvdj_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\necon\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nS\n,\nconst\nfloat\n*\nU\n,\nint\nldu\n,\nconst\nfloat\n*\nV\n,\nint\nldv\n,\nint\n*\nlwork\n,\ngesvdjInfo_t\nparams\n);\ncusolverStatus_t\ncusolverDnDgesvdj_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\necon\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nS\n,\nconst\ndouble\n*\nU\n,\nint\nldu\n,\nconst\ndouble\n*\nV\n,\nint\nldv\n,\nint\n*\nlwork\n,\ngesvdjInfo_t\nparams\n);\ncusolverStatus_t\ncusolverDnCgesvdj_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\necon\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nS\n,\nconst\ncuComplex\n*\nU\n,\nint\nldu\n,\nconst\ncuComplex\n*\nV\n,\nint\nldv\n,\nint\n*\nlwork\n,\ngesvdjInfo_t\nparams\n);\ncusolverStatus_t\ncusolverDnZgesvdj_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\necon\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nS\n,\nconst\ncuDoubleComplex\n*\nU\n,\nint\nldu\n,\nconst\ncuDoubleComplex\n*\nV\n,\nint\nldv\n,\nint\n*\nlwork\n,\ngesvdjInfo_t\nparams\n);\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnSgesvdj\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\necon\n,\nint\nm\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\n*\nS\n,\nfloat\n*\nU\n,\nint\nldu\n,\nfloat\n*\nV\n,\nint\nldv\n,\nfloat\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\ngesvdjInfo_t\nparams\n);\ncusolverStatus_t\ncusolverDnDgesvdj\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\necon\n,\nint\nm\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\n*\nS\n,\ndouble\n*\nU\n,\nint\nldu\n,\ndouble\n*\nV\n,\nint\nldv\n,\ndouble\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\ngesvdjInfo_t\nparams\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnCgesvdj\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\necon\n,\nint\nm\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\nfloat\n*\nS\n,\ncuComplex\n*\nU\n,\nint\nldu\n,\ncuComplex\n*\nV\n,\nint\nldv\n,\ncuComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\ngesvdjInfo_t\nparams\n);\ncusolverStatus_t\ncusolverDnZgesvdj\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\necon\n,\nint\nm\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ndouble\n*\nS\n,\ncuDoubleComplex\n*\nU\n,\nint\nldu\n,\ncuDoubleComplex\n*\nV\n,\nint\nldv\n,\ncuDoubleComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\ngesvdjInfo_t\nparams\n);\nThis function computes the singular value decomposition (SVD) of an\n\\(m \\times n\\)\nmatrix\nA\nand corresponding the left and/or right singular vectors. The SVD is written:\n\\[A = U*\\Sigma*V^{H}\\]\nwhere\nΣ\nis an\n\\(m \\times n\\)\nmatrix which is zero except for its\nmin(m,n)\ndiagonal elements,\nU\nis an\n\\(m \\times m\\)\nunitary matrix, and\nV\nis an\n\\(n \\times n\\)\nunitary matrix. The diagonal elements of\nΣ\nare the singular values of\nA\n; they are real and non-negative, and are returned in descending order. The first\nmin(m,n)\ncolumns of\nU\nand\nV\nare the left and right singular vectors of\nA\n.\ngesvdj\nhas the same functionality as\ngesvd\n. The difference is that\ngesvd\nuses QR algorithm and\ngesvdj\nuses Jacobi method. The parallelism of Jacobi method gives GPU better performance on small and medium size matrices. Moreover the user can configure\ngesvdj\nto perform approximation up to certain accuracy.\ngesvdj\niteratively generates a sequence of unitary matrices to transform matrix\nA\nto the following form\n\\[U^{H}*A*V = S + E\\]\nwhere\nS\nis diagonal and diagonal of\nE\nis zero.\nDuring the iterations, the Frobenius norm of\nE\ndecreases monotonically. As\nE\ngoes down to zero,\nS\nis the set of singular values. In practice, Jacobi method stops if\n\\[{\\|E\\|}_{F}\\leq\\operatorname{eps}*{\\|A\\|}_{F}\\]\nwhere\neps\nis given tolerance. Note that if the real residual norm\n\\[{\\|{S} - {U}^{H}*{A}*{V}\\|}_{F}\\]\nis computed, it will differ from\n\\({\\|{E}\\|}_{F}\\)\nup to roundoff errors of order\n\\(N = max(m, n)\\)\n, to still have the standard SVD accuracy expectation\n\\[\\frac{\\|S - U^{H} * A * V\\|_F}{O(N) * \\|A\\|_F} \\leq \\frac{\\|E\\|_F}{\\|A\\|_F} \\leq \\operatorname{eps}\\]\n\\(O(N)\\)\nis typically\n\\(N\\)\n, but the constant depends on the number of sweeps, which gives an upper roundoff error bound of\n\\(sweeps * N\\)\n.\ngesvdj\nhas two parameters to control the accuracy. First parameter is tolerance (\neps\n). The default value is machine accuracy but The user can use function\ncusolverDnXgesvdjSetTolerance\nto set a priori tolerance. The second parameter is maximum number of sweeps which controls number of iterations of Jacobi method. The default value is 100 but the user can use function\ncusolverDnXgesvdjSetMaxSweeps\nto set a proper bound. The experiments show 15 sweeps are good enough to converge to machine accuracy.\ngesvdj\nstops either tolerance is met or maximum number of sweeps is met.\nJacobi method has quadratic convergence, so the accuracy is not proportional to number of sweeps. To guarantee certain accuracy, the user should configure tolerance only.\nThe user has to provide working space which is pointed by input parameter\nwork\n. The input parameter\nlwork\nis the size of the working space, and it is returned by\ngesvdj_bufferSize()\n. Please note that the size in bytes of the working space is equal to\nsizeof(<type>)\n*\nlwork\n.\nIf output parameter\ninfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle). If\ninfo\n=\nmin(m,n)+1\n,\ngesvdj\ndoes not converge under given tolerance and maximum sweeps.\nIf the user sets an improper tolerance,\ngesvdj\nmay not converge. For example, tolerance should not be smaller than machine accuracy.\nPlease visit\ncuSOLVER Library Samples - gesvdj\nfor a code example.\nRemark 1:\ngesvdj\nsupports any combination of\nm\nand\nn\n.\nRemark 2: the routine returns\nV\n, not\n\\(V^{H}\\)\n. This is different from\ngesvd\n.\nAPI of gesvdj\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\njobz\nhost\ninput\nSpecifies options to either compute singular value only or singular vectors as well:\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n: Compute singular values only;\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n: Compute singular values and singular vectors.\necon\nhost\ninput\necon\n= 1 for economy size for\nU\nand\nV\n.\nm\nhost\ninput\nNumber of rows of matrix\nA\n.\nn\nhost\ninput\nNumber of columns of matrix\nA\n.\nA\ndevice\nin/out\n<type> array of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,m)\n. On exit, the contents of\nA\nare destroyed.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nS\ndevice\noutput\nReal array of dimension\nmin(m,n)\n. The singular values of A, sorted so that\nS(i)\n>=\nS(i+1)\n.\nU\ndevice\noutput\n<type> array of dimension\nldu\n*\nm\nif\necon\nis zero. If\necon\nis nonzero, the dimension is\nldu\n*\nmin(m,n)\n.\nU\ncontains the left singular vectors.\nldu\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nU\n.\nldu\nis not less than\nmax(1,m)\n.\nV\ndevice\noutput\n<type> array of dimension\nldv\n*\nn\nif\necon\nis zero. If\necon\nis nonzero, the dimension is\nldv\n*\nmin(m,n)\n.\nV\ncontains the right singular vectors.\nldv\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nV\n.\nldv\nis not less than\nmax(1,n)\n.\nwork\ndevice\nin/out\n<type> array of size\nlwork\n, working space.\nlwork\nhost\ninput\nSize of\nwork\n, returned by\ngesvdj_bufferSize\n.\ninfo\ndevice\noutput\nIf\ninfo\n=\n0\n, the operation is successful. if\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle). if\ninfo\n=\nmin(m,n)+1\n,\ngesvdj\ndose not converge under given tolerance and maximum sweeps.\nparams\nhost\ninput\nStructure filled with parameters of Jacobi algorithm and results of\ngesvdj\n.\nparams\ncan be destroyed after the host thread exits the routine.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,n<0\nor\nlda<max(1,m)\nor\nldu<max(1,m)\nor\nldv<max(1,n)\nor\njobz\nis not\nCUSOLVER_EIG_MODE_NOVECTOR\nor\nCUSOLVER_EIG_MODE_VECTOR\n).\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.3.8.\ncusolverDn<t>gesvdjBatched()\n\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverDnSgesvdjBatched_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nS\n,\nconst\nfloat\n*\nU\n,\nint\nldu\n,\nconst\nfloat\n*\nV\n,\nint\nldv\n,\nint\n*\nlwork\n,\ngesvdjInfo_t\nparams\n,\nint\nbatchSize\n);\ncusolverStatus_t\ncusolverDnDgesvdjBatched_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nS\n,\nconst\ndouble\n*\nU\n,\nint\nldu\n,\nconst\ndouble\n*\nV\n,\nint\nldv\n,\nint\n*\nlwork\n,\ngesvdjInfo_t\nparams\n,\nint\nbatchSize\n);\ncusolverStatus_t\ncusolverDnCgesvdjBatched_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nS\n,\nconst\ncuComplex\n*\nU\n,\nint\nldu\n,\nconst\ncuComplex\n*\nV\n,\nint\nldv\n,\nint\n*\nlwork\n,\ngesvdjInfo_t\nparams\n,\nint\nbatchSize\n);\ncusolverStatus_t\ncusolverDnZgesvdjBatched_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nS\n,\nconst\ncuDoubleComplex\n*\nU\n,\nint\nldu\n,\nconst\ncuDoubleComplex\n*\nV\n,\nint\nldv\n,\nint\n*\nlwork\n,\ngesvdjInfo_t\nparams\n,\nint\nbatchSize\n);\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnSgesvdjBatched\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\nm\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\n*\nS\n,\nfloat\n*\nU\n,\nint\nldu\n,\nfloat\n*\nV\n,\nint\nldv\n,\nfloat\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\ngesvdjInfo_t\nparams\n,\nint\nbatchSize\n);\ncusolverStatus_t\ncusolverDnDgesvdjBatched\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\nm\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\n*\nS\n,\ndouble\n*\nU\n,\nint\nldu\n,\ndouble\n*\nV\n,\nint\nldv\n,\ndouble\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\ngesvdjInfo_t\nparams\n,\nint\nbatchSize\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnCgesvdjBatched\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\nm\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\nfloat\n*\nS\n,\ncuComplex\n*\nU\n,\nint\nldu\n,\ncuComplex\n*\nV\n,\nint\nldv\n,\ncuComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\ngesvdjInfo_t\nparams\n,\nint\nbatchSize\n);\ncusolverStatus_t\ncusolverDnZgesvdjBatched\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\nm\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ndouble\n*\nS\n,\ncuDoubleComplex\n*\nU\n,\nint\nldu\n,\ncuDoubleComplex\n*\nV\n,\nint\nldv\n,\ncuDoubleComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\ngesvdjInfo_t\nparams\n,\nint\nbatchSize\n);\nThis function computes singular values and singular vectors of a sequence of general\n\\(m \\times n\\)\nmatrices\n\\[A_{j} = U_{j}*\\Sigma_{j}*V_{j}^{H}\\]\nwhere\n\\(\\Sigma_{j}\\)\nis a real\n\\(m \\times n\\)\ndiagonal matrix which is zero except for its\nmin(m,n)\ndiagonal elements.\n\\(U_{j}\\)\n(left singular vectors) is an\n\\(m \\times m\\)\nunitary matrix and\n\\(V_{j}\\)\n(right singular vectors) is a\n\\(n \\times n\\)\nunitary matrix. The diagonal elements of\n\\(\\Sigma_{j}\\)\nare the singular values of\n\\(A_{j}\\)\nin either descending order or non-sorting order.\ngesvdjBatched\nperforms\ngesvdj\non each matrix. It requires that all matrices are of the same size\nm,n\nno greater than 32 and are packed in contiguous way,\n\\[\\begin{split}A = \\begin{pmatrix}\n{A0} & {A1} & \\cdots \\\\\n\\end{pmatrix}\\end{split}\\]\nEach matrix is column-major with leading dimension\nlda\n, so the formula for random access is\n\\(A_{k}\\operatorname{(i,j)} = {A\\lbrack\\ i\\ +\\ lda*j\\ +\\ lda*n*k\\rbrack}\\)\n.\nThe parameter\nS\nalso contains singular values of each matrix in contiguous way,\n\\[\\begin{split}S = \\begin{pmatrix}\n{S0} & {S1} & \\cdots \\\\\n\\end{pmatrix}\\end{split}\\]\nThe formula for random access of\nS\nis\n\\(S_{k}\\operatorname{(j)} = {S\\lbrack\\ j\\ +\\ min(m,n)*k\\rbrack}\\)\n.\nExcept for tolerance and maximum sweeps,\ngesvdjBatched\ncan either sort the singular values in descending order (default) or chose as-is (without sorting) by the function\ncusolverDnXgesvdjSetSortEig\n. If the user packs several tiny matrices into diagonal blocks of one matrix, non-sorting option can separate singular values of those tiny matrices.\ngesvdjBatched\ncannot report residual and executed sweeps by function\ncusolverDnXgesvdjGetResidual\nand\ncusolverDnXgesvdjGetSweeps\n. Any call of the above two returns\nCUSOLVER_STATUS_NOT_SUPPORTED\n. The user needs to compute residual explicitly.\nThe user has to provide working space pointed by input parameter\nwork\n. The input parameter\nlwork\nis the size of the working space, and it is returned by\ngesvdjBatched_bufferSize()\n. Please note that the size in bytes of the working space is equal to\nsizeof(<type>)\n*\nlwork\n.\nThe output parameter\ninfo\nis an integer array of size\nbatchSize\n. If the function returns\nCUSOLVER_STATUS_INVALID_VALUE\n, the first element\ninfo[0]\n=\n-i\n(less than zero) indicates\ni-th\nparameter is wrong (not counting handle). Otherwise, if\ninfo[i]\n=\nmin(m,n)+1\n,\ngesvdjBatched\ndoes not converge on\ni-th\nmatrix under given tolerance and maximum sweeps.\nPlease visit\ncuSOLVER Library Samples - gesvdjBatched\nfor a code example.\nAPI of gesvdjBatched\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\njobz\nhost\ninput\nSpecifies options to either compute singular value only or singular vectors as well:\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n: Compute singular values only;\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n: Compute singular values and singular vectors.\nm\nhost\ninput\nNumber of rows of matrix\nAj\n.\nm\nis no greater than 32.\nn\nhost\ninput\nNumber of columns of matrix\nAj\n.\nn\nis no greater than 32.\nA\ndevice\nin/out\n<type> array of dimension\nlda\n*\nn\n*\nbatchSize\nwith\nlda\nis not less than\nmax(1,n)\n. on Exit: the contents of\nAj\nare destroyed.\nlda\nhost\ninput\nLading dimension of two-dimensional array used to store matrix\nAj\n.\nS\ndevice\noutput\nAreal array of dimension\nmin(m,n)*batchSize\n. It stores the singular values of\nAj\nin descending order or non-sorting order.\nU\ndevice\noutput\n<type> array of dimension\nldu\n*\nm\n*\nbatchSize\n.\nUj\ncontains the left singular vectors of\nAj\n.\nldu\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nUj\n.\nldu\nis not less than\nmax(1,m)\n.\nV\ndevice\noutput\n<type> array of dimension\nldv\n*\nn\n*\nbatchSize\n.\nVj\ncontains the right singular vectors of\nAj\n.\nldv\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nVj\n.\nldv\nis not less than\nmax(1,n)\n.\nwork\ndevice\nin/out\n<type> array of size\nlwork\n, working space.\nlwork\nhost\ninput\nSize of\nwork\n, returned by\ngesvdjBatched_bufferSize\n.\ninfo\ndevice\noutput\nAn integer array of dimension\nbatchSize\n. If\nCUSOLVER_STATUS_INVALID_VALUE\nis returned,\ninfo[0]\n=\n-i\n(less than zero) indicates\ni-th\nparameter is wrong (not counting handle). Otherwise, if\ninfo[i]\n=\n0\n, the operation is successful. if\ninfo[i]\n=\nmin(m,n)+1\n,\ngesvdjBatched\ndose not converge on\ni-th\nmatrix under given tolerance and maximum sweeps.\nparams\nhost\ninput\nStructure filled with parameters of Jacobi algorithm.\nparams\ncan be destroyed after the host thread exits the routine.\nbatchSize\nhost\ninput\nNumber of matrices.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,n<0\nor\nlda<max(1,m)\nor\nldu<max(1,m)\nor\nldv<max(1,n)\nor\njobz\nis not\nCUSOLVER_EIG_MODE_NOVECTOR\nor\nCUSOLVER_EIG_MODE_VECTOR\n, or\nbatchSize<0\n).\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.3.9.\ncusolverDn<t>gesvdaStridedBatched()\n\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverDnSgesvdaStridedBatched_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\nrank\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\nconst\nfloat\n*\nS\n,\nlong\nlong\nint\nstrideS\n,\nconst\nfloat\n*\nU\n,\nint\nldu\n,\nlong\nlong\nint\nstrideU\n,\nconst\nfloat\n*\nV\n,\nint\nldv\n,\nlong\nlong\nint\nstrideV\n,\nint\n*\nlwork\n,\nint\nbatchSize\n);\ncusolverStatus_t\ncusolverDnDgesvdaStridedBatched_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\nrank\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\nconst\ndouble\n*\nS\n,\nlong\nlong\nint\nstrideS\n,\nconst\ndouble\n*\nU\n,\nint\nldu\n,\nlong\nlong\nint\nstrideU\n,\nconst\ndouble\n*\nV\n,\nint\nldv\n,\nlong\nlong\nint\nstrideV\n,\nint\n*\nlwork\n,\nint\nbatchSize\n);\ncusolverStatus_t\ncusolverDnCgesvdaStridedBatched_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\nrank\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\nconst\nfloat\n*\nS\n,\nlong\nlong\nint\nstrideS\n,\nconst\ncuComplex\n*\nU\n,\nint\nldu\n,\nlong\nlong\nint\nstrideU\n,\nconst\ncuComplex\n*\nV\n,\nint\nldv\n,\nlong\nlong\nint\nstrideV\n,\nint\n*\nlwork\n,\nint\nbatchSize\n);\ncusolverStatus_t\ncusolverDnZgesvdaStridedBatched_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\nrank\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\nconst\ndouble\n*\nS\n,\nlong\nlong\nint\nstrideS\n,\nconst\ncuDoubleComplex\n*\nU\n,\nint\nldu\n,\nlong\nlong\nint\nstrideU\n,\nconst\ncuDoubleComplex\n*\nV\n,\nint\nldv\n,\nlong\nlong\nint\nstrideV\n,\nint\n*\nlwork\n,\nint\nbatchSize\n);\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnSgesvdaStridedBatched\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\nrank\n,\nint\nm\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\nfloat\n*\nS\n,\nlong\nlong\nint\nstrideS\n,\nfloat\n*\nU\n,\nint\nldu\n,\nlong\nlong\nint\nstrideU\n,\nfloat\n*\nV\n,\nint\nldv\n,\nlong\nlong\nint\nstrideV\n,\nfloat\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\ndouble\n*\nh_R_nrmF\n,\nint\nbatchSize\n);\ncusolverStatus_t\ncusolverDnDgesvdaStridedBatched\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\nrank\n,\nint\nm\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\ndouble\n*\nS\n,\nlong\nlong\nint\nstrideS\n,\ndouble\n*\nU\n,\nint\nldu\n,\nlong\nlong\nint\nstrideU\n,\ndouble\n*\nV\n,\nint\nldv\n,\nlong\nlong\nint\nstrideV\n,\ndouble\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\ndouble\n*\nh_R_nrmF\n,\nint\nbatchSize\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnCgesvdaStridedBatched\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\nrank\n,\nint\nm\n,\nint\nn\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\nfloat\n*\nS\n,\nlong\nlong\nint\nstrideS\n,\ncuComplex\n*\nU\n,\nint\nldu\n,\nlong\nlong\nint\nstrideU\n,\ncuComplex\n*\nV\n,\nint\nldv\n,\nlong\nlong\nint\nstrideV\n,\ncuComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\ndouble\n*\nh_R_nrmF\n,\nint\nbatchSize\n);\ncusolverStatus_t\ncusolverDnZgesvdaStridedBatched\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\nint\nrank\n,\nint\nm\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nlong\nlong\nint\nstrideA\n,\ndouble\n*\nS\n,\nlong\nlong\nint\nstrideS\n,\ncuDoubleComplex\n*\nU\n,\nint\nldu\n,\nlong\nlong\nint\nstrideU\n,\ncuDoubleComplex\n*\nV\n,\nint\nldv\n,\nlong\nlong\nint\nstrideV\n,\ncuDoubleComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\ndouble\n*\nh_R_nrmF\n,\nint\nbatchSize\n);\nThis function\ngesvda\n(\na\nstands for approximate) approximates the singular value decomposition of a tall skinny\n\\(m \\times n\\)\nmatrix\nA\nand corresponding the left and right singular vectors. The economy form of SVD is written by\n\\[A = U*\\Sigma*V^{H}\\]\nwhere\nΣ\nis an\n\\(n \\times n\\)\nmatrix.\nU\nis an\n\\(m \\times n\\)\nunitary matrix, and\nV\nis an\n\\(n \\times n\\)\nunitary matrix. The diagonal elements of\nΣ\nare the singular values of\nA\n; they are real and non-negative, and are returned in descending order.\nU\nand\nV\nare the left and right singular vectors of\nA\n.\ngesvda\ncomputes eigenvalues of\nA**T*A\n, or\nA**H*A\n(if\nA\nis complex), to approximate singular values and singular vectors. It generates matrices\nU\nand\nV\nand transforms the matrix\nA\nto the following form\n\\[U^{H}*A*V = S + E\\]\nwhere\nS\nis diagonal and\nE\ndepends on rounding errors. To certain conditions,\nU\n,\nV\nand\nS\napproximate singular values and singular vectors up to machine zero of single precision. In general,\nV\nis unitary,\nS\nis more accurate than\nU\n. If singular value is far from zero, then left singular vector\nU\nis accurate. In other words, the accuracy of singular values and left singular vectors depend on the distance between singular value and zero. Since the computation of\nA**T*A\n, or\nA**H*A\ncan greatly amplify errors, it is recommended to use\ngesvda\nonly with well-conditioned data.\nThe input parameter\nrank\ndecides the number of singular values and singular vectors are computed in parameter\nS\n,\nU\nand\nV\n.\nThe output parameter\nh_RnrmF\ncomputes Frobenius norm of residual. To compute\nh_RnrmF\n,\ninfo\n!=\nNULL\nis required.\n\\[A - U*S*V^{H}\\]\nif the parameter\nrank\nis equal\nn\n. Otherwise,\nh_RnrmF\nreports\n\\[{\\|}U*S*V^{H}{\\|} - {\\|S\\|}\\]\nin Frobenius norm sense, that is, how far\nU\nis from unitary.\ngesvdaStridedBatched\nperforms\ngesvda\non each matrix. It requires that all matrices are of the same size\nm,n\nand are packed in a contiguous way,\n\\[\\begin{split}A = \\begin{pmatrix}\n{A0} & {A1} & \\cdots \\\\\n\\end{pmatrix}\\end{split}\\]\nEach matrix is column-major with leading dimension\nlda\n, so the formula for random access is\n\\(A_{k}\\operatorname{(i,j)} = {A\\lbrack\\ i\\ +\\ lda*j\\ +\\ strideA*k\\rbrack}\\)\n. Similarly, the formula for random access of\nS\nis\n\\(S_{k}\\operatorname{(j)} = {S\\lbrack\\ j\\ +\\ StrideS*k\\rbrack}\\)\n, the formula for random access of\nU\nis\n\\(U_{k}\\operatorname{(i,j)} = {U\\lbrack\\ i\\ +\\ ldu*j\\ +\\ strideU*k\\rbrack}\\)\nand the formula for random access of\nV\nis\n\\(V_{k}\\operatorname{(i,j)} = {V\\lbrack\\ i\\ +\\ ldv*j\\ +\\ strideV*k\\rbrack}\\)\n.\nThe user has to provide working space which is pointed by input parameter\nwork\n. The input parameter\nlwork\nis the size of the working space, and it is returned by\ngesvdaStridedBatched_bufferSize()\n. Please note that the size in bytes of the working space is equal to\nsizeof(<type>)\n*\nlwork\n.\nThe output parameter\ninfo\nis an integer array of size\nbatchSize\n. If the function returns\nCUSOLVER_STATUS_INVALID_VALUE\n, the first element\ninfo[0]\n=\n-i\n(less than zero) indicates\ni-th\nparameter is wrong (not counting handle). Otherwise, if\ninfo[i]\n=\nmin(m,n)+1\n,\ngesvdaStridedBatched\ndid not converge on the\ni-th\nmatrix. If\n0\n<\ninfo[i]\n<\nmin(m,n)+1\n,\ngesvdaStridedBatched\ncould not compute an SVD of the\ni-th\nmatrix fully; the leading singular values\nSi[k]\n,\n0\n<=\nk\n<=\ninfo[i]-1\n, and corresponding singular vectors may still be useful. In this case, if\nh_RnrmF\nis requested,\nh_RnrmF\nreports the residual as if\nrank\nwas set to\ninfo[i]-1\n.\nNote that the problem size is limited by the condition\nbatchSize*stride{A/S/U/V}<=INT32_MAX\nprimarily due to the current implementation constraints.\nPlease visit\ncuSOLVER Library Samples - gesvdaStridedBatched\nfor a code example.\nRemark 1: The routine returns\nV\n, not\n\\(V^{H}\\)\n. This is different from\ngesvd\n.\nRemark 2: The routine only supports\nm\n>=n\n.\nRemark 3: It is recommended to use an FP64 data type, that is\nDgesvdaStridedBatched\nor\nZgesvdaStridedBatched\n.\nRemark 4: If the user is confident on the accuracy of singular values and singular vectors, for example, certain conditions hold (required singular value is far from zero), then the performance can be improved by passing a null pointer to\nh_RnrmF\n, i.e. no computation of the residual norm.\nAPI of gesvdaStridedBatched\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\njobz\nhost\ninput\nSpecifies options to either compute singular value only or singular vectors as well:\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n: Compute singular values only;\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n: Compute singular values and singular vectors.\nrank\nhost\ninput\nNumber of singular values (from largest to smallest).\nm\nhost\ninput\nNumber of rows of matrix\nAj\n.\nn\nhost\ninput\nNumber of columns of matrix\nAj\n.\nA\ndevice\ninput\n<type> array of dimension\nstrideA\n*\nbatchSize\nwith\nlda\nis not less than\nmax(1,m)\n.\nAj\nis of dimension\nm\n*\nn\n.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nAj\n.\nstrideA\nhost\ninput\nValue of type long long int that gives the address offset between\nA[i]\nand\nA[i+1]\n.\nstrideA\nis not less than\nlda*n\n.\nS\ndevice\noutput\nA real array of dimension\nstrideS*batchSize\n. It stores the singular values of\nAj\nin descending order.\nSj\nis of dimension\nrank\n*\n1\nstrideS\nhost\ninput\nValue of type long long int that gives the address offset between\nS[i]\nand\nS[i+1]\n.\nstrideS\nis not less than\nrank\n.\nU\ndevice\noutput\n<type> array of dimension\nstrideU\n*\nbatchSize\n.\nUj\ncontains the left singular vectors of\nAj\n.\nUj\nis of dimension\nm\n*\nrank\n.\nldu\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nUj\n.\nldu\nis not less than\nmax(1,m)\n.\nstrideU\nhost\ninput\nValue of type long long int that gives the address offset between\nU[i]\nand\nU[i+1]\n.\nstrideU\nis not less than\nldu*rank\n.\nV\ndevice\noutput\n<type> array of dimension\nstrideV\n*\nbatchSize\n.\nVj\ncontains the right singular vectors of\nAj\n.\nVj\nis of dimension\nn\n*\nrank\n.\nldv\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nVj\n.\nldv\nis not less than\nmax(1,n)\n.\nstrideV\nhost\ninput\nValue of type long long int that gives the address offset between\nV[i]\nand\nV[i+1]\n.\nstrideV\nis not less than\nldv*rank\n.\nwork\ndevice\nin/out\n<type> array of size\nlwork\n, working space.\nlwork\nhost\ninput\nSize of\nwork\n, returned by\ngesvdaStridedBatched_bufferSize\n.\ninfo\ndevice\noutput\nAn integer array of dimension\nbatchSize\n. If\nCUSOLVER_STATUS_INVALID_VALUE\nis returned,\ninfo[0]\n=\n-i\n(less than zero) indicates\ni-th\nparameter is wrong (not counting handle). Otherwise, if\ninfo[i]\n=\n0\n, the operation is successful. If\ninfo[i]\n=\nmin(m,n)+1\n,\ngesvdaStridedBatched\ndid not converge on the\ni-th\nmatrix. If\n0\n<\ninfo[i]\n<\nmin(m,n)+1\n,\ngesvdaStridedBatched\ncomputed only a partial SVD of the\ni-th\nmatrix.\nh_RnrmF\nhost\noutput\n<double> array of size\nbatchSize\n.\nh_RnrmF[i]\nis norm of residual of\ni-th\nmatrix. If\n0\n<\ninfo[i]\n<\nmin(m,n)+1\n,\nh_RnrmF[i]\nreports the residual as if\nrank\nof the\ni-th\nmatrix had been set to\ninfo[i]-1\n.\nbatchSize\nhost\ninput\nNumber of matrices.\nbatchSize\nis not less than 1.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,n<0\nor\nbatchSize*stride{A/S/U/V}>INT32_MAX\nor\nlda<max(1,m)\nor\nldu<max(1,m)\nor\nldv<max(1,n)\nor\nstrideA<lda*n\nor\nstrideS<rank\nor\nstrideU<ldu*rank\nor\nstrideV<ldv*rank\nor\nbatchSize<1\nor\njobz\nis not\nCUSOLVER_EIG_MODE_NOVECTOR\nor\nCUSOLVER_EIG_MODE_VECTOR\n).\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.3.10.\ncusolverDn<t>syevd()\n\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverDnSsyevd_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nW\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnDsyevd_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nW\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnCheevd_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nW\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnZheevd_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nW\n,\nint\n*\nlwork\n);\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnSsyevd\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\n*\nW\n,\nfloat\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnDsyevd\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\n*\nW\n,\ndouble\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnCheevd\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\nfloat\n*\nW\n,\ncuComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnZheevd\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ndouble\n*\nW\n,\ncuDoubleComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\nThis function computes eigenvalues and eigenvectors of a symmetric (Hermitian)\n\\(n \\times n\\)\nmatrix\nA\n. The standard symmetric eigenvalue problem is\n\\[A*V = V*\\Lambda\\]\nwhere\nΛ\nis a real\n\\(n \\times n\\)\ndiagonal matrix.\nV\nis an\n\\(n \\times n\\)\nunitary matrix. The diagonal elements of\nΛ\nare the eigenvalues of\nA\nin ascending order.\nThe user has to provide working space which is pointed by input parameter\nwork\n. The input parameter\nlwork\nis size of the working space, and it is returned by\nsyevd_bufferSize()\n. Please note that the size in bytes of the working space is equal to\nsizeof(<type>)\n*\nlwork\n.\nIf output parameter\ndevInfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle). If\ndevInfo\n=\ni\n(greater than zero),\ni\noff-diagonal elements of an intermediate tridiagonal form did not converge to zero.\nIf\njobz\n= CUSOLVER_EIG_MODE_VECTOR,\nA\ncontains the orthonormal eigenvectors of the matrix\nA\n. The eigenvectors are computed by a divide and conquer algorithm.\nPlease visit\ncuSOLVER Library Samples - syevd\nfor a code example.\nAPI of syevd\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\njobz\nhost\ninput\nSpecifies options to either compute eigenvalue only or compute eigen-pair:\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n: Compute eigenvalues only;\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n: Compute eigenvalues and eigenvectors.\nuplo\nhost\ninput\nSpecifies which part of\nA\nis stored.\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n: Lower triangle of\nA\nis stored.\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n: Upper triangle of\nA\nis stored.\nn\nhost\ninput\nNumber of rows (or columns) of matrix\nA\n.\nA\ndevice\nin/out\n<type> array of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,n)\n. If\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n, the leading n-by-n upper triangular part of\nA\ncontains the upper triangular part of the matrix\nA\n. If\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n, the leading n-by-n lower triangular part of\nA\ncontains the lower triangular part of the matrix\nA\n. On exit, if\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n, and\ndevInfo\n= 0,\nA\ncontains the orthonormal eigenvectors of the matrix\nA\n. If\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n, the contents of\nA\nare destroyed.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nW\ndevice\noutput\nA real array of dimension\nn\n. The eigenvalue values of\nA\n, in ascending order ie, sorted so that\nW(i)\n<=\nW(i+1)\n.\nwork\ndevice\nin/out\nWorking space, <type> array of size\nlwork\n.\nLwork\nhost\ninput\nSize of\nwork\n, returned by\nsyevd_bufferSize\n.\ndevInfo\ndevice\noutput\nIf\ndevInfo\n=\n0\n, the operation is successful. If\ndevInfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle). If\ndevInfo\n=\ni\n(>\n0)\n,\ndevInfo\nindicates\ni\noff-diagonal elements of an intermediate tridiagonal form did not converge to zero;\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\n, or\nlda<max(1,n)\n, or\njobz\nis not\nCUSOLVER_EIG_MODE_NOVECTOR\nor\nCUSOLVER_EIG_MODE_VECTOR\n, or\nuplo\nis not\nCUBLAS_FILL_MODE_LOWER\nor\nCUBLAS_FILL_MODE_UPPER\n).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.3.11.\ncusolverDn<t>syevdx()\n\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverDnSsyevdx_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncusolverEigRange_t\nrange\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\nvl\n,\nfloat\nvu\n,\nint\nil\n,\nint\niu\n,\nint\n*\nh_meig\n,\nconst\nfloat\n*\nW\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnDsyevdx_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncusolverEigRange_t\nrange\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\nvl\n,\ndouble\nvu\n,\nint\nil\n,\nint\niu\n,\nint\n*\nh_meig\n,\nconst\ndouble\n*\nW\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnCheevdx_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncusolverEigRange_t\nrange\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nfloat\nvl\n,\nfloat\nvu\n,\nint\nil\n,\nint\niu\n,\nint\n*\nh_meig\n,\nconst\nfloat\n*\nW\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnZheevdx_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncusolverEigRange_t\nrange\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ndouble\nvl\n,\ndouble\nvu\n,\nint\nil\n,\nint\niu\n,\nint\n*\nh_meig\n,\nconst\ndouble\n*\nW\n,\nint\n*\nlwork\n);\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnSsyevdx\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncusolverEigRange_t\nrange\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\nvl\n,\nfloat\nvu\n,\nint\nil\n,\nint\niu\n,\nint\n*\nh_meig\n,\nfloat\n*\nW\n,\nfloat\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnDsyevdx\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncusolverEigRange_t\nrange\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\nvl\n,\ndouble\nvu\n,\nint\nil\n,\nint\niu\n,\nint\n*\nh_meig\n,\ndouble\n*\nW\n,\ndouble\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnCheevdx\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncusolverEigRange_t\nrange\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\nfloat\nvl\n,\nfloat\nvu\n,\nint\nil\n,\nint\niu\n,\nint\n*\nh_meig\n,\nfloat\n*\nW\n,\ncuComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnZheevdx\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncusolverEigRange_t\nrange\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ndouble\nvl\n,\ndouble\nvu\n,\nint\nil\n,\nint\niu\n,\nint\n*\nh_meig\n,\ndouble\n*\nW\n,\ncuDoubleComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\nThis function computes all or selection of the eigenvalues and optionally eigenvectors of a symmetric (Hermitian)\n\\(n \\times n\\)\nmatrix\nA\n. The standard symmetric eigenvalue problem is:\n\\[A*V = V*\\Lambda\\]\nwhere\nΛ\nis a real\nn×h_meig\ndiagonal matrix.\nV\nis an\nn×h_meig\nunitary matrix.\nh_meig\nis the number of eigenvalues/eigenvectors computed by the routine,\nh_meig\nis equal to\nn\nwhen the whole spectrum (e.g.,\nrange\n=\nCUSOLVER_EIG_RANGE_ALL\n) is requested. The diagonal elements of\nΛ\nare the eigenvalues of\nA\nin ascending order.\nThe user has to provide working space which is pointed by input parameter\nwork\n. The input parameter\nlwork\nis size of the working space, and it is returned by\nsyevdx_bufferSize()\n. Please note that the size in bytes of the working space is equal to\nsizeof(<type>)\n*\nlwork\n.\nIf output parameter\ndevInfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle). If\ndevInfo\n=\ni\n(greater than zero),\ni\noff-diagonal elements of an intermediate tridiagonal form did not converge to zero.\nIf\njobz\n= CUSOLVER_EIG_MODE_VECTOR,\nA\ncontains the orthonormal eigenvectors of the matrix\nA\n. The eigenvectors are computed by a divide and conquer algorithm.\nPlease visit\ncuSOLVER Library Samples - syevdx\nfor a code example.\nAPI of syevdx\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\njobz\nhost\ninput\nSpecifies options to either compute eigenvalue only or compute eigen-pair:\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n: Compute eigenvalues only;\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n: Compute eigenvalues and eigenvectors.\nrange\nhost\ninput\nSpecifies options to which selection of eigenvalues and optionally eigenvectors that need to be computed:\nrange\n=\nCUSOLVER_EIG_RANGE_ALL\n: all eigenvalues/eigenvectors will be found, will becomes the classical syevd/heevd routine;\nrange\n=\nCUSOLVER_EIG_RANGE_V\n: all eigenvalues/eigenvectors in the half-open interval (vl,vu] will be found;\nrange\n=\nCUSOLVER_EIG_RANGE_I\n: the il-th through iu-th eigenvalues/eigenvectors will be found;\nuplo\nhost\ninput\nSpecifies which part of\nA\nis stored.\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n: Lower triangle of\nA\nis stored.\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n: Upper triangle of\nA\nis stored.\nn\nhost\ninput\nNumber of rows (or columns) of matrix\nA\n.\nA\ndevice\nin/out\n<type> array of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,n)\n. If\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n, the leading n-by-n upper triangular part of\nA\ncontains the upper triangular part of the matrix\nA\n. If\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n, the leading n-by-n lower triangular part of\nA\ncontains the lower triangular part of the matrix\nA\n. On exit, if\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n, and\ndevInfo\n= 0,\nA\ncontains the orthonormal eigenvectors of the matrix\nA\n. If\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n, the contents of\nA\nare destroyed.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nlda\nis not less than\nmax(1,n)\n.\nvl,vu\nhost\ninput\nReal values float or double for (C, S) or (Z, D) precision respectively. If\nrange\n=\nCUSOLVER_EIG_RANGE_V\n, the lower and upper bounds of the interval to be searched for eigenvalues. vl > vu. Not referenced if\nrange\n=\nCUSOLVER_EIG_RANGE_ALL\nor\nrange\n=\nCUSOLVER_EIG_RANGE_I\n. Note that, if eigenvalues are very close to each other, it is well known that two different eigenvalues routines might find slightly different number of eigenvalues inside the same interval. This is due to the fact that different eigenvalue algorithms, or even same algorithm but different run might find eigenvalues within some rounding error close to the machine precision. Thus, if the user wants to be sure not to miss any eigenvalue within the interval bound, we suggest that the user subtract/add epsilon (machine precision) to the interval bound such as\n(vl=vl-eps,\nvu=vu+eps]\n. This suggestion is valid for any selective routine from cuSolver or LAPACK.\nil,iu\nhost\ninput\nInteger. If\nrange\n=\nCUSOLVER_EIG_RANGE_I\n, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 <= il <=\niu\n<= n, if\nn\n> 0;\nil\n= 1 and\niu\n= 0 if\nn\n= 0. Not referenced if\nrange\n=\nCUSOLVER_EIG_RANGE_ALL\nor\nrange\n=\nCUSOLVER_EIG_RANGE_V\n.\nh_meig\nhost\noutput\nInteger. The total number of eigenvalues found. 0 <=\nh_meig\n<= n. If\nrange\n=\nCUSOLVER_EIG_RANGE_ALL\n,\nh_meig\n= n, and if\nrange\n=\nCUSOLVER_EIG_RANGE_I\n,\nh_meig\n=\niu-il\n+1.\nW\ndevice\noutput\nA real array of dimension\nn\n. The eigenvalue values of\nA\n, in ascending order ie, sorted so that\nW(i)\n<=\nW(i+1)\n.\nwork\ndevice\nin/out\nWorking space, <type> array of size\nlwork\n.\nlwork\nhost\ninput\nSize of\nwork\n, returned by\nsyevdx_bufferSize\n.\ndevInfo\ndevice\noutput\nIf\ndevInfo\n=\n0\n, the operation is successful. If\ndevInfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle). If\ndevInfo\n=\ni\n(>\n0)\n,\ndevInfo\nindicates\ni\noff-diagonal elements of an intermediate tridiagonal form did not converge to zero.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\n, or\nlda<max(1,n)\n, or\njobz\nis not\nCUSOLVER_EIG_MODE_NOVECTOR\nor\nCUSOLVER_EIG_MODE_VECTOR\n, or\nrange\nis not\nCUSOLVER_EIG_RANGE_ALL\nor\nCUSOLVER_EIG_RANGE_V\nor\nCUSOLVER_EIG_RANGE_I\n, or\nuplo\nis not\nCUBLAS_FILL_MODE_LOWER\nor\nCUBLAS_FILL_MODE_UPPER\n).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.3.12.\ncusolverDn<t>sygvd()\n\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverDnSsygvd_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nB\n,\nint\nldb\n,\nconst\nfloat\n*\nW\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnDsygvd_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nB\n,\nint\nldb\n,\nconst\ndouble\n*\nW\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnChegvd_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\nB\n,\nint\nldb\n,\nconst\nfloat\n*\nW\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnZhegvd_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\nconst\ndouble\n*\nW\n,\nint\n*\nlwork\n);\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnSsygvd\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\n*\nB\n,\nint\nldb\n,\nfloat\n*\nW\n,\nfloat\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnDsygvd\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\n*\nB\n,\nint\nldb\n,\ndouble\n*\nW\n,\ndouble\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnChegvd\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\ncuComplex\n*\nB\n,\nint\nldb\n,\nfloat\n*\nW\n,\ncuComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnZhegvd\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\ndouble\n*\nW\n,\ncuDoubleComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\nThis function computes eigenvalues and eigenvectors of a symmetric (Hermitian)\n\\(n \\times n\\)\nmatrix-pair (\nA\n,\nB\n). The generalized symmetric-definite eigenvalue problem is\nwhere the matrix\nB\nis positive definite.\nΛ\nis a real\n\\(n \\times n\\)\ndiagonal matrix. The diagonal elements of\nΛ\nare the eigenvalues of (\nA\n,\nB\n) in ascending order.\nV\nis an\n\\(n \\times n\\)\northogonal matrix. The eigenvectors are normalized as follows:\nThe user has to provide working space which is pointed by input parameter\nwork\n. The input parameter\nlwork\nis size of the working space, and it is returned by\nsygvd_bufferSize()\n. Please note that the size in bytes of the working space is equal to\nsizeof(<type>)\n*\nlwork\n.\nIf output parameter\ndevInfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle). If\ndevInfo\n=\ni\n(i > 0 and i<=n) and\njobz\n= CUSOLVER_EIG_MODE_NOVECTOR,\ni\noff-diagonal elements of an intermediate tridiagonal form did not converge to zero. If\ndevInfo\n=\nN\n+\ni\n(i > 0), then the leading minor of order\ni\nof\nB\nis not positive definite. The factorization of\nB\ncould not be completed and no eigenvalues or eigenvectors were computed.\nif\njobz\n= CUSOLVER_EIG_MODE_VECTOR,\nA\ncontains the orthogonal eigenvectors of the matrix\nA\n. The eigenvectors are computed by divide and conquer algorithm.\nPlease visit\ncuSOLVER Library Samples - sygvd\nfor a code example.\nAPI of sygvd\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nitype\nhost\ninput\nSpecifies the problem type to be solved:\nitype\n=CUSOLVER_EIG_TYPE_1: A*x = (lambda)*B*x.\nitype\n=CUSOLVER_EIG_TYPE_2: A*B*x = (lambda)*x.\nitype\n=CUSOLVER_EIG_TYPE_3: B*A*x = (lambda)*x.\njobz\nhost\ninput\nSpecifies options to either compute eigenvalue only or compute eigen-pair:\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n: Compute eigenvalues only;\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n: Compute eigenvalues and eigenvectors.\nuplo\nhost\ninput\nSpecifies which part of\nA\nand\nB\nare stored.\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n: Lower triangle of\nA\nand\nB\nare stored.\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n: Upper triangle of\nA\nand\nB\nare stored.\nn\nhost\ninput\nNumber of rows (or columns) of matrix\nA\nand\nB\n.\nA\ndevice\nin/out\n<type> array of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,n)\n. If\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n, the leading n-by-n upper triangular part of\nA\ncontains the upper triangular part of the matrix\nA\n. If\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n, the leading n-by-n lower triangular part of\nA\ncontains the lower triangular part of the matrix\nA\n. On exit, if\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n, and\ndevInfo\n= 0,\nA\ncontains the orthonormal eigenvectors of the matrix\nA\n. If\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n, the contents of\nA\nare destroyed.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nlda\nis not less than\nmax(1,n)\n.\nB\ndevice\nin/out\n<type> array of dimension\nldb\n*\nn\n. If\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n, the leading n-by-n upper triangular part of\nB\ncontains the upper triangular part of the matrix\nB\n. If\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n, the leading n-by-n lower triangular part of\nB\ncontains the lower triangular part of the matrix\nB\n. On exit, if\ndevInfo\nis less than\nn\n,\nB\nis overwritten by triangular factor\nU\nor\nL\nfrom the Cholesky factorization of\nB\n.\nldb\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nB\n.\nldb\nis not less than\nmax(1,n)\n.\nW\ndevice\noutput\nA real array of dimension\nn\n. The eigenvalue values of\nA\n, sorted so that\nW(i)\n>=\nW(i+1)\n.\nwork\ndevice\nin/out\nWorking space, <type> array of size\nlwork\n.\nLwork\nhost\ninput\nSize of\nwork\n, returned by\nsygvd_bufferSize\n.\ndevInfo\ndevice\noutput\nIf\ndevInfo\n=\n0\n, the operation is successful. If\ndevInfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle). If\ndevInfo\n=\ni\n(>\n0)\n,\ndevInfo\nindicates either\npotrf\nor\nsyevd\nis wrong.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\n, or\nlda<max(1,n)\n, or\nldb<max(1,n)\n, or\nitype\nis not 1, 2 or 3, or\njobz\nis not\nCUSOLVER_EIG_MODE_NOVECTOR\nor\nCUSOLVER_EIG_MODE_VECTOR\n, or\nuplo\nis not\nCUBLAS_FILL_MODE_LOWER\nor\nCUBLAS_FILL_MODE_UPPER\n).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.3.13.\ncusolverDn<t>sygvdx()\n\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverDnSsygvdx_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncusolverEigRange_t\nrange\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nB\n,\nint\nldb\n,\nfloat\nvl\n,\nfloat\nvu\n,\nint\nil\n,\nint\niu\n,\nint\n*\nh_meig\n,\nconst\nfloat\n*\nW\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnDsygvdx_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncusolverEigRange_t\nrange\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nB\n,\nint\nldb\n,\ndouble\nvl\n,\ndouble\nvu\n,\nint\nil\n,\nint\niu\n,\nint\n*\nh_meig\n,\nconst\ndouble\n*\nW\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnChegvdx_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncusolverEigRange_t\nrange\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\nB\n,\nint\nldb\n,\nfloat\nvl\n,\nfloat\nvu\n,\nint\nil\n,\nint\niu\n,\nint\n*\nh_meig\n,\nconst\nfloat\n*\nW\n,\nint\n*\nlwork\n);\ncusolverStatus_t\ncusolverDnZhegvdx_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncusolverEigRange_t\nrange\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\ndouble\nvl\n,\ndouble\nvu\n,\nint\nil\n,\nint\niu\n,\nint\n*\nh_meig\n,\nconst\ndouble\n*\nW\n,\nint\n*\nlwork\n);\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnSsygvdx\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncusolverEigRange_t\nrange\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\n*\nB\n,\nint\nldb\n,\nfloat\nvl\n,\nfloat\nvu\n,\nint\nil\n,\nint\niu\n,\nint\n*\nh_meig\n,\nfloat\n*\nW\n,\nfloat\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnDsygvdx\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncusolverEigRange_t\nrange\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\n*\nB\n,\nint\nldb\n,\ndouble\nvl\n,\ndouble\nvu\n,\nint\nil\n,\nint\niu\n,\nint\n*\nh_meig\n,\ndouble\n*\nW\n,\ndouble\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnChegvdx\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncusolverEigRange_t\nrange\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\ncuComplex\n*\nB\n,\nint\nldb\n,\nfloat\nvl\n,\nfloat\nvu\n,\nint\nil\n,\nint\niu\n,\nint\n*\nh_meig\n,\nfloat\n*\nW\n,\ncuComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\ncusolverStatus_t\ncusolverDnZhegvdx\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncusolverEigRange_t\nrange\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\ndouble\nvl\n,\ndouble\nvu\n,\nint\nil\n,\nint\niu\n,\nint\n*\nh_meig\n,\ndouble\n*\nW\n,\ncuDoubleComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ndevInfo\n);\nThis function computes all or selection of the eigenvalues and optionally eigenvectors of a symmetric (Hermitian)\n\\(n \\times n\\)\nmatrix-pair (\nA\n,\nB\n). The generalized symmetric-definite eigenvalue problem is\nwhere the matrix\nB\nis positive definite.\nΛ\nis a real\n\\(n \\times {h\\_meig}\\)\ndiagonal matrix. The diagonal elements of\nΛ\nare the eigenvalues of (\nA\n,\nB\n) in ascending order.\nV\nis an\n\\(n \\times {h\\_meig}\\)\northogonal matrix.\nh_meig\nis the number of eigenvalues/eigenvectors computed by the routine,\nh_meig\nis equal to\nn\nwhen the whole spectrum (for example,\nrange\n=\nCUSOLVER_EIG_RANGE_ALL\n) is requested. The eigenvectors are normalized as follows:\nThe user has to provide working space which is pointed by input parameter\nwork\n. The input parameter\nlwork\nis size of the working space, and it is returned by\nsygvdx_bufferSize()\n. Please note that the size in bytes of the working space is equal to\nsizeof(<type>)\n*\nlwork\n.\nIf output parameter\ndevInfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle). If\ndevInfo\n=\ni\n(i > 0 and i<=n) and\njobz\n= CUSOLVER_EIG_MODE_NOVECTOR,\ni\noff-diagonal elements of an intermediate tridiagonal form did not converge to zero. If\ndevInfo\n=\nn\n+\ni\n(i > 0), then the leading minor of order\ni\nof\nB\nis not positive definite. The factorization of\nB\ncould not be completed and no eigenvalues or eigenvectors were computed.\nIf\njobz\n= CUSOLVER_EIG_MODE_VECTOR,\nA\ncontains the orthogonal eigenvectors of the matrix\nA\n. The eigenvectors are computed by divide and conquer algorithm.\nPlease visit\ncuSOLVER Library Samples - sygvdx\nfor a code example.\nAPI of sygvdx\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nitype\nhost\ninput\nSpecifies the problem type to be solved:\nitype\n=CUSOLVER_EIG_TYPE_1: A*x = (lambda)*B*x\nitype\n=CUSOLVER_EIG_TYPE_2: A*B*x = (lambda)*x\nitype\n=CUSOLVER_EIG_TYPE_3: B*A*x = (lambda)*x\njobz\nhost\ninput\nSpecifies options to either compute eigenvalue only or compute eigen-pair:\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n: Compute eigenvalues only;\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n: Compute eigenvalues and eigenvectors.\nrange\nhost\ninput\nSpecifies options to which selection of eigenvalues and optionally eigenvectors that need to be computed:\nrange\n=\nCUSOLVER_EIG_RANGE_ALL\n: all eigenvalues/eigenvectors will be found, will becomes the classical syevd/heevd routine;\nrange\n=\nCUSOLVER_EIG_RANGE_V\n: all eigenvalues/eigenvectors in the half-open interval\n(vl,vu]\nwill be found;\nrange\n=\nCUSOLVER_EIG_RANGE_I\n: the il-th through iu-th eigenvalues/eigenvectors will be found;\nuplo\nhost\ninput\nSpecifies which part of\nA\nand\nB\nare stored.\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n: Lower triangle of\nA\nand\nB\nare stored.\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n: Upper triangle of\nA\nand\nB\nare stored.\nn\nhost\ninput\nNumber of rows (or columns) of matrix\nA\nand\nB\n.\nA\ndevice\nin/out\n<type> array of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,n)\n. If\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n, the leading n-by-n upper triangular part of\nA\ncontains the upper triangular part of the matrix\nA\n. If\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n, the leading n-by-n lower triangular part of\nA\ncontains the lower triangular part of the matrix\nA\n. On exit, if\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n, and\ndevInfo\n= 0,\nA\ncontains the orthonormal eigenvectors of the matrix\nA\n. If\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n, the contents of\nA\nare destroyed.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nlda\nis not less than\nmax(1,n)\n.\nB\ndevice\nin/out\n<type> array of dimension\nldb\n*\nn\n. If\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n, the leading n-by-n upper triangular part of\nB\ncontains the upper triangular part of the matrix\nB\n. If\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n, the leading n-by-n lower triangular part of\nB\ncontains the lower triangular part of the matrix\nB\n. On exit, if\ndevInfo\nis less than\nn\n,\nB\nis overwritten by triangular factor\nU\nor\nL\nfrom the Cholesky factorization of\nB\n.\nldb\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nB\n.\nldb\nis not less than\nmax(1,n)\n.\nvl,vu\nhost\ninput\nReal values float or double for (C, S) or (Z, D) precision respectively. If\nrange\n=\nCUSOLVER_EIG_RANGE_V\n, the lower and upper bounds of the interval to be searched for eigenvalues. vl > vu. Not referenced if\nrange\n=\nCUSOLVER_EIG_RANGE_ALL\nor\nrange\n=\nCUSOLVER_EIG_RANGE_I\n. Note that, if eigenvalues are very close to each other, it is well known that two different eigenvalues routines might find slightly different number of eigenvalues inside the same interval. This is due to the fact that different eigenvalue algorithms, or even same algorithm but different run might find eigenvalues within some rounding error close to the machine precision. Thus, if the user want to be sure not to miss any eigenvalue within the interval bound, we suggest that, the user subtract/add epsilon (machine precision) to the interval bound such as (\nvl\n=\nvl\n-\neps\n,\nvu\n=\nvu\n+\neps\n]. this suggestion is valid for any selective routine from cuSolver or LAPACK.\nil,iu\nhost\ninput\nInteger. If\nrange\n=\nCUSOLVER_EIG_RANGE_I\n, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 <=\nil\n<=\niu\n<=\nn\n, if\nn\n> 0;\nil\n= 1 and\niu\n= 0 if\nn\n= 0. Not referenced if\nrange\n=\nCUSOLVER_EIG_RANGE_ALL\nor\nrange\n=\nCUSOLVER_EIG_RANGE_V\n.\nh_meig\nhost\noutput\nInteger. The total number of eigenvalues found. 0 <= h_meig <= n. If\nrange\n=\nCUSOLVER_EIG_RANGE_ALL\n, h_meig = n, and if\nrange\n=\nCUSOLVER_EIG_RANGE_I\n, h_meig = iu-il+1.\nW\ndevice\noutput\nA real array of dimension\nn\n. The eigenvalue values of\nA\n, sorted so that\nW(i)\n>=\nW(i+1)\n.\nwork\ndevice\nin/out\nWorking space, <type> array of size\nlwork\n.\nlwork\nhost\ninput\nSize of\nwork\n, returned by\nsygvdx_bufferSize\n.\ndevInfo\ndevice\noutput\nIf\ndevInfo\n=\n0\n, the operation is successful. If\ndevInfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle). If\ndevInfo\n=\ni\n(>\n0)\n,\ndevInfo\nindicates either\npotrf\nor\nsyevd\nis wrong.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\n, or\nlda<max(1,n)\n, or\nldb<max(1,n)\n, or\nitype\nis not\nCUSOLVER_EIG_TYPE_1\nor\nCUSOLVER_EIG_TYPE_2\nor\nCUSOLVER_EIG_TYPE_3\nor\njobz\nis not\nCUSOLVER_EIG_MODE_NOVECTOR\nor\nCUSOLVER_EIG_MODE_VECTORL\n, or\nrange\nis not\nCUSOLVER_EIG_RANGE_ALL\nor\nCUSOLVER_EIG_RANGE_V\nor\nCUSOLVER_EIG_RANGE_I\n, or\nuplo\nis not\nCUBLAS_FILL_MODE_LOWER\nor\nCUBLAS_FILL_MODE_UPPER\n).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.3.14.\ncusolverDn<t>syevj()\n\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverDnSsyevj_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nW\n,\nint\n*\nlwork\n,\nsyevjInfo_t\nparams\n);\ncusolverStatus_t\ncusolverDnDsyevj_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nW\n,\nint\n*\nlwork\n,\nsyevjInfo_t\nparams\n);\ncusolverStatus_t\ncusolverDnCheevj_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nW\n,\nint\n*\nlwork\n,\nsyevjInfo_t\nparams\n);\ncusolverStatus_t\ncusolverDnZheevj_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nW\n,\nint\n*\nlwork\n,\nsyevjInfo_t\nparams\n);\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnSsyevj\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\n*\nW\n,\nfloat\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\nsyevjInfo_t\nparams\n);\ncusolverStatus_t\ncusolverDnDsyevj\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\n*\nW\n,\ndouble\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\nsyevjInfo_t\nparams\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnCheevj\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\nfloat\n*\nW\n,\ncuComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\nsyevjInfo_t\nparams\n);\ncusolverStatus_t\ncusolverDnZheevj\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ndouble\n*\nW\n,\ncuDoubleComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\nsyevjInfo_t\nparams\n);\nThis function computes eigenvalues and eigenvectors of a symmetric (Hermitian)\n\\(n \\times n\\)\nmatrix\nA\n. The standard symmetric eigenvalue problem is\n\\[A*Q = Q*\\Lambda\\]\nwhere\nΛ\nis a real\n\\(n \\times n\\)\ndiagonal matrix.\nQ\nis an\n\\(n \\times n\\)\nunitary matrix. The diagonal elements of\nΛ\nare the eigenvalues of\nA\nin ascending order.\nsyevj\nhas the same functionality as\nsyevd\n. The difference is that\nsyevd\nuses QR algorithm and\nsyevj\nuses Jacobi method. The parallelism of Jacobi method gives GPU better performance on small and medium size matrices. Moreover the user can configure\nsyevj\nto perform approximation up to certain accuracy.\nHow does it work?\nsyevj\niteratively generates a sequence of unitary matrices to transform matrix\nA\nto the following form\n\\[V^{H}*A*V = W + E\\]\nwhere\nW\nis diagonal and\nE\nis symmetric without diagonal.\nDuring the iterations, the Frobenius norm of\nE\ndecreases monotonically. As\nE\ngoes down to zero,\nW\nis the set of eigenvalues. In practice, Jacobi method stops if\n\\[{\\|E\\|}_{F}\\leq\\operatorname{eps}*{\\|A\\|}_{F}\\]\nwhere\neps\nis the given tolerance.\nsyevj\nhas two parameters to control the accuracy. First parameter is tolerance (\neps\n). The default value is machine accuracy but The user can use function\ncusolverDnXsyevjSetTolerance\nto set a priori tolerance. The second parameter is maximum number of sweeps which controls number of iterations of Jacobi method. The default value is 100 but the user can use function\ncusolverDnXsyevjSetMaxSweeps\nto set a proper bound. The experiments show 15 sweeps are good enough to converge to machine accuracy.\nsyevj\nstops either tolerance is met or maximum number of sweeps is met.\nThe Jacobi method has quadratic convergence, so the accuracy is not proportional to number of sweeps. To guarantee certain accuracy, the user should configure tolerance only.\nAfter\nsyevj\n, the user can query residual by function\ncusolverDnXsyevjGetResidual\nand number of executed sweeps by function\ncusolverDnXsyevjGetSweeps\n. However the user needs to be aware that residual is the Frobenius norm of\nE\n, not accuracy of individual eigenvalue, i.e.\n\\[{residual}={\\|E\\|}_{F} = {{\\|}\\Lambda - W{\\|}}_{F}\\]\nThe same as\nsyevd\n, the user has to provide working space pointed by input parameter\nwork\n. The input parameter\nlwork\nis the size of the working space, and it is returned by\nsyevj_bufferSize()\n. Please note that the size in bytes of the working space is equal to\nsizeof(<type>)\n*\nlwork\n.\nIf output parameter\ninfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle). If\ninfo\n=\nn+1\n,\nsyevj\ndoes not converge under given tolerance and maximum sweeps.\nIf the user sets an improper tolerance,\nsyevj\nmay not converge. For example, tolerance should not be smaller than machine accuracy.\nIf\njobz\n= CUSOLVER_EIG_MODE_VECTOR,\nA\ncontains the orthonormal eigenvectors\nV\n.\nPlease visit\ncuSOLVER Library Samples - syevj\nfor a code example.\nAPI of syevj\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\njobz\nhost\ninput\nSpecifies options to either compute eigenvalue only or compute eigen-pair:\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n: Compute eigenvalues only;\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n: Compute eigenvalues and eigenvectors.\nuplo\nhost\ninput\nSpecifies which part of\nA\nis stored.\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n: Lower triangle of\nA\nis stored.\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n: Upper triangle of\nA\nis stored.\nn\nhost\ninput\nNumber of rows (or columns) of matrix\nA\n.\nA\ndevice\nin/out\n<type> array of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,n)\n. If\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n, the leading n-by-n upper triangular part of\nA\ncontains the upper triangular part of the matrix\nA\n. If\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n, the leading n-by-n lower triangular part of\nA\ncontains the lower triangular part of the matrix\nA\n. On exit, if\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n, and\ninfo\n= 0,\nA\ncontains the orthonormal eigenvectors of the matrix\nA\n. If\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n, the contents of\nA\nare destroyed.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nW\ndevice\noutput\nA real array of dimension\nn\n. The eigenvalue values of\nA\n, in ascending order ie, sorted so that\nW(i)\n<=\nW(i+1)\n.\nwork\ndevice\nin/out\nWorking space, <type> array of size\nlwork\n.\nlwork\nhost\ninput\nSize of\nwork\n, returned by\nsyevj_bufferSize\n.\ninfo\ndevice\noutput\nIf\ninfo\n=\n0\n, the operation is successful. If\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle). If\ninfo\n=\nn+1\n,\nsyevj\ndoes not converge under given tolerance and maximum sweeps.\nparams\nhost\nin/out\nStructure filled with parameters of Jacobi algorithm and results of\nsyevj\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\n, or\nlda<max(1,n)\n, or\njobz\nis not\nCUSOLVER_EIG_MODE_NOVECTOR\nor\nCUSOLVER_EIG_MODE_VECTOR\n, or\nuplo\nis not\nCUBLAS_FILL_MODE_LOWER\nor\nCUBLAS_FILL_MODE_UPPER\n).\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.3.15.\ncusolverDn<t>sygvj()\n\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverDnSsygvj_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nB\n,\nint\nldb\n,\nconst\nfloat\n*\nW\n,\nint\n*\nlwork\n,\nsyevjInfo_t\nparams\n);\ncusolverStatus_t\ncusolverDnDsygvj_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nB\n,\nint\nldb\n,\nconst\ndouble\n*\nW\n,\nint\n*\nlwork\n,\nsyevjInfo_t\nparams\n);\ncusolverStatus_t\ncusolverDnChegvj_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuComplex\n*\nB\n,\nint\nldb\n,\nconst\nfloat\n*\nW\n,\nint\n*\nlwork\n,\nsyevjInfo_t\nparams\n);\ncusolverStatus_t\ncusolverDnZhegvj_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\nconst\ndouble\n*\nW\n,\nint\n*\nlwork\n,\nsyevjInfo_t\nparams\n);\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnSsygvj\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\n*\nB\n,\nint\nldb\n,\nfloat\n*\nW\n,\nfloat\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\nsyevjInfo_t\nparams\n);\ncusolverStatus_t\ncusolverDnDsygvj\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\n*\nB\n,\nint\nldb\n,\ndouble\n*\nW\n,\ndouble\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\nsyevjInfo_t\nparams\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnChegvj\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\ncuComplex\n*\nB\n,\nint\nldb\n,\nfloat\n*\nW\n,\ncuComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\nsyevjInfo_t\nparams\n);\ncusolverStatus_t\ncusolverDnZhegvj\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigType_t\nitype\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ncuDoubleComplex\n*\nB\n,\nint\nldb\n,\ndouble\n*\nW\n,\ncuDoubleComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\nsyevjInfo_t\nparams\n);\nThis function computes eigenvalues and eigenvectors of a symmetric (Hermitian)\n\\(n \\times n\\)\nmatrix-pair (\nA\n,\nB\n). The generalized symmetric-definite eigenvalue problem is\nwhere the matrix\nB\nis positive definite.\nΛ\nis a real\n\\(n \\times n\\)\ndiagonal matrix. The diagonal elements of\nΛ\nare the eigenvalues of (\nA\n,\nB\n) in ascending order.\nV\nis an\n\\(n \\times n\\)\northogonal matrix. The eigenvectors are normalized as follows:\nThis function has the same functionality as\nsygvd\nexcept that\nsyevd\nin\nsygvd\nis replaced by\nsyevj\nin\nsygvj\n. Therefore,\nsygvj\ninherits properties of\nsyevj\n, the user can use\ncusolverDnXsyevjSetTolerance\nand\ncusolverDnXsyevjSetMaxSweeps\nto configure tolerance and maximum sweeps.\nHowever the meaning of residual is different from\nsyevj\n.\nsygvj\nfirst computes Cholesky factorization of matrix\nB\n,\n\\[B = L*L^{H}\\]\ntransform the problem to standard eigenvalue problem, then calls\nsyevj\n.\nFor example, the standard eigenvalue problem of type I is\n\\[M*Q = Q*\\Lambda\\]\nwhere matrix\nM\nis symmetric\n\\[M = L^{-1}*A*L^{-H}\\]\nThe residual is the result of\nsyevj\non matrix\nM\n, not\nA\n.\nThe user has to provide working space which is pointed by input parameter\nwork\n. The input parameter\nlwork\nis the size of the working space, and it is returned by\nsygvj_bufferSize()\n. Please note that the size in bytes of the working space is equal to\nsizeof(<type>)\n*\nlwork\n.\nIf output parameter\ninfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle). If\ninfo\n=\ni\n(i > 0 and i<=n),\nB\nis not positive definite, the factorization of\nB\ncould not be completed and no eigenvalues or eigenvectors were computed. If\ninfo\n=\nn+1\n,\nsyevj\ndoes not converge under given tolerance and maximum sweeps. In this case, the eigenvalues and eigenvectors are still computed because non-convergence comes from improper tolerance of maximum sweeps.\nif\njobz\n= CUSOLVER_EIG_MODE_VECTOR,\nA\ncontains the orthogonal eigenvectors\nV\n.\nPlease visit\ncuSOLVER Library Samples - sygvj\nfor a code example.\nAPI of sygvj\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nitype\nhost\ninput\nSpecifies the problem type to be solved:\nitype\n=CUSOLVER_EIG_TYPE_1: A*x = (lambda)*B*x.\nitype\n=CUSOLVER_EIG_TYPE_2: A*B*x = (lambda)*x.\nitype\n=CUSOLVER_EIG_TYPE_3: B*A*x = (lambda)*x.\njobz\nhost\ninput\nSpecifies options to either compute eigenvalue only or compute eigen-pair:\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n: Compute eigenvalues only;\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n: Compute eigenvalues and eigenvectors.\nuplo\nhost\ninput\nSpecifies which part of\nA\nand\nB\nare stored.\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n: Lower triangle of\nA\nand\nB\nare stored.\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n: Upper triangle of\nA\nand\nB\nare stored.\nn\nhost\ninput\nNumber of rows (or columns) of matrix\nA\nand\nB\n.\nA\ndevice\nin/out\n<type> array of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,n)\n. If\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n, the leading n-by-n upper triangular part of\nA\ncontains the upper triangular part of the matrix\nA\n. If\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n, the leading n-by-n lower triangular part of\nA\ncontains the lower triangular part of the matrix\nA\n. On exit, if\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n, and\ninfo\n= 0,\nA\ncontains the orthonormal eigenvectors of the matrix\nA\n. If\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n, the contents of\nA\nare destroyed.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nlda\nis not less than\nmax(1,n)\n.\nB\ndevice\nin/out\n<type> array of dimension\nldb\n*\nn\n. If\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n, the leading n-by-n upper triangular part of\nB\ncontains the upper triangular part of the matrix\nB\n. If\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n, the leading n-by-n lower triangular part of\nB\ncontains the lower triangular part of the matrix\nB\n. On exit, if\ninfo\nis less than\nn\n,\nB\nis overwritten by triangular factor\nU\nor\nL\nfrom the Cholesky factorization of\nB\n.\nldb\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nB\n.\nldb\nis not less than\nmax(1,n)\n.\nW\ndevice\noutput\nA real array of dimension\nn\n. The eigenvalue values of\nA\n, sorted so that\nW(i)\n>=\nW(i+1)\n.\nwork\ndevice\nin/out\nWorking space, <type> array of size\nlwork\n.\nlwork\nhost\ninput\nSize of\nwork\n, returned by\nsygvj_bufferSize\n.\ninfo\ndevice\noutput\nIf\ninfo\n=\n0\n, the operation is successful. if\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle). If\ninfo\n=\ni\n(>\n0)\n,\ninfo\nindicates either\nB\nis not positive definite or\nsyevj\n(called by\nsygvj\n) does not converge.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\n, or\nlda<max(1,n)\n, or\nldb<max(1,n)\n, or\nitype\nis not 1, 2 or 3, or\njobz\nis not\nCUSOLVER_EIG_MODE_NOVECTOR\nor\nCUSOLVER_EIG_MODE_VECTOR\n, or\nuplo\nis not\nCUBLAS_FILL_MODE_LOWER\nor\nCUBLAS_FILL_MODE_UPPER\n).\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.3.16.\ncusolverDn<t>syevjBatched()\n\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverDnSsyevjBatched_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\nfloat\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nW\n,\nint\n*\nlwork\n,\nsyevjInfo_t\nparams\n,\nint\nbatchSize\n);\ncusolverStatus_t\ncusolverDnDsyevjBatched_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ndouble\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nW\n,\nint\n*\nlwork\n,\nsyevjInfo_t\nparams\n,\nint\nbatchSize\n);\ncusolverStatus_t\ncusolverDnCheevjBatched_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuComplex\n*\nA\n,\nint\nlda\n,\nconst\nfloat\n*\nW\n,\nint\n*\nlwork\n,\nsyevjInfo_t\nparams\n,\nint\nbatchSize\n);\ncusolverStatus_t\ncusolverDnZheevjBatched_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nconst\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\nconst\ndouble\n*\nW\n,\nint\n*\nlwork\n,\nsyevjInfo_t\nparams\n,\nint\nbatchSize\n);\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnSsyevjBatched\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nfloat\n*\nA\n,\nint\nlda\n,\nfloat\n*\nW\n,\nfloat\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\nsyevjInfo_t\nparams\n,\nint\nbatchSize\n);\ncusolverStatus_t\ncusolverDnDsyevjBatched\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ndouble\n*\nA\n,\nint\nlda\n,\ndouble\n*\nW\n,\ndouble\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\nsyevjInfo_t\nparams\n,\nint\nbatchSize\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverDnCheevjBatched\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuComplex\n*\nA\n,\nint\nlda\n,\nfloat\n*\nW\n,\ncuComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\nsyevjInfo_t\nparams\n,\nint\nbatchSize\n);\ncusolverStatus_t\ncusolverDnZheevjBatched\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\ncuDoubleComplex\n*\nA\n,\nint\nlda\n,\ndouble\n*\nW\n,\ncuDoubleComplex\n*\nwork\n,\nint\nlwork\n,\nint\n*\ninfo\n,\nsyevjInfo_t\nparams\n,\nint\nbatchSize\n);\nThis function computes eigenvalues and eigenvectors of a sequence of symmetric (Hermitian)\n\\(n \\times n\\)\nmatrices\n\\[A_{j}*Q_{j} = Q_{j}*\\Lambda_{j}\\]\nwhere\n\\(\\Lambda_{j}\\)\nis a real\n\\(n \\times n\\)\ndiagonal matrix.\n\\(Q_j\\)\nis an\n\\(n \\times n\\)\nunitary matrix. The diagonal elements of\n\\(\\Lambda_j\\)\nare the eigenvalues of\n\\(A_j\\)\nin either ascending order or non-sorting order.\nsyevjBatched\nperforms\nsyevj\non each matrix. It requires that all matrices are of the same size\nn\nand are packed in contiguous way,\n\\[\\begin{split}A = \\begin{pmatrix}\n{A0} & {A1} & \\cdots \\\\\n\\end{pmatrix}\\end{split}\\]\nEach matrix is column-major with leading dimension\nlda\n, so the formula for random access is\n\\(A_{k}\\operatorname{(i,j)} = {A\\lbrack\\ i\\ +\\ lda*j\\ +\\ lda*n*k\\rbrack}\\)\n.\nThe parameter\nW\nalso contains eigenvalues of each matrix in contiguous way,\n\\[\\begin{split}W = \\begin{pmatrix}\n{W0} & {W1} & \\cdots \\\\\n\\end{pmatrix}\\end{split}\\]\nThe formula for random access of\nW\nis\n\\(W_{k}\\operatorname{(j)} = {W\\lbrack\\ j\\ +\\ n*k\\rbrack}\\)\n.\nExcept for tolerance and maximum sweeps,\nsyevjBatched\ncan either sort the eigenvalues in ascending order (default) or chose as-is (without sorting) by the function\ncusolverDnXsyevjSetSortEig\n. If the user packs several tiny matrices into diagonal blocks of one matrix, non-sorting option can separate spectrum of those tiny matrices.\nsyevjBatched\ncannot report residual and executed sweeps by function\ncusolverDnXsyevjGetResidual\nand\ncusolverDnXsyevjGetSweeps\n. Any call of the above two returns\nCUSOLVER_STATUS_NOT_SUPPORTED\n. The user needs to compute residual explicitly.\nThe user has to provide working space pointed by input parameter\nwork\n. The input parameter\nlwork\nis the size of the working space, and it is returned by\nsyevjBatched_bufferSize()\n. Please note that the size in bytes of the working space is equal to\nsizeof(<type>)\n*\nlwork\n.\nThe output parameter\ninfo\nis an integer array of size\nbatchSize\n. If the function returns\nCUSOLVER_STATUS_INVALID_VALUE\n, the first element\ninfo[0]\n=\n-i\n(less than zero) indicates\ni-th\nparameter is wrong (not counting handle). Otherwise, if\ninfo[i]\n=\nn+1\n,\nsyevjBatched\ndoes not converge on\ni-th\nmatrix under given tolerance and maximum sweeps.\nIf\njobz\n= CUSOLVER_EIG_MODE_VECTOR,\n\\(A_j\\)\ncontains the orthonormal eigenvectors\n\\(V_j\\)\n.\nPlease visit\ncuSOLVER Library Samples - syevjBatched\nfor a code example.\nAPI of syevjBatched\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\njobz\nhost\ninput\nSpecifies options to either compute eigenvalue only or compute eigen-pair:\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n: Compute eigenvalues only;\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n: Compute eigenvalues and eigenvectors.\nuplo\nhost\ninput\nSpecifies which part of\nAj\nis stored.\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n: Lower triangle of\nAj\nis stored.\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n: Upper triangle of\nAj\nis stored.\nn\nhost\ninput\nNumber of rows (or columns) of matrix each\nAj\n.\nA\ndevice\nin/out\n<type> array of dimension\nlda\n*\nn\n*\nbatchSize\nwith\nlda\nis not less than\nmax(1,n)\n. If\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n, the leading n-by-n upper triangular part of\nAj\ncontains the upper triangular part of the matrix\nAj\n. If\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n, the leading n-by-n lower triangular part of\nAj\ncontains the lower triangular part of the matrix\nAj\n. On exit, if\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n, and\ninfo[j]\n= 0,\nAj\ncontains the orthonormal eigenvectors of the matrix\nAj\n. If\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n, the contents of\nAj\nare destroyed.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nAj\n.\nW\ndevice\noutput\nA real array of dimension\nn*batchSize\n. It stores the eigenvalues of\nAj\nin ascending order or non-sorting order.\nwork\ndevice\nin/out\n<type> array of size\nlwork\n, workspace.\nlwork\nhost\ninput\nSize of\nwork\n, returned by\nsyevjBatched_bufferSize\n.\ninfo\ndevice\noutput\nAn integer array of dimension\nbatchSize\n. If\nCUSOLVER_STATUS_INVALID_VALUE\nis returned,\ninfo[0]\n=\n-i\n(less than zero) indicates\ni-th\nparameter is wrong (not counting handle). Otherwise, if\ninfo[i]\n=\n0\n, the operation is successful. If\ninfo[i]\n=\nn+1\n,\nsyevjBatched\ndoes not converge on\ni-th\nmatrix under given tolerance and maximum sweeps.\nparams\nhost\nin/out\nStructure filled with parameters of Jacobi algorithm.\nbatchSize\nhost\ninput\nNumber of matrices.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\n, or\nlda<max(1,n)\n, or\njobz\nis not\nCUSOLVER_EIG_MODE_NOVECTOR\nor\nCUSOLVER_EIG_MODE_VECTOR\n, or\nuplo\nis not\nCUBLAS_FILL_MODE_LOWER\nor\nCUBLAS_FILL_MODE_UPPER\n), or\nbatchSize<0\n.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.4.\nDense Linear Solver Reference (64-bit API)\n\nThis section describes linear solver 64-bit API of cuSolverDN, including Cholesky factorization, LU with partial pivoting and QR factorization.\n2.4.4.1.\ncusolverDnXpotrf()\n\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverDnXpotrf_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\ncublasFillMode_t\nuplo\n,\nint64_t\nn\n,\ncudaDataType\ndataTypeA\n,\nconst\nvoid\n*\nA\n,\nint64_t\nlda\n,\ncudaDataType\ncomputeType\n,\nsize_t\n*\nworkspaceInBytesOnDevice\n,\nsize_t\n*\nworkspaceInBytesOnHost\n)\nThe following routine:\ncusolverStatus_t\ncusolverDnXpotrf\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\ncublasFillMode_t\nuplo\n,\nint64_t\nn\n,\ncudaDataType\ndataTypeA\n,\nvoid\n*\nA\n,\nint64_t\nlda\n,\ncudaDataType\ncomputeType\n,\nvoid\n*\nbufferOnDevice\n,\nsize_t\nworkspaceInBytesOnDevice\n,\nvoid\n*\nbufferOnHost\n,\nsize_t\nworkspaceInBytesOnHost\n,\nint\n*\ninfo\n)\ncomputes the Cholesky factorization of a Hermitian positive-definite matrix using the generic API interface.\nA\nis a\n\\(n \\times n\\)\nHermitian matrix, only lower or upper part is meaningful. The input parameter\nuplo\nindicates which part of the matrix is used. The function will leave the other part untouched.\nIf input parameter\nuplo\nis\nCUBLAS_FILL_MODE_LOWER\n, only lower triangular part of\nA\nis processed, and replaced by lower triangular Cholesky factor\nL\n.\n\\[A = L*L^{H}\\]\nIf input parameter\nuplo\nis\nCUBLAS_FILL_MODE_UPPER\n, only upper triangular part of\nA\nis processed, and replaced by upper triangular Cholesky factor\nU\n.\n\\[A = U^{H}*U\\]\nThe user has to provide device and host working spaces which are pointed by input parameters\nbufferOnDevice\nand\nbufferOnHost\n. The input parameters\nworkspaceInBytesOnDevice\n(and\nworkspaceInBytesOnHost\n) is size in bytes of the device (and host) working space, and it is returned by\ncusolverDnXpotrf_bufferSize()\n.\nIf Cholesky factorization failed, i.e. some leading minor of\nA\nis not positive definite, or equivalently some diagonal elements of\nL\nor\nU\nis not a real number. The output parameter\ninfo\nwould indicate smallest leading minor of\nA\nwhich is not positive definite.\nIf output parameter\ninfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nCurrently,\ncusolverDnXpotrf\nsupports only the default algorithm.\nPlease visit\ncuSOLVER Library Samples - Xpotrf\nfor a code example.\nAlgorithms supported by cusolverDnXpotrf\nCUSOLVER_ALG_0\nor\nNULL\nDefault algorithm.\nList of input arguments for\ncusolverDnXpotrf_bufferSize\nand\ncusolverDnXpotrf\n:\nAPI of potrf\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nparams\nhost\ninput\nStructure with information collected by\ncusolverDnSetAdvOptions\n.\nuplo\nhost\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other part is not referenced.\nn\nhost\ninput\nNumber of rows and columns of matrix\nA\n.\ndataTypeA\nhost\nin\nData type of array\nA\n.\nA\ndevice\nin/out\nArray of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,n)\n.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\ncomputeType\nhost\nin\nData type of computation.\nbufferOnDevice\ndevice\nin/out\nDevice workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnDevice\nbytes.\nworkspaceInBytesOnDevice\nhost\ninput\nSize in bytes of\nbufferOnDevice\n, returned by\ncusolverDnXpotrf_bufferSize\n.\nbufferOnHost\nhost\nin/out\nHost workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnHost\nbytes.\nworkspaceInBytesOnHost\nhost\ninput\nSize in bytes of\nbufferOnHost\n, returned by\ncusolverDnXpotrf_bufferSize\n.\ninfo\ndevice\noutput\nIf\ninfo\n=\n0\n, the Cholesky factorization is successful. If\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle). If\ninfo\n=\ni\n, the leading minor of order\ni\nis not positive definite.\nThe generic API has two different types,\ndataTypeA\nis data type of the matrix\nA\n,\ncomputeType\nis compute type of the operation.\ncusolverDnXpotrf\nonly supports the following four combinations.\nValid combination of data type and compute type\nDataTypeA\nComputeType\nMeaning\nCUDA_R_32F\nCUDA_R_32F\nSPOTRF\nCUDA_R_64F\nCUDA_R_64F\nDPOTRF\nCUDA_C_32F\nCUDA_C_32F\nCPOTRF\nCUDA_C_64F\nCUDA_C_64F\nZPOTRF\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\nor\nlda<max(1,n)\n).\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.4.2.\ncusolverDnXpotrs()\n\ncusolverStatus_t\ncusolverDnXpotrs\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\ncublasFillMode_t\nuplo\n,\nint64_t\nn\n,\nint64_t\nnrhs\n,\ncudaDataType\ndataTypeA\n,\nconst\nvoid\n*\nA\n,\nint64_t\nlda\n,\ncudaDataType\ndataTypeB\n,\nvoid\n*\nB\n,\nint64_t\nldb\n,\nint\n*\ninfo\n)\nThis function solves a system of linear equations\n\\[A*X = B\\]\nwhere\nA\nis a\n\\(n \\times n\\)\nHermitian matrix, only lower or upper part is meaningful using the generic API interface. The input parameter\nuplo\nindicates which part of the matrix is used. The function will leave the other part untouched.\nThe user has to call\ncusolverDnXpotrf\nfirst to factorize matrix\nA\n. If input parameter\nuplo\nis\nCUBLAS_FILL_MODE_LOWER\n,\nA\nis lower triangular Cholesky factor\nL\ncorresponding to\n\\(A = L*L^{H}\\)\n. If input parameter\nuplo\nis\nCUBLAS_FILL_MODE_UPPER\n,\nA\nis upper triangular Cholesky factor\nU\ncorresponding to\n\\(A = U^{H}*U\\)\n.\nThe operation is in-place, i.e. matrix\nX\noverwrites matrix\nB\nwith the same leading dimension\nldb\n.\nIf output parameter\ninfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nCurrently,\ncusolverDnXpotrs\nsupports only the default algorithm.\nPlease visit\ncuSOLVER Library Samples - Xpotrf\nfor a code example.\nAlgorithms supported by cusolverDnXpotrs\nCUSOLVER_ALG_0\nor\nNULL\nDefault algorithm.\nList of input arguments for\ncusolverDnXpotrs\n:\nAPI of potrs\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nparams\nhost\ninput\nStructure with information collected by\ncusolverDnSetAdvOptions\n.\nuplo\nhost\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other part is not referenced.\nn\nhost\ninput\nNumber of rows and columns of matrix\nA\n.\nnrhs\nhost\ninput\nNumber of columns of matrix\nX\nand\nB\n.\ndataTypeA\nhost\nin\nData type of array\nA\n.\nA\ndevice\ninput\nArray of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,n)\n.\nA\nis either lower Cholesky factor\nL\nor upper Cholesky factor\nU\n.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\ndataTypeB\nhost\nin\nData type of array\nB\n.\nB\ndevice\nin/out\nArray of dimension\nldb\n*\nnrhs\n.\nldb\nis not less than\nmax(1,n)\n. As an input,\nB\nis right hand side matrix. As an output,\nB\nis the solution matrix.\ninfo\ndevice\noutput\nIf\ninfo\n=\n0\n, the Cholesky factorization is successful. if\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle).\nThe generic API has two different types,\ndataTypeA\nis data type of the matrix\nA\n,\ndataTypeB\nis data type of the matrix\nB\n.\ncusolverDnXpotrs\nonly supports the following four combinations.\nValid combination of data type and compute type\ndataTypeA\ndataTypeB\nMeaning\nCUDA_R_32F\nCUDA_R_32F\nSPOTRS\nCUDA_R_64F\nCUDA_R_64F\nDPOTRS\nCUDA_C_32F\nCUDA_C_32F\nCPOTRS\nCUDA_C_64F\nCUDA_C_64F\nZPOTRS\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\n,\nnrhs<0\n,\nlda<max(1,n)\nor\nldb<max(1,n)\n).\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.4.3.\ncusolverDnXgetrf()\n\nThe helper function below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverDnXgetrf_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\nint64_t\nm\n,\nint64_t\nn\n,\ncudaDataType\ndataTypeA\n,\nconst\nvoid\n*\nA\n,\nint64_t\nlda\n,\ncudaDataType\ncomputeType\n,\nsize_t\n*\nworkspaceInBytesOnDevice\n,\nsize_t\n*\nworkspaceInBytesOnHost\n)\nThe function below\ncusolverStatus_t\ncusolverDnXgetrf\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\nint64_t\nm\n,\nint64_t\nn\n,\ncudaDataType\ndataTypeA\n,\nvoid\n*\nA\n,\nint64_t\nlda\n,\nint64_t\n*\nipiv\n,\ncudaDataType\ncomputeType\n,\nvoid\n*\nbufferOnDevice\n,\nsize_t\nworkspaceInBytesOnDevice\n,\nvoid\n*\nbufferOnHost\n,\nsize_t\nworkspaceInBytesOnHost\n,\nint\n*\ninfo\n)\ncomputes the LU factorization of a\n\\(m \\times n\\)\nmatrix\n\\[P*A = L*U\\]\nwhere\nA\nis a\n\\(m \\times n\\)\nmatrix,\nP\nis a permutation matrix,\nL\nis a lower triangular matrix with unit diagonal, and\nU\nis an upper triangular matrix using the generic API interface.\nIf LU factorization failed, i.e. matrix\nA\n(\nU\n) is singular, The output parameter\ninfo=i\nindicates\nU(i,i)\n=\n0\n.\nIf output parameter\ninfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nIf\nipiv\nis null, no pivoting is performed. The factorization is\nA=L*U\n, which is not numerically stable.\nNo matter LU factorization failed or not, the output parameter\nipiv\ncontains pivoting sequence, row\ni\nis interchanged with row\nipiv(i)\n.\nThe user has to provide device and host working spaces which are pointed by input parameters\nbufferOnDevice\nand\nbufferOnHost\n. The input parameters\nworkspaceInBytesOnDevice\n(and\nworkspaceInBytesOnHost\n) is size in bytes of the device (and host) working space, and it is returned by\ncusolverDnXgetrf_bufferSize()\n.\nThe user can combine\ncusolverDnXgetrf\nand\ncusolverDnGetrs\nto complete a linear solver.\nCurrently,\ncusolverDnXgetrf\nsupports two algorithms. To select legacy implementation, the user has to call\ncusolverDnSetAdvOptions\n.\nPlease visit\ncuSOLVER Library Samples - Xgetrf\nfor a code example.\nAlgorithms supported by cusolverDnXgetrf\nCUSOLVER_ALG_0\nor\nNULL\nDefault algorithm. The fastest, requires a large workspace of\nm*n\nelements.\nCUSOLVER_ALG_1\nLegacy implementation\nList of input arguments for\ncusolverDnXgetrf_bufferSize\nand\ncusolverDnXgetrf\n:\nAPI of cusolverDnXgetrf\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nparams\nhost\ninput\nStructure with information collected by\ncusolverDnSetAdvOptions\n.\nm\nhost\ninput\nNumber of rows of matrix\nA\n.\nn\nhost\ninput\nNumber of columns of matrix\nA\n.\ndataTypeA\nhost\nin\nData type of array\nA\n.\nA\ndevice\nin/out\n<type> array of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,m)\n.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nipiv\ndevice\noutput\nArray of size at least\nmin(m,n)\n, containing pivot indices.\ncomputeType\nhost\nin\nData type of computation.\nbufferOnDevice\ndevice\nin/out\nDevice workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnDevice\nbytes.\nworkspaceInBytesOnDevice\nhost\ninput\nSize in bytes of\nbufferOnDevice\n, returned by\ncusolverDnXgetrf_bufferSize\n.\nbufferOnHost\nhost\nin/out\nHost workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnHost\nbytes.\nworkspaceInBytesOnHost\nhost\ninput\nSize in bytes of\nbufferOnHost\n, returned by\ncusolverDnXgetrf_bufferSize\n.\ninfo\ndevice\noutput\nIf\ninfo\n=\n0\n, the LU factorization is successful. if\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle). If\ninfo\n=\ni\n, the\nU(i,i)\n=\n0\n.\nThe generic API has two different types,\ndataTypeA\nis data type of the matrix\nA\n,\ncomputeType\nis compute type of the operation.\ncusolverDnXgetrf\nonly supports the following four combinations.\nValid combination of data type and compute type\nDataTypeA\nComputeType\nMeaning\nCUDA_R_32F\nCUDA_R_32F\nSGETRF\nCUDA_R_64F\nCUDA_R_64F\nDGETRF\nCUDA_C_32F\nCUDA_C_32F\nCGETRF\nCUDA_C_64F\nCUDA_C_64F\nZGETRF\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,n<0\nor\nlda<max(1,m)\n).\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.4.4.\ncusolverDnXgetrs()\n\ncusolverStatus_t\ncusolverDnXgetrs\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\ncublasOperation_t\ntrans\n,\nint64_t\nn\n,\nint64_t\nnrhs\n,\ncudaDataType\ndataTypeA\n,\nconst\nvoid\n*\nA\n,\nint64_t\nlda\n,\nconst\nint64_t\n*\nipiv\n,\ncudaDataType\ndataTypeB\n,\nvoid\n*\nB\n,\nint64_t\nldb\n,\nint\n*\ninfo\n)\nThis function solves a linear system of multiple right-hand sides\n\\[op(A)*X = B\\]\nwhere\nA\nis an\n\\(n \\times n\\)\nmatrix, and was LU-factored by\ncusolverDnXgetrf\n, that is, lower triangular part of A is\nL\n, and upper triangular part (including diagonal elements) of\nA\nis\nU\n.\nB\nis an\n\\(n \\times {nrhs}\\)\nright-hand side matrix using the generic API interface.\nThe input parameter\ntrans\nis defined by\nThe input parameter\nipiv\nis an output of\ncusolverDnXgetrf\n. It contains pivot indices, which are used to permutate right-hand sides.\nIf output parameter\ninfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nThe user can combine\ncusolverDnXgetrf\nand\ncusolverDnXgetrs\nto complete a linear solver.\nCurrently,\ncusolverDnXgetrs\nsupports only the default algorithm.\nPlease visit\ncuSOLVER Library Samples - Xgetrf\nfor a code example.\nAlgorithms supported by cusolverDnXgetrs\nCUSOLVER_ALG_0\nor\nNULL\nDefault algorithm.\nList of input arguments for\ncusolverDnXgetrs\n:\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nparams\nhost\ninput\nStructure with information collected by\ncusolverDnSetAdvOptions\n.\ntrans\nhost\ninput\nOperation\nop(A)\nthat is non- or (conj.) transpose.\nn\nhost\ninput\nNumber of rows and columns of matrix\nA\n.\nnrhs\nhost\ninput\nNumber of right-hand sides.\ndataTypeA\nhost\nin\nData type of array\nA\n.\nA\ndevice\ninput\nArray of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,n)\n.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nipiv\ndevice\ninput\nArray of size at least\nn\n, containing pivot indices.\ndataTypeB\nhost\nin\nData type of array\nB\n.\nB\ndevice\noutput\n<type> array of dimension\nldb\n*\nnrhs\nwith\nldb\nis not less than\nmax(1,n)\n.\nldb\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nB\n.\ninfo\ndevice\noutput\nIf\ninfo\n=\n0\n, the operation is successful. If\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle).\nThe generic API has two different types:\ndataTypeA\nis data type of the matrix\nA\nand\ndataTypeB\nis data type of the matrix\nB\n.\ncusolverDnXgetrs\nonly supports the following four combinations:\nValid combination of data type and compute type\nDataTypeA\ndataTypeB\nMeaning\nCUDA_R_32F\nCUDA_R_32F\nSGETRS\nCUDA_R_64F\nCUDA_R_64F\nDGETRS\nCUDA_C_32F\nCUDA_C_32F\nCGETRS\nCUDA_C_64F\nCUDA_C_64F\nZGETRS\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\nor\nlda<max(1,n)\nor\nldb<max(1,n)\n).\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.4.5.\ncusolverDnXgeqrf()\n\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverDnXgeqrf_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\nint64_t\nm\n,\nint64_t\nn\n,\ncudaDataType\ndataTypeA\n,\nconst\nvoid\n*\nA\n,\nint64_t\nlda\n,\ncudaDataType\ndataTypeTau\n,\nconst\nvoid\n*\ntau\n,\ncudaDataType\ncomputeType\n,\nsize_t\n*\nworkspaceInBytesOnDevice\n,\nsize_t\n*\nworkspaceInBytesOnHost\n)\nThe following routine:\ncusolverStatus_t\ncusolverDnXgeqrf\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\nint64_t\nm\n,\nint64_t\nn\n,\ncudaDataType\ndataTypeA\n,\nvoid\n*\nA\n,\nint64_t\nlda\n,\ncudaDataType\ndataTypeTau\n,\nvoid\n*\ntau\n,\ncudaDataType\ncomputeType\n,\nvoid\n*\nbufferOnDevice\n,\nsize_t\nworkspaceInBytesOnDevice\n,\nvoid\n*\nbufferOnHost\n,\nsize_t\nworkspaceInBytesOnHost\n,\nint\n*\ninfo\n)\ncomputes the QR factorization of a\n\\(m \\times n\\)\nmatrix\n\\[A = Q*R\\]\nwhere\nA\nis an\n\\(m \\times n\\)\nmatrix,\nQ\nis a\n\\(m \\times n\\)\nmatrix, and\nR\nis an\n\\(n \\times n\\)\nupper triangular matrix using the generic API interface.\nThe user has to provide device and host working spaces which are pointed by input parameters\nbufferOnDevice\nand\nbufferOnHost\n. The input parameters\nworkspaceInBytesOnDevice\n(and\nworkspaceInBytesOnHost\n) is size in bytes of the device (and host) working space, and it is returned by\ncusolverDnXgeqrf_bufferSize()\n.\nThe matrix\nR\nis overwritten in upper triangular part of\nA\n, including diagonal elements.\nThe matrix\nQ\nis not formed explicitly, instead, a sequence of householder vectors are stored in lower triangular part of\nA\n. The leading nonzero element of householder vector is assumed to be 1 such that output parameter\nTAU\ncontains the scaling factor\nτ\n. If\nv\nis original householder vector,\nq\nis the new householder vector corresponding to\nτ\n, satisfying the following relation\n\\[I - 2*v*v^{H} = I - \\tau*q*q^{H}\\]\nIf output parameter\ninfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nCurrently,\ncusolverDnXgeqrf\nsupports only the default algorithm.\nPlease visit\ncuSOLVER Library Samples - Xgeqrf\nfor a code example.\nAlgorithms supported by cusolverDnXgeqrf\nCUSOLVER_ALG_0\nor\nNULL\nDefault algorithm.\nList of input arguments for\ncusolverDnXgeqrf_bufferSize\nand\ncusolverDnXgeqrf\n:\nAPI of geqrf\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nparams\nhost\ninput\nStructure with information collected by\ncusolverDnSetAdvOptions\n.\nm\nhost\ninput\nNumber of rows of matrix\nA\n.\nn\nhost\ninput\nNumber of columns of matrix\nA\n.\ndataTypeA\nhost\nin\nData type of array\nA\n.\nA\ndevice\nin/out\nArray of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,m)\n.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\ndataTypeTau\nhost\nin\nData type of array\ntau\n.\ntau\ndevice\noutput\nArray of dimension at least\nmin(m,n)\n.\ncomputeType\nhost\nin\nData type of computation.\nbufferOnDevice\ndevice\nin/out\nDevice workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnDevice\nbytes.\nworkspaceInBytesOnDevice\nhost\ninput\nSize in bytes of\nbufferOnDevice\n, returned by\ncusolverDnXgeqrf_bufferSize\n.\nbufferOnHost\nhost\nin/out\nHost workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnHost\nbytes.\nworkspaceInBytesOnHost\nhost\ninput\nSize in bytes of\nbufferOnHost\n, returned by\ncusolverDnXgeqrf_bufferSize\n.\ninfo\ndevice\noutput\nIf\ninfo\n=\n0\n, the QR factorization is successful. If\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle).\nThe generic API has two different types,\ndataTypeA\nis data type of the matrix\nA\n,\ndataTypeTau\nis data type of the array\ntau\nand\ncomputeType\nis compute type of the operation.\ncusolverDnXgeqrf\nonly supports the following four combinations.\nValid combination of data type and compute type\nDataTypeA\nComputeType\nMeaning\nCUDA_R_32F\nCUDA_R_32F\nSGEQRF\nCUDA_R_64F\nCUDA_R_64F\nDGEQRF\nCUDA_C_32F\nCUDA_C_32F\nCGEQRF\nCUDA_C_64F\nCUDA_C_64F\nZGEQRF\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,n<0\nor\nlda<max(1,m)\n).\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.4.6.\ncusolverDnXsytrs()\n\nThe helper functions below can calculate the sizes needed for pre-allocated buffers.\ncusolverStatus_t\ncusolverDnXsytrs_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint64_t\nn\n,\nint64_t\nnrhs\n,\ncudaDataType\ndataTypeA\n,\nconst\nvoid\n*\nA\n,\nint64_t\nlda\n,\nconst\nint64_t\n*\ndevIpiv\n,\ncudaDataType\ndataTypeB\n,\nvoid\n*\nB\n,\nint64_t\nldb\n,\nsize_t\n*\nworkspaceInBytesOnDevice\n,\nsize_t\n*\nworkspaceInBytesOnHost\n);\nThe following routine:\ncusolverStatus_t\ncusolverDnXsytrs\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint64_t\nn\n,\nint64_t\nnrhs\n,\ncudaDataType\ndataTypeA\n,\nconst\nvoid\n*\nA\n,\nint64_t\nlda\n,\nconst\nint64_t\n*\ndevIpiv\n,\ncudaDataType\ndataTypeB\n,\nvoid\n*\nB\n,\nint64_t\nldb\n,\nvoid\n*\nbufferOnDevice\n,\nsize_t\nworkspaceInBytesOnDevice\n,\nvoid\n*\nbufferOnHost\n,\nsize_t\nworkspaceInBytesOnHost\n,\nint\n*\ndevInfo\n);\nsolves a system of linear equations using the generic API interface.\nA\ncontains the factorization from\ncusolverDn<t>sytrf()\n, only lower or upper part is meaningful, the other part is not touched.\nIf input parameter\nuplo\nis\nCUBLAS_FILL_MODE_LOWER\n, the details of the factorization are stores as:\n\\[A = L*D*L^{T}\\]\nIf input parameter\nuplo\nis\nCUBLAS_FILL_MODE_UPPER\n, the details of the factorization are stores as:\n\\[A = U*D*U^{T}\\]\nThe user has to provide the pivot indices that can be obtained by\ncusolverDn<t>sytrf()\nas well as device and host work spaces which are pointed by input parameters\nbufferOnDevice\nand\nbufferOnHost\n. The input parameters\nworkspaceInBytesOnDevice\nand\nworkspaceInBytesOnHost\nare sizes in bytes of the device and host work spaces, and they are returned by\ncusolverDnXsytrs_bufferSize()\n.\nTo factorize and solve the symmetric system without pivoting, the user should set\ndevIpiv\n=\nNULL\nwhen calling\ncusolverDn<t>sytrf\nand\ncusolverDnXsytrs\n.\nIf output parameter\ndevInfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nList of input arguments for\ncusolverDnXsytrs_bufferSize\nand\ncusolverDnXsytrs\n:\nAPI of sytrs\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nuplo\nhost\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other part is not referenced.\nn\nhost\ninput\nNumber of rows and columns of matrix\nA\n.\nnrhs\nhost\ninput\nNumber of right-hand sides.\ndataTypeA\nhost\nin\nData type of array\nA\n.\nA\ndevice\ninput\nArray of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,n)\n.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\ndevIpiv\ndevice\ninput\nArray of size at least\nn\n, containing pivot indices. To solve the system without pivoting, set the argument\nNULL\n.\ndataTypeB\nhost\nin\nData type of array\nB\n.\nB\ndevice\nin/out\nArray of dimension\nldb\n*\nnrhs\nwith\nldb\nis not less than\nmax(1,nrhs)\n.\nldb\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nB\n.\nbufferOnDevice\ndevice\nin/out\nDevice workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnDevice\nbytes.\nworkspaceInBytesOnDevice\nhost\ninput\nSize in bytes of\nbufferOnDevice\n, returned by\ncusolverDnXsytrs_bufferSize\n.\nbufferOnHost\nhost\nin/out\nHost workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnHost\nbytes.\nworkspaceInBytesOnHost\nhost\ninput\nSize in bytes of\nbufferOnHost\n, returned by\ncusolverDnXsytrs_bufferSize\n.\ndevInfo\ndevice\noutput\nIf\ndevInfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle). Otherwise, it sets\ndevInfo\n=\n0\nindicating all parameters are valid.\nThe generic API has two different types:\ndataTypeA\nis data type of the matrix\nA\n,\ndataTypeB\nis data type of the matrix\nA\n.\ncusolverDnXsytrs\nonly supports the following four combinations:\nValid combination of data type and compute type\nDataTypeA\nDataTypeB\nMeaning\nCUDA_R_32F\nCUDA_R_32F\nSSYTRS\nCUDA_R_64F\nCUDA_R_64F\nDSYTRS\nCUDA_C_32F\nCUDA_C_32F\nCSYTRS\nCUDA_C_64F\nCUDA_C_64F\nZSYTRS\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\nor\nlda<max(1,n)\n).\nCUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED\nData type is not supported.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.4.7.\ncusolverDnXtrtri()\n\nThe helper functions below can calculate the sizes needed for pre-allocated buffers.\ncusolverStatus_t\ncusolverDnXtrtri_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasDiagType_t\ndiag\n,\nint64_t\nn\n,\ncudaDataType\ndataTypeA\n,\nvoid\n*\nA\n,\nint64_t\nlda\n,\nsize_t\n*\nworkspaceInBytesOnDevice\n,\nsize_t\n*\nworkspaceInBytesOnHost\n);\nThe following routine:\ncusolverStatus_t\ncusolverDnXtrtri\n(\ncusolverDnHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\ncublasDiagType_t\ndiag\n,\nint64_t\nn\n,\ncudaDataType\ndataTypeA\n,\nvoid\n*\nA\n,\nint64_t\nlda\n,\nvoid\n*\nbufferOnDevice\n,\nsize_t\nworkspaceInBytesOnDevice\n,\nvoid\n*\nbufferOnHost\n,\nsize_t\nworkspaceInBytesOnHost\n,\nint\n*\ninfo\n);\ncomputes the inverse of a triangular matrix using the generic API interface.\nA\nis an\n\\(n \\times n\\)\ntriangular matrix, only lower or upper part is meaningful. The input parameter\nuplo\nindicates which part of the matrix is used. The function will leave the other part untouched.\nIf input parameter\nuplo\nis\nCUBLAS_FILL_MODE_LOWER\n, only lower triangular part of\nA\nis processed, and replaced by lower triangular inverse.\nIf input parameter\nuplo\nis\nCUBLAS_FILL_MODE_UPPER\n, only upper triangular part of\nA\nis processed, and replaced by upper triangular inverse.\nThe user has to provide device and host work spaces which are pointed by input parameters\nbufferOnDevice\nand\nbufferOnHost\n. The input parameters\nworkspaceInBytesOnDevice\nand\nworkspaceInBytesOnHost\nare sizes in bytes of the device and host work spaces, and they are returned by\ncusolverDnXtrtri_bufferSize()\n.\nIf matrix inversion fails, the output parameter\ninfo\n=\ni\nshows\nA(i,i)\n=\n0\n.\nIf output parameter\ninfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nPlease visit\ncuSOLVER Library Samples - Xtrtri\nfor a code example.\nList of input arguments for\ncusolverDnXtrtri_bufferSize\nand\ncusolverDnXtrtri\n:\nAPI of trtri\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nuplo\nhost\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other part is not referenced.\ndiag\nhost\ninput\nThe enumerated unit diagonal type.\nn\nhost\ninput\nNumber of rows and columns of matrix\nA\n.\ndataTypeA\nhost\nin\nData type of array\nA\n.\nA\ndevice\nin/out\nArray of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,n)\n.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nbufferOnDevice\ndevice\nin/out\nDevice workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnDevice\nbytes.\nworkspaceInBytesOnDevice\nhost\ninput\nSize in bytes of\nbufferOnDevice\n, returned by\ncusolverDnXtrtri_bufferSize\n.\nbufferOnHost\nhost\nin/out\nHost workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnHost\nbytes.\nworkspaceInBytesOnHost\nhost\ninput\nSize in bytes of\nbufferOnHost\n, returned by\ncusolverDnXtrtri_bufferSize\n.\ninfo\ndevice\noutput\nIf\ninfo\n=\n0\n, the matrix inversion succeeded. If\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle). If\ninfo\n=\ni\n,\nA(i,i)\n=\n0\n.\nValid data types\nDataTypeA\nMeaning\nCUDA_R_32F\nSTRTRI\nCUDA_R_64F\nDTRTRI\nCUDA_C_32F\nCTRTRI\nCUDA_C_64F\nZTRTRI\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_NOT_SUPPORTED\nData type is not supported.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\nor\nlda<max(1,n)\n).\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.4.8.\ncusolverDnXlarft()\n\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverDnXlarft_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\ncusolverDirectMode_t\ndirect\n,\ncusolverStorevMode_t\nstorev\n,\nint64_t\nn\n,\nint64_t\nk\n,\ncudaDataType\ndataTypeV\n,\nconst\nvoid\n*\nV\n,\nint64_t\nldv\n,\ncudaDataType\ndataTypeTau\n,\nconst\nvoid\n*\ntau\n,\ncudaDataType\ndataTypeT\n,\nvoid\n*\nT\n,\nint64_t\nldt\n,\ncudaDataType\ncomputeType\n,\nsize_t\n*\nworkspaceInBytesOnDevice\n,\nsize_t\n*\nworkspaceInBytesOnHost\n)\nThe following routine:\ncusolverStatus_t\ncusolverDnXlarft\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\ncusolverDirectMode_t\ndirect\n,\ncusolverStorevMode_t\nstorev\n,\nint64_t\nn\n,\nint64_t\nk\n,\ncudaDataType\ndataTypeV\n,\nconst\nvoid\n*\nV\n,\nint64_t\nldv\n,\ncudaDataType\ndataTypeTau\n,\nconst\nvoid\n*\ntau\n,\ncudaDataType\ndataTypeT\n,\nvoid\n*\nT\n,\nint64_t\nldt\n,\ncudaDataType\ncomputeType\n,\nvoid\n*\nbufferOnDevice\n,\nsize_t\nworkspaceInBytesOnDevice\n,\nvoid\n*\nbufferOnHost\n,\nsize_t\nworkspaceInBytesOnHost\n)\nforms the triangular factor\nT\nof a real block reflector\nH\nof order\nn\n, which is defined as a product of\nk\nelementary reflectors.\nIf:\ndirect\n==\nCUBLAS_DIRECT_FORWARD\n:\n\\(H = H(1) H(2) ... H(k)\\)\nand\nT\nis upper triangular;\ndirect\n==\nCUBLAS_DIRECT_BACKWARD\n:\n\\(H = H(k) ... H(2) H(1)\\)\nand\nT\nis lower triangular.\nOnly\nstorev\n==\nCUBLAS_STOREV_COLUMNWISE\nis supported, which indicates that the vector defining the elementary reflector\nH(i)\nis stored in the i-th column of the array\nV\n, and\n\\(H = I - V * T * V^{T}\\)\n(\n\\(H = I - V * T * V^{H}\\)\nfor complex types).\nThe user has to provide device and host working spaces which are pointed by input parameters\nbufferOnDevice\nand\nbufferOnHost\n. The input parameters\nworkspaceInBytesOnDevice\n(and\nworkspaceInBytesOnHost\n) is size in bytes of the device (and host) working space, and it is returned by\ncusolverDnXlarft_bufferSize()\n.\nCurrently, only\nn\n>=\nk\nscenario is supported.\nAPI of larft\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nparams\nhost\ninput\nStructure with information collected by\ncusolverDnSetAdvOptions\n.\ndirect\nhost\ninput\nSpecifies the order in which the elementary reflectors are multiplied to form the block reflector.\nstorev\nhost\ninput\nSpecifies how the vectors which define the elementary reflectors are stored.\nn\nhost\ninput\nThe order of the block reflector\nH\n.\nn\n>=\n0\n.\nk\nhost\ninput\nThe order of the triangular factor\nT\n(= the number of elementary reflectors).\nk\n>=\n1\n.\ndataTypeV\nhost\ninput\nData type of array\nV\n.\nV\ndevice\ninput\nThe matrix\nV\nof dimension\nlda\n*\nk\n.\nldv\nhost\ninput\nLeading dimension of the array\nV\n.\nldv\n>=\nmax(1,n)\n.\ndataTypeTau\nhost\ninput\nData type of array\ntau\n.\ntau\ndevice\ninput\nDimension\nk\n.\ntau(i)\nmust contain the scalar factor of the elementary reflector\nH(i)\n.\ndataTypeT\nhost\ninput\nData type of array\nT\n.\nT\ndevice\noutput\nDimension\nldt\n*\nk\n. The\n\\(k \\times k\\)\ntriangular factor\nT\nof the block reflector. If\ndirect\n==\nCUBLAS_DIRECT_FORWARD\n,\nT\nis upper triangular; if\ndirect\n==\nCUBLAS_DIRECT_BACKWARD\n,\nT\nis lower triangular.\nldt\nhost\ninput\nThe leading dimension of the array\nT\n.\nldt\n>=\nk\n.\ncomputeType\nhost\ninput\nData type of computation.\nbufferOnDevice\ndevice\nin/out\nDevice workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnDevice\nbytes.\nworkspaceInBytesOnDevice\nhost\ninput\nSize in bytes of\nbufferOnDevice\n, returned by\ncusolverDnXlarft_bufferSize\n.\nbufferOnHost\nhost\nin/out\nHost workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnHost\nbytes.\nworkspaceInBytesOnHost\nhost\ninput\nSize in bytes of\nbufferOnHost\n, returned by\ncusolverDnXlarft_bufferSize\n.\nThe generic API has four different types:\ndataTypeV\nis data type of the array\nV\ndataTypeTau\nis data type of the array\ntau\ndataTypeT\nis data type of the array\nT\ncomputeType\nis compute type of the operation\ncusolverDnXlarft\nonly supports the following four combinations.\nValid combinations of data types and compute types\nDataTypeV\nDataTypeTau\nDataTypeT\nComputeType\nMeaning\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nSLARFT\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nDLARFT\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nCLARFT\nCUDA_C_64F\nCUDA_C_64F\nCUDA_C_64F\nCUDA_C_64F\nZLARFT\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn\n==\n0\n,\nk\n>\nn\n, or\nstorev\n==\nCUBLAS_STOREV_ROWWISE\n).\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.5.\nDense Eigenvalue Solver Reference (64-bit API)\n\nThis section describes eigenvalue solver API of cuSolverDN, including bidiagonalization and SVD.\n2.4.5.1.\ncusolverDnXgesvd()\n\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverDnXgesvd_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\nsigned\nchar\njobu\n,\nsigned\nchar\njobvt\n,\nint64_t\nm\n,\nint64_t\nn\n,\ncudaDataType\ndataTypeA\n,\nconst\nvoid\n*\nA\n,\nint64_t\nlda\n,\ncudaDataType\ndataTypeS\n,\nconst\nvoid\n*\nS\n,\ncudaDataType\ndataTypeU\n,\nconst\nvoid\n*\nU\n,\nint64_t\nldu\n,\ncudaDataType\ndataTypeVT\n,\nconst\nvoid\n*\nVT\n,\nint64_t\nldvt\n,\ncudaDataType\ncomputeType\n,\nsize_t\n*\nworkspaceInBytesOnDevice\n,\nsize_t\n*\nworkspaceInBytesOnHost\n)\nThe following routine:\ncusolverStatus_t\ncusolverDnXgesvd\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\nsigned\nchar\njobu\n,\nsigned\nchar\njobvt\n,\nint64_t\nm\n,\nint64_t\nn\n,\ncudaDataType\ndataTypeA\n,\nvoid\n*\nA\n,\nint64_t\nlda\n,\ncudaDataType\ndataTypeS\n,\nvoid\n*\nS\n,\ncudaDataType\ndataTypeU\n,\nvoid\n*\nU\n,\nint64_t\nldu\n,\ncudaDataType\ndataTypeVT\n,\nvoid\n*\nVT\n,\nint64_t\nldvt\n,\ncudaDataType\ncomputeType\n,\nvoid\n*\nbufferOnDevice\n,\nsize_t\nworkspaceInBytesOnDevice\n,\nvoid\n*\nbufferOnHost\n,\nsize_t\nworkspaceInBytesOnHost\n,\nint\n*\ninfo\n)\nThis function computes the singular value decomposition (SVD) of an\n\\(m \\times n\\)\nmatrix\nA\nand corresponding the left and/or right singular vectors. The SVD is written\n\\[A = U*\\Sigma*V^{H}\\]\nwhere\nΣ\nis an\n\\(m \\times n\\)\nmatrix which is zero except for its\nmin(m,n)\ndiagonal elements,\nU\nis an\n\\(m \\times m\\)\nunitary matrix, and\nV\nis an\n\\(n \\times n\\)\nunitary matrix. The diagonal elements of\nΣ\nare the singular values of\nA\n; they are real and non-negative, and are returned in descending order. The first\nmin(m,n)\ncolumns of\nU\nand\nV\nare the left and right singular vectors of\nA\n.\nThe user has to provide device and host working spaces which are pointed by input parameters\nbufferOnDevice\nand\nbufferOnHost\n. The input parameters\nworkspaceInBytesOnDevice\n(and\nworkspaceInBytesOnHost\n) is size in bytes of the device (and host) working space, and it is returned by\ncusolverDnXgesvd_bufferSize()\n.\nIf output parameter\ninfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle). if\nbdsqr\ndid not converge,\ninfo\nspecifies how many superdiagonals of an intermediate bidiagonal form did not converge to zero.\nCurrently,\ncusolverDnXgesvd\nsupports only the default algorithm.\nAlgorithms supported by cusolverDnXgesvd\nCUSOLVER_ALG_0\nor\nNULL\nDefault algorithm.\nPlease visit\ncuSOLVER Library Samples - Xgesvd\nfor a code example.\nRemark 1:\ngesvd\nonly supports\nm>=n\n.\nRemark 2: the routine returns\n\\(V^H\\)\n, not\nV\n.\nList of input arguments for\ncusolverDnXgesvd_bufferSize\nand\ncusolverDnXgesvd\n:\nAPI of cusolverDnXgesvd\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nparams\nhost\ninput\nStructure with information collected by\ncusolverDnSetAdvOptions\n.\njobu\nhost\ninput\nSpecifies options for computing all or part of the matrix\nU\n: = ‘A’: all m columns of U are returned in array U: = ‘S’: the first min(m,n) columns of U (the left singular vectors) are returned in the array U; = ‘O’: the first min(m,n) columns of U (the left singular vectors) are overwritten on the array A; = ‘N’: no columns of U (no left singular vectors) are computed.\njobvt\nhost\ninput\nSpecifies options for computing all or part of the matrix V**T: = ‘A’: all N rows of V**T are returned in the array VT; = ‘S’: the first min(m,n) rows of V**T (the right singular vectors) are returned in the array VT; = ‘O’: the first min(m,n) rows of V**T (the right singular vectors) are overwritten on the array A; = ‘N’: no rows of V**T (no right singular vectors) are computed.\nm\nhost\ninput\nNumber of rows of matrix\nA\n.\nn\nhost\ninput\nNumber of columns of matrix\nA\n.\ndataTypeA\nhost\ninput\nData type of array\nA\n.\nA\ndevice\nin/out\nArray of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,m)\n. On exit, the contents of\nA\nare destroyed.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\ndataTypeS\nhost\ninput\nData type of array\nS\n.\nS\ndevice\noutput\nReal array of dimension\nmin(m,n)\n. The singular values of A, sorted so that\nS(i)\n>=\nS(i+1)\n.\ndataTypeU\nhost\ninput\nData type of array\nU\n.\nU\ndevice\noutput\nArray of dimension\nldu\n*\nm\nwith\nldu\nis not less than\nmax(1,m)\n.\nU\ncontains the\n\\(m \\times m\\)\nunitary matrix\nU\n.\nldu\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nU\n.\ndataTypeVT\nhost\ninput\nData type of array\nVT\n.\nVT\ndevice\noutput\nArray of dimension\nldvt\n*\nn\nwith\nldvt\nis not less than\nmax(1,n)\n.\nVT\ncontains the\n\\(n \\times n\\)\nunitary matrix V**T.\nldvt\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nVt\n.\ncomputeType\nhost\ninput\nData type of computation.\nbufferOnDevice\ndevice\nin/out\nDevice workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnDevice\nbytes.\nworkspaceInBytesOnDevice\nhost\ninput\nSize in bytes of\nbufferOnDevice\n, returned by\ncusolverDnXgesvd_bufferSize\n.\nbufferOnHost\nhost\nin/out\nHost workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnHost\nbytes.\nworkspaceInBytesOnHost\nhost\ninput\nSize in bytes of\nbufferOnHost\n, returned by\ncusolverDnXgesvd_bufferSize\n.\ninfo\ndevice\noutput\nIf\ninfo\n=\n0\n, the operation is successful. If\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle). If\ninfo\n>\n0\n,\ninfo\nindicates how many superdiagonals of an intermediate bidiagonal form did not converge to zero.\nThe generic API has three different types,\ndataTypeA\nis data type of the matrix\nA\n,\ndataTypeS\nis data type of the vector\nS\nand\ndataTypeU\nis data type of the matrix\nU\n,\ndataTypeVT\nis data type of the matrix\nVT\n,\ncomputeType\nis compute type of the operation.\ncusolverDnXgesvd\nonly supports the following four combinations.\nValid combination of data type and compute type\nDataTypeA\nDataTypeS\nDataTypeU\nDataTypeVT\nComputeType\nMeaning\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nSGESVD\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nDGESVD\nCUDA_C_32F\nCUDA_R_32F\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nCGESVD\nCUDA_C_64F\nCUDA_R_64F\nCUDA_C_64F\nCUDA_C_64F\nCUDA_C_64F\nZGESVD\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,n<0\nor\nlda<max(1,m)\nor\nldu<max(1,m)\nor\nldvt<max(1,n)\n).\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.5.2.\ncusolverDnXgesvdp()\n\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverDnXgesvdp_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\ncusolverEigMode_t\njobz\n,\nint\necon\n,\nint64_t\nm\n,\nint64_t\nn\n,\ncudaDataType\ndataTypeA\n,\nconst\nvoid\n*\nA\n,\nint64_t\nlda\n,\ncudaDataType\ndataTypeS\n,\nconst\nvoid\n*\nS\n,\ncudaDataType\ndataTypeU\n,\nconst\nvoid\n*\nU\n,\nint64_t\nldu\n,\ncudaDataType\ndataTypeV\n,\nconst\nvoid\n*\nV\n,\nint64_t\nldv\n,\ncudaDataType\ncomputeType\n,\nsize_t\n*\nworkspaceInBytesOnDevice\n,\nsize_t\n*\nworkspaceInBytesOnHost\n)\nThe routine below:\ncusolverStatus_t\ncusolverDnXgesvdp\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\ncusolverEigMode_t\njobz\n,\nint\necon\n,\nint64_t\nm\n,\nint64_t\nn\n,\ncudaDataType\ndataTypeA\n,\nvoid\n*\nA\n,\nint64_t\nlda\n,\ncudaDataType\ndataTypeS\n,\nvoid\n*\nS\n,\ncudaDataType\ndataTypeU\n,\nvoid\n*\nU\n,\nint64_t\nldu\n,\ncudaDataType\ndataTypeV\n,\nvoid\n*\nV\n,\nint64_t\nldv\n,\ncudaDataType\ncomputeType\n,\nvoid\n*\nbufferOnDevice\n,\nsize_t\nworkspaceInBytesOnDevice\n,\nvoid\n*\nbufferOnHost\n,\nsize_t\nworkspaceInBytesOnHost\n,\nint\n*\nd_info\n,\ndouble\n*\nh_err_sigma\n)\nThis function computes the singular value decomposition (SVD) of an\n\\(m \\times n\\)\nmatrix\nA\nand corresponding the left and/or right singular vectors. The SVD is written\n\\[A = U*\\Sigma*V^H\\]\nwhere\nΣ\nis an\n\\(m \\times n\\)\nmatrix which is zero except for its\nmin(m,n)\ndiagonal elements,\nU\nis an\n\\(m \\times m\\)\nunitary matrix, and\nV\nis an\n\\(n \\times n\\)\nunitary matrix. The diagonal elements of\nΣ\nare the singular values of\nA\n; they are real and non-negative, and are returned in descending order. The first\nmin(m,n)\ncolumns of\nU\nand\nV\nare the left and right singular vectors of\nA\n.\ncusolverDnXgesvdp\ncombines polar decomposition in [14] and\ncusolverDnXsyevd\nto compute SVD. It is much faster than\ncusolverDnXgesvd\nwhich is based on QR algorithm. However polar decomposition in [14] may not deliver a full unitary matrix when the matrix A has a singular value close to zero. To workaround the issue when the singular value is close to zero, we add a small perturbation so polar decomposition can deliver the correct result. The consequence is inaccurate singular values shifted by this perturbation. The output parameter\nh_err_sigma\nis the magnitude of this perturbation. In other words,\nh_err_sigma\nshows the accuracy of SVD.\nThe user has to provide device and host working spaces which are pointed by input parameters\nbufferOnDevice\nand\nbufferOnHost\n. The input parameters\nworkspaceInBytesOnDevice\n(and\nworkspaceInBytesOnHost\n) is size in bytes of the device (and host) working space, and it is returned by\ncusolverDnXgesvdp_bufferSize()\n.\nIf output parameter\ninfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nCurrently,\ncusolverDnXgesvdp\nsupports only the default algorithm.\nAlgorithms supported by cusolverDnXgesvdp\nCUSOLVER_ALG_0\nor\nNULL\nDefault algorithm.\nPlease visit\ncuSOLVER Library Samples - Xgesvdp\nfor a code example.\nRemark 1:\ngesvdp\nsupports\nn>=m\nas well.\nRemark 2: the routine returns\nV\n, not\n\\(V^{H}\\)\nList of input arguments for\ncusolverDnXgesvdp_bufferSize\nand\ncusolverDnXgesvdp\n:\nAPI of cusolverDnXgesvdp\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nparams\nhost\ninput\nStructure with information collected by\ncusolverDnSetAdvOptions\n.\njobz\nhost\ninput\nSpecifies options to either compute singular values only or compute singular vectors as well:\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n: Compute singular values only.\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n: Compute singular values and singular vectors.\necon\nhost\ninput\necon\n=\n1\nfor economy size for\nU\nand\nV\n.\nm\nhost\ninput\nNumber of rows of matrix\nA\n.\nn\nhost\ninput\nNumber of columns of matrix\nA\n.\ndataTypeA\nhost\ninput\nData type of array\nA\n.\nA\ndevice\nin/out\nArray of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,m)\n. On exit, the contents of\nA\nare destroyed.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\ndataTypeS\nhost\ninput\nData type of array\nS\n.\nS\ndevice\noutput\nReal array of dimension\nmin(m,n)\n. The singular values of A, sorted so that\nS(i)\n>=\nS(i+1)\n.\ndataTypeU\nhost\ninput\nData type of array\nU\n.\nU\ndevice\noutput\nArray of dimension\nldu\n*\nm\nwith\nldu\nis not less than\nmax(1,m)\n.\nU\ncontains the\n\\(m \\times m\\)\nunitary matrix\nU\n. If\necon=1\n, only reports first\nmin(m,n)\ncolumns of\nU\n.\nldu\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nU\n.\ndataTypeV\nhost\ninput\nData type of array\nV\n.\nV\ndevice\noutput\nArray of dimension\nldv\n*\nn\nwith\nldv\nis not less than\nmax(1,n)\n.\nV\ncontains the\n\\(n \\times n\\)\nunitary matrix V. if\necon=1\n, only reports first\nmin(m,n)\ncolumns of\nV\n.\nldv\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nV\n.\ncomputeType\nhost\ninput\nData type of computation.\nbufferOnDevice\ndevice\nin/out\nDevice workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnDevice\nbytes.\nworkspaceInBytesOnDevice\nhost\ninput\nSize in bytes of\nbufferOnDevice\n, returned by\ncusolverDnXgesvdp_bufferSize\n.\nbufferOnHost\nhost\nin/out\nHost workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnHost\nbytes.\nworkspaceInBytesOnHost\nhost\ninput\nSize in bytes of\nbufferOnHost\n, returned by\ncusolverDnXgesvdp_bufferSize\n.\ninfo\ndevice\noutput\nIf\ninfo\n=\n0\n, the operation is successful. If\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle).\nh_err_sigma\nhost\noutput\nMagnitude of the perturbation, showing the accuracy of SVD.\nThe generic API has three different types,\ndataTypeA\nis data type of the matrix\nA\n,\ndataTypeS\nis data type of the vector\nS\nand\ndataTypeU\nis data type of the matrix\nU\n,\ndataTypeV\nis data type of the matrix\nV\n,\ncomputeType\nis compute type of the operation.\ncusolverDnXgesvdp\nonly supports the following four combinations:\nValid combination of data type and compute type\nDataTypeA\nDataTypeS\nDataTypeU\nDataTypeV\nComputeType\nMeaning\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nSGESVDP\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nDGESVDP\nCUDA_C_32F\nCUDA_R_32F\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nCGESVDP\nCUDA_C_64F\nCUDA_R_64F\nCUDA_C_64F\nCUDA_C_64F\nCUDA_C_64F\nZGESVDP\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,n<0\nor\nlda<max(1,m)\nor\nldu<max(1,m)\nor\nldv<max(1,n)\n).\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.5.3.\ncusolverDnXgesvdr()\n\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverDnXgesvdr_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\nsigned\nchar\njobu\n,\nsigned\nchar\njobv\n,\nint64_t\nm\n,\nint64_t\nn\n,\nint64_t\nk\n,\nint64_t\np\n,\nint64_t\nniters\n,\ncudaDataType\ndataTypeA\n,\nconst\nvoid\n*\nA\n,\nint64_t\nlda\n,\ncudaDataType\ndataTypeSrand\n,\nconst\nvoid\n*\nSrand\n,\ncudaDataType\ndataTypeUrand\n,\nconst\nvoid\n*\nUrand\n,\nint64_t\nldUrand\n,\ncudaDataType\ndataTypeVrand\n,\nconst\nvoid\n*\nVrand\n,\nint64_t\nldVrand\n,\ncudaDataType\ncomputeType\n,\nsize_t\n*\nworkspaceInBytesOnDevice\n,\nsize_t\n*\nworkspaceInBytesOnHost\n)\nThe routine below\ncusolverStatus_t\ncusolverDnXgesvdr\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\nsigned\nchar\njobu\n,\nsigned\nchar\njobv\n,\nint64_t\nm\n,\nint64_t\nn\n,\nint64_t\nk\n,\nint64_t\np\n,\nint64_t\nniters\n,\ncudaDataType\ndataTypeA\n,\nvoid\n*\nA\n,\nint64_t\nlda\n,\ncudaDataType\ndataTypeSrand\n,\nvoid\n*\nSrand\n,\ncudaDataType\ndataTypeUrand\n,\nvoid\n*\nUrand\n,\nint64_t\nldUrand\n,\ncudaDataType\ndataTypeVrand\n,\nvoid\n*\nVrand\n,\nint64_t\nldVrand\n,\ncudaDataType\ncomputeType\n,\nvoid\n*\nbufferOnDevice\n,\nsize_t\nworkspaceInBytesOnDevice\n,\nvoid\n*\nbufferOnHost\n,\nsize_t\nworkspaceInBytesOnHost\n,\nint\n*\nd_info\n)\nThis function computes the approximated rank-k singular value decomposition (k-SVD) of an\n\\(m \\times n\\)\nmatrix\nA\nand the corresponding left and/or right singular vectors. The k-SVD is written as\n\\[A_{k}\\approx U*\\Sigma*V^{H}\\]\nwhere\nΣ\nis a\n\\(k \\times k\\)\nmatrix which is zero except for its diagonal elements,\nU\nis an\n\\(m \\times k\\)\northonormal matrix, and\nV\nis an\n\\(k \\times n\\)\northonormal matrix. The diagonal elements of\nΣ\nare the approximated singular values of\nA\n; they are real and non-negative, and are returned in descending order. The columns of\nU\nand\nV\nare the top-\nk\nleft and right singular vectors of\nA\n.\ncusolverDnXgesvdr\nimplements randomized methods described in [15] to compute k-SVD that is accurate with high probability if the conditions described in [15] hold.\ncusolverDnXgesvdr\nis intended to compute a very small portion of the spectrum (meaning that\nk\nis very small compared to\nmin(m,n)\n). of\nA\nfast and with good quality, specially when the dimensions of the matrix are large.\nThe accuracy of the method depends on the spectrum of\nA\n, the number of power iterations\nniters\n, the oversampling parameter\np\nand the ratio between\np\nand the dimensions of the matrix\nA\n. Larger values of oversampling\np\nor larger number of iterations\nniters\nmight produce more accurate approximations, but it will also increase the run time of\ncusolverDnXgesvdr\n.\nOur recommendation is to use two iterations and set the oversampling to at least\n2k\n. Once the solver provides enough accuracy, adjust the values of\nk\nand\nniters\nfor better performance.\nThe user has to provide device and host working spaces which are pointed by input parameters\nbufferOnDevice\nand\nbufferOnHost\n. The input parameters\nworkspaceInBytesOnDevice\n(and\nworkspaceInBytesOnHost\n) is size in bytes of the device (and host) working space, and it is returned by\ncusolverDnXgesvdr_bufferSize()\n.\nIf output parameter\ninfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nCurrently,\ncusolverDnXgesvdr\nsupports only the default algorithm.\nAlgorithms supported by cusolverDnXgesvdr\nCUSOLVER_ALG_0\nor\nNULL\nDefault algorithm.\nPlease visit\ncuSOLVER Library Samples - Xgesvdr\nfor a code example.\nRemark 1:\ngesvdr\nsupports\nn>=m\nas well.\nRemark 2: the routine returns\nV\n, not\n\\(V^{H}\\)\nList of input arguments for\ncusolverDnXgesvdr_bufferSize\nand\ncusolverDnXgesvdr\n:\nAPI of cusolverDnXgesvdr\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nparams\nhost\ninput\nStructure with information collected by\ncusolverDnSetAdvOptions\n.\njobu\nhost\ninput\nSpecifies options for computing all or part of the matrix\nU\n: = ‘S’: the first k columns of U (the left singular vectors) are returned in the array U; = ‘N’: no columns of U (no left singular vectors) are computed.\njobv\nhost\ninput\nSpecifies options for computing all or part of the matrix V: = ‘S’: the first k rows of V (the right singular vectors) are returned in the array V; = ‘N’: no rows of V (no right singular vectors) are computed.\nm\nhost\ninput\nNumber of rows of matrix\nA\n.\nn\nhost\ninput\nNumber of columns of matrix\nA\n.\nk\nhost\ninput\nRank of the k-SVD decomposition of matrix\nA\n.\nrank\nis less than\nmin(m,n)\n.\np\nhost\ninput\nOversampling. The size of the subspace will be\n(k\n+\np)\n.\n(k+p)\nis less than\nmin(m,n)\n.\nniters\nhost\ninput\nNumber of iteration of power method.\ndataTypeA\nhost\ninput\nData type of array\nA\n.\nA\ndevice\nin/out\nArray of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,m)\n. On exit, the contents of\nA\nare destroyed.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\ndataTypeS\nhost\ninput\nData type of array\nS\n.\nS\ndevice\noutput\nReal array of dimension\nmin(m,n)\n. The singular values of A, sorted so that\nS(i)\n>=\nS(i+1)\n.\ndataTypeU\nhost\ninput\nData type of array\nU\n.\nU\ndevice\noutput\nArray of dimension\nldu\n*\nm\nwith\nldu\nis not less than\nmax(1,m)\n.\nU\ncontains the\n\\(m \\times m\\)\nunitary matrix\nU\n. if\njobu=S\n, only reports first min(m,n) columns of\nU\n.\nldu\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nU\n.\ndataTypeV\nhost\ninput\nData type of array\nV\n.\nV\ndevice\noutput\nArray of dimension\nldv\n*\nn\nwith\nldv\nis not less than\nmax(1,n)\n.\nV\ncontains the\n\\(n \\times n\\)\nunitary matrix V. If\njobv=S\n, only reports first min(m,n) columns of\nV\n.\nldv\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nV\n.\ncomputeType\nhost\ninput\nData type of computation.\nbufferOnDevice\ndevice\nin/out\nDevice workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnDevice\nbytes.\nworkspaceInBytesOnDevice\nhost\ninput\nSize in bytes of\nbufferOnDevice\n, returned by\ncusolverDnXgesvdr_bufferSize\n.\nbufferOnHost\nhost\nin/out\nHost workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnHost\nbytes.\nworkspaceInBytesOnHost\nhost\ninput\nSize in bytes of\nbufferOnHost\n, returned by\ncusolverDnXgesvdr_bufferSize\n.\nd_info\ndevice\noutput\nIf\ninfo\n=\n0\n, the operation is successful. If\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle).\nThe generic API has five different types,\ndataTypeA\nis data type of the matrix\nA\n,\ndataTypeS\nis data type of the vector\nS\nand\ndataTypeU\nis data type of the matrix\nU\n,\ndataTypeV\nis data type of the matrix\nV\n,\ncomputeType\nis compute type of the operation.\ncusolverDnXgesvdr\nonly supports the following four combinations.\nValid combination of data type and compute type\nDataTypeA\nDataTypeS\nDataTypeU\nDataTypeV\nComputeType\nMeaning\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nSGESVDR\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nDGESVDR\nCUDA_C_32F\nCUDA_R_32F\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nCGESVDR\nCUDA_C_64F\nCUDA_R_64F\nCUDA_C_64F\nCUDA_C_64F\nCUDA_C_64F\nZGESVDR\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,n<0\nor\nlda<max(1,m)\nor\nldu<max(1,m)\nor\nldv<max(1,n)\n).\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.5.4.\ncusolverDnXsyevd()\n\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverDnXsyevd_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint64_t\nn\n,\ncudaDataType\ndataTypeA\n,\nconst\nvoid\n*\nA\n,\nint64_t\nlda\n,\ncudaDataType\ndataTypeW\n,\nconst\nvoid\n*\nW\n,\ncudaDataType\ncomputeType\n,\nsize_t\n*\nworkspaceInBytesOnDevice\n,\nsize_t\n*\nworkspaceInBytesOnHost\n)\nThe following routine:\ncusolverStatus_t\ncusolverDnXsyevd\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint64_t\nn\n,\ncudaDataType\ndataTypeA\n,\nvoid\n*\nA\n,\nint64_t\nlda\n,\ncudaDataType\ndataTypeW\n,\nvoid\n*\nW\n,\ncudaDataType\ncomputeType\n,\nvoid\n*\nbufferOnDevice\n,\nsize_t\nworkspaceInBytesOnDevice\n,\nvoid\n*\nbufferOnHost\n,\nsize_t\nworkspaceInBytesOnHost\n,\nint\n*\ninfo\n)\ncomputes eigenvalues and eigenvectors of a symmetric (Hermitian)\n\\(n \\times n\\)\nmatrix\nA\nusing the generic API interface. The standard symmetric eigenvalue problem is\n\\[A*V = V*\\Lambda\\]\nwhere\nΛ\nis a real\n\\(n \\times n\\)\ndiagonal matrix.\nV\nis an\n\\(n \\times n\\)\nunitary matrix. The diagonal elements of\nΛ\nare the eigenvalues of\nA\nin ascending order.\nThe user has to provide device and host working spaces which are pointed by input parameters\nbufferOnDevice\nand\nbufferOnHost\n. The input parameters\nworkspaceInBytesOnDevice\n(and\nworkspaceInBytesOnHost\n) is size in bytes of the device (and host) working space, and it is returned by\ncusolverDnXsyevd_bufferSize()\n.\nIf output parameter\ninfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle). If\ninfo\n=\ni\n(greater than zero),\ni\noff-diagonal elements of an intermediate tridiagonal form did not converge to zero.\nIf\njobz\n= CUSOLVER_EIG_MODE_VECTOR,\nA\ncontains the orthonormal eigenvectors of the matrix\nA\n. The eigenvectors are computed by a divide and conquer algorithm.\nPlease visit\ncuSOLVER Library Samples - Xsyevd\nfor a code example.\nCurrently,\ncusolverDnXsyevd\nsupports only the default algorithm.\nAlgorithms supported by cusolverDnXsyevd\nCUSOLVER_ALG_0\nor\nNULL\nDefault algorithm.\nList of input arguments for\ncusolverDnXsyevd_bufferSize\nand\ncusolverDnXsyevd\n:\nAPI of cusolverDnXsyevd\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nparams\nhost\ninput\nStructure with information collected by\ncusolverDnSetAdvOptions\n.\njobz\nhost\ninput\nSpecifies options to either compute eigenvalue only or compute eigen-pair:\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n: Compute eigenvalues only;\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n: Compute eigenvalues and eigenvectors.\nuplo\nhost\ninput\nSpecifies which part of\nA\nis stored.\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n: Lower triangle of\nA\nis stored.\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n: Upper triangle of\nA\nis stored.\nn\nhost\ninput\nNumber of rows (or columns) of matrix\nA\n.\ndataTypeA\nhost\nin\nData type of array\nA\n.\nA\ndevice\nin/out\nArray of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,n)\n. If\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n, the leading n-by-n upper triangular part of\nA\ncontains the upper triangular part of the matrix\nA\n. If\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n, the leading n-by-n lower triangular part of\nA\ncontains the lower triangular part of the matrix\nA\n. On exit, if\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n, and\ninfo\n= 0,\nA\ncontains the orthonormal eigenvectors of the matrix\nA\n. If\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n, the contents of\nA\nare destroyed.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\ndataTypeW\nhost\nin\nData type of array\nW\n.\nW\ndevice\noutput\nA real array of dimension\nn\n. The eigenvalue values of\nA\n, in ascending order, i.e., sorted so that\nW(i)\n<=\nW(i+1)\n.\ncomputeType\nhost\nin\nData type of computation.\nbufferOnDevice\ndevice\nin/out\nDevice workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnDevice\nbytes.\nworkspaceInBytesOnDevice\nhost\ninput\nSize in bytes of\nbufferOnDevice\n, returned by\ncusolverDnXsyevd_bufferSize\n.\nbufferOnHost\nhost\nin/out\nHost workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnHost\nbytes.\nworkspaceInBytesOnHost\nhost\ninput\nSize in bytes of\nbufferOnHost\n, returned by\ncusolverDnXsyevd_bufferSize\n.\ninfo\ndevice\noutput\nIf\ninfo\n=\n0\n, the operation is successful. If\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle). If\ninfo\n=\ni\n(>\n0)\n,\ninfo\nindicates\ni\noff-diagonal elements of an intermediate tridiagonal form did not converge to zero.\nThe generic API has three different types,\ndataTypeA\nis data type of the matrix\nA\n,\ndataTypeW\nis data type of the matrix\nW\nand\ncomputeType\nis compute type of the operation.\ncusolverDnXsyevd\nonly supports the following four combinations.\nValid combination of data type and compute type\nDataTypeA\nDataTypeW\nComputeType\nMeaning\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nSSYEVD\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nDSYEVD\nCUDA_C_32F\nCUDA_R_32F\nCUDA_C_32F\nCHEEVD\nCUDA_C_64F\nCUDA_R_64F\nCUDA_C_64F\nZHEEVD\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\n, or\nlda<max(1,n)\n, or\njobz\nis not\nCUSOLVER_EIG_MODE_NOVECTOR\nor\nCUSOLVER_EIG_MODE_VECTOR\n, or\nuplo\nis not\nCUBLAS_FILL_MODE_LOWER\nor\nCUBLAS_FILL_MODE_UPPER\n).\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.5.5.\ncusolverDnXsyevdx()\n\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverDnXsyevdx_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\ncusolverEigMode_t\njobz\n,\ncusolverEigRange_t\nrange\n,\ncublasFillMode_t\nuplo\n,\nint64_t\nn\n,\ncudaDataType\ndataTypeA\n,\nconst\nvoid\n*\nA\n,\nint64_t\nlda\n,\nvoid\n*\nvl\n,\nvoid\n*\nvu\n,\nint64_t\nil\n,\nint64_t\niu\n,\nint64_t\n*\nh_meig\n,\ncudaDataType\ndataTypeW\n,\nconst\nvoid\n*\nW\n,\ncudaDataType\ncomputeType\n,\nsize_t\n*\nworkspaceInBytesOnDevice\n,\nsize_t\n*\nworkspaceInBytesOnHost\n)\nThe following routine:\ncusolverStatus_t\ncusolverDnXsyevdx\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\ncusolverEigMode_t\njobz\n,\ncusolverEigRange_t\nrange\n,\ncublasFillMode_t\nuplo\n,\nint64_t\nn\n,\ncudaDataType\ndataTypeA\n,\nvoid\n*\nA\n,\nint64_t\nlda\n,\nvoid\n*\nvl\n,\nvoid\n*\nvu\n,\nint64_t\nil\n,\nint64_t\niu\n,\nint64_t\n*\nmeig64\n,\ncudaDataType\ndataTypeW\n,\nvoid\n*\nW\n,\ncudaDataType\ncomputeType\n,\nvoid\n*\nbufferOnDevice\n,\nsize_t\nworkspaceInBytesOnDevice\n,\nvoid\n*\nbufferOnHost\n,\nsize_t\nworkspaceInBytesOnHost\n,\nint\n*\ninfo\n)\ncomputes all or selection of the eigenvalues and optionally eigenvectors of a symmetric (Hermitian)\n\\(n \\times n\\)\nmatrix\nA\nusing the generic API interface. The standard symmetric eigenvalue problem is\n\\[A*V = V*\\Lambda\\]\nwhere\nΛ\nis a real\nn×h_meig\ndiagonal matrix.\nV\nis an\nn×h_meig\nunitary matrix.\nh_meig\nis the number of eigenvalues/eigenvectors computed by the routine,\nh_meig\nis equal to\nn\nwhen the whole spectrum (e.g.,\nrange\n=\nCUSOLVER_EIG_RANGE_ALL\n) is requested. The diagonal elements of\nΛ\nare the eigenvalues of\nA\nin ascending order.\nThe user has to provide device and host working spaces which are pointed by input parameters\nbufferOnDevice\nand\nbufferOnHost\n. The input parameters\nworkspaceInBytesOnDevice\n(and\nworkspaceInBytesOnHost\n) is size in bytes of the device (and host) working space, and it is returned by\ncusolverDnXsyevdx_bufferSize()\n.\nIf output parameter\ninfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle). If\ninfo\n=\ni\n(greater than zero),\ni\noff-diagonal elements of an intermediate tridiagonal form did not converge to zero.\nif\njobz\n= CUSOLVER_EIG_MODE_VECTOR,\nA\ncontains the orthonormal eigenvectors of the matrix\nA\n. The eigenvectors are computed by a divide and conquer algorithm.\nCurrently,\ncusolverDnXsyevdx\nsupports only the default algorithm.\nPlease visit\ncuSOLVER Library Samples - Xsyevdx\nfor a code example.\nAlgorithms supported by cusolverDnXsyevdx\nCUSOLVER_ALG_0\nor\nNULL\nDefault algorithm.\nList of input arguments for\ncusolverDnXsyevdx_bufferSize\nand\ncusolverDnXsyevdx\n:\nAPI of cusolverDnXsyevdx\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nparams\nhost\ninput\nStructure with information collected by\ncusolverDnSetAdvOptions\n.\njobz\nhost\ninput\nSpecifies options to either compute eigenvalue only or compute eigen-pair:\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n: Compute eigenvalues only;\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n: Compute eigenvalues and eigenvectors.\nrange\nhost\ninput\nSpecifies options to which selection of eigenvalues and optionally eigenvectors that need to be computed:\nrange\n=\nCUSOLVER_EIG_RANGE_ALL\n: all eigenvalues/eigenvectors will be found, will becomes the classical syevd/heevd routine;\nrange\n=\nCUSOLVER_EIG_RANGE_V\n: all eigenvalues/eigenvectors in the half-open interval (vl,vu] will be found;\nrange\n=\nCUSOLVER_EIG_RANGE_I\n: the il-th through iu-th eigenvalues/eigenvectors will be found;\nuplo\nhost\ninput\nSpecifies which part of\nA\nis stored.\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n: Lower triangle of\nA\nis stored.\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n: Upper triangle of\nA\nis stored.\nn\nhost\ninput\nNumber of rows (or columns) of matrix\nA\n.\ndataTypeA\nhost\nin\nData type of array\nA\n.\nA\ndevice\nin/out\nArray of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,n)\n. If\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n, the leading n-by-n upper triangular part of\nA\ncontains the upper triangular part of the matrix\nA\n. If\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n, the leading n-by-n lower triangular part of\nA\ncontains the lower triangular part of the matrix\nA\n. On exit, if\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n, and\ninfo\n= 0,\nA\ncontains the orthonormal eigenvectors of the matrix\nA\n. If\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n, the contents of\nA\nare destroyed.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\nlda\nis not less than\nmax(1,n)\n.\nvl,vu\nhost\ninput\nIf\nrange\n=\nCUSOLVER_EIG_RANGE_V\n, the lower and upper bounds of the interval to be searched for eigenvalues. vl > vu. Not referenced if\nrange\n=\nCUSOLVER_EIG_RANGE_ALL\nor\nrange\n=\nCUSOLVER_EIG_RANGE_I\n. Note that, if eigenvalues are very close to each other, it is well known that two different eigenvalues routines might find slightly different number of eigenvalues inside the same interval. This is due to the fact that different eigenvalue algorithms, or even same algorithm but different run might find eigenvalues within some rounding error close to the machine precision. Thus, if the user want to be sure not to miss any eigenvalue within the interval bound, we suggest that, the user subtract/add epsilon (machine precision) to the interval bound such as (vl=vl-eps, vu=vu+eps]. this suggestion is valid for any selective routine from cuSolver or LAPACK.\nil,iu\nhost\ninput\nInteger. If\nrange\n=\nCUSOLVER_EIG_RANGE_I\n, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 <= il <= iu <= n, if n > 0; il = 1 and iu = 0 if n = 0. Not referenced if\nrange\n=\nCUSOLVER_EIG_RANGE_ALL\nor\nrange\n=\nCUSOLVER_EIG_RANGE_V\n.\nh_meig\nhost\noutput\nInteger. The total number of eigenvalues found. 0 <= h_meig <= n. If\nrange\n=\nCUSOLVER_EIG_RANGE_ALL\n, h_meig = n, and if\nrange\n=\nCUSOLVER_EIG_RANGE_I\n, h_meig = iu-il+1.\ndataTypeW\nhost\nin\nData type of array\nW\n.\nW\ndevice\noutput\nA real array of dimension\nn\n. The eigenvalue values of\nA\n, in ascending order, i.e., sorted so that\nW(i)\n<=\nW(i+1)\n.\ncomputeType\nhost\nin\nData type of computation.\nbufferOnDevice\ndevice\nin/out\nDevice workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnDevice\nbytes.\nworkspaceInBytesOnDevice\nhost\ninput\nSize in bytes of\nbufferOnDevice\n, returned by\ncusolverDnXsyevdx_bufferSize\n.\nbufferOnHost\nhost\nin/out\nHost workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnHost\nbytes.\nworkspaceInBytesOnHost\nhost\ninput\nSize in bytes of\nbufferOnHost\n, returned by\ncusolverDnXsyevdx_bufferSize\n.\ninfo\ndevice\noutput\nIf\ninfo\n=\n0\n, the operation is successful. if\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle). If\ninfo\n=\ni\n(>\n0)\n,\ninfo\nindicates\ni\noff-diagonal elements of an intermediate tridiagonal form did not converge to zero.\nThe generic API has three different types,\ndataTypeA\nis data type of the matrix\nA\n,\ndataTypeW\nis data type of the matrix\nW\nand\ncomputeType\nis compute type of the operation.\ncusolverDnXsyevdx\nonly supports the following four combinations:\nValid combination of data type and compute type\nDataTypeA\nDataTypeW\nComputeType\nMeaning\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nSSYEVDX\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nDSYEVDX\nCUDA_C_32F\nCUDA_R_32F\nCUDA_C_32F\nCHEEVDX\nCUDA_C_64F\nCUDA_R_64F\nCUDA_C_64F\nZHEEVDX\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\n, or\nlda<max(1,n)\n, or\njobz\nis not\nCUSOLVER_EIG_MODE_NOVECTOR\nor\nCUSOLVER_EIG_MODE_VECTOR\n, or\nrange\nis not\nCUSOLVER_EIG_RANGE_ALL\nor\nCUSOLVER_EIG_RANGE_V\nor\nCUSOLVER_EIG_RANGE_I\n, or\nuplo\nis not\nCUBLAS_FILL_MODE_LOWER\nor\nCUBLAS_FILL_MODE_UPPER\n).\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.5.6.\ncusolverDnXsyevBatched()\n\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverDnXsyevBatched_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint64_t\nn\n,\ncudaDataType\ndataTypeA\n,\nconst\nvoid\n*\nA\n,\nint64_t\nlda\n,\ncudaDataType\ndataTypeW\n,\nconst\nvoid\n*\nW\n,\ncudaDataType\ncomputeType\n,\nsize_t\n*\nworkspaceInBytesOnDevice\n,\nsize_t\n*\nworkspaceInBytesOnHost\n,\nint64_t\nbatchSize\n)\nThe following routine:\ncusolverStatus_t\ncusolverDnXsyevBatched\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint64_t\nn\n,\ncudaDataType\ndataTypeA\n,\nvoid\n*\nA\n,\nint64_t\nlda\n,\ncudaDataType\ndataTypeW\n,\nvoid\n*\nW\n,\ncudaDataType\ncomputeType\n,\nvoid\n*\nbufferOnDevice\n,\nsize_t\nworkspaceInBytesOnDevice\n,\nvoid\n*\nbufferOnHost\n,\nsize_t\nworkspaceInBytesOnHost\n,\nint\n*\ninfo\n,\nint64_t\nbatchSize\n)\ncomputes eigenvalues and eigenvectors of a sequence of symmetric (Hermitian)\n\\(n \\times n\\)\nmatrices\n\\[A_j*V_j = V_j*\\Lambda_j\\]\nwhere\n\\(\\Lambda_j\\)\nis a real\n\\(n \\times n\\)\ndiagonal matrix.\n\\(V_j\\)\nis an\n\\(n \\times n\\)\nunitary matrix. The diagonal elements of\n\\(\\Lambda_j\\)\nare the eigenvalues of\n\\(A_j\\)\nin ascending order.\nsyevBatched\nperforms an eigendecomposition on each matrix. It requires that all matrices are of the same size\nn\nand are packed in a contiguous way,\n\\[\\begin{split}A = \\begin{pmatrix}\n{A0} & {A1} & \\cdots \\\\\n\\end{pmatrix}\\end{split}\\]\nEach matrix is column-major with leading dimension\nlda\n, so the formula for random access is\n\\(A_{k}\\operatorname{(i,j)} = {A\\lbrack\\ i\\ +\\ lda*j\\ +\\ lda*n*k\\rbrack}\\)\n.\nThe parameter\nW\nalso contains the eigenvalues of each matrix in a contiguous way,\n\\[\\begin{split}W = \\begin{pmatrix}\n{W0} & {W1} & \\cdots \\\\\n\\end{pmatrix}\\end{split}\\]\nThe formula for random access of\nW\nis\n\\(W_{k}\\operatorname{(j)} = {W\\lbrack\\ j\\ +\\ n*k\\rbrack}\\)\n.\nThe user has to provide device and host working space which are pointed to by the input parameters\nbufferOnDevice\nand\nbufferOnHost\n. The input parameters\nworkspaceInBytesOnDevice\nand\nworkspaceInBytesOnHost\ndenote the size in bytes of the device and host working space, and returned by\ncusolverDnXsyevBatched_bufferSize()\n.\nThe output parameter\ninfo\nis an integer array of size\nbatchSize\n. If the function returns\nCUSOLVER_STATUS_INVALID_VALUE\n, the first element\ninfo[0]\n=\n-i\n(less than zero) indicates the\ni-th\nparameter is wrong (not counting handle). Otherwise, if\ninfo[i]\n>\n0\n,\nsyevBatched\ndoes not converge on the\ni-th\nmatrix.\nIf\njobz\n= CUSOLVER_EIG_MODE_VECTOR,\n\\(A_{j}\\)\ncontains the orthonormal eigenvectors of the matrix\n\\(A_{j}\\)\n.\nNote that the problem size is limited by the condition\nn*lda*batchSize<=INT32_MAX\nprimarily due to the current implementation constraints.\nAlgorithms supported by cusolverDnXsyevBatched\n\nCUSOLVER_ALG_0\nor\nNULL\nDefault. May switch between algorithms for best performance.\nCUSOLVER_ALG_1\nUses a single algorithm for consistent accuracy over all n.\nList of input arguments for\ncusolverDnXsyevBatched_bufferSize\nand\ncusolverDnXsyevBatched\n:\nAPI of cusolverDnXsyevBatched\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nparams\nhost\ninput\nStructure with information collected by\ncusolverDnSetAdvOptions\n.\njobz\nhost\ninput\nSpecifies options to either compute eigenvalue only or compute eigen-pair:\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n: Compute eigenvalues only;\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n: Compute eigenvalues and eigenvectors.\nuplo\nhost\ninput\nSpecifies which part of\nA\nis stored.\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n: Lower triangle of\nA\nis stored.\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n: Upper triangle of\nA\nis stored.\nn\nhost\ninput\nNumber of rows (or columns) of matrix\nA\n.\ndataTypeA\nhost\nin\nData type of array\nA\n.\nA\ndevice\nin/out\nArray of dimension\nlda\n*\nn\n*\nbatchSize\nwith\nlda\nis not less than\nmax(1,n)\n. If\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n, the leading n-by-n upper triangular part of\nAj\ncontains the upper triangular part of the matrix\nAj\n. If\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n, the leading n-by-n lower triangular part of\nAj\ncontains the lower triangular part of the matrix\nAj\n. On exit, if\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n, and\ninfo[j]\n= 0,\nAj\ncontains the orthonormal eigenvectors of the matrix\nAj\n. If\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n, the contents of\nAj\nare destroyed.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nAj\n.\nlda\nis not less than\nmax(1,n)\n.\ndataTypeW\nhost\nin\nData type of array\nW\n.\nW\ndevice\noutput\nA real array of dimension\nn\n*\nbatchSize\n. The eigenvalue values of\nAj\n, in ascending order, i.e., sorted so that\nWj(i)\n<=\nWj(i+1)\n.\ncomputeType\nhost\nin\nData type of computation.\nbufferOnDevice\ndevice\nin/out\nDevice workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnDevice\nbytes.\nworkspaceInBytesOnDevice\nhost\ninput\nSize in bytes of\nbufferOnDevice\n, returned by\ncusolverDnXsyevBatched_bufferSize\n.\nbufferOnHost\nhost\nin/out\nHost workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnHost\nbytes.\nworkspaceInBytesOnHost\nhost\ninput\nSize in bytes of\nbufferOnHost\n, returned by\ncusolverDnXsyevBatched_bufferSize\n.\ninfo\ndevice\noutput\nAn integer array of dimension\nbatchSize\n. If\nCUSOLVER_STATUS_INVALID_VALUE\nis returned,\ninfo[0]\n=\n-i\n(less than zero) indicates\ni-th\nparameter is wrong (not counting handle). Otherwise, if\ninfo[i]\n=\n0\n, the operation is successful. If\ninfo[i]\n>\n0\n,\nsyevBatched\ndoes not converge on the\ni-th\nmatrix.\nbatchSize\nhost\ninput\nNumber of matrices.\nbatchSize\nis not less than 1.\nThe generic API has three different types,\ndataTypeA\nis data type of the matrix\nA\n,\ndataTypeW\nis data type of the array\nW\nand\ncomputeType\nis compute type of the operation.\ncusolverDnXsyevBatched\nonly supports the following four combinations:\nValid combination of data type and compute type\nDataTypeA\nDataTypeW\nComputeType\nMeaning\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nSSYEVBATCHED\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nDSYEVBATCHED\nCUDA_C_32F\nCUDA_R_32F\nCUDA_C_32F\nCSYEVBATCHED\nCUDA_C_64F\nCUDA_R_64F\nCUDA_C_64F\nZSYEVBATCHED\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn<0\n, or\nn*lda*batchSize>INT32_MAX\n, or\nlda<max(1,n)\n, or\njobz\nis not\nCUSOLVER_EIG_MODE_NOVECTOR\nor\nuplo\nis not\nCUBLAS_FILL_MODE_LOWER\nor\nCUBLAS_FILL_MODE_UPPER\nor\nbatchSize<0\n).\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.4.5.7.\ncusolverDnXgeev()\n\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverDnXgeev_bufferSize\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\ncusolverEigMode_t\njobvl\n,\ncusolverEigMode_t\njobvr\n,\nint64_t\nn\n,\ncudaDataType\ndataTypeA\n,\nconst\nvoid\n*\nA\n,\nint64_t\nlda\n,\ncudaDataType\ndataTypeW\n,\nconst\nvoid\n*\nW\n,\ncudaDataType\ndataTypeVL\n,\nconst\nvoid\n*\nVL\n,\nint64_t\nldvl\n,\ncudaDataType\ndataTypeVR\n,\nconst\nvoid\n*\nVR\n,\nint64_t\nldvr\n,\ncudaDataType\ncomputeType\n,\nsize_t\n*\nworkspaceInBytesOnDevice\n,\nsize_t\n*\nworkspaceInBytesOnHost\n)\nThe following routine:\ncusolverStatus_t\ncusolverDnXgeev\n(\ncusolverDnHandle_t\nhandle\n,\ncusolverDnParams_t\nparams\n,\ncusolverEigMode_t\njobvl\n,\ncusolverEigMode_t\njobvr\n,\nint64_t\nn\n,\ncudaDataType\ndataTypeA\n,\nvoid\n*\nA\n,\nint64_t\nlda\n,\ncudaDataType\ndataTypeW\n,\nvoid\n*\nW\n,\ncudaDataType\ndataTypeVL\n,\nvoid\n*\nVL\n,\nint64_t\nldvl\n,\ncudaDataType\ndataTypeVR\n,\nvoid\n*\nVR\n,\nint64_t\nldvr\n,\ncudaDataType\ncomputeType\n,\nvoid\n*\nbufferOnDevice\n,\nsize_t\nworkspaceInBytesOnDevice\n,\nvoid\n*\nbufferOnHost\n,\nsize_t\nworkspaceInBytesOnHost\n,\nint\n*\ninfo\n)\ncomputes for an n-by-n real non-symmetric or complex non-Hermitian matrix\nA\nthe eigenvalues and, optionally, the left and/or right eigenvectors. The right eigenvector\nv(j)\nof\nA\nsatisfies\n\\[A*v(j) = w(j)*v(j)\\]\nwhere\nw(j)\nis its eigenvalue. The left eigenvalue\nu(j)\nof\nA\nsatisfies\n\\[u(j)^{H}*A = w(j)*v(j)^{H}\\]\nwhere\n\\(u(j)^{H}\\)\ndenotes the conjugate-transpose of\nu(j)\n.\nThe computed eigenvectors are normalized to have Euclidean norm equal to 1 and largest component real.\nIf\nA\nis real-valued, there are two options to return the eigenvalues in\nW\n. The first options sets all data types to real-valued types. Then\nW\nholds\n2*n\nentries. The first n entries hold the real parts and the last n entries hold the imaginary parts. The LAPACK interface with separate arrays for the real parts\nWR\nand the imaginary parts\nWI\ncan be recovered by settings pointers\nWR\n=\nW\n,\nWI\n=\nW+n\n. The second option uses a complex data type for\nW\n. Then\nW\nis n entries long; each real eigenvalue is stored as a complex number and for each complex conjugate pair, both eigenvalues are returned. The computation is still executed fully in real arithmetic.\nThe user has to provide device and host working space which are pointed to by the input parameters\nbufferOnDevice\nand\nbufferOnHost\n. The input parameters\nworkspaceInBytesOnDevice\nand\nworkspaceInBytesOnHost\ndenote the size in bytes of the device and host working space, and returned by\ncusolverDnXgeev_bufferSize()\n.\nIf the output parameter\ninfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle). If\ninfo\n=\n0\n, the QR algorithm converged and\nW\ncontains the computed eigenvalues of\nA\nand, if requested, the corresponding left and/or right eigenvectors have been computed. If\ninfo\n=\ni\n(greater than zero), the QR algorithm failed to compute all the eigenvalues and no eigenvectors have been computed. The elements\ni+1:n\nof\nW\ncontain eigenvalues which have converged.\nRemark 1:\ngeev\nonly supports the computation of right eigenvectors. So,\njobvl\n=\nCUSOLVER_EIG_MODE_NOVECTOR\nmust be set.\nRemark 2:\ngeev\nuses balancing to improve the conditioning of the eigenvalues and eigenvectors.\nRemark 3:\ngeev\nis a hybrid CPU-GPU algorithm. Best performance is attained with pinned host memory.\nCurrently,\ncusolverDnXgeev\nsupports only the default algorithm.\nPlease visit\ncuSOLVER Library Samples - Xgeev\nfor a code example.\nTable of algorithms supported by cusolverDnXgeev\nCUSOLVER_ALG_0\nor\nNULL\nDefault algorithm.\nList of input arguments for\ncusolverDnXgeev_bufferSize\nand\ncusolverDnXgeev\n:\nAPI of cusolverDnXgeev\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverDN library context.\nparams\nhost\ninput\nStructure with information collected by\ncusolverDnSetAdvOptions\n.\njobvl\nhost\ninput\nSpecifies whether or not to compute left eigenvectors.\njobvl\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n: Do not compute left eigenvectors of\nA\n;\njobvl\n=\nCUSOLVER_EIG_MODE_VECTOR\n: Compute left eigenvectors of\nA\n.\njobvr\nhost\ninput\nSpecifies whether or not to compute right eigenvectors.\njobvl\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n: Do not compute left eigenvectors of\nA\n;\njobvl\n=\nCUSOLVER_EIG_MODE_VECTOR\n: Compute left eigenvectors of\nA\n.\nn\nhost\ninput\nNumber of rows (or columns) of matrix\nA\n.\ndataTypeA\nhost\nin\nData type of array\nA\n.\nA\ndevice\nin/out\nArray of dimension\nlda\n*\nn\nwith\nlda\nis not less than\nmax(1,n)\n. On entry, the n-by-n matrix\nA\n. On exit,\nA\nhas been overwritten.\nlda\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nA\n.\ndataTypeW\nhost\nin\nData type of array\nW\n.\nW\ndevice\noutput\nArray holding the computed eigenvalues of\nA\n. Its length is\n2*n\nif\ndataTypeA\n=\nCUDA_R_32F\nand\ndataTypeW\n=\nCUDA_R_32F\nor\ndataTypeA\n=\nCUDA_R_64F\nand\ndataTypeW\n=\nCUDA_R_64F\nand the first n entries of\nW\nhold the real parts and the last n entries of\nW\nhold the imaginary parts of the eigenvalues. Otherwise, the length is\nn\n.\ndataTypeVL\nhost\nin\nData type of array\nVL\n.\nVL\ndevice\noutput\nArray of dimension\nldvl\n*\nn\n. If\njobvl\n=\nCUSOLVER_EIG_MODE_VECTOR\n, the left eigenvectors\nu(j)\nare stored one after another in the columns of\nVL\n, in the same order as their eigenvalues. If\ndatatypeVL\nis complex or the\nj-th\neigenvalue is real, then\nu(j)\n=\nVL(:,j)\n, the\nj-th\ncolumn of\nVL\n. If\ndataTypeVL\nis real and the\nj-th\nand\n(j+1)-st\neigenvalues form a complex conjugate pair, then\nu(j)\n=\nVL(:,j)\n+\ni*VL(:,j+1)\nand\nu(j+1)\n=\nVL(:,j)\n-\ni*VL(:,j+1)\n. If\njobvl\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n,\nVL\nis not referenced.\nldvl\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nVL\nwith\nldvl\n>=\n1\n. If\njobvl\n=\nCUSOLVER_EIG_MODE_VECTOR\n,\nldvl\n>=\nn\n.\ndataTypeVR\nhost\nin\nData type of array\nVR\n.\nVR\ndevice\noutput\nArray of dimension\nldvr\n*\nn\n. If\njobvr\n=\nCUSOLVER_EIG_MODE_VECTOR\n, the right eigenvectors\nv(j)\nare stored one after another in the columns of\nVR\n, in the same order as their eigenvalues. If\ndatatypeVR\nis complex or the\nj-th\neigenvalue is real, then\nv(j)\n=\nVR(:,j)\n, the\nj-th\ncolumn of\nVR\n. If\ndataTypeVR\nis real and the\nj-th\nand\n(j+1)-st\neigenvalues form a complex conjugate pair, then\nv(j)\n=\nVR(:,j)\n+\ni*VR(:,j+1)\nand\nv(j+1)\n=\nVR(:,j)\n-\ni*VR(:,j+1)\n. If\njobvr\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n,\nVR\nis not referenced.\nldvr\nhost\ninput\nLeading dimension of two-dimensional array used to store matrix\nVR\nwith\nldvr\n>=\n1\n. If\njobvr\n=\nCUSOLVER_EIG_MODE_VECTOR\n,\nldvr\n>=\nn\n.\ncomputeType\nhost\nin\nData type of computation.\nbufferOnDevice\ndevice\nin/out\nDevice workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnDevice\nbytes.\nworkspaceInBytesOnDevice\nhost\ninput\nSize in bytes of\nbufferOnDevice\n, returned by\ncusolverDnXgeev_bufferSize\n.\nbufferOnHost\nhost\nin/out\nHost workspace. Array of type\nvoid\nof size\nworkspaceInBytesOnHost\nbytes.\nworkspaceInBytesOnHost\nhost\ninput\nSize in bytes of\nbufferOnHost\n, returned by\ncusolverDnXgeev_bufferSize\n.\ninfo\ndevice\noutput\nIf\ninfo\n=\n0\n, the operation is successful. If\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle). If\ninfo\n=\ni\n(greater than zero), the QR algorithm failed to compute all the eigenvalues and no eigenvectors have been computed; elements\ni+1:n\nof\nW\ncontain eigenvalues which have converged.\nThe generic API has five different types,\ndataTypeA\nis the data type of the matrix\nA\n,\ndataTypeW\nis the data type of the array\nW\n,\ndataTypeVL\nis the data type of the matrix\nVL\n,\ndataTypeVR\nis the data type of the matrix\nVR\nand\ncomputeType\nis compute type of the operation.\ncusolverDnXgeev\nonly supports the following four combinations:\nValid combination of data type and compute type\nDataTypeA\nDataTypeW\nDataTypeVL\nDataTypeVR\nComputeType\nMeaning\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nSGEEV\nCUDA_R_32F\nCUDA_C_32F\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\n32F mixed real-complex\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nDGEEV\nCUDA_R_64F\nCUDA_C_64F\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\n64F mixed real-complex\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nCGEEV\nCUDA_C_64F\nCUDA_C_64F\nCUDA_C_64F\nCUDA_C_64F\nCUDA_C_64F\nZGEEV\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\njobvl\nis not\nCUSOLVER_EIG_MODE_NOVECTOR\nor\nCUSOLVER_EIG_MODE_VECTOR\n, or\njobvr\nis not\nCUSOLVER_EIG_MODE_NOVECTOR\nor\nCUSOLVER_EIG_MODE_VECTOR\n,\nn<0\n, or\nlda\n<\nmax(1,n)\n, or\nldvl\n<\nn\nif\njobvl\nis\nCUSOLVER_EIG_MODE_VECTOR\n, or\nldvr\n<\nn\nif\njobvr\nis\nCUSOLVER_EIG_MODE_VECTOR\n).\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.5.\ncuSolverSP: sparse LAPACK Function Reference [[DEPRECATED]]\n\n[[DEPRECATED]] cuSolverSP is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\nThis section describes the API of cuSolverSP, which provides a subset of LAPACK functions for sparse matrices in CSR or CSC format.\n2.5.1.\nHelper Function Reference\n\n2.5.1.1.\ncusolverSpCreate() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverSpCreate\n(\ncusolverSpHandle_t\n*\nhandle\n)\nThis function initializes the cuSolverSP library and creates a handle on the cuSolver context. It must be called before any other cuSolverSP API function is invoked. It allocates hardware resources necessary for accessing the GPU.\nOutput\nhandle\nThe pointer to the handle to the cuSolverSP context.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe initialization succeeded.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe CUDA Runtime initialization failed.\nCUSOLVER_STATUS_ALLOC_FAILED\nThe resources could not be allocated.\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\n2.5.1.2.\ncusolverSpDestroy() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverSpDestroy\n(\ncusolverSpHandle_t\nhandle\n)\nThis function releases CPU-side resources used by the cuSolverSP library.\nInput\nhandle\nThe handle to the cuSolverSP context.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe shutdown succeeded.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\n2.5.1.3.\ncusolverSpSetStream() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverSpSetStream\n(\ncusolverSpHandle_t\nhandle\n,\ncudaStream_t\nstreamId\n)\nThis function sets the stream to be used by the cuSolverSP library to execute its routines.\nInput\nhandle\nThe handle to the cuSolverSP context.\nstreamId\nThe stream to be used by the library.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe stream was set successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\n2.5.1.4.\ncusolverSpXcsrissym() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\ncusolverStatus_t\ncusolverSpXcsrissymHost\n(\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrEndPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nint\n*\nissym\n);\nThis function checks if\nA\nhas symmetric pattern or not. The output parameter\nissym\nreports 1 if\nA\nis symmetric; otherwise, it reports 0.\nThe matrix\nA\nis an\n\\(m \\times m\\)\nsparse matrix that is defined in CSR storage format by the four arrays\ncsrValA\n,\ncsrRowPtrA\n,\ncsrEndPtrA\nand\ncsrColIndA\n.\nThe supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n.\nThe\ncsrlsvlu\nand\ncsrlsvqr\ndo not accept non-general matrix. the user has to extend the matrix into its missing upper/lower part, otherwise the result is not expected. The user can use\ncsrissym\nto check if the matrix has symmetric pattern or not.\nRemark 1: only CPU path is provided.\nRemark 2: the user has to check returned status to get valid information. The function converts\nA\nto CSC format and compare CSR and CSC format. If the CSC failed because of insufficient resources,\nissym\nis undefined, and this state can only be detected by the return status code.\nInput\nParameter\nMemorySpace\nDescription\nhandle\nhost\nHandle to the cuSolverSP library context.\nm\nhost\nNumber of rows and columns of matrix\nA\n.\nnnzA\nhost\nNumber of nonzeros of matrix\nA\n. It is the size of\ncsrValA\nand\ncsrColIndA\n.\ndescrA\nhost\nThe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrRowPtrA\nhost\nInteger array of\nm\nelements that contains the start of every row.\ncsrEndPtrA\nhost\nInteger array of\nm\nelements that contains the end of the last row plus one.\ncsrColIndA\nhost\nInteger array of\nnnzA\ncolumn indices of the nonzero elements of matrix\nA\n.\nOutput\nParameter\nMemorySpace\nDescription\nissym\nhost\n1 if\nA\nis symmetric; 0 otherwise.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_ALLOC_FAILED\nThe resources could not be allocated.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,nnzA<=0\n), base index is not 0 or 1.\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\nCUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED\nThe matrix type is not supported.\n2.5.2.\nHigh Level Function Reference\n\nThis section describes high level API of cuSolverSP, including linear solver, least-square solver and eigenvalue solver. The high-level API is designed for ease-of-use, so it allocates any required memory under the hood automatically. If the host or GPU system memory is not enough, an error is returned.\n2.5.2.1.\ncusolverSp<t>csrlsvlu() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverSpScsrlsvlu\n[\nHost\n](\ncusolverSpHandle_t\nhandle\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\nfloat\n*\nb\n,\nfloat\ntol\n,\nint\nreorder\n,\nfloat\n*\nx\n,\nint\n*\nsingularity\n);\ncusolverStatus_t\ncusolverSpDcsrlsvlu\n[\nHost\n](\ncusolverSpHandle_t\nhandle\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\ndouble\n*\nb\n,\ndouble\ntol\n,\nint\nreorder\n,\ndouble\n*\nx\n,\nint\n*\nsingularity\n);\ncusolverStatus_t\ncusolverSpCcsrlsvlu\n[\nHost\n](\ncusolverSpHandle_t\nhandle\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\ncuComplex\n*\nb\n,\nfloat\ntol\n,\nint\nreorder\n,\ncuComplex\n*\nx\n,\nint\n*\nsingularity\n);\ncusolverStatus_t\ncusolverSpZcsrlsvlu\n[\nHost\n](\ncusolverSpHandle_t\nhandle\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\ncuDoubleComplex\n*\nb\n,\ndouble\ntol\n,\nint\nreorder\n,\ncuDoubleComplex\n*\nx\n,\nint\n*\nsingularity\n);\nThis function solves the linear system\n\\[A*x = b\\]\nwhere\nA\nis an\n\\(n \\times n\\)\nsparse matrix that is defined in CSR storage format by the three arrays\ncsrValA\n,\ncsrRowPtrA\n, and\ncsrColIndA\n.\nb\nis the right-hand-side vector of size\nn\n, and\nx\nis the solution vector of size\nn\n.\nThe supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. If matrix\nA\nis symmetric/Hermitian and only lower/upper part is used or meaningful, the user has to extend the matrix into its missing upper/lower part, otherwise the result would be wrong.\nThe linear system is solved by sparse LU with partial pivoting:\n\\[P*A = L*U\\]\ncusolver\nlibrary provides three reordering schemes,\nsymrcm\nsymamd\n, and\ncsrmetisnd\nto reduce zero fill-in which dramatically affects the performance of LU factorization. The input parameter\nreorder\ncan enable\nsymrcm\n(\nsymamd\nor\ncsrmetisnd\n) if\nreorder\nis 1 (2, or 3), otherwise, no reordering is performed.\nIf\nreorder\nis nonzero,\ncsrlsvlu\ndoes\n\\[P*A*Q^{T} = L*U\\]\nwhere\n\\(Q = {symrcm}(A + A^{T})\\)\n.\nIf\nA\nis singular under given tolerance (\nmax(tol,0)\n), then some diagonal elements of\nU\nis zero, i.e.\n\\[{|U(j,j)|} < {tol\\ for\\ some\\ j}\\]\nThe output parameter\nsingularity\nis the smallest index of such\nj\n. If\nA\nis non-singular,\nsingularity\nis -1. The index is base-0, independent of base index of\nA\n. For example, if 2nd column of\nA\nis the same as first column, then\nA\nis singular and\nsingularity\n=\n1\nwhich means\nU(1,1)≈0\n.\nRemark 1:\ncsrlsvlu\nperforms traditional LU with partial pivoting, the pivot of k-th column is determined dynamically based on the k-th column of intermediate matrix.\ncsrlsvlu\nfollows Gilbert and Peierls’s algorithm [4] which uses depth-first-search and topological ordering to solve triangular system (Davis also describes this algorithm in detail in his book [1]). Since CUDA 10.1,\ncsrlsvlu\nwill incrementally reallocate the memory to store\nL\nand\nU\n. This feature can avoid over-estimate size from QR factorization. In some cases, zero fill-in of QR can be order of magnitude higher than LU.\nRemark 2: only CPU (Host) path is provided.\nInput\nParameter\ncusolverSp MemSpace\n*Host MemSpace\nDescription\nhandle\nhost\nhost\nHandle to the cuSolverSP library context.\nn\nhost\nhost\nNumber of rows and columns of matrix\nA\n.\nnnzA\nhost\nhost\nNumber of nonzeros of matrix\nA\n.\ndescrA\nhost\nhost\nThe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrValA\ndevice\nhost\n<type> array of\nnnzA\n\\(( =\\)\ncsrRowPtrA(n)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\nnonzero elements of matrix\nA\n.\ncsrRowPtrA\ndevice\nhost\nInteger array of\nn\n\\(+ 1\\)\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndA\ndevice\nhost\nInteger array of\nnnzA\n\\(( =\\)\ncsrRowPtrA(n)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero elements of matrix\nA\n.\nb\ndevice\nhost\nRight hand side vector of size\nn\n.\ntol\nhost\nhost\nTolerance to decide if singular or not.\nreorder\nhost\nhost\nNo ordering if\nreorder\n=0. Otherwise,\nsymrcm\n,\nsymamd\n, or\ncsrmetisnd\nis used to reduce zero fill-in.\nOutput\nParameter\ncusolverSp MemSpace\n*Host MemSpace\nDescription\nx\ndevice\nhost\nSolution vector of size\nn\n, x = inv(A)*b.\nsingularity\nhost\nhost\n-1 if\nA\nis invertible. Otherwise, first index\nj\nsuch that\nU(j,j)≈0\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_ALLOC_FAILED\nThe resources could not be allocated.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn,nnzA<=0\n, base index is not 0 or 1,\nreorder\nis not 0,1,2,3).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\nCUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED\nThe matrix type is not supported.\n2.5.2.2.\ncusolverSp<t>csrlsvqr() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\ncusolverStatus_t\ncusolverSpScsrlsvqr\n[\nHost\n](\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\nfloat\n*\nb\n,\nfloat\ntol\n,\nint\nreorder\n,\nfloat\n*\nx\n,\nint\n*\nsingularity\n);\ncusolverStatus_t\ncusolverSpDcsrlsvqr\n[\nHost\n](\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\ndouble\n*\nb\n,\ndouble\ntol\n,\nint\nreorder\n,\ndouble\n*\nx\n,\nint\n*\nsingularity\n);\ncusolverStatus_t\ncusolverSpCcsrlsvqr\n[\nHost\n](\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\ncuComplex\n*\nb\n,\nfloat\ntol\n,\nint\nreorder\n,\ncuComplex\n*\nx\n,\nint\n*\nsingularity\n);\ncusolverStatus_t\ncusolverSpZcsrlsvqr\n[\nHost\n](\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\ncuDoubleComplex\n*\nb\n,\ndouble\ntol\n,\nint\nreorder\n,\ncuDoubleComplex\n*\nx\n,\nint\n*\nsingularity\n);\nThis function solves the linear system\n\\[A*x = b\\]\nA\nis an\n\\(m \\times m\\)\nsparse matrix that is defined in CSR storage format by the three arrays\ncsrValA\n,\ncsrRowPtrA\n, and\ncsrColIndA\n.\nb\nis the right-hand-side vector of size\nm\n, and\nx\nis the solution vector of size\nm\n.\nThe supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. If matrix\nA\nis symmetric/Hermitian and only lower/upper part is used or meaningful, the user has to extend the matrix into its missing upper/lower part, otherwise the result would be wrong.\nThe linear system is solved by sparse QR factorization,\n\\[A\\ =\\ Q*R\\]\nIf\nA\nis singular under given tolerance (\nmax(tol,0)\n), then some diagonal elements of\nR\nis zero, i.e.\n\\[{|R(j,j)|} < {tol\\ for\\ some\\ j}\\]\nThe output parameter\nsingularity\nis the smallest index of such\nj\n. If\nA\nis non-singular,\nsingularity\nis -1. The\nsingularity\nis base-0, independent of base index of\nA\n. For example, if 2nd column of\nA\nis the same as first column, then\nA\nis singular and\nsingularity\n=\n1\nwhich means\nR(1,1)≈0\n.\ncusolver\nlibrary provides three reordering schemes,\nsymrcm\nsymamd\n, and\ncsrmetisnd\nto reduce zero fill-in which dramatically affects the performance of QR factorization. The input parameter\nreorder\ncan enable\nsymrcm\n(\nsymamd\nor\ncsrmetisnd\n) if\nreorder\nis 1 (2, or 3), otherwise, no reordering is performed.\nInput\nParameter\ncusolverSp MemSpace\n*Host MemSpace\nDescription\nhandle\nhost\nhost\nHandle to the cuSolverSP library context.\nm\nhost\nhost\nNumber of rows and columns of matrix\nA\n.\nnnz\nhost\nhost\nNumber of nonzeros of matrix\nA\n.\ndescrA\nhost\nhost\nThe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrValA\ndevice\nhost\n<type> array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\nnonzero elements of matrix\nA\n.\ncsrRowPtrA\ndevice\nhost\nInteger array of\nm\n\\(+ 1\\)\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndA\ndevice\nhost\nInteger array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero elements of matrix\nA\n.\nb\ndevice\nhost\nRight hand side vector of size\nm\n.\ntol\nhost\nhost\nTolerance to decide if singular or not.\nreorder\nhost\nhost\nNo ordering if\nreorder\n=0. Otherwise,\nsymrcm\n,\nsymamd\n, or\ncsrmetisnd\nis used to reduce zero fill-in.\nOutput\nParameter\ncusolverSp MemSpace\n*Host MemSpace\nDescription\nx\ndevice\nhost\nSolution vector of size\nm\n, x = inv(A)*b.\nsingularity\nhost\nhost\n-1 if\nA\nis invertible. Otherwise, first index j such that\nR(j,j)≈0\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_ALLOC_FAILED\nThe resources could not be allocated.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,nnz<=0\n, base index is not 0 or 1,\nreorder\nis not 0,1,2,3)\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\nCUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED\nThe matrix type is not supported.\n2.5.2.3.\ncusolverSp<t>csrlsvchol() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverSpScsrlsvchol\n[\nHost\n](\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\ncsrVal\n,\nconst\nint\n*\ncsrRowPtr\n,\nconst\nint\n*\ncsrColInd\n,\nconst\nfloat\n*\nb\n,\nfloat\ntol\n,\nint\nreorder\n,\nfloat\n*\nx\n,\nint\n*\nsingularity\n);\ncusolverStatus_t\ncusolverSpDcsrlsvchol\n[\nHost\n](\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\ncsrVal\n,\nconst\nint\n*\ncsrRowPtr\n,\nconst\nint\n*\ncsrColInd\n,\nconst\ndouble\n*\nb\n,\ndouble\ntol\n,\nint\nreorder\n,\ndouble\n*\nx\n,\nint\n*\nsingularity\n);\ncusolverStatus_t\ncusolverSpCcsrlsvchol\n[\nHost\n](\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\ncsrVal\n,\nconst\nint\n*\ncsrRowPtr\n,\nconst\nint\n*\ncsrColInd\n,\nconst\ncuComplex\n*\nb\n,\nfloat\ntol\n,\nint\nreorder\n,\ncuComplex\n*\nx\n,\nint\n*\nsingularity\n);\ncusolverStatus_t\ncusolverSpZcsrlsvchol\n[\nHost\n](\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\ncsrVal\n,\nconst\nint\n*\ncsrRowPtr\n,\nconst\nint\n*\ncsrColInd\n,\nconst\ncuDoubleComplex\n*\nb\n,\ndouble\ntol\n,\nint\nreorder\n,\ncuDoubleComplex\n*\nx\n,\nint\n*\nsingularity\n);\nThis function solves the linear system\n\\[A*x = b\\]\nA\nis an\n\\(m \\times m\\)\nsymmetric positive definite sparse matrix that is defined in CSR storage format by the three arrays\ncsrValA\n,\ncsrRowPtrA\n, and\ncsrColIndA\n.\nb\nis the right-hand-side vector of size\nm\n, and\nx\nis the solution vector of size\nm\n.\nThe supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\nand upper triangular part of\nA\nis ignored (if parameter\nreorder\nis zero). In other words, suppose input matrix\nA\nis decomposed as\n\\(A = L + D + U\\)\n, where\nL\nis lower triangular,\nD\nis diagonal and\nU\nis upper triangular. The function would ignore\nU\nand regard\nA\nas a symmetric matrix with the formula\n\\(A = L + D + L^{H}\\)\n. If parameter\nreorder\nis nonzero, the user has to extend\nA\nto a full matrix, otherwise the solution would be wrong.\nThe linear system is solved by sparse Cholesky factorization,\n\\[A = G*G^{H}\\]\nwhere\nG\nis the Cholesky factor, a lower triangular matrix.\nThe output parameter\nsingularity\nhas two meanings:\nIf\nA\nis not positive definite, there exists some integer\nk\nsuch that\nA(0:k,\n0:k)\nis not positive definite.\nsingularity\nis the minimum of such\nk\n.\nIf\nA\nis positive definite but near singular under tolerance (\nmax(tol,0)\n), i.e. there exists some integer\nk\nsuch that\n\\(G\\begin{pmatrix}\n{k,k} \\\\\n\\end{pmatrix}<={tol}\\)\n.\nsingularity\nis the minimum of such\nk\n.\nsingularity\nis base-0. If\nA\nis positive definite and not near singular under tolerance,\nsingularity\nis -1. If the user wants to know if\nA\nis positive definite or not,\ntol=0\nis enough.\ncusolver\nlibrary provides three reordering schemes,\nsymrcm\nsymamd\n, and\ncsrmetisnd\nto reduce zero fill-in which dramatically affects the performance of Cholesky factorization. The input parameter\nreorder\ncan enable\nsymrcm\n(\nsymamd\nor\ncsrmetisnd\n) if\nreorder\nis 1 (2, or 3), otherwise, no reordering is performed.\nRemark 1: the function works for in-place (\nx\nand\nb\npoint to the same memory block) and out-of-place.\nRemark 2: the function only works on 32-bit index, if matrix\nG\nhas large zero fill-in such that number of nonzeros is bigger than\n\\(2^{31}\\)\n, then\nCUSOLVER_STATUS_ALLOC_FAILED\nis returned.\nInput\nParameter\ncusolverSp MemSpace\n*Host MemSpace\nDescription\nhandle\nhost\nhost\nHandle to the cuSolverSP library context.\nm\nhost\nhost\nNumber of rows and columns of matrix\nA\n.\nnnz\nhost\nhost\nNumber of nonzeros of matrix\nA\n.\ndescrA\nhost\nhost\nThe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrValA\ndevice\nhost\n<type> array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\nnonzero elements of matrix\nA\n.\ncsrRowPtrA\ndevice\nhost\nInteger array of\nm\n\\(+ 1\\)\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndA\ndevice\nhost\nInteger array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero elements of matrix\nA\n.\nb\ndevice\nhost\nRight hand side vector of size\nm\n.\ntol\nhost\nhost\nTolerance to decide singularity.\nreorder\nhost\nhost\nNo ordering if\nreorder\n=0. Otherwise,\nsymrcm\n,\nsymamd\n, or\ncsrmetisnd\nis used to reduce zero fill-in.\nOutput\nParameter\ncusolverSp MemSpace\n*Host MemSpace\nDescription\nx\ndevice\nhost\nSolution vector of size\nm\n, x = inv(A)*b.\nsingularity\nhost\nhost\n-1 if\nA\nis symmetric positive definite.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_ALLOC_FAILED\nThe resources could not be allocated.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,nnz<=0\n, base index is not 0 or 1,\nreorder\nis not 0,1,2,3).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\nCUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED\nThe matrix type is not supported.\n2.5.2.4.\ncusolverSp<t>csrlsqvqr() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverSpScsrlsqvqr\n[\nHost\n](\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\nfloat\n*\nb\n,\nfloat\ntol\n,\nint\n*\nrankA\n,\nfloat\n*\nx\n,\nint\n*\np\n,\nfloat\n*\nmin_norm\n);\ncusolverStatus_t\ncusolverSpDcsrlsqvqr\n[\nHost\n](\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\ndouble\n*\nb\n,\ndouble\ntol\n,\nint\n*\nrankA\n,\ndouble\n*\nx\n,\nint\n*\np\n,\ndouble\n*\nmin_norm\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverSpCcsrlsqvqr\n[\nHost\n](\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\ncuComplex\n*\nb\n,\nfloat\ntol\n,\nint\n*\nrankA\n,\ncuComplex\n*\nx\n,\nint\n*\np\n,\nfloat\n*\nmin_norm\n);\ncusolverStatus_t\ncusolverSpZcsrlsqvqr\n[\nHost\n](\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\ncuDoubleComplex\n*\nb\n,\ndouble\ntol\n,\nint\n*\nrankA\n,\ncuDoubleComplex\n*\nx\n,\nint\n*\np\n,\ndouble\n*\nmin_norm\n);\nThis function solves the following least-square problem:\n\\[x = {argmin}{\\|}A*z - b{\\|}\\]\nA\nis an\n\\(m \\times n\\)\nsparse matrix that is defined in CSR storage format by the three arrays\ncsrValA\n,\ncsrRowPtrA\n, and\ncsrColIndA\n.\nb\nis the right-hand-side vector of size\nm\n, and\nx\nis the least-square solution vector of size\nn\n.\nThe supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. If\nA\nis square, symmetric/Hermitian and only lower/upper part is used or meaningful, the user has to extend the matrix into its missing upper/lower part, otherwise the result is wrong.\nThis function only works if\nm\nis greater or equal to\nn\n, in other words,\nA\nis a tall matrix.\nThe least-square problem is solved by sparse QR factorization with column pivoting,\n\\[A*P^{T} = Q*R\\]\nIf\nA\nis of full rank (i.e. all columns of\nA\nare linear independent), then matrix\nP\nis an identity. Suppose rank of\nA\nis\nk\n, less than\nn\n, the permutation matrix\nP\nreorders columns of\nA\nin the following sense:\n\\[\\begin{split}A*P^{T} = \\begin{pmatrix}\nA_1 & A_2 \\\\\n\\end{pmatrix} = \\begin{pmatrix}\nQ_1 & Q_2 \\\\\n\\end{pmatrix}\\begin{pmatrix}\nR_{11} & R_{12} \\\\\n& R_{22} \\\\\n\\end{pmatrix}\\end{split}\\]\nwhere\n\\(R_{11}\\)\nand\nA\nhave the same rank, but\n\\(R_{22}\\)\nis almost zero, i.e. every column of\n\\(A_{2}\\)\nis linear combination of\n\\(A_{1}\\)\n.\nThe input parameter\ntol\ndecides numerical rank. The absolute value of every entry in\n\\(R_{22}\\)\nis less than or equal to\ntolerance=max(tol,0)\n.\nThe output parameter\nrankA\ndenotes numerical rank of\nA\n.\nSuppose\n\\(y = P*x\\)\nand\n\\(c = Q^{H}*b\\)\n, the least square problem can be reformed by\n\\[\\left. \\min\\|A*x - b\\| = \\min\\|R*y - c \\right.\\|\\]\nor in matrix form\n\\[\\begin{split}\\begin{pmatrix}\nR_{11} & R_{12} \\\\\n& R_{22} \\\\\n\\end{pmatrix}\\begin{pmatrix}\ny_{1} \\\\\ny_{2} \\\\\n\\end{pmatrix} = \\begin{pmatrix}\nc_{1} \\\\\nc_{2} \\\\\n\\end{pmatrix}\\end{split}\\]\nThe output parameter\nmin_norm\nis\n\\(\\left. \\|c_{2} \\right.\\|\\)\n, which is minimum value of least-square problem.\nIf\nA\nis not of full rank, above equation does not have a unique solution. The least-square problem is equivalent to\n\\[\\begin{split}\\begin{matrix}\n\\left. \\min\\|y \\right.\\| \\\\\n{{subject\\ to}R_{11}*y_{1} + R_{12}*y_{2} = c_{1}} \\\\\n\\end{matrix}\\end{split}\\]\nOr equivalently another least-square problem\n\\[\\begin{split} \\left.min\\| \\begin{pmatrix}\nR_{11} \\backslash R_{12} \\\\\nI\n\\end{pmatrix}\n* y_2 -\n\\begin{pmatrix}\nR_{11} \\backslash c_1 \\\\\nO\n\\end{pmatrix}\n\\right.\\|\\end{split}\\]\nThe output parameter\nx\nis\n\\(P^{T}*y\\)\n, the solution of least-square problem.\nThe output parameter\np\nis a vector of size\nn\n. It corresponds to a permutation matrix\nP\n.\np(i)=j\nmeans\n(P*x)(i)\n=\nx(j)\n. If\nA\nis of full rank,\np=0:n-1\n.\nRemark 1:\np\nis always base 0, independent of base index of\nA\n.\nRemark 2: only CPU (Host) path is provided.\nInput\nParameter\ncusolverSp MemSpace\n*Host MemSpace\nDescription\nhandle\nhost\nhost\nHandle to the cuSolver library context.\nm\nhost\nhost\nNumber of rows of matrix\nA\n.\nn\nhost\nhost\nNumber of columns of matrix\nA\n.\nnnz\nhost\nhost\nNumber of nonzeros of matrix\nA\n.\ndescrA\nhost\nhost\nThe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrValA\ndevice\nhost\n<type> array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\nnonzero elements of matrix\nA\n.\ncsrRowPtrA\ndevice\nhost\nInteger array of\nm\n\\(+ 1\\)\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndA\ndevice\nhost\nInteger array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero elements of matrix\nA\n.\nb\ndevice\nhost\nRight hand side vector of size\nm\n.\ntol\nhost\nhost\nTolerance to decide rank of\nA\n.\nOutput\nParameter\ncusolverSp MemSpace\n*Host MemSpace\nDescription\nrankA\nhost\nhost\nNumerical rank of\nA\n.\nx\ndevice\nhost\nSolution vector of size\nn\n, x=pinv(A)*b.\np\ndevice\nhost\nA vector of size\nn\n, which represents the permutation matrix\nP\nsatisfying A*P^T=Q*R.\nmin_norm\nhost\nhost\n||A*x-b||,\nx=pinv(A)*b\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_ALLOC_FAILED\nThe resources could not be allocated.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,n,nnz<=0\n), base index is not 0 or 1.\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\nCUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED\nThe matrix type is not supported.\n2.5.2.5.\ncusolverSp<t>csreigvsi() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverSpScsreigvsi\n[\nHost\n](\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nfloat\nmu0\n,\nconst\nfloat\n*\nx0\n,\nint\nmaxite\n,\nfloat\ntol\n,\nfloat\n*\nmu\n,\nfloat\n*\nx\n);\ncusolverStatus_t\ncusolverSpDcsreigvsi\n[\nHost\n](\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ndouble\nmu0\n,\nconst\ndouble\n*\nx0\n,\nint\nmaxite\n,\ndouble\ntol\n,\ndouble\n*\nmu\n,\ndouble\n*\nx\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverSpCcsreigvsi\n[\nHost\n](\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncuComplex\nmu0\n,\nconst\ncuComplex\n*\nx0\n,\nint\nmaxite\n,\nfloat\ntol\n,\ncuComplex\n*\nmu\n,\ncuComplex\n*\nx\n);\ncusolverStatus_t\ncusolverSpZcsreigvsi\n(\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncuDoubleComplex\nmu0\n,\nconst\ncuDoubleComplex\n*\nx0\n,\nint\nmaxite\n,\ndouble\ntol\n,\ncuDoubleComplex\n*\nmu\n,\ncuDoubleComplex\n*\nx\n);\nThis function solves the simple eigenvalue problem\n\\(A*x = \\lambda*x\\)\nby shift-inverse method.\nA\nis an\n\\(m \\times m\\)\nsparse matrix that is defined in CSR storage format by the three arrays\ncsrValA\n,\ncsrRowPtrA\n, and\ncsrColIndA\n. The output parameter\nx\nis the approximated eigenvector of size\nm\n,\nThe following shift-inverse method corrects eigenpair step-by-step until convergence.\nIt accepts several parameters:\nmu0\nis an initial guess of eigenvalue. The shift-inverse method will converge to the eigenvalue\nmu\nnearest\nmu0\nif\nmu\nis a singleton. Otherwise, the shift-inverse method may not converge.\nx0\nis an initial eigenvector. If the user has no preference, just chose\nx0\nrandomly.\nx0\nmust be nonzero. It can be non-unit length.\ntol\nis the tolerance to decide convergence. If\ntol\nis less than zero, it would be treated as zero.\nmaxite\nis maximum number of iterations. It is useful when shift-inverse method does not converge because the tolerance is too small or the desired eigenvalue is not a singleton.\nShift-Inverse Method\nGiven an initial guess of eigenvalue μ0 and initial vector x0\n\\[\\begin{split}x (0) = x0 \\text{ of unit length} \\\\\n\\text{for }j = 0 : maxite \\\\\n& \\text{solve } ( A - \\mu0 * I ) * x^{k+1} = x^{k} \\\\\n& \\text{normalize } x^{k+1} \\text{ to unit length} \\\\\n& \\text{compute approx. eigenvalue } \\mu = x^H * A * x \\text{ where } x = x^{k+1} \\\\\n& if \\| A * x^{k+1} - \\mu * x^{k+1} \\| < \\text{ tolerance, then stop} \\\\\n\\text{endfor}\\end{split}\\]\nThe supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. If\nA\nis symmetric/Hermitian and only lower/upper part is used or meaningful, the user has to extend the matrix into its missing upper/lower part, otherwise the result is wrong.\nRemark 1:\n[cu|h]solver[S|D]csreigvsi\nonly allows\nmu0\nas a real number. This works if\nA\nis symmetric. Otherwise, the non-real eigenvalue has a conjugate counterpart on the complex plan, and shift-inverse method would not converge to such eigenvalue even the eigenvalue is a singleton. The user has to extend\nA\nto complex numbers and call\n[cu|h]solver[C|Z]csreigvsi\nwith\nmu0\nnot on real axis.\nRemark 2: the tolerance\ntol\nshould not be smaller than |mu0|*eps, where eps is machine zero. Otherwise, shift-inverse may not converge because of small tolerance.\nInput\nParameter\ncusolverSp MemSpace\n*Host MemSpace\nDescription\nhandle\nhost\nhost\nHandle to the cuSolver library context.\nm\nhost\nhost\nNumber of rows and columns of matrix\nA\n.\nnnz\nhost\nhost\nNumber of nonzeros of matrix\nA\n.\ndescrA\nhost\nhost\nThe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrValA\ndevice\nhost\n<type> array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\nnonzero elements of matrix\nA\n.\ncsrRowPtrA\ndevice\nhost\nInteger array of\nm\n\\(+ 1\\)\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndA\ndevice\nhost\nInteger array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero elements of matrix\nA\n.\nmu0\nhost\nhost\nInitial guess of eigenvalue.\nx0\ndevice\nhost\nInitial guess of eigenvector, a vector of size\nm\n.\nmaxite\nhost\nhost\nMaximum iterations in shift-inverse method.\ntol\nhost\nhost\nTolerance for convergence.\nOutput\nParameter\ncusolverSp MemSpace\n*Host MemSpace\nDescription\nmu\ndevice\nhost\nApproximated eigenvalue nearest\nmu0\nunder tolerance.\nx\ndevice\nhost\nApproximated eigenvector of size\nm\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_ALLOC_FAILED\nThe resources could not be allocated.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,nnz<=0\n), base index is not 0 or 1.\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\nCUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED\nThe matrix type is not supported.\n2.5.2.6.\ncusolverSp<t>csreigs() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\nsolverspScsreigs\n[\nHost\n](\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncuComplex\nleft_bottom_corner\n,\ncuComplex\nright_upper_corner\n,\nint\n*\nnum_eigs\n);\ncusolverStatus_t\ncusolverSpDcsreigs\n[\nHost\n](\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncuDoubleComplex\nleft_bottom_corner\n,\ncuDoubleComplex\nright_upper_corner\n,\nint\n*\nnum_eigs\n);\ncusolverStatus_t\ncusolverSpCcsreigs\n[\nHost\n](\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncuComplex\nleft_bottom_corner\n,\ncuComplex\nright_upper_corner\n,\nint\n*\nnum_eigs\n);\ncusolverStatus_t\ncusolverSpZcsreigs\n[\nHost\n](\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncuDoubleComplex\nleft_bottom_corner\n,\ncuDoubleComplex\nright_upper_corner\n,\nint\n*\nnum_eigs\n);\nThis function computes number of algebraic eigenvalues in a given box\nB\nby contour integral\n\\[\\text{number of algebraic eigenvalues in box B} = \\frac{1}{2*\\pi*\\sqrt{- 1}}\\oint_{C}\\frac{P^{\\prime}{(z)}}{P(z)}dz\\]\nwhere closed line\nC\nis boundary of the box\nB\nwhich is a rectangle specified by two points, one is left bottom corner (input parameter\nleft_bottom_corner\n) and the other is right upper corner (input parameter\nright_upper_corner\n).\nP(z)=det(A\n-\nz*I)\nis the characteristic polynomial of\nA\n.\nA\nis an\n\\(m \\times m\\)\nsparse matrix that is defined in CSR storage format by the three arrays\ncsrValA\n,\ncsrRowPtrA\n, and\ncsrColIndA\n.\nThe output parameter\nnum_eigs\nis number of algebraic eigenvalues in the box\nB\n. This number may not be accurate due to several reasons:\nThe contour\nC\nis close to some eigenvalues or even passes through some eigenvalues.\nThe numerical integration is not accurate due to coarse grid size. The default resolution is 1200 grids along contour\nC\nuniformly.\nEven though\ncsreigs\nmay not be accurate, it still can give the user some idea how many eigenvalues in a region where the resolution of disk theorem is bad. For example, standard 3-point stencil of finite difference of Laplacian operator is a tridiagonal matrix, and disk theorem would show “all eigenvalues are in the interval [0, 4*N^2]” where N is number of grids. In this case,\ncsreigs\nis useful for any interval inside [0, 4*N^2].\nRemark 1: if\nA\nis symmetric in real or Hermitian in complex, all eigenvalues are real. The user still needs to specify a box, not an interval. The height of the box can be much smaller than the width.\nRemark 2: only CPU (Host) path is provided.\nInput\nParameter\ncusolverSp MemSpace\n*Host MemSpace\nDescription\nhandle\nhost\nhost\nHandle to the cuSolverSP library context.\nm\nhost\nhost\nNumber of rows and columns of matrix\nA\n.\nnnz\nhost\nhost\nNumber of nonzeros of matrix\nA\n.\ndescrA\nhost\nhost\nThe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrValA\ndevice\nhost\n<type> array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\nnonzero elements of matrix\nA\n.\ncsrRowPtrA\ndevice\nhost\nInteger array of\nm\n\\(+ 1\\)\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndA\ndevice\nhost\nInteger array of\nnnz\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\ncolumn indices of the nonzero elements of matrix\nA\n.\nleft_bottom_corner\nhost\nhost\nLeft bottom corner of the box.\nright_upper_corner\nhost\nhost\nRight upper corner of the box.\nOutput\nParameter\ncusolverSp MemSpace\n*Host MemSpace\nDescription\nnum_eigs\nhost\nhost\nNumber of algebraic eigenvalues in a box.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_ALLOC_FAILED\nThe resources could not be allocated.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,nnz<=0\n), base index is not 0 or 1.\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\nCUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED\nThe matrix type is not supported.\n2.5.3.\nLow Level Function Reference\n\nThis section describes low level API of cuSolverSP, including symrcm and batched QR.\n2.5.3.1.\ncusolverSpXcsrsymrcm() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\ncusolverStatus_t\ncusolverSpXcsrsymrcmHost\n(\ncusolverSpHandle_t\nhandle\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nint\n*\np\n);\nThis function implements Symmetric Reverse Cuthill-McKee permutation. It returns a permutation vector\np\nsuch that\nA(p,p)\nwould concentrate nonzeros to diagonal. This is equivalent to\nsymrcm\nin MATLAB, however the result may not be the same because of different heuristics in the pseudoperipheral finder. The\ncuSolverSP\nlibrary implements\nsymrcm\nbased on the following two papers:\nE. Cuthill and J. McKee, Reducing the bandwidth of sparse symmetric matrices, ACM ‘69 Proceedings of the 1969 24th national conference, Pages 157-172\nAlan George, Joseph W. H. Liu, An Implementation of a Pseudoperipheral Node Finder, ACM Transactions on Mathematical Software (TOMS) Volume 5 Issue 3, Sept. 1979, Pages 284-295\nThe output parameter\np\nis an integer array of\nn\nelements. It represents a permutation array and it indexed using the base-0 convention. The permutation array\np\ncorresponds to a permutation matrix\nP\n, and satisfies the following relation:\n\\[{A(p,p)} = P*A*P^{T}\\]\nA\nis an\n\\(n \\times n\\)\nsparse matrix that is defined in CSR storage format by the three arrays\ncsrValA\n,\ncsrRowPtrA\n, and\ncsrColIndA\n.\nThe supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Internally\nrcm\nworks on\n\\(A + A^{T}\\)\n, the user does not need to extend the matrix if the matrix is not symmetric.\nRemark 1: only CPU (Host) path is provided.\nInput\nParameter\n*Host MemSpace\nDescription\nhandle\nhost\nHandle to the cuSolverSP library context.\nn\nhost\nNumber of rows and columns of matrix\nA\n.\nnnzA\nhost\nNumber of nonzeros of matrix\nA\n. It is the size of\ncsrValA\nand\ncsrColIndA\n.\ndescrA\nhost\nThe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrRowPtrA\nhost\nInteger array of\nn+1\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndA\nhost\nInteger array of\nnnzA\ncolumn indices of the nonzero elements of matrix\nA\n.\nOutput\nParameter\nhsolver\nDescription\np\nhost\nPermutation vector of size\nn\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_ALLOC_FAILED\nThe resources could not be allocated.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn,nnzA<=0\n), base index is not 0 or 1.\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\nCUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED\nThe matrix type is not supported.\n2.5.3.2.\ncusolverSpXcsrsymmdq() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\ncusolverStatus_t\ncusolverSpXcsrsymmdqHost\n(\ncusolverSpHandle_t\nhandle\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nint\n*\np\n);\nThis function implements Symmetric Minimum Degree Algorithm based on Quotient Graph. It returns a permutation vector\np\nsuch that\nA(p,p)\nwould have less zero fill-in during Cholesky factorization. The\ncuSolverSP\nlibrary implements\nsymmdq\nbased on the following two papers:\nPatrick R. Amestoy, Timothy A. Davis, Iain S. Duff, An Approximate Minimum Degree Ordering Algorithm, SIAM J. Matrix Analysis Applic. Vol 17, no 4, pp. 886-905, Dec. 1996.\nAlan George, Joseph W. Liu, A Fast Implementation of the Minimum Degree Algorithm Using Quotient Graphs, ACM Transactions on Mathematical Software, Vol 6, No. 3, September 1980, page 337-358.\nThe output parameter\np\nis an integer array of\nn\nelements. It represents a permutation array with base-0 index. The permutation array\np\ncorresponds to a permutation matrix\nP\n, and satisfies the following relation:\n\\[{A(p,p)} = P*A*P^{T}\\]\nA\nis an\n\\(n \\times n\\)\nsparse matrix that is defined in CSR storage format by the three arrays\ncsrValA\n,\ncsrRowPtrA\n, and\ncsrColIndA\n.\nThe supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Internally\nmdq\nworks on\n\\(A + A^{T}\\)\n, the user does not need to extend the matrix if the matrix is not symmetric.\nRemark 1: only CPU (Host) path is provided.\nInput\nParameter\n*Host MemSpace\nDescription\nhandle\nhost\nHandle to the cuSolverSP library context.\nn\nhost\nNumber of rows and columns of matrix\nA\n.\nnnzA\nhost\nNumber of nonzeros of matrix\nA\n. It is the size of\ncsrValA\nand\ncsrColIndA\n.\ndescrA\nhost\nThe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrRowPtrA\nhost\nInteger array of\nn+1\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndA\nhost\nInteger array of\nnnzA\ncolumn indices of the nonzero elements of matrix\nA\n.\nOutput\nParameter\nhsolver\nDescription\np\nhost\nPermutation vector of size\nn\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_ALLOC_FAILED\nThe resources could not be allocated.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn,nnzA<=0\n), base index is not 0 or 1.\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\nCUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED\nThe matrix type is not supported.\n2.5.3.3.\ncusolverSpXcsrsymamd() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\ncusolverStatus_t\ncusolverSpXcsrsymamdHost\n(\ncusolverSpHandle_t\nhandle\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nint\n*\np\n);\nThis function implements Symmetric Approximate Minimum Degree Algorithm based on Quotient Graph. It returns a permutation vector\np\nsuch that\nA(p,p)\nwould have less zero fill-in during Cholesky factorization. The\ncuSolverSP\nlibrary implements\nsymamd\nbased on the following paper:\nPatrick R. Amestoy, Timothy A. Davis, Iain S. Duff, An Approximate Minimum Degree Ordering Algorithm, SIAM J. Matrix Analysis Applic. Vol 17, no 4, pp. 886-905, Dec. 1996.\nThe output parameter\np\nis an integer array of\nn\nelements. It represents a permutation array with base-0 index. The permutation array\np\ncorresponds to a permutation matrix\nP\n, and satisfies the following relation:\n\\[{A(p,p)} = P*A*P^{T}\\]\nA\nis an\n\\(n \\times n\\)\nsparse matrix that is defined in CSR storage format by the three arrays\ncsrValA\n,\ncsrRowPtrA\n, and\ncsrColIndA\n.\nThe supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Internally\namd\nworks on\n\\(A + A^{T}\\)\n, the user does not need to extend the matrix if the matrix is not symmetric.\nRemark 1: only CPU (Host) path is provided.\nInput\nParameter\n*Host MemSpace\nDescription\nhandle\nhost\nHandle to the cuSolverSP library context.\nn\nhost\nNumber of rows and columns of matrix\nA\n.\nnnzA\nhost\nNumber of nonzeros of matrix\nA\n. It is the size of\ncsrValA\nand\ncsrColIndA\n.\ndescrA\nhost\nThe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrRowPtrA\nhost\nInteger array of\nn+1\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndA\nhost\nInteger array of\nnnzA\ncolumn indices of the nonzero elements of matrix\nA\n.\nOutput\nParameter\nhsolver\nDescription\np\nhost\nPermutation vector of size\nn\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_ALLOC_FAILED\nThe resources could not be allocated.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn,nnzA<=0\n), base index is not 0 or 1.\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\nCUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED\nThe matrix type is not supported.\n2.5.3.4.\ncusolverSpXcsrmetisnd() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\ncusolverStatus_t\ncusolverSpXcsrmetisndHost\n(\ncusolverSpHandle_t\nhandle\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\nint64_t\n*\noptions\n,\nint\n*\np\n);\nThis function is a wrapper of\nMETIS_NodeND\n. It returns a permutation vector\np\nsuch that\nA(p,p)\nwould have less zero fill-in during nested dissection. The\ncuSolverSP\nlibrary links\nlibcusolver_metis_static.a\nwhich is 64-bit metis-5.1.0 .\nThe parameter\noptions\nis the configuration of\nmetis\n. For those who do not have experiences of\nmetis\n, set\noptions\n=\nNULL\nfor default setting.\nThe output parameter\np\nis an integer array of\nn\nelements. It represents a permutation array with base-0 index. The permutation array\np\ncorresponds to a permutation matrix\nP\n, and satisfies the following relation:\n\\[{A(p,p)} = P*A*P^{T}\\]\nA\nis an\n\\(n \\times n\\)\nsparse matrix that is defined in CSR storage format by the three arrays\ncsrValA\n,\ncsrRowPtrA\n, and\ncsrColIndA\n.\nThe supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Internally\ncsrmetisnd\nworks on\n\\(A + A^{T}\\)\n, the user does not need to extend the matrix if the matrix is not symmetric.\nRemark 1: only CPU (Host) path is provided.\nInput\nParameter\n*Host MemSpace\nDescription\nhandle\nhost\nHandle to the cuSolverSP library context.\nn\nhost\nNumber of rows and columns of matrix\nA\n.\nnnzA\nhost\nNumber of nonzeros of matrix\nA\n. It is the size of\ncsrValA\nand\ncsrColIndA\n.\ndescrA\nhost\nThe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrRowPtrA\nhost\nInteger array of\nn+1\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndA\nhost\nInteger array of\nnnzA\ncolumn indices of the nonzero elements of matrix\nA\n.\noptions\nhost\nInteger array to configure\nmetis\n.\nOutput\nParameter\n*Host MemSpace\nDescription\np\nhost\nPermutation vector of size\nn\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_ALLOC_FAILED\nThe resources could not be allocated.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn,nnzA<=0\n), base index is not 0 or 1.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\nCUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED\nThe matrix type is not supported.\n2.5.3.5.\ncusolverSpXcsrzfd() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\ncusolverStatus_t\ncusolverSpScsrzfdHost\n(\ncusolverSpHandle_t\nhandle\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nint\n*\nP\n,\nint\n*\nnumnz\n)\ncusolverStatus_t\ncusolverSpDcsrzfdHost\n(\ncusolverSpHandle_t\nhandle\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nint\n*\nP\n,\nint\n*\nnumnz\n)\ncusolverStatus_t\ncusolverSpCcsrzfdHost\n(\ncusolverSpHandle_t\nhandle\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nint\n*\nP\n,\nint\n*\nnumnz\n)\ncusolverStatus_t\ncusolverSpZcsrzfdHost\n(\ncusolverSpHandle_t\nhandle\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nint\n*\nP\n,\nint\n*\nnumnz\n)\nThis function implements MC21, zero-free diagonal algorithm. It returns a permutation vector\np\nsuch that\nA(p,:)\nhas no zero diagonal.\nA\nis an\n\\(n \\times n\\)\nsparse matrix that is defined in CSR storage format by the three arrays\ncsrValA\n,\ncsrRowPtrA\n, and\ncsrColIndA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n.\nThe output parameter\np\nis an integer array of\nn\nelements. It represents a permutation array with base-0 index. The permutation array\np\ncorresponds to a permutation matrix\nP\n, and satisfies the following relation:\n\\[{A(p,:)} = P*A\\]\nThe output parameter\nnumnz\ndescribes number of nonzero diagonal in permutated matrix\nA(p,:)\n. If\nnumnz\nis less than\nn\n, matrix\nA\nhas structural singularity.\nRemark 1: only CPU (Host) path is provided.\nRemark 2: this routine does not maximize diagonal value of permuted matrix. The user cannot expect this routine can make “LU without pivoting” stable.\nInput\nParameter\n*Host MemSpace\nDescription\nhandle\nhost\nHandle to the cuSolverSP library context.\nn\nhost\nNumber of rows and columns of matrix\nA\n.\nnnzA\nhost\nNumber of nonzeros of matrix\nA\n. It is the size of\ncsrValA\nand\ncsrColIndA\n.\ndescrA\nhost\nThe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrValA\nhost\n<type> array of\nnnzA\n\\(( =\\)\ncsrRowPtrA(m)\n\\(-\\)\ncsrRowPtrA(0)\n\\()\\)\nnonzero elements of matrix\nA\n.\ncsrRowPtrA\nhost\nInteger array of\nn+1\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndA\nhost\nInteger array of\nnnzA\ncolumn indices of the nonzero elements of matrix\nA\n.\nOutput\nParameter\n*Host MemSpace\nDescription\np\nhost\nPermutation vector of size\nn\n.\nnumnz\nhost\nNumber of nonzeros on diagonal of permuted matrix.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_ALLOC_FAILED\nThe resources could not be allocated.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nn,nnzA<=0\n), base index is not 0 or 1.\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\nCUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED\nThe matrix type is not supported.\n2.5.3.6.\ncusolverSpXcsrperm() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\ncusolverStatus_t\ncusolverSpXcsrperm_bufferSizeHost\n(\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nint\n*\ncsrRowPtrA\n,\nint\n*\ncsrColIndA\n,\nconst\nint\n*\np\n,\nconst\nint\n*\nq\n,\nsize_t\n*\nbufferSizeInBytes\n);\ncusolverStatus_t\ncusolverSpXcsrpermHost\n(\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nint\n*\ncsrRowPtrA\n,\nint\n*\ncsrColIndA\n,\nconst\nint\n*\np\n,\nconst\nint\n*\nq\n,\nint\n*\nmap\n,\nvoid\n*\npBuffer\n);\nGiven a left permutation vector\np\nwhich corresponds to permutation matrix\nP\nand a right permutation vector\nq\nwhich corresponds to permutation matrix\nQ\n, this function computes permutation of matrix\nA\nby\n\\[B = P*A*Q^T\\]\nA\nis an\n\\(m \\times n\\)\nsparse matrix that is defined in CSR storage format by the three arrays\ncsrValA\n,\ncsrRowPtrA\nand\ncsrColIndA\n.\nThe operation is in-place, i.e. the matrix\nA\nis overwritten by\nB\n.\nThe permutation vector\np\nand\nq\nare base 0.\np\nperforms row permutation while\nq\nperforms column permutation. One can also use MATLAB command\n\\(B = {A(p,q)}\\)\nto permutate matrix\nA\n.\nThis function only computes sparsity pattern of\nB\n. The user can use parameter\nmap\nto get\ncsrValB\nas well. The parameter\nmap\nis an input/output. If the user sets\nmap=0:1:(nnzA-1)\nbefore calling\ncsrperm\n,\ncsrValB=csrValA(map)\n.\nThe supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. If\nA\nis symmetric and only lower/upper part is provided, the user has to pass\n\\(A + A^{T}\\)\ninto this function.\nThis function requires a buffer size returned by\ncsrperm_bufferSize()\n. The address of\npBuffer\nmust be a multiple of 128 bytes. If it is not,\nCUSOLVER_STATUS_INVALID_VALUE\nis returned.\nFor example, if matrix\nA\nis\n\\[\\begin{split}A = \\begin{pmatrix}\n{1.0} & {2.0} & {3.0} \\\\\n{4.0} & {5.0} & {6.0} \\\\\n{7.0} & {8.0} & {9.0} \\\\\n\\end{pmatrix}\\end{split}\\]\nand left permutation vector\np=(0,2,1)\n, right permutation vector\nq=(2,1,0)\n, then\n\\(P*A*Q^{T}\\)\nis\n\\[\\begin{split}P*A*Q^{T} = \\begin{pmatrix}\n{3.0} & {2.0} & {1.0} \\\\\n{9.0} & {8.0} & {7.0} \\\\\n{6.0} & {5.0} & {4.0} \\\\\n\\end{pmatrix}\\end{split}\\]\nRemark 1: only CPU (Host) path is provided.\nRemark 2: the user can combine\ncsrsymrcm\nand\ncsrperm\nto get\n\\(P*A*P^{T}\\)\nwhich has less zero fill-in during QR factorization.\nInput\nParameter\ncusolverSp MemSpace\nDescription\nhandle\nhost\nHandle to the cuSolver library context.\nm\nhost\nNumber of rows of matrix\nA\n.\nn\nhost\nNumber of columns of matrix\nA\n.\nnnzA\nhost\nNumber of nonzeros of matrix\nA\n. It is the size of\ncsrValA\nand\ncsrColIndA\n.\ndescrA\nhost\nThe descriptor of matrix\nA\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrRowPtrA\nhost\nInteger array of\nm+1\nelements that contains the start of every row and end of last row plus one of matrix\nA\n.\ncsrColIndA\nhost\nInteger array of\nnnzA\ncolumn indices of the nonzero elements of matrix\nA\n.\np\nhost\nLeft permutation vector of size\nm\n.\nq\nhost\nRight permutation vector of size\nn\n.\nmap\nhost\nInteger array of\nnnzA\nindices. If the user wants to get relationship between\nA\nand\nB\n,\nmap\nmust be set\n0:1:(nnzA-1)\n.\npBuffer\nhost\nBuffer allocated by the user, the size is returned by\ncsrperm_bufferSize()\n.\nOutput\nParameter\nhsolver\nDescription\ncsrRowPtrA\nhost\nInteger array of\nm+1\nelements that contains the start of every row and end of last row plus one of matrix\nB\n.\ncsrColIndA\nhost\nInteger array of\nnnzA\ncolumn indices of the nonzero elements of matrix\nB\n.\nmap\nhost\nInteger array of\nnnzA\nindices that maps matrix\nA\nto matrix\nB\n.\npBufferSizeInBytes\nhost\nNumber of bytes of the buffer.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_ALLOC_FAILED\nThe resources could not be allocated.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,n,nnzA<=0\n), base index is not 0 or 1.\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\nCUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED\nThe matrix type is not supported.\n2.5.3.7.\ncusolverSpXcsrqrBatched() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nThe create and destroy methods start and end the lifetime of a csrqrInfo object.\ncusolverStatus_t\ncusolverSpCreateCsrqrInfo\n(\ncsrqrInfo_t\n*\ninfo\n);\ncusolverStatus_t\ncusolverSpDestroyCsrqrInfo\n(\ncsrqrInfo_t\ninfo\n);\nAnalysis is the same for all data types, but each data type has a unique buffer size.\ncusolverStatus_t\ncusolverSpXcsrqrAnalysisBatched\n(\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\ncsrqrInfo_t\ninfo\n);\ncusolverStatus_t\ncusolverSpScsrqrBufferInfoBatched\n(\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nint\nbatchSize\n,\ncsrqrInfo_t\ninfo\n,\nsize_t\n*\ninternalDataInBytes\n,\nsize_t\n*\nworkspaceInBytes\n);\ncusolverStatus_t\ncusolverSpDcsrqrBufferInfoBatched\n(\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nint\nbatchSize\n,\ncsrqrInfo_t\ninfo\n,\nsize_t\n*\ninternalDataInBytes\n,\nsize_t\n*\nworkspaceInBytes\n);\nCalculate buffer sizes for complex valued data types.\ncusolverStatus_t\ncusolverSpCcsrqrBufferInfoBatched\n(\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nint\nbatchSize\n,\ncsrqrInfo_t\ninfo\n,\nsize_t\n*\ninternalDataInBytes\n,\nsize_t\n*\nworkspaceInBytes\n);\ncusolverStatus_t\ncusolverSpZcsrqrBufferInfoBatched\n(\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nint\nbatchSize\n,\ncsrqrInfo_t\ninfo\n,\nsize_t\n*\ninternalDataInBytes\n,\nsize_t\n*\nworkspaceInBytes\n);\nThe S and D data types are real valued single and double precision, respectively.\ncusolverStatus_t\ncusolverSpScsrqrsvBatched\n(\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\nfloat\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\nfloat\n*\nb\n,\nfloat\n*\nx\n,\nint\nbatchSize\n,\ncsrqrInfo_t\ninfo\n,\nvoid\n*\npBuffer\n);\ncusolverStatus_t\ncusolverSpDcsrqrsvBatched\n(\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnz\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ndouble\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\ndouble\n*\nb\n,\ndouble\n*\nx\n,\nint\nbatchSize\n,\ncsrqrInfo_t\ninfo\n,\nvoid\n*\npBuffer\n);\nThe C and Z data types are complex valued single and double precision, respectively.\ncusolverStatus_t\ncusolverSpCcsrqrsvBatched\n(\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\ncuComplex\n*\nb\n,\ncuComplex\n*\nx\n,\nint\nbatchSize\n,\ncsrqrInfo_t\ninfo\n,\nvoid\n*\npBuffer\n);\ncusolverStatus_t\ncusolverSpZcsrqrsvBatched\n(\ncusolverSpHandle_t\nhandle\n,\nint\nm\n,\nint\nn\n,\nint\nnnzA\n,\nconst\ncusparseMatDescr_t\ndescrA\n,\nconst\ncuDoubleComplex\n*\ncsrValA\n,\nconst\nint\n*\ncsrRowPtrA\n,\nconst\nint\n*\ncsrColIndA\n,\nconst\ncuDoubleComplex\n*\nb\n,\ncuDoubleComplex\n*\nx\n,\nint\nbatchSize\n,\ncsrqrInfo_t\ninfo\n,\nvoid\n*\npBuffer\n);\nThe batched sparse QR factorization is used to solve either a set of least-squares problems\n\\[x_j = {argmin}{\\|}A_{j}*z - b_{j}{\\|}{,\\ j\\ =\\ 1,2,...,\\ batchSize}\\]\nor a set of linear systems\n\\[A_{j}x_{j} = b_{j}{,\\ j\\ =\\ 1,2,...,\\ batchSize}\\]\nwhere each\n\\(A_{j}\\)\nis an\n\\(m \\times n\\)\nsparse matrix that is defined in CSR storage format by the four arrays\ncsrValA\n,\ncsrRowPtrA\nand\ncsrColIndA\n.\nThe supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. If\nA\nis symmetric and only lower/upper part is provided, the user has to pass\n\\(A + A^{H}\\)\ninto this function.\nThe prerequisite to use batched sparse QR has two-folds. First all matrices\n\\(A_{j}\\)\nmust have the same sparsity pattern. Second, no column pivoting is used in least-square problem, so the solution is valid only if\n\\(A_{j}\\)\nis of full rank for all\nj\n=\n1,2,...,\nbatchSize\n. All matrices have the same sparsity pattern, so only one copy of\ncsrRowPtrA\nand\ncsrColIndA\nis used. But the array\ncsrValA\nstores coefficients of\n\\(A_{j}\\)\none after another. In other words,\ncsrValA[k*nnzA\n:\n(k+1)*nnzA]\nis the value of\n\\(A_{k}\\)\n.\nThe batched QR uses opaque data structure\ncsrqrInfo\nto keep intermediate data, for example, matrix\nQ\nand matrix\nR\nof QR factorization. The user needs to create\ncsrqrInfo\nfirst by\ncusolverSpCreateCsrqrInfo\nbefore any function in batched QR operation. The\ncsrqrInfo\nwould not release internal data until\ncusolverSpDestroyCsrqrInfo\nis called.\nThere are three routines in batched sparse QR,\ncusolverSpXcsrqrAnalysisBatched\n,\ncusolverSp[S|D|C|Z]csrqrBufferInfoBatched\nand\ncusolverSp[S|D|C|Z]csrqrsvBatched\n.\nFirst,\ncusolverSpXcsrqrAnalysisBatched\nis the analysis phase, used to analyze sparsity pattern of matrix\nQ\nand matrix\nR\nof QR factorization. Also parallelism is extracted during analysis phase. Once analysis phase is done, the size of working space to perform QR is known. However\ncusolverSpXcsrqrAnalysisBatched\nuses CPU to analyze the structure of matrix\nA\n, and this may consume a lot of memory. If host memory is not sufficient to finish the analysis,\nCUSOLVER_STATUS_ALLOC_FAILED\nis returned. The required memory for analysis is proportional to zero fill-in in QR factorization. The user may need to perform some kind of reordering to minimize zero fill-in, for example,\ncolamd\nor\nsymrcm\nin MATLAB.\ncuSolverSP\nlibrary provides\nsymrcm\n(\ncusolverSpXcsrsymrcm\n).\nSecond, the user needs to choose proper\nbatchSize\nand to prepare working space for sparse QR. There are two memory blocks used in batched sparse QR. One is internal memory block used to store matrix\nQ\nand matrix\nR\n. The other is working space used to perform numerical factorization. The size of the former is proportional to\nbatchSize\n, and the size is specified by returned parameter\ninternalDataInBytes\nof\ncusolverSp[S|D|C|Z]csrqrBufferInfoBatched\n. while the size of the latter is almost independent of\nbatchSize\n, and the size is specified by returned parameter\nworkspaceInBytes\nof\ncusolverSp[S|D|C|Z]csrqrBufferInfoBatched\n. The internal memory block is allocated implicitly during first call of\ncusolverSp[S|D|C|Z]csrqrsvBatched\n. The user only needs to allocate working space for\ncusolverSp[S|D|C|Z]csrqrsvBatched\n.\nInstead of trying all batched matrices, the user can find maximum\nbatchSize\nby querying\ncusolverSp[S|D|C|Z]csrqrBufferInfoBatched\n. For example, the user can increase\nbatchSize\ntill summation of\ninternalDataInBytes\nand\nworkspaceInBytes\nis greater than size of available device memory.\nSuppose that the user needs to perform 253 linear solvers and available device memory is 2GB. if\ncusolverSp[S|D|C|Z]csrqrsvBatched\ncan only afford\nbatchSize\n100, the user has to call\ncusolverSp[S|D|C|Z]csrqrsvBatched\nthree times to finish all. The user calls\ncusolverSp[S|D|C|Z]csrqrBufferInfoBatched\nwith\nbatchSize\n100. The opaque\ninfo\nwould remember this\nbatchSize\nand any subsequent call of\ncusolverSp[S|D|C|Z]csrqrsvBatched\ncannot exceed this value. In this example, the first two calls of\ncusolverSp[S|D|C|Z]csrqrsvBatched\nwill use\nbatchSize\n100, and last call of\ncusolverSp[S|D|C|Z]csrqrsvBatched\nwill use\nbatchSize\n53.\nExample: suppose that A0, A1, .., A9 have the same sparsity pattern, the following code solves 10 linear systems\n\\(A_{j}x_{j} = b_{j}{,\\ j\\ =\\ 0,2,...,\\ 9}\\)\nby batched sparse QR.\n// Suppose that A0, A1, .., A9 are m x m sparse matrix represented by CSR format,\n// Each matrix Aj has nonzero nnzA, and shares the same csrRowPtrA and csrColIndA.\n// csrValA is aggregation of A0, A1, ..., A9.\nint\nm\n;\n// number of rows and columns of each Aj\nint\nnnzA\n;\n// number of nonzeros of each Aj\nint\n*\ncsrRowPtrA\n;\n// each Aj has the same csrRowPtrA\nint\n*\ncsrColIndA\n;\n// each Aj has the same csrColIndA\ndouble\n*\ncsrValA\n;\n// aggregation of A0,A1,...,A9\nconst\nint\nbatchSize\n=\n10\n;\n// 10 linear systems\ncusolverSpHandle_t\nhandle\n;\n// handle to cusolver library\ncsrqrInfo_t\ninfo\n=\nNULL\n;\ncusparseMatDescr_t\ndescrA\n=\nNULL\n;\nvoid\n*\npBuffer\n=\nNULL\n;\n// working space for numerical factorization\n// step 1: create a descriptor\ncusparseCreateMatDescr\n(\n&\ndescrA\n);\ncusparseSetMatIndexBase\n(\ndescrA\n,\nCUSPARSE_INDEX_BASE_ONE\n);\n// A is base-1\ncusparseSetMatType\n(\ndescrA\n,\nCUSPARSE_MATRIX_TYPE_GENERAL\n);\n// A is a general matrix\n// step 2: create empty info structure\ncusolverSpCreateCsrqrInfo\n(\n&\ninfo\n);\n// step 3: symbolic analysis\ncusolverSpXcsrqrAnalysisBatched\n(\nhandle\n,\nm\n,\nm\n,\nnnzA\n,\ndescrA\n,\ncsrRowPtrA\n,\ncsrColIndA\n,\ninfo\n);\n// step 4: allocate working space for Aj*xj=bj\ncusolverSpDcsrqrBufferInfoBatched\n(\nhandle\n,\nm\n,\nm\n,\nnnzA\n,\ndescrA\n,\ncsrValA\n,\ncsrRowPtrA\n,\ncsrColIndA\n,\nbatchSize\n,\ninfo\n,\n&\ninternalDataInBytes\n,\n&\nworkspaceInBytes\n);\ncudaMalloc\n(\n&\npBuffer\n,\nworkspaceInBytes\n);\n// step 5: solve Aj*xj = bj\ncusolverSpDcsrqrsvBatched\n(\nhandle\n,\nm\n,\nm\n,\nnnzA\n,\ndescrA\n,\ncsrValA\n,\ncsrRowPtrA\n,\ncsrColIndA\n,\nb\n,\nx\n,\nbatchSize\n,\ninfo\n,\npBuffer\n);\n// step 7: destroy info\ncusolverSpDestroyCsrqrInfo\n(\ninfo\n);\nPlease refer to\ncuSOLVER Library Samples - csrqr\nfor a code example.\nRemark 1: only GPU (device) path is provided.\nInput\nParameter\ncusolverSp MemSpace\nDescription\nhandle\nhost\nHandle to the cuSolverSP library context.\nm\nhost\nNumber of rows of each matrix\nAj\n.\nn\nhost\nNumber of columns of each matrix\nAj\n.\nnnzA\nhost\nNumber of nonzeros of each matrix\nAj\n. It is the size\ncsrColIndA\n.\ndescrA\nhost\nThe descriptor of each matrix\nAj\n. The supported matrix type is\nCUSPARSE_MATRIX_TYPE_GENERAL\n. Also, the supported index bases are\nCUSPARSE_INDEX_BASE_ZERO\nand\nCUSPARSE_INDEX_BASE_ONE\n.\ncsrValA\ndevice\n<type> array of\nnnzA*batchSize\nnonzero elements of matrices\nA0,\nA1,\n...\n. All matrices are aggregated one after another.\ncsrRowPtrA\ndevice\nInteger array of\nm+1\nelements that contains the start of every row and the end of the last row plus one.\ncsrColIndA\ndevice\nInteger array of\nnnzA\ncolumn indices of the nonzero elements of each matrix\nAj\n.\nb\ndevice\n<type> array of\nm*batchSize\nof right-hand-side vectors\nb0,\nb1,\n...\n. All vectors are aggregated one after another.\nbatchSize\nhost\nNumber of systems to be solved.\ninfo\nhost\nOpaque structure for QR factorization.\npBuffer\ndevice\nBuffer allocated by the user, the size is returned by\ncusolverSpXcsrqrBufferInfoBatched()\n.\nOutput\nParameter\ncusolverSp MemSpace\nDescription\nx\ndevice\n<type> array of\nm*batchSize\nof solution vectors\nx0,\nx1,\n...\n. All vectors are aggregated one after another.\ninternalDataInBytes\nhost\nNumber of bytes of the internal data.\nworkspaceInBytes\nhost\nNumber of bytes of the buffer in numerical factorization.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_ALLOC_FAILED\nThe resources could not be allocated.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nm,n,nnzA<=0\n), base index is not 0 or 1.\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\nCUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED\nThe matrix type is not supported.\n2.6.\ncuSolverRF: Refactorization Reference [[DEPRECATED]]\n\n[[DEPRECATED]] cuSolverRF is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\nThis section describes API of cuSolverRF, a library for fast refactorization.\n2.6.1.\ncusolverRfAccessBundledFactorsDevice() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfAccessBundledFactorsDevice\n(\n/* Input */\ncusolverRfHandle_t\nhandle\n,\n/* Output (in the host memory)\n*/\nint\n*\nnnzM\n,\n/* Output (in the device memory) */\nint\n**\nMp\n,\nint\n**\nMi\n,\ndouble\n**\nMx\n);\nThis routine allows direct access to the lower\nL\nand upper\nU\ntriangular factors stored in the cuSolverRF library handle. The factors are compressed into a single matrix\nM=(L-I)+U\n, where the unitary diagonal of\nL\nis not stored. It is assumed that a prior call to the\ncusolverRfRefactor()\nwas done in order to generate these triangular factors.\nParameter\nMemSpace\nIn/out\nMeaning\nhandle\nhost\ninput\nThe handle to the cuSolverRF library.\nnnzM\nhost\noutput\nThe number of non-zero elements of matrix\nM\n.\nMp\ndevice\noutput\nThe array of offsets corresponding to the start of each row in the arrays\nMi\nand\nMx\n. This array has also an extra entry at the end that stores the number of non-zero elements in the matrix\nM\n. The array size is\nn+1\n.\nMi\ndevice\noutput\nThe array of column indices corresponding to the non-zero elements in the matrix\nM\n. It is assumed that this array is sorted by row and by column within each row. The array size is\nnnzM\n.\nMx\ndevice\noutput\nThe array of values corresponding to the non-zero elements in the matrix\nM\n. It is assumed that this array is sorted by row and by column within each row. The array size is\nnnzM\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_EXECUTION_FAILED\nA kernel failed to launch on the GPU.\n2.6.2.\ncusolverRfAnalyze() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfAnalyze\n(\ncusolverRfHandle_t\nhandle\n);\nThis routine performs the appropriate analysis of parallelism available in the LU re-factorization depending upon the algorithm chosen by the user.\n\\[A = L*U\\]\nIt is assumed that a prior call to the\ncusolverRfSetup[Host|Device]()\nwas done in order to create internal data structures needed for the analysis.\nThis routine needs to be called only once for a single linear system\n\\[A_{i}x_{i} = f_{i}\\]\nParameter\nMemSpace\nIn/out\nMeaning\nhandle\nhost\nin/out\nThe handle to the cuSolverRF library.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_EXECUTION_FAILED\nA kernel failed to launch on the GPU.\nCUSOLVER_STATUS_ALLOC_FAILED\nAn allocation of memory failed.\ncusolverRfSetupDevice() [[DEPRECATED]]\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfSetupDevice\n(\n/* Input (in the device memory)\n*/\nint\nn\n,\nint\nnnzA\n,\nint\n*\ncsrRowPtrA\n,\nint\n*\ncsrColIndA\n,\ndouble\n*\ncsrValA\n,\nint\nnnzL\n,\nint\n*\ncsrRowPtrL\n,\nint\n*\ncsrColIndL\n,\ndouble\n*\ncsrValL\n,\nint\nnnzU\n,\nint\n*\ncsrRowPtrU\n,\nint\n*\ncsrColIndU\n,\ndouble\n*\ncsrValU\n,\nint\n*\nP\n,\nint\n*\nQ\n,\n/* Output */\ncusolverRfHandle_t\nhandle\n);\nThis routine assembles the internal data structures of the cuSolverRF library. It is often the first routine to be called after the call to the\ncusolverRfCreate()\nroutine.\nThis routine accepts as input (on the device) the original matrix\nA\n, the lower\n(L)\nand upper\n(U)\ntriangular factors, as well as the left\n(P)\nand the right\n(Q)\npermutations resulting from the full LU factorization of the first\n(i=1)\nlinear system\n\\[A_{i}x_{i} = f_{i}\\]\nThe permutations\nP\nand\nQ\nrepresent the final composition of all the left and right reorderings applied to the original matrix\nA\n, respectively. However, these permutations are often associated with partial pivoting and reordering to minimize fill-in, respectively.\nThis routine needs to be called only once for a single linear system\n\\[A_{i}x_{i} = f_{i}\\]\nParameter\nMemSpace\nIn/out\nMeaning\nn\nhost\ninput\nThe number of rows (and columns) of matrix\nA\n.\nnnzA\nhost\ninput\nThe number of non-zero elements of matrix\nA\n.\ncsrRowPtrA\ndevice\ninput\nThe array of offsets corresponding to the start of each row in the arrays\ncsrColIndA\nand\ncsrValA\n. This array has also an extra entry at the end that stores the number of non-zero elements in the matrix. The array size is\nn+1\n.\ncsrColIndA\ndevice\ninput\nThe array of column indices corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row and by column within each row. The array size is\nnnzA\n.\ncsrValA\ndevice\ninput\nThe array of values corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row and by column within each row. The array size is\nnnzA\n.\nnnzL\nhost\ninput\nThe number of non-zero elements of matrix\nL\n.\ncsrRowPtrL\ndevice\ninput\nThe array of offsets corresponding to the start of each row in the arrays\ncsrColIndL\nand\ncsrValL\n. This array has also an extra entry at the end that stores the number of non-zero elements in the matrix\nL\n. The array size is\nn+1\n.\ncsrColIndL\ndevice\ninput\nThe array of column indices corresponding to the non-zero elements in the matrix\nL\n. It is assumed that this array is sorted by row and by column within each row. The array size is\nnnzL\n.\ncsrValL\ndevice\ninput\nThe array of values corresponding to the non-zero elements in the matrix\nL\n. It is assumed that this array is sorted by row and by column within each row. The array size is\nnnzL\n.\nnnzU\nhost\ninput\nThe number of non-zero elements of matrix\nU\n.\ncsrRowPtrU\ndevice\ninput\nThe array of offsets corresponding to the start of each row in the arrays\ncsrColIndU\nand\ncsrValU\n. This array has also an extra entry at the end that stores the number of non-zero elements in the matrix\nU\n. The array size is\nn+1\n.\ncsrColIndU\ndevice\ninput\nThe array of column indices corresponding to the non-zero elements in the matrix\nU\n. It is assumed that this array is sorted by row and by column within each row. The array size is\nnnzU\n.\ncsrValU\ndevice\ninput\nThe array of values corresponding to the non-zero elements in the matrix\nU\n. It is assumed that this array is sorted by row and by column within each row. The array size is\nnnzU\n.\nP\ndevice\ninput\nThe left permutation (often associated with pivoting). The array size in\nn\n.\nQ\ndevice\ninput\nThe right permutation (often associated with reordering). The array size in\nn\n.\nhandle\nhost\noutput\nThe handle to the cuSolverRF library.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nAn unsupported value or parameter was passed.\nCUSOLVER_STATUS_ALLOC_FAILED\nAn allocation of memory failed.\nCUSOLVER_STATUS_EXECUTION_FAILED\nA kernel failed to launch on the GPU.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.6.3.\ncusolverRfSetupHost() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfSetupHost\n(\n/* Input (in the host memory)\n*/\nint\nn\n,\nint\nnnzA\n,\nint\n*\nh_csrRowPtrA\n,\nint\n*\nh_csrColIndA\n,\ndouble\n*\nh_csrValA\n,\nint\nnnzL\n,\nint\n*\nh_csrRowPtrL\n,\nint\n*\nh_csrColIndL\n,\ndouble\n*\nh_csrValL\n,\nint\nnnzU\n,\nint\n*\nh_csrRowPtrU\n,\nint\n*\nh_csrColIndU\n,\ndouble\n*\nh_csrValU\n,\nint\n*\nh_P\n,\nint\n*\nh_Q\n,\n/* Output */\ncusolverRfHandle_t\nhandle\n);\nThis routine assembles the internal data structures of the cuSolverRF library. It is often the first routine to be called after the call to the\ncusolverRfCreate()\nroutine.\nThis routine accepts as input (on the host) the original matrix\nA\n, the lower\n(L)\nand upper\n(U)\ntriangular factors, as well as the left\n(P)\nand the right\n(Q)\npermutations resulting from the full LU factorization of the first\n(i=1)\nlinear system\n\\[A_{i}x_{i} = f_{i}\\]\nThe permutations\nP\nand\nQ\nrepresent the final composition of all the left and right reorderings applied to the original matrix\nA\n, respectively. However, these permutations are often associated with partial pivoting and reordering to minimize fill-in, respectively.\nThis routine needs to be called only once for a single linear system\n\\[A_{i}x_{i} = f_{i}\\]\nParameter\nMemSpace\nIn/out\nMeaning\nn\nhost\ninput\nThe number of rows (and columns) of matrix\nA\n.\nnnzA\nhost\ninput\nThe number of non-zero elements of matrix\nA\n.\nh_csrRowPtrA\nhost\ninput\nThe array of offsets corresponding to the start of each row in the arrays\nh_csrColIndA\nand\nh_csrValA\n. This array has also an extra entry at the end that stores the number of non-zero elements in the matrix. The array size is\nn+1\n.\nh_csrColIndA\nhost\ninput\nThe array of column indices corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row and by column within each row. The array size is\nnnzA\n.\nh_csrValA\nhost\ninput\nThe array of values corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row and by column within each row. The array size is\nnnzA\n.\nnnzL\nhost\ninput\nThe number of non-zero elements of matrix\nL\n.\nh_csrRowPtrL\nhost\ninput\nThe array of offsets corresponding to the start of each row in the arrays\nh_csrColIndL\nand\nh_csrValL\n. This array has also an extra entry at the end that stores the number of non-zero elements in the matrix\nL\n. The array size is\nn+1\n.\nh_csrColIndL\nhost\ninput\nThe array of column indices corresponding to the non-zero elements in the matrix\nL\n. It is assumed that this array is sorted by row and by column within each row. The array size is\nnnzL\n.\nh_csrValL\nhost\ninput\nThe array of values corresponding to the non-zero elements in the matrix\nL\n. It is assumed that this array is sorted by row and by column within each row. The array size is\nnnzL\n.\nnnzU\nhost\ninput\nThe number of non-zero elements of matrix\nU\n.\nh_csrRowPtrU\nhost\ninput\nThe array of offsets corresponding to the start of each row in the arrays\nh_csrColIndU\nand\nh_csrValU\n. This array has also an extra entry at the end that stores the number of non-zero elements in the matrix\nU\n. The array size is\nn+1\n.\nh_csrColIndU\nhost\ninput\nThe array of column indices corresponding to the non-zero elements in the matrix\nU\n. It is assumed that this array is sorted by row and by column within each row. The array size is\nnnzU\n.\nh_csrValU\nhost\ninput\nThe array of values corresponding to the non-zero elements in the matrix\nU\n. It is assumed that this array is sorted by row and by column within each row. The array size is\nnnzU\n.\nh_P\nhost\ninput\nThe left permutation (often associated with pivoting). The array size in\nn\n.\nh_Q\nhost\ninput\nThe right permutation (often associated with reordering). The array size in\nn\n.\nhandle\nhost\noutput\nThe handle to the cuSolverRF library.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nAn unsupported value or parameter was passed.\nCUSOLVER_STATUS_ALLOC_FAILED\nAn allocation of memory failed.\nCUSOLVER_STATUS_EXECUTION_FAILED\nA kernel failed to launch on the GPU.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.6.4.\ncusolverRfCreate() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfCreate\n(\ncusolverRfHandle_t\n*\nhandle\n);\nThis routine initializes the cuSolverRF library. It allocates required resources and must be called prior to any other cuSolverRF library routine.\nParameter\nMemSpace\nIn/out\nMeaning\nhandle\nhost\noutput\nThe pointer to the cuSolverRF library handle.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_ALLOC_FAILED\nAn allocation of memory failed.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.6.5.\ncusolverRfExtractBundledFactorsHost() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfExtractBundledFactorsHost\n(\n/* Input */\ncusolverRfHandle_t\nhandle\n,\n/* Output (in the host memory)\n*/\nint\n*\nh_nnzM\n,\nint\n**\nh_Mp\n,\nint\n**\nh_Mi\n,\ndouble\n**\nh_Mx\n);\nThis routine extracts lower\n(L)\nand upper\n(U)\ntriangular factors from the cuSolverRF library handle into the host memory. The factors are compressed into a single matrix\nM=(L-I)+U\n, where the unitary diagonal of\n(L)\nis not stored. It is assumed that a prior call to the\ncusolverRfRefactor()\nwas done in order to generate these triangular factors.\nParameter\nMemSpace\nIn/out\nMeaning\nhandle\nhost\ninput\nThe handle to the cuSolverRF library.\nh_nnzM\nhost\noutput\nThe number of non-zero elements of matrix\nM\n.\nh_Mp\nhost\noutput\nThe array of offsets corresponding to the start of each row in the arrays\nh_Mi\nand\nh_Mx\n. This array has also an extra entry at the end that stores the number of non-zero elements in the matrix\nM\n. The array size is\nn+1\n.\nh_Mi\nhost\noutput\nThe array of column indices corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row and by column within each row. The array size is\nh_nnzM\n.\nh_Mx\nhost\noutput\nThe array of values corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row and by column within each row. The array size is\nh_nnzM\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_ALLOC_FAILED\nAn allocation of memory failed.\nCUSOLVER_STATUS_EXECUTION_FAILED\nA kernel failed to launch on the GPU.\n2.6.6.\ncusolverRfExtractSplitFactorsHost() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfExtractSplitFactorsHost\n(\n/* Input */\ncusolverRfHandle_t\nhandle\n,\n/* Output (in the host memory)\n*/\nint\n*\nh_nnzL\n,\nint\n**\nh_Lp\n,\nint\n**\nh_Li\n,\ndouble\n**\nh_Lx\n,\nint\n*\nh_nnzU\n,\nint\n**\nh_Up\n,\nint\n**\nh_Ui\n,\ndouble\n**\nh_Ux\n);\nThis routine extracts lower\n(L)\nand upper\n(U)\ntriangular factors from the cuSolverRF library handle into the host memory. It is assumed that a prior call to the\ncusolverRfRefactor()\nwas done in order to generate these triangular factors.\nParameter\nMemSpace\nIn/out\nMeaning\nhandle\nhost\ninput\nThe handle to the cuSolverRF library.\nh_nnzL\nhost\noutput\nThe number of non-zero elements of matrix\nL\n.\nh_Lp\nhost\noutput\nThe array of offsets corresponding to the start of each row in the arrays\nh_Li\nand\nh_Lx\n. This array has also an extra entry at the end that stores the number of non-zero elements in the matrix\nL\n. The array size is\nn+1\n.\nh_Li\nhost\noutput\nThe array of column indices corresponding to the non-zero elements in the matrix\nL\n. It is assumed that this array is sorted by row and by column within each row. The array size is\nh_nnzL\n.\nh_Lx\nhost\noutput\nThe array of values corresponding to the non-zero elements in the matrix\nL\n. It is assumed that this array is sorted by row and by column within each row. The array size is\nh_nnzL\n.\nh_nnzU\nhost\noutput\nThe number of non-zero elements of matrix\nU\n.\nh_Up\nhost\noutput\nThe array of offsets corresponding to the start of each row in the arrays\nh_Ui\nand\nh_Ux\n. This array has also an extra entry at the end that stores the number of non-zero elements in the matrix\nU\n. The array size is\nn+1\n.\nh_Ui\nhost\noutput\nThe array of column indices corresponding to the non-zero elements in the matrix\nU\n. It is assumed that this array is sorted by row and by column within each row. The array size is\nh_nnzU\n.\nh_Ux\nhost\noutput\nThe array of values corresponding to the non-zero elements in the matrix\nU\n. It is assumed that this array is sorted by row and by column within each row. The array size is\nh_nnzU\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_ALLOC_FAILED\nAn allocation of memory failed.\nCUSOLVER_STATUS_EXECUTION_FAILED\nA kernel failed to launch on the GPU.\n2.6.7.\ncusolverRfDestroy() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfDestroy\n(\ncusolverRfHandle_t\nhandle\n);\nThis routine shuts down the cuSolverRF library. It releases acquired resources and must be called after all the cuSolverRF library routines.\nParameter\nMemSpace\nIn/out\nMeaning\nhandle\nhost\ninput\nThe cuSolverRF library handle.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\n2.6.8.\ncusolverRfGetMatrixFormat() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfGetMatrixFormat\n(\ncusolverRfHandle_t\nhandle\n,\ncusolverRfMatrixFormat_t\n*\nformat\n,\ncusolverRfUnitDiagonal_t\n*\ndiag\n);\nThis routine gets the matrix format used in the\ncusolverRfSetupDevice()\n,\ncusolverRfSetupHost()\n,\ncusolverRfResetValues()\n,\ncusolverRfExtractBundledFactorsHost()\nand\ncusolverRfExtractSplitFactorsHost()\nroutines.\nParameter\nMemSpace\nIn/out\nMeaning\nhandle\nhost\ninput\nThe handle to the cuSolverRF library.\nformat\nhost\noutput\nThe enumerated matrix format type.\ndiag\nhost\noutput\nThe enumerated unit diagonal type.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\n2.6.9.\ncusolverRfGetNumericProperties() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfGetNumericProperties\n(\ncusolverRfHandle_t\nhandle\n,\ndouble\n*\nzero\n,\ndouble\n*\nboost\n);\nThis routine gets the numeric values used for checking for ‘’zero’’ pivot and for boosting it in the\ncusolverRfRefactor()\nand\ncusolverRfSolve()\nroutines. The numeric boosting will be used only if\nboost\n>\n0.0\n.\nParameter\nMemSpace\nIn/out\nMeaning\nhandle\nhost\ninput\nThe handle to the cuSolverRF library.\nzero\nhost\noutput\nThe value below which zero pivot is flagged.\nboost\nhost\noutput\nThe value which is substituted for zero pivot (if the later is flagged).\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\n2.6.10.\ncusolverRfGetNumericBoostReport() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfGetNumericBoostReport\n(\ncusolverRfHandle_t\nhandle\n,\ncusolverRfNumericBoostReport_t\n*\nreport\n);\nThis routine gets the report whether numeric boosting was used in the\ncusolverRfRefactor()\nand\ncusolverRfSolve()\nroutines.\nParameter\nMemSpace\nIn/out\nMeaning\nhandle\nhost\ninput\nThe handle to the cuSolverRF library.\nreport\nhost\noutput\nThe enumerated boosting report type.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\n2.6.11.\ncusolverRfGetResetValuesFastMode() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfGetResetValuesFastMode\n(\ncusolverRfHandle_t\nhandle\n,\ncusolverRfResetValuesFastMode_t\n*\nfastMode\n);\nThis routine gets the mode used in the\ncusolverRfResetValues\nroutine.\nParameter\nMemSpace\nIn/out\nMeaning\nhandle\nhost\ninput\nThe handle to the cuSolverRF library.\nfastMode\nhost\noutput\nThe enumerated mode type.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\n2.6.12.\ncusolverRfGetAlgs()\n\ncusolverStatus_t\ncusolverRfGetAlgs\n(\ncusolverRfHandle_t\nhandle\n,\ncusolverRfFactorization_t\n*\nfact_alg\n,\ncusolverRfTriangularSolve_t\n*\nsolve_alg\n);\nThis routine gets the algorithm used for the refactorization in\ncusolverRfRefactor()\nand the triangular solve in\ncusolverRfSolve()\n.\nParameter\nMemSpace\nIn/out\nMeaning\nhandle\nhost\ninput\nThe handle to the cuSolverRF library.\nalg\nhost\noutput\nThe enumerated algorithm type.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\n2.6.13.\ncusolverRfRefactor() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfRefactor\n(\ncusolverRfHandle_t\nhandle\n);\nThis routine performs the LU re-factorization:\n\\[A = L*U\\]\nexploring the available parallelism on the GPU. It is assumed that a prior call to the\ncusolverRfAnalyze()\nwas done in order to find the available parallelism.\nThis routine may be called multiple times, once for each of the linear systems:\n\\[A_{i}x_{i} = f_{i}\\]\nThere are some constraints to the combination of algorithms used for refactorization and solving routines,\ncusolverRfRefactor()\nand\ncusolverRfSolve()\n. The wrong combination generates the error code\nCUSOLVER_STATUS_INVALID_VALUE\n. The table below summarizes the supported combinations of algorithms:\nCompatible algorithms for solving and refactorization routines.\nFactorization\nSolving\nCUSOLVERRF_FACTORIZATION_ALG0\nTRIANGULAR_SOLVE_ALG1\nCUSOLVERRF_FACTORIZATION_ALG1\nTRIANGULAR_SOLVE_ALG2,\nTRIANGULAR_SOLVE_ALG3\nCUSOLVERRF_FACTORIZATION_ALG2\nTRIANGULAR_SOLVE_ALG2,\nTRIANGULAR_SOLVE_ALG3\nParameter\nMemSpace\nIn/out\nMeaning\nhandle\nhost\nin/out\nThe handle to the cuSolverRF library.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_EXECUTION_FAILED\nA kernel failed to launch on the GPU.\nCUSOLVER_STATUS_ZERO_PIVOT\nA zero pivot was encountered during the computation.\n2.6.14.\ncusolverRfResetValues() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfResetValues\n(\n/* Input (in the device memory)\n*/\nint\nn\n,\nint\nnnzA\n,\nint\n*\ncsrRowPtrA\n,\nint\n*\ncsrColIndA\n,\ndouble\n*\ncsrValA\n,\nint\n*\nP\n,\nint\n*\nQ\n,\n/* Output */\ncusolverRfHandle_t\nhandle\n);\nThis routine updates internal data structures with the values of the new coefficient matrix. It is assumed that the arrays\ncsrRowPtrA\n,\ncsrColIndA\n,\nP\nand\nQ\nhave not changed since the last call to the\ncusolverRfSetup[Host|Device]\nroutine. This assumption reflects the fact that the sparsity pattern of coefficient matrices as well as reordering to minimize fill-in and pivoting remain the same in the set of linear systems:\n\\[A_{i}x_{i} = f_{i}\\]\nThis routine may be called multiple times, once for each of the linear systems:\n\\[A_{i}x_{i} = f_{i}\\]\nParameter\nMemSpace\nIn/out\nMeaning\nn\nhost\ninput\nThe number of rows (and columns) of matrix\nA\n.\nnnzA\nhost\ninput\nThe number of non-zero elements of matrix\nA\n.\ncsrRowPtrA\ndevice\ninput\nThe array of offsets corresponding to the start of each row in the arrays\ncsrColIndA\nand\ncsrValA\n. This array has also an extra entry at the end that stores the number of non-zero elements in the matrix. The array size is\nn+1\n.\ncsrColIndA\ndevice\ninput\nThe array of column indices corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row and by column within each row. The array size is\nnnzA\n.\ncsrValA\ndevice\ninput\nThe array of values corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row and by column within each row. The array size is\nnnzA\n.\nP\ndevice\ninput\nThe left permutation (often associated with pivoting). The array size in\nn\n.\nQ\ndevice\ninput\nThe right permutation (often associated with reordering). The array size in\nn\n.\nhandle\nhost\noutput\nThe handle to the cuSolverRF library.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nAn unsupported value or parameter was passed.\nCUSOLVER_STATUS_EXECUTION_FAILED\nA kernel failed to launch on the GPU.\n2.6.15.\ncusolverRfSetMatrixFormat() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfSetMatrixFormat\n(\ncusolverRfHandle_t\nhandle\n,\ncusolverRfMatrixFormat_t\nformat\n,\ncusolverRfUnitDiagonal_t\ndiag\n);\nThis routine sets the matrix format used in the\ncusolverRfSetupDevice()\n,\ncusolverRfSetupHost()\n,\ncusolverRfResetValues()\n,\ncusolverRfExtractBundledFactorsHost()\nand\ncusolverRfExtractSplitFactorsHost()\nroutines. It may be called once prior to\ncusolverRfSetupDevice()\nand\ncusolverRfSetupHost()\nroutines.\nParameter\nMemSpace\nIn/out\nMeaning\nhandle\nhost\ninput\nThe handle to the cuSolverRF library.\nformat\nhost\ninput\nThe enumerated matrix format type.\ndiag\nhost\ninput\nThe enumerated unit diagonal type.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nAn enumerated mode parameter is wrong.\n2.6.16.\ncusolverRfSetNumericProperties() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfSetNumericProperties\n(\ncusolverRfHandle_t\nhandle\n,\ndouble\nzero\n,\ndouble\nboost\n);\nThis routine sets the numeric values used for checking for ‘’zero’’ pivot and for boosting it in the\ncusolverRfRefactor()\nand\ncusolverRfSolve()\nroutines. It may be called multiple times prior to\ncusolverRfRefactor()\nand\ncusolverRfSolve()\nroutines. The numeric boosting will be used only if\nboost\n>\n0.0\n.\nParameter\nMemSpace\nIn/out\nMeaning\nhandle\nhost\ninput\nThe handle to the cuSolverRF library.\nzero\nhost\ninput\nThe value below which zero pivot is flagged.\nboost\nhost\ninput\nThe value which is substituted for zero pivot (if the later is flagged).\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\n2.6.17.\ncusolverRfSetResetValuesFastMode() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfSetResetValuesFastMode\n(\ncusolverRfHandle_t\nhandle\n,\ncusolverRfResetValuesFastMode_t\nfastMode\n);\nThis routine sets the mode used in the\ncusolverRfResetValues\nroutine. The fast mode requires extra memory and is recommended only if very fast calls to\ncusolverRfResetValues()\nare needed. It may be called once prior to\ncusolverRfAnalyze()\nroutine.\nParameter\nMemSpace\nIn/out\nMeaning\nhandle\nhost\ninput\nThe handle to the cuSolverRF library.\nfastMode\nhost\ninput\nThe enumerated mode type.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nAn enumerated mode parameter is wrong.\n2.6.18.\ncusolverRfSetAlgs() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfSetAlgs\n(\ncusolverRfHandle_t\nhandle\n,\ncusolverRfFactorization_t\nfact_alg\n,\ncusolverRfTriangularSolve_t\nalg\n);\nThis routine sets the algorithm used for the refactorization in\ncusolverRfRefactor()\nand the triangular solve in\ncusolverRfSolve()\n. It may be called once prior to\ncusolverRfAnalyze()\nroutine.\nParameter\nMemSpace\nIn/out\nMeaning\nhandle\nhost\ninput\nThe handle to the cuSolverRF library.\nalg\nhost\ninput\nThe enumerated algorithm type.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\n2.6.19.\ncusolverRfSolve() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfSolve\n(\n/* Input (in the device memory)\n*/\ncusolverRfHandle_t\nhandle\n,\nint\n*\nP\n,\nint\n*\nQ\n,\nint\nnrhs\n,\ndouble\n*\nTemp\n,\nint\nldt\n,\n/* Input/Output (in the device memory) */\ndouble\n*\nXF\n,\n/* Input */\nint\nldxf\n);\nThis routine performs the forward and backward solve with the lower\n\\(L\\in R^{nxn}\\)\nand upper\n\\(U\\in R^{nxn}\\)\ntriangular factors resulting from the LU re-factorization:\n\\[A = L*U\\]\nwhich is assumed to have been computed by a prior call to the\ncusolverRfRefactor()\nroutine.\nThe routine can solve linear systems with multiple right-hand-sides (RHS):\n\\[AX = {(LU)}X = L{(UX)} = LY = F~{where}~UX = Y\\]\neven though currently only a single RHS is supported.\nThis routine may be called multiple times, once for each of the linear systems:\n\\[A_{i}x_{i} = f_{i}\\]\nParameter\nMemSpace\nIn/out\nMeaning\nhandle\nhost\noutput\nThe handle to the cuSolverRF library.\nP\ndevice\ninput\nThe left permutation (often associated with pivoting). The array size in\nn\n.\nQ\ndevice\ninput\nThe right permutation (often associated with reordering). The array size in\nn\n.\nnrhs\nhost\ninput\nThe number right-hand-sides to be solved.\nTemp\ndevice\ninput\nThe dense matrix that contains temporary workspace (of size\nldt*nrhs\n).\nldt\nhost\ninput\nThe leading dimension of dense matrix Temp (\nldt\n>=\nn\n).\nXF\ndevice\nin/out\nThe dense matrix that contains the right-hand-sides\nF\nand solutions\nX\n(of size\nldxf*nrhs\n).\nldxf\nhost\ninput\nThe leading dimension of dense matrix\nXF\n(\nldxf\n>=\nn\n).\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nAn unsupported value or parameter was passed.\nCUSOLVER_STATUS_EXECUTION_FAILED\nA kernel failed to launch on the GPU.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.6.20.\ncusolverRfBatchSetupHost() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfBatchSetupHost\n(\n/* Input (in the host memory)\n*/\nint\nbatchSize\n,\nint\nn\n,\nint\nnnzA\n,\nint\n*\nh_csrRowPtrA\n,\nint\n*\nh_csrColIndA\n,\ndouble\n*\nh_csrValA_array\n[],\nint\nnnzL\n,\nint\n*\nh_csrRowPtrL\n,\nint\n*\nh_csrColIndL\n,\ndouble\n*\nh_csrValL\n,\nint\nnnzU\n,\nint\n*\nh_csrRowPtrU\n,\nint\n*\nh_csrColIndU\n,\ndouble\n*\nh_csrValU\n,\nint\n*\nh_P\n,\nint\n*\nh_Q\n,\n/* Output */\ncusolverRfHandle_t\nhandle\n);\nThis routine assembles the internal data structures of the cuSolverRF library for batched operation. It is called after the call to the\ncusolverRfCreate()\nroutine, and before any other batched routines.\nThe batched operation assumes that the user has the following linear systems:\n\\[A_{j}x_{j} = b_{j}{, j = 1,2,..., batchSize}\\]\nwhere each matrix in the set:\n\\(\\{ A_{j}\\}\\)\nhas the same sparsity pattern, and quite similar such that factorization can be done by the same permutation\nP\nand\nQ\n. In other words,\n\\(A_{j}{,\\ j>1}\\)\nis a small perturbation of\n\\(A_{1}\\)\n.\nThis routine accepts as input (on the host) the original matrix\nA\n(sparsity pattern and batched values), the lower\n(L)\nand upper\n(U)\ntriangular factors, as well as the left\n(P)\nand the right\n(Q)\npermutations resulting from the full LU factorization of the first\n(i=1)\nlinear system:\n\\[A_{i}x_{i} = f_{i}\\]\nThe permutations\nP\nand\nQ\nrepresent the final composition of all the left and right reorderings applied to the original matrix\nA\n, respectively. However, these permutations are often associated with partial pivoting and reordering to minimize fill-in, respectively.\nRemark 1: the matrices\nA\n,\nL\nand\nU\nmust be CSR format and base-0.\nRemark 2: to get best performance,\nbatchSize\nshould be multiple of 32 and greater or equal to 32. The algorithm is memory-bound, once bandwidth limit is reached, there is no room to improve performance by large\nbatchSize\n. In practice,\nbatchSize\nof 32 - 128 is often enough to obtain good performance, but in some cases larger\nbatchSize\nmight be beneficial.\nThe following routine needs to be called only once for a single linear system:\n\\[A_{i}x_{i} = f_{i}\\]\nParameter\nMemSpace\nIn/out\nMeaning\nbatchSize\nhost\ninput\nThe number of matrices in the batched mode.\nn\nhost\ninput\nThe number of rows (and columns) of matrix\nA\n.\nnnzA\nhost\ninput\nThe number of non-zero elements of matrix\nA\n.\nh_csrRowPtrA\nhost\ninput\nThe array of offsets corresponding to the start of each row in the arrays\nh_csrColIndA\nand\nh_csrValA\n. This array has also an extra entry at the end that stores the number of non-zero elements in the matrix. The array size is\nn+1\n.\nh_csrColIndA\nhost\ninput\nThe array of column indices corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row and by column within each row. The array size is\nnnzA\n.\nh_csrValA_array\nhost\ninput\nArray of pointers of size\nbatchSize\n, each pointer points to the array of values corresponding to the non-zero elements in the matrix.\nnnzL\nhost\ninput\nThe number of non-zero elements of matrix\nL\n.\nh_csrRowPtrL\nhost\ninput\nThe array of offsets corresponding to the start of each row in the arrays\nh_csrColIndL\nand\nh_csrValL\n. This array has also an extra entry at the end that stores the number of non-zero elements in the matrix\nL\n. The array size is\nn+1\n.\nh_csrColIndL\nhost\ninput\nThe array of column indices corresponding to the non-zero elements in the matrix\nL\n. It is assumed that this array is sorted by row and by column within each row. The array size is\nnnzL\n.\nh_csrValL\nhost\ninput\nThe array of values corresponding to the non-zero elements in the matrix\nL\n. It is assumed that this array is sorted by row and by column within each row. The array size is\nnnzL\n.\nnnzU\nhost\ninput\nThe number of non-zero elements of matrix\nU\n.\nh_csrRowPtrU\nhost\ninput\nThe array of offsets corresponding to the start of each row in the arrays\nh_csrColIndU\nand\nh_csrValU\n. This array has also an extra entry at the end that stores the number of non-zero elements in the matrix\nU\n. The array size is\nn+1\n.\nh_csrColIndU\nhost\ninput\nThe array of column indices corresponding to the non-zero elements in the matrix\nU\n. It is assumed that this array is sorted by row and by column within each row. The array size is\nnnzU\n.\nh_csrValU\nhost\ninput\nThe array of values corresponding to the non-zero elements in the matrix\nU\n. It is assumed that this array is sorted by row and by column within each row. The array size is\nnnzU\n.\nh_P\nhost\ninput\nThe left permutation (often associated with pivoting). The array size in\nn\n.\nh_Q\nhost\ninput\nThe right permutation (often associated with reordering). The array size in\nn\n.\nhandle\nhost\noutput\nThe handle to the cuSolverRF library.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nAn unsupported value or parameter was passed.\nCUSOLVER_STATUS_ALLOC_FAILED\nAn allocation of memory failed.\nCUSOLVER_STATUS_EXECUTION_FAILED\nA kernel failed to launch on the GPU.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.6.21.\ncusolverRfBatchAnalyze() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfBatchAnalyze\n(\ncusolverRfHandle_t\nhandle\n);\nThis routine performs the appropriate analysis of parallelism available in the batched LU re-factorization.\nIt is assumed that a prior call to the\ncusolverRfBatchSetup[Host]()\nwas done in order to create internal data structures needed for the analysis.\nThe following routine needs to be called only once for a single linear system:\n\\[A_{j}x_{j} = b_{j}{, j = 1,2,..., batchSize}\\]\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\nin/out\nThe handle to the cuSolverRF library.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_EXECUTION_FAILED\nA kernel failed to launch on the GPU.\nCUSOLVER_STATUS_ALLOC_FAILED\nAn allocation of memory failed.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.6.22.\ncusolverRfBatchResetValues() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfBatchResetValues\n(\n/* Input (in the device memory)\n*/\nint\nbatchSize\n,\nint\nn\n,\nint\nnnzA\n,\nint\n*\ncsrRowPtrA\n,\nint\n*\ncsrColIndA\n,\ndouble\n*\ncsrValA_array\n[],\nint\n*\nP\n,\nint\n*\nQ\n,\n/* Output */\ncusolverRfHandle_t\nhandle\n);\nThis routine updates internal data structures with the values of the new coefficient matrix. It is assumed that the arrays\ncsrRowPtrA\n,\ncsrColIndA\n,\nP\nand\nQ\nhave not changed since the last call to the\ncusolverRfbatch_setup_host\nroutine.\nThis assumption reflects the fact that the sparsity pattern of coefficient matrices as well as reordering to minimize fill-in and pivoting remain the same in the set of linear systems:\n\\[A_{j}x_{j} = b_{j}{, j\\ = 1,2,..., batchSize}\\]\nThe input parameter\ncsrValA_array\nis an array of pointers on device memory.\ncsrValA_array(j)\npoints to matrix:\n\\(A_{j}\\)\nwhich is also on device memory.\nParameter\nMemSpace\nIn/out\nMeaning\nbatchSize\nhost\ninput\nThe number of matrices in batched mode.\nn\nhost\ninput\nThe number of rows (and columns) of matrix\nA\n.\nnnzA\nhost\ninput\nThe number of non-zero elements of matrix\nA\n.\ncsrRowPtrA\ndevice\ninput\nThe array of offsets corresponding to the start of each row in the arrays\ncsrColIndA\nand\ncsrValA\n. This array has also an extra entry at the end that stores the number of non-zero elements in the matrix. The array size is\nn+1\n.\ncsrColIndA\ndevice\ninput\nThe array of column indices corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row and by column within each row. The array size is\nnnzA\n.\ncsrValA_array\ndevice\ninput\nArray of pointers of size\nbatchSize\n, each pointer points to the array of values corresponding to the non-zero elements in the matrix.\nP\ndevice\ninput\nThe left permutation (often associated with pivoting). The array size in\nn\n.\nQ\ndevice\ninput\nThe right permutation (often associated with reordering). The array size in\nn\n.\nhandle\nhost\noutput\nThe handle to the cuSolverRF library.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nAn unsupported value or parameter was passed.\nCUSOLVER_STATUS_EXECUTION_FAILED\nA kernel failed to launch on the GPU.\n2.6.23.\ncusolverRfBatchRefactor() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfBatchRefactor\n(\ncusolverRfHandle_t\nhandle\n);\nThis routine performs the LU re-factorization:\n\\[M_{j} = P*A_{j}*Q^{T} = L_{j}*U_{j}\\]\nexploring the available parallelism on the GPU. It is assumed that a prior call to the\ncusolverRfBatchAnalyze()\nwas done in order to find the available parallelism.\nRemark:\ncusolverRfBatchRefactor()\nwould not report any failure of LU refactorization. The user has to call\ncusolverRfBatchZeroPivot()\nto know which matrix failed the LU refactorization.\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\nin/out\nThe handle to the cuSolverRF library.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_EXECUTION_FAILED\nA kernel failed to launch on the GPU.\n2.6.24.\ncusolverRfBatchSolve() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfBatchSolve\n(\n/* Input (in the device memory)\n*/\ncusolverRfHandle_t\nhandle\n,\nint\n*\nP\n,\nint\n*\nQ\n,\nint\nnrhs\n,\ndouble\n*\nTemp\n,\nint\nldt\n,\n/* Input/Output (in the device memory) */\ndouble\n*\nXF_array\n[],\n/* Input */\nint\nldxf\n);\nTo solve\n\\(A_{j}*x_{j} = b_{j}\\)\n, first we reform the equation by\n\\(M_{j}*Q*x_{j} = P*b_{j}\\)\nwhere\n\\(M_{j} = P*A_{j}*Q^{T}\\)\n. Then do refactorization\n\\(M_{j} = L_{j}*U_{j}\\)\nby\ncusolverRfBatch_Refactor()\n. Further\ncusolverRfBatch_Solve()\ntakes over the remaining steps, including:\n\\(z_{j} = P*b_{j}\\)\n\\(M_{j}*y_{j} = z_{j}\\)\n\\(x_{j} = Q^{T}*y_{j}\\)\nThe input parameter\nXF_array\nis an array of pointers on device memory.\nXF_array(j)\npoints to matrix\n\\(x_{j}\\)\nwhich is also on device memory.\nRemark 1: only a single rhs is supported.\nRemark 2: no singularity is reported during backward solve. If some matrix\n\\(A_{j}\\)\nfailed the refactorization and\n\\(U_{j}\\)\nhas some zero diagonal, backward solve would compute NAN. The user has to call\ncusolverRfBatch_Zero_Pivot\nto check if refactorization is successful or not.\nParameter\nMemSpace\nIn/out\nMeaning\nhandle\nhost\noutput\nThe handle to the cuSolverRF library.\nP\ndevice\ninput\nThe left permutation (often associated with pivoting). The array size in\nn\n.\nQ\ndevice\ninput\nThe right permutation (often associated with reordering). The array size in\nn\n.\nnrhs\nhost\ninput\nThe number right-hand-sides to be solved.\nTemp\ndevice\ninput\nThe dense matrix that contains temporary workspace (of size\nldt*nrhs\n).\nldt\nhost\ninput\nThe leading dimension of dense matrix Temp (\nldt\n>=\nn\n).\nXF_array\ndevice\nin/out\nArray of pointers of size\nbatchSize\n, each pointer points to the dense matrix that contains the right-hand-sides\nF\nand solutions\nX\n(of size\nldxf*nrhs\n).\nldxf\nhost\ninput\nThe leading dimension of dense matrix\nXF\n(\nldxf\n>=\nn\n).\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nAn unsupported value or parameter was passed.\nCUSOLVER_STATUS_EXECUTION_FAILED\nA kernel failed to launch on the GPU.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n2.6.25.\ncusolverRfBatchZeroPivot() [[DEPRECATED]]\n\n[[DEPRECATED]] This function is deprecated and will be removed in a future major version.\nPlease use the\ncuDSS\nlibrary instead for better performance and support.\nFor the transition, please visit\ncuDSS Library Samples\nfor a code example.\ncusolverStatus_t\ncusolverRfBatchZeroPivot\n(\n/* Input */\ncusolverRfHandle_t\nhandle\n/* Output (in the host memory)\n*/\nint\n*\nposition\n);\nAlthough\n\\(A_{j}\\)\nis close to each other, it does not mean\n\\(M_{j} = P*A_{j}*Q^{T} = L_{j}*U_{j}\\)\nexists for every j. The user can query which matrix failed LU refactorization by checking corresponding value in\nposition\narray. The input parameter\nposition\nis an integer array of size\nbatchSize\n.\nThe\nj-th\ncomponent denotes the refactorization result of matrix\n\\(A_{j}\\)\n. If\nposition(j)\nis -1, the LU refactorization of matrix\n\\(A_{j}\\)\nis successful. If\nposition(j)\nis\nk\n>=\n0\n, matrix\n\\(A_{j}\\)\nis not LU factorizable and its matrix\n\\(U_{j}{(j,j)}\\)\nis zero.\nThe return value of\ncusolverRfBatch_Zero_Pivot\nis\nCUSOLVER_STATUS_ZERO_PIVOT\nif there exists one\n\\(A_{j}\\)\nwhich failed LU refactorization. The user can redo LU factorization to get new permutation\nP\nand\nQ\nif error code\nCUSOLVER_STATUS_ZERO_PIVOT\nis returned.\nParameter\nMemSpace\nIn/out\nMeaning\nhandle\nhost\ninput\nThe handle to the cuSolverRF library.\nposition\nhost\noutput\nInteger array of size\nbatchSize\n. The value of\nposition(j)\nreports singularity of matrix\nAj\n, -1 if no structural/numerical zero,\nk\n>=\n0\nif\nAj(k,k)\nis either structural zero or numerical zero.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_ZERO_PIVOT\nA zero pivot was encountered during the computation.\n3.\nUsing the CUSOLVERMG API\n\nNote\ncuSolverMG is deprecated. Users are encouraged to use\ncuSOLVERMp\nfor multi-GPU functionality, both single- and multi-node.\n3.1.\nGeneral Description\n\nThis section describes how to use the cuSolverMG library API. It is not a reference for the cuSolverMG API data types and functions; that is provided in subsequent chapters.\n3.1.1.\nThread Safety\n\nThe library is thread-safe only if there is one cuSolverMG context per thread.\n3.1.2.\nDeterminism\n\nCurrently all cuSolverMG API routines from a given toolkit version generate the same bit-wise results when the following conditions are respected:\nall GPUs participating to the computation have the same compute-capabilities and the same number of SMs.\nthe tiles size is kept the same between run.\nnumber of logical GPUs is kept the same. The order of GPUs are not important because all have the same compute-capabilities.\n3.1.3.\nTile Strategy\n\nThe tiling strategy of cuSolverMG is compatible with ScaLAPACK. The current release only supports 1-D column block cyclic, column-major PACKED format.\nFigure 1.a shows a partition of the matrix A of dimension\nM_A\nby\nN_A\n. Each column tile has\nT_A\ncolumns. There are seven columns of tiles, labeled as 0,1,2,3,4,5,6, distributed into three GPUs in a\ncyclic\nway, i.e. each GPU takes one column tile in turn. For example, GPU 0 has column tile 0, 3, 6 (yellow tiles) and GPU 1 takes column tiles next to GPU 0 (blue tiles). Not all GPUs have the same number of tiles; in this example, GPU 0 has three tiles, others have only two tiles.\nFigure 1.b shows two possible formats to store those column tiles locally in each GPU. Left side is called PACKED format and right side is UNPACKED format. PACKED format aggregates three column tiles in a contiguous memory block while UNPACKED format distributes these three column tiles into different memory blocks. The only difference between them is that PACKED format can have a big GEMM call instead of three GEMM calls in UNPACKED format. So theoretically speaking, PACKED format can deliver better performance than UNPACKED format.\ncuSolverMG\nonly supports PACKED format in the API. In order to achieve maximal performance, the user just needs to choose the proper tile size\nT_A\nto partition the matrix, not too small, for example 256 or above is enough.\nThere is another parameter, called\nLLD_A\n, to control the leading dimension of the local matrix in each GPU.\nLLD_A\nmust be greater or equal to\nM_A\n. The purpose of\nLLD_A\nis for better performance of GEMM. For small problems, GEMM is faster if\nLLD_A\nis power of 2. However for big problems,\nLLD_A\ndoes not show significant improvement.\ncuSolverMG\nonly supports\nLLD_A=M_A\n.\nExample of\ncuSolverMG\ntiling for 3 GPUs\n\nThe processing grid in\ncuSolverMG\nis a list of GPU IDs, similar to the process ID in\nScaLAPACK\n.\ncuSolverMG\nonly supports 1D column block cyclic, so only 1D grid is supported as well. Suppose\ndeviceId\nis a list of GPU IDs, both\ndeviceId=1,1,1\nand\ndeviceId=2,1,0\nare valid. The former describes three logical devices that are selected to run\ncuSolverMG\nroutines, and all have the same physical ID, 0. The latter still uses three logical devices, but each has a different physical ID. The current design only accepts 32 logical devices, that is, the length of\ndeviceId\nis less or equal to 32. Figure 1 uses\ndeviceId=0,1,2\n.\nIn practice, the matrix A is distributed into GPUs listed in\ndeviceId\n. If the user chooses\ndeviceId=1,1,1\n, all columns tile are located in GPU 1, this will limit the size of the problem because of memory capacity of one GPU. Besides, multiGPU routine adds extra overhead on data communication through the off-chip bus, which has a big performance impact if NVLINK is not supported or used. It would be faster to run on a single GPU instead of running multiGPU version with devices of the same GPU ID.\n3.1.4.\nGlobal Matrix Versus Local Matrix\n\nOperating a submatrix of the matrix A is simple in dense linear algebra, just shift the pointer to the starting point of the submatrix relative to A. For example,\ngesvd(10,10,\nA)\nis SVD of\nA(0:9,0:9)\n.\ngesvd(10,10,\nA\n+\n5\n+\n2*lda\n)\nis SVD of 10-by-10 submatrix starting at\nA(5,2)\n.\nHowever it is not simple to operate on a submatrix of a distributed matrix because different starting point of the submatrix changes the distribution of the layout of that submatrix.\nScaLAPACK\nintroduces two parameters,\nIA\nand\nJA\n, to locate the submatrix. Figure 2 shows (global) matrix A of dimension\nM_A\nby\nN_A\n. The\nsub(A)\nis a\nM\nby\nN\nsubmatrix of A, starting at\nIA\nand\nJA\n. Please be aware that\nIA\nand\nJA\nare base-1.\nGiven a distributed matrix\nA\n, the user can compute eigenvalues of the submatrix\nsub(A)\nby either calling\nsyevd(A,\nIA,\nJA)\nor gathering\nsub(A)\nto another distributed matrix\nB\nand calling\nsyevd(B,\nIB=1,\nJB=1)\n.\nglobal matrix and local matrix\n\n3.1.5.\nUsage of _bufferSize\n\nThere is no cudaMalloc inside\ncuSolverMG\nlibrary, so the user must allocate the device workspace explicitly. The routine\nxyz_bufferSize\nis to query the size of workspace of the routine\nxyz\n, for example\nxyz\n=\nsyevd\n. To make the API simple,\nxyz_bufferSize\nfollows almost the same signature of\nxyz\neven it only depends on some parameters, for example, the device pointer is not used to decide the size of workspace. In most cases,\nxyz_bufferSize\nis called in the beginning before actual device data (pointing by a device pointer) is prepared or before the device pointer is allocated. In such cases, the user can pass a null pointer to\nxyz_bufferSize\nwithout breaking the functionality.\nxyz_bufferSize\nreturns bufferSize for each device. The size is number of elements, not number of bytes.\n3.1.6.\nSynchronization\n\nAll routines are in synchronous (blocking call) manner. The data is ready after the routine. However the user has to prepare the distributed data before calling the routine. For example, if the user has multiple streams to set up the matrix, stream synchronization or device synchronization is necessary to guarantee the distributed matrix is ready.\n3.1.7.\nContext Switch\n\nThe user does not need to restore the device by\ncudaSetDevice()\nafter each cuSolverMG call. All routines set the device back to what the caller has.\n3.1.8.\nNVLINK\n\nThe peer-to-peer communication via NVLINK can dramatically reduce the overhead of data exchange among GPUs.\ncuSolverMG\ndoes not enable NVLINK implicitly, instead, it gives this option back to the user, not to interfere with other libraries. The example code H.1 shows how to enable peer-to-peer communication.\n3.2.\ncuSolverMG Types Reference\n\n3.2.1.\ncuSolverMG Types\n\nThe\nfloat\n,\ndouble\n,\ncuComplex\n, and\ncuDoubleComplex\ndata types are supported. The first two are standard C data types, while the last two are exported from\ncuComplex.h\n. In addition, cuSolverMG uses some familiar types from cuBLAS.\n3.2.2.\ncusolverMgHandle_t\n\nThis is a pointer type to an opaque cuSolverMG context, which the user must initialize by calling\ncusolverMgCreate()\nprior to calling any other library function. An un-initialized handle object will lead to unexpected behavior, including crashes of cuSolverMG. The handle created and returned by\ncusolverMgCreate()\nmust be passed to every cuSolverMG function.\n3.2.3.\ncusolverMgGridMapping_t\n\nThe type indicates layout of grids.\nValue\nMeaning\nCUDALIBMG_GRID_MAPPING_ROW_MAJOR\nRow-major ordering.\nCUDALIBMG_GRID_MAPPING_COL_MAJOR\nColumn-major ordering.\n3.2.4.\ncudaLibMgGrid_t\n\nOpaque structure of the distributed grid.\n3.2.5.\ncudaLibMgMatrixDesc_t\n\nOpaque structure of the distributed matrix descriptor.\n3.3.\nHelper Function Reference\n\n3.3.1.\ncusolverMgCreate() [DEPRECATED]\n\n[[DEPRECATED]] cuSolverMG is deprecated. Users are encouraged to use\ncuSOLVERMp\nfor multi-GPU functionality, both single- and multi-node.\ncusolverStatus_t\ncusolverMgCreate\n(\ncusolverMgHandle_t\n*\nhandle\n)\nThis function initializes the cuSolverMG library and creates a handle on the cuSolverMG context. It must be called before any other cuSolverMG API function is invoked. It allocates hardware resources necessary for accessing the GPU.\nOutput\nhandle\nThe pointer to the handle to the cuSolverMG context.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe initialization succeeded.\nCUSOLVER_STATUS_ALLOC_FAILED\nThe resources could not be allocated.\n3.3.2.\ncusolverMgDestroy() [DEPRECATED]\n\n[[DEPRECATED]] cuSolverMG is deprecated. Users are encouraged to use\ncuSOLVERMp\nfor multi-GPU functionality, both single- and multi-node.\ncusolverStatus_t\ncusolverMgDestroy\n(\ncusolverMgHandle_t\nhandle\n)\nThis function releases CPU-side resources used by the cuSolverMG library.\nInput\nhandle\nThe handle to the cuSolverMG context.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe shutdown succeeded.\n3.3.3.\ncusolverMgDeviceSelect() [DEPRECATED]\n\n[[DEPRECATED]] cuSolverMG is deprecated. Users are encouraged to use\ncuSOLVERMp\nfor multi-GPU functionality, both single- and multi-node.\ncusolverStatus_t\ncusolverMgDeviceSelect\n(\ncusolverMgHandle_t\nhandle\n,\nint\nnbDevices\n,\nint\ndeviceId\n[]\n)\nThis function registers a subset of devices (GPUs) to\ncuSolverMG\nhandle. Such subset of devices is used in subsequent API calls. The array\ndeviceId\ncontains a list of logical device ID. The term\nlogical\nmeans repeated device ID are permitted. For example, suppose the user has only one GPU in the system, say device 0. If the user sets\ndeviceId=0,0,0\n, then\ncuSolverMG\ntreats them as three independent GPUs, one stream each, so concurrent kernel launches still hold. The current design only supports up to 32 logical devices.\nInput\nhandle\nThe pointer to the handle to the cuSolverMG context.\nnbDevices\nThe number of logical devices.\ndeviceId\nAn integer array of size\nnbDevices\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe initialization succeeded.\nCUSOLVER_STATUS_INVALID_VALUE\nnbDevices\nmust be greater than zero, and less or equal to 32.\nCUSOLVER_STATUS_ALLOC_FAILED\nThe resources could not be allocated.\nCUSOLVER_STATUS_INTERNAL_ERROR\nInternal error occurred when setting internal streams and events.\n3.3.4.\ncusolverMgCreateDeviceGrid() [DEPRECATED]\n\n[[DEPRECATED]] cuSolverMG is deprecated. Users are encouraged to use\ncuSOLVERMp\nfor multi-GPU functionality, both single- and multi-node.\ncusolverStatus_t\ncusolverMgCreateDeviceGrid\n(\ncusolverMgGrid_t\n*\ngrid\n,\nint32_t\nnumRowDevices\n,\nint32_t\nnumColDevices\n,\nconst\nint32_t\ndeviceId\n[],\ncusolverMgGridMapping_t\nmapping\n)\nThis function sets up a grid of devices.\nOnly 1-D column block cyclic is supported, so\nnumRowDevices\nmust be equal to 1.\nWarning\ncusolverMgCreateDeviceGrid()\nmust be consistent with\ncusolverMgDeviceSelect()\n, i.e.\nnumColDevices\nmust be equal to\nnbDevices\nin\ncusolverMgDeviceSelect()\n.\nParameter\nMemSpace\nIn/out\nMeaning\ngrid\nhost\noutput\nThe pointer to the opaque structure.\nnumRowDevices\nhost\ninput\nNumber of devices in the row.\nnumColDevices\nhost\ninput\nNumber of devices in the column.\ndeviceId\nhost\ninput\nInteger array of size\nnumColDevices\n, containing device IDs.\nmapping\nhost\ninput\nRow-major or column-major ordering.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_INVALID_VALUE\nnumColDevices\nis not greater than 0.\nnumRowDevices\nis not 1.\n3.3.5.\ncusolverMgDestroyGrid() [DEPRECATED]\n\n[[DEPRECATED]] cuSolverMG is deprecated. Users are encouraged to use\ncuSOLVERMp\nfor multi-GPU functionality, both single- and multi-node.\ncusolverStatus_t\ncusolverMgDestroyGrid\n(\ncusolverMgGrid_t\ngrid\n)\nThis function releases resources of a grid.\nParameter\nMemSpace\nIn/out\nMeaning\ngrid\nhost\ninput/output\nThe pointer to the opaque structure.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\n3.3.6.\ncusolverMgCreateMatrixDesc() [DEPRECATED]\n\n[[DEPRECATED]] cuSolverMG is deprecated. Users are encouraged to use\ncuSOLVERMp\nfor multi-GPU functionality, both single- and multi-node.\ncusolverStatus_t\ncusolverMgCreateMatrixDesc\n(\ncusolverMgMatrixDesc_t\n*\ndesc\n,\nint64_t\nnumRows\n,\nint64_t\nnumCols\n,\nint64_t\nrowBlockSize\n,\nint64_t\ncolBlockSize\n,\ncudaDataType_t\ndataType\n,\nconst\ncusolverMgGrid_t\ngrid\n)\nThis function sets up the matrix descriptor\ndesc\n.\nOnly 1-D column block cyclic is supported, so\nnumRows\nmust be equal to\nrowBlockSize\n.\nParameter\nMemory\nIn/out\nMeaning\ndesc\nhost\noutput\nThe matrix descriptor.\nnumRows\nhost\ninput\nThe number of rows of global A.\nnumCols\nhost\ninput\nThe number of columns of global A.\nrowBlockSize\nhost\ninput\nThe number of rows per tile.\ncolBlockSize\nhost\ninput\nThe number of columns per tile.\ndataType\nhost\ninput\nData type of the matrix.\ngrid\nhost\ninput\nThe pointer to structure of grid.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_INVALID_VALUE\nnumRows\n,\nnumCols\n, or\nrowBlockSize\nor\ncolBlockSize\nis less than 0.\nnumRows\nis not equal to\nrowBlockSize\n.\n3.3.7.\ncusolverMgDestroyMatrixDesc() [DEPRECATED]\n\n[[DEPRECATED]] cuSolverMG is deprecated. Users are encouraged to use\ncuSOLVERMp\nfor multi-GPU functionality, both single- and multi-node.\ncusolverStatus_t\ncusolverMgDestroyMatrixDesc\n(\ncusolverMgMatrixDesc_t\ndesc\n)\nThis function releases the matrix descriptor\ndesc\n.\nParameter\nMemory\nIn/out\nMeaning\ndesc\nhost\ninput/output\nThe matrix descriptor.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\n3.4.\nDense Linear Solver Reference\n\nThis section describes the linear solver API of cuSolverMG.\n3.4.1.\ncusolverMgPotrf() [DEPRECATED]\n\n[[DEPRECATED]] cuSolverMG is deprecated. Users are encouraged to use\ncuSOLVERMp\nfor multi-GPU functionality, both single- and multi-node.\nThe following helper function can calculate the sizes needed for pre-allocated buffer for\ncusolverMgPotrf\n:\ncusolverStatus_t\ncusolverMgPotrf_bufferSize\n(\ncusolverMgHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nN\n,\nvoid\n*\narray_d_A\n[],\nint\nIA\n,\nint\nJA\n,\ncudaLibMgMatrixDesc_t\ndescrA\n,\ncudaDataType\ncomputeType\n,\nint64_t\n*\nlwork\n)\nThe following routine:\ncusolverStatus_t\ncusolverMgPotrf\n(\ncusolverMgHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nN\n,\nvoid\n*\narray_d_A\n[],\nint\nIA\n,\nint\nJA\n,\ncudaLibMgMatrixDesc_t\ndescrA\n,\ncudaDataType\ncomputeType\n,\nvoid\n*\narray_d_work\n[],\nint64_t\nlwork\n,\nint\n*\ninfo\n)\ncomputes the Cholesky factorization of a Hermitian positive-definite matrix using the generic API interface.\nA\nis an\n\\(n \\times n\\)\nHermitian matrix; only lower or upper part is meaningful. The input parameter\nuplo\nindicates which part of the matrix is used. The function would leave other parts untouched.\nIf input parameter\nuplo\nis\nCUBLAS_FILL_MODE_LOWER\n, only lower triangular part of\nA\nis processed, and replaced by lower triangular Cholesky factor\nL\n:\n\\[A = L*L^{H}\\]\nIf input parameter\nuplo\nis\nCUBLAS_FILL_MODE_UPPER\n, only upper triangular part of\nA\nis processed, and replaced by upper triangular Cholesky factor\nU\n:\n\\[A = U^{H}*U\\]\nThe user has to provide device working space in\narray_d_work\n.\narray_d_work\nis a host pointer array of dimension\nG\n, where\nG\nis number of devices.\narray_d_work[j]\nis a device pointer pointing to a device memory in j-th device. The data type of\narray_d_work[j]\nis\ncomputeType\n. The size of\narray_d_work[j]\nis\nlwork\nwhich is the number of elements per device, returned by\ncusolverMgPotrf_bufferSize()\n.\nIf Cholesky factorization failed, i.e. some leading minor of\nA\nis not positive definite, or equivalently some diagonal elements of\nL\nor\nU\nis not a real number. The output parameter\ninfo\nwould indicate smallest leading minor of\nA\nwhich is not positive definite.\nIf output parameter\ninfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nThe generic API has two different types,\ndataTypeA\nis data type of the matrix\nA\n, and\ncomputeType\nis compute type of the operation and data type of the workspace (\narray_d_work\n)\ndescrA\ncontains\ndataTypeA\n, so there is no explicit parameter of\ndataTypeA\n.\ncusolverMgPotrf\nonly supports the following four combinations.\nPlease visit\ncuSOLVER Library Samples - MgPotrf\nfor a code example.\nValid combination of data type and compute type\nDataTypeA\nComputeType\nMeaning\nCUDA_R_32F\nCUDA_R_32F\nSPOTRF\nCUDA_R_64F\nCUDA_R_64F\nDPOTRF\nCUDA_C_32F\nCUDA_C_32F\nCPOTRF\nCUDA_C_64F\nCUDA_C_64F\nZPOTRF\nAPI of potrf\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverMg library context.\nuplo\nhost\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other part is not referenced. Only\nCUBLAS_FILL_MODE_LOWER\nis supported.\nN\nhost\ninput\nNumber of rows and columns of matrix\nsub(A)\n.\narray_d_A\nhost\nin/out\nA host pointer array of dimension\nG\n. It contains a distributed <type> array containing\nsub(A)\nof dimension\nN\n*\nN\n. On exit,\nsub(A)\ncontains the factors\nL\nor\nU\n.\nIA\nhost\ninput\nThe row index in the global array A indicating the first row of\nsub(A)\n.\nJA\nhost\ninput\nThe column index in the global array A indicating the first column of\nsub(A)\n.\ndescrA\nhost\ninput\nMatrix descriptor for the distributed matrix A.\ncomputeType\nhost\ninput\nData type used for computation.\narray_d_work\nhost\nin/out\nA host pointer array of dimension\nG\n.\narray_d_work[j]\npoints to a device working space in\nj-th\ndevice, <type> array of size\nlwork\n.\nlwork\nhost\ninput\nSze of\narray_d_work[j]\n, returned by\ncusolverMgPotrf_bufferSize\n.\nlwork\ndenotes number of elements, not number of bytes.\ninfo\nhost\noutput\nIf\ninfo\n=\n0\n, the Cholesky factorization is successful.\nIf\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle).\nIf\ninfo\n=\ni\n, the leading minor of order\ni\nis not positive definite.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nM,N<0\n).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n3.4.2.\ncusolverMgPotrs() [DEPRECATED]\n\n[[DEPRECATED]] cuSolverMG is deprecated. Users are encouraged to use\ncuSOLVERMp\nfor multi-GPU functionality, both single- and multi-node.\nThe helper function below can calculate the sizes needed for pre-allocated buffer for\ncusolverMgPotrs\n.\ncusolverStatus_t\ncusolverMgPotrs_bufferSize\n(\ncusolverMgHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nint\nnrhs\n,\nvoid\n*\narray_d_A\n[],\nint\nIA\n,\nint\nJA\n,\ncudaLibMgMatrixDesc_t\ndescrA\n,\nvoid\n*\narray_d_B\n[],\nint\nIB\n,\nint\nJB\n,\ncudaLibMgMatrixDesc_t\ndescrB\n,\ncudaDataType\ncomputeType\n,\nint64_t\n*\nlwork\n)\nThe following routine:\ncusolverStatus_t\ncusolverMgPotrs\n(\ncusolverMgHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nn\n,\nint\nnrhs\n,\nvoid\n*\narray_d_A\n[],\nint\nIA\n,\nint\nJA\n,\ncudaLibMgMatrixDesc_t\ndescrA\n,\nvoid\n*\narray_d_B\n[],\nint\nIB\n,\nint\nJB\n,\ncudaLibMgMatrixDesc_t\ndescrB\n,\ncudaDataType\ncomputeType\n,\nvoid\n*\narray_d_work\n[],\nint64_t\nlwork\n,\nint\n*\ninfo\n)\nThis function solves a system of linear equations:\n\\[A*X = B\\]\nwhere\nA\nis an\n\\(n \\times n\\)\nHermitian matrix, only lower or upper part is meaningful using the generic API interface. The input parameter\nuplo\nindicates which part of the matrix is used. The function would leave other parts untouched.\nIf input parameter\nuplo\nis\nCUBLAS_FILL_MODE_LOWER\n, the matrix should\nA\ncontain the lower triangular factor for Cholesky decomposition previously computed by\ncusolverMgPotrf\nroutine.\n\\[A = L*L^{H}\\]\nIf input parameter\nuplo\nis\nCUBLAS_FILL_MODE_UPPER\n, the matrix should\nA\ncontain the upper triangular factor for Cholesky decomposition previously computed by the\ncusolverMgPotrf\nroutine.\n\\[A = U^{H}*U\\]\nThe operation is in-place, i.e. matrix\nB\ncontains the solution of the linear system on exit.\nIf output parameter\ninfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nThe user has to provide device working space in\narray_d_work\n.\narray_d_work\nis a host pointer array of dimension\nG\n, where\nG\nis the number of devices.\narray_d_work[j]\nis a device pointer pointing to a device memory in the\nj\n-th device. The data type of\narray_d_work[j]\nis\ncomputeType\n. The size of\narray_d_work[j]\nis\nlwork\nwhich is number of elements per device, returned by\ncusolverMgPotrs_bufferSize()\n.\nIf output parameter\ninfo\n=\n-i\n(less than zero), the\ni\n-th parameter is wrong (not counting handle).\nThe generic API has four different types:\ndataTypeA\nis data type of the matrix\nA\n,\ndataTypeB\nis data type of the matrix\nB\n,\ncomputeType\nis compute type of the operation and data type of the workspace (\narray_d_work\n)\ndescrA\ncontains\ndataTypeA\nand\ndescrB\ncontains\ndataTypeB\nand so there is no explicit parameter of\ndataTypeA\nand\ndataTypeB\n.\ncusolverMgPotrs\nonly supports the following four combinations.\nPlease visit\ncuSOLVER Library Samples - MgPotrf\nfor a code example.\nValid combination of data type and compute type\nDataTypeA\nDataTypeB\nComputeType\nMeaning\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nSPOTRS\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nDPOTRS\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nCPOTRS\nCUDA_C_64F\nCUDA_C_64F\nCUDA_C_64F\nZPOTRS\nAPI of potrs\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverMg library context.\nuplo\nhost\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other part is not referenced. Only\nCUBLAS_FILL_MODE_LOWER\nis supported.\nN\nhost\ninput\nNumber of rows and columns of matrix\nsub(A)\n.\nNRHS\nhost\ninput\nNumber of columns of matrix\nsub(A)\nand\nsub(B)\n.\narray_d_A\nhost\nin/out\nA host pointer array of dimension\nG\n. It contains a distributed <type> array containing\nsub(A)\nof dimension\nM\n*\nN\n. On exit,\nsub(A)\ncontains the factors\nL\nand\nU\n.\nIA\nhost\ninput\nThe row index in the global array A indicating the first row of\nsub(A)\n.\nJA\nhost\ninput\nThe column index in the global array A indicating the first column of\nsub(A)\n.\ndescrA\nhost\ninput\nMatrix descriptor for the distributed matrix A.\narray_d_B\nhost\nin/out\nA host pointer array of dimension\nG\n. It contains a distributed <type> array containing\nsub(B)\nof dimension\nN\n*\nNRHS\n. On exit,\nsub(A)\ncontains the solution to the linear system.\nIB\nhost\ninput\nThe row index in the global array B indicating the first row of\nsub(B)\n.\nJB\nhost\ninput\nThe column index in the global array B indicating the first column of\nsub(B)\n.\ndescrB\nhost\ninput\nMatrix descriptor for the distributed matrix B.\ncomputeType\nhost\ninput\nData type used for computation.\narray_d_work\nhost\nin/out\nA host pointer array of dimension\nG\n.\narray_d_work[j]\npoints to a device working space in\nj-th\ndevice, <type> array of size\nlwork\n.\nlwork\nhost\ninput\nSize of\narray_d_work[j]\n, returned by\ncusolverMgPotrs_bufferSize\n.\nlwork\ndenotes number of elements, not number of bytes.\ninfo\nhost\noutput\nIf\ninfo\n=\n0\n, the routine successful.\nIf\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle).\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nM,N<0\n).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n3.4.3.\ncusolverMgPotri() [DEPRECATED]\n\n[[DEPRECATED]] cuSolverMG is deprecated. Users are encouraged to use\ncuSOLVERMp\nfor multi-GPU functionality, both single- and multi-node.\nThe helper function below can calculate the sizes needed for pre-allocated buffer for\ncusolverMgPotri\n.\ncusolverStatus_t\ncusolverMgPotri_bufferSize\n(\ncusolverMgHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nN\n,\nvoid\n*\narray_d_A\n[],\nint\nIA\n,\nint\nJA\n,\ncudaLibMgMatrixDesc_t\ndescrA\n,\ncudaDataType\ncomputeType\n,\nint64_t\n*\nlwork\n)\nThe following routine:\ncusolverStatus_t\ncusolverMgPotri\n(\ncusolverMgHandle_t\nhandle\n,\ncublasFillMode_t\nuplo\n,\nint\nN\n,\nvoid\n*\narray_d_A\n[],\nint\nIA\n,\nint\nJA\n,\ncudaLibMgMatrixDesc_t\ndescrA\n,\ncudaDataType\ncomputeType\n,\nvoid\n*\narray_d_work\n[],\nint64_t\nlwork\n,\nint\n*\ninfo\n)\nThis function computes the inverse of a Hermitian positive-definite matrix\nA\nusing the Cholesky factorization\n\\[A = L*L^{H} = U^{H}*U\\]\ncomputed by\ncusolverMgPotrf()\n.\nIf the input parameter\nuplo\nis\nCUBLAS_FILL_MODE_LOWER\n, on input, matrix\nA\ncontains the lower triangular factor of\nA\ncomputed by\ncusolverMgPotrf\n. Only lower triangular part of\nA\nis processed, and replaced the by lower triangular part of the inverse of\nA\n.\nIf the input parameter\nuplo\nis\nCUBLAS_FILL_MODE_UPPER\n, on input, matrix\nA\ncontains the upper triangular factor of\nA\ncomputed by\ncusolverMgPotrf\n. Only upper triangular part of\nA\nis processed, and replaced the by upper triangular part of the inverse of\nA\n.\nThe user has to provide device working space in\narray_d_work\n.\narray_d_work\nis a host pointer array of dimension\nG\n, where\nG\nis number of devices.\narray_d_work[j]\nis a device pointer pointing to a device memory in the\nj\n-th device. The data type of\narray_d_work[j]\nis\ncomputeType\n. The size of\narray_d_work[j]\nis\nlwork\nwhich is number of elements per device, returned by\ncusolverMgPotri_bufferSize()\n.\nIf the computation of the inverse fails, i.e. some leading minor of\nL\nor\nU\n, is null, the output parameter\ninfo\nwould indicate the smallest leading minor of\nL\nor\nU\nwhich is not positive definite.\nIf the output parameter\ninfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting the handle).\nThe generic API has two different types,\ndataTypeA\nis data type of the matrix\nA\n,\ncomputeType\nis compute type of the operation and data type of the workspace (\narray_d_work\n)\ndescrA\ncontains\ndataTypeA\n, so there is no explicit parameter of\ndataTypeA\n.\ncusolverMgPotri\nonly supports the following four combinations.\nPlease visit\ncuSOLVER Library Samples - MgPotrf\nfor a code example.\nValid combinations of data type and compute type\nDataTypeA\nComputeType\nMeaning\nCUDA_R_32F\nCUDA_R_32F\nSPOTRI\nCUDA_R_64F\nCUDA_R_64F\nDPOTRI\nCUDA_C_32F\nCUDA_C_32F\nCPOTRI\nCUDA_C_64F\nCUDA_C_64F\nZPOTRI\nAPI of potri\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverMg library context.\nuplo\nhost\ninput\nIndicates if matrix\nA\nlower or upper part is stored, the other part is not referenced. Only\nCUBLAS_FILL_MODE_LOWER\nis supported.\nN\nhost\ninput\nNumber of rows and columns of matrix\nsub(A)\n.\narray_d_A\nhost\nin/out\nA host pointer array of dimension\nG\n. It contains a distributed <type> array containing\nsub(A)\nof dimension\nN\n*\nN\n. On exit,\nsub(A)\ncontains the upper or lower triangular part of the inverse of A depending on the value of\nuplo\nargument.\nIA\nhost\ninput\nThe row index in the global array A indicating the first row of\nsub(A)\n.\nJA\nhost\ninput\nThe column index in the global array A indicating the first column of\nsub(A)\n.\ndescrA\nhost\ninput\nMatrix descriptor for the distributed matrix A.\ncomputeType\nhost\ninput\nData type used for computation.\narray_d_work\nhost\nin/out\nA host pointer array of dimension\nG\n.\narray_d_work[j]\npoints to a device working space in\nj-th\ndevice, <type> array of size\nlwork\n.\nlwork\nhost\ninput\nSize of\narray_d_work[j]\n, returned by\ncusolverMgPotri_bufferSize\n.\nlwork\ndenotes number of elements, not number of bytes.\ninfo\nhost\noutput\nIf\ninfo\n=\n0\n, the Cholesky factorization is successful.\nIf\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle).\nIf\ninfo\n=\ni\n, the leading minor of order i is zero.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_NOT_INITIALIZED\nThe library was not initialized.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nM,N<0\n).\nCUSOLVER_STATUS_ARCH_MISMATCH\nThe device only supports compute capability 5.0 and above.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n3.4.4.\ncusolverMgGetrf() [DEPRECATED]\n\n[[DEPRECATED]] cuSolverMG is deprecated. Users are encouraged to use\ncuSOLVERMp\nfor multi-GPU functionality, both single- and multi-node.\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverMgGetrf_bufferSize\n(\ncusolverMgHandle_t\nhandle\n,\nint\nM\n,\nint\nN\n,\nvoid\n*\narray_d_A\n[],\nint\nIA\n,\nint\nJA\n,\ncudaLibMgMatrixDesc_t\ndescrA\n,\nint\n*\narray_d_IPIV\n[],\ncudaDataType_t\ncomputeType\n,\nint64_t\n*\nlwork\n);\ncusolverStatus_t\ncusolverMgGetrf\n(\ncusolverMgHandle_t\nhandle\n,\nint\nM\n,\nint\nN\n,\nvoid\n*\narray_d_A\n[],\nint\nIA\n,\nint\nJA\n,\ncudaLibMgMatrixDesc_t\ndescrA\n,\nint\n*\narray_d_IPIV\n[],\ncudaDataType_t\ncomputeType\n,\nvoid\n*\narray_d_work\n[],\nint64_t\nlwork\n,\nint\n*\ninfo\n);\nThis function computes the LU factorization of an\n\\(M \\times N\\)\nmatrix\n\\[P*A = L*U\\]\nwhere\nA\nis an\n\\(M \\times N\\)\nmatrix,\nP\nis a permutation matrix,\nL\nis a lower triangular matrix with unit diagonal, and\nU\nis an upper triangular matrix.\nThe user has to provide device working space in\narray_d_work\n.\narray_d_work\nis a host pointer array of dimension\nG\n, where\nG\nis number of devices.\narray_d_work[j]\nis a device pointer pointing to a device memory in j-th device. The data type of\narray_d_work[j]\nis\ncomputeType\n. The size of\narray_d_work[j]\nis\nlwork\nwhich is number of elements per device, returned by\ncusolverMgGetrf_bufferSize()\n.\nIf LU factorization failed, i.e. matrix\nA\n(\nU\n) is singular, The output parameter\ninfo=i\nindicates\nU(i,i)\n=\n0\n.\nIf output parameter\ninfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nIf\narray_d_IPIV\nis null, no pivoting is performed. The factorization is\nA=L*U\n, which is not numerically stable.\narray_d_IPIV\nmust be consistent with\narray_d_A\n, i.e.\nJA\nis the first column of\nsub(A)\n, also the first column of\nsub(IPIV)\n.\nNo matter LU factorization failed or not, the output parameter\narray_d_IPIV\ncontains pivoting sequence, row\ni\nis interchanged with row\narray_d_IPIV(i)\n.\nThe generic API has three different types,\ndataTypeA\nis data type of the matrix\nA\n,\ncomputeType\nis compute type of the operation and data type of the workspace (\narray_d_work\n)\ndescrA\ncontains\ndataTypeA\n, so there is no explicit parameter of\ndataTypeA\n.\ncusolverMgGetrf\nonly supports the following four combinations.\nPlease visit\ncuSOLVER Library Samples - MgGetrf\nfor a code example.\nValid combinations of data type and compute type\nDataTypeA\nComputeType\nMeaning\nCUDA_R_32F\nCUDA_R_32F\nSGETRF\nCUDA_R_64F\nCUDA_R_64F\nDGETRF\nCUDA_C_32F\nCUDA_C_32F\nCGETRF\nCUDA_C_64F\nCUDA_C_64F\nZGETRF\nRemark 1: tile size\nTA\nmust be less or equal to 512.\nAPI of getrf\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverMg library context.\nM\nhost\ninput\nNumber of rows of matrix\nsub(A)\n.\nN\nhost\ninput\nNumber of columns of matrix\nsub(A)\n.\narray_d_A\nhost\nin/out\nA host pointer array of dimension\nG\n. It contains a distributed <type> array containing\nsub(A)\nof dimension\nM\n*\nN\n. On exit,\nsub(A)\ncontains the factors\nL\nand\nU\n.\nIA\nhost\ninput\nThe row index in the global array A indicating the first row of\nsub(A)\n.\nJA\nhost\ninput\nThe column index in the global array A indicating the first column of\nsub(A)\n.\ndescrA\nhost\ninput\nMatrix descriptor for the distributed matrix A.\narray_d_IPIV\nhost\noutput\nA host pointer array of dimension\nG\n. it contains a distributed integer array containing\nsub(IPIV)\nof size\nmin(M,N)\n.\nsub(IPIV)\ncontains pivot indices.\ncomputeType\nhost\ninput\nData type used for computation.\narray_d_work\nhost\nin/out\nA host pointer array of dimension\nG\n.\narray_d_work[j]\npoints to a device working space in\nj-th\ndevice, <type> array of size\nlwork\n.\nlwork\nhost\ninput\nSize of\narray_d_work[j]\n, returned by\ncusolverMgGetrf_bufferSize\n.\nlwork\ndenotes number of elements, not number of bytes.\ninfo\nhost\noutput\nIf\ninfo\n=\n0\n, the LU factorization is successful.\nIf\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle).\nIf\ninfo\n=\ni\n, the\nU(i,i)\n=\n0\n.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nM,N<0\n).\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n3.4.5.\ncusolverMgGetrs() [DEPRECATED]\n\n[[DEPRECATED]] cuSolverMG is deprecated. Users are encouraged to use\ncuSOLVERMp\nfor multi-GPU functionality, both single- and multi-node.\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverMgGetrs_bufferSize\n(\ncusolverMgHandle_t\nhandle\n,\ncublasOperation_t\nTRANS\n,\nint\nN\n,\nint\nNRHS\n,\nvoid\n*\narray_d_A\n[],\nint\nIA\n,\nint\nJA\n,\ncudaLibMgMatrixDesc_t\ndescrA\n,\nint\n*\narray_d_IPIV\n[],\nvoid\n*\narray_d_B\n[],\nint\nIB\n,\nint\nJB\n,\ncudaLibMgMatrixDesc_t\ndescrB\n,\ncudaDataType_t\ncomputeType\n,\nint64_t\n*\nlwork\n);\ncusolverStatus_t\ncusolverMgGetrs\n(\ncusolverMgHandle_t\nhandle\n,\ncublasOperation_t\nTRANS\n,\nint\nN\n,\nint\nNRHS\n,\nvoid\n*\narray_d_A\n[],\nint\nIA\n,\nint\nJA\n,\ncudaLibMgMatrixDesc_t\ndescrA\n,\nint\n*\narray_d_IPIV\n[],\nvoid\n*\narray_d_B\n[],\nint\nIB\n,\nint\nJB\n,\ncudaLibMgMatrixDesc_t\ndescrB\n,\ncudaDataType_t\ncomputeType\n,\nvoid\n*\narray_d_work\n[],\nint64_t\nlwork\n,\nint\n*\ninfo\n);\nThis function solves a linear system of multiple right-hand sides\n\\[op(A)*X = B\\]\nwhere\nA\nis an\n\\(N \\times N\\)\nmatrix, and was LU-factored by\ngetrf\n, that is, lower triangular part of A is\nL\n, and upper triangular part (including diagonal elements) of\nA\nis\nU\n.\nB\nis an\n\\(N \\times {NRHS}\\)\nright-hand side matrix. The solution matrix\nX\noverwrites the right-hand-side matrix\nB\n.\nThe input parameter\nTRANS\nis defined by\nThe user has to provide device working space in\narray_d_work\n.\narray_d_work\nis a host pointer array of dimension\nG\n, where\nG\nis number of devices.\narray_d_work[j]\nis a device pointer pointing to a device memory in j-th device. The data type of\narray_d_work[j]\nis\ncomputeType\n. The size of\narray_d_work[j]\nis\nlwork\nwhich is number of elements per device, returned by\ncusolverMgGetrs_bufferSize()\n.\nIf\narray_d_IPIV\nis null, no pivoting is performed. Otherwise,\narray_d_IPIV\nis an output of\ngetrf\n. It contains pivot indices, which are used to permutate right-hand sides.\nIf output parameter\ninfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle).\nThe generic API has three different types,\ndataTypeA\nis data type of the matrix\nA\n,\ndataTypeB\nis data type of the matrix\nB\n, and\ncomputeType\nis compute type of the operation and data type of the workspace (\narray_d_work\n)\ndescrA\ncontains\ndataTypeA\n, so there is no explicit parameter of\ndataTypeA\n.\ndescrB\ncontains\ndataTypeB\n, so there is no explicit parameter of\ndataTypeB\n.\ncusolverMgGetrs\nonly supports the following four combinations.\nValid combinations of data type and compute type\nDataTypeA\nDataTypeB\nComputeType\nMeaning\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nSGETRS\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nDGETRS\nCUDA_C_32F\nCUDA_C_32F\nCUDA_C_32F\nCGETRS\nCUDA_C_64F\nCUDA_C_64F\nCUDA_C_64F\nZGETRS\nRemark 1: tile size\nTA\nmust be less or equal to 512.\nRemark 2: only support\nTRANS=CUBLAS_OP_N\n.\nPlease visit\ncuSOLVER Library Samples - MgGetrf\nfor a code example.\nAPI of getrs\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverMG library context.\nTRANS\nhost\ninput\nOperation\nop(A)\nthat is non- or (conj.) transpose.\nN\nhost\ninput\nNumber of rows and columns of matrix\nsub(A)\n.\nNRHS\nhost\ninput\nNumber of columns of matrix\nsub(B)\n.\narray_d_A\nhost\ninput\nA host pointer array of dimension\nG\n. It contains a distributed <type> array containing\nsub(A)\nof dimension\nM\n*\nN\n.\nsub(A)\ncontains the factors\nL\nand\nU\n.\nIA\nhost\ninput\nThe row index in the global array A indicating the first row of\nsub(A)\n.\nJA\nhost\ninput\nThe column index in the global array A indicating the first column of\nsub(A)\n.\ndescrA\nhost\ninput\nMatrix descriptor for the distributed matrix A.\narray_d_IPIV\nhost\ninput\nA host pointer array of dimension\nG\n. it contains a distributed integer array containing\nsub(IPIV)\nof dimension\nmin(M,N)\n.\nsub(IPIV)\ncontains pivot indices.\narray_d_B\nhost\nin/out\nA host pointer array of dimension\nG\n. It contains a distributed <type> array containing\nsub(B)\nof dimension\nN\n*\nNRHS\n.\nIB\nhost\ninput\nThe row index in the global array B indicating the first row of\nsub(B)\n.\nJB\nhost\ninput\nThe column index in the global array B indicating the first column of\nsub(B)\n.\ndescrB\nhost\ninput\nMatrix descriptor for the distributed matrix B.\ncomputeType\nhost\ninput\nData type used for computation.\narray_d_work\nhost\nin/out\nA host pointer array of dimension\nG\n.\narray_d_work[j]\npoints to a device working space in\nj-th\ndevice, <type> array of size\nlwork\n.\nlwork\nhost\ninput\nSize of\narray_d_work[j]\n, returned by\ncusolverMgGetrs_bufferSize\n.\nlwork\ndenotes number of elements, not number of bytes.\ninfo\nhost\noutput\nIf\ninfo\n=\n0\n, the operation is successful.\nIf\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle).\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nN<0\nor\nNRHS<0\n).\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n3.5.\nDense Eigenvalue Solver Reference\n\nThis section describes the eigenvalue solver API of cuSolverMG.\n3.5.1.\ncusolverMgSyevd() [DEPRECATED]\n\n[[DEPRECATED]] cuSolverMG is deprecated. Users are encouraged to use\ncuSOLVERMp\nfor multi-GPU functionality, both single- and multi-node.\nThe helper functions below can calculate the sizes needed for pre-allocated buffer.\ncusolverStatus_t\ncusolverMgSyevd_bufferSize\n(\ncusolverMgHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nN\n,\nvoid\n*\narray_d_A\n[],\nint\nIA\n,\nint\nJA\n,\ncudaLibMgMatrixDesc_t\ndescrA\n,\nvoid\n*\nW\n,\ncudaDataType_t\ndataTypeW\n,\ncudaDataType_t\ncomputeType\n,\nint64_t\n*\nlwork\n);\ncusolverStatus_t\ncusolverMgSyevd\n(\ncusolverMgHandle_t\nhandle\n,\ncusolverEigMode_t\njobz\n,\ncublasFillMode_t\nuplo\n,\nint\nN\n,\nvoid\n*\narray_d_A\n[],\nint\nIA\n,\nint\nJA\n,\ncudaLibMgMatrixDesc_t\ndescrA\n,\nvoid\n*\nW\n,\ncudaDataType_t\ndataTypeW\n,\ncudaDataType_t\ncomputeType\n,\nvoid\n*\narray_d_work\n[],\nint64_t\nlwork\n,\nint\n*\ninfo\n);\nThis function computes eigenvalues and eigenvectors of a symmetric (Hermitian)\n\\(N \\times N\\)\nmatrix\nA\n. The standard symmetric eigenvalue problem is:\n\\[A*V = V*\\Lambda\\]\nwhere\nΛ\nis a real\n\\(N \\times N\\)\ndiagonal matrix.\nV\nis an\n\\(N \\times N\\)\nunitary matrix. The diagonal elements of\nΛ\nare the eigenvalues of\nA\nin ascending order.\ncusolverMgSyevd\nreturns the eigenvalues in\nW\nand overwrites the eigenvectors in\nA\n.\nW\nis a host\n\\(1 \\times N\\)\nvector.\nThe generic API has three different types,\ndataTypeA\nis data type of the matrix\nA\n,\ndataTypeW\nis data type of the vector\nW\n, and\ncomputeType\nis compute type of the operation and data type of the workspace (\narray_d_work\n)\ndescrA\ncontains\ndataTypeA\n, so there is no explicit parameter of\ndataTypeA\n.\ncusolverMgSyevd\nonly supports the following four combinations.\nValid combination of data type and compute type\nDataTypeA\nDataTypeW\nComputeType\nMeaning\nCUDA_R_32F\nCUDA_R_32F\nCUDA_R_32F\nSSYEVD\nCUDA_R_64F\nCUDA_R_64F\nCUDA_R_64F\nDSYEVD\nCUDA_C_32F\nCUDA_R_32F\nCUDA_C_32F\nCHEEVD\nCUDA_C_64F\nCUDA_R_64F\nCUDA_C_64F\nZHEEVD\nThe user has to provide device working space in\narray_d_work\n.\narray_d_work\nis a host pointer array of dimension\nG\n, where\nG\nis number of devices.\narray_d_work[j]\nis a device pointer pointing to a device memory in j-th device. The data type of\narray_d_work[j]\nis\ncomputeType\n. The size of\narray_d_work[j]\nis\nlwork\nwhich is number of elements per device, returned by\ncusolverMgSyevd_bufferSize()\n.\narray_d_A\nis also a host pointer array of dimension\nG\n.\narray_d_A[j]\nis a device pointer pointing to a device memory in j-th device. The data type of\narray_d_A[j]\nis\ndataTypeA\n. The size of\narray_d_A[j]\nis about\nN*TA*(blocks\nper\ndevice)\n. The user has to prepare\narray_d_A\nmanually (see\ncuSOLVER Library Samples - MgSyevd\nfor a code example.).\nIf output parameter\ninfo\n=\n-i\n(less than zero), the\ni-th\nparameter is wrong (not counting handle). If\ninfo\n=\ni\n(greater than zero), the algorithm failed to converge all eigenvalues.\nIf\njobz\n= CUSOLVER_EIG_MODE_VECTOR,\nA\ncontains the orthonormal eigenvectors of the matrix\nA\n. The eigenvectors are computed by a divide and conquer algorithm.\nRemark 1: only\nCUBLAS_FILL_MODE_LOWER\nis supported, so the user has to prepare lower triangle of\nA\n.\nRemark 2: only\nIA=1\nand\nJA=1\nare supported.\nRemark 3: tile size\nTA\nmust be less or equal to 1024. To achieve best performance,\nTA\nshould be 256 or 512.\nPlease visit\ncuSOLVER Library Samples - MgSyevd\nfor a code example.\nAPI of syevd\n\nParameter\nMemory\nIn/out\nMeaning\nhandle\nhost\ninput\nHandle to the cuSolverMG library context.\njobz\nhost\ninput\nSpecifies options to either compute eigenvalue only or compute eigen-pair:\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n: Compute eigenvalues only\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n: Compute eigenvalues and eigenvectors\nuplo\nhost\ninput\nSpecifies which part of\nA\nis stored.\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n: Lower triangle of\nA\nis stored.\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n: Upper triangle of\nA\nis stored.\nOnly\nCUBLAS_FILL_MODE_LOWER\nis supported.\nN\nhost\ninput\nNumber of rows (or columns) of matrix\nsub(A)\n.\narray_d_A\nhost\nin/out\nA host pointer array of dimension\nG\n. It contains a distributed <type> array containing\nsub(A)\nof dimension\nN\n*\nN\n.\nIf\nuplo\n=\nCUBLAS_FILL_MODE_UPPER\n, the leading N-by-N upper triangular part of\nsub(A)\ncontains the upper triangular part of the matrix\nsub(A)\n.\nIf\nuplo\n=\nCUBLAS_FILL_MODE_LOWER\n, the leading N-by-N lower triangular part of\nsub(A)\ncontains the lower triangular part of the matrix\nsub(A)\n. On exit, if\njobz\n=\nCUSOLVER_EIG_MODE_VECTOR\n, and\ninfo\n= 0,\nsub(A)\ncontains the orthonormal eigenvectors of the matrix\nsub(A)\n.\nIf\njobz\n=\nCUSOLVER_EIG_MODE_NOVECTOR\n, the contents of\nA\nare destroyed.\nIA\nhost\ninput\nThe row index in the global array A indicating the first row of\nsub(A)\n.\nJA\nhost\ninput\nThe column index in the global array A indicating the first column of\nsub(A)\n.\ndescrA\nhost\ninput\nMatrix descriptor for the distributed matrix A.\nW\nhost\noutput\nA real array of dimension\nN\n. The eigenvalue values of\nsub(A)\n, in ascending order, that is, sorted so that\nW(i)\n<=\nW(i+1)\n.\ndataTypeW\nhost\ninput\nData type of the vector W.\ncomputeType\nhost\ninput\nData type used for computation.\narray_d_work\nhost\nin/out\nA host pointer array of dimension\nG\n.\narray_d_work[j]\npoints to a device working space in\nj-th\ndevice, <type> array of size\nlwork\n.\nlwork\nhost\ninput\nSize of\narray_d_work[j]\n, returned by\ncusolverMgSyevd_bufferSize\n.\nlwork\ndenotes number of elements, not number of bytes.\ninfo\nhost\noutput\nIf\ninfo\n=\n0\n, the operation is successful.\nIf\ninfo\n=\n-i\n, the\ni-th\nparameter is wrong (not counting handle).\nIf\ninfo\n=\ni\n(>\n0)\n, not all eigenvalues converged.\nStatus Returned\nCUSOLVER_STATUS_SUCCESS\nThe operation completed successfully.\nCUSOLVER_STATUS_INVALID_VALUE\nInvalid parameters were passed (\nN<0\n, or\nlda<max(1,N)\n, or\njobz\nis not\nCUSOLVER_EIG_MODE_NOVECTOR\nor\nCUSOLVER_EIG_MODE_VECTOR\n, or\nuplo\nis not\nCUBLAS_FILL_MODE_LOWER\n, or\nIA\nand\nJA\nare not 1, or\nN\nis bigger than dimension of global\nA\n, or the combination of\ndataType\nand\ncomputeType\nis not valid.\nCUSOLVER_STATUS_INTERNAL_ERROR\nAn internal operation failed.\n4.\nAcknowledgements\n\nNVIDIA would like to thank the following individuals and institutions for their contributions:\nCPU LAPACK routines from netlib, CLAPACK-3.2.1 (\nhttp://www.netlib.org/clapack/\n)\nThe following is license of CLAPACK-3.2.1.\nCopyright (c) 1992-2008 The University of Tennessee. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer listed in this license in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nMETIS-5.1.0 (\nhttp://glaros.dtc.umn.edu/gkhome/metis/metis/overview\n)\nThe following is license of METIS (Apache 2.0 license).\nCopyright 1995-2013, Regents of the University of Minnesota\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\nQD (A C++/fortran-90 double-double and quad-double package) (\nhttp://crd-legacy.lbl.gov/~dhbailey/mpdist/\n)\nThe following is license of QD (modified BSD license).\nCopyright (c) 2003-2009, The Regents of the University of California, through Lawrence Berkeley National Laboratory (subject to receipt of any required approvals from U.S. Dept. of Energy) All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\nRedistributions of source code must retain the copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the University of California, Lawrence Berkeley National Laboratory, U.S. Dept. of Energy nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nYou are under no obligation whatsoever to provide any bug fixes, patches, or upgrades to the features, functionality or performance of the source code (“Enhancements”) to anyone; however, if you choose to make your Enhancements available either publicly, or directly to Lawrence Berkeley National Laboratory, without imposing a separate written license agreement for such Enhancements, then you hereby grant the following license: a non-exclusive, royalty-free perpetual license to install, use, modify, prepare derivative works, incorporate into other computer software, distribute, and sublicense such enhancements or derivative works thereof, in binary and source code form.\n5.\nBibliography\n\n[1] Timothy A. Davis, Direct Methods for sparse Linear Systems, siam 2006.\n[2] E. Chuthill and J. McKee, reducing the bandwidth of sparse symmetric matrices, ACM ‘69 Proceedings of the 1969 24th national conference, Pages 157-172.\n[3] Alan George, Joseph W. H. Liu, An Implementation of a Pseudoperipheral Node Finder, ACM Transactions on Mathematical Software (TOMS) Volume 5 Issue 3, Sept. 1979 Pages 284-295.\n[4] J. R. Gilbert and T. Peierls, Sparse partial pivoting in time proportional to arithmetic operations, SIAM J. Sci. Statist. Comput., 9 (1988), pp. 862-874.\n[5] Alan George and Esmond Ng, An Implementation of Gaussian Elimination with Partial Pivoting for Sparse Systems, SIAM J. Sci. and Stat. Comput., 6(2), 390-409.\n[6] Alan George and Esmond Ng, Symbolic Factorization for Sparse Gaussian Elimination with Partial Pivoting, SIAM J. Sci. and Stat. Comput., 8(6), 877-898.\n[7] John R. Gilbert, Xiaoye S. Li, Esmond G. Ng, Barry W. Peyton, Computing Row and Column Counts for Sparse QR and LU Factorization, BIT 2001, Vol. 41, No. 4, pp. 693-711.\n[8] Patrick R. Amestoy, Timothy A. Davis, Iain S. Duff, An Approximate Minimum Degree Ordering Algorithm, SIAM J. Matrix Analysis Applic. Vol 17, no 4, pp. 886-905, Dec. 1996.\n[9] Alan George, Joseph W. Liu, A Fast Implementation of the Minimum Degree Algorithm Using Quotient Graphs, ACM Transactions on Mathematical Software, Vol 6, No. 3, September 1980, page 337-358.\n[10] Alan George, Joseph W. Liu, Computer Solution of Large Sparse Positive Definite Systems, Englewood Cliffs, New Jersey: Prentice-Hall, 1981.\n[11] Iain S. Duff, ALGORITHM 575 Permutations for a Zero-Free Diagonal, ACM Transactions on Mathematical Software, Vol 7, No 3, September 1981, Page 387-390\n[12] Iain S. Duff and Jacko Koster, On algorithms for permuting large entries to the diagonal of a sparse matrix, SIAM Journal on Matrix Analysis and Applications, 2001, Vol. 22, No. 4 : pp. 973-996\n[13] “A Fast and Highly Quality Multilevel Scheme for Partitioning Irregular Graphs”. George Karypis and Vipin Kumar. SIAM Journal on Scientific Computing, Vol. 20, No. 1, pp. 359-392, 1999.\n[14] YUJI NAKATSUKASA, ZHAOJUN BAI, AND FRANC¸OIS GYGI, OPTIMIZING HALLEY’S ITERATION FOR COMPUTING THE MATRIX POLAR DECOMPOSITION, SIAM J. Matrix Anal. Appl., 31 (5): 2700-2720,2010\n[15] Halko, Nathan, Per-Gunnar Martinsson, and Joel A. Tropp. “Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions.” SIAM review 53.2 (2011): 217-288.\n6.\nNotices\n\n6.1.\nNotice\n\nThis document is provided for information purposes only and shall not be regarded as a warranty of a certain functionality, condition, or quality of a product. NVIDIA Corporation (“NVIDIA”) makes no representations or warranties, expressed or implied, as to the accuracy or completeness of the information contained in this document and assumes no responsibility for any errors contained herein. NVIDIA shall have no liability for the consequences or use of such information or for any infringement of patents or other rights of third parties that may result from its use. This document is not a commitment to develop, release, or deliver any Material (defined below), code, or functionality.\nNVIDIA reserves the right to make corrections, modifications, enhancements, improvements, and any other changes to this document, at any time without notice.\nCustomer should obtain the latest relevant information before placing orders and should verify that such information is current and complete.\nNVIDIA products are sold subject to the NVIDIA standard terms and conditions of sale supplied at the time of order acknowledgement, unless otherwise agreed in an individual sales agreement signed by authorized representatives of NVIDIA and customer (“Terms of Sale”). NVIDIA hereby expressly objects to applying any customer general terms and conditions with regards to the purchase of the NVIDIA product referenced in this document. No contractual obligations are formed either directly or indirectly by this document.\nNVIDIA products are not designed, authorized, or warranted to be suitable for use in medical, military, aircraft, space, or life support equipment, nor in applications where failure or malfunction of the NVIDIA product can reasonably be expected to result in personal injury, death, or property or environmental damage. NVIDIA accepts no liability for inclusion and/or use of NVIDIA products in such equipment or applications and therefore such inclusion and/or use is at customer’s own risk.\nNVIDIA makes no representation or warranty that products based on this document will be suitable for any specified use. Testing of all parameters of each product is not necessarily performed by NVIDIA. It is customer’s sole responsibility to evaluate and determine the applicability of any information contained in this document, ensure the product is suitable and fit for the application planned by customer, and perform the necessary testing for the application in order to avoid a default of the application or the product. Weaknesses in customer’s product designs may affect the quality and reliability of the NVIDIA product and may result in additional or different conditions and/or requirements beyond those contained in this document. NVIDIA accepts no liability related to any default, damage, costs, or problem which may be based on or attributable to: (i) the use of the NVIDIA product in any manner that is contrary to this document or (ii) customer product designs.\nNo license, either expressed or implied, is granted under any NVIDIA patent right, copyright, or other NVIDIA intellectual property right under this document. Information published by NVIDIA regarding third-party products or services does not constitute a license from NVIDIA to use such products or services or a warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual property rights of the third party, or a license from NVIDIA under the patents or other intellectual property rights of NVIDIA.\nReproduction of information in this document is permissible only if approved in advance by NVIDIA in writing, reproduced without alteration and in full compliance with all applicable export laws and regulations, and accompanied by all associated conditions, limitations, and notices.\nTHIS DOCUMENT AND ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, “MATERIALS”) ARE BEING PROVIDED “AS IS.” NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL NVIDIA BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Notwithstanding any damages that customer might incur for any reason whatsoever, NVIDIA’s aggregate and cumulative liability towards customer for the products described herein shall be limited in accordance with the Terms of Sale for the product.\n6.2.\nOpenCL\n\nOpenCL is a trademark of Apple Inc. used under license to the Khronos Group Inc.\n6.3.\nTrademarks\n\nNVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated.", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://docs.nvidia.com/cuda/cusolver/index.html"}}
{"text": "NVIDIA cuDNN — NVIDIA cuDNN\nSkip to main content\nBack to top\nCtrl\n+\nK\nNVIDIA cuDNN\nNVIDIA cuDNN\nNVIDIA cuDNN\n#\nThe NVIDIA CUDA Deep Neural Network library (cuDNN) is a GPU-accelerated library of primitives for deep neural networks. It provides highly tuned implementations of operations arising frequently in deep neural network (DNN) applications:\nScaled dot-product attention\nConvolution, including cross-correlation\nMatrix multiplication\nNormalizations, softmax, and pooling\nArithmetic, mathematical, relational, and logical pointwise operations\nBeyond just providing high-performance implementations of individual operations, cuDNN also supports a flexible set of multi-operation fusion patterns for further optimization. The goal is to achieve the best available performance on NVIDIA GPUs for important deep learning use cases.\nIn cuDNN, both single-operation and multi-operation computations are expressed as operation graphs. The following API layers are available for constructing these graphs:\nPython frontend API\nC++ frontend API\nC backend API\nThe\nNVIDIA cuDNN frontend API\nprovides a simplified programming model that is sufficient for most use cases.\nUse the\nNVIDIA cuDNN backend API\nonly if you want to use the legacy fixed-function routines that are not graph-based interfaces and are not exposed by the frontend API layers, or if you need a C-only interface.", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://docs.nvidia.com/deeplearning/cudnn/index.html"}}
{"text": "Overview — NVIDIA TensorRT Documentation\nSkip to main content\nBack to top\nCtrl\n+\nK\nNVIDIA TensorRT Documentation\nChoose version\nDocumentation Home\nSearch\nCtrl\n+\nK\nSearch\nCtrl\n+\nK\nNVIDIA TensorRT Documentation\nChoose version\nDocumentation Home\nOverview\n#\nThis section demonstrates how to use the C++ and Python APIs to implement the most common deep learning layers. It shows how to take an existing model built with a deep learning framework and build a TensorRT engine using the provided parsers.\nSamples\n#\nThe\nSample Support Guide\nillustrates many of the topics discussed in this section.\nComplementary GPU Features\n#\nMulti-instance GPU\n, or MIG, is a feature of NVIDIA GPUs with NVIDIA Ampere Architecture or later architectures that enable user-directed partitioning of a single GPU into multiple smaller GPUs. The physical partitions provide dedicated compute and memory slices with quality of service and independent execution of parallel workloads on fractions of the GPU. For TensorRT applications with low GPU utilization, MIG can produce higher throughput with little or no latency impact. The optimal partitioning scheme is application-specific.\nComplementary Software\n#\nThe\nNVIDIA Triton Inference Server\nis a higher-level library providing optimized inference across CPUs and GPUs. It provides capabilities for starting and managing multiple models and REST and gRPC endpoints for serving inference.\nNVIDIA DALI\nprovides high-performance primitives for preprocessing image, audio, and video data. TensorRT inference can be integrated as a custom operator in a DALI pipeline. A working example of TensorRT inference integrated into DALI can be found on\nGitHub: DALI\n.\nTorch-TensorRT (Torch-TRT)\nis a PyTorch-TensorRT compiler that converts PyTorch modules into TensorRT engines. Internally, the PyTorch modules are converted into TorchScript/FX modules based on the selected Intermediate Representation (IR). The compiler selects subgraphs of the PyTorch graphs to be accelerated by TensorRT while leaving Torch to execute the rest of the graph natively. The result is still a PyTorch module that you can execute as usual. For examples, refer to\nGitHub: Examples for Torch-TRT\n.\nThe\nTensorRT Model Optimizer\nis a unified library of state-of-the-art model optimization techniques such as quantization, pruning, distillation, etc. It compresses deep learning models for downstream deployment frameworks like TensorRT-LLM or TensorRT to optimize inference speed on NVIDIA GPUs. TensorRT Model Optimizer replaces the\nPyTorch Quantization Toolkit\nand\nTensorFlow-Quantization Toolkit\n, which are no longer maintained. To quantize TensorFlow models, export to ONNX and then use Model Optimizer to quantize the model.\nTensorRT is integrated with NVIDIAâs profiling tool,\nNVIDIA Nsight Systems\n.\nTensorRTâs core functionalities are now accessible via NVIDIAâs\nNsight Deep Learning Designer\n, an IDE for ONNX model editing, performance profiling, and TensorRT engine building.\nA restricted subset of TensorRT is certified for use in\nNVIDIA DRIVE\nproducts. Some APIs are marked for use only in NVIDIA DRIVE and are not supported for general use.\nONNX\n#\nTensorRTâs primary means of importing a trained model from a framework is the\nONNX\ninterchange format. TensorRT ships with an ONNX parser library to assist in importing models. Where possible, the parser is backward compatible up to opset 9; the\nONNX Model Opset Version Converter\ncan assist in resolving incompatibilities.\nThe\nGitHub version\nmay support later opsets than the version shipped with TensorRT.  Refer to the\nONNX-TensorRT operator support matrix\nfor the latest information on the supported opset and operators. For TensorRT deployment, we recommend exporting to the latest available ONNX opset.\nThe ONNX operator support list for TensorRT can be found on\nGitHub: Supported ONNX Operators\n.\nPyTorch natively supports\nONNX export\n. For TensorFlow, the recommended method is\ntf2onnx\n.\nAfter exporting a model to ONNX, a good first step is to run constant folding using\nPolygraphy\n. This often solves TensorRT conversion issues in the ONNX parser and simplifies the workflow. For details, refer to\nthis example\n. In some cases, modifying the ONNX model may be necessary, such as replacing subgraphs with plugins or reimplementing unsupported operations in other operations. To make this process easier, you can use\nONNX-GraphSurgeon\n.\nCode Analysis Tools\n#\nFor guidance using the Valgrind and Clang sanitizer tools with TensorRT, refer to the\nTroubleshooting\nsection.\nAPI Versioning\n#\nTensorRT version number (MAJOR.MINOR.PATCH) follows\nSemantic Versioning 2.0.0\nfor its public APIs and library ABIs. Version numbers change as follows:\nMAJOR version when making incompatible API or ABI changes\nMINOR version when adding functionality in a backward-compatible manner\nPATCH version when making backward-compatible bug fixes\nNote that semantic versioning does not extend to serialized objects. To reuse plan files and timing caches, version numbers must match across major, minor, patch, and build versions (with some exceptions for the safety runtime as detailed in the\nNVIDIA DRIVE OS Developer Guide\n). Calibration caches can typically be reused within a major version, but compatibility beyond a specific patch version is not guaranteed.\nDeprecation Policy\n#\nDeprecation informs developers that some APIs and tools are no longer recommended. Beginning with version 8.0, TensorRT has the following deprecation policy:\nDeprecation notices are communicated in the\nRelease Notes\n.\nWhen using C++ API:\nAPI functions are marked with the\nTRT_DEPRECATED_API\nmacro.\nEnums are marked with the\nTRT_DEPRECATED_ENUM\nmacro.\nAll other locations are marked with the\nTRT_DEPRECATED\nmacro.\nClasses, functions, and objects will have a statement documenting when they were deprecated.\nWhen using the Python API, deprecated methods and classes will issue deprecation warnings at runtime if they are used.\nTensorRT provides a 12-month migration period after the deprecation.\nAPIs and tools continue to work during the migration period.\nAfter the migration period ends, APIs and tools are removed in a manner consistent with semantic versioning.\nFor any APIs and tools specifically deprecated in TensorRT 7.x, the 12-month migration period starts from the TensorRT 8.0 GA release date.\nHardware Support Lifetime\n#\nTensorRT 8.5.3 was the last release supporting NVIDIA Kepler (SM 3.x) and NVIDIA Maxwell (SM 5.x) devices. These devices are no longer supported in TensorRT 8.6. NVIDIA Pascal (SM 6.x) devices were deprecated in TensorRT 8.6. TensorRT 10.4 was the last release supporting NVIDIA Volta (SM 7.0) devices. For more information, refer to the\nSupport Matrix\nsection.\nSupport\n#\nSupport, resources, and information about TensorRT can be found online at\nhttps://developer.nvidia.com/tensorrt\n. This includes blogs, samples, and more.\nIn addition, you can access the NVIDIA DevTalk TensorRT forum at\nhttps://devtalk.nvidia.com/default/board/304/tensorrt/\nfor all things related to TensorRT. This forum offers the possibility of finding answers, making connections, and getting involved in discussions with customers, developers, and TensorRT engineers.\nReporting Bugs\n#\nNVIDIA appreciates all types of feedback. If you encounter any problems, follow the instructions in the\nReporting TensorRT Issues\nsection to report the issues.\nOn this page", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://docs.nvidia.com/deeplearning/tensorrt/developer-guide/index.html"}}
{"text": "1. Introduction — NVIDIA CUDA Compiler Driver 13.0 documentation\n»\n1.\nIntroduction\nv13.0 |\nPDF\n|\nArchive\nNVIDIA CUDA Compiler Driver NVCC\nThe documentation for\nnvcc\n, the CUDA compiler driver.\n1.\nIntroduction\n\n1.1.\nOverview\n\n1.1.1.\nCUDA Programming Model\n\nThe CUDA Toolkit targets a class of applications whose control part runs as a process on a general purpose computing device, and which use one or more NVIDIA GPUs as coprocessors for accelerating\nsingle program, multiple data\n(SPMD) parallel jobs. Such jobs are self-contained, in the sense that they can be executed and completed by a batch of GPU threads entirely without intervention by the host process, thereby gaining optimal benefit from the parallel graphics hardware.\nThe GPU code is implemented as a collection of functions in a language that is essentially C++, but with some annotations for distinguishing them from the host code, plus annotations for distinguishing different types of data memory that exists on the GPU. Such functions may have parameters, and they can be called using a syntax that is very similar to regular C function calling, but slightly extended for being able to specify the matrix of GPU threads that must execute the called function. During its life time, the host process may dispatch many parallel GPU tasks.\nFor more information on the CUDA programming model, consult the\nCUDA C++ Programming Guide\n.\n1.1.2.\nCUDA Sources\n\nSource files for CUDA applications consist of a mixture of conventional C++ host code, plus GPU device functions. The CUDA compilation trajectory separates the device functions from the host code, compiles the device functions using the proprietary NVIDIA compilers and assembler, compiles the host code using a C++ host compiler that is available, and afterwards embeds the compiled GPU functions as fatbinary images in the host object file. In the linking stage, specific CUDA runtime libraries are added for supporting remote SPMD procedure calling and for providing explicit GPU manipulation such as allocation of GPU memory buffers and host-GPU data transfer.\n1.1.3.\nPurpose of NVCC\n\nThe compilation trajectory involves several splitting, compilation, preprocessing, and merging steps for each CUDA source file. It is the purpose of\nnvcc\n, the CUDA compiler driver, to hide the intricate details of CUDA compilation from developers. It accepts a range of conventional compiler options, such as for defining macros and include/library paths, and for steering the compilation process. All non-CUDA compilation steps are forwarded to a C++ host compiler that is supported by\nnvcc\n, and\nnvcc\ntranslates its options to appropriate host compiler command line options.\n1.2.\nSupported Host Compilers\n\nA general purpose C++ host compiler is needed by\nnvcc\nin the following situations:\nDuring non-CUDA phases (except the run phase), because these phases will be forwarded by\nnvcc\nto this compiler.\nDuring CUDA phases, for several preprocessing stages and host code compilation (see also\nThe CUDA Compilation Trajectory\n).\nnvcc\nassumes that the host compiler is installed with the standard method designed by the compiler provider. If the host compiler installation is non-standard, the user must make sure that the environment is set appropriately and use relevant\nnvcc\ncompile options.\nThe following documents provide detailed information about supported host compilers:\nNVIDIA CUDA Installation Guide for Linux\nNVIDIA CUDA Installation Guide for Microsoft Windows\nOn all platforms, the default host compiler executable (\ngcc\nand\ng++\non Linux and\ncl.exe\non Windows) found in the current execution search path will be used, unless specified otherwise with appropriate options (see\nfile-and-path-specifications\n).\nNote,\nnvcc\ndoes not support the compilation of file paths that exceed the maximum path length limitations of the host system. To support the compilation of long file paths, please refer to the documentation for your system.\n2.\nCompilation Phases\n\n2.1.\nNVCC Identification Macro\n\nnvcc\npredefines the following macros:\n__NVCC__\nDefined when compiling C/C++/CUDA source files.\n__CUDACC__\nDefined when compiling CUDA source files.\n__CUDACC_RDC__\nDefined when compiling CUDA source files in relocatable device code mode (see\nNVCC Options for Separate Compilation\n).\n__CUDACC_EWP__\nDefined when compiling CUDA source files in extensible whole program mode (see\nOptions for Specifying Behavior of Compiler/Linker\n).\n__CUDACC_DEBUG__\nDefined when compiling CUDA source files in the device-debug mode (see\nOptions for Specifying Behavior of Compiler/Linker\n).\n__CUDACC_RELAXED_CONSTEXPR__\nDefined when the\n--expt-relaxed-constexpr\nflag is specified on the command line. Refer to the\nCUDA C++ Programming Guide\nfor more details.\n__CUDACC_EXTENDED_LAMBDA__\nDefined when the\n--expt-extended-lambda\nor\n--extended-lambda\nflag is specified on the command line. Refer to the\nCUDA C++ Programming Guide\nfor more details.\n__CUDACC_VER_MAJOR__\nDefined with the major version number of\nnvcc\n.\n__CUDACC_VER_MINOR__\nDefined with the minor version number of\nnvcc\n.\n__CUDACC_VER_BUILD__\nDefined with the build version number of\nnvcc\n.\n__NVCC_DIAG_PRAGMA_SUPPORT__\nDefined when the CUDA frontend compiler supports diagnostic control with the\nnv_diag_suppress\n,\nnv_diag_error\n,\nnv_diag_warning\n,\nnv_diag_default\n,\nnv_diag_once\n, and\nnv_diagnostic\npragmas.\n__CUDACC_DEVICE_ATOMIC_BUILTINS__\nDefined when the CUDA frontend compiler supports device atomic compiler builtins. Refer to the\nCUDA C++ Programming Guide\nfor more details.\n2.2.\nNVCC Phases\n\nA compilation phase is a logical translation step that can be selected by command line options to\nnvcc\n. A single compilation phase can still be broken up by\nnvcc\ninto smaller steps, but these smaller steps are just implementations of the phase: they depend on seemingly arbitrary capabilities of the internal tools that\nnvcc\nuses, and all of these internals may change with a new release of the CUDA Toolkit. Hence, only compilation phases are stable across releases, and although\nnvcc\nprovides options to display the compilation steps that it executes, these are for debugging purposes only and must not be copied and used in build scripts.\nnvcc\nphases are selected by a combination of command line options and input file name suffixes, and the execution of these phases may be modified by other command line options. In phase selection, the input file suffix defines the phase input, while the command line option defines the required output of the phase.\nThe following paragraphs list the recognized file name suffixes and the supported compilation phases. A full explanation of the\nnvcc\ncommand line options can be found in\nNVCC Command Options\n.\n2.3.\nSupported Input File Suffixes\n\nThe following table defines how\nnvcc\ninterprets its input files:\nInput File Suffix\nDescription\n.cu\nCUDA source file, containing host code and device functions\n.c\nC source file\n.cc\n,\n.cxx\n,\n.cpp\nC++ source file\n.ptx\nPTX intermediate assembly file (see\nFigure 1\n)\n.cubin\nCUDA device code binary file (CUBIN) for a single GPU architecture (see\nFigure 1\n)\n.fatbin\nCUDA fat binary file that may contain multiple PTX and CUBIN files (see\nFigure 1\n)\n.o\n,\n.obj\nObject file\n.a\n,\n.lib\nLibrary file\n.res\nResource file\n.so\nShared object file\nNote that\nnvcc\ndoes not make any distinction between object, library or resource files. It just passes files of these types to the linker when the linking phase is executed.\n2.4.\nSupported Phases\n\nThe following table specifies the supported compilation phases, plus the option to\nnvcc\nthat enables the execution of each phase. It also lists the default name of the output file generated by each phase, which takes effect when no explicit output file name is specified using the option\n--output-file\n:\nPhase\nnvcc\nOption\nDefault Output File Name\nLong Name\nShort Name\nCUDA compilation to C/C++ source file\n--cuda\n-cuda\n.cpp.ii\nappended to source file name, as in\nx.cu.cpp.ii\n. This output file can be compiled by the host compiler that was used by\nnvcc\nto preprocess the\n.cu\nfile.\nC/C++ preprocessing\n--preprocess\n-E\n<\nresult on standard output\n>\nC/C++ compilation to object file\n--compile\n-c\nSource file name with suffix replaced by\no\non Linux or\nobj\non Windows\nCubin generation from CUDA source files\n--cubin\n-cubin\nSource file name with suffix replaced by\ncubin\nCubin generation from PTX intermediate files.\n--cubin\n-cubin\nSource file name with suffix replaced by\ncubin\nPTX generation from CUDA source files\n--ptx\n-ptx\nSource file name with suffix replaced by\nptx\nFatbinary generation from source, PTX or cubin files\n--fatbin\n-fatbin\nSource file name with suffix replaced by\nfatbin\nLinking relocatable device code.\n--device-link\n-dlink\na_dlink.obj\non Windows or\na_dlink.o\non other platforms\nCubin generation from linked relocatable device code.\n--device-link\n--cubin\n-dlink\n-cubin\na_dlink.cubin\nFatbinary generation from linked relocatable device code\n--device-link\n--fatbin\n-dlink\n-fatbin\na_dlink.fatbin\nLinking an executable\n<\nno phase option\n>\na.exe\non Windows or\na.out\non other platforms\nConstructing an object file archive, or library\n--lib\n-lib\na.lib\non Windows or\na.a\non other platforms\nmake\ndependency generation\n--generate-dependencies\n-M\n<\nresult on standard output\n>\nmake\ndependency generation without headers in system paths.\n--generate-nonsystem-dependencies\n-MM\n<\nresult on standard output\n>\nCompile CUDA source to OptiX IR output.\n--optix-ir\n-optix-ir\nSource file name with suffix replaced by\noptixir\nCompile CUDA source to LTO IR output.\n--ltoir\n-ltoir\nSource file name with suffix replaced by\nltoir\nRunning an executable\n--run\n-run\nNotes:\nThe last phase in this list is more of a convenience phase. It allows running the compiled and linked executable without having to explicitly set the library path to the CUDA dynamic libraries.\nUnless a phase option is specified,\nnvcc\nwill compile and link all its input files.\n3.\nThe CUDA Compilation Trajectory\n\nCUDA compilation works as follows: the input program is preprocessed for device compilation and is compiled to CUDA binary (\ncubin\n) and/or PTX intermediate code, which are placed in a fatbinary. The input program is preprocessed once again for host compilation and is synthesized to embed the fatbinary and transform CUDA specific C++ extensions into standard C++ constructs. Then the C++ host compiler compiles the synthesized host code with the embedded fatbinary into a host object. The exact steps that are followed to achieve this are displayed in\nFigure 1\n.\nThe embedded fatbinary is inspected by the CUDA runtime system whenever the device code is launched by the host program to obtain an appropriate fatbinary image for the current GPU.\nCUDA programs are compiled in the whole program compilation mode by default, i.e., the device code cannot reference an entity from a separate file. In the whole program compilation mode, device link steps have no effect. For more information on the separate compilation and the whole program compilation, refer to\nUsing Separate Compilation in CUDA\n.\nCUDA Compilation Trajectory\n\n4.\nNVCC Command Options\n\n4.1.\nCommand Option Types and Notation\n\nEach\nnvcc\noption has a long name and a short name, which are interchangeable with each other. These two variants are distinguished by the number of hyphens that must precede the option name: long names must be preceded by two hyphens, while short names must be preceded by a single hyphen. For example,\n-I\nis the short name of\n--include-path\n. Long options are intended for use in build scripts, where the size of the option is less important than the descriptive value. In contrast, short options are intended for interactive use.\nnvcc\nrecognizes three types of command options: boolean options, single value options, and list options.\nBoolean options do not have an argument; they are either specified on the command line or not. Single value options must be specified at most once, but list options may be repeated. Examples of each of these option types are, respectively:\n--verbose\n(switch to verbose mode),\n--output-file\n(specify output file), and\n--include-path\n(specify include path).\nSingle value options and list options must have arguments, which must follow the name of the option itself by either one of more spaces or an equals character. When a one-character short name such as\n-I\n,\n-l\n, and\n-L\nis used, the value of the option may also immediately follow the option itself without being seperated by spaces or an equal character. The individual values of list options may be separated by commas in a single instance of the option, or the option may be repeated, or any combination of these two cases.\nHence, for the two sample options mentioned above that may take values, the following notations are legal:\n-o file\n-o=file\n-Idir1,dir2 -I=dir3 -I dir4,dir5\nUnless otherwise specified, long option names are used throughout this document. However, short names can be used instead of long names for the same effect.\n4.2.\nCommand Option Description\n\nThis section presents tables of\nnvcc\noptions. The option type in the tables can be recognized as follows: Boolean options do not have arguments specified in the first column, while the other two types do. List options can be recognized by the repeat indicator\n,...\nat the end of the argument.\nLong options are described in the first column of the options table, and short options occupy the second column.\n4.2.1.\nFile and Path Specifications\n\n4.2.1.1.\n--output-file\nfile\n(\n-o\n)\n\nSpecify name and location of the output file.\n4.2.1.2.\n--objdir-as-tempdir\n(\n-objtemp\n)\n\nCreate all intermediate files in the same directory as the object file. These intermediate files are deleted when the compilation is finished. This option will take effect only if -c, -dc or -dw is also used. Using this option will ensure that the intermediate file name that is embedded in the object file will not change in multiple compiles of the same file. However, this is not guaranteed if the input is stdin. If the same file is compiled with two different options, ex., ‘nvcc -c t.cu’ and ‘nvcc -c -ptx t.cu’, then the files should be compiled in different directories. Compiling them in the same directory can either cause the compilation to fail or produce incorrect results.\n4.2.1.3.\n--pre-include\nfile,...\n(\n-include\n)\n\nSpecify header files that must be pre-included during preprocessing.\n4.2.1.4.\n--library\nlibrary,...\n(\n-l\n)\n\nSpecify libraries to be used in the linking stage without the library file extension.\nThe libraries are searched for on the library search paths that have been specified using option\n--library-path\n(see\nLibraries\n).\n4.2.1.5.\n--define-macro\ndef,...\n(\n-D\n)\n\nDefine macros to be used during preprocessing.\ndef\ncan be either\nname\nor\nname\n=\ndefinition\n.\nname\n-  Predefine\nname\nas a macro.\nname\n=\ndefinition\n-  The contents of\ndefinition\nare tokenized and preprocessed as if they appear during translation phase three in a\n#define\ndirective. The definition will be truncated by embedded new line characters.\n4.2.1.6.\n--undefine-macro\ndef,...\n(\n-U\n)\n\nUndefine an existing macro during preprocessing or compilation.\n4.2.1.7.\n--include-path\npath,...\n(\n-I\n)\n\nSpecify include search paths.\n4.2.1.8.\n--system-include\npath,...\n(\n-isystem\n)\n\nSpecify system include search paths.\n4.2.1.9.\n--library-path\npath,...\n(\n-L\n)\n\nSpecify library search paths (see\nLibraries\n).\n4.2.1.10.\n--output-directory\ndirectory\n(\n-odir\n)\n\nSpecify the directory of the output file.\nThis option is intended for letting the dependency generation step (see\n--generate-dependencies\n) generate a rule that defines the target object file in the proper directory.\n4.2.1.11.\n--dependency-output\nfile\n(\n-MF\n)\n\nSpecify the dependency output file.\nThis option specifies the output file for the dependency generation step (see\n--generate-dependencies\n). The option\n--generate-dependencies\nor\n--generate-nonystem-dependencies\nmust be specified if a dependency output file is set.\n4.2.1.12.\n--generate-dependency-targets\n(\n-MP\n)\n\nAdd an empty target for each dependency.\nThis option adds phony targets to the dependency generation step (see\n--generate-dependencies\n) intended to avoid makefile errors if old dependencies are deleted. The input files are not emitted as phony targets.\n4.2.1.13.\n--compiler-bindir\ndirectory\n(\n-ccbin\n)\n\nSpecify the directory in which the default host compiler executable resides.\nThe host compiler executable name can be also specified to ensure that the correct host compiler is selected. In addition, driver prefix options (\n--input-drive-prefix\n,\n--dependency-drive-prefix\n, or\n--drive-prefix\n) may need to be specified, if\nnvcc\nis executed in a Cygwin shell or a MinGW shell on Windows.\n4.2.1.14.\n--allow-unsupported-compiler\n(\n-allow-unsupported-compiler\n)\n\nDisable nvcc check for supported host compiler versions.\nUsing an unsupported host compiler may cause compilation failure or incorrect run time execution. Use at your own risk. This option has no effect on MacOS.\n4.2.1.15.\n--archiver-binary\nexecutable\n(\n-arbin\n)\n\nSpecify the path of the archiver tool used create static library with\n--lib\n.\n4.2.1.16.\n--cudart\n{\nnone\n|\nshared\n|\nstatic\n} (\n-cudart\n)\n\nSpecify the type of CUDA runtime library to be used: no CUDA runtime library, shared/dynamic CUDA runtime library, or static CUDA runtime library.\nAllowed Values\nnone\nshared\nstatic\nDefault\nThe static CUDA runtime library is used by default.\n4.2.1.17.\n--cudadevrt\n{\nnone\n|\nstatic\n} (\n-cudadevrt\n)\n\nSpecify the type of CUDA device runtime library to be used: no CUDA device runtime library, or static CUDA device runtime library.\nAllowed Values\nnone\nstatic\nDefault\nThe static CUDA device runtime library is used by default.\n4.2.1.18.\n--libdevice-directory\ndirectory\n(\n-ldir\n)\n\nSpecify the directory that contains the libdevice library files.\nLibdevice library files are located in the\nnvvm/libdevice\ndirectory in the CUDA Toolkit.\n4.2.1.19.\n--target-directory\nstring\n(\n-target-dir\n)\n\nSpecify the subfolder name in the targets directory where the default include and library paths are located.\n4.2.2.\nOptions for Specifying the Compilation Phase\n\nOptions of this category specify up to which stage the input files must be compiled.\n4.2.2.1.\n--link\n(\n-link\n)\n\nSpecify the default behavior: compile and link all input files.\nDefault Output File Name\na.exe\non Windows or\na.out\non other platforms is used as the default output file name.\n4.2.2.2.\n--lib\n(\n-lib\n)\n\nCompile all input files into object files, if necessary, and add the results to the specified library output file.\nDefault Output File Name\na.lib\non Windows or\na.a\non other platforms is used as the default output file name.\n4.2.2.3.\n--device-link\n(\n-dlink\n)\n\nLink object files with relocatable device code and\n.ptx\n,\n.cubin\n, and\n.fatbin\nfiles into an object file with executable device code, which can be passed to the host linker.\nDefault Output File Name\na_dlink.obj\non Windows or\na_dlink.o\non other platforms is used as the default output file name. When this option is used in conjunction with\n--fatbin\n,\na_dlink.fatbin\nis used as the default output file name. When this option is used in conjunction with\n--cubin\n,\na_dlink.cubin\nis used as the default output file name.\n4.2.2.4.\n--device-c\n(\n-dc\n)\n\nCompile each\n.c\n,\n.cc\n,\n.cpp\n,\n.cxx\n, and\n.cu\ninput file into an object file that contains relocatable device code.\nIt is equivalent to\n--relocatable-device-code=true\n--compile\n.\nDefault Output File Name\nThe source file name extension is replaced by\n.obj\non Windows and\n.o\non other platforms to create the default output file name. For example, the default output file name for\nx.cu\nis\nx.obj\non Windows and\nx.o\non other platforms.\n4.2.2.5.\n--device-w\n(\n-dw\n)\n\nCompile each\n.c\n,\n.cc\n,\n.cpp\n,\n.cxx\n, and\n.cu\ninput file into an object file that contains executable device code.\nIt is equivalent to\n--relocatable-device-code=false\n--compile\n.\nDefault Output File Name\nThe source file name extension is replaced by\n.obj\non Windows and\n.o\non other platforms to create the default output file name. For example, the default output file name for\nx.cu\nis\nx.obj\non Windows and\nx.o\non other platforms.\n4.2.2.6.\n--cuda\n(\n-cuda\n)\n\nCompile each\n.cu\ninput file to a\n.cu.cpp.ii\nfile.\nDefault Output File Name\n.cu.cpp.ii\nis appended to the basename of the source file name to create the default output file name. For example, the default output file name for\nx.cu\nis\nx.cu.cpp.ii\n.\n4.2.2.7.\n--compile\n(\n-c\n)\n\nCompile each\n.c\n,\n.cc\n,\n.cpp\n,\n.cxx\n, and\n.cu\ninput file into an object file.\nDefault Output File Name\nThe source file name extension is replaced by\n.obj\non Windows and\n.o\non other platforms to create the default output file name. For example, the default output file name for\nx.cu\nis\nx.obj\non Windows and\nx.o\non other platforms.\n4.2.2.8.\n--fatbin\n(\n-fatbin\n)\n\nCompile all\n.cu\n,\n.ptx\n, and\n.cubin\ninput files to device-only\n.fatbin\nfiles.\nnvcc\ndiscards the host code for each\n.cu\ninput file with this option.\nDefault Output File Name\nThe source file name extension is replaced by\n.fatbin\nto create the default output file name. For example, the default output file name for\nx.cu\nis\nx.fatbin\n.\n4.2.2.9.\n--cubin\n(\n-cubin\n)\n\nCompile all\n.cu\nand\n.ptx\ninput files to device-only\n.cubin\nfiles.\nnvcc\ndiscards the host code for each\n.cu\ninput file with this option.\nDefault Output File Name\nThe source file name extension is replaced by\n.cubin\nto create the default output file name. For example, the default output file name for\nx.cu\nis\nx.cubin\n.\n4.2.2.10.\n--ptx\n(\n-ptx\n)\n\nCompile all\n.cu\ninput files to device-only\n.ptx\nfiles.\nnvcc\ndiscards the host code for each\n.cu\ninput file with this option.\nDefault Output File Name\nThe source file name extension is replaced by\n.ptx\nto create the default output file name. For example, the default output file name for\nx.cu\nis\nx.ptx\n.\n4.2.2.11.\n--preprocess\n(\n-E\n)\n\nPreprocess all\n.c\n,\n.cc\n,\n.cpp\n,\n.cxx\n, and\n.cu\ninput files.\nDefault Output File Name\nThe output is generated in\nstdout\nby default.\n4.2.2.12.\n--generate-dependencies\n(\n-M\n)\n\nGenerate a dependency file that can be included in a\nMakefile\nfor the\n.c\n,\n.cc\n,\n.cpp\n,\n.cxx\n, and\n.cu\ninput file.\nnvcc\nuses a fixed prefix to identify dependencies in the preprocessed file ( ‘\n#line\n1\n’ on Linux and ‘\n#\n1\n’ on Windows). The files mentioned in source location directives starting with this prefix will be included in the dependency list.\nDefault Output File Name\nThe output is generated in\nstdout\nby default.\n4.2.2.13.\n--generate-nonsystem-dependencies\n(\n-MM\n)\n\nSame as\n--generate-dependencies\nbut skip header files found in system directories (Linux only).\nDefault Output File Name\nThe output is generated in\nstdout\nby default.\n4.2.2.14.\n--generate-dependencies-with-compile\n(\n-MD\n)\n\nGenerate a dependency file and compile the input file. The dependency file can be included in a\nMakefile\nfor the\n.c\n,\n.cc\n,\n.cpp\n,\n.cxx\n, and\n.cu\ninput file.\nThis option cannot be specified together with\n-E\n. The dependency file name is computed as follows:\nIf\n-MF\nis specified, then the specified file is used as the dependency file name.\nIf\n-o\nis specified, the dependency file name is computed from the specified file name by replacing the suffix with ‘.d’.\nOtherwise, the dependency file name is computed by replacing the input file names’s suffix with ‘.d’.\nIf the dependency file name is computed based on either\n-MF\nor\n-o\n, then multiple input files are not supported.\n4.2.2.15.\n--generate-nonsystem-dependencies-with-compile\n(\n-MMD\n)\n\nSame as\n--generate-dependencies-with-compile\nbut skip header files found in system directories (Linux only).\n4.2.2.16.\n--optix-ir\n(\n-optix-ir\n)\n\nCompile CUDA source to OptiX IR (.optixir) output. The OptiX IR is only intended for consumption by OptiX through appropriate APIs. This feature is not supported with link-time-optimization (\n-dlto\n), the lto_NN -arch target, or with\n-gencode\n.\nDefault Output File Name\nThe source file name extension is replaced by\n.optixir\nto create the default output file name. For example, the default output file name for\nx.cu\nis\nx.optixir\n.\n4.2.2.17.\n--ltoir\n(\n-ltoir\n)\n\nCompile CUDA source to LTO IR (.ltoir) output. This feature is only supported with link-time-optimization (\n-dlto\n) or the lto_NN -arch target.\nDefault Output File Name\nThe source file name extension is replaced by\n.ltoir\nto create the default output file name. For example, the default output file name for\nx.cu\nis\nx.ltoir\n.\n4.2.2.18.\n--run\n(\n-run\n)\n\nCompile and link all input files into an executable, and executes it.\nWhen the input is a single executable, it is executed without any compilation or linking. This step is intended for developers who do not want to be bothered with setting the necessary environment variables; these are set temporarily by\nnvcc\n.\n4.2.3.\nOptions for Specifying Behavior of Compiler/Linker\n\n4.2.3.1.\n--profile\n(\n-pg\n)\n\nInstrument generated code/executable for use by\ngprof\n.\n4.2.3.2.\n--debug\n(\n-g\n)\n\nGenerate debug information for host code.\n4.2.3.3.\n--device-debug\n(\n-G\n)\n\nGenerate debug information for device code.\nIf\n--dopt\nis not specified, then this option turns off all optimizations on device code. It is not intended for profiling; use\n--generate-line-info\ninstead for profiling.\n4.2.3.4.\n--extensible-whole-program\n(\n-ewp\n)\n\nGenerate extensible whole program device code, which allows some calls to not be resolved until linking with libcudadevrt.\n4.2.3.5.\n--no-compress\n(\n-no-compress\n)\n\nDo not compress device code in fatbinary.\n4.2.3.6.\n--compress-mode\n{\ndefault\n|\nsize\n|\nspeed\n|\nbalance\n|\nnone\n} (\n-compress-mode\n)\n\nChoose the device code compression behavior in fatbinary.\nThis option is not compatible with drivers released before CUDA Toolkit’s 12.4 Release.\nAllowed Values\ndefault\nUses the default compression mode, as if this weren’t specified. The behavior of this mode can change from version to version. It is currently equivalent to\nspeed\n.\nsize\nUses a compression mode more focused on reduced binary size, at the cost of compression and decompression time.\nspeed\nUses a compression mode more focused on reduced decompression time, at the cost of less reduction in final binary size.\nbalance\nUses a compression mode that balances binary size with compression and decompression time.\nnone\nDoes not perform compression. Equivalent to\n--no-compress\n.\nDefault Value\ndefault\nis used as the default mode.\n4.2.3.7.\n--relocatable-ptx\n(\n-reloc-ptx\n)\n\nInsert PTX from relocatable fatbins within input objects when producing final fatbin.\n4.2.3.8.\n--generate-line-info\n(\n-lineinfo\n)\n\nGenerate line-number information for device code.\n4.2.3.9.\n--optimization-info\nkind,...\n(\n-opt-info\n)\n\nProvide optimization reports for the specified kind of optimization.\nThe following tags are supported:\ninline\nEmit remarks related to function inlining. Inlining pass may be invoked multiple times by the compiler and a function not inlined in an earlier pass may be inlined in a subsequent pass.\n4.2.3.10.\n--optimize\nlevel\n(\n-O\n)\n\nSpecify optimization level for host code.\n4.2.3.11.\n--Ofast-compile\nlevel\n(\n-Ofc\n)\n\nSpecify the fast-compile level for device code, which controls the tradeoff between compilation speed and runtime performance by disabling certain optimizations at varying levels.\nAllowed Values\nmax\n: Focus only on the fastest compilation speed, disabling many optimizations.\nmid\n: Balance compile time and runtime, disabling expensive optimizations.\nmin\n: More minimal impact on both compile time and runtime, minimizing some expensive optimizations.\n0\n: Disable fast-compile.\nDefault Value\nThe option is disabled by default.\n4.2.3.12.\n--dopt\nkind\n(\n-dopt\n)\n\nEnable device code optimization. When specified along with\n-G\n, enables limited debug information generation for optimized device code (currently, only line number information). When\n-G\nis not specified,\n-dopt=on\nis implicit.\nAllowed Values\non\n: enable device code optimization.\n4.2.3.13.\n--dlink-time-opt\n(\n-dlto\n)\n\nPerform link-time optimization of device code. The option ‘-lto’ is also an alias to ‘-dlto’. Link-time optimization must be specified at both compile and link time; at compile time it stores high-level intermediate code, then at link time it links together and optimizes the intermediate code. If that intermediate is not found at link time then nothing happens. Intermediate code is also stored at compile time with the\n--gpu-code='lto_NN'\ntarget. The options\n-dlto\n-arch=sm_NN\nwill add a lto_NN target; if you want to only add a lto_NN target and not the compute_NN that\n-arch=sm_NN\nusually generates, use\n-arch=lto_NN\n.\n4.2.3.14.\n--gen-opt-lto\n(\n-gen-opt-lto\n)\n\nRun the optimizer passes before generating the LTO IR.\n4.2.3.15.\n--split-compile\nnumber\n(\n-split-compile\n)\n\nPerform compiler optimizations in parallel.\nSplit compilation attempts to reduce compile time by enabling the compiler to run certain optimization passes concurrently. It does this by splitting the device code into smaller translation units, each containing one or more device functions, and running optimization passes on each unit concurrently across multiple threads. It will then link back the split units prior to code generation.\nThe option accepts a numerical value that specifies the maximum number of threads the compiler can use. One can also allow the compiler to use the maximum threads available on the system by setting\n--split-compile=0\n. Setting\n--split-compile=1\nwill cause this option to be ignored.\nThis option can work in conjunction with device Link Time Optimization (\n-dlto\n) as well as\n--threads\n.\n4.2.3.16.\n--split-compile-extended\nnumber\n(\n-split-compile-extended\n)\n\nA more aggressive form of\n-split-compile\n. Available in LTO mode only.\nExtended split compilation attempts to reduce compile time even further by extending concurrent compilation through to the back-end. This agressive form of split compilation can potentially impact performance of the compiled binary.\nThe option accepts a numerical value that specifies the maximum number of threads the compiler can use. One can also allow the compiler to use the maximum threads available on the system by setting\n--split-compile-extended=0\n. Setting\n--split-compile-extended=1\nwill cause this option to be ignored.\nThis option is only applicable with device Link Time Optimization (\n-dlto\n) and can work in conjunction with\n--threads\n.\n4.2.3.17.\n--jobserver\n(\n-jobserver\n)\n\nWhen using\n-split-compile\nor\n--threads\ninside of a build controlled by GNU Make, require that job slots are acquired Make’s jobserver for each of the threads used, helping prevent oversubscription.\nThis option does not restrict\n-split-compile-extended\n(the number of threads created by it will not be controlled).\nThis option only works when Make is called with\n-j\nset to a numerical value greater than 1, as\n-j\n(without a number) causes Make to skip making the jobserver and\n-j1\ndisables all parallelism.\nThis requires GNU Make 4.3 or newer. For versions of Make before 4.4, or if the\n--jobserver-style=pipe\nis manually specified to Make, each call to NVCC must be considered a submake by make (by prepending a\n+\nto each line where NVCC is called) in order to provide it access to Make’s jobserver.\nUsing this option with an unsupported version of Make, or without the correct\n-j\nvalue may lead to undefined behavior.\nWe do not implement any signal handling and only minimal error handling for this feature, which can cause resources to go unused if NVCC crashes. However, it should not cause a deadlock even if an error occurs, as the job slot used by NVCC itself will always be reclaimed.\nNote: This flag is only supported on Linux.\n4.2.3.18.\n--ftemplate-backtrace-limit\nlimit\n(\n-ftemplate-backtrace-limit\n)\n\nSet the maximum number of template instantiation notes for a single warning or error to limit.\nA value of\n0\nis allowed, and indicates that no limit should be enforced. This value is also passed to the host compiler if it provides an equivalent flag.\n4.2.3.19.\n--ftemplate-depth\nlimit\n(\n-ftemplate-depth\n)\n\nSet the maximum instantiation depth for template classes to limit.\nThis value is also passed to the host compiler if it provides an equivalent flag.\n4.2.3.20.\n--no-exceptions\n(\n-noeh\n)\n\nDisable exception handling for host code.\nDisable exception handling for host code, by passing “-EHs-c-” (for cl.exe) and “–fno-exceptions” (for other host compilers) during host compiler invocation. These flags are added to the host compiler invocation before any flags passed directly to the host compiler with “-Xcompiler”\nDefault (on Windows)\nOn Windows,\nnvcc\npasses /EHsc to the host compiler by default.\nExample (on Windows)\nnvcc\n--no-exceptions\n-Xcompiler\n/EHa\nx.cu\n4.2.3.21.\n--shared\n(\n-shared\n)\n\nGenerate a shared library during linking.\nUse option\n--linker-options\nwhen other linker options are required for more control.\n4.2.3.22.\n--x\n{\nc\n|\nc++\n|\ncu\n} (\n-x\n)\n\nExplicitly specify the language for the input files, rather than letting the compiler choose a default based on the file name suffix.\nAllowed Values\nc\nc++\ncu\nDefault\nThe language of the source code is determined based on the file name suffix.\n4.2.3.23.\n--std\n{\nc++03\n|\nc++11\n|\nc++14\n|\nc++17\n|\nc++20\n} (\n-std\n)\n\nSelect a particular C++ dialect.\nAllowed Values\nc++03\nc++11\nc++14\nc++17\nc++20\nDefault\nThe default C++ dialect depends on the host compiler.\nnvcc\nmatches the default C++ dialect that the host compiler uses.\n4.2.3.24.\n--no-host-device-initializer-list\n(\n-nohdinitlist\n)\n\nDo not consider member functions of\nstd::initializer_list\nas\n__host__\n__device__\nfunctions implicitly.\n4.2.3.25.\n--expt-relaxed-constexpr\n(\n-expt-relaxed-constexpr\n)\n\nExperimental flag\n: Allow host code to invoke ``__device__ constexpr`` functions, and device code to invoke ``__host__ constexpr`` functions.\nNote that the behavior of this flag may change in future compiler releases.\n4.2.3.26.\n--extended-lambda\n(\n-extended-lambda\n)\n\nAllow\n__host__\n,\n__device__\nannotations in lambda declarations.\n4.2.3.27.\n--expt-extended-lambda\n(\n-expt-extended-lambda\n)\n\nAlias for\n--extended-lambda\n.\n4.2.3.28.\n--machine\n{\n64\n} (\n-m\n)\n\nSpecify 64-bit architecture.\nAllowed Values\n64\nDefault\nThis option is set based on the host platform on which\nnvcc\nis executed.\n4.2.3.29.\n--m64\n(\n-m64\n)\n\nAlias for\n--machine=64\n4.2.3.30.\n--host-linker-script\n{\nuse-lcs\n|\ngen-lcs\n} (\n-hls\n)\n\nUse the host linker script (GNU/Linux only) to enable support for certain CUDA specific requirements, while building executable files or shared libraries.\nAllowed Values\nuse-lcs\nPrepares a host linker script and enables host linker to support relocatable device object files that are larger in size, that would otherwise, in certain cases, cause the host linker to fail with relocation truncation error.\ngen-lcs\nGenerates a host linker script that can be passed to host linker manually, in the case where host linker is invoked separately outside of nvcc. This option can be combined with\n-shared\nor\n-r\noption to generate linker scripts that can be used while generating host shared libraries or host relocatable links respectively.\nThe file generated using this options must be provided as the last input file to the host linker.\nThe output is generated to stdout by default. Use the option\n-o\nfilename to specify the output filename.\nA linker script may already be in used and passed to the host linker using the host linker option\n--script\n(or\n-T\n), then the generated host linker script must augment the existing linker script. In such cases, the option\n-aug-hls\nmust be used to generate linker script that contains only the augmentation parts. Otherwise, the host linker behaviour is undefined.\nA host linker option, such as\n-z\nwith a non-default argument, that can modify the default linker script internally, is incompatible with this option and the behavior of any such usage is undefined.\nDefault Value\nuse-lcs\nis used as the default type.\n4.2.3.31.\n--augment-host-linker-script\n(\n-aug-hls\n)\n\nEnables generation of host linker script that augments an existing host linker script (GNU/Linux only). See option\n--host-linker-script\nfor more details.\n4.2.3.32.\n--host-relocatable-link\n(\n-r\n)\n\nWhen used in combination with\n-hls=gen-lcs\n, controls the behaviour of\n-hls=gen-lcs\nand sets it to generate host linker script that can be used in host relocatable link (\nld\n-r\nlinkage). See option\n-hls=gen-lcs\nfor more information.\nThis option currently is effective only when used with\n-hls=gen-lcs\n; in all other cases, this option is ignored currently.\n4.2.3.33.\n--frandom-seed\n(\n-frandom-seed\n)\n\nThe user specified random seed will be used to replace random numbers used in generating symbol names and variable names. The option can be used to generate deterministicly identical ptx and object files.\nIf the input value is a valid number (decimal, octal, or hex), it will be used directly as the random seed.\nOtherwise, the CRC value of the passed string will be used instead.\nNVCC will also pass the option, as well as the user specified value to host compilers, if the host compiler is either GCC or Clang, since they support -frandom-seed option as well. Users are respoonsible for assigning different seed to different files.\n4.2.4.\nOptions for Passing Specific Phase Options\n\nThese flags allow for passing specific options directly to the internal compilation tools that\nnvcc\nencapsulates, without burdening\nnvcc\nwith too-detailed knowledge on these tools.\n4.2.4.1.\n--compiler-options\noptions,...\n(\n-Xcompiler\n)\n\nSpecify options directly to the compiler/preprocessor.\n4.2.4.2.\n--linker-options\noptions,...\n(\n-Xlinker\n)\n\nSpecify options directly to the host linker.\n4.2.4.3.\n--archive-options\noptions,...\n(\n-Xarchive\n)\n\nSpecify options directly to the library manager.\n4.2.4.4.\n--ptxas-options\noptions,...\n(\n-Xptxas\n)\n\nSpecify options directly to\nptxas\n, the PTX optimizing assembler.\n4.2.4.5.\n--nvlink-options\noptions,...\n(\n-Xnvlink\n)\n\nSpecify options directly to\nnvlink\n, the device linker.\n4.2.5.\nOptions for Guiding the Compiler Driver\n\n4.2.5.1.\n--static-global-template-stub\n{\ntrue\n|\nfalse\n} (\n-static-global-template-stub\n)\n\nIn whole-program compilation mode (\n-rdc=false\n), force\nstatic\nlinkage for host side stub functions generated for\n__global__\nfunction templates.\nA\n__global__\nfunction represents the entry point for GPU code execution, and is typically referenced from host code. In whole program compilation mode (\nnvcc\ndefault), the device code in each translation unit forms a self-contained device program. In the code sent to the host compiler, the CUDA frontend compiler will replace the contents of the body of the original\n__global__\nfunction or function template with calls to the CUDA runtime to launch the kernel (these are referred to as ‘stub’ functions below).\nWhen this flag is\nfalse\n, the template stub function will have weak linkage. This causes a problem if two different translation units\na.cu\nand\nb.cu\nhave the same instatiation for a\n__global__\ntemplate\nG\n.\nFor example:\n//common.h\ntemplate\n<\ntypename\nT\n>\n__global__\nvoid\nG\n()\n{\nqqq\n=\n4\n;\n}\n//a.cu\nstatic\n__device__\nint\nqqq\n;\n#include\n\"common.h\"\nint\nmain\n()\n{\nG\n<\nint\n><<<\n1\n,\n1\n>>>\n();\n}\n//b.cu\nstatic\n__device__\nint\nqqq\n;\n#include\n\"common.h\"\nint\nmain\n()\n{\nG\n<\nint\n><<<\n1\n,\n1\n>>>\n();\n}\nWhen\na.cu\nand\nb.cu\nare compiled in nvcc whole program mode, the device programs generated for\na.cu\nand\nb.cu\nare separate programs, but the host linker will encounter multiple weak definitions for\nG<int>\nstub instantiation, and choose only one in the linked host program. As a result, launching\nG<int>\nfrom\na.cu\nor\nb.cu\nwill incorrectly launch the device program corresponding to one of\na.cu\nor\nb.cu\n; while the correct expected behavior is that\nG<int>\nfrom\na.cu\nlaunches the device program generated for\na.cu\n, and\nG<int>\nfrom\nb.cu\nlaunches the device program generated for\nb.cu\n, respectively.\nWhen the flag is\ntrue\n, the CUDA frontend compiler will make all the stub functions\nstatic\nin the generated host code. This solves the problem above, since\nG<int>\nin\na.cu\nand\nb.cu\nnow refer to distinct symbols in the host object code, and the host linker will not combine these symbols.\nNotes\nThis option is ignored unless the program is being compiled in whole program compilation mode (\n-rdc=false\n).\nTurning on this flag may break existing code in some corner cases (only in whole program compilation mode):\nIf a\n__global__\nfunction template is declared as a friend, and the friend declaration is the first declaration of the entity.\nIf a\n__global__\nfunction template is referenced, but not defined in the current translation unit.\nDefault\ntrue\n4.2.5.2.\n--device-entity-has-hidden-visibility\n{\ntrue\n|\nfalse\n} (\n-device-entity-has-hidden-visibility\n)\n\nThis flag applies to\n__global__\nfunctions and function templates, and to\n__constant__\n,\n__device__\nand\n__managed__\nvariables and variable templates, when using host compilers that support the\nvisibility\nattribute (e.g.\ngcc\n,\nclang\n).\nWhen this flag is enabled, the CUDA frontend compiler will implicitly add\n__attribute__((visibility(\"hidden\")))\nto every declaration of these entities, unless the entity has internal linkage or the entity has non-default visibility e.g., due to\nattribute((visibility(\"default\")))\non an enclosing namespace.\nIf building a shared library, entities with\nhidden\nvisibility cannot be referenced from outside the shared library.  This behavior is desired for\n__global__\nfunctions/template instantiations and for\n__constant__/__device__/__managed__\nvariables and template instantiations, because the functionality of these entities depends on the CUDA Runtime (\nCUDART\n) library. If such entities are referenced from outside the shared library, then subtle errors can occur if a different\nCUDART\nis linked in to the shared library versus the user of the shared library. By forcing\nhidden\nvisibility for such entities, these problems are avoided (the program will fail to build).\nPlease also see related flag\n-static-global-template-stub\n, which forces internal linkage for\n__global__\ntemplates in whole program compilation mode.\nDefault Value\ntrue\n4.2.5.3.\n--forward-unknown-to-host-compiler\n(\n-forward-unknown-to-host-compiler\n)\n\nForward unknown options to the host compiler. An ‘unknown option’ is a command line argument that starts with\n-\nfollowed by another character, and is not a recognized nvcc flag or an argument for a recognized nvcc flag.\nIf the unknown option is followed by a separate command line argument, the argument will not be forwarded, unless it begins with the\n-\ncharacter.\nFor example:\nnvcc\n-forward-unknown-to-host-compiler\n-foo=bar\na.cu\nwill forward\n-foo=bar\nto host compiler.\nnvcc\n-forward-unknown-to-host-compiler\n-foo\nbar\na.cu\nwill report an error for\nbar\nargument.\nnvcc\n-forward-unknown-to-host-compiler\n-foo\n-bar\na.cu\nwill forward\n-foo\nand\n-bar\nto host compiler.\nNote: On Windows, also see option\n-forward-slash-prefix-opts\nfor forwarding options that begin with ‘/’.\n4.2.5.4.\n--forward-unknown-to-host-linker\n(\n-forward-unknown-to-host-linker\n)\n\nForward unknown options to the host linker. An ‘unknown option’ is a command line argument that starts with\n-\nfollowed by another character, and is not a recognized nvcc flag or an argument for a recognized nvcc flag.\nIf the unknown option is followed by a separate command line argument, the argument will not be forwarded, unless it begins with the\n-\ncharacter.\nFor example:\nnvcc\n-forward-unknown-to-host-linker\n-foo=bar\na.cu\nwill forward\n-foo=bar\nto host linker.\nnvcc\n-forward-unknown-to-host-linker\n-foo\nbar\na.cu\nwill report an error for\nbar\nargument.\nnvcc\n-forward-unknown-to-host-linker\n-foo\n-bar\na.cu\nwill forward\n-foo\nand\n-bar\nto host linker.\nNote: On Windows, also see option\n-forward-slash-prefix-opts\nfor forwarding options that begin with ‘/’.\n4.2.5.5.\n--forward-unknown-opts\n(\n-forward-unknown-opts\n)\n\nImplies the combination of options\n-forward-unknown-to-host-linker\nand\n-forward-unknown-to-host-compiler\n.\nFor example:\nnvcc\n-forward-unknown-opts\n-foo=bar\na.cu\nwill forward\n-foo=bar\nto the host linker and compiler.\nnvcc\n-forward-unknown-opts\n-foo\nbar\na.cu\nwill report an error for\nbar\nargument.\nnvcc\n-forward-unknown-opts\n-foo\n-bar\na.cu\nwill forward\n-foo\nand\n-bar\nto the host linker and compiler.\nNote: On Windows, also see option\n-forward-slash-prefix-opts\nfor forwarding options that begin with ‘/’.\n4.2.5.6.\n--forward-slash-prefix-opts\n(\n-forward-slash-prefix-opts\n)\n\nIf this flag is specified, and forwarding unknown options to host toolchain is enabled (\n-forward-unknown-opts\nor\n-forward-unknown-to-host-linker\nor\n-forward-unknown-to-host-compiler\n), then a command line argument beginning\nwith ‘/’ is  forwarded to the host toolchain.\nFor example:\nnvcc\n-forward-slash-prefix-opts\n-forward-unknown-opts\n/T\nfoo.cu\nwill forward the flag\n/T\nto the host compiler and linker.\nWhen this flag is not specified, a command line argument beginning with ‘/’   is treated as an input file.\nFor example:\nnvcc\n/T\nfoo.cu\nwill treat ‘/T’ as an input file, and the Windows API function\nGetFullPathName()\nis used to determine the full path name.\nNote: This flag is only supported on Windows.\n4.2.5.7.\n--dont-use-profile\n(\n-noprof\n)\n\nDo not use configurations from the\nnvcc.profile\nfile for compilation.\n4.2.5.8.\n--threads\nnumber\n(\n-t\n)\n\nSpecify the maximum number of threads to be used to execute the compilation steps in parallel.\nThis option can be used to improve the compilation speed when compiling for multiple architectures. The compiler creates\nnumber\nthreads to execute the compilation steps in parallel. If\nnumber\nis 1, this option is ignored. If\nnumber\nis 0, the number of threads used is the number of CPUs on the machine.\n4.2.5.9.\n--dryrun\n(\n-dryrun\n)\n\nList the compilation sub-commands without executing them.\n4.2.5.10.\n--verbose\n(\n-v\n)\n\nList the compilation sub-commands while executing them.\n4.2.5.11.\n--keep\n(\n-keep\n)\n\nKeep all intermediate files that are generated during internal compilation steps.\n4.2.5.12.\n--keep-dir\ndirectory\n(\n-keep-dir\n)\n\nKeep all intermediate files that are generated during internal compilation steps in this directory.\n4.2.5.13.\n--save-temps\n(\n-save-temps\n)\n\nThis option is an alias of\n--keep\n.\n4.2.5.14.\n--clean-targets\n(\n-clean\n)\n\nDelete all the non-temporary files that the same\nnvcc\ncommand would generate without this option.\nThis option reverses the behavior of\nnvcc\n. When specified, none of the compilation phases will be executed. Instead, all of the non-temporary files that\nnvcc\nwould otherwise create will be deleted.\n4.2.5.15.\n--run-args\narguments,...\n(\n-run-args\n)\n\nSpecify command line arguments for the executable when used in conjunction with\n--run\n.\n4.2.5.16.\n--use-local-env\n(\n-use-local-env\n)\n\nUse this flag to force nvcc to assume that the environment for cl.exe has already been set up, and skip running the\nbatch file from the MSVC installation that sets up the environment for cl.exe. This can significantly reduce overall\ncompile time for small programs.\n4.2.5.17.\n--force-cl-env-setup\n(\n-force-cl-env-setup\n)\n\nForce nvcc to always run the batch file from the MSVC installation to set up the environment for cl.exe\n(matching legacy nvcc behavior).\nIf this flag is not specified, by default, nvcc will skip running the batch file if the following conditions are\nsatisfied : cl.exe is in the PATH, environment variable VSCMD_VER is set, and, if\n-ccbin\nis specifed, then compiler\ndenoted by\n-ccbin\nmatches the cl.exe in the PATH. Skipping the batch file execution can reduce overall compile time\nsignificantly for small programs.\n4.2.5.18.\n--input-drive-prefix\nprefix\n(\n-idp\n)\n\nSpecify the input drive prefix.\nOn Windows, all command line arguments that refer to file names must be converted to the Windows native format before they are passed to pure Windows executables. This option specifies how the current development environment represents absolute paths. Use\n/cygwin/\nas\nprefix\nfor Cygwin build environments and\n/\nas\nprefix\nfor MinGW.\n4.2.5.19.\n--dependency-drive-prefix\nprefix\n(\n-ddp\n)\n\nSpecify the dependency drive prefix.\nOn Windows, when generating dependency files (see\n--generate-dependencies\n), all file names must be converted appropriately for the instance of\nmake\nthat is used. Some instances of\nmake\nhave trouble with the colon in absolute paths in the native Windows format, which depends on the environment in which the\nmake\ninstance has been compiled. Use\n/cygwin/\nas\nprefix\nfor a Cygwin\nmake\n, and\n/\nas\nprefix\nfor MinGW. Or leave these file names in the native Windows format by specifying nothing.\n4.2.5.20.\n--drive-prefix\nprefix\n(\n-dp\n)\n\nSpecify the drive prefix.\nThis option specifies\nprefix\nas both\n--input-drive-prefix\nand\n--dependency-drive-prefix\n.\n4.2.5.21.\n--dependency-target-name\ntarget\n(\n-MT\n)\n\nSpecify the target name of the generated rule when generating a dependency file (see\n--generate-dependencies\n).\n4.2.5.22.\n--no-align-double\n\nSpecify that\n-malign-double\nshould not be passed as a compiler argument on 32-bit platforms.\nWARNING:\nthis makes the ABI incompatible with the CUDA’s kernel ABI for certain 64-bit types.\n4.2.5.23.\n--no-device-link\n(\n-nodlink\n)\n\nSkip the device link step when linking object files.\n4.2.5.24.\n--allow-unsupported-compiler\n(\n-allow-unsupported-compiler\n)\n\nDisable nvcc check for supported host compiler versions.\nUsing an unsupported host compiler may cause compilation failure or incorrect run time execution. Use at your own risk. This option has no effect on MacOS.\n4.2.6.\nOptions for Steering CUDA Compilation\n\n4.2.6.1.\n--default-stream\n{\nlegacy\n|\nnull\n|\nper-thread\n} (\n-default-stream\n)\n\nSpecify the stream that CUDA commands from the compiled program will be sent to by default.\nAllowed Values\nlegacy\nThe CUDA legacy stream (per context, implicitly synchronizes with other streams)\nper-thread\nNormal CUDA stream (per thread, does not implicitly synchronize with other streams)\nnull\nDeprecated alias for\nlegacy\nDefault\nlegacy\nis used as the default stream.\n4.2.7.\nOptions for Steering GPU Code Generation\n\n4.2.7.1.\n--gpu-architecture\n(\n-arch\n)\n\nSpecify the name of the class of NVIDIA virtual GPU architecture for which the CUDA input files must be compiled.\nWith the exception as described for the shorthand below, the architecture specified with this option must be a\nvirtual\narchitecture (such as compute_100). Normally, this option alone does not trigger assembly of the generated PTX for a\nreal\narchitecture (that is the role of\nnvcc\noption\n--gpu-code\n, see below); rather, its purpose is to control preprocessing and compilation of the input to PTX.\nFor convenience, in case of simple\nnvcc\ncompilations, the following shorthand is supported. If no value for option\n--gpu-code\nis specified, then the value of this option defaults to the value of\n--gpu-architecture\n. In this situation, as the only exception to the description above, the value specified for\n--gpu-architecture\nmay be a\nreal\narchitecture (such as a sm_100), in which case\nnvcc\nuses the specified\nreal\narchitecture and its closest\nvirtual\narchitecture as the effective architecture values. For example,\nnvcc\n--gpu-architecture=sm_100\nis equivalent to\nnvcc\n--gpu-architecture=compute_100\n--gpu-code=sm_100,compute_100\n. If the architecture-specific\nreal\ngpu (such as\n-arch=sm_90a\n) is specified, then both architecture-specific and non-architecture-specific virtual code are added to the code list:\n--gpu-architecture=compute_90a\n--gpu-code=sm_90a,compute_90,compute_90a\n.\nWhen\n-arch=native\nis specified,\nnvcc\ndetects the visible GPUs on the system and generates codes for them, no PTX program will be generated for this option. It is a warning if there are no visible supported GPU on the system, and the default architecture will be used.\nIf\n-arch=all\nis specified,\nnvcc\nembeds a compiled code image for all supported architectures\n(sm_*)\n, and a PTX program for the highest major virtual architecture. For\n-arch=all-major\n,\nnvcc\nembeds a compiled code image for all supported major versions\n(sm_*0)\n, plus the earliest supported, and adds a PTX program for the highest major virtual architecture.\nSee\nVirtual Architecture Feature List\nfor the list of supported\nvirtual\narchitectures and\nGPU Feature List\nfor the list of supported\nreal\narchitectures.\nDefault\nsm_75\nis used as the default value; PTX is generated for\ncompute_75\nthen assembled and optimized for\nsm_75\n.\n4.2.7.2.\n--gpu-code\ncode,...\n(\n-code\n)\n\nSpecify the name of the NVIDIA GPU to assemble and optimize PTX for.\nnvcc\nembeds a compiled code image in the resulting executable for each specified\ncode\narchitecture, which is a true binary load image for each\nreal\narchitecture (such as sm_100), and PTX code for the\nvirtual\narchitecture (such as compute_100).\nDuring runtime, such embedded PTX code is dynamically compiled by the CUDA runtime system if no binary load image is found for the\ncurrent\nGPU.\nArchitectures specified for options\n--gpu-architecture\nand\n--gpu-code\nmay be\nvirtual\nas well as\nreal\n, but the\ncode\narchitectures must be compatible with the\narch\narchitecture. When the\n--gpu-code\noption is used, the value for the\n--gpu-architecture\noption must be a\nvirtual\nPTX architecture.\nFor instance,\n--gpu-architecture=compute_100\nis not compatible with\n--gpu-code=sm_90\n, because the earlier compilation stages will assume the availability of\ncompute_100\nfeatures that are not present on\nsm_90\n.\nSee\nVirtual Architecture Feature List\nfor the list of supported\nvirtual\narchitectures and\nGPU Feature List\nfor the list of supported\nreal\narchitectures.\n4.2.7.3.\n--generate-code\nspecification\n(\n-gencode\n)\n\nThis option provides a generalization of the\n--gpu-architecture=arch\n--gpu-code=code,...\noption combination for specifying\nnvcc\nbehavior with respect to code generation.\nWhere use of the previous options generates code for different\nreal\narchitectures with the PTX for the same\nvirtual\narchitecture, option\n--generate-code\nallows multiple PTX generations for different\nvirtual\narchitectures. In fact,\n--gpu-architecture=arch\n--gpu-code=code,...\nis equivalent to\n--generate-code=arch=arch,code=code,...\n.\n--generate-code\noptions may be repeated for different virtual architectures.\nSee\nVirtual Architecture Feature List\nfor the list of supported\nvirtual\narchitectures and\nGPU Feature List\nfor the list of supported\nreal\narchitectures.\n4.2.7.4.\n--relocatable-device-code\n{\ntrue\n|\nfalse\n} (\n-rdc\n)\n\nEnable or disable the generation of relocatable device code.\nIf disabled, executable device code is generated. Relocatable device code must be linked before it can be executed.\nAllowed Values\ntrue\nfalse\nDefault\nThe generation of relocatable device code is disabled.\n4.2.7.5.\n--entries\nentry,...\n(\n-e\n)\n\nSpecify the global entry functions for which code must be generated.\nPTX generated for all entry functions, but only the selected entry functions are assembled. Entry function names for this option must be specified in the mangled name.\nDefault\nnvcc\ngenerates code for all entry functions.\n4.2.7.6.\n--maxrregcount\namount\n(\n-maxrregcount\n)\n\nSpecify the maximum amount of registers that GPU functions can use.\nUntil a function-specific limit, a higher value will generally increase the performance of individual GPU threads that execute this function. However, because thread registers are allocated from a global register pool on each GPU, a higher value of this option will also reduce the maximum thread block size, thereby reducing the amount of thread parallelism. Hence, a good\nmaxrregcount\nvalue is the result of a trade-off.\nA value less than the minimum registers required by ABI will be bumped up by the compiler to ABI minimum limit.\nUser program may not be able to make use of all registers as some registers are reserved by compiler.\nDefault\nNo maximum is assumed.\n4.2.7.7.\n--use_fast_math\n(\n-use_fast_math\n)\n\nMake use of fast math library.\n--use_fast_math\nimplies\n--ftz=true\n--prec-div=false\n--prec-sqrt=false\n--fmad=true\n.\n4.2.7.8.\n--ftz\n{\ntrue\n|\nfalse\n} (\n-ftz\n)\n\nControl single-precision denormals support.\n--ftz=true\nflushes denormal values to zero and\n--ftz=false\npreserves denormal values.\n--use_fast_math\nimplies\n--ftz=true\n.\nAllowed Values\ntrue\nfalse\nDefault\nThis option is set to\nfalse\nand\nnvcc\npreserves denormal values.\n4.2.7.9.\n--prec-div\n{\ntrue\n|\nfalse\n} (\n-prec-div\n)\n\nThis option controls single-precision floating-point division and reciprocals.\n--prec-div=true\nenables the IEEE round-to-nearest mode and\n--prec-div=false\nenables the fast approximation mode.\n--use_fast_math\nimplies\n--prec-div=false\n.\nAllowed Values\ntrue\nfalse\nDefault\nThis option is set to\ntrue\nand\nnvcc\nenables the IEEE round-to-nearest mode.\n4.2.7.10.\n--prec-sqrt\n{\ntrue\n|\nfalse\n} (\n-prec-sqrt\n)\n\nThis option controls single-precision floating-point square root.\n--prec-sqrt=true\nenables the IEEE round-to-nearest mode and\n--prec-sqrt=false\nenables the fast approximation mode.\n--use_fast_math\nimplies\n--prec-sqrt=false\n.\nAllowed Values\ntrue\nfalse\nDefault\nThis option is set to\ntrue\nand\nnvcc\nenables the IEEE round-to-nearest mode.\n4.2.7.11.\n--fmad\n{\ntrue\n|\nfalse\n} (\n-fmad\n)\n\nThis option enables (disables) the contraction of floating-point multiplies and adds/subtracts into floating-point multiply-add operations (FMAD, FFMA, or DFMA).\n--use_fast_math\nimplies\n--fmad=true\n.\nAllowed Values\ntrue\nfalse\nDefault\nThis option is set to\ntrue\nand\nnvcc\nenables the contraction of floating-point multiplies and adds/subtracts into floating-point multiply-add operations (FMAD, FFMA, or DFMA).\n4.2.7.12.\n--extra-device-vectorization\n(\n-extra-device-vectorization\n)\n\nThis option enables more aggressive device code vectorization.\n4.2.7.13.\n--compile-as-tools-patch\n(\n-astoolspatch\n)\n\nCompile patch code for CUDA tools. Implies\n–keep-device-functions\n.\nMay only be used in conjunction with\n--ptx\nor\n--cubin\nor\n--fatbin\n.\nShall not be used in conjunction with\n-rdc=true\nor\n-ewp\n.\nSome PTX ISA features may not be usable in this compilation mode.\n4.2.7.14.\n--keep-device-functions\n(\n-keep-device-functions\n)\n\nIn whole program compilation mode, preserve user defined external linkage\n__device__\nfunction definitions in generated PTX.\n4.2.7.15.\n--jump-table-density\npercentage\n(\n-jtd\n)\n\nSpecify the case density percentage in switch statements, and use it as a minimal threshold to determine whether jump table(brx.idx instruction) will be used to implement a switch statement.\nThe percentage ranges from 0 to 101 inclusively.\nDefault\nThis option is set to\n101\nand\nnvcc\ndisables jump table generation for switch statements.\n4.2.8.\nGeneric Tool Options\n\n4.2.8.1.\n--disable-warnings\n(\n-w\n)\n\nInhibit all warning messages.\n4.2.8.2.\n--source-in-ptx\n(\n-src-in-ptx\n)\n\nInterleave source in PTX.\nMay only be used in conjunction with\n--device-debug\nor\n--generate-line-info\n.\n4.2.8.3.\n--restrict\n(\n-restrict\n)\n\nAssert that all kernel pointer parameters are restrict pointers.\n4.2.8.4.\n--Wno-deprecated-gpu-targets\n(\n-Wno-deprecated-gpu-targets\n)\n\nSuppress warnings about deprecated GPU target architectures.\n4.2.8.5.\n--Wno-deprecated-declarations\n(\n-Wno-deprecated-declarations\n)\n\nSuppress warning on use of a deprecated entity.\n4.2.8.6.\n--Wreorder\n(\n-Wreorder\n)\n\nGenerate warnings when member initializers are reordered.\n4.2.8.7.\n--Wdefault-stream-launch\n(\n-Wdefault-stream-launch\n)\n\nGenerate warning when an explicit stream argument is not provided in the\n<<<...>>>\nkernel launch syntax.\n4.2.8.8.\n--Wmissing-launch-bounds\n(\n-Wmissing-launch-bounds\n)\n\nGenerate warning when a\n__global__\nfunction does not have an explicit\n__launch_bounds__\nannotation.\n4.2.8.9.\n--Wext-lambda-captures-this\n(\n-Wext-lambda-captures-this\n)\n\nGenerate warning when an extended lambda implicitly captures\nthis\n.\n4.2.8.10.\n--Werror\nkind,...\n(\n-Werror\n)\n\nMake warnings of the specified kinds into errors.\nThe following is the list of warning kinds accepted by this option:\nall-warnings\nTreat all warnings as errors.\ncross-execution-space-call\nBe more strict about unsupported cross execution space calls. The compiler will generate an error instead of a warning for a call from a\n__host__\n__device__\nto a\n__host__\nfunction.\nreorder\nGenerate errors when member initializers are reordered.\ndefault-stream-launch\nGenerate error when an explicit stream argument is not provided in the\n<<<...>>>\nkernel launch syntax.\nmissing-launch-bounds\nGenerate warning when a\n__global__\nfunction does not have an explicit\n__launch_bounds__\nannotation.\next-lambda-captures-this\nGenerate error when an extended lambda implicitly captures\nthis\n.\ndeprecated-declarations\nGenerate error on use of a deprecated entity.\n4.2.8.11.\n--display-error-number\n(\n-err-no\n)\n\nThis option displays a diagnostic number for any message generated by the CUDA frontend compiler (note: not the host compiler).\n4.2.8.12.\n--no-display-error-number\n(\n-no-err-no\n)\n\nThis option disables the display of a diagnostic number for any message generated by the CUDA frontend compiler (note: not the host compiler).\n4.2.8.13.\n--diag-error\nerrNum,...\n(\n-diag-error\n)\n\nEmit error for specified diagnostic message(s) generated by the CUDA frontend compiler (note: does not affect diagnostics generated by the host compiler/preprocessor).\n4.2.8.14.\n--diag-suppress\nerrNum,...\n(\n-diag-suppress\n)\n\nSuppress specified diagnostic message(s) generated by the CUDA frontend compiler (note: does not affect diagnostics generated by the host compiler/preprocessor).\n4.2.8.15.\n--diag-warn\nerrNum,...\n(\n-diag-warn\n)\n\nEmit warning for specified diagnostic message(s) generated by the CUDA frontend compiler (note: does not affect diagnostics generated by the host compiler/preprocessor).\n4.2.8.16.\n--resource-usage\n(\n-res-usage\n)\n\nShow resource usage such as registers and memory of the GPU code.\nThis option implies\n--nvlink-options=--verbose\nwhen\n--relocatable-device-code=true\nis set. Otherwise, it implies\n--ptxas-options=--verbose\n.\n4.2.8.17.\n--device-stack-protector\n{\ntrue\n|\nfalse\n} (\n-device-stack-protector\n)\n\nEnable or disable the generation of stack canaries in device code.\nStack canaries make it more difficult to exploit certain types of memory safety bugs involving stack-local variables.\nThe compiler uses heuristics to assess the risk of such a bug in each function.  Only those functions which are deemed high-risk make use of a stack canary.\nAllowed Values\ntrue\nfalse\nDefault\nThe generation of stack canaries in device code is disabled.\n4.2.8.18.\n--help\n(\n-h\n)\n\nPrint help information on this tool.\n4.2.8.19.\n--version\n(\n-V\n)\n\nPrint version information on this tool.\n4.2.8.20.\n--options-file\nfile,...\n(\n-optf\n)\n\nInclude command line options from specified file.\n4.2.8.21.\n--time\nfilename\n(\n-time\n)\n\nGenerate a comma separated value table with the time taken by each compilation phase, and append it at the end of the file given as the option argument. If the file is empty, the column headings are generated in the first row of the table.\nIf the file name is\n-\n, the timing data is generated in stdout.\n4.2.8.22.\n--qpp-config\nconfig\n(\n-qpp-config\n)\n\nSpecify the configuration ([[compiler/]version,][target]) when using q++ host compiler. The argument will be forwarded to the q++ compiler with its -V flag.\n4.2.8.23.\n--list-gpu-code\n(\n-code-ls\n)\n\nList the non-architecture-specific gpu architectures (sm_XX) supported by the tool and exit.\nIf both\n–list-gpu-code\nand\n–list-gpu-arch\nare set, the list is displayed using the same format as the\n–generate-code\nvalue.\n4.2.8.24.\n--list-gpu-arch\n(\n-arch-ls\n)\n\nList the non-architecture-specific virtual device architectures (compute_XX) supported by the tool and exit.\nIf both\n–list-gpu-arch\nand\n–list-gpu-code\nare set, the list is displayed using the same format as the\n–generate-code\nvalue.\n4.2.8.25.\n--fdevice-time-trace\n(\n-fdevice-time-trace\n)\n\nEnables the time profiler, outputting a JSON file based on given file name. If file name is ‘-’, the JSON file will have the same name as the user provided output file\n-o\n, otherwise it will be set to ‘trace.json’.\n4.2.9.\nPhase Options\n\nThe following sections lists some useful options to lower level compilation tools.\n4.2.9.1.\nPtxas Options\n\nThe following table lists some useful\nptxas\noptions which can be specified with\nnvcc\noption\n-Xptxas\n.\n4.2.9.1.1.\n--allow-expensive-optimizations\n(\n-allow-expensive-optimizations\n)\n\nEnable (disable) to allow compiler to perform expensive optimizations using maximum available resources (memory and compile-time).\nIf unspecified, default behavior is to enable this feature for optimization level >=\nO2\n.\n4.2.9.1.2.\n--compile-only\n(\n-c\n)\n\nGenerate relocatable object.\n4.2.9.1.3.\n--def-load-cache\n(\n-dlcm\n)\n\nDefault cache modifier on global/generic load.\n4.2.9.1.4.\n--def-store-cache\n(\n-dscm\n)\n\nDefault cache modifier on global/generic store.\n4.2.9.1.5.\n--device-debug\n(\n-g\n)\n\nSemantics same as\nnvcc\noption\n--device-debug\n.\n4.2.9.1.6.\n--disable-optimizer-constants\n(\n-disable-optimizer-consts\n)\n\nDisable use of optimizer constant bank.\n4.2.9.1.7.\n--entry\nentry,...\n(\n-e\n)\n\nSemantics same as\nnvcc\noption\n--entries\n.\n4.2.9.1.8.\n--fmad\n(\n-fmad\n)\n\nSemantics same as\nnvcc\noption\n--fmad\n.\n4.2.9.1.9.\n--force-load-cache\n(\n-flcm\n)\n\nForce specified cache modifier on global/generic load.\n4.2.9.1.10.\n--force-store-cache\n(\n-fscm\n)\n\nForce specified cache modifier on global/generic store.\n4.2.9.1.11.\n--generate-line-info\n(\n-lineinfo\n)\n\nSemantics same as\nnvcc\noption\n--generate-line-info\n.\n4.2.9.1.12.\n--gpu-name\ngpuname\n(\n-arch\n)\n\nSpecify name of NVIDIA GPU to generate code for.\nThis option also takes virtual compute architectures, in which case code generation is suppressed.\nThis can be used for parsing only.\nPTX for .target sm_XY can be compiled to all GPU targets sm_MN, sm_MNa, SM_MNf where MN >= XY. PTX\nfor .target sm_XYf can be compiled to GPU targets sm_XZ, sm_XZf, sm_XZa where Z >= Y and sm_XY and\nsm_XZ belong in same family. PTX with .target sm_XYa can only be compiled to GPU target sm_XYa.\nAllowed Values\ncompute_75\ncompute_80\ncompute_86\ncompute_87\ncompute_88\ncompute_89\ncompute_90\ncompute_90a\ncompute_100\ncompute_100f\ncompute_100a\ncompute_103\ncompute_103f\ncompute_103a\ncompute_110\ncompute_110f\ncompute_110a\ncompute_120\ncompute_120f\ncompute_120a\ncompute_121\ncompute_121f\ncompute_121a\nsm_75\nsm_80\nsm_86\nsm_87\nsm_88\nsm_89\nsm_90\nsm_90a\nsm_100\nsm_100f\nsm_100a\nsm_103\nsm_103f\nsm_103a\nsm_110\nsm_110f\nsm_110a\nsm_120\nsm_120f\nsm_120a\nsm_121\nsm_121f\nsm_121a\nDefault value:\nsm_75\n4.2.9.1.13.\n--help\n(\n-h\n)\n\nSemantics same as\nnvcc\noption\n--help\n.\n4.2.9.1.14.\n--machine\n(\n-m\n)\n\nSemantics same as\nnvcc\noption\n--machine\n.\n4.2.9.1.15.\n--maxrregcount\namount\n(\n-maxrregcount\n)\n\nSemantics same as\nnvcc\noption\n--maxrregcount\n.\n4.2.9.1.16.\n--opt-level\nN\n(\n-O\n)\n\nSpecify optimization level.\nDefault value:\n3\n.\n4.2.9.1.17.\n--options-file\nfile,...\n(\n-optf\n)\n\nSemantics same as\nnvcc\noption\n--options-file\n.\n4.2.9.1.18.\n--position-independent-code\n(\n-pic\n)\n\nGenerate position-independent code.\nDefault value:\nFor whole-program compilation:\ntrue\nOtherwise:\nfalse\n4.2.9.1.19.\n--preserve-relocs\n(\n-preserve-relocs\n)\n\nThis option will make\nptxas\nto generate relocatable references for variables and preserve relocations generated for them in linked executable.\n4.2.9.1.20.\n--sp-bounds-check\n(\n-sp-bounds-check\n)\n\nGenerate stack-pointer bounds-checking code sequence.\nThis option is turned on automatically when\n--device-debug\nor\n--opt-level=0\nis specified.\n4.2.9.1.21.\n--suppress-async-bulk-multicast-advisory-warning\n(\n-suppress-async-bulk-multicast-advisory-warning\n)\n\nSuppress the warning on use of\n.multicast::cluster\nmodifier on\ncp.async.bulk{.tensor}\ninstruction with\nsm_90\n.\n4.2.9.1.22.\n--verbose\n(\n-v\n)\n\nEnable verbose mode which prints code generation statistics.\n4.2.9.1.23.\n--version\n(\n-V\n)\n\nSemantics same as\nnvcc\noption\n--version\n.\n4.2.9.1.24.\n--warning-as-error\n(\n-Werror\n)\n\nMake all warnings into errors.\n4.2.9.1.25.\n--warn-on-double-precision-use\n(\n-warn-double-usage\n)\n\nWarning if double(s) are used in an instruction.\n4.2.9.1.26.\n--warn-on-local-memory-usage\n(\n-warn-lmem-usage\n)\n\nWarning if local memory is used.\n4.2.9.1.27.\n--warn-on-spills\n(\n-warn-spills\n)\n\nWarning if registers are spilled to local memory.\n4.2.9.1.28.\n--compile-as-tools-patch\n(\n-astoolspatch\n)\n\nCompile patch code for CUDA tools.\nShall not be used in conjunction with\n-Xptxas\n-c\nor\n-ewp\n.\nSome PTX ISA features may not be usable in this compilation mode.\n4.2.9.1.29.\n--maxntid\n(\n-maxntid\n)\n\nSpecify the maximum number of threads that a thread block can have.\nThis option will be ignored if used along with\n-maxrregcount\noption. This option is also ignored\nfor entry functions that have\n.maxntid\ndirective specified.\n4.2.9.1.30.\n--minnctapersm\n(\n-minnctapersm\n)\n\nSpecify the minimum number of CTAs to be mapped to an SM.\nThis option will be ignored if used along with\n-maxrregcount\noption. This option is also ignored\nfor entry functions that have\n.minnctapersm\ndirective specified.\n4.2.9.1.31.\n--override-directive-values\n(\n-override-directive-values\n)\n\nOverride the PTX directives values by the corresponding option values.\nThis option is effective only for\n-minnctapersm\n,\n-maxntid\nand\n-maxrregcount\noptions.\n4.2.9.1.32.\n--make-errors-visible-at-exit\n(\n-make-errors-visible-at-exit\n)\n\nGenerate required instructions at exit point to make memory faults and errors visible at exit.\n4.2.9.1.33.\n--Ofast-compile\nlevel\n(\n-Ofc\n)\n\nSpecify the fast-compile level for device code, which controls the tradeoff between compilation speed and runtime performance by disabling certain optimizations at varying levels. Passed automatically at the same level when nvcc is called with\n--Ofast-compile\n.\nAllowed Values\nmax\n: Focus only on the fastest compilation speed, disabling many optimizations.\nmid\n: Balance compile time and runtime, disabling expensive optimizations.\nmin\n: More minimal impact on both compile time and runtime, minimizing some expensive optimizations.\n0\n: Disable fast-compile.\nDefault Value\nThe option is disabled by default.\n4.2.9.1.34.\n--device-stack-protector\n(\n-device-stack-protector\n)\n\nEnable or disable the generation of stack canaries in device code.\nStack canaries make it more difficult to exploit certain types of memory safety bugs involving stack-local variables.\nThe compiler uses heuristics to assess the risk of such a bug in each function.  Only those functions which are deemed high-risk make use of a stack canary.\nAllowed Values\ntrue\nfalse\nDefault\nThe generation of stack canaries in device code is disabled.\n4.2.9.1.35.\n--g-tensor-memory-access-check\n(\n-g-tmem-access-check\n)\n\nEnable tensor memory access checks for\ntcgen05\noperations.\nThis option is enabled by default with\n--device-debug\n(\n-g\n) option.\n4.2.9.1.36.\n--gno-tensor-memory-access-check\n(\n-gno-tmem-access-check\n)\n\nDisable tensor memory access checks for\ntcgen05\noperations.\nThis option will override the\n--g-tensor-memory-access-check\noption if both are specified.\n4.2.9.1.37.\n--split-compile\n(\n-split-compile\n)\n\nSpecify the maximum amount of concurrent threads to be utilized when running compiler optimizations.\nIf value specified is\n1\n, option will be ignored.\nIf value specified is\n0\n, then the number of threads will be the number of CPUs on\nthe underlying machine.\n4.2.9.1.38.\n--jobserver\n(\n-jobserver\n)\n\nEnable GNU jobserver support.\nWhen using\n-split-compile\ninside of a build controlled by GNU Make,\nrequire that job slots are acquired Make’s jobserver for each of the threads used, helping\nprevent oversubscription.\nThis option only works when Make is called with\n-j\nset to a numerical value greater\nthan 1, as\n-j\n(without a number) causes Make to skip making the jobserver and\n-j1\ndisables all parallelism.\nThis requires GNU Make 4.3 or newer.\nUsing this option with an unsupported version of Make, or without the correct\n-j\nvalue may lead to undefined behavior.\nNote: This flag is only supported on Linux.\n4.2.9.2.\nNVLINK Options\n\nThe following is a list of some useful\nnvlink\noptions which can be specified with\nnvcc\noption\n--nvlink-options\n.\n4.2.9.2.1.\n--disable-warnings\n(\n-w\n)\n\nInhibit all warning messages.\n4.2.9.2.2.\n--preserve-relocs\n(\n-preserve-relocs\n)\n\nPreserve resolved relocations in linked executable.\n4.2.9.2.3.\n--verbose\n(\n-v\n)\n\nEnable verbose mode which prints code generation statistics.\n4.2.9.2.4.\n--warning-as-error\n(\n-Werror\n)\n\nMake all warnings into errors.\n4.2.9.2.5.\n--suppress-arch-warning\n(\n-suppress-arch-warning\n)\n\nSuppress the warning that otherwise is printed when object does not contain code for target arch.\n4.2.9.2.6.\n--suppress-stack-size-warning\n(\n-suppress-stack-size-warning\n)\n\nSuppress the warning that otherwise is printed when stack size cannot be determined.\n4.2.9.2.7.\n--dump-callgraph\n(\n-dump-callgraph\n)\n\nDump information about the callgraph and register usage.\n4.2.9.2.8.\n--dump-callgraph-no-demangle\n(\n-dump-callgraph-no-demangle\n)\n\nDump callgraph information without demangling.\n4.2.9.2.9.\n--Xptxas\n(\n-Xptxas\n)\n\nPtxas options (only used with LTO).\n4.2.9.2.10.\n--cpu-arch\n(\n-cpu-arch\n)\n\nSpecify the name of the cpu target architecture.\n4.2.9.2.11.\n--extra-warnings\n(\n-extrawarn\n)\n\nEmit extra warnings about possible problems.\n4.2.9.2.12.\n--gen-host-linker-script\n(\n-ghls\n)\n\nSpecify the type of host linker script to be generated.\n4.2.9.2.13.\n--ignore-host-info\n(\n-ignore-host-info\n)\n\nIgnore information about host references, so don’t remove device code that could potentially be referenced by host.\n4.2.9.2.14.\n--keep-system-libraries\n(\n-keep-system-libraries\n)\n\nDon’t optimize away system library (e.g. cudadevrt) code.\n4.2.9.2.15.\n--kernels-used\n(\n-kernels-used\n)\n\nSpecify kernels that are used. Can be part of a kernel name so any kernels with that string in name are matched. If this option is used, then any other kernels are considered dead-code and removed.\n4.2.9.2.16.\n--options-file\n(\n-optf\n)\n\nInclude command line options from the specified file.\n4.2.9.2.17.\n--report-arch\n(\n-report-arch\n)\n\nReport SM target arch in error messages.\n4.2.9.2.18.\n--suppress-debug-info\n(\n-suppress-debug-info\n)\n\nDo not preserve debug symbols in output. This option is ignored if used without –debug option.\n4.2.9.2.19.\n--variables-used\n(\n-variables\nused\n)\n\nSpecify variables that are used. Can be part of a variable name so any variable with that string in name are matched. If this option is used, then any other variables are considered dead-code and potentially removed unless have other accesses from device code.\n4.2.9.2.20.\n--device-stack-protector\n{\ntrue\n|\nfalse\n} (\n-device-stack-protector\n)\n\nEnable or disable the generation of stack canaries in device code (only used with LTO).\nStack canaries make it more difficult to exploit certain types of memory safety bugs involving stack-local variables.\nThe compiler uses heuristics to assess the risk of such a bug in each function.  Only those functions which are deemed high-risk make use of a stack canary.\nAllowed Values\ntrue\nfalse\nDefault\nThe generation of stack canaries in device code is disabled.\n4.3.\nNVCC Environment Variables\n\nNVCC_PREPEND_FLAGS and NVCC_APPEND_FLAGS:\nThe\nnvcc\ncommand line flags can be augmented using the following environment variables, if set:\nNVCC_PREPEND_FLAGS\nFlags to be injected before the normal nvcc command line.\nNVCC_APPEND_FLAGS\nFlags to be injected after the normal nvcc command line.\nFor example, after setting:\nexport NVCC_PREPEND_FLAGS='-G -keep -arch=sm_90'\nexport NVCC_APPEND_FLAGS='-DNAME=\" foo \"'\nThe following invocation:\nnvcc foo.cu -o foo\nBecomes equivalent to:\nnvcc -G -keep -arch=sm_90 foo.cu -o foo -DNAME=\" foo \"\nThese environment variables can be useful for injecting\nnvcc\nflags globally without modifying build scripts.\nThe additional flags coming from either NVCC_PREPEND_FLAGS or NVCC_APPEND_FLAGS will be listed in the verbose log (\n--verbose\n).\nNVCC_CCBIN:\nA default host compiler can be set using the environment variable\nNVCC_CCBIN\n. For example, after setting:\nexport NVCC_CCBIN='gcc'\nnvcc\nwill choose\ngcc\nas the host compiler if\n--compiler-bindir\nis not set.\nNVCC_CCBIN\ncan be useful for controlling the default host compiler globally. If\nNVCC_CCBIN\nand\n--compiler-bindir\nare both set,\nnvcc\nwill choose the host compiler specified by\n--compiler-bindir\n. For example:\nexport NVCC_CCBIN='gcc'\nnvcc foo.cu -ccbin='clang' -o foo\nIn this case,\nnvcc\nwill choose\nclang\nas the host compiler.\n5.\nGPU Compilation\n\nThis chapter describes the GPU compilation model that is maintained by\nnvcc\n, in cooperation with the CUDA driver. It goes through some technical sections, with concrete examples at the end.\n5.1.\nGPU Generations\n\nIn order to allow for architectural evolution, NVIDIA GPUs are released in different generations. New generations introduce major improvements in functionality and/or chip architecture, while GPU models within the same generation show minor configuration differences that\nmoderately\naffect functionality, performance, or both.\nAll NVIDIA GPUs have a compute capability (CC) which is a two part identifier in the form\nmajor.minor\nThe major version identifies the GPU generation, while the minor number identifies the version within that generation. For example, compute capability 8.6 is part of CC 8.x generation. While GPUs generations are often refered to by product names such as Hopper or Blackwell, these don’t always have a direct correspondence to major compute capability version.\nBinary compatibility of GPU applications is not guaranteed across different major compute capabilities. For example, a CUDA application that has been compiled for a CC 9.0 GPU will not run on a CC 10.0 GPU (and vice versa). This is because the instruction set and instruction encodings are different between different major compute capabilities.\nBinary compatibility within a major compute capability can be guaranteed under certain conditions. This is the case when two GPU versions do not show functional differences (for instance when one version is a scaled down version of the other), or when one version is functionally included in the other. An example of the latter is that code compiled for the target\nsm_80\nwill run on all other CC 8.x GPUs, such as\nsm_86\nor\nsm_89\n.\n5.2.\nGPU Feature List\n\nThe following table lists the names of the current GPU architectures, annotated with the functional capabilities that they provide. There are other differences, such as amounts of register and processor clusters, that only affect execution performance.\nIn NVCC, GPUs are named\nsm_xy\n, where\nx\ndenotes the major compute capability, and\ny\nthe minor compute capability. Additionally, to facilitate comparing GPU capabilities, CUDA attempts to choose its GPU names such that if\nx1y1\n<=\nx2y2\nthen all non-ISA related capabilities of\nsm_x1y1\nare included in\nsm_x2y2\n.\nsm_75\nTuring support\nsm_80\n,\nsm_86\nand\nsm_87\n,\nsm_88\nNVIDIA Ampere GPU architecture support\nsm_89\nAda support\nsm_90\n,\nsm_90a\nHopper support\nsm_100\n,\nsm_100f\n,\nsm_100a\n,\nsm_103\n,\nsm_103f\n,\nsm_103a\n,\nsm_110\n,\nsm_110f\n,\nsm_110a\n,\nsm_120\n,\nsm_120f\n,\nsm_120a\n,\nsm_121\n,\nsm_121f\n,\nsm_121a\nBlackwell support\n5.3.\nApplication Compatibility\n\nBinary code compatibility over CPU generations, together with a published instruction set architecture is the usual mechanism for ensuring that distributed applications\nout there in the field\nwill continue to run on newer versions of the CPU when these become mainstream.\nThis situation is different for GPUs, because NVIDIA cannot guarantee binary compatibility without sacrificing regular opportunities for GPU improvements. Rather, as is already conventional in the graphics programming domain,\nnvcc\nrelies on a two stage compilation model for ensuring application compatibility with future GPU generations.\n5.4.\nVirtual Architectures\n\nGPU compilation is performed via an intermediate representation, PTX, which can be considered as assembly for a virtual GPU architecture. Contrary to an actual graphics processor, such a virtual GPU is defined entirely by the set of capabilities, or features, that it provides to the application. In particular, a virtual GPU architecture provides a (largely) generic instruction set, and binary instruction encoding is a non-issue because PTX programs are always represented in text format.\nHence, a\nnvcc\ncompilation command always uses two architectures: a\nvirtual\nintermediate architecture, plus a\nreal\nGPU architecture to specify the intended processor to execute on. For such an\nnvcc\ncommand to be valid, the\nreal\narchitecture must be an implementation of the\nvirtual\narchitecture. This is further explained below.\nThe chosen virtual architecture is more of a statement on the GPU capabilities that the application requires: using a\nsmaller\nvirtual architecture still allows a\nwider\nrange of actual architectures for the second\nnvcc\nstage. Conversely, specifying a virtual architecture that provides features unused by the application unnecessarily restricts the set of possible GPUs that can be specified in the second\nnvcc\nstage.\nFrom this it follows that the virtual architecture should always be chosen as\nlow\nas possible, thereby maximizing the actual GPUs to run on. The\nreal\narchitecture should be chosen as\nhigh\nas possible (assuming that this always generates better code), but this is only possible with knowledge of the actual GPUs on which the application is expected to run on. As we will see later in the situation of just-in-time compilation, where the driver has this exact knowledge, the runtime GPU is the one on which the program is about to be launched/executed.\nTwo-Staged Compilation with Virtual and Real Architectures\n\n5.5.\nVirtual Architecture Feature List\n\ncompute_75\nTuring support\ncompute_80\n,\ncompute_86\nand\ncompute_87\n,\ncompute_88\nNVIDIA Ampere GPU architecture support\ncompute_89\nAda support\ncompute_90\n,\ncompute_90a\nHopper support\ncompute_100\n,\ncompute_100f\n,\ncompute_100a\n,\ncompute_103\n,\ncompute_103f\n,\ncompute_103a\n,\ncompute_110\n,\ncompute_110f\n,\ncompute_110a\n,\ncompute_120\n,\ncompute_120f\n,\ncompute_120a\n,\ncompute_121\n,\ncompute_121f\n,\ncompute_121a\nBlackwell support\nThe above table lists the currently defined virtual architectures. The virtual architecture naming scheme is the same as the real architecture naming scheme shown in Section\nGPU Feature List\n.\n5.6.\nFurther Mechanisms\n\nClearly, compilation staging in itself does not help towards the goal of application compatibility with future GPUs. For this we need two other mechanisms: just-in-time compilation (JIT) and fatbinaries.\n5.6.1.\nJust-in-Time Compilation\n\nThe compilation step to an actual GPU binds the code to one generation of GPUs. Within that generation, it involves a choice between GPU\ncoverage\nand possible performance. For example, compiling to\nsm_80\nallows the code to run on all NVIDIA Ampere and Ada generation GPUs, but compiling to\nsm_89\nwould probably yield better code if Ada generation GPUs are the only targets.\nJust-in-Time Compilation of Device Code\n\nBy specifying a virtual code architecture instead of a\nreal\nGPU,\nnvcc\npostpones the assembly of PTX code until application runtime, at which time the target GPU is exactly known. For instance, the command below allows generation of exactly matching GPU binary code, when the application is launched on an\nsm_90\nor later architecture.\nnvcc x.cu --gpu-architecture=compute_90 --gpu-code=compute_90\nThe disadvantage of just-in-time compilation is increased application startup delay, but this can be alleviated by letting the CUDA driver use a compilation cache (refer to “Section 3.1.1.2. Just-in-Time Compilation” of\nCUDA C++ Programming Guide\n) which is persistent over multiple runs of the applications.\n5.6.2.\nFatbinaries\n\nA different solution to overcome startup delay by JIT while still allowing execution on newer GPUs is to specify multiple code instances, as in\nnvcc x.cu --gpu-architecture=compute_80 --gpu-code=compute_80,sm_86,sm_89\nThis command generates exact code for two architectures, plus PTX code for use by JIT in case a next-generation GPU is encountered.\nnvcc\norganizes its device code in fatbinaries, which are able to hold multiple translations of the same GPU source code. At runtime, the CUDA driver will select the most appropriate translation when the device function is launched.\n5.7.\nNVCC Examples\n\n5.7.1.\nBase Notation\n\nnvcc\nprovides the options\n--gpu-architecture\nand\n--gpu-code\nfor specifying the target architectures for both translation stages. Except for allowed short hands described below, the\n--gpu-architecture\noption takes a single value, which must be the name of a virtual compute architecture, while option\n--gpu-code\ntakes a list of values which must all be the names of actual GPUs.\nnvcc\nperforms a stage 2 translation for each of these GPUs, and will embed the result in the result of compilation (which usually is a host object file or executable).\nExample\nnvcc x.cu --gpu-architecture=compute_80 --gpu-code=sm_80,sm_86\n5.7.2.\nShorthand\n\nnvcc\nallows a number of shorthands for simple cases.\n5.7.2.1.\nShorthand 1\n\n--gpu-code\narguments can be virtual architectures. In this case the stage 2 translation will be omitted for such virtual architecture, and the stage 1 PTX result will be embedded instead. At application launch, and in case the driver does not find a better alternative, the stage 2 compilation will be invoked by the driver with the PTX as input.\nExample\nnvcc x.cu --gpu-architecture=compute_80 --gpu-code=compute_80,sm_80,sm_86\n5.7.2.2.\nShorthand 2\n\nThe\n--gpu-code\noption can be omitted. Only in this case, the\n--gpu-architecture\nvalue can be a non-virtual architecture. The\n--gpu-code\nvalues default to the\nclosest\nvirtual architecture that is implemented by the GPU specified with\n--gpu-architecture\n, plus the\n--gpu-architecture\n, value itself. The\nclosest\nvirtual architecture is used as the effective\n--gpu-architecture\n, value. If the\n--gpu-architecture\nvalue is a virtual architecture, it is also used as the effective\n--gpu-code\nvalue.\nExample\nnvcc x.cu --gpu-architecture=sm_86\nnvcc x.cu --gpu-architecture=compute_80\nare equivalent to\nnvcc x.cu --gpu-architecture=compute_86 --gpu-code=sm_86,compute_86\nnvcc x.cu --gpu-architecture=compute_80 --gpu-code=compute_80\n5.7.2.3.\nShorthand 3\n\nBoth\n--gpu-architecture\nand\n--gpu-code\noptions can be omitted.\nExample\nnvcc x.cu\nis equivalent to\nnvcc x.cu --gpu-architecture=compute_75 --gpu-code=sm_75,compute_75\n5.7.3.\nGPU Code Generation in CUDA\n\n5.7.3.1.\nList of Supported GPU Codes\n\nBelow are the recognized GPU code values for compilation and optimization:\nCompute Capability Targets\ncompute_75\ncompute_80\ncompute_86\ncompute_87\ncompute_88\ncompute_89\ncompute_90\ncompute_90a\ncompute_100\ncompute_100f\ncompute_100a\ncompute_103\ncompute_103f\ncompute_103a\ncompute_110\ncompute_110f\ncompute_110a\ncompute_120\ncompute_120f\ncompute_120a\ncompute_121\ncompute_121f\ncompute_121a\nLink-Time Optimization (LTO) Targets\nlto_75\nlto_80\nlto_86\nlto_87\nlto_88\nlto_89\nlto_90\nlto_90a\nlto_100\nlto_100f\nlto_100a\nlto_103\nlto_103f\nlto_103a\nlto_110\nlto_110f\nlto_110a\nlto_120\nlto_120f\nlto_120a\nlto_121\nlto_121f\nlto_121a\nStreaming Multiprocessor (SM) Architectures\nsm_75\nsm_80\nsm_86\nsm_87\nsm_88\nsm_89\nsm_90\nsm_90a\nsm_100\nsm_100f\nsm_100a\nsm_103\nsm_103f\nsm_103a\nsm_110\nsm_110f\nsm_110a\nsm_120\nsm_120f\nsm_120a\nsm_121\nsm_121f\nsm_121a\n5.7.3.2.\nExtended Notation\n\nThe options\n--gpu-architecture\nand\n--gpu-code\ncan be used in all cases where code is to be generated for one or more GPUs using a common virtual architecture. This will cause a single invocation of\nnvcc\nstage 1 (that is, preprocessing and generation of virtual PTX assembly code), followed by a compilation stage 2 (binary code generation) repeated for each specified GPU.\nUsing a common virtual architecture means that all assumed GPU features are fixed for the entire\nnvcc\ncompilation. For instance, the following\nnvcc\ncommand assumes only the features available in compute capability 8.0 for both\nsm_80\ncode and the\nsm_86\ncode:\nnvcc x.cu --gpu-architecture=compute_80 --gpu-code=compute_80,sm_80,sm_86\nSometimes it is necessary to perform different GPU code generation steps, partitioned over different architectures. This is possible using\nnvcc\noption\n--generate-code\n, which then must be used instead of a\n--gpu-architecture\nand\n--gpu-code\ncombination.\n5.7.3.3.\nUsing Code Generation Options\n\nUnlike option\n--gpu-architecture\n, option\n--generate-code\nmay be repeated on the\nnvcc\ncommand line. It takes sub-options\narch\nand\ncode\n, which must not be confused with their main option equivalents, but behave similarly. If repeated architecture compilation is used, then the device code must use conditional compilation based on the value of the architecture identification macro\n__CUDA_ARCH__\n, which is described in the next section.\nFor example, the following assumes only the features available in compute capability 8.0 for the\nsm_80\nand\nsm_86\ncode, but all features available in compute capability 9.0 support on\nsm_90\n:\nnvcc x.cu \\\n--generate-code arch=compute_80,code=sm_80 \\\n--generate-code arch=compute_80,code=sm_86 \\\n--generate-code arch=compute_90,code=sm_90\nOr, leaving actual GPU code generation to the JIT compiler in the CUDA driver:\nnvcc x.cu \\\n--generate-code arch=compute_80,code=compute_80 \\\n--generate-code arch=compute_90,code=compute_90\nThe code sub-options can be combined with a slightly more complex syntax:\nnvcc x.cu \\\n--generate-code arch=compute_80,code=[sm_80,sm_86] \\\n--generate-code arch=compute_90,code=sm_90\n5.7.4.\nVirtual Architecture Macros\n\nThe architecture identification macro\n__CUDA_ARCH__\nis assigned a three-digit value string\nxy0\n(ending in a literal\n0\n) for each stage 1\nnvcc\ncompilation that compiles for\ncompute_xy\n.\nThis macro can be used in the implementation of GPU functions for determining the virtual architecture for which it is currently being compiled. The host code (the non-GPU code) must\nnot\ndepend on it.\nThe architecture list macro\n__CUDA_ARCH_LIST__\nis a list of comma-separated\n__CUDA_ARCH__\nvalues for each of the virtual architectures specified in the compiler invocation. The list is sorted in numerically ascending order.\nThe macro\n__CUDA_ARCH_LIST__\nis defined when compiling C, C++ and CUDA source files.\nFor example, the following nvcc compilation command line will define\n__CUDA_ARCH_LIST__\nas\n800,860,900\n:\nnvcc x.cu \\\n--generate-code arch=compute_90,code=sm_90 \\\n--generate-code arch=compute_80,code=sm_80 \\\n--generate-code arch=compute_86,code=sm_86 \\\n--generate-code arch=compute_86,code=sm_89\n6.\nUsing Separate Compilation in CUDA\n\nPrior to the 5.0 release, CUDA did not support separate compilation, so CUDA code could not call device functions or access variables across files. Such compilation is referred to as\nwhole program compilation\n. We have always supported the separate compilation of host code, it was just the CUDA device code that needed to all be within one file. Starting with CUDA 5.0, separate compilation of device code is supported, but the old whole program mode is still the default, so there are new options to invoke separate compilation.\n6.1.\nCode Changes for Separate Compilation\n\nThe code changes required for separate compilation of device code are the same as what you already do for host code, namely using\nextern\nand\nstatic\nto control the visibility of symbols. Note that previously\nextern\nwas ignored in CUDA code; now it will be honored. With the use of\nstatic\nit is possible to have multiple device symbols with the same name in different files. For this reason, the CUDA API calls that referred to symbols by their string name are deprecated; instead the symbol should be referenced by its address.\n6.2.\nNVCC Options for Separate Compilation\n\nCUDA works by embedding device code into host objects. In whole program compilation, it embeds executable device code into the host object. In separate compilation, we embed relocatable device code into the host object, and run\nnvlink\n, the device linker, to link all the device code together. The output of nvlink is then linked together with all the host objects by the host linker to form the final executable.\nThe generation of relocatable vs executable device code is controlled by the\n--relocatable-device-code\noption.\nThe\n--compile\noption is already used to control stopping a compile at a host object, so a new option\n--device-c\nis added that simply does\n--relocatable-device-code=true\n--compile\n.\nTo invoke just the device linker, the\n--device-link\noption can be used, which emits a host object containing the embedded executable device code. The output of that must then be passed to the host linker. Or:\nnvcc <objects>\ncan be used to implicitly call both the device and host linkers. This works because if the device linker does not see any relocatable code it does not do anything.\nThe following figure shows the flow.\nCUDA Separate Compilation Trajectory\n\n6.3.\nLibraries\n\nThe device linker has the ability to read the static host library formats (\n.a\non Linux and Mac OS X,\n.lib\non Windows). It ignores any dynamic (\n.so\nor\n.dll\n) libraries. The\n--library\nand\n--library-path\noptions can be used to pass libraries to both the device and host linker. The library name is specified without the library file extension when the\n--library\noption is used.\nnvcc --gpu-architecture=sm_100 a.o b.o --library-path=<path> --library=foo\nAlternatively, the library name, including the library file extension, can be used without the\n--library\noption on Windows.\nnvcc --gpu-architecture=sm_100 a.obj b.obj foo.lib --library-path=<path>\nNote that the device linker ignores any objects that do not have relocatable device code.\n6.4.\nExamples\n\nSuppose we have the following files:\n//---------- b.h ----------\n#define N 8\nextern\n__device__\nint\ng\n[\nN\n];\nextern\n__device__\nvoid\nbar\n(\nvoid\n);\n//---------- b.cu ----------\n#include\n\"b.h\"\n__device__\nint\ng\n[\nN\n];\n__device__\nvoid\nbar\n(\nvoid\n)\n{\ng\n[\nthreadIdx\n.\nx\n]\n++\n;\n}\n//---------- a.cu ----------\n#include\n<stdio.h>\n#include\n\"b.h\"\n__global__\nvoid\nfoo\n(\nvoid\n)\n{\n__shared__\nint\na\n[\nN\n];\na\n[\nthreadIdx\n.\nx\n]\n=\nthreadIdx\n.\nx\n;\n__syncthreads\n();\ng\n[\nthreadIdx\n.\nx\n]\n=\na\n[\nblockDim\n.\nx\n-\nthreadIdx\n.\nx\n-\n1\n];\nbar\n();\n}\nint\nmain\n(\nvoid\n)\n{\nunsigned\nint\ni\n;\nint\n*\ndg\n,\nhg\n[\nN\n];\nint\nsum\n=\n0\n;\nfoo\n<<<\n1\n,\nN\n>>>\n();\nif\n(\ncudaGetSymbolAddress\n((\nvoid\n**\n)\n&\ndg\n,\ng\n)){\nprintf\n(\n\"couldn't get the symbol addr\n\\n\n\"\n);\nreturn\n1\n;\n}\nif\n(\ncudaMemcpy\n(\nhg\n,\ndg\n,\nN\n*\nsizeof\n(\nint\n),\ncudaMemcpyDeviceToHost\n)){\nprintf\n(\n\"couldn't memcpy\n\\n\n\"\n);\nreturn\n1\n;\n}\nfor\n(\ni\n=\n0\n;\ni\n<\nN\n;\ni\n++\n)\n{\nsum\n+=\nhg\n[\ni\n];\n}\nif\n(\nsum\n==\n36\n)\n{\nprintf\n(\n\"PASSED\n\\n\n\"\n);\n}\nelse\n{\nprintf\n(\n\"FAILED (%d)\n\\n\n\"\n,\nsum\n);\n}\nreturn\n0\n;\n}\nThese can be compiled with the following commands (these examples are for Linux):\nnvcc --gpu-architecture=sm_100 --device-c a.cu b.cu\nnvcc --gpu-architecture=sm_100 a.o b.o\nIf you want to invoke the device and host linker separately, you can do:\nnvcc --gpu-architecture=sm_100 --device-c a.cu b.cu\nnvcc --gpu-architecture=sm_100 --device-link a.o b.o --output-file link.o\ng++ a.o b.o link.o --library-path=<path> --library=cudart\nNote that all desired target architectures must be passed to the device linker, as that specifies what will be in the final executable (some objects or libraries may contain device code for multiple architectures, and the link step can then choose what to put in the final executable).\nIf you want to use the driver API to load a linked cubin, you can request just the cubin:\nnvcc --gpu-architecture=sm_100 --device-link a.o b.o \\\n--cubin --output-file link.cubin\nThe objects could be put into a library and used with:\nnvcc --gpu-architecture=sm_100 --device-c a.cu b.cu\nnvcc --lib a.o b.o --output-file test.a\nnvcc --gpu-architecture=sm_100 test.a\nNote that only static libraries are supported by the device linker.\nA PTX file can be compiled to a host object file and then linked by using:\nnvcc --gpu-architecture=sm_100 --device-c a.ptx\nAn example that uses libraries, host linker, and dynamic parallelism would be:\nnvcc --gpu-architecture=sm_100 --device-c a.cu b.cu\nnvcc --gpu-architecture=sm_100 --device-link a.o b.o --output-file link.o\nnvcc --lib --output-file libgpu.a a.o b.o link.o\ng++ host.o --library=gpu --library-path=<path> \\\n--library=cudadevrt --library=cudart\nIt is possible to do multiple device links within a single host executable, as long as each device link is independent of the other. This requirement of independence means that they cannot share code across device executables, nor can they share addresses (e.g., a device function address can be passed from host to device for a callback only if the device link sees both the caller and potential callback callee; you cannot pass an address from one device executable to another, as those are separate address spaces).\n6.5.\nOptimization Of Separate Compilation\n\nSeparately compiled code may not have as high of performance as whole program code because of the inability to inline code across files. A way to still get optimal performance is to use link-time optimization, which stores intermediate code which is then linked together to perform high level optimizations. This can be done with the\n--dlink-time-opt\nor\n-dlto\noption. This option must be specified at both compile and link time. If only some of the files are compiled with\n-dlto\n, then those will be linked and optimized together while the rest uses the normal separate compilation. A side effect is that this shifts some of the compile time to the link phase, and there may be some scalability issues with really large codes. If you want to compile using\n-gencode\nto build for multiple arch, use\n-dc\n-gencode\narch=compute_NN,code=lto_NN\nto specify the intermediate IR to be stored (where\nNN\nis the SM architecture version). Then use\n-dlto\noption to link for a specific architecture.\nAs of CUDA 12.0 there is support for runtime LTO via the\nnvJitLink\nlibrary.\n6.6.\nPotential Separate Compilation Issues\n\n6.6.1.\nObject Compatibility\n\nOnly relocatable device code with the same ABI version, link-compatible SM target architecture, and same pointer size (32 or 64) can be linked together. The toolkit version of the linker must be >= the toolkit version of the objects. Incompatible objects will produce a link error. Link-compatible SM architectures are ones that have compatible SASS binaries that can combine without translating, e.g. sm_86 and sm_80. An object could have been compiled for a different architecture but also have PTX available, in which case the device linker will JIT the PTX to cubin for the desired architecture and then link.\nIf Link Time Optimization is used with\n-dlto\n, the intermediate LTOIR is only guaranteed to be compatible within a major release (e.g. can link together 12.0 and 12.1 LTO intermediates, but not 12.1 and 11.6).\nIf a kernel is limited to a certain number of registers with the\nlaunch_bounds\nattribute or the\n--maxrregcount\noption, then all functions that the kernel calls must not use more than that number of registers; if they exceed the limit, then a link error will be given.\n6.6.2.\nJIT Linking Support\n\nJIT linking means doing an implicit relink of the code at load time. If the cubin does not match the target architecture at load time, the driver re-invokes the device linker to generate cubin for the target architecture, by first JIT’ing the PTX for each object to the appropriate cubin, and then linking together the new cubin. If PTX or cubin for the target architecture is not found for an object, then the link will fail. Implicit JIT linking of the LTO intermediates is not supported at this time, although they can be explicitly linked with the\nnvJitLink\nlibrary.\n6.6.3.\nImplicit CUDA Host Code\n\nA file like\nb.cu\nabove only contains CUDA device code, so one might think that the b.o object doesn’t need to be passed to the host linker. But actually there is implicit host code generated whenever a device symbol can be accessed from the host side, either via a launch or an API call like\ncudaGetSymbolAddress()\n. This implicit host code is put into\nb.o\n, and needs to be passed to the host linker. Plus, for JIT linking to work all device code must be passed to the host linker, else the host executable will not contain device code needed for the JIT link. So a general rule is that the device linker and host linker must see the same host object files (if the object files have any device references in them—if a file is pure host then the device linker doesn’t need to see it). If an object file containing device code is not passed to the host linker, then you will see an error message about the function\n__cudaRegisterLinkedBinary_name\ncalling an undefined or unresolved symbol\n__fatbinwrap_name\n.\n6.6.4.\nUsing __CUDA_ARCH__\n\nIn separate compilation,\n__CUDA_ARCH__\nmust not be used in headers such that different objects could contain different behavior. Or, it must be guaranteed that all objects will compile for the same compute_arch. If a weak function or template function is defined in a header and its behavior depends on\n__CUDA_ARCH__\n, then the instances of that function in the objects could conflict if the objects are compiled for different compute arch. For example, if an a.h contains:\ntemplate\n<\ntypename\nT\n>\n__device__\nT\n*\ngetptr\n(\nvoid\n)\n{\n#if __CUDA_ARCH__ == 800\nreturn\nNULL\n;\n/* no address */\n#else\n__shared__\nT\narr\n[\n256\n];\nreturn\narr\n;\n#endif\n}\nThen if a.cu and b.cu both include a.h and instantiate\ngetptr\nfor the same type, and b.cu expects a non-NULL address, and compile with:\nnvcc --gpu-architecture=compute_80 --device-c a.cu\nnvcc --gpu-architecture=compute_86 --device-c b.cu\nnvcc --gpu-architecture=sm_86 a.o b.o\nAt link time only one version of the getptr is used, so the behavior would depend on which version is picked. To avoid this, either a.cu and b.cu must be compiled for the same compute arch, or\n__CUDA_ARCH__\nshould not be used in the shared header function.\n6.6.5.\nDevice Code in Libraries\n\nIf a device function with non-weak external linkage is defined in a library as well as a non-library object (or another library), the device linker will complain about the multiple definitions (this differs from traditional host linkers that may ignore the function definition from the library object, if it was already found in an earlier object).\n7.\nMiscellaneous NVCC Usage\n\n7.1.\nCross Compilation\n\nCross compilation is controlled by using the following\nnvcc\ncommand line option:\n--compiler-bindir\nis used for cross compilation, where the underlying host compiler is capable of generating objects for the target platform.\nOn an x86 system, if a CUDA toolkit installation has been configured to support cross compilation to both Tegra and non-Tegra ARM targets, then\nnvcc\nwill use the non-Tegra configuration by default, when an ARM host cross compiler has been specified. To use the Tegra configuration instead, pass “\n-target-dir\naarch64-linux\n” to nvcc.\n7.2.\nKeeping Intermediate Phase Files\n\nnvcc\nstores intermediate results by default into temporary files that are deleted immediately before it completes. The location of the temporary file directories used are, depending on the current platform, as follows:\nWindows\nValue of environment variable\nTEMP\nis used. If it is not set,\nC:\\Windows\\temp\nis used instead.\nOther Platforms\nValue of environment variable\nTMPDIR\nis used. If it is not set,\n/tmp\nis used instead.\nOption\n--keep\nmakes\nnvcc\nstore these intermediate files in the current directory or in the directory specified by\n--keep-dir\ninstead, with names as described in\nSupported Phases\n.\n7.3.\nCleaning Up Generated Files\n\nAll files generated by a particular\nnvcc\ncommand can be cleaned up by repeating the command, but with additional option\n--clean-targets\n. This option is particularly useful after using\n--keep\n, because the\n--keep\noption usually leaves quite an amount of intermediate files around.\nBecause using\n--clean-targets\nwill remove exactly what the original\nnvcc\ncommand created, it is important to exactly repeat all of the options in the original command. For instance, in the following example, omitting\n--keep\n, or adding\n--compile\nwill have different cleanup effects.\nnvcc acos.cu --keep\nnvcc acos.cu --keep --clean-targets\n7.4.\nPrinting Code Generation Statistics\n\nA summary on the amount of used registers and the amount of memory needed per compiled device function can be printed by passing option\n--resource-usage\nto\nnvcc\n:\n$ nvcc --resource-usage acos.cu -arch sm_80\nptxas info    : 1536 bytes gmem\nptxas info    : Compiling entry function 'acos_main' for 'sm_80'\nptxas info    : Function properties for acos_main\n0 bytes stack frame, 0 bytes spill stores, 0 bytes spill loads\nptxas info    : Used 6 registers, 1536 bytes smem, 32 bytes cmem[0]\nAs shown in the above example, the amount of statically allocated global memory (gmem) is listed.\nGlobal memory and some of the constant banks are module scoped resources and not per kernel resources. Allocation of constant variables to constant banks is profile specific.\nFollowed by this, per kernel resource information is printed.\nStack frame is per thread stack usage used by this function. Spill stores and loads represent stores and loads done on stack memory which are being used for storing variables that couldn’t be allocated to physical registers.\nSimilarly number of registers, amount of shared memory and total space in constant bank allocated is shown.\n8.\nNotices\n\n8.1.\nNotice\n\nThis document is provided for information purposes only and shall not be regarded as a warranty of a certain functionality, condition, or quality of a product. NVIDIA Corporation (“NVIDIA”) makes no representations or warranties, expressed or implied, as to the accuracy or completeness of the information contained in this document and assumes no responsibility for any errors contained herein. NVIDIA shall have no liability for the consequences or use of such information or for any infringement of patents or other rights of third parties that may result from its use. This document is not a commitment to develop, release, or deliver any Material (defined below), code, or functionality.\nNVIDIA reserves the right to make corrections, modifications, enhancements, improvements, and any other changes to this document, at any time without notice.\nCustomer should obtain the latest relevant information before placing orders and should verify that such information is current and complete.\nNVIDIA products are sold subject to the NVIDIA standard terms and conditions of sale supplied at the time of order acknowledgement, unless otherwise agreed in an individual sales agreement signed by authorized representatives of NVIDIA and customer (“Terms of Sale”). NVIDIA hereby expressly objects to applying any customer general terms and conditions with regards to the purchase of the NVIDIA product referenced in this document. No contractual obligations are formed either directly or indirectly by this document.\nNVIDIA products are not designed, authorized, or warranted to be suitable for use in medical, military, aircraft, space, or life support equipment, nor in applications where failure or malfunction of the NVIDIA product can reasonably be expected to result in personal injury, death, or property or environmental damage. NVIDIA accepts no liability for inclusion and/or use of NVIDIA products in such equipment or applications and therefore such inclusion and/or use is at customer’s own risk.\nNVIDIA makes no representation or warranty that products based on this document will be suitable for any specified use. Testing of all parameters of each product is not necessarily performed by NVIDIA. It is customer’s sole responsibility to evaluate and determine the applicability of any information contained in this document, ensure the product is suitable and fit for the application planned by customer, and perform the necessary testing for the application in order to avoid a default of the application or the product. Weaknesses in customer’s product designs may affect the quality and reliability of the NVIDIA product and may result in additional or different conditions and/or requirements beyond those contained in this document. NVIDIA accepts no liability related to any default, damage, costs, or problem which may be based on or attributable to: (i) the use of the NVIDIA product in any manner that is contrary to this document or (ii) customer product designs.\nNo license, either expressed or implied, is granted under any NVIDIA patent right, copyright, or other NVIDIA intellectual property right under this document. Information published by NVIDIA regarding third-party products or services does not constitute a license from NVIDIA to use such products or services or a warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual property rights of the third party, or a license from NVIDIA under the patents or other intellectual property rights of NVIDIA.\nReproduction of information in this document is permissible only if approved in advance by NVIDIA in writing, reproduced without alteration and in full compliance with all applicable export laws and regulations, and accompanied by all associated conditions, limitations, and notices.\nTHIS DOCUMENT AND ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, “MATERIALS”) ARE BEING PROVIDED “AS IS.” NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL NVIDIA BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Notwithstanding any damages that customer might incur for any reason whatsoever, NVIDIA’s aggregate and cumulative liability towards customer for the products described herein shall be limited in accordance with the Terms of Sale for the product.\n8.2.\nOpenCL\n\nOpenCL is a trademark of Apple Inc. used under license to the Khronos Group Inc.\n8.3.\nTrademarks\n\nNVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated.", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html"}}
{"text": "1. Preparing An Application For Profiling — Profiler 12.9 documentation\n»\n1.\nPreparing An Application For Profiling\nv12.9 |\nPDF\n|\nArchive\nProfiler User’s Guide\nThe user manual for NVIDIA profiling tools for optimizing performance of CUDA applications.\nProfiling Overview\nThis document describes NVIDIA profiling tools that enable you to understand and optimize the performance of your CUDA, OpenACC or OpenMP applications. The\nVisual Profiler\nis a graphical profiling tool that displays a timeline of your application’s CPU and GPU activity, and that includes an automated analysis engine to identify optimization opportunities. The\nnvprof\nprofiling tool enables you to collect and view profiling data from the command-line.\nNote that Visual Profiler and nvprof are deprecated and will be removed in a future CUDA release.\nThe NVIDIA Volta platform is the last architecture on which these tools are fully supported. It is recommended to use next-generation tools\nNVIDIA Nsight Systems\nfor GPU and CPU sampling and tracing and\nNVIDIA Nsight Compute\nfor GPU kernel profiling.\nRefer the\nMigrating to Nsight Tools from Visual Profiler and nvprof\nsection for more details.\nTerminology\nAn\nevent\nis a countable activity, action, or occurrence on a device. It corresponds to a single hardware counter value which is collected during kernel execution. To see a list of all available events on a particular NVIDIA GPU, type\nnvprof\n--query-events\n.\nA\nmetric\nis a characteristic of an application that is calculated from one or more event values. To see a list of all available metrics on a particular NVIDIA GPU, type\nnvprof\n--query-metrics\n. You can also refer to the\nmetrics reference\n.\n1.\nPreparing An Application For Profiling\n\nThe CUDA profiling tools do not require any application changes to enable profiling; however, by making some simple modifications and additions, you can greatly increase the usability and effectiveness profiling. This section describes these modifications and how they can improve your profiling results.\n1.1.\nFocused Profiling\n\nBy default, the profiling tools collect profile data over the entire run of your application. But, as explained below, you typically only want to profile the region(s) of your application containing some or all of the performance-critical code. Limiting profiling to performance-critical regions reduces the amount of profile data that both you and the tools must process, and focuses attention on the code where optimization will result in the greatest performance gains.\nThere are several common situations where profiling a region of the application is helpful.\nThe application is a test harness that contains a CUDA implementation of all or part of your algorithm. The test harness initializes the data, invokes the CUDA functions to perform the algorithm, and then checks the results for correctness. Using a test harness is a common and productive way to quickly iterate and test algorithm changes. When profiling, you want to collect profile data for the CUDA functions implementing the algorithm, but not for the test harness code that initializes the data or checks the results.\nThe application operates in phases, where a different set of algorithms is active in each phase. When the performance of each phase of the application can be optimized independently of the others, you want to profile each phase separately to focus your optimization efforts.\nThe application contains algorithms that operate over a large number of iterations, but the performance of the algorithm does not vary significantly across those iterations. In this case you can collect profile data from a subset of the iterations.\nTo limit profiling to a region of your application, CUDA provides functions to start and stop profile data collection.\ncudaProfilerStart()\nis used to start profiling and\ncudaProfilerStop()\nis used to stop profiling (using the CUDA driver API, you get the same functionality with\ncuProfilerStart()\nand\ncuProfilerStop()\n). To use these functions you must include\ncuda_profiler_api.h\n(or\ncudaProfiler.h\nfor the driver API).\nWhen using the start and stop functions, you also need to instruct the profiling tool to disable profiling at the start of the application. For\nnvprof\nyou do this with the\n--profile-from-start\noff\nflag. For the Visual Profiler you use the Start execution with profiling enabled checkbox in the\nSettings View\n.\n1.2.\nMarking Regions of CPU Activity\n\nThe Visual Profiler can collect a trace of the CUDA function calls made by your application. The Visual Profiler shows these calls in the\nTimeline View\n, allowing you to see where each CPU thread in the application is invoking CUDA functions. To understand what the application’s CPU threads are doing outside of CUDA function calls, you can use the\nNVIDIA Tools Extension API\n(NVTX). When you add NVTX markers and ranges to your application, the\nTimeline View\nshows when your CPU threads are executing within those regions.\nnvprof\nalso supports NVTX markers and ranges. Markers and ranges are shown in the API trace output in the timeline. In summary mode, each range is shown with CUDA activities associated with that range.\n1.3.\nNaming CPU and CUDA Resources\n\nThe Visual Profiler\nTimeline View\nshows default naming for CPU thread and GPU devices, context and streams. Using custom names for these resources can improve understanding of the application behavior, especially for CUDA applications that have many host threads, devices, contexts, or streams. You can use the\nNVIDIA Tools Extension API\nto assign custom names for your CPU and GPU resources. Your custom names will then be displayed in the\nTimeline View\n.\nnvprof\nalso supports NVTX naming. Names of CUDA devices, contexts and streams are displayed in summary and trace mode. Thread names are displayed in summary mode.\n1.4.\nFlush Profile Data\n\nTo reduce profiling overhead, the profiling tools collect and record profile information into internal buffers. These buffers are then flushed asynchronously to disk with low priority to avoid perturbing application behavior. To avoid losing profile information that has not yet been flushed, the application being profiled should make sure, before exiting, that all GPU work is done (using CUDA synchronization calls), and then call\ncudaProfilerStop()\nor\ncuProfilerStop()\n. Doing so forces buffered profile information on corresponding context(s) to be flushed.\nIf your CUDA application includes graphics that operate using a display or main loop, care must be taken to call\ncudaProfilerStop()\nor\ncuProfilerStop()\nbefore the thread executing that loop calls\nexit()\n. Failure to call one of these APIs may result in the loss of some or all of the collected profile data.\nFor some graphics applications like the ones use OpenGL, the application exits when the escape key is pressed. In those cases where calling the above functions before exit is not feasible, use\nnvprof\noption\n--timeout\nor set the “Execution timeout” in the Visual Profiler. The profiler will force a data flush just before the timeout.\n1.5.\nProfiling CUDA Fortran Applications\n\nCUDA Fortran applications compiled with the PGI CUDA Fortran compiler can be profiled by nvprof and the Visual Profiler. In cases where the profiler needs source file and line information (kernel profile analysis, global memory access pattern analysis, divergent execution analysis, etc.), use the “-Mcuda=lineinfo” option when compiling. This option is supported on Linux 64-bit targets in PGI 2019 version 19.1 or later.\n2.\n​Visual Profiler\n\nThe NVIDIA Visual Profiler allows you to visualize and optimize the performance of your application. The Visual Profiler displays a timeline of your application’s activity on both the CPU and GPU so that you can identify opportunities for performance improvement. In addition, the Visual Profiler will analyze your application to detect potential performance bottlenecks and direct you on how to take action to eliminate or reduce those bottlenecks.\nThe Visual Profiler is available as both a standalone application and as part of Nsight Eclipse Edition. The standalone version of the Visual Profiler,\nnvvp\n, is included in the CUDA Toolkit for all supported OSes. Within Nsight Eclipse Edition, the Visual Profiler is located in the Profile Perspective and is activated when an application is run in profile mode.\n2.1.\nGetting Started\n\nThis section describes steps you might take as you begin profiling.\n2.1.1.\nSetting up Java Runtime Environment\n\nVisual Profiler requires Java Runtime Environment (JRE) 1.8 to be available on the local system. However, starting with CUDA Toolkit version 10.1 Update 2, the JRE is no longer included in the CUDA Toolkit due to Oracle upgrade licensing changes. The user must install the required version of JRE 1.8 in order to use Visual Profiler. See\nInstalling JRE\n.\nTo run Visual Profiler on OpenSUSE15 or SLES15:\nMake sure that you invoke Visual Profiler with the command-line option included as shown below:\nnvvp -vm /usr/lib64/jvm/jre-1.8.0/bin/java\nNote\nThe\n-vm\noption is only required when JRE 1.8 is not in the default path.\nTo run Visual Profiler on Ubuntu 18.04 or Ubuntu 18.10:\nMake sure that you invoke Visual Profiler with the command-line option included as shown below:\nnvvp -vm /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java\nNote\nThe\n-vm\noption is only required when JRE 1.8 is not in the default path.\nOn Ubuntu 18.10, if you get error “\nno\nswt-pi-gtk\nin\njava.library.path\n” when running Visual Profiler, then you need to install GTK2. Type the below command to install the required GTK2.\napt-get install libgtk2.0-0\nTo run Visual Profiler on Fedora 29:\nMake sure that you invoke Visual Profiler with the command-line option included as shown below:\nnvvp -vm /usr/bin/java\nNote\nThe\n-vm\noption is only required when JRE 1.8 is not in the default path.\nTo run Visual Profiler on Windows:\nMake sure that you invoke Visual Profiler with the command-line option included as shown below:\nnvvp -vm \"C:\\Program Files\\Java\\jdk1.8.0_77\\jre\\bin\\java\"\nNote\nThe\n-vm\noption is only required when JRE 1.8 is not in the default path.\n2.1.2.\nInstalling JRE\n\nVisual Profiler require Java Runtime Environment (JRE) 1.8 to be available on the local system. However, as of CUDA Toolkit version 10.1 Update 2, the JRE is no longer included in the CUDA Toolkit due to Oracle upgrade licensing changes. The user must install JRE 1.8 in order to use Visual Profiler. See below for available options. Also see\nJava Platform, Standard Edition 8 Names and Versions.\nWindows\nOracle JRE 1.8 (may require paid updates)\nOpenJDK JRE 1.8\nLinux\nOracle JRE 1.8 (may require paid updates)\nOpenJDK JRE 1.8\nNote\nJRE 1.8u152 or later is not supported for Visual Profiler. You can find the JRE update 151 on the Oracle Download Archive site here:\nhttps://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html?printOnly=1\n.\n2.1.3.\nModify Your Application For Profiling\n\nThe Visual Profiler does not require any application changes; however, by making some simple modifications and additions, you can greatly increase its usability and effectiveness. Section\nPreparing An Application For Profiling\ndescribes how you can focus your profiling efforts and add extra annotations to your application that will greatly improve your profiling experience.\n2.1.4.\nCreating a Session\n\nThe first step in using the Visual Profiler to profile your application is to create a new profiling session. A session contains the settings, data, and results associated with your application. The\nSessions\nsection gives more information on working with sessions.\nYou can create a new session by selecting the Profile An Application link on the Welcome page, or by selecting New Session from the File menu. In the Create New Session dialog enter the executable for your application. Optionally, you can also specify the working directory, arguments, multi-process profiling option and environment.\nThe muti-process profiling options are:\nProfile child processes - If selected, profile all processes launched by the specified application.\nProfile all processes - If selected, profile every CUDA process launched on the same system by the same user who launched nvprof. In this mode the Visual Profiler will launch nvprof and user needs to run his application in another terminal outside the Visual Profiler. User can exit this mode by pressing “Cancel” button on progress dialog in Visual Profiler to load the profile data\nProfile current process only - If selected, only profile specified application.\nPress Next to choose some additional profiling options.\nCUDA options:\nStart execution with profiling enabled - If selected profile data is collected from the start of application execution. If not selected profile data is not collected until\ncudaProfilerStart()\nis called in the application. See\nFocused Profiling\nfor more information about\ncudaProfilerStart()\n.\nEnable concurrent kernel profiling - This option should be selected for an application that uses CUDA streams to launch kernels that can execute concurrently. If the application uses only a single stream (and therefore cannot have concurrent kernel execution), deselecting this option may decrease profiling overhead.\nEnable CUDA API tracing in the timeline - If selected, the CUDA driver and runtime API call trace is collected and displayed on timeline.\nEnable power, clock, and thermal profiling - If selected, power, clock, and thermal conditions on the GPUs will be sampled and displayed on the timeline. Collection of this data is not supported on all GPUs. See the description of the Device timeline in\nTimeline View\nfor more information.\nEnable unified memory profiling - If selected for the GPU that supports Unified Memory, the Unified Memory related memory traffic to and from each GPU is collected on your system and displayed on timeline.\nReplay application to collect events and metrics - If selected, the whole application is re-run instead of replaying each kernel, in order to collect all events/metrics.\nRun guided analysis - If selected, the guided analysis is run immediately after the creation of a new session. Uncheck this option to disable this behavior.\nCPU (host) options:\nProfile execution on the CPU - If selected the CPU threads are sampled and data collected about the CPU performance is shown in the\nCPU Details View\n.\nEnable OpenACC profiling - If selected and an OpenACC application is profiled, OpenACC activities will be recorded and displayed on a new OpenACC timeline. Collection of this data is only supported on Linux and PGI 19.1 or later. See the description of the OpenACC timeline in\nTimeline View\nfor more information.\nEnable CPU thread tracing - If enabled, selected CPU thread API calls will be recorded and displayed on a new thread API timeline. This currently includes the Pthread API, mutexes and condition variables. For performance reasons, only those API calls that influence concurrent execution are recorded and collection of this data is not supported on Windows. See the description of the thread timeline in\nTimeline View\nfor more information. This option should be selected for dependency analysis of applications with multiple CPU threads using CUDA.\nTimeline Options:\nLoad data for time range - If selected the start and end time stamps for the range of data to be loaded can be specified. This option is useful to select a subset of a large data.\nEnable timelines in the session - By default all timelines are enabled. If a timeline is un-checked, the data associated with that timeline will not be loaded and it will not be displayed.\nNote\nIf some timelines are disabled by un-checking the option the analyses results which use this timeline data will be incorrect.\nPress Finish.\n2.1.5.\nAnalyzing Your Application\n\nIf the Don’t run guided analysis option was not selected when you created your session, the Visual Profiler will immediately run your application to collect the data needed for the first stage of guided analysis. As described in the\nAnalysis View\nsection, you can use the guided analysis system to get recommendations on performance limiting behavior in your application.\n2.1.6.\nExploring the Timeline\n\nIn addition to the guided analysis results, you will see a timeline for your application showing the CPU and GPU activity that occurred as your application executed. Read\nTimeline View\nand\nProperties View\nto learn how to explore the profiling information that is available in the timeline.\nNavigating the Timeline\ndescribes how you can zoom and scroll the timeline to focus on specific areas of your application.\n2.1.7.\nLooking at the Details\n\nIn addition to the results provided in the\nAnalysis View\n, you can also look at the specific metric and event values collected as part of the analysis. Metric and event values are displayed in the\nGPU Details View\n. You can collect specific metric and event values that reveal how the kernels in your application are behaving. You collect metrics and events as described in the\nGPU Details View\nsection.\n2.1.8.\nImprove Loading of Large Profiles\n\nSome applications launch many tiny kernels, making them prone to very large (100s of megabytes or larger) output, even for application runs of only a few seconds. The Visual Profiler needs roughly the same amount of memory as the size of the profile it is opening/importing. The Java virtual machine may use a fraction of the main memory if no “max heap size” setting is specified. So depending on the size of main memory, the Visual Profiler may fail to load some large files.\nIf the Visual Profiler fails to load a large profile, try setting the max heap size that JVM is allowed to use according to main memory size. You can modify the config file\nlibnvvp/nvvp.ini\nin the toolkit installation directory. The\nnvvp.ini\nconfiguration file looks like this:\n-startup\nplugins/org.eclipse.equinox.launcher_1.3.0.v20140415-2008.jar\n--launcher.library\nplugins/org.eclipse.equinox.launcher.gtk.linux.x86_64_1.1.200.v20140603-1326\n-data\n@user.home/nvvp_workspace\n-vm\n../jre/bin/java\n-vmargs\n-Dorg.eclipse.swt.browser.DefaultType=mozilla\nTo force the JVM to use 3 gigabytes of memory, for example, add a new line with\n‑Xmx3G\nafter\n‑vmargs\n. The -Xmx setting should be tailored to the available system memory and input size. For example, if your system has 24GB of system memory, and you happen to know that you won’t need to run any other memory-intensive applications at the same time as the Visual Profiler, so it’s okay for the profiler to take up the vast majority of that space. So you might pick, say, 22GB as the maximum heap size, leaving a few gigabytes for the OS, GUI, and any other programs that might be running.\nSome other\nnvvp.ini\nconfiguration settings can also be modified:\nIncrease the default heap size (the one Java automatically starts up with) to, say, 2GB. (\n-Xms\n)\nTell Java to run in 64-bit mode instead of the default 32-bit mode (only works on 64-bit systems); this is required if you want heap sizes >4GB. (\n-d64\n)\nEnable Javas parallel garbage collection system, which helps both to decrease the required memory space for a given input size as well as to catch out of memory errors more gracefully. (\n-XX:+UseConcMarkSweepGC\n-XX:+CMSIncrementalMode\n)\nNote: most installations require administrator/root-level access to modify this file.\nThe modified\nnvvp.ini\nfile as per examples given above is as follows:\n-data\n@user.home/nvvp_workspace\n-vm\n../jre/bin/java\n-d64\n-vmargs\n-Xms2g\n-Xmx22g\n-XX:+UseConcMarkSweepGC\n-XX:+CMSIncrementalMode\n-Dorg.eclipse.swt.browser.DefaultType=Mozilla\nFor more details on JVM settings, consult the Java virtual machine manual.\nIn addition to this you can use timeline options Load data for time range and Enable timelines in the session mentioned in the\nCreating a Session\nsection to limit the data which is loaded and displayed.\n2.2.\nSessions\n\nA session contains the settings, data, and profiling results associated with your application. Each session is saved in a separate file; so you can delete, move, copy, or share a session by simply deleting, moving, copying, or sharing the session file. By convention, the file extension\n.nvvp\nis used for Visual Profiler session files.\nThere are two types of sessions: an executable session that is associated with an application that is executed and profiled from within the Visual Profiler, and an import session that is created by importing data generated by\nnvprof\n.\n2.2.1.\nExecutable Session\n\nYou can create a new executable session for your application by selecting the Profile An Application link on the Welcome page, or by selecting New Session from the File menu. Once a session is created, you can edit the session’s settings as described in the\nSettings View\n.\nYou can open and save existing sessions using the open and save options in the File menu.\nTo analyze your application and to collect metric and event values, the Visual Profiler will execute your application multiple times. To get accurate profiling results, it is important that your application conform to the requirements detailed in\nApplication Requirements\n.\n2.2.2.\nImport Session\n\nYou create an import session from the output of nvprof by using the Import… option in the File menu. Selecting this option opens the import dialog which guides you through the import process.\nBecause an executable application is not associated with an import session, the Visual Profiler cannot execute the application to collect additional profile data. As a result, analysis can only be performed with the data that is imported. Also, the\nGPU Details View\nwill show any imported event and metrics values but new metrics and events cannot be selected and collected for the import session.\n2.2.2.1.\nImport Single-Process\nnvprof\nSession\n\nUsing the import dialog you can select one or more\nnvprof\ndata files for import into the new session.\nYou must have one\nnvprof\ndata file that contains the timeline information for the session. This data file should be collected by running nvprof with the\n--export-profile\noption. You can optionally enable other options such as\n--system-profiling\non\n, but you should not collect any events or metrics as that will distort the timeline so that it is not representative of the applications true behavior.\nYou may optionally specify one or more event/metric data files that contain event and metric values for the application. These data files should be collected by running nvprof with one or both of the\n--events\nand\n--metrics\noptions. To collect all the events and metrics that are needed for the analysis system, you can simply use the\n--analysis-metrics\noption along with the\n--kernels\noption to select the kernel(s) to collect events and metrics for. See\nRemote Profiling\nfor more information.\nIf you are importing multiple\nnvprof\noutput files into the session, it is important that your application conform to the requirements detailed in\nApplication Requirements\n.\n2.2.2.2.\nImport Multi-Process\nnvprof\nSession\n\nUsing the import wizard you can select multiple\nnvprof\ndata files for import into the new multi-process session.\nEach\nnvprof\ndata file must contain the timeline information for one of the processes. This data file should be collected by running nvprof with the\n--export-profile\noption. You can optionally enable other options such as\n--system-profiling\non\n, but you should not collect any events or metrics as that will distort the timeline so that it is not representative of the applications true behavior.\nSelect the Multiple Processes option in the Import nvprof Data dialog as shown in the figure below.\nWhen importing timeline data from multiple processes you may not specify any event/metric data files for those processes. Multi-processes profiling is only supported for timeline data.\n2.2.2.3.\nImport Command-Line Profiler Session\n\nSupport for command-line profiler (using the environment variable COMPUTE_PROFILE) has been dropped, but CSV files generated using earlier versions can still be imported.\nUsing the import wizard you can select one or more command-line profiler generated CSV files for import into the new session. When you import multiple CSV files, their contents are combined and displayed in a single timeline.\nThe command-line profiler CSV file must be generated with the gpustarttimestamp and streamid configuration parameters. It is fine to include other configuration parameters, including events.\n2.3.\nApplication Requirements\n\nTo collect performance data about your application, the Visual Profiler must be able to execute your application repeatedly in a deterministic manner. Due to software and hardware limitations, it is not possible to collect all the necessary profile data in a single execution of your application. Each time your application is run, it must operate on the same data and perform the same kernel and memory copy invocations in the same order. Specifically,\nFor a device, the order of context creation must be the same each time the application executes. For a multi-threaded application where each thread creates its own context(s), care must be taken to ensure that the order of those context creations is consistent across multiple runs. For example, it may be necessary to create the contexts on a single thread and then pass the contexts to the other threads. Alternatively, the\nNVIDIA Tools Extension API\ncan be used to provide a custom name for each context. As long as the same custom name is applied to the same context on each execution of the application, the Visual Profiler will be able to correctly associate those contexts across multiple runs.\nFor a context, the order of stream creation must be the same each time the application executes. Alternatively, the\nNVIDIA Tools Extension API\ncan be used to provide a custom name for each stream. As long as the same custom name is applied to the same stream on each execution of the application, the Visual Profiler will be able to correctly associate those streams across multiple runs.\nWithin a stream, the order of kernel and memcpy invocations must be the same each time the application executes.\n2.4.\nVisual Profiler Views\n\nThe Visual Profiler is organized into views. Together, the views allow you to analyze and visualize the performance of your application. This section describes each view and how you use it while profiling your application.\n2.4.1.\nTimeline View\n\nThe Timeline View shows CPU and GPU activity that occurred while your application was being profiled. Multiple timelines can be opened in the Visual Profiler at the same time in different tabs. The following figure shows a Timeline View for a CUDA application.\nAlong the top of the view is a horizontal ruler that shows elapsed time from the start of application profiling. Along the left of the view is a vertical ruler that describes what is being shown for each horizontal row of the timeline, and that contains various controls for the timeline. These controls are described in\nTimeline Controls\nThe timeline view is composed of timeline rows. Each row shows intervals that represent the start and end times of the activities that correspond to the type of the row. For example, timeline rows representing kernels have intervals representing the start and end times of executions of that kernel. In some cases (as noted below) a timeline row can display multiple sub-rows of activity. Sub-rows are used when there is overlapping activity. These sub-rows are created dynamically as necessary depending on how much activity overlap there is. The placement of intervals within certain sub-rows does not convey any particular meaning. Intervals are just packed into sub-rows using a heuristic that attempts to minimize the number of needed sub-rows. The height of the sub-rows is scaled to keep vertical space reasonable.\nThe types of timeline rows that are displayed in the Timeline View are:\nProcess\nA timeline will contain a Process row for each application profiled. The process identifier represents the pid of the process. The timeline row for a process does not contain any intervals of activity. Threads within the process are shown as children of the process.\nThread\nA timeline will contain a Thread row for each CPU thread in the profiled application that performed either a CUDA driver or CUDA runtime API call. The thread identifier is a unique id for that CPU thread. The timeline row for a thread is does not contain any intervals of activity.\nRuntime API\nA timeline will contain a Runtime API row for each CPU thread that performs a CUDA Runtime API call. Each interval in the row represents the duration of the call on the corresponding thread.\nDriver API\nA timeline will contain a Driver API row for each CPU thread that performs a CUDA Driver API call. Each interval in the row represents the duration of the call on the corresponding thread.\nOpenACC\nA timeline will contain one or multiple OpenACC rows for each CPU thread that calls OpenACC directives. Each interval in the row represents the duration of the call on the corresponding thread. Each OpenACC timeline may consist of multiple rows. Within one timeline, OpenACC activities on rows further down are called from within activities on the rows above.\nOpenMP\nA timeline will contain one OpenMP row for each CPU thread that calls OpenMP. Each interval in the row represents how long the application spends in a given OpenMP region or state. The application may be in multiple states at the same time, this is shown by drawing multiple rows where some intervals overlap.\nPthread\nA timeline will contain one Pthread row for each CPU thread that performs Pthread API calls, given that host thread API calls have been recorded during measurement. Each interval in the row represents the duration of the call. Note that for performance reasons, only selected Pthread API calls may have been recorded.\nMarkers and Ranges\nA timeline will contain a single Markers and Ranges row for each CPU thread that uses the\nNVIDIA Tools Extension API\nto annotate a time range or marker. Each interval in the row represents the duration of a time range, or the instantaneous point of a marker. This row will have sub-rows if there are overlapping ranges.\nProfiling Overhead\nA timeline will contain a single Profiling Overhead row for each process. Each interval in the row represents the duration of execution of some activity required for profiling. These intervals represent activity that does not occur when the application is not being profiled.\nDevice\nA timeline will contain a Device row for each GPU device utilized by the application being profiled. The name of the timeline row indicates the device ID in square brackets followed by the name of the device. After running the Compute Utilization analysis, the row will contain an estimate of the compute utilization of the device over time. If power, clock, and thermal profiling are enabled, the row will also contain points representing those readings.\nUnified Memory\nA timeline will contain a Unified Memory row for each CPU thread and device that uses unified memory. The Unified memory may contain CPU Page Faults, GPU Page Faults, Data Migration (DtoH) and Data Migration (HtoD) rows. When creating a session user can select segment mode or non-segment mode for Unified Memory timelines. In the segment mode the timeline is split into equal width segments and only aggregated data values for each time segment are shown. The number of segments can be changed. In non-segment mode each interval on the timeline will represent the actual data collected and the properties for each interval can be viewed. The segments are colored using a heat-map color scheme. Under properties for the timeline the property which is used for selecting the color is given and also a legend displays the mapping of colors to different range of property values.\nCPU Page Faults\nThis will contain a CPU Page Faults row for each CPU thread. In the non-segment mode each interval on the timeline corresponds to one CPU page fault.\nData Migration (DtoH)\nA timeline will contain Data Migration (DtoH) row for each device. In the non-segment mode each interval on the timeline corresponds to one data migration from device to host.\nGPU Page Faults\nA timeline will contain GPU Page Faults. row for each CPU thread. In the non-segment mode each interval on the timeline corresponds to one GPU page fault group.\nData Migration (DtoH)\nA timeline will contain Data Migration (HtoD) row for each device. In the non-segment mode each interval on the timeline corresponds to one data migration from host to device.\nContext\nA timeline will contains a Context row for each CUDA context on a GPU device. The name of the timeline row indicates the context ID or the custom context name if the\nNVIDIA Tools Extension API\nwas used to name the context. The row for a context does not contain any intervals of activity.\nMemcpy\nA timeline will contain memory copy row(s) for each context that performs memcpys. A context may contain up to four memcpy rows for device-to-host, host-to-device, device-to-device, and peer-to-peer memory copies. Each interval in a row represents the duration of a memcpy executing on the GPU.\nCompute\nA timeline will contain a Compute row for each context that performs computation on the GPU. Each interval in a row represents the duration of a kernel on the GPU device. The Compute row indicates all the compute activity for the context. Sub-rows are used when concurrent kernels are executed on the context. All kernel activity, including kernels launched using CUDA Dynamic Parallelism, is shown on the Compute row. The Kernel rows following the Compute row show activity of each individual application kernel.\nKernel\nA timeline will contain a Kernel row for each kernel executed by the application. Each interval in a row represents the duration of execution of an instance of that kernel in the containing context. Each row is labeled with a percentage that indicates the total execution time of all instances of that kernel compared to the total execution time of all kernels. For each context, the kernels are ordered top to bottom by this execution time percentage. Sub-rows are used to show concurrent kernel execution. For CUDA Dynamic Parallelism applications, the kernels are organized in a hierarchy that represents the parent/child relationship between the kernels. Host-launched kernels are shown as direct children of the Context row. Kernels that use CUDA Dynamic Parallelism to launch other kernels can be expanded using the ‘+’ icon to show the kernel rows representing those child kernels. For kernels that don’t launch child kernels, the kernel execution is represented by a solid interval, showing the time that that instance of the kernel was executing on the GPU. For kernels that launch child kernels, the interval can also include a hollow part at the end. The hollow part represents the time after the kernel has finished executing where it is waiting for child kernels to finish executing. The CUDA Dynamic Parallelism execution model requires that a parent kernel not complete until all child kernels complete and this is what the hollow part is showing. The Focus control described in\nTimeline Controls\ncan be used to control display of the parent/child timelines.\nStream\nA timeline will contain a Stream row for each stream used by the application (including both the default stream and any application created streams). Each interval in a Stream row represents the duration of a memcpy or kernel execution performed on that stream.\n2.4.1.1.\nTimeline Controls\n\nThe\nTimeline View\nhas several controls that you use to control how the timeline is displayed. Some of these controls also influence the presentation of data in the\nGPU Details View\nand the\nAnalysis View\n.\nResizing the Vertical Timeline Ruler\nThe width of the vertical ruler can be adjusted by placing the mouse pointer over the right edge of the ruler. When the double arrow pointer appears, click and hold the left mouse button while dragging. The vertical ruler width is saved with your session.\nReordering Timelines\nThe Kernel and Stream timeline rows can be reordered. You may want to reorder these rows to aid in visualizing related kernels and streams, or to move unimportant kernels and streams to the bottom of the timeline. To reorder a row, left-click and hold onto the row label. When the double arrow pointer appears, drag up or down to position the row. The timeline ordering is saved with your session.\nFiltering Timelines\nMemcpy and Kernel rows can be filtered to exclude their activities from presentation in the\nGPU Details View\nand the\nAnalysis View\n. To filter out a row, left-click on the filter icon just to the left of the row label. To filter all Kernel or Memcpy rows, Shift-left-click one of the rows. When a row is filtered, any intervals on that row are dimmed to indicate their filtered status.\nExpanding and Collapsing Timelines\nGroups of timeline rows can be expanded and collapsed using the [+] and [-] controls just to the left of the row labels. There are three expand/collapse states:\nCollapsed\nNo timeline rows contained in the collapsed row are shown.\nExpanded\nAll non-filtered timeline rows are shown.\nAll-Expanded\nAll timeline rows, filtered and non-filtered, are shown.\nIntervals associated with collapsed rows may not be shown in the\nGPU Details View\nand the\nAnalysis View\n, depending on the filtering mode set for those views (see view documentation for more information). For example, if you collapse a device row, then all memcpys, memsets, and kernels associated with that device are excluded from the results shown in those views.\nColoring Timelines\nThere are three modes for timeline coloring. The coloring mode can be selected in the View menu, in the timeline context menu (accessed by right-clicking in the timeline view), and on the profiler toolbar. In kernel coloring mode, each type of kernel is assigned a unique color (that is, all activity intervals in a kernel row have the same color). In stream coloring mode, each stream is assigned a unique color (that is, all memcpy and kernel activity occurring on a stream are assigned the same color). In process coloring mode, each process is assigned a unique color (that is, all memcpy and kernel activity occurring in a process are assigned the same color).\nFocusing Kernel Timelines\nFor applications using CUDA Dynamic Parallelism, the\nTimeline View\ndisplays a hierarchy of kernel activity that shows the parent/child relationship between kernels. By default all parent/child relationships are shown simultaneously. The focus timeline control can be used to focus the displayed parent/child relationships to a specific, limited set of “family trees”. The focus timeline mode can be selected and deselected in the timeline context menu (accessed by right-clicking in the timeline view), and on the profiler toolbar.\nTo see the “family tree” of a particular kernel, select a kernel and then enable Focus mode. All kernels except those that are ancestors or descendants of the selected kernel will be hidden. Ctrl-select can be used to select multiple kernels before enabling Focus mode. Use the “Don’t Focus” option to disable focus mode and restore all kernels to the Timeline view.\nDependency Analysis Controls\nThere are two modes for visualizing dependency analysis results in the timeline: Focus Critical Path and Highlight Execution Dependencies. These modes can be selected in the View menu, in the timeline context menu (accessed by right-clicking in the timeline view), and on the Visual Profiler toolbar.\nThese options become available after the Dependency Analysis application analysis stage has been run (see\nUnguided Application Analysis\n). A detailed explanation of these modes is given in\nDependency Analysis Controls\n2.4.1.2.\nNavigating the Timeline\n\nThe timeline can be scrolled, zoomed, and focused in several ways to help you better understand and visualize your application’s performance.\nZooming\nThe zoom controls are available in the View menu, in the timeline context menu (accessed by right-clicking in the timeline view), and on the profiler toolbar. Zoom-in reduces the timespan displayed in the view, zoom-out increases the timespan displayed in the view, and zoom-to-fit scales the view so that the entire timeline is visible.\nYou can also zoom-in and zoom-out with the mouse wheel while holding the Ctrl key.\nAnother useful zoom mode is zoom-to-region. Select a region of the timeline by holding Ctrl while left-clicking and dragging the mouse. The highlighted region will be expanded to occupy the entire view when the mouse button is released.\nScrolling\nThe timeline can be scrolled vertically with the scrollbar of the mouse wheel. The timeline can be scrolled horizontally with the scrollbar or by using the mouse wheel while holding the Shift key.\nHighlighting/Correlation\nWhen you move the mouse pointer over an activity interval on the timeline, that interval is highlighted in all places where the corresponding activity is shown. For example, if you move the mouse pointer over an interval representing a kernel execution, that kernel execution is also highlighted in the Stream and in the Compute timeline row. When a kernel or memcpy interval is highlighted, the corresponding driver or runtime API interval will also highlight. This allows you to see the correlation between the invocation of a driver or runtime API or OpenACC directive on the CPU and the corresponding activity on the GPU. Information about the highlighted interval is shown in the\nProperties View\n.\nSelecting\nYou can left-click on a timeline interval or row to select it. Multi-select is done using Ctrl-left-click. To unselect an interval or row simply Ctrl-left-click on it again. When a single interval or row is selected, the information about that interval or row is pinned in the\nProperties View\n. In the\nGPU Details View\n, the detailed information for the selected interval is shown in the table.\nMeasuring Time Deltas\nMeasurement rulers can be created by left-click dragging in the horizontal ruler at the top of the timeline. Once a ruler is created it can be activated and deactivated by left-clicking. Multiple rulers can be activated by Ctrl-left-click. Any number of rulers can be created. Active rulers are deleted with the Delete or Backspace keys. After a ruler is created, it can be resized by dragging the vertical guide lines that appear over the timeline. If the mouse is dragged over a timeline interval, the guideline will snap to the nearest edge of that interval.\n2.4.1.3.\nTimeline Refreshing\n\nThe profiler loads the timeline gradually as it reads the data. This is more apparent if the data file being loaded is big, or the application has generated a lot of data. In such cases, the timeline may be partially rendered. At the same time, a spinning circle replaces the icon of the current session tab, indicating the timeline is not fully loaded. Loading is finished when the icon changes back.\nTo reduce its memory footprint, the profiler may skip loading some timeline contents if they are not visible at the current zoom level. These contents will be automatically loaded when they become visible on a new zoom level.\n2.4.1.4.\nDependency Analysis Controls\n\nThe profiler allows the visualization of dependency analysis results in the timeline once the respective analysis stage has been run. For a detailed description on how dependency analysis works, see\nDependency Analysis\n.\nFocus Critical Path visualizes the critical path through the application by focusing on all intervals on the critical path and fading others. When the mode is enabled and any timeline interval is selected (by left-clicking it), the selected interval will have focus. However, the critical path will still be visible as hollow intervals. This allows you to “follow” the critical path through the execution and to inspect individual intervals.\nHighlight Execution Dependencies allows you to analyze the execution dependencies for each interval (Note that for certain intervals, no dependency information is collected). When this mode is enabled, the highlighting color changes from yellow (representing correlated intervals) to red (representing dependencies). Both the selected interval as well as all incoming and outgoing dependencies are highlighted.\n2.4.2.\nAnalysis View\n\nThe Analysis View is used to control application analysis and to display the analysis results. There are two analysis modes: guided and unguided. In guided mode the analysis system will guide you through multiple analysis stages to help you understand the likely performance limiters and optimization opportunities in your application. In unguided mode you can manually explore all the analysis results collected for your application. The following figure shows the analysis view in guided analysis mode. The left part of the view provides step-by-step directions to help you analyze and optimize your application. The right part of the view shows detailed analysis results appropriate for each part of the analysis.\n2.4.2.1.\nGuided Application Analysis\n\nIn guided mode, the analysis view will guide you step-by-step through analysis of your entire application with specific analysis guidance provided for each kernel within your application. Guided analysis starts with CUDA Application Analysis and from there will guide you to optimization opportunities within your application.\n2.4.2.2.\nUnguided Application Analysis\n\nIn unguided analysis mode each application analysis stage has a Run analysis button that can be used to generate the analysis results for that stage. When the Run analysis button is selected, the profiler will execute the application to collect the profiling data needed to perform the analysis. The green check-mark next to an analysis stage indicates that the analysis results for that stage are available. Each analysis result contains a brief description of the analysis and a More… link to detailed documentation on the analysis. When you select an analysis result, the timeline rows or intervals associated with that result are highlighted in the\nTimeline View\n.\nWhen a single kernel instance is selected in the timeline, additional kernel-specific analysis stages are available. Each kernel-specific analysis stage has a Run analysis button that operates in the same manner as for the application analysis stages. The following figure shows the analysis results for the Divergent Execution analysis stage. Some kernel instance analysis results, like Divergent Execution, are associated with specific source-lines within the kernel. To see the source associated with each result, select an entry from the table. The source file associated with that entry will open.\n2.4.2.3.\nPC Sampling View\n\nDevices with compute capability 5.2 and higher, excluding mobile devices, have a feature for PC sampling. In this feature PC and state of warp are sampled at regular interval for one of the active warps per SM. The warp state indicates if that warp issued an instruction in a cycle or why it was stalled and could not issue an instruction. When a warp that is sampled is stalled, there is a possibility that in the same cycle some other warp is issuing an instruction. Hence the stall for the sampled warp need not necessarily indicate that there is a hole in the instruction issue pipeline. Refer to the\nWarp State\nsection for a description of different states.\nDevices with compute capability 6.0 and higher have a new feature that gives latency reasons. The latency samples indicate the reasons for holes in the issue pipeline. While collecting these samples, there is no instruction issued in the respective warp scheduler and hence these give the latency reasons. The latency reasons will be one of the stall reasons in\nWarp State\nsection except ‘not selected’ stall reason.\nThe profiler collects this information and presents it in the Kernel Profile - PC Sampling view. In this view, the sample distribution for all functions and kernels is given in a table. A pie chart shows the distribution of stall reasons collected for each kernel. After clicking on the source file or device function the Kernel Profile - PC Sampling view is opened. The hotspots shown next to the vertical scroll bar are determined by the number of samples collected for each source and assembly line. The distribution of the stall reasons is shown as a stacked bar for each source and assembly line. This helps in pinpointing the latency reasons at the source code level.\nFor devices with compute capability 6.0 and higher, Visual Profiler show two views: ‘Kernel Profile - PC Sampling’ which gives the warp state view and ‘Kernel Profile - PC Sampling - Latency’ which gives the latency reasons. Hotspots can be seleted to point to hotspot of ‘Warp State’ or ‘Latency Reasons’. The tables in result section give percentage distribution for total latency samples, issue pipeline busy samples and instruction issued samples.\nThe blog post\nPinpoint Performance Problems with Instruction-Level Profiling\nshows how PC Sampling can be used to optimize a CUDA kernel.\n2.4.2.4.\nMemory Statistics\n\nDevices with compute capability 5.0 and higher have a feature to show usage of the memory sub-system during kernel execution. The chart shows a summary view of the memory hierarchy of the CUDA programming model. The green nodes in the diagram depict logical memory space whereas blue nodes depicts actual hardware unit on the chip. For the various caches the reported percentage number states the cache hit rate; that is the ratio of requests that could be served with data locally available to the cache over all requests made.\nThe links between the nodes in the diagram depict the data paths between the SMs to the memory spaces into the memory system. Different metrics are shown per data path. The data paths from the SMs to the memory spaces (Global, Local, Texture, Surface and Shared) report the total number of memory instructions executed, it includes both read and write operations. The data path between memory spaces and “Unified Cache” or “Shared Memory” reports the total amount of memory requests made. All other data paths report the total amount of transferred memory in bytes. The arrow pointing to right direction indicates WRITE operation whereas the arrow pointing to left direction indicates the READ operations.\n2.4.2.5.\nNVLink view\n\nNVIDIA NVLink is a high-bandwidth, energy-efficient interconnect that enables fast communication between the CPU and GPU, and between GPUs.\nVisual Profiler collects NVLink topology and NVLink transmit/receive throughput metrics and maps the metrics on to the topology. The topology is collected by default along with the timeline. Throughput/ utilization metrics are generated only when NVLink option is chosen.\nNVLink information is presented in the Results section of Examine GPU Usage in CUDA Application Analysis in Guided Analysis. NVLink Analysis shows topology that shows the logical NVLink connections between different devices. A logical link comprises of 1 to 4 physical NVLinks of same properties connected between two devices. Visual profiler lists the properties and achieved utilization for logical NVLinks in ‘Logical NVLink Properties’ table. It also lists the transmit and receive throughputs for logical NVLink in ‘Logical NVLink Throughput’ table.\n2.4.3.\nSource-Disassembly View\n\nThe Source-Disassembly View is used to display the analysis results for a kernel at the source and assembly instruction level. To be able to view the kernel source you need to compile the code using the\n-lineinfo\noption. If this compiler option is not used, only the disassembly view will be shown.\nThis view is displayed for the following types of analysis:\nGlobal Memory Access Pattern Analysis\nShared Memory Access Pattern Analysis\nDivergent Execution Analysis\nKernel Profile - Instruction Execution Analysis\nKernel Profile - PC Sampling Analysis\nAs part of the Guided Analysis or Unguided Analysis for a kernel the analysis results are displayed under the Analysis view. After clicking on the source file or device function the Source-Disassembly view is opened. If the source file is not found a dialog is opened to select and point to the new location of the source file. This can happen for example when the profiling is done on a different system.\nThe Source-Disassembly view contains:\nHigh level source\nAssembly instructions\nHotspots at the source level\nHotspots at the assembly instruction level\nColumns for profiling data aggregated to the source level\nColumns for profiling data collected at the assembly instruction level\nThe information shown in the Source-Disassembly view can be customized by the following toolbar options:\nView menu - Select one or more out of the available profiler data columns to display. This is chosen by default based on the analysis type.\nHot Spot menu - Select which profiler data to use for hot spots. This is chosen by default based on the analysis type.\nShow the source and disassembly views side by side.\nShow the source and disassembly views top to bottom.\nMaximize the source view\nMaximize the disassembly view\nHotspots are colored based on level of importance - low, medium or high. Hovering the mouse over the hotspot displays the value of the profiler data, the level of importance and the source or disassembly line. You can click on a hotspot at the source level or assembly instruction level to view the source or disassembly line corresponding to the hotspot.\nIn the disassembly view the assembly instructions corresponding to the selected source line are highlighted. You can click on the up and down arrow buttons displayed at the right of the disassembly column header to navigate to the next or previous instruction block.\n2.4.4.\nGPU Details View\n\nThe GPU Details View displays a table of information for each memory copy and kernel execution in the profiled application. The following figure shows the table containing several memcpy and kernel executions. Each row of the table contains general information for a kernel execution or memory copy. For kernels, the table will also contain a column for each metric or event value collected for that kernel. In the figure, the Achieved Occupancy column shows the value of that metric for each of the kernel executions.\nYou can sort the data by column by left clicking on the column header, and you can rearrange the columns by left clicking on a column header and dragging it to its new location. If you select a row in the table, the corresponding interval will be selected in the\nTimeline View\n. Similarly, if you select a kernel or memcpy interval in the\nTimeline View\nthe table will be scrolled to show the corresponding data.\nIf you hover the mouse over a column header, a tooltip will display the data shown in that column. For a column containing event or metric data, the tooltip will describe the corresponding event or metric. The\nMetrics Reference\nsection contains more detailed information about each metric.\nThe information shown in the GPU Details View can be filtered in various ways using the menu accessible from the Details View toolbar. The following modes are available:\nFilter By Selection - If selected, the GPU Details View shows data only for the selected kernel and memcpy intervals.\nShow Hidden Timeline Data - If not selected, data is shown only for kernels and memcpys that are visible in the timeline. Kernels and memcpys that are not visible because they are inside collapsed parts of the timeline are not shown.\nShow Filtered Timeline Data - If not selected, data is shown only for kernels and memcpys that are in timeline rows that are not filtered.\nCollecting Events and Metrics\nSpecific event and metric values can be collected for each kernel and displayed in the details table. Use the toolbar icon in the upper right corner of the view to configure the events and metrics to collect for each device, and to run the application to collect those events and metrics.\nShow Summary Data\nBy default the table shows one row for each memcpy and kernel invocation. Alternatively, the table can show summary results for each kernel function. Use the toolbar icon in the upper right corner of the view to select or deselect summary format.\nFormatting Table Contents\nThe numbers in the table can be displayed either with or without grouping separators. Use the toolbar icon in the upper right corner of the view to select or deselect grouping separators.\nExporting Details\nThe contents of the table can be exported in CSV format using the toolbar icon in the upper right corner of the view.\n2.4.5.\nCPU Details View\n\nCPU Details view\nThis view details the amount of time your application spends executing functions on the CPU. Each thread is sampled periodically to capture its callstack and the summary of these measurements are displayed in this view. You can manipulate the view by selecting different orientations for organizing the callstack: Top-down, Bottom-up, Code Structure (3), choosing which thread to view (1), and by sorting or highlighting a specific thread (7, 8).\nAll the threads profiled are shown in one view when the ‘all threads’ option is selected (default). You can use this drop-down menu to instead select an individual thread.\nThis column displays a tree of events representing the structure of the application’s execution on the CPU. Each of the remaining columns show the measurements collected for this event. The events shown here are determined by which tree orientation mode is selected (3).\nThe tree is organized to show the calling hierarchy among functions. The following modes are available:\nTop-down (callers first) call tree view - The CPU details tree is organized as a call tree with each function shown as a child of its caller. In this mode you can see the callstack starting at the ‘main’ function.\nBottom-up (callees first) call tree view - The CPU details tree is organized in such a way that each function is shown as a child of any functions it calls. In this mode you can quickly identify the call path that contributes the most time to the application’s execution.\nCode structure (file and line) tree view - The CPU details tree shows which functions belong to each source file and library as well as how much of the application’s execution is attributed to a given line of source code.\nIn every mode the time listed for each function is ‘inclusive’ and includes time spent both in this function and any functions that it calls. For the code structure view the region of code is inclusive (i.e. the file entry lists the time spent in every function contained within a file).\nThis column displays the total amount of time spent by all threads in this event as a percentage of the total amount of time spent in all events.\nThis column displays a bar denoting a range where the amount of time spent in an event by any thread is always within this this range. On the left the minimum value is written, and on the right the maximum value is written. Also, if there is space, a small ‘diamond’ is drawn in the middle of the bar where the mean time is spent in this event across all threads.\nThese columns display a distinct chart for each event. On the left is a vertical scale showing the same minimum and maximum values as shown on the range chart. The following columns each show the amount of time spent in this event by thread. If the cell for the given event / thread combination is greyed out then no time was spent by this thread in this event (for this example both threads 1 and 2 spent no time in the event ‘x_solve’). Furthermore, the thread(s) with the minimum or maximum amount of time spent in the event across all threads are annotated with the ‘triangle / line’. In this example thread 3 spent the most and thread 6 the least amount of time in the event ‘x_solve’.\nTo reorder the rows by the time spent on a given thread click on the thread column header.\nTo highlight a given thread click on one of its bars in this chart.\nThis change to the view is the result of sorting by thread 3 (7) and highlighting it (8).\nHaving highlighted thread 3 we now see a vertical line on the range chart showing the amount of time this thread spent in this event compared to the range across all thread.\nThis thread is also highlighted on each row.\nCPU Threads\nCPU Source Code\nYou can open the\nCPU Source View\nfor any function by double-clicking on it in the tree. To be displayed the source files must be on the local file system. By default the directory containing the executable or profile file is searched. If the source file cannot be found a prompt will appear asking for its location. Sometimes a file within a specific directory is being sought, in this case you should give the path to where this directory resides.\nTip\nThe CPU profile is gathered by periodically sampling the state of the running application. For this reason a function will only appear in this view if it was sampled during execution. Short-running or very infrequently called functions are less likely to be sampled. If a function was not sampled the time it was running is accounted to the function that called it. In order to gather a CPU profile that is representative of the application’s performance the code of interest must execute for enough to gather enough samples. Usually a minute of runtime is sufficient.\nTip\nThe file and line information is gathered from the application’s debug information obtained by the compiler. To ensure that this information is available it is recommended that you compile with ‘-g’ or a similar option.\n2.4.6.\nOpenACC Details View\n\nOpenACC table view\nThe OpenACC Details View displays each OpenACC runtime activity executed by the profiled application. Each activity is grouped by source location: each activity which occurs at the same file and line number in the application’s source code is placed under a node labeled with the source location. Each activity shows the amount of time spent by the profiled application as both a unit of time and as a percentage of the total time this application was executing any OpenACC activity. Also the number of times this activity was called is shown. There are two ways to count how much time is spent in a particular OpenACC activity:\nShow the Inclusive durations (counting any other OpenACC activities running at the same time) in the OpenACC details view - The OpenACC details view shows the total time spent in each activity including any activities that were executed as the result of this activity. In this case the amount of time spent in each activity occurring at a given application source location is totaled and displayed on the row displaying the source location.\nShow the Exclusive durations (excluding any other OpenACC activities running at the same time) in the OpenACC details view - The OpenACC details view shows the time spent only in a given activity. In this case the amount of time spent at a given source location is always zero—time is attributed solely to each activity occurring at this source location.\n2.4.7.\nOpenMP Details View\n\nOpenMP table view\nThe OpenMP Details view displays the activity of the OpenMP runtime on the CPU. The time your application spends in a parallel region or idling is shown both on the timeline and is summarized in this view. The reference for the percentage of time spent in each type of activity is the time from the start of the first parallel region to the end of the last parallel region. The sum of the percentages of each activity type often exceeds 100% because the OpenMP runtime can be in multiple states at the same time.\n2.4.8.\nProperties View\n\nThe Properties View shows information about the row or interval highlighted or selected in the\nTimeline View\n. If a row or interval is not selected, the displayed information tracks the motion of the mouse pointer. If a row or interval is selected, the displayed information is pinned to that row or interval.\nWhen an OpenACC interval with an associated source file is selected, this filename is shown in the Source File table entry. Double-clicking on the filename opens the respective source file if it is available on the file-system.\n2.4.9.\nConsole View\n\nThe Console View shows stdout and stderr output of the application each time it executes. If you need to provide stdin input to your application, do so by typing into the console view.\n2.4.10.\nSettings View\n\nThe Settings View allows you to specify execution settings for the application being profiled. As shown in the following figure, the Executable settings tab allows you to specify the executable file, the working directory, the command-line arguments, and the environment for the application. Only the executable file is required, all other fields are optional.\nExection Timeout\nThe Executable settings tab also allows you to specify an optional execution timeout. If the execution timeout is specified, the application execution will be terminated after that number of seconds. If the execution timeout is not specified, the application will be allowed to continue execution until it terminates normally.\nNote\nThe timer starts counting from the moment the CUDA driver is initialized. If the application doesn’t call any CUDA APIs, a timeout won’t be triggered.\nStart execution with profiling enabled\nThe Start execution with profiling enabled checkbox is set by default to indicate that application profiling begins at the start of application execution. If you are using\ncudaProfilerStart()\nand\ncudaProfilerStop()\nto control profiling within your application as described in\nFocused Profiling\n, then you should uncheck this box.\nEnable concurrent kernel profiling\nThe Enable concurrent kernel profiling checkbox is set by default to enable profiling of applications that exploit concurrent kernel execution. If this checkbox is unset, the profiler will disable concurrent kernel execution. Disabling concurrent kernel execution can reduce profiling overhead in some cases and so may be appropriate for applications that do not exploit concurrent kernels.\nEnable power, clock, and thermal profiling\nThe Enable power, clock, and thermal profiling checkbox can be set to enable low frequency sampling of the power, clock, and thermal behavior of each GPU used by the application.\n2.4.11.\nCPU Source View\n\nThe CPU source code view allows you to inspect the files that comprise the profiled application’s CPU source. This view can be opened in the\nCPU Details View\nby double-clicking on a function in the tree–the source file that corresponds to this function is then opened. Line numbers can be enabled by right-clicking left side ruler.\nWhen compiling using the PGI® compilers annotations can be added to this view (see\nCommon Compiler Feedback Format\nfor more information). These annotation are notes about how a given line of code is compiled. PGI compilers save information about how your program was optimized, or why a particular optimization was not made. This can be combined with the\nCPU Details View\nto help identify why certain lines of code performed the way they did. For example, the message may tell you about the following:\nvector instructions generated by the compiler.\ncompute-intensity of a loop, a ratio computation to memory operations–higher numbers mean that there is more computation than memory loads and stores.\ninformation about parallelization, with a hint for how it might be possible to make the loop run in parallel if the compiler could not auto-parallelize it.\n2.5.\nCustomizing the Profiler\n\nWhen you first start the Visual Profiler\n,\nand\nafter\nclosing\nthe\nWelcome\npage,\nyou will be presented with a default placement of the views. By moving and resizing the views, you can customize the profiler to meet your development needs. Any changes you make are restored the next time you start the profiler.\n2.5.1.\nResizing a View\n\nTo resize a view, simply left click and drag on the dividing area between the views. All views stacked together in one area are resized at the same time.\n2.5.2.\nReordering a View\n\nTo reorder a view in a stacked set of views, left click and drag the view tab to the new location within the view stack.\n2.5.3.\nMoving a View\n\nto move a view, left click the view tab and drag it to its new location. As you drag the view, an outline will show the target location for the view. You can place the view in a new location, or stack it in the same location as other views.\n2.5.4.\nUndocking a View\n\nYou can undock a view from the profiler window so that the view occupies its own stand-alone window. You may want to do this to take advantage of multiple monitors or to maximum the size of an individual view. To undock a view, left click the view tab and drag it outside of the profiler window. To dock a view, left click the view tab (not the window decoration) and drag it into the profiler window.\n2.5.5.\nOpening and Closing a View\n\nUse the X icon on a view tab to close a view. To open a view, use the View menu.\n2.6.\nCommand Line Arguments\n\nWhen the Visual Profiler is started from the command line, it is possible, using command line arguments, to specify executable to start new session with or import profile files exported from nvprof using one of the following patterns:\nStart new executable session by launching nvvp with name of executable followed, optionally, by its arguments:\nnvvp\nexecutableName\n[[\nexecutableArguments\n]...]\nImport single-process nvprof session by launching nvvp with single .nvprof file as argument(see\nnvprof’s export/import options\nsection for more details):\nnvvp\ndata\n.\nnvprof\nImport multi-process nvprof session, by launching nvvp with multiple .nvprof files as arguments:\nnvvp\ndata1\n.\nnvprof\ndata2\n.\nnvprof\n...\n3.\n​nvprof\n\nThe\nnvprof\nprofiling tool enables you to collect and view profiling data from the command-line.\nnvprof\nenables the collection of a timeline of CUDA-related activities on both CPU and GPU, including kernel execution, memory transfers, memory set and CUDA API calls and events or metrics for CUDA kernels. Profiling options are provided to\nnvprof\nthrough command-line options. Profiling results are displayed in the console after the profiling data is collected, and may also be saved for laterviewing by either\nnvprof\nor the Visual Profiler.\nNote\nThe textual output of the profiler is redirected to\nstderr\nby default. Use\n--log-file\nto redirect the output to another file. See\nRedirecting Output\n.\nTo profile an application from the command-line:\nnvprof\n[\noptions\n]\n[\napplication\n]\n[\napplication\n-\narguments\n]\nTo view the full help page, type\nnvprof\n--help\n.\n3.1.\nCommand Line Options\n\n3.1.1.\nCUDA Profiling Options\n\nOption\nValues\nDefault\nDescription\naggregate-mode\non, off\non\nTurn on/off aggregate mode for events and metrics specified by subsequent\n--events\nand\n--metrics\noptions. Those event/metric values will be collected for each domain instance, instead of the whole device.\nSee\nEvent/metric Trace Mode\nfor more information.\nanalysis-metrics\nN/A\nN/A\nCollect profiling data that can be imported to Visual Profiler’s “analysis” mode. Note: Use\n--export-profile\nto specify an export file.\nannotate-mpi\noff, openmpi, mpich\noff\nAutomatically annotate MPI calls with NVTX markers. Specify the MPI implementation installed on your machine. Currently, Open MPI and MPICH implementations are supported.\nSee\nAutomatic MPI Annotation with NVTX\nfor more information.\nconcurrent-kernels\non, off\non\nTurn on/off concurrent kernel execution. If concurrent kernel execution is off, all kernels running on one device will be serialized.\ncontinuous-sampling-interval\n{interval in milliseconds}\n2 milliseconds\nSet the continuous mode sampling interval in milliseconds. Minimum is 1 ms.\ncpu-thread-tracing\non, off\noff\nCollect information about CPU thread API activity.\nSee\nCPU Thread Tracing\nfor more information.\ndependency-analysis\nN/A\nN/A\nGenerate event dependency graph for host and device activities and run dependency analysis.\nSee\nDependency Analysis\nfor more information.\ndevice-buffer-size\n{size in MBs}\n8 MB\nSet the device memory size (in MBs) reserved for storing profiling data for non-CDP operations, especially for concurrent kernel tracing, for each buffer on a context. The size should be a positive integer.\ndevice-cdp-buffer-size\n{size in MBs}\n8 MB\nSet the device memory size (in MBs) reserved for storing profiling data for CDP operations for each buffer on a context. The size should be a positive integer.\ndevices\n{comma-separated device IDs}, all\nN/A\nChange the scope of subsequent\n--events\n,\n--metrics\n,\n--query-events\nand\n--query-metrics\noptions.\nSee\nProfiling Scope\nfor more information.\nevent-collection-mode\nkernel, continuous\nkernel\nChoose event collection mode for all events/metrics.\nkernel: Events/metrics are collected only for durations of kernel executions\ncontinuous: Events/metrics are collected for duration of application. This is not applicable for non-Tesla devices. This mode is compatible only with NVLink events/metrics. This mode is incompatible with\n--profile-all-processes\nor\n--profile-child-processes\nor\n--replay-mode\nkernel\nor\n--replay-mode\napplication\n.\nevents (e)\n{comma-separated event names}, all\nN/A\nSpecify the events to be profiled on certain device(s). Multiple event names separated by comma can be specified. Which device(s) are profiled is controlled by the\n--devices\noption. Otherwise events will be collected on all devices. For a list of available events, use\n--query-events\n. Use\n--events\nall\nto profile all events available for each device. Use\n--devices\nand\n--kernels\nto select a specific kernel invocation.\nkernel-latency-timestamps\non, off\noff\nTurn on/off collection of kernel latency timestamps, namely queued and submitted. The queued timestamp is captured when a kernel launch command was queued into the CPU command buffer. The submitted timestamp denotes when the CPU command buffer containing this kernel launch was submitted to the GPU. Turning this option on may incur an overhead during profiling.\nkernels\n{kernel name}, {[context id/name]:[stream id/name]:[kernel name]:[invocation]}\nN/A\nChange the scope of subsequent\n--events\n,\n--metrics\noptions. The syntax is as follows:\n{kernel name}: Limit scope to given kernel name.\n{[context id/name]:[stream id/name]:[kernel name]:[invocation]}: The context/stream IDs, names, kernel name and invocation can be regular expressions. Empty string matches any number or characters. If [context id/name] or [stream id/name] is a positive number, it’s strictly matched against the CUDA context/stream ID. Otherwise it’s treated as a regular expression and matched against the context/stream name specified by the NVTX library. If the invocation count is a positive number, it’s strictly matched against the invocation of the kernel. Otherwise it’s treated as a regular expression.\nExample:\n--kernels\n\"1:foo:bar:2\"\nwill profile any kernel whose name contains “bar” and is the 2nd instance on context 1 and on stream named “foo”.\nSee\nProfiling Scope\nfor more information.\nmetrics (m)\n{comma-separated metric names}, all\nN/A\nSpecify the metrics to be profiled on certain device(s). Multiple metric names separated by comma can be specified. Which device(s) are profiled is controlled by the\n--devices\noption. Otherwise metrics will be collected on all devices. For a list of available metrics, use\n--query-metrics\n. Use\n--metrics\nall\nto profile all metrics available for each device. Use\n--devices\nand\n--kernels\nto select a specific kernel invocation. Note:\n--metrics\nall\ndoes not include some metrics which are needed for Visual Profiler’s source level analysis. For that, use\n--analysis-metrics\n.\npc-sampling-period\n{period in cycles}\nBetween 5 and 12 based on the setup\nSpecify PC Sampling period in cycles, at which the sampling records will be dumped. Allowed values for the period are integers between 5 to 31 both inclusive. This will set the sampling period to (2^period) cycles Note: Only available for GM20X+.\nprofile-all-processes\nN/A\nN/A\nProfile all processes launched by the same user who launched this nvprof instance. Note: Only one instance of nvprof can run with this option at the same time. Under this mode, there’s no need to specify an application to run.\nSee\nMultiprocess Profiling\nfor more information.\nprofile-api-trace\nnone, runtime, driver, all\nall\nTurn on/off CUDA runtime/driver API tracing.\nnone: turn off API tracing\nruntime: only turn on CUDA runtime API tracing\ndriver: only turn on CUDA driver API tracing\nall: turn on all API tracing\nprofile-child-processes\nN/A\nN/A\nProfile the application and all child processes launched by it.\nSee\nMultiprocess Profiling\nfor more information.\nprofile-from-start\non, off\non\nEnable/disable profiling from the start of the application. If it’s disabled, the application can use {cu,cuda}Profiler{Start,Stop} to turn on/off profiling.\nSee\nFocused Profiling\nfor more information.\nprofiling-semaphore-pool-size\n{count}\n65536\nSet the profiling semaphore pool size reserved for storing profiling data for serialized kernels and memory operations for each context. The size should be a positive integer.\nquery-events\nN/A\nN/A\nList all the events available on the device(s). Device(s) queried can be controlled by the\n--devices\noption.\nquery-metrics\nN/A\nN/A\nList all the metrics available on the device(s). Device(s) queried can be controlled by the\n--devices\noption.\nreplay-mode\ndisabled, kernel, application\nkernel\nChoose replay mode used when not all events/metrics can be collected in a single run.\ndisabled: replay is disabled, events/metrics couldn’t be profiled will be dropped\nkernel: each kernel invocation is replayed\napplication: the entire application is replayed. This mode is incompatible with\n--profile-all-processes\nor\nprofile-child-processes\n.\nskip-kernel-replay-save-restore\non, off\noff\nIf enabled, this option can vastly improve kernel replay speed, as save and restore of the mutable state for each kernel pass will be skipped. Skipping of save/restore of input/output buffers allows you to specify that all profiled kernels on the context do not change the contents of their input buffers during execution, or call device malloc/free or new/delete, that leave the device heap in a different state. Specifically, a kernel can malloc and free a buffer in the same launch, but it cannot call an unmatched malloc or an unmatched free. Note: incorrectly using this mode while one of the kernels does modify the input buffer or uses unmatched malloc/free will result in undefined behavior, including kernel execution failure and/or corrupted device data.\non: skip save/restore of the input/output buffers\noff: save/restore input/output buffers for each kernel replay pass\nsource-level-analysis (a)\nglobal_access, shared_access, branch, instruction_execution, pc_sampling\nN/A\nSpecify the source level metrics to be profiled on a certain kernel invocation. Use\n--devices\nand\n--kernels\nto select a specific kernel invocation. One or more of these may be specified, separated by commas\nglobal_access: global access\nshared_access: shared access\nbranch: divergent branch\ninstruction_execution: instruction execution\npc_sampling: pc sampling, available only for GM20X+\nNote: Use\n--export-profile\nto specify an export file.\nSee\nSource-Disassembly View\nfor more information.\nsystem-profiling\non, off\noff\nTurn on/off power, clock, and thermal profiling.\nSee\nSystem Profiling\nfor more information.\ntimeout (t)\n{seconds}\nN/A\nSet an execution timeout (in seconds) for the CUDA application. Note: Timeout starts counting from the moment the CUDA driver is initialized. If the application doesn’t call any CUDA APIs, timeout won’t be triggered.\nSee\nTimeout\nand\nFlush Profile Data\nfor more information.\ntrack-memory-allocations\non, off\noff\nTurn on/off tracking of memory operations, which involves recording timestamps, memory size, memory type and program counters of the memory allocations and frees. Turning this option on may incur an overhead during profiling.\nunified-memory-profiling\nper-process-device, off\nper-process-device\nConfigure unified memory profiling.\nper-process-device: collect counts for each process and each device\noff: turn off unified memory profiling\nSee\nUnified Memory Profiling\nfor more information.\n3.1.2.\nCPU Profiling Options\n\nOption\nValues\nDefault\nDescription\ncpu-profiling\non, off\noff\nTurn on CPU profiling. Note: CPU profiling is not supported in multi-process mode.\ncpu-profiling-explain-ccff\n{filename}\nN/A\nSet the path to a PGI pgexplain.xml file that should be used to interpret Common Compiler Feedback Format (CCFF) messages.\ncpu-profiling-frequency\n{frequency}\n100Hz\nSet the CPU profiling frequency in samples per second. Maximum is 500Hz.\ncpu-profiling-max-depth\n{depth}\n0 (i.e. unlimited)\nSet the maximum depth of each call stack.\ncpu-profiling-mode\nflat, top-down, bottom-up\nbottom-up\nSet the output mode of CPU profiling.\nflat: Show flat profile\ntop-down: Show parent functions at the top\nbottom-up: Show parent functions at the bottom\ncpu-profiling-percentage-threshold\n{threshold}\n0 (i.e. unlimited)\nFilter out the entries that are below the set percentage threshold. The limit should be an integer between 0 and 100, inclusive.\ncpu-profiling-scope\nfunction, instruction\nfunction\nChoose the profiling scope.\nfunction: Each level in the stack trace represents a distinct function\ninstruction: Each level in the stack trace represents a distinct instruction address\ncpu-profiling-show-ccff\non, off\noff\nChoose whether to print Common Compiler Feedback Format (CCFF) messages embedded in the binary. Note: this option implies\n--cpu-profiling-scope\ninstruction\n.\ncpu-profiling-show-library\non, off\noff\nChoose whether to print the library name for each sample.\ncpu-profiling-thread-mode\nseparated, aggregated\naggregated\nSet the thread mode of CPU profiling.\nseparated: Show separate profile for each thread\naggregated: Aggregate data from all threads\ncpu-profiling-unwind-stack\non, off\non\nChoose whether to unwind the CPU call-stack at each sample point.\nopenacc-profiling\non, off\non\nEnable/disable recording information from the OpenACC profiling interface. Note: if the OpenACC profiling interface is available depends on the OpenACC runtime.\nSee\nOpenACC\nfor more information.\nopenmp-profiling\non, off\noff\nEnable/disable recording information from the OpenMP profiling interface. Note: if the OpenMP profiling interface is available depends on the OpenMP runtime.\nSee\nOpenMP\nfor more information.\n3.1.3.\nPrint Options\n\nOption\nValues\nDefault\nDescription\ncontext-name\n{name}\nN/A\nName of the CUDA context.\n%i\nin the context name string is replaced with the ID of the context.\n%p\nin the context name string is replaced with the process ID of the application being profiled.\n%q{<ENV>}\nin the context name string is replaced with the value of the environment variable\n<ENV>\n. If the environment variable is not set it’s an error.\n%h\nin the context name string is replaced with the hostname of the system.\n%%\nin the context name string is replaced with\n%\n. Any other character following\n%\nis illegal.\ncsv\nN/A\nN/A\nUse comma-separated values in the output.\nSee\nCSV\nfor more information.\ndemangling\non, off\non\nTurn on/off C++ name demangling of function names.\nSee\nDemangling\nfor more information.\nnormalized-time-unit (u)\ns, ms, us, ns, col, auto\nauto\nSpecify the unit of time that will be used in the output.\ns: second\nms: millisecond\nus: microsecond\nns: nanosecond\ncol: a fixed unit for each column\nauto: the scale is chosen for each value based on its length.\nSee\nAdjust Units\nfor more information.\nopenacc-summary-mode\nexclusive, inclusive\nexclusive\nSet how durations are computed in the OpenACC summary.\nSee\nOpenACC Summary Modes\nfor more information.\ntrace\napi, gpu\nN/A\nSpecify the option (or options separated by commas) to be traced.\napi - only turn on CUDA runtime and driver API tracing\ngpu - only turn on CUDA GPU tracing\nprint-api-summary\nN/A\nN/A\nPrint a summary of CUDA runtime/driver API calls.\nprint-api-trace\nN/A\nN/A\nPrint CUDA runtime/driver API trace.\nSee\nGPU-Trace and API-Trace Modes\nfor more information.\nprint-dependency-analysis-trace\nN/A\nN/A\nPrint dependency analysis trace.\nSee\nDependency Analysis\nfor more information.\nprint-gpu-summary\nN/A\nN/A\nPrint a summary of the activities on the GPU (including CUDA kernels and memcpy’s/memset’s).\nSee\nSummary Mode\nfor more information.\nprint-gpu-trace\nN/A\nN/A\nPrint individual kernel invocations (including CUDA memcpy’s/memset’s) and sort them in chronological order. In event/metric profiling mode, show events/metrics for each kernel invocation.\nSee\nGPU-Trace and API-Trace Modes\nfor more information.\nprint-openacc-constructs\nN/A\nN/A\nInclude parent construct names in OpenACC profile.\nSee\nOpenACC Options\nfor more information.\nprint-openacc-summary\nN/A\nN/A\nPrint a summary of the OpenACC profile.\nprint-openacc-trace\nN/A\nN/A\nPrint a trace of the OpenACC profile.\nprint-openmp-summary\nN/A\nN/A\nPrint a summary of the OpenMP profile.\nprint-summary (s)\nN/A\nN/A\nPrint a summary of the profiling result on screen. Note: This is the default unless\n--export-profile\nor other print options are used.\nprint-summary-per-gpu\nN/A\nN/A\nPrint a summary of the profiling result for each GPU.\nprocess-name\n{name}\nN/A\nName of the process.\n%p\nin the process name string is replaced with the process ID of the application being profiled.\n%q{<ENV>}\nin the process name string is replaced with the value of the environment variable\n<ENV>\n. If the environment variable is not set it’s an error.\n%h\nin the process name string is replaced with the hostname of the system.\n%%\nin the process name string is replaced with\n%\n. Any other character following\n%\nis illegal.\nquiet\nN/A\nN/A\nSuppress all nvprof output.\nstream-name\n{name}\nN/A\nName of the CUDA stream.\n%i\nin the stream name string is replaced with the ID of the stream.\n%p\nin the stream name string is replaced with the process ID of the application being profiled.\n%q{<ENV>}\nin the stream name string is replaced with the value of the environment variable\n<ENV>\n. If the environment variable is not set it’s an error.\n%h\nin the stream name string is replaced with the hostname of the system.\n%%\nin the stream name string is replaced with\n%\n. Any other character following\n%\nis illegal.\n3.1.4.\nIO Options\n\nOption\nValues\nDefault\nDescription\nexport-profile (o)\n{filename}\nN/A\nExport the result file which can be imported later or opened by the NVIDIA Visual Profiler.\n%p\nin the file name string is replaced with the process ID of the application being profiled.\n%q{<ENV>}\nin the file name string is replaced with the value of the environment variable\n<ENV>\n. If the environment variable is not set it’s an error.\n%h\nin the file name string is replaced with the hostname of the system.\n%%\nin the file name string is replaced with\n%\n. Any other character following\n%\nis illegal.\nBy default, this option disables the summary output. Note: If the application being profiled creates child processes, or if\n--profile-all-processes\nis used, the\n%p\nformat is needed to get correct export files for each process.\nSee\nExport/Import\nfor more information.\nforce-overwrite (f)\nN/A\nN/A\nForce overwriting all output files (any existing files will be overwritten).\nimport-profile (i)\n{filename}\nN/A\nImport a result profile from a previous run.\nSee\nExport/Import\nfor more information.\nlog-file\n{filename}\nN/A\nMake nvprof send all its output to the specified file, or one of the standard channels. The file will be overwritten. If the file doesn’t exist, a new one will be created.\n%1\nas the whole file name indicates standard output channel (stdout).\n%2\nas the whole file name indicates standard error channel (stderr). Note: This is the default.\n%p\nin the file name string is replaced with the process ID of the application being profiled.\n%q{<ENV>}\nin the file name string is replaced with the value of the environment variable\n<ENV>\n. If the environment variable is not set it’s an error.\n%h\nin the file name string is replaced with the hostname of the system.\n%%\nin the file name is replaced with\n%\n. Any other character following\n%\nis illegal.\nSee\nRedirecting Output\nfor more information.\nprint-nvlink-topology\nN/A\nN/A\nPrint nvlink topology\nprint-pci-topology\nN/A\nN/A\nPrint PCI topology\nhelp (h)\nN/A\nN/A\nPrint help information.\nversion (V)\nN/A\nN/A\nPrint version information of this tool.\n3.2.\nProfiling Modes\n\nnvprof\noperates in one of the modes listed below.\n3.2.1.\nSummary Mode\n\nSummary mode is the default operating mode for\nnvprof\n. In this mode,\nnvprof\noutputs a single result line for each kernel function and each type of CUDA memory copy/set performed by the application. For each kernel,\nnvprof\noutputs the total time of all instances of the kernel or type of memory copy as well as the average, minimum, and maximum time. The time for a kernel is the kernel execution time on the device. By default,\nnvprof\nalso prints a summary of all the CUDA runtime/driver API calls. Output of\nnvprof\n(except for tables) are prefixed with\n==<pid>==\n,\n<pid>\nbeing the process ID of the application being profiled.\nHere’s a simple example of running\nnvprof\non the CUDA sample\nmatrixMul\n:\n$\nnvprof\nmatrixMul\n[\nMatrix\nMultiply\nUsing\nCUDA\n]\n-\nStarting\n...\n==\n27694\n==\nNVPROF\nis\nprofiling\nprocess\n27694\n,\ncommand\n:\nmatrixMul\nGPU\nDevice\n0\n:\n\"GeForce GT 640M LE\"\nwith\ncompute\ncapability\n3.0\nMatrixA\n(\n320\n,\n320\n),\nMatrixB\n(\n640\n,\n320\n)\nComputing\nresult\nusing\nCUDA\nKernel\n...\ndone\nPerformance\n=\n35.35\nGFlop\n/\ns\n,\nTime\n=\n3.708\nmsec\n,\nSize\n=\n131072000\nOps\n,\nWorkgroupSize\n=\n1024\nthreads\n/\nblock\nChecking\ncomputed\nresult\nfor\ncorrectness\n:\nOK\nNote\n:\nFor\npeak\nperformance\n,\nplease\nrefer\nto\nthe\nmatrixMulCUBLAS\nexample\n.\n==\n27694\n==\nProfiling\napplication\n:\nmatrixMul\n==\n27694\n==\nProfiling\nresult\n:\nTime\n(\n%\n)\nTime\nCalls\nAvg\nMin\nMax\nName\n99.94\n%\n1.11524\ns\n301\n3.7051\nms\n3.6928\nms\n3.7174\nms\nvoid\nmatrixMulCUDA\n<\nint\n=\n32\n>\n(\nfloat\n*\n,\nfloat\n*\n,\nfloat\n*\n,\nint\n,\nint\n)\n0.04\n%\n406.30\nus\n2\n203.15\nus\n136.13\nus\n270.18\nus\n[\nCUDA\nmemcpy\nHtoD\n]\n0.02\n%\n248.29\nus\n1\n248.29\nus\n248.29\nus\n248.29\nus\n[\nCUDA\nmemcpy\nDtoH\n]\n==\n27964\n==\nAPI\ncalls\n:\nTime\n(\n%\n)\nTime\nCalls\nAvg\nMin\nMax\nName\n49.81\n%\n285.17\nms\n3\n95.055\nms\n153.32\nus\n284.86\nms\ncudaMalloc\n25.95\n%\n148.57\nms\n1\n148.57\nms\n148.57\nms\n148.57\nms\ncudaEventSynchronize\n22.23\n%\n127.28\nms\n1\n127.28\nms\n127.28\nms\n127.28\nms\ncudaDeviceReset\n1.33\n%\n7.6314\nms\n301\n25.353\nus\n23.551\nus\n143.98\nus\ncudaLaunch\n0.25\n%\n1.4343\nms\n3\n478.09\nus\n155.84\nus\n984.38\nus\ncudaMemcpy\n0.11\n%\n601.45\nus\n1\n601.45\nus\n601.45\nus\n601.45\nus\ncudaDeviceSynchronize\n0.10\n%\n564.48\nus\n1505\n375\nns\n313\nns\n3.6790\nus\ncudaSetupArgument\n0.09\n%\n490.44\nus\n76\n6.4530\nus\n307\nns\n221.93\nus\ncuDeviceGetAttribute\n0.07\n%\n406.61\nus\n3\n135.54\nus\n115.07\nus\n169.99\nus\ncudaFree\n0.02\n%\n143.00\nus\n301\n475\nns\n431\nns\n2.4370\nus\ncudaConfigureCall\n0.01\n%\n42.321\nus\n1\n42.321\nus\n42.321\nus\n42.321\nus\ncuDeviceTotalMem\n0.01\n%\n33.655\nus\n1\n33.655\nus\n33.655\nus\n33.655\nus\ncudaGetDeviceProperties\n0.01\n%\n31.900\nus\n1\n31.900\nus\n31.900\nus\n31.900\nus\ncuDeviceGetName\n0.00\n%\n21.874\nus\n2\n10.937\nus\n8.5850\nus\n13.289\nus\ncudaEventRecord\n0.00\n%\n16.513\nus\n2\n8.2560\nus\n2.6240\nus\n13.889\nus\ncudaEventCreate\n0.00\n%\n13.091\nus\n1\n13.091\nus\n13.091\nus\n13.091\nus\ncudaEventElapsedTime\n0.00\n%\n8.1410\nus\n1\n8.1410\nus\n8.1410\nus\n8.1410\nus\ncudaGetDevice\n0.00\n%\n2.6290\nus\n2\n1.3140\nus\n509\nns\n2.1200\nus\ncuDeviceGetCount\n0.00\n%\n1.9970\nus\n2\n998\nns\n520\nns\n1.4770\nus\ncuDeviceGet\nNote\nAPI trace can be turned off, if not needed, by using\n--profile-api-trace\nnone\n. This reduces some of the profiling overhead, especially when the kernels are short.\nIf multiple CUDA capable devices are profiled,\nnvprof\n--print-summary-per-gpu\ncan be used to print one summary per GPU.\nnvprof\nsupports CUDA Dynamic Parallelism in summary mode. If your application uses Dynamic Parallelism, the output will contain one column for the number of host-launched kernels and one for the number of device-launched kernels. Here’s an example of running\nnvprof\non the CUDA Dynamic Parallelism sample\ncdpSimpleQuicksort\n:\n$\nnvprof\ncdpSimpleQuicksort\n==\n27325\n==\nNVPROF\nis\nprofiling\nprocess\n27325\n,\ncommand\n:\ncdpSimpleQuicksort\nRunning\non\nGPU\n0\n(\nTesla\nK20c\n)\nInitializing\ndata\n:\nRunning\nquicksort\non\n128\nelements\nLaunching\nkernel\non\nthe\nGPU\nValidating\nresults\n:\nOK\n==\n27325\n==\nProfiling\napplication\n:\ncdpSimpleQuicksort\n==\n27325\n==\nProfiling\nresult\n:\nTime\n(\n%\n)\nTime\nCalls\n(\nhost\n)\nCalls\n(\ndevice\n)\nAvg\nMin\nMax\nName\n99.71\n%\n1.2114\nms\n1\n14\n80.761\nus\n5.1200\nus\n145.66\nus\ncdp_simple_quicksort\n(\nunsigned\nint\n*\n,\nint\n,\nint\n,\nint\n)\n0.18\n%\n2.2080\nus\n1\n-\n2.2080\nus\n2.2080\nus\n2.2080\nus\n[\nCUDA\nmemcpy\nDtoH\n]\n0.11\n%\n1.2800\nus\n1\n-\n1.2800\nus\n1.2800\nus\n1.2800\nus\n[\nCUDA\nmemcpy\nHtoD\n]\n3.2.2.\nGPU-Trace and API-Trace Modes\n\nGPU-Trace and API-Trace modes can be enabled individually or together. GPU-Trace mode provides a timeline of all activities taking place on the GPU in chronological order. Each kernel execution and memory copy/set instance is shown in the output. For each kernel or memory copy, detailed information such as kernel parameters, shared memory usage and memory transfer throughput are shown. The number shown in the square brackets after the kernel name correlates to the CUDA API that launched that kernel.\nHere’s an example:\n$\nnvprof\n--\nprint\n-\ngpu\n-\ntrace\nmatrixMul\n==\n27706\n==\nNVPROF\nis\nprofiling\nprocess\n27706\n,\ncommand\n:\nmatrixMul\n==\n27706\n==\nProfiling\napplication\n:\nmatrixMul\n[\nMatrix\nMultiply\nUsing\nCUDA\n]\n-\nStarting\n...\nGPU\nDevice\n0\n:\n\"GeForce GT 640M LE\"\nwith\ncompute\ncapability\n3.0\nMatrixA\n(\n320\n,\n320\n),\nMatrixB\n(\n640\n,\n320\n)\nComputing\nresult\nusing\nCUDA\nKernel\n...\ndone\nPerformance\n=\n35.36\nGFlop\n/\ns\n,\nTime\n=\n3.707\nmsec\n,\nSize\n=\n131072000\nOps\n,\nWorkgroupSize\n=\n1024\nthreads\n/\nblock\nChecking\ncomputed\nresult\nfor\ncorrectness\n:\nOK\nNote\n:\nFor\npeak\nperformance\n,\nplease\nrefer\nto\nthe\nmatrixMulCUBLAS\nexample\n.\n==\n27706\n==\nProfiling\nresult\n:\nStart\nDuration\nGrid\nSize\nBlock\nSize\nRegs\n*\nSSMem\n*\nDSMem\n*\nSize\nThroughput\nDevice\nContext\nStream\nName\n133.81\nms\n135.78\nus\n-\n-\n-\n-\n-\n409.60\nKB\n3.0167\nGB\n/\ns\nGeForce\nGT\n640\nM\n1\n2\n[\nCUDA\nmemcpy\nHtoD\n]\n134.62\nms\n270.66\nus\n-\n-\n-\n-\n-\n819.20\nKB\n3.0267\nGB\n/\ns\nGeForce\nGT\n640\nM\n1\n2\n[\nCUDA\nmemcpy\nHtoD\n]\n134.90\nms\n3.7037\nms\n(\n20\n10\n1\n)\n(\n32\n32\n1\n)\n29\n8.1920\nKB\n0\nB\n-\n-\nGeForce\nGT\n640\nM\n1\n2\nvoid\nmatrixMulCUDA\n<\nint\n=\n32\n>\n(\nfloat\n*\n,\nfloat\n*\n,\nfloat\n*\n,\nint\n,\nint\n)\n[\n94\n]\n138.71\nms\n3.7011\nms\n(\n20\n10\n1\n)\n(\n32\n32\n1\n)\n29\n8.1920\nKB\n0\nB\n-\n-\nGeForce\nGT\n640\nM\n1\n2\nvoid\nmatrixMulCUDA\n<\nint\n=\n32\n>\n(\nfloat\n*\n,\nfloat\n*\n,\nfloat\n*\n,\nint\n,\nint\n)\n[\n105\n]\n<\n...\nmore\noutput\n...\n>\n1.24341\ns\n3.7011\nms\n(\n20\n10\n1\n)\n(\n32\n32\n1\n)\n29\n8.1920\nKB\n0\nB\n-\n-\nGeForce\nGT\n640\nM\n1\n2\nvoid\nmatrixMulCUDA\n<\nint\n=\n32\n>\n(\nfloat\n*\n,\nfloat\n*\n,\nfloat\n*\n,\nint\n,\nint\n)\n[\n2191\n]\n1.24711\ns\n3.7046\nms\n(\n20\n10\n1\n)\n(\n32\n32\n1\n)\n29\n8.1920\nKB\n0\nB\n-\n-\nGeForce\nGT\n640\nM\n1\n2\nvoid\nmatrixMulCUDA\n<\nint\n=\n32\n>\n(\nfloat\n*\n,\nfloat\n*\n,\nfloat\n*\n,\nint\n,\nint\n)\n[\n2198\n]\n1.25089\ns\n248.13\nus\n-\n-\n-\n-\n-\n819.20\nKB\n3.3015\nGB\n/\ns\nGeForce\nGT\n640\nM\n1\n2\n[\nCUDA\nmemcpy\nDtoH\n]\nRegs\n:\nNumber\nof\nregisters\nused\nper\nCUDA\nthread\n.\nThis\nnumber\nincludes\nregisters\nused\ninternally\nby\nthe\nCUDA\ndriver\nand\n/\nor\ntools\nand\ncan\nbe\nmore\nthan\nwhat\nthe\ncompiler\nshows\n.\nSSMem\n:\nStatic\nshared\nmemory\nallocated\nper\nCUDA\nblock\n.\nDSMem\n:\nDynamic\nshared\nmemory\nallocated\nper\nCUDA\nblock\n.\nnvprof\nsupports CUDA Dynamic Parallelism in GPU-Trace mode. For host kernel launch, the kernel ID will be shown. For device kernel launch, the kernel ID, parent kernel ID and parent block will be shown. Here’s an example:\n$nvprof\n--\nprint\n-\ngpu\n-\ntrace\ncdpSimpleQuicksort\n==\n28128\n==\nNVPROF\nis\nprofiling\nprocess\n28128\n,\ncommand\n:\ncdpSimpleQuicksort\nRunning\non\nGPU\n0\n(\nTesla\nK20c\n)\nInitializing\ndata\n:\nRunning\nquicksort\non\n128\nelements\nLaunching\nkernel\non\nthe\nGPU\nValidating\nresults\n:\nOK\n==\n28128\n==\nProfiling\napplication\n:\ncdpSimpleQuicksort\n==\n28128\n==\nProfiling\nresult\n:\nStart\nDuration\nGrid\nSize\nBlock\nSize\nRegs\n*\nSSMem\n*\nDSMem\n*\nSize\nThroughput\nDevice\nContext\nStream\nID\nParent\nID\nParent\nBlock\nName\n192.76\nms\n1.2800\nus\n-\n-\n-\n-\n-\n512\nB\n400.00\nMB\n/\ns\nTesla\nK20c\n(\n0\n)\n1\n2\n-\n-\n-\n[\nCUDA\nmemcpy\nHtoD\n]\n193.31\nms\n146.02\nus\n(\n1\n1\n1\n)\n(\n1\n1\n1\n)\n32\n0\nB\n0\nB\n-\n-\nTesla\nK20c\n(\n0\n)\n1\n2\n2\n-\n-\ncdp_simple_quicksort\n(\nunsigned\nint\n*\n,\nint\n,\nint\n,\nint\n)\n[\n171\n]\n193.41\nms\n110.53\nus\n(\n1\n1\n1\n)\n(\n1\n1\n1\n)\n32\n0\nB\n256\nB\n-\n-\nTesla\nK20c\n(\n0\n)\n1\n2\n-5\n2\n(\n0\n0\n0\n)\ncdp_simple_quicksort\n(\nunsigned\nint\n*\n,\nint\n,\nint\n,\nint\n)\n193.45\nms\n125.57\nus\n(\n1\n1\n1\n)\n(\n1\n1\n1\n)\n32\n0\nB\n256\nB\n-\n-\nTesla\nK20c\n(\n0\n)\n1\n2\n-6\n2\n(\n0\n0\n0\n)\ncdp_simple_quicksort\n(\nunsigned\nint\n*\n,\nint\n,\nint\n,\nint\n)\n193.48\nms\n9.2480\nus\n(\n1\n1\n1\n)\n(\n1\n1\n1\n)\n32\n0\nB\n256\nB\n-\n-\nTesla\nK20c\n(\n0\n)\n1\n2\n-7\n-5\n(\n0\n0\n0\n)\ncdp_simple_quicksort\n(\nunsigned\nint\n*\n,\nint\n,\nint\n,\nint\n)\n193.52\nms\n107.23\nus\n(\n1\n1\n1\n)\n(\n1\n1\n1\n)\n32\n0\nB\n256\nB\n-\n-\nTesla\nK20c\n(\n0\n)\n1\n2\n-8\n-5\n(\n0\n0\n0\n)\ncdp_simple_quicksort\n(\nunsigned\nint\n*\n,\nint\n,\nint\n,\nint\n)\n193.53\nms\n93.824\nus\n(\n1\n1\n1\n)\n(\n1\n1\n1\n)\n32\n0\nB\n256\nB\n-\n-\nTesla\nK20c\n(\n0\n)\n1\n2\n-9\n-6\n(\n0\n0\n0\n)\ncdp_simple_quicksort\n(\nunsigned\nint\n*\n,\nint\n,\nint\n,\nint\n)\n193.57\nms\n117.47\nus\n(\n1\n1\n1\n)\n(\n1\n1\n1\n)\n32\n0\nB\n256\nB\n-\n-\nTesla\nK20c\n(\n0\n)\n1\n2\n-10\n-6\n(\n0\n0\n0\n)\ncdp_simple_quicksort\n(\nunsigned\nint\n*\n,\nint\n,\nint\n,\nint\n)\n193.58\nms\n5.0560\nus\n(\n1\n1\n1\n)\n(\n1\n1\n1\n)\n32\n0\nB\n256\nB\n-\n-\nTesla\nK20c\n(\n0\n)\n1\n2\n-11\n-8\n(\n0\n0\n0\n)\ncdp_simple_quicksort\n(\nunsigned\nint\n*\n,\nint\n,\nint\n,\nint\n)\n193.62\nms\n108.06\nus\n(\n1\n1\n1\n)\n(\n1\n1\n1\n)\n32\n0\nB\n256\nB\n-\n-\nTesla\nK20c\n(\n0\n)\n1\n2\n-12\n-8\n(\n0\n0\n0\n)\ncdp_simple_quicksort\n(\nunsigned\nint\n*\n,\nint\n,\nint\n,\nint\n)\n193.65\nms\n113.34\nus\n(\n1\n1\n1\n)\n(\n1\n1\n1\n)\n32\n0\nB\n256\nB\n-\n-\nTesla\nK20c\n(\n0\n)\n1\n2\n-13\n-10\n(\n0\n0\n0\n)\ncdp_simple_quicksort\n(\nunsigned\nint\n*\n,\nint\n,\nint\n,\nint\n)\n193.68\nms\n29.536\nus\n(\n1\n1\n1\n)\n(\n1\n1\n1\n)\n32\n0\nB\n256\nB\n-\n-\nTesla\nK20c\n(\n0\n)\n1\n2\n-14\n-12\n(\n0\n0\n0\n)\ncdp_simple_quicksort\n(\nunsigned\nint\n*\n,\nint\n,\nint\n,\nint\n)\n193.69\nms\n22.848\nus\n(\n1\n1\n1\n)\n(\n1\n1\n1\n)\n32\n0\nB\n256\nB\n-\n-\nTesla\nK20c\n(\n0\n)\n1\n2\n-15\n-10\n(\n0\n0\n0\n)\ncdp_simple_quicksort\n(\nunsigned\nint\n*\n,\nint\n,\nint\n,\nint\n)\n193.71\nms\n130.85\nus\n(\n1\n1\n1\n)\n(\n1\n1\n1\n)\n32\n0\nB\n256\nB\n-\n-\nTesla\nK20c\n(\n0\n)\n1\n2\n-16\n-13\n(\n0\n0\n0\n)\ncdp_simple_quicksort\n(\nunsigned\nint\n*\n,\nint\n,\nint\n,\nint\n)\n193.73\nms\n62.432\nus\n(\n1\n1\n1\n)\n(\n1\n1\n1\n)\n32\n0\nB\n256\nB\n-\n-\nTesla\nK20c\n(\n0\n)\n1\n2\n-17\n-12\n(\n0\n0\n0\n)\ncdp_simple_quicksort\n(\nunsigned\nint\n*\n,\nint\n,\nint\n,\nint\n)\n193.76\nms\n41.024\nus\n(\n1\n1\n1\n)\n(\n1\n1\n1\n)\n32\n0\nB\n256\nB\n-\n-\nTesla\nK20c\n(\n0\n)\n1\n2\n-18\n-13\n(\n0\n0\n0\n)\ncdp_simple_quicksort\n(\nunsigned\nint\n*\n,\nint\n,\nint\n,\nint\n)\n193.92\nms\n2.1760\nus\n-\n-\n-\n-\n-\n512\nB\n235.29\nMB\n/\ns\nTesla\nK20c\n(\n0\n)\n1\n2\n-\n-\n-\n[\nCUDA\nmemcpy\nDtoH\n]\nRegs\n:\nNumber\nof\nregisters\nused\nper\nCUDA\nthread\n.\nThis\nnumber\nincludes\nregisters\nused\ninternally\nby\nthe\nCUDA\ndriver\nand\n/\nor\ntools\nand\ncan\nbe\nmore\nthan\nwhat\nthe\ncompiler\nshows\n.\nSSMem\n:\nStatic\nshared\nmemory\nallocated\nper\nCUDA\nblock\n.\nDSMem\n:\nDynamic\nshared\nmemory\nallocated\nper\nCUDA\nblock\n.\nAPI-trace mode shows the timeline of all CUDA runtime and driver API calls invoked on the host in chronological order. Here’s an example:\n$nvprof\n--\nprint\n-\napi\n-\ntrace\nmatrixMul\n==\n27722\n==\nNVPROF\nis\nprofiling\nprocess\n27722\n,\ncommand\n:\nmatrixMul\n==\n27722\n==\nProfiling\napplication\n:\nmatrixMul\n[\nMatrix\nMultiply\nUsing\nCUDA\n]\n-\nStarting\n...\nGPU\nDevice\n0\n:\n\"GeForce GT 640M LE\"\nwith\ncompute\ncapability\n3.0\nMatrixA\n(\n320\n,\n320\n),\nMatrixB\n(\n640\n,\n320\n)\nComputing\nresult\nusing\nCUDA\nKernel\n...\ndone\nPerformance\n=\n35.35\nGFlop\n/\ns\n,\nTime\n=\n3.708\nmsec\n,\nSize\n=\n131072000\nOps\n,\nWorkgroupSize\n=\n1024\nthreads\n/\nblock\nChecking\ncomputed\nresult\nfor\ncorrectness\n:\nOK\nNote\n:\nFor\npeak\nperformance\n,\nplease\nrefer\nto\nthe\nmatrixMulCUBLAS\nexample\n.\n==\n27722\n==\nProfiling\nresult\n:\nStart\nDuration\nName\n108.38\nms\n6.2130\nus\ncuDeviceGetCount\n108.42\nms\n840\nns\ncuDeviceGet\n108.42\nms\n22.459\nus\ncuDeviceGetName\n108.45\nms\n11.782\nus\ncuDeviceTotalMem\n108.46\nms\n945\nns\ncuDeviceGetAttribute\n149.37\nms\n23.737\nus\ncudaLaunch\n(\nvoid\nmatrixMulCUDA\n<\nint\n=\n32\n>\n(\nfloat\n*\n,\nfloat\n*\n,\nfloat\n*\n,\nint\n,\nint\n)\n[\n2198\n])\n149.39\nms\n6.6290\nus\ncudaEventRecord\n149.40\nms\n1.10156\ns\ncudaEventSynchronize\n<\n...\nmore\noutput\n...\n>\n1.25096\ns\n21.543\nus\ncudaEventElapsedTime\n1.25103\ns\n1.5462\nms\ncudaMemcpy\n1.25467\ns\n153.93\nus\ncudaFree\n1.25483\ns\n75.373\nus\ncudaFree\n1.25491\ns\n75.564\nus\ncudaFree\n1.25693\ns\n10.901\nms\ncudaDeviceReset\nNote\nDue to the way the profiler is setup, the first “cuInit()” driver API call is never traced.\n3.2.3.\nEvent/metric Summary Mode\n\nTo see a list of all available events on a particular NVIDIA GPU, use the\n--query-events\noption. To see a list of all available metrics on a particular NVIDIA GPU, use the\n--query-metrics\noption.\nnvprof\nis able to collect multiple events/metrics at the same time. Here’s an example:\n$\nnvprof\n--\nevents\nwarps_launched\n,\nlocal_load\n--\nmetrics\nipc\nmatrixMul\n[\nMatrix\nMultiply\nUsing\nCUDA\n]\n-\nStarting\n...\n==\n6461\n==\nNVPROF\nis\nprofiling\nprocess\n6461\n,\ncommand\n:\nmatrixMul\nGPU\nDevice\n0\n:\n\"GeForce GTX TITAN\"\nwith\ncompute\ncapability\n3.5\nMatrixA\n(\n320\n,\n320\n),\nMatrixB\n(\n640\n,\n320\n)\nComputing\nresult\nusing\nCUDA\nKernel\n...\n==\n6461\n==\nWarning\n:\nSome\nkernel\n(\ns\n)\nwill\nbe\nreplayed\non\ndevice\n0\nin\norder\nto\ncollect\nall\nevents\n/\nmetrics\n.\ndone\nPerformance\n=\n6.39\nGFlop\n/\ns\n,\nTime\n=\n20.511\nmsec\n,\nSize\n=\n131072000\nOps\n,\nWorkgroupSize\n=\n1024\nthreads\n/\nblock\nChecking\ncomputed\nresult\nfor\ncorrectness\n:\nResult\n=\nPASS\nNOTE\n:\nThe\nCUDA\nSamples\nare\nnot\nmeant\nfor\nperformance\nmeasurements\n.\nResults\nmay\nvary\nwhen\nGPU\nBoost\nis\nenabled\n.\n==\n6461\n==\nProfiling\napplication\n:\nmatrixMul\n==\n6461\n==\nProfiling\nresult\n:\n==\n6461\n==\nEvent\nresult\n:\nInvocations\nEvent\nName\nMin\nMax\nAvg\nDevice\n\"GeForce GTX TITAN (0)\"\nKernel\n:\nvoid\nmatrixMulCUDA\n<\nint\n=\n32\n>\n(\nfloat\n*\n,\nfloat\n*\n,\nfloat\n*\n,\nint\n,\nint\n)\n301\nwarps_launched\n6400\n6400\n6400\n301\nlocal_load\n0\n0\n0\n==\n6461\n==\nMetric\nresult\n:\nInvocations\nMetric\nName\nMetric\nDescription\nMin\nMax\nAvg\nDevice\n\"GeForce GTX TITAN (0)\"\nKernel\n:\nvoid\nmatrixMulCUDA\n<\nint\n=\n32\n>\n(\nfloat\n*\n,\nfloat\n*\n,\nfloat\n*\n,\nint\n,\nint\n)\n301\nipc\nExecuted\nIPC\n1.282576\n1.299736\n1.291500\nIf the specified events/metrics can’t be profiled in a single run of the application,\nnvprof\nby default replays each kernel multiple times until all the events/metrics are collected.\nThe\n--replay-mode\n<mode>\noption can be used to change the replay mode. In “application replay” mode,\nnvprof\nre-runs the whole application instead of replaying each kernel, in order to collect all events/metrics. In some cases this mode can be faster than kernel replay mode if the application allocates large amount of device memory. Replay can also be turned off entirely, in which case the profiler will not collect some events/metrics.\nTo collect all events available on each device, use the option\n--events\nall\n.\nTo collect all metrics available on each device, use the option\n--metrics\nall\n.\nNote\nEvents or metrics collection may significantly change the overall performance characteristics of the application because all kernel executions are serialized on the GPU.\nNote\nIf a large number of events or metrics are requested, no matter which replay mode is chosen, the overall application execution time may increase significantly.\n3.2.4.\nEvent/metric Trace Mode\n\nIn event/metric trace mode, event and metric values are shown for each kernel execution. By default, event and metric values are aggregated across all units in the GPU. For example, multiprocessor specific events are aggregated across all multiprocessors on the GPU. If\n--aggregate-mode\noff\nis specified, values of each unit are shown. For example, in the following example, the “branch” event value is shown for each multiprocessor on the GPU:\n$\nnvprof\n--\naggregate\n-\nmode\noff\n--\nevents\nlocal_load\n--\nprint\n-\ngpu\n-\ntrace\nmatrixMul\n[\nMatrix\nMultiply\nUsing\nCUDA\n]\n-\nStarting\n...\n==\n6740\n==\nNVPROF\nis\nprofiling\nprocess\n6740\n,\ncommand\n:\nmatrixMul\nGPU\nDevice\n0\n:\n\"GeForce GTX TITAN\"\nwith\ncompute\ncapability\n3.5\nMatrixA\n(\n320\n,\n320\n),\nMatrixB\n(\n640\n,\n320\n)\nComputing\nresult\nusing\nCUDA\nKernel\n...\ndone\nPerformance\n=\n16.76\nGFlop\n/\ns\n,\nTime\n=\n7.822\nmsec\n,\nSize\n=\n131072000\nOps\n,\nWorkgroupSize\n=\n1024\nthreads\n/\nblock\nChecking\ncomputed\nresult\nfor\ncorrectness\n:\nResult\n=\nPASS\nNOTE\n:\nThe\nCUDA\nSamples\nare\nnot\nmeant\nfor\nperformance\nmeasurements\n.\nResults\nmay\nvary\nwhen\nGPU\nBoost\nis\nenabled\n.\n==\n6740\n==\nProfiling\napplication\n:\nmatrixMul\n==\n6740\n==\nProfiling\nresult\n:\nDevice\nContext\nStream\nKernel\nlocal_load\n(\n0\n)\nlocal_load\n(\n1\n)\n...\nGeForce\nGTX\nTIT\n1\n7\nvoid\nmatrixMulCUDA\n<\ni\n0\n0\n...\nGeForce\nGTX\nTIT\n1\n7\nvoid\nmatrixMulCUDA\n<\ni\n0\n0\n...\n<\n...\nmore\noutput\n...\n>\nNote\nAlthough\n--aggregate-mode\napplies to metrics, some metrics are only available in aggregate mode and some are only available in non-aggregate mode.\n3.3.\nProfiling Controls\n\n3.3.1.\nTimeout\n\nA timeout (in seconds) can be provided to\nnvprof\n. The CUDA application being profiled will be killed by\nnvprof\nafter the timeout. Profiling result collected before the timeout will be shown.\nNote\nTimeout starts counting from the moment the CUDA driver is initialized. If the application doesn’t call any CUDA APIs, timeout won’t be triggered.\n3.3.2.\nConcurrent Kernels\n\nConcurrent-kernel profiling is supported, and is turned on by default. To turn the feature off, use the option\n--concurrent-kernels\noff\n. This forces concurrent kernel executions to be serialized when a CUDA application is run with\nnvprof\n.\n3.3.3.\nProfiling Scope\n\nWhen collecting events/metrics,\nnvprof\nprofiles all kernels launched on all visible CUDA devices by default. This profiling scope can be limited by the following options.\n--devices\n<device\nIDs>\napplies to\n--events\n,\n--metrics\n,\n--query-events\nand\n--query-metrics\noptions\nthat follows it\n. It limits these options to collect events/metrics only on the devices specified by\n<device\nIDs>\n, which can be a list of device ID numbers separated by comma.\n--kernels\n<kernel\nfilter>\napplies to\n--events\nand\n--metrics\noptions\nthat follows it\n. It limits these options to collect events/metrics only on the kernels specified by\n<kernel\nfilter>\n, which has the following syntax:\n<kernel name>\nor\n<context id/name>:<stream id/name>:<kernel\nname>:<invocation>\nEach string in the angle brackets can be a standard Perl regular expression. Empty string matches any number or character combination.\nInvocation number\nn\nindicates the\nn\nth invocation of the kernel. If invocation is a positive number, it’s strictly matched against the invocation of the kernel. Otherwise it’s treated as a regular expression. Invocation number is counted separately for each kernel. So for instance\n:::3\nwill match the 3rd invocation of every kernel.\nIf the context/stream string is a positive number, it’s strictly matched against the cuda context/stream ID. Otherwise it’s treated as a regular expression and matched against the context/stream name provided by the NVIDIA Tools Extension.\nBoth\n--devices\nand\n--kernels\ncan be specified multiple times, with distinct events/metrics associated.\n--events\n,\n--metrics\n,\n--query-events\nand\n--query-metrics\nare controlled by the nearest scope options before them.\nAs an example, the following command,\nnvprof --devices 0 --metrics ipc\n--kernels \"1:foo:bar:2\" --events local_load a.out\ncollects metric\nipc\non all kernels launched on device 0. It also collects event\nlocal_load\nfor any kernel whose name contains\nbar\nand is the 2nd instance launched on context 1 and on stream named\nfoo\non device 0.\n3.3.4.\nMultiprocess Profiling\n\nBy default,\nnvprof\nonly profiles the application specified by the command-line argument. It doesn’t trace child processes launched by that process. To profile all processes launched by an application, use the\n--profile-child-processes\noption.\nNote\nnvprof\ncannot profile processes that\nfork()\nbut do not then\nexec()\n.\nnvprof\nalso has a “profile all processes” mode, in which it profiles every CUDA process launched on the same system by the same user who launched\nnvprof\n. Exit this mode by typing “Ctrl-c”.\nNote\nCPU profiling is not supported in multi-process mode.\n3.3.5.\nSystem Profiling\n\nFor devices that support system profiling, nvprof can enable low frequency sampling of the power, clock, and thermal behavior of each GPU used by the application. This feature is turned off by default. To turn on this feature, use\n--system-profiling\non\n. To see the detail of each sample point, combine the above option with\n--print-gpu-trace\n.\n3.3.6.\nUnified Memory Profiling\n\nFor GPUs that support Unified Memory,\nnvprof\ncollects the Unified Memory related memory traffic to and from each GPU on your system. This feature is enabled by default. This feature can be disabled with\n--unified-memory-profiling\noff\n. To see the detail of each memory transfer while this feature is enabled, use\n--print-gpu-trace\n.\nOn multi-GPU configurations without P2P support between any pair of devices that support Unified Memory, managed memory allocations are placed in zero-copy memory. In this case Unified Memory profiling is not supported. In certain cases, the environment variable\nCUDA_MANAGED_FORCE_DEVICE_ALLOC\ncan be set to force managed allocations to be in device memory and to enable migration on these hardware configurations. In this case Unified Memory profiling is supported. Normally, using the environment variable\nCUDA_VISIBLE_DEVICES\nis recommended to restrict CUDA to only use those GPUs that have P2P support. Please refer to the environment variables section in the\nCUDA C++ Programming Guide\nfor further details.\n3.3.7.\nCPU Thread Tracing\n\nIn order to allow a correct\nDependency Analysis\n,\nnvprof\ncan collect information about CPU-side threading APIs. This can be enabled by specifying\n--cpu-thread-tracing\non\nduring measurement. Recording this information is necessary if\nthe application uses multiple CPU threads and\nat least two of these threads call the CUDA API.\nCurrently, only POSIX threads (Pthreads) are supported. For performance reasons, only selected Pthread API calls may be recorded.\nnvprof\ntries to detect which calls are necessary to model the execution behavior and filters others. Filtered calls include\npthread_mutex_lock\nand\npthread_mutex_unlock\nwhen those do not cause any concurrent thread to block.\nNote\nCPU thread tracing is not available on Windows.\nNote\nCPU thread tracing starts after the first CUDA API call, from the thread issuing this call. Therefore, the application must call e.g.\ncuInit\nfrom its main thread before spawning any other user threads that call the CUDA API.\n3.4.\nOutput\n\n3.4.1.\nAdjust Units\n\nBy default,\nnvprof\nadjusts the time units automatically to get the most precise time values. The\n--normalized-time-unit\noptions can be used to get fixed time units throughout the results.\n3.4.2.\nCSV\n\nFor each profiling mode, option\n--csv\ncan be used to generate output in comma-separated values (CSV) format. The result can be directly imported to spreadsheet software such as Excel.\n3.4.3.\nExport/Import\n\nFor each profiling mode, option\n--export-profile\ncan be used to generate a result file. This file is not human-readable, but can be imported back to\nnvprof\nusing the option\n--import-profile\n, or into the Visual Profiler.\nNote\nThe profilers use SQLite as the format of the export profiles. Writing files in such format may require more disk operations than writing a plain file. Thus, exporting profiles to slower devices such as a network drive may slow down the execution of the application.\n3.4.4.\nDemangling\n\nBy default,\nnvprof\ndemangles C++ function names. Use option\n--demangling\noff\nto turn this feature off.\n3.4.5.\nRedirecting Output\n\nBy default,\nnvprof\nsends most of its output to\nstderr\n. To redirect the output, use\n--log-file\n.\n--log-file\n%1\ntells\nnvprof\nto redirect all output to\nstdout\n.\n--log-file\n<filename>\nredirects output to a file. Use\n%p\nin the filename to be replaced by the process ID of\nnvprof\n,\n%h\nby the hostname ,\n%q{ENV}\nby the value of environment variable\nENV\n, and\n%%\nby\n%\n.\n3.4.6.\nDependency Analysis\n\nnvprof\ncan run a\nDependency Analysis\nafter the application has been profiled, using the\n--dependency-analysis\noption. This analysis can also be applied to imported profiles. It requires to collect the full CUDA API and GPU activity trace during measurement. This is the default for\nnvprof\nif not disabled using\n--profile-api-trace\nnone\n.\nFor applications using CUDA from multiple CPU threads,\nCPU Thread Tracing\nshould be enabled, too. The option\n--print-dependency-analysis-trace\ncan be specified to change from a summary output to a trace output, showing computed metrics such as time on the critical path per function instance rather than per function type.\nAn example for dependency analysis summary output with all computed metrics aggregated per function type is shown below. The table is sorted first by time on the critical path and second by waiting time. The summary contains an entry named\nOther\n, referring to all CPU activity that is not tracked by\nnvprof\n(e.g. the application’s\nmain\nfunction).\n==\n20704\n==\nDependency\nAnalysis\n:\n==\n20704\n==\nAnalysis\nprogress\n:\n100\n%\nCritical\npath\n(\n%\n)\nCritical\npath\nWaiting\ntime\nName\n%\ns\ns\n92.06\n4.061817\n0.000000\nclock_block\n(\nlong\n*\n,\nlong\n)\n4.54\n0.200511\n0.000000\ncudaMalloc\n3.25\n0.143326\n0.000000\ncudaDeviceReset\n0.13\n5.7273280e-03\n0.000000\n<\nOther\n>\n0.01\n2.7200900e-04\n0.000000\ncudaFree\n0.00\n0.000000\n4.062506\npthread_join\n0.00\n0.000000\n4.061790\ncudaStreamSynchronize\n0.00\n0.000000\n1.015485\npthread_mutex_lock\n0.00\n0.000000\n1.013711\npthread_cond_wait\n0.00\n0.000000\n0.000000\npthread_mutex_unlock\n0.00\n0.000000\n0.000000\npthread_exit\n0.00\n0.000000\n0.000000\npthread_enter\n0.00\n0.000000\n0.000000\npthread_create\n0.00\n0.000000\n0.000000\npthread_cond_signal\n0.00\n0.000000\n0.000000\ncudaLaunch\n3.5.\nCPU Sampling\n\nSometimes it’s useful to profile the CPU portion of your application, in order to better understand the bottlenecks and identify potential hotspots for the entire CUDA application. For the CPU portion of the application,\nnvprof\nis able to sample the program counter and call stacks at a certain frequency. The data is then used to construct a graph, with nodes being frames in each call stack. Function and library symbols are also extracted if available. A sample graph is shown below:\n========\nCPU\nprofiling\nresult\n(\nbottom\nup\n)\n:\n45.45\n%\ncuInit\n|\n45.45\n%\ncudart\n::\nglobalState\n::\nloadDriverInternal\n(\nvoid\n)\n|\n45.45\n%\ncudart\n::\n__loadDriverInternalUtil\n(\nvoid\n)\n|\n45.45\n%\npthread_once\n|\n45.45\n%\ncudart\n::\ncuosOnce\n(\nint\n*\n,\nvoid\n(\n*\n)\n(\nvoid\n))\n|\n45.45\n%\ncudart\n::\nglobalState\n::\nloadDriver\n(\nvoid\n)\n|\n45.45\n%\ncudart\n::\nglobalState\n::\ninitializeDriver\n(\nvoid\n)\n|\n45.45\n%\ncudaMalloc\n|\n45.45\n%\nmain\n33.33\n%\ncuDevicePrimaryCtxRetain\n|\n33.33\n%\ncudart\n::\ncontextStateManager\n::\ninitPrimaryContext\n(\ncudart\n::\ndevice\n*\n)\n|\n33.33\n%\ncudart\n::\ncontextStateManager\n::\ntryInitPrimaryContext\n(\ncudart\n::\ndevice\n*\n)\n|\n33.33\n%\ncudart\n::\ncontextStateManager\n::\ninitDriverContext\n(\nvoid\n)\n|\n33.33\n%\ncudart\n::\ncontextStateManager\n::\ngetRuntimeContextState\n(\ncudart\n::\ncontextState\n**\n,\nbool\n)\n|\n33.33\n%\ncudart\n::\ngetLazyInitContextState\n(\ncudart\n::\ncontextState\n**\n)\n|\n33.33\n%\ncudart\n::\ndoLazyInitContextState\n(\nvoid\n)\n|\n33.33\n%\ncudart\n::\ncudaApiMalloc\n(\nvoid\n**\n,\nunsigned\nlong\n)\n|\n33.33\n%\ncudaMalloc\n|\n33.33\n%\nmain\n18.18\n%\ncuDevicePrimaryCtxReset\n|\n18.18\n%\ncudart\n::\ndevice\n::\nresetPrimaryContext\n(\nvoid\n)\n|\n18.18\n%\ncudart\n::\ncudaApiThreadExit\n(\nvoid\n)\n|\n18.18\n%\ncudaThreadExit\n|\n18.18\n%\nmain\n3.03\n%\ncudbgGetAPIVersion\n3.03\n%\nstart_thread\n3.03\n%\nclone\nThe graph can be presented in different “views” (\ntop-down\n,\nbottom-up\nor\nflat\n), allowing the user to analyze the sampling data from different perspectives. For instance, the\nbottom-up\nview (shown above) can be useful in identifying the “hot” functions in which the application is spending most of its time. The\ntop-down\nview gives a break-down of the application execution time, starting from the\nmain\nfunction, allowing you to find “call paths” which are executed frequently.\nBy default the CPU sampling feature is disabled. To enable it, use the option\n--cpu-profiling\non\n. The next section describes all the options controlling the CPU sampling behavior.\nCPU sampling is supported on Linux and Windows for Intel x86/x86_64 architecture.\nNote\nWhen using the CPU profiling feature on POSIX systems, the profiler samples the application by sending periodic signals. Applications should therefore ensure that system calls are handled appropriately when interrupted.\nNote\nOn Windows, nvprof requires Visual Studio installation (2010 or later) and compiler-generated .PDB (program database) files to resolve symbol information. When building your application, ensure that .PDB files are created and placed next to the profiled executable and libraries.\n3.5.1.\nCPU Sampling Limitations\n\nThe following are known issues with the current release.\nCPU sampling is not supported on the mobile devices.\nCPU sampling is currently not supported in multi-process profiling mode.\nThe result stack traces might not be complete under some compiler optimizations, notably frame pointer omission and function inlining.\nThe CPU sampling result does not support CSV mode.\n3.6.\nOpenACC\n\nOn 64bit Linux platforms,\nnvprof\nsupports recording OpenACC activities using the CUPTI Activity API. This allows to investigate the performance on the level of OpenACC constructs in addition to the underlying, compiler-generated CUDA API calls.\nOpenACC profiling in\nnvprof\nrequires the targeted application to use PGI OpenACC runtime 19.1 or later.\nEven though recording OpenACC activities is only supported on x86_64 Linux systems, importing and viewing previously generated profile data is available on all platforms supported by\nnvprof\n.\nAn example for OpenACC summary output is shown below. The CUPTI OpenACC activities are mapped to the original OpenACC constructs using their source file and line information. For\nacc_enqueue_launch\nactivities, it will furthermore show the launched CUDA kernel name which is generated by the OpenACC compiler. By default, nvprof will demangle kernel names generated by the OpenACC compiler. You can pass\n--demangling\noff\nto disable this behavior.\n==20854== NVPROF is profiling process 20854, command: ./acc_saxpy\n==20854== Profiling application: ./acc_saxpy\n==20854== Profiling result:\n==20854== OpenACC (excl):\nTime(%)      Time     Calls       Avg       Min       Max  Name\n33.16%  1.27944s       200  6.3972ms  24.946us  12.770ms  acc_implicit_wait@acc_saxpy.cpp:42\n33.12%  1.27825s       100  12.783ms  12.693ms  12.787ms  acc_wait@acc_saxpy.cpp:54\n33.12%  1.27816s       100  12.782ms  12.720ms  12.786ms  acc_wait@acc_saxpy.cpp:61\n0.14%  5.4550ms       100  54.549us  51.858us  71.461us  acc_enqueue_download@acc_saxpy.cpp:43\n0.07%  2.5190ms       100  25.189us  23.877us  60.269us  acc_enqueue_launch@acc_saxpy.cpp:50 (kernel2(int, float, float*, float*)_50_gpu)\n0.06%  2.4988ms       100  24.987us  24.161us  29.453us  acc_enqueue_launch@acc_saxpy.cpp:60 (kernel3(int, float, float*, float*)_60_gpu)\n0.06%  2.2799ms       100  22.798us  21.654us  56.674us  acc_enqueue_launch@acc_saxpy.cpp:42 (kernel1(int, float, float*, float*)_42_gpu)\n0.05%  2.1068ms       100  21.068us  20.444us  33.159us  acc_enqueue_download@acc_saxpy.cpp:51\n0.05%  2.0854ms       100  20.853us  19.453us  23.697us  acc_enqueue_download@acc_saxpy.cpp:61\n0.04%  1.6265ms       100  16.265us  15.284us  49.632us  acc_enqueue_upload@acc_saxpy.cpp:50\n0.04%  1.5963ms       100  15.962us  15.052us  19.749us  acc_enqueue_upload@acc_saxpy.cpp:60\n0.04%  1.5393ms       100  15.393us  14.592us  56.414us  acc_enqueue_upload@acc_saxpy.cpp:42\n0.01%  558.54us       100  5.5850us  5.3700us  6.2090us  acc_implicit_wait@acc_saxpy.cpp:43\n0.01%  266.13us       100  2.6610us  2.4630us  4.7590us  acc_compute_construct@acc_saxpy.cpp:42\n0.01%  211.77us       100  2.1170us  1.9980us  4.1770us  acc_compute_construct@acc_saxpy.cpp:50\n0.01%  209.14us       100  2.0910us  1.9880us  2.2500us  acc_compute_construct@acc_saxpy.cpp:60\n0.00%  55.066us         1  55.066us  55.066us  55.066us  acc_enqueue_launch@acc_saxpy.cpp:70 (initVec(int, float, float*)_70_gpu)\n0.00%  13.209us         1  13.209us  13.209us  13.209us  acc_compute_construct@acc_saxpy.cpp:70\n0.00%  10.901us         1  10.901us  10.901us  10.901us  acc_implicit_wait@acc_saxpy.cpp:70\n0.00%       0ns       200       0ns       0ns       0ns  acc_delete@acc_saxpy.cpp:61\n0.00%       0ns       200       0ns       0ns       0ns  acc_delete@acc_saxpy.cpp:43\n0.00%       0ns       200       0ns       0ns       0ns  acc_create@acc_saxpy.cpp:60\n0.00%       0ns       200       0ns       0ns       0ns  acc_create@acc_saxpy.cpp:42\n0.00%       0ns       200       0ns       0ns       0ns  acc_delete@acc_saxpy.cpp:51\n0.00%       0ns       200       0ns       0ns       0ns  acc_create@acc_saxpy.cpp:50\n0.00%       0ns         2       0ns       0ns       0ns  acc_alloc@acc_saxpy.cpp:42\n3.6.1.\nOpenACC Options\n\nTable 1 contains OpenACC profiling related command-line options of\nnvprof\n.\nTable 1. OpenACC Options\n\nOption\nDescription\n--openacc-profiling\n<on|off>\nTurn on/off OpenACC profiling. Note: OpenACC profiling is only supported on x86_64 Linux. Default is on.\n--print-openacc-summary\nPrint a summary of all recorded OpenACC activities.\n--print-openacc-trace\nPrint a detailed trace of all recorded OpenACC activities, including each activity’s timestamp and duration.\n--print-openacc-constructs\nInclude the name of the OpenACC parent construct that caused an OpenACC activity to be emitted. Note that for applications using PGI OpenACC runtime before 19.1, this value will always be\nunknown\n.\n--openacc-summary-mode\n<exclusive|inclusive>\nSpecify how activity durations are presented in the OpenACC summary. Allowed values: “exclusive” - exclusive durations (default). “inclusive” - inclusive durations. See\nOpenACC Summary Modes\nfor more information.\n3.6.2.\nOpenACC Summary Modes\n\nnvprof\nsupports two modes for presenting OpenACC activity durations in the OpenACC summary mode (enabled with\n--print-openacc-summary\n): “exclusive” and “inclusive”.\nInclusive: In this mode, all durations represent the actual runtime of an activity. This includes the time spent in this activity as well as in all its children (callees).\nExclusive: In this mode, all durations represent the time spent solely in this activity. This includes the time spent in this activity but excludes the runtime of all of its children (callees).\nAs an example, consider the OpenACC\nacc_compute_construct\nwhich itself calls\nacc_enqueue_launch\nto launch a kernel to the device and\nacc_implicit_wait\n, which waits on the completion of this kernel. In “inclusive” mode, the duration for\nacc_compute_construct\nwill include the time spent in\nacc_enqueue_launch\nand\nacc_implicit_wait\n. In “exclusive” mode, those two durations are subtracted. In the summary profile, this is helpful to identify if a long\nacc_compute_construct\nrepresents a high launch overhead or rather a long wait (synchronization) time.\n3.7.\nOpenMP\n\nOn 64bit Linux platforms,\nnvprof\nsupports recording OpenMP activities\nOpenMP profiling in\nnvprof\nrequires the targeted application to use a runtime supporting the OpenMP Tools interface (OMPT). (PGI version 19.1 or greater using the LLVM code generator supports OMPT).\nEven though recording OpenMP activities is only supported on x86_64 Linux systems, importing and viewing previously generated profile data is available on all platforms supported by\nnvprof\n.\nAn example for the OpenMP summary output is shown below:\n==\n20854\n==\nNVPROF\nis\nprofiling\nprocess\n20854\n,\ncommand\n:\n.\n/\nopenmp\n==\n20854\n==\nProfiling\napplication\n:\n.\n/\nopenmp\n==\n20854\n==\nProfiling\nresult\n:\nNo\nkernels\nwere\nprofiled\n.\nNo\nAPI\nactivities\nwere\nprofiled\n.\nType\nTime\n(\n%\n)\nTime\nCalls\nAvg\nMin\nMax\nName\nOpenMP\n(\nincl\n)\n:\n99.97\n%\n277.10\nms\n20\n13.855\nms\n13.131\nms\n18.151\nms\nomp_parallel\n0.03\n%\n72.728\nus\n19\n3.8270\nus\n2.9840\nus\n9.5610\nus\nomp_idle\n0.00\n%\n7.9170\nus\n7\n1.1310\nus\n1.0360\nus\n1.5330\nus\nomp_wait_barrier\n3.7.1.\nOpenMP Options\n\nTable 2 contains OpenMP profiling related command-line options of\nnvprof\n.\nTable 2. OpenMP Options\n\nOption\nDescription\n--print-openmp-summary\nPrint a summary of all recorded OpenMP activities.\n4.\nRemote Profiling\n\nRemote profiling is the process of collecting profile data from a remote system that is different than the host system at which that profile data will be viewed and analyzed. There are two ways to perform remote profiling. You can profile your remote application directly from\nnsight\northe Visual Profiler. Or you can use\nnvprof\nto collect the profile data on the remote system and then use\nnvvp\non the host system to view and analyze the data.\n4.1.\nRemote Profiling With Visual Profiler\n\nThis section describes how to perform remote profiling by using the remote capabilities of nsight and the Visual Profiler.\nNsight Eclipse Edition supports full remote development including remote building, debugging, and profiling. Using these capabilities you can create a project and launch configuration that allows you to remotely profile your application. See the Nsight Eclipse Edition documentation for more information.\nThe\nVisual\nProfiler\nalso enables remote profiling. As shown in the following figure, when creating a new session or editing an existing session you can specify that the application being profiled resides on a remote system. Once you have configured your session to use a remote application, you can perform all profiler functions in the same way as you would with a local application, including timeline generation, guided analysis, and event and metric collection.\nTo use the Visual Profiler remote profiling you must install the same version of the CUDA Toolkit on both the host and remote systems. It is not necessary for the host system to have an NVIDIA GPU, but ensure that the CUDA Toolkit installed on the host system supports the target device. The host and remote systems may run different operating systems or have different CPU architectures. Only a remote system running Linux is supported. The remote system must be accessible via SSH.\n4.1.1.\nOne-hop remote profiling\n\nIn certain remote profiling setups, the machine running the actual CUDA program is not accessible from the machine running the Visual Profiler. These two machines are connected via an intermediate machine, which we refer to as the login node.\nThe host machine is the one which is running the Visual Profiler.\nThe login node is where the one-hop profiling script will run. We only need ssh, scp and perl on this machine.\nThe compute node is where the actual CUDA application will run and profiled. The profiling data generated will be copied over to the login node, so that it can be used by the Visual Profiler on the host.\nTo configure one-hop profiling, you need to do the following one-time setup:\nCopy the\none-hop profiling Perl script\nonto the login node.\nIn Visual Profiler, add the login node as a new remote connection.\nIn Visual Profiler’s New Session wizard, use the Configure button to open the toolkit configuration window. Here, use the radio button to select the custom script option, and browse to point to the Perl script on the login node.\nOnce this setup is complete, you can profile the application as you would on any remote machine. Copying all data to and from the login and compute nodes happens transparently and automatically.\n4.2.\nRemote Profiling With\nnvprof\n\nThis section describes how to perform remote profiling by running\nnvprof\nmanually on the remote system and then importing the collected profile data into the\nVisual\nProfiler\n.\n4.2.1.\nCollect Data On Remote System\n\nThere are three common remote profiling use cases that can be addressed by using\nnvprof\nand the Visual Profiler.\nTimeline\nThe first use case is to collect a timeline of the application executing on the remote system. The timeline should be collected in a way that most accurately reflects the behavior of the application. To collect the timeline execute the following on the remote system. See\n​nvprof\nfor more information on\nnvprof\noptions.\n$\nnvprof\n--\nexport\n-\nprofile\ntimeline\n.\nprof\n<\napp\n>\n<\napp\nargs\n>\nThe profile data will be collected in timeline.prof. You should copy this file back to the host system and then import it into the Visual Profiler as described in the next section.\nMetrics And Events\nThe second use case is to collect events or metrics for all kernels in an application for which you have already collected a timeline. Collecting events or metrics for all kernels will significantly change the overall performance characteristics of the application because all kernel executions will be serialized on the GPU. Even though overall application performance is changed, the event or metric values for individual kernels will be correct and so you can merge the collected event and metric values onto a previously collected timeline to get an accurate picture of the applications behavior. To collect events or metrics you use the\n--events\nor\n--metrics\nflag. The following shows an example using just the\n--metrics\nflag to collect two metrics.\n$\nnvprof\n--\nmetrics\nachieved_occupancy\n,\nipc\n-\no\nmetrics\n.\nprof\n<\napp\n>\n<\napp\nargs\n>\nYou can collect any number of events and metrics for each\nnvprof\ninvocation, and you can invoke\nnvprof\nmultiple times to collect multiple metrics.prof files. To get accurate profiling results, it is important that your application conform to the requirements detailed in\nApplication Requirements\n.\nThe profile data will be collected in the metrics.prof file(s). You should copy these files back to the host system and then import it into the Visual Profiler as described in the next section.\nAnalysis For Individual Kernel\nThe third common remote profiling use case is to collect the metrics needed by the analysis system for an individual kernel. When imported into the Visual Profiler this data will enable the analysis system to analyze the kernel and report optimization opportunities for that kernel. To collect the analysis data execute the following on the remote system. It is important that the\n--kernels\noption appear before the\n--analysis-metrics\noption so that metrics are collected only for the kernel(s) specified by\nkernel\nspecifier\n. See\nProfiling Scope\nfor more information on the\n--kernels\noption.\n$\nnvprof\n--\nkernels\n<\nkernel\nspecifier\n>\n--\nanalysis\n-\nmetrics\n-\no\nanalysis\n.\nprof\n<\napp\n>\n<\napp\nargs\n>\nThe profile data will be collected in analysis.prof. You should copy this file back to the host system and then import it into the Visual Profiler as described in the next section.\n4.2.2.\nView And Analyze Data\n\nThe collected profile data is viewed and analyzed by importing it into the Visual Profiler on the host system. See\nImport Session\nfor more information about importing.\nTimeline, Metrics And Events\nTo view collected timeline data, the timeline.prof file can be imported into the Visual Profiler as described in\nImport Single-Process nvprof Session\n. If metric or event data was also collected for the application, the corresponding metrics.prof file(s) can be imported into the Visual Profiler along with the timeline so that the events and metrics collected for each kernel are associated with the corresponding kernel in the timeline.\nGuided Analysis For Individual Kernel\nTo view collected analysis data for an individual kernel, the analysis.prof file can be imported into the\nVisual\nProfiler\nas described in\nImport Single-Process nvprof Session\n. The analysis.prof must be imported by itself. The timeline will show just the individual kernel that we specified during data collection. After importing, the guided analysis system can be used to explore the optimization opportunities for the kernel.\n5.\nNVIDIA Tools Extension\n\nNVIDIA Tools Extension (NVTX) is a C-based Application Programming Interface (API) for annotating events, code ranges, and resources in your applications. Applications which integrate NVTX can use the Visual Profiler to capture and visualize these events and ranges. The NVTX API provides two core services:\nTracing of CPU events and time ranges.\nNaming of OS and CUDA resources.\nNVTX can be quickly integrated into an application. The sample program below shows the use of marker events, range events, and resource naming.\nvoid Wait(int waitMilliseconds) {\nnvtxNameOsThread(“MAIN”);\nnvtxRangePush(__FUNCTION__);\nnvtxMark(\"Waiting...\");\nSleep(waitMilliseconds);\nnvtxRangePop();\n}\nint main(void) {\nnvtxNameOsThread(\"MAIN\");\nnvtxRangePush(__FUNCTION__);\nWait();\nnvtxRangePop();\n}\n5.1.\nNVTX API Overview\n\nFiles\nThe core NVTX API is defined in file nvToolsExt.h, whereas CUDA-specific extensions to the NVTX interface are defined in nvToolsExtCuda.h and nvToolsExtCudaRt.h. On Linux the NVTX shared library is called\nlibnvToolsExt.so\nand on macOS the shared library is called\nlibnvToolsExt.dylib\n. On Windows the library (.lib) and runtime components (.dll) are named\nnvToolsExt[bitness=32|64]_[version].{dll|lib}\n.\nFunction Calls\nAll NVTX API functions start with an nvtx name prefix and may end with one of the three suffixes: A, W, or Ex. NVTX functions with these suffixes exist in multiple variants, performing the same core functionality with different parameter encodings. Depending on the version of the NVTX library, available encodings may include ASCII (A), Unicode (W), or event structure (Ex).\nThe CUDA implementation of NVTX only implements the ASCII (A) and event structure (Ex) variants of the API, the Unicode (W) versions are not supported and have no effect when called.\nReturn Values\nSome of the NVTX functions are defined to have return values. For example, the\nnvtxRangeStart()\nfunction returns a unique range identifier and\nnvtxRangePush()\nfunction outputs the current stack level. It is recommended not to use the returned values as part of conditional code in the instrumented application. The returned values can differ between various implementations of the NVTX library and, consequently, having added dependencies on the return values might work with one tool, but may fail with another.\n5.2.\nNVTX API Events\n\nMarkers are used to describe events that occur at a specific time during the execution of an application, while ranges detail the time span in which they occur. This information is presented alongside all of the other captured data, which makes it easier to understand the collected information. All markers and ranges are identified by a message string. The Ex version of the marker and range APIs also allows category, color, and payload attributes to be associated with the event using the event attributes structure.\n5.2.1.\nNVTX Markers\n\nA marker is used to describe an instantaneous event. A marker can contain a text message or specify additional information using the\nevent attributes structure\n. Use\nnvtxMarkA\nto create a marker containing an ASCII message. Use\nnvtxMarkEx()\nto create a marker containing additional attributes specified by the event attribute structure. The\nnvtxMarkW()\nfunction is not supported in the CUDA implementation of NVTX and has no effect if called.\nCode Example\nnvtxMarkA\n(\n\"My mark\"\n);\nnvtxEventAttributes_t\neventAttrib\n=\n{\n0\n};\neventAttrib\n.\nversion\n=\nNVTX_VERSION\n;\neventAttrib\n.\nsize\n=\nNVTX_EVENT_ATTRIB_STRUCT_SIZE\n;\neventAttrib\n.\ncolorType\n=\nNVTX_COLOR_ARGB\n;\neventAttrib\n.\ncolor\n=\nCOLOR_RED\n;\neventAttrib\n.\nmessageType\n=\nNVTX_MESSAGE_TYPE_ASCII\n;\neventAttrib\n.\nmessage\n.\nascii\n=\n\"my mark with attributes\"\n;\nnvtxMarkEx\n(\n&\neventAttrib\n);\n5.2.2.\nNVTX Range Start/Stop\n\nA start/end range is used to denote an arbitrary, potentially non-nested, time span. The start of a range can occur on a different thread than the end of the range. A range can contain a text message or specify additional information using the\nevent attributes structure\n. Use\nnvtxRangeStartA()\nto create a marker containing an ASCII message. Use\nnvtxRangeStartEx()\nto create a range containing additional attributes specified by the event attribute structure. The\nnvtxRangeStartW()\nfunction is not supported in the CUDA implementation of NVTX and has no effect if called. For the correlation of a start/end pair, a unique correlation ID is created that is returned from\nnvtxRangeStartA()\nor\nnvtxRangeStartEx()\n, and is then passed into\nnvtxRangeEnd()\n.\nCode Example\n// non-overlapping range\nnvtxRangeId_t\nid1\n=\nnvtxRangeStartA\n(\n\"My range\"\n);\nnvtxRangeEnd\n(\nid1\n);\nnvtxEventAttributes_t\neventAttrib\n=\n{\n0\n};\neventAttrib\n.\nversion\n=\nNVTX_VERSION\n;\neventAttrib\n.\nsize\n=\nNVTX_EVENT_ATTRIB_STRUCT_SIZE\n;\neventAttrib\n.\ncolorType\n=\nNVTX_COLOR_ARGB\n;\neventAttrib\n.\ncolor\n=\nCOLOR_BLUE\n;\neventAttrib\n.\nmessageType\n=\nNVTX_MESSAGE_TYPE_ASCII\n;\neventAttrib\n.\nmessage\n.\nascii\n=\n\"my start/stop range\"\n;\nnvtxRangeId_t\nid2\n=\nnvtxRangeStartEx\n(\n&\neventAttrib\n);\nnvtxRangeEnd\n(\nid2\n);\n// overlapping ranges\nnvtxRangeId_t\nr1\n=\nnvtxRangeStartA\n(\n\"My range 0\"\n);\nnvtxRangeId_t\nr2\n=\nnvtxRangeStartA\n(\n\"My range 1\"\n);\nnvtxRangeEnd\n(\nr1\n);\nnvtxRangeEnd\n(\nr2\n);\n5.2.3.\nNVTX Range Push/Pop\n\nA push/pop range is used to denote nested time span. The start of a range must occur on the same thread as the end of the range. A range can contain a text message or specify additional information using the\nevent attributes structure\n. Use\nnvtxRangePushA()\nto create a marker containing an ASCII message. Use\nnvtxRangePushEx()\nto create a range containing additional attributes specified by the event attribute structure. The\nnvtxRangePushW()\nfunction is not supported in the CUDA implementation of NVTX and has no effect if called. Each push function returns the zero-based depth of the range being started. The\nnvtxRangePop()\nfunction is used to end the most recently pushed range for the thread.\nnvtxRangePop()\nreturns the zero-based depth of the range being ended. If the pop does not have a matching push, a negative value is returned to indicate an error.\nCode Example\nnvtxRangePushA\n(\n\"outer\"\n);\nnvtxRangePushA\n(\n\"inner\"\n);\nnvtxRangePop\n();\n// end \"inner\" range\nnvtxRangePop\n();\n// end \"outer\" range\nnvtxEventAttributes_t\neventAttrib\n=\n{\n0\n};\neventAttrib\n.\nversion\n=\nNVTX_VERSION\n;\neventAttrib\n.\nsize\n=\nNVTX_EVENT_ATTRIB_STRUCT_SIZE\n;\neventAttrib\n.\ncolorType\n=\nNVTX_COLOR_ARGB\n;\neventAttrib\n.\ncolor\n=\nCOLOR_GREEN\n;\neventAttrib\n.\nmessageType\n=\nNVTX_MESSAGE_TYPE_ASCII\n;\neventAttrib\n.\nmessage\n.\nascii\n=\n\"my push/pop range\"\n;\nnvtxRangePushEx\n(\n&\neventAttrib\n);\nnvtxRangePop\n();\n5.2.4.\nEvent Attributes Structure\n\nThe events attributes structure,\nnvtxEventAttributes_t\n, is used to describe the attributes of an event. The layout of the structure is defined by a specific version of NVTX and can change between different versions of the Tools Extension library.\nAttributes\nMarkers and ranges can use attributes to provide additional information for an event or to guide the tool’s visualization of the data. Each of the attributes is optional and if left unspecified, the attributes fall back to a default value.\nMessage\nThe message field can be used to specify an optional string. The caller must set both the\nmessageType\nand\nmessage\nfields. The default value is\nNVTX_MESSAGE_UNKNOWN\n. The CUDA implementation of NVTX only supports ASCII type messages.\nCategory\nThe category attribute is a user-controlled ID that can be used to group events. The tool may use category IDs to improve filtering, or for grouping events. The default value is 0.\nColor\nThe color attribute is used to help visually identify events in the tool. The caller must set both the\ncolorType\nand\ncolor\nfields.\nPayload\nThe payload attribute can be used to provide additional data for markers and ranges. Range events can only specify values at the beginning of a range. The caller must specify valid values for both the\npayloadType\nand\npayload\nfields.\nInitialization\nThe caller should always perform the following three tasks when using attributes:\nZero the structure\nSet the version field\nSet the size field\nZeroing the structure sets all the event attributes types and values to the default value. The version and size field are used by NVTX to handle multiple versions of the attributes structure.\nIt is recommended that the caller use the following method to initialize the event attributes structure.\nnvtxEventAttributes_t\neventAttrib\n=\n{\n0\n};\neventAttrib\n.\nversion\n=\nNVTX_VERSION\n;\neventAttrib\n.\nsize\n=\nNVTX_EVENT_ATTRIB_STRUCT_SIZE\n;\neventAttrib\n.\ncolorType\n=\nNVTX_COLOR_ARGB\n;\neventAttrib\n.\ncolor\n=\n::\nCOLOR_YELLOW\n;\neventAttrib\n.\nmessageType\n=\nNVTX_MESSAGE_TYPE_ASCII\n;\neventAttrib\n.\nmessage\n.\nascii\n=\n\"My event\"\n;\nnvtxMarkEx\n(\n&\neventAttrib\n);\n5.2.5.\nNVTX Synchronization Markers\n\nThe NVTX synchronization module provides functions to support tracking additional synchronization details of the target application. Naming OS synchronization primitives may allow users to better understand the data collected by traced synchronization APIs. Additionally, annotating a user-defined synchronization object can allow the user to tell the tools when the user is building their own synchronization system that does not rely on the OS to provide behaviors, and instead uses techniques like atomic operations and spinlocks.\nNote\nSynchronization marker support is not available on Windows.\nCode Example\nclass\nMyMutex\n{\nvolatile\nlong\nbLocked\n;\nnvtxSyncUser_t\nhSync\n;\npublic\n:\nMyMutex\n(\nconst\nchar\n*\nname\n,\nnvtxDomainHandle_t\nd\n)\n{\nbLocked\n=\n0\n;\nnvtxSyncUserAttributes_t\nattribs\n=\n{\n0\n};\nattribs\n.\nversion\n=\nNVTX_VERSION\n;\nattribs\n.\nsize\n=\nNVTX_SYNCUSER_ATTRIB_STRUCT_SIZE\n;\nattribs\n.\nmessageType\n=\nNVTX_MESSAGE_TYPE_ASCII\n;\nattribs\n.\nmessage\n.\nascii\n=\nname\n;\nhSync\n=\nnvtxDomainSyncUserCreate\n(\nd\n,\n&\nattribs\n);\n}\n~\nMyMutex\n()\n{\nnvtxDomainSyncUserDestroy\n(\nhSync\n);\n}\nbool\nLock\n()\n{\nnvtxDomainSyncUserAcquireStart\n(\nhSync\n);\n//atomic compiler intrinsic\nbool\nacquired\n=\n__sync_bool_compare_and_swap\n(\n&\nbLocked\n,\n0\n,\n1\n);\nif\n(\nacquired\n)\n{\nnvtxDomainSyncUserAcquireSuccess\n(\nhSync\n);\n}\nelse\n{\nnvtxDomainSyncUserAcquireFailed\n(\nhSync\n);\n}\nreturn\nacquired\n;\n}\nvoid\nUnlock\n()\n{\nnvtxDomainSyncUserReleasing\n(\nhSync\n);\nbLocked\n=\nfalse\n;\n}\n};\n5.3.\nNVTX Domains\n\nDomains enable developers to scope annotations. By default all events and annotations are in the default domain. Additional domains can be registered. This allows developers to scope markers and ranges to avoid conflicts.\nThe function\nnvtxDomainCreateA()\nor\nnvtxDomainCreateW()\nis used to create a named domain.\nEach domain maintains its own\ncategories\nthread range stacks\nregistered strings\nThe function\nnvtxDomainDestroy()\nmarks the end of the domain. Destroying a domain unregisters and destroys all objects associated with it such as registered strings, resource objects, named categories, and started ranges.\nNote\nDomain support is not available on Windows.\nCode Example\nnvtxDomainHandle_t\ndomain\n=\nnvtxDomainCreateA\n(\n\"Domain_A\"\n);\nnvtxMarkA\n(\n\"Mark_A\"\n);\nnvtxEventAttributes_t\nattrib\n=\n{\n0\n};\nattrib\n.\nversion\n=\nNVTX_VERSION\n;\nattrib\n.\nsize\n=\nNVTX_EVENT_ATTRIB_STRUCT_SIZE\n;\nattrib\n.\nmessage\n.\nascii\n=\n\"Mark A Message\"\n;\nnvtxDomainMarkEx\n(\nNULL\n,\n&\nattrib\n);\nnvtxDomainDestroy\n(\ndomain\n);\n5.4.\nNVTX Resource Naming\n\nNVTX resource naming allows custom names to be associated with host OS threads and CUDA resources such as devices, contexts, and streams. The names assigned using NVTX are displayed by the Visual Profiler.\nOS Thread\nThe\nnvtxNameOsThreadA()\nfunction is used to name a host OS thread. The\nnvtxNameOsThreadW()\nfunction is not supported in the CUDA implementation of NVTX and has no effect if called. The following example shows how the current host OS thread can be named.\n// Windows\nnvtxNameOsThread\n(\nGetCurrentThreadId\n(),\n\"MAIN_THREAD\"\n);\n// Linux/Mac\nnvtxNameOsThread\n(\npthread_self\n(),\n\"MAIN_THREAD\"\n);\nCUDA Runtime Resources\nThe\nnvtxNameCudaDeviceA()\nand\nnvtxNameCudaStreamA()\nfunctions are used to name CUDA device and stream objects, respectively. The\nnvtxNameCudaDeviceW()\nand\nnvtxNameCudaStreamW()\nfunctions are not supported in the CUDA implementation of NVTX and have no effect if called. The\nnvtxNameCudaEventA()\nand\nnvtxNameCudaEventW()\nfunctions are also not supported. The following example shows how a CUDA device and stream can be named.\nnvtxNameCudaDeviceA\n(\n0\n,\n\"my cuda device 0\"\n);\ncudaStream_t\ncudastream\n;\ncudaStreamCreate\n(\n&\ncudastream\n);\nnvtxNameCudaStreamA\n(\ncudastream\n,\n\"my cuda stream\"\n);\nCUDA Driver Resources\nThe\nnvtxNameCuDeviceA()\n,\nnvtxNameCuContextA()\nand\nnvtxNameCuStreamA()\nfunctions are used to name CUDA driver device, context and stream objects, respectively. The\nnvtxNameCuDeviceW()\n,\nnvtxNameCuContextW()\nand\nnvtxNameCuStreamW()\nfunctions are not supported in the CUDA implementation of NVTX and have no effect if called. The\nnvtxNameCuEventA()\nand\nnvtxNameCuEventW()\nfunctions are also not supported. The following example shows how a CUDA device, context and stream can be named.\nCUdevice\ndevice\n;\ncuDeviceGet\n(\n&\ndevice\n,\n0\n);\nnvtxNameCuDeviceA\n(\ndevice\n,\n\"my device 0\"\n);\nCUcontext\ncontext\n;\ncuCtxCreate\n(\n&\ncontext\n,\n0\n,\ndevice\n);\nnvtxNameCuContextA\n(\ncontext\n,\n\"my context\"\n);\ncuStream\nstream\n;\ncuStreamCreate\n(\n&\nstream\n,\n0\n);\nnvtxNameCuStreamA\n(\nstream\n,\n\"my stream\"\n);\n5.5.\nNVTX String Registration\n\nRegistered strings are intended to increase performance by lowering instrumentation overhead. String may be registered once and the handle may be passed in place of a string where an the APIs may allow.\nThe\nnvtxDomainRegisterStringA()\nfunction is used to register a string. The\nnvtxDomainRegisterStringW()\nfunction is not supported in the CUDA implementation of NVTX and has no effect if called.\nnvtxDomainHandle_t\ndomain\n=\nnvtxDomainCreateA\n(\n\"Domain_A\"\n);\nnvtxStringHandle_t\nmessage\n=\nnvtxDomainRegisterStringA\n(\ndomain\n,\n\"registered string\"\n);\nnvtxEventAttributes_t\neventAttrib\n=\n{\n0\n};\neventAttrib\n.\nversion\n=\nNVTX_VERSION\n;\neventAttrib\n.\nsize\n=\nNVTX_EVENT_ATTRIB_STRUCT_SIZE\n;\neventAttrib\n.\nmessageType\n=\nNVTX_MESSAGE_TYPE_REGISTERED\n;\neventAttrib\n.\nmessage\n.\nregistered\n=\nmessage\n;\n6.\nMPI Profiling\n\n6.1.\nAutomatic MPI Annotation with NVTX\n\nYou can annotate MPI calls with\nNVTX\nmarkers to profile, trace and visualize them. It can get tedious to wrap every MPI call with NVTX markers, but there are two ways to do this automatically:\nBuilt-in annotation\nnvprof has a built-in option that supports two MPI implementations - OpenMPI and MPICH. If you have either of these installed on your system, you can use the\n--annotate-mpi\noption and specify your installed MPI implementation.\nIf you use this option, nvprof will generate NVTX markers every time your application makes MPI calls. Only synchronous MPI calls are annotated using this built-in option. Additionally, we use NVTX to rename the current thread and current device object to indicate the MPI rank.\nFor example if you have OpenMPI installed, you can annotate your application using the command:\n$\nmpirun\n-\nnp\n2\nnvprof\n--\nannotate\n-\nmpi\nopenmpi\n.\n/\nmy_mpi_app\nThis will give you output that looks something like this:\nNVTX\nresult\n:\nThread\n\"MPI Rank 0\"\n(\nid\n=\n583411584\n)\nDomain\n\"<unnamed>\"\nRange\n\"MPI_Reduce\"\nType\nTime\n(\n%\n)\nTime\nCalls\nAvg\nMin\nMax\nName\nRange\n:\n100.00\n%\n16.652\nus\n1\n16.652\nus\n16.652\nus\n16.652\nus\nMPI_Reduce\n...\nRange\n\"MPI_Scatter\"\nType\nTime\n(\n%\n)\nTime\nCalls\nAvg\nMin\nMax\nName\nRange\n:\n100.00\n%\n3.0320\nms\n1\n3.0320\nms\n3.0320\nms\n3.0320\nms\nMPI_Scatter\n...\nNVTX\nresult\n:\nThread\n\"MPI Rank 1\"\n(\nid\n=\n199923584\n)\nDomain\n\"<unnamed>\"\nRange\n\"MPI_Reduce\"\nType\nTime\n(\n%\n)\nTime\nCalls\nAvg\nMin\nMax\nName\nRange\n:\n100.00\n%\n21.062\nus\n1\n21.062\nus\n21.062\nus\n21.062\nus\nMPI_Reduce\n...\nRange\n\"MPI_Scatter\"\nType\nTime\n(\n%\n)\nTime\nCalls\nAvg\nMin\nMax\nName\nRange\n:\n100.00\n%\n85.296\nms\n1\n85.296\nms\n85.296\nms\n85.296\nms\nMPI_Scatter\n...\nCustom annotation\nIf your system has a version of MPI that is not supported by nvprof, or if you want more control over which MPI functions are annotated and how the NVTX markers are generated, you can create your own annotation library, and use the environment variable\nLD_PRELOAD\nto intercept MPI calls and wrap them with NVTX markers.\nYou can create this annotation library conveniently using the documentation and open-source scripts located\nhere\n.\n6.2.\nManual MPI Profiling\n\nTo use\nnvprof\nto collect the profiles of the individual MPI processes, you must tell\nnvprof\nto send its output to unique files. In CUDA 5.0 and earlier versions, it was recommended to use a script for this. However, you can now easily do it utilizing the\n%h\n,\n%p\nand\n%q{ENV}\nfeatures of the\n--export-profile\nargument to the\nnvprof\ncommand. Below is example run using Open MPI.\n$\nmpirun\n-\nnp\n2\n-\nhost\nc0\n-0\n,\nc0\n-1\nnvprof\n-\no\noutput\n.\n%\nh\n.\n%\np\n.\n%\nq\n{\nOMPI_COMM_WORLD_RANK\n}\n.\n/\nmy_mpi_app\nAlternatively, one can make use of the new feature to turn on profiling on the nodes of interest using the\n--profile-all-processes\nargument to\nnvprof\n. To do this, you first log into the node you want to profile and start up\nnvprof\nthere.\n$\nnvprof\n--\nprofile\n-\nall\n-\nprocesses\n-\no\noutput\n.\n%\nh\n.\n%\np\nThen you can just run the MPI job as your normally would.\n$\nmpirun\n-\nnp\n2\n-\nhost\nc0\n-0\n,\nc0\n-1\n.\n/\nmy_mpi_app\nAny processes that run on the node where the\n--profile-all-processes\nis running will automatically get profiled. The profiling data will be written to the output files. Note that the\n%q{OMPI_COMM_WORLD_RANK}\noption will not work here, because this environment variable will not be available in the shell where nvprof is running.\nStarting CUDA 7.5, you can name threads and CUDA contexts just as you name output files with the options –process-name and –context-name, by passing a string like\n\"MPI\nRank\n%q{OMPI_COMM_WORLD_RANK}\"\nas a parameter. This feature is useful to spot resources associated with a specific rank when user imports multiple files into the same time-line in the Visual Profiler.\n$\nmpirun\n-\nnp\n2\n-\nhost\nc0\n-0\n,\nc0\n-1\nnvprof\n--\nprocess\n-\nname\n\"MPI Rank %q{OMPI_COMM_WORLD_RANK}\"\n--\ncontext\n-\nname\n\"MPI Rank %q{OMPI_COMM_WORLD_RANK}\"\n-\no\noutput\n.\n%\nh\n.\n%\np\n.\n%\nq\n{\nOMPI_COMM_WORLD_RANK\n}\n.\n/\nmy_mpi_app\n6.3.\nFurther Reading\n\nDetails about what types of additional arguments to use with\nnvprof\ncan be found in the\nMultiprocess Profiling\nand\nRedirecting Output\nsection. Additional information about how to view the data with the Visual Profiler can be found in the\nImport Single-Process nvprof Session\nand\nImport Multi-Process nvprof Session\nsections.\nThe blog post\nProfiling MPI Applications\nshows how to use new output file naming of nvprof introduced in CUDA 6.5 and NVTX library to name various resources to analyze the performance of a MPI application.\nThe blog post\nTrack MPI Calls in the Visual Profiler\nshows how Visual Profiler, combined with PMPI and NVTX can give interesting insights into how the MPI calls in your application interact with the GPU.\n7.\nMPS Profiling\n\nYou can collect profiling data for a CUDA application using Multi-Process Service(MPS) with\nnvprof\nand then view the timeline by importing the data in the Visual Profiler.\n7.1.\nMPS profiling with Visual Profiler\n\nVisual Profiler can be run on a particular MPS client or for all MPS clients. Timeline profiling can be done for all MPS clients on the same server. Event or metric profiling results in serialization - only one MPS client will execute at a time.\nTo profile a CUDA application using MPS:\nLaunch the MPS daemon. Refer the MPS document for details.\nnvidia-cuda-mps-control -d\nIn Visual Profiler open “New Session” wizard using main menu “File->New Session”. Select “Profile all processes” option from drop down, press “Next” and then “Finish”.\nRun the application in a separate terminal\nTo end profiling press the “Cancel” button on progress dialog in Visual Profiler.\nNote that the profiling output also includes data for the CUDA MPS server processes which have process name\nnvidia-cuda-mps-server\n.\n7.2.\nMPS profiling with nvprof\n\nnvprof\ncan be run on a particular MPS client or for all MPS clients. Timeline profiling can be done for all MPS clients on the same server. Event or metric profiling results in serialization - only one MPS client will execute at a time.\nTo profile a CUDA application using MPS:\nLaunch the MPS daemon. Refer to the MPS document for details.\nnvidia-cuda-mps-control -d\nRun\nnvprof\nwith\n--profile-all-processes\nargument and to generate separate output files for each process use the\n%p\nfeature of the\n--export-profile\nargument. Note that\n%p\nwill be replaced by the process id.\nnvprof --profile-all-processes -o output_%p\nRun the application in a separate terminal\nExit\nnvprof\nby typing “Ctrl-c”.\nNote that the profiling output also includes data for the CUDA MPS server processes which have process name\nnvidia-cuda-mps-server\n.\n7.3.\nViewing nvprof MPS timeline in Visual Profiler\n\nImport the nvprof generated data files for each process using the multi-process import option. Refer the\nImport Multi-Process Session\nsection.\nThe figure below shows the MPS timeline view for three processes. The MPS context is identified in the timeline row label as Context MPS. Note that the Compute and kernel timeline row shows three kernels overlapping.\n8.\nDependency Analysis\n\nThe dependency analysis feature enables optimization of the program runtime and concurrency of applications utilizing multiple CPU threads and CUDA streams. It allows to compute the critical path of a specific execution, detect waiting time and inspect dependencies between functions executing in different threads or streams.\n8.1.\nBackground\n\nThe dependency analysis in\nnvprof\nand the\nVisual\nProfiler\nis based on execution traces of applications. A trace captures all relevant activities such as API function calls or CUDA kernels along with their timestamps and durations. Given this execution trace and a model of the dependencies between those activities on different threads/streams, a dependency graph can be constructed. Typical dependencies modelled in this graph would be that a CUDA kernel can not start before its respective launch API call or that a blocking CUDA stream synchronization call can not return before all previously enqueued work in this stream has been completed. These dependencies are defined by the CUDA API contract.\nFrom this dependency graph and the API model(s), wait states can be computed. A wait state is the duration for which an activity such as an API function call is blocked waiting on an event in another thread or stream. Given the previous stream synchronization example, the synchronizing API call is blocked for the time it has to wait on any GPU activity in the respective CUDA stream. Knowledge about where wait states occur and how long functions are blocked is helpful to identify optimization opportunities for more high-level concurrency in the application.\nIn addition to individual wait states, the critical path through the captured event graph enables to pinpoint those function calls, kernel and memory copies that are responsible for the total application runtime. The critical path is the longest path through an event graph that does not contain wait states, i.e. optimizing activities on this path can directly improve the execution time.\n8.2.\nMetrics\n\nWaiting Time\nA wait state is the duration for which an activity such as an API function call is blocked waiting on an event in another thread or stream. Waiting time is an inidicator for load-imbalances between execution streams. In the example below, the blocking CUDA synchronization API calls are waiting on their respective kernels to finish executing on the GPU. Instead of waiting immediately, one should attempt to overlap the kernel executions with concurrent CPU work with a similar runtime, thereby reducing the time that any computing device (CPU or GPU) is blocked.\nTime on Critical Path\nThe critical path is the longest path through an event graph that does not contain wait states, i.e. optimizing activities on this path can directly improve the execution time. Activities with a high time on the critical path have a high direct impact on the application runtime. In the example pictured below,\ncopy_kernel\nis on the critical path since the CPU is blocked waiting for it to finish in\ncudeDeviceSynchronize\n. Reducing the kernel runtime allows the CPU to return earlier from the API call and continue program execution. On the other hand,\njacobi_kernel\nis fully overlapped with CPU work, i.e. the synchronizing API call is triggered after the kernel is already finished. Since no execution stream is waiting on this kernel to finish, reducing its duration will likely not improve the overall application runtime.\n8.3.\nSupport\n\nThe following programming APIs are currently supported for dependency analysis\nCUDA runtime and driver API\nPOSIX threads (Pthreads), POSIX mutexes and condition variables\nDependency analysis is available in Visual Profiler and\nnvprof\n. A Dependency Analysis stage can be selected in the\nUnguided Application Analysis\nand new\nDependency Analysis Controls\nare available for the timeline. See section\nDependency Analysis\non how to use this feature in\nnvprof\n.\n8.4.\nLimitations\n\nThe dependency and wait time analysis between different threads and CUDA streams only takes into account execution dependencies stated in the respective supported API contracts. This especially does not include synchronization as a result of resource contention. For example, asynchronous memory copies enqueued into independent CUDA streams will not be marked dependent even if the concrete GPU has only a single copy engine. Furthermore, the analysis does not account for synchronization using a not-supported API. For example, a CPU thread actively polling for a value at some memory location (busy-waiting) will not be considered blocked on another concurrent activity.\nThe dependency analysis has only limited support for applications using CUDA Dynamic Parallelism (CDP). CDP kernels can use CUDA API calls from the GPU which are not tracked via the CUPTI Activity API. Therefore, the analysis cannot determine the full dependencies and waiting time for CDP kernels. However, it utilizes the parent-child launch dependencies between CDP kernels. As a result the critical path will always include the last CDP kernel of each host-launched kernel.\nThe POSIX semaphores API is currently not supported.\nThe dependency analysis does not support API functions\ncudaLaunchCooperativeKernelMultiDevice\nor\ncuLaunchCooperativeKernelMultiDevice\n. Kernel launched by either of these API functions might not be tracked correctly.\n9.\nMetrics Reference\n\nThis section contains detailed descriptions of the metrics that can be collected by\nnvprof\nand the Visual Profiler. A scope value of “Single-context” indicates that the metric can only be accurately collected when a single context (CUDA or graphic) is executing on the GPU. A scope value of “Multi-context” indicates that the metric can be accurately collected when multiple contexts are executing on the GPU. A scope value of “Device” indicates that the metric will be collected at device level, that is it will include values for all the contexts executing on the GPU.\nNote that, NVLink metrics collected for kernel mode exhibit the behavior of “Single-context”.\n9.1.\nMetrics for Capability 5.x\n\nDevices with compute capability 5.x implement the metrics shown in the following table. Note that for some metrics the “Multi-context” scope is supported only for specific devices. Such metrics are marked with “Multi-context\n*\n” under the “Scope” column. Refer to the note at the bottom of the table.\nTable 4. Capability 5.x Metrics\n\nMetric Name\nDescription\nScope\nachieved_occupancy\nRatio of the average active warps per active cycle to the maximum number of warps supported on a multiprocessor\nMulti-context\natomic_transactions\nGlobal memory atomic and reduction transactions\nMulti-context\natomic_transactions_per_request\nAverage number of global memory atomic and reduction transactions performed for each atomic and reduction instruction\nMulti-context\nbranch_efficiency\nRatio of non-divergent branches to total branches expressed as percentage\nMulti-context\ncf_executed\nNumber of executed control-flow instructions\nMulti-context\ncf_fu_utilization\nThe utilization level of the multiprocessor function units that execute control-flow instructions on a scale of 0 to 10\nMulti-context\ncf_issued\nNumber of issued control-flow instructions\nMulti-context\ndouble_precision_fu_utilization\nThe utilization level of the multiprocessor function units that execute double-precision floating-point instructions on a scale of 0 to 10\nMulti-context\ndram_read_bytes\nTotal bytes read from DRAM to L2 cache. This is available for compute capability 5.0 and 5.2.\nMulti-context\n*\ndram_read_throughput\nDevice memory read throughput. This is available for compute capability 5.0 and 5.2.\nMulti-context\n*\ndram_read_transactions\nDevice memory read transactions. This is available for compute capability 5.0 and 5.2.\nMulti-context\n*\ndram_utilization\nThe utilization level of the device memory relative to the peak utilization on a scale of 0 to 10\nMulti-context\n*\ndram_write_bytes\nTotal bytes written from L2 cache to DRAM. This is available for compute capability 5.0 and 5.2.\nMulti-context\n*\ndram_write_throughput\nDevice memory write throughput. This is available for compute capability 5.0 and 5.2.\nMulti-context\n*\ndram_write_transactions\nDevice memory write transactions. This is available for compute capability 5.0 and 5.2.\nMulti-context\n*\necc_throughput\nECC throughput from L2 to DRAM. This is available for compute capability 5.0 and 5.2.\nMulti-context\n*\necc_transactions\nNumber of ECC transactions between L2 and DRAM. This is available for compute capability 5.0 and 5.2.\nMulti-context\n*\neligible_warps_per_cycle\nAverage number of warps that are eligible to issue per active cycle\nMulti-context\nflop_count_dp\nNumber of double-precision floating-point operations executed by non-predicated threads (add, multiply, and multiply-accumulate). Each multiply-accumulate operation contributes 2 to the count.\nMulti-context\nflop_count_dp_add\nNumber of double-precision floating-point add operations executed by non-predicated threads.\nMulti-context\nflop_count_dp_fma\nNumber of double-precision floating-point multiply-accumulate operations executed by non-predicated threads. Each multiply-accumulate operation contributes 1 to the count.\nMulti-context\nflop_count_dp_mul\nNumber of double-precision floating-point multiply operations executed by non-predicated threads.\nMulti-context\nflop_count_hp\nNumber of half-precision floating-point operations executed by non-predicated threads (add, multiply and multiply-accumulate). Each multiply-accumulate operation contributes 2 to the count. This is available for compute capability 5.3.\nMulti-context\n*\nflop_count_hp_add\nNumber of half-precision floating-point add operations executed by non-predicated threads. This is available for compute capability 5.3.\nMulti-context\n*\nflop_count_hp_fma\nNumber of half-precision floating-point multiply-accumulate operations executed by non-predicated threads. Each multiply-accumulate operation contributes 1 to the count. This is available for compute capability 5.3.\nMulti-context\n*\nflop_count_hp_mul\nNumber of half-precision floating-point multiply operations executed by non-predicated threads. This is available for compute capability 5.3.\nMulti-context\n*\nflop_count_sp\nNumber of single-precision floating-point operations executed by non-predicated threads (add, multiply, and multiply-accumulate). Each multiply-accumulate operation contributes 2 to the count. The count does not include special operations.\nMulti-context\nflop_count_sp_add\nNumber of single-precision floating-point add operations executed by non-predicated threads.\nMulti-context\nflop_count_sp_fma\nNumber of single-precision floating-point multiply-accumulate operations executed by non-predicated threads. Each multiply-accumulate operation contributes 1 to the count.\nMulti-context\nflop_count_sp_mul\nNumber of single-precision floating-point multiply operations executed by non-predicated threads.\nMulti-context\nflop_count_sp_special\nNumber of single-precision floating-point special operations executed by non-predicated threads.\nMulti-context\nflop_dp_efficiency\nRatio of achieved to peak double-precision floating-point operations\nMulti-context\nflop_hp_efficiency\nRatio of achieved to peak half-precision floating-point operations. This is available for compute capability 5.3.\nMulti-context\n*\nflop_sp_efficiency\nRatio of achieved to peak single-precision floating-point operations\nMulti-context\ngld_efficiency\nRatio of requested global memory load throughput to required global memory load throughput expressed as percentage.\nMulti-context\n*\ngld_requested_throughput\nRequested global memory load throughput\nMulti-context\ngld_throughput\nGlobal memory load throughput\nMulti-context\n*\ngld_transactions\nNumber of global memory load transactions\nMulti-context\n*\ngld_transactions_per_request\nAverage number of global memory load transactions performed for each global memory load.\nMulti-context\n*\nglobal_atomic_requests\nTotal number of global atomic(Atom and Atom CAS) requests from Multiprocessor\nMulti-context\nglobal_hit_rate\nHit rate for global loads in unified l1/tex cache. Metric value maybe wrong if malloc is used in kernel.\nMulti-context\n*\nglobal_load_requests\nTotal number of global load requests from Multiprocessor\nMulti-context\nglobal_reduction_requests\nTotal number of global reduction requests from Multiprocessor\nMulti-context\nglobal_store_requests\nTotal number of global store requests from Multiprocessor. This does not include atomic requests.\nMulti-context\ngst_efficiency\nRatio of requested global memory store throughput to required global memory store throughput expressed as percentage.\nMulti-context\n*\ngst_requested_throughput\nRequested global memory store throughput\nMulti-context\ngst_throughput\nGlobal memory store throughput\nMulti-context\n*\ngst_transactions\nNumber of global memory store transactions\nMulti-context\n*\ngst_transactions_per_request\nAverage number of global memory store transactions performed for each global memory store\nMulti-context\n*\nhalf_precision_fu_utilization\nThe utilization level of the multiprocessor function units that execute 16 bit floating-point instructions and integer instructions on a scale of 0 to 10. This is available for compute capability 5.3.\nMulti-context\n*\ninst_bit_convert\nNumber of bit-conversion instructions executed by non-predicated threads\nMulti-context\ninst_compute_ld_st\nNumber of compute load/store instructions executed by non-predicated threads\nMulti-context\ninst_control\nNumber of control-flow instructions executed by non-predicated threads (jump, branch, etc.)\nMulti-context\ninst_executed\nThe number of instructions executed\nMulti-context\ninst_executed_global_atomics\nWarp level instructions for global atom and atom cas\nMulti-context\ninst_executed_global_loads\nWarp level instructions for global loads\nMulti-context\ninst_executed_global_reductions\nWarp level instructions for global reductions\nMulti-context\ninst_executed_global_stores\nWarp level instructions for global stores\nMulti-context\ninst_executed_local_loads\nWarp level instructions for local loads\nMulti-context\ninst_executed_local_stores\nWarp level instructions for local stores\nMulti-context\ninst_executed_shared_atomics\nWarp level shared instructions for atom and atom CAS\nMulti-context\ninst_executed_shared_loads\nWarp level instructions for shared loads\nMulti-context\ninst_executed_shared_stores\nWarp level instructions for shared stores\nMulti-context\ninst_executed_surface_atomics\nWarp level instructions for surface atom and atom cas\nMulti-context\ninst_executed_surface_loads\nWarp level instructions for surface loads\nMulti-context\ninst_executed_surface_reductions\nWarp level instructions for surface reductions\nMulti-context\ninst_executed_surface_stores\nWarp level instructions for surface stores\nMulti-context\ninst_executed_tex_ops\nWarp level instructions for texture\nMulti-context\ninst_fp_16\nNumber of half-precision floating-point instructions executed by non-predicated threads (arithmetic, compare, etc.) This is available for compute capability 5.3.\nMulti-context\n*\ninst_fp_32\nNumber of single-precision floating-point instructions executed by non-predicated threads (arithmetic, compare, etc.)\nMulti-context\ninst_fp_64\nNumber of double-precision floating-point instructions executed by non-predicated threads (arithmetic, compare, etc.)\nMulti-context\ninst_integer\nNumber of integer instructions executed by non-predicated threads\nMulti-context\ninst_inter_thread_communication\nNumber of inter-thread communication instructions executed by non-predicated threads\nMulti-context\ninst_issued\nThe number of instructions issued\nMulti-context\ninst_misc\nNumber of miscellaneous instructions executed by non-predicated threads\nMulti-context\ninst_per_warp\nAverage number of instructions executed by each warp\nMulti-context\ninst_replay_overhead\nAverage number of replays for each instruction executed\nMulti-context\nipc\nInstructions executed per cycle\nMulti-context\nissue_slot_utilization\nPercentage of issue slots that issued at least one instruction, averaged across all cycles\nMulti-context\nissue_slots\nThe number of issue slots used\nMulti-context\nissued_ipc\nInstructions issued per cycle\nMulti-context\nl2_atomic_throughput\nMemory read throughput seen at L2 cache for atomic and reduction requests\nMulti-context\nl2_atomic_transactions\nMemory read transactions seen at L2 cache for atomic and reduction requests\nMulti-context\n*\nl2_global_atomic_store_bytes\nBytes written to L2 from Unified cache for global atomics (ATOM and ATOM CAS)\nMulti-context\n*\nl2_global_load_bytes\nBytes read from L2 for misses in Unified Cache for global loads\nMulti-context\n*\nl2_global_reduction_bytes\nBytes written to L2 from Unified cache for global reductions\nMulti-context\n*\nl2_local_global_store_bytes\nBytes written to L2 from Unified Cache for local and global stores. This does not include global atomics.\nMulti-context\n*\nl2_local_load_bytes\nBytes read from L2 for misses in Unified Cache for local loads\nMulti-context\n*\nl2_read_throughput\nMemory read throughput seen at L2 cache for all read requests\nMulti-context\n*\nl2_read_transactions\nMemory read transactions seen at L2 cache for all read requests\nMulti-context\n*\nl2_surface_atomic_store_bytes\nBytes transferred between Unified Cache and L2 for surface atomics (ATOM and ATOM CAS)\nMulti-context\n*\nl2_surface_load_bytes\nBytes read from L2 for misses in Unified Cache for surface loads\nMulti-context\n*\nl2_surface_reduction_bytes\nBytes written to L2 from Unified Cache for surface reductions\nMulti-context\n*\nl2_surface_store_bytes\nBytes written to L2 from Unified Cache for surface stores. This does not include surface atomics.\nMulti-context\n*\nl2_tex_hit_rate\nHit rate at L2 cache for all requests from texture cache\nMulti-context\n*\nl2_tex_read_hit_rate\nHit rate at L2 cache for all read requests from texture cache. This is available for compute capability 5.0 and 5.2.\nMulti-context\n*\nl2_tex_read_throughput\nMemory read throughput seen at L2 cache for read requests from the texture cache\nMulti-context\n*\nl2_tex_read_transactions\nMemory read transactions seen at L2 cache for read requests from the texture cache\nMulti-context\n*\nl2_tex_write_hit_rate\nHit Rate at L2 cache for all write requests from texture cache. This is available for compute capability 5.0 and 5.2.\nMulti-context\n*\nl2_tex_write_throughput\nMemory write throughput seen at L2 cache for write requests from the texture cache\nMulti-context\n*\nl2_tex_write_transactions\nMemory write transactions seen at L2 cache for write requests from the texture cache\nMulti-context\n*\nl2_utilization\nThe utilization level of the L2 cache relative to the peak utilization on a scale of 0 to 10\nMulti-context\n*\nl2_write_throughput\nMemory write throughput seen at L2 cache for all write requests\nMulti-context\n*\nl2_write_transactions\nMemory write transactions seen at L2 cache for all write requests\nMulti-context\n*\nldst_executed\nNumber of executed local, global, shared and texture memory load and store instructions\nMulti-context\nldst_fu_utilization\nThe utilization level of the multiprocessor function units that execute shared load, shared store and constant load instructions on a scale of 0 to 10\nMulti-context\nldst_issued\nNumber of issued local, global, shared and texture memory load and store instructions\nMulti-context\nlocal_hit_rate\nHit rate for local loads and stores\nMulti-context\n*\nlocal_load_requests\nTotal number of local load requests from Multiprocessor\nMulti-context\n*\nlocal_load_throughput\nLocal memory load throughput\nMulti-context\n*\nlocal_load_transactions\nNumber of local memory load transactions\nMulti-context\n*\nlocal_load_transactions_per_request\nAverage number of local memory load transactions performed for each local memory load\nMulti-context\n*\nlocal_memory_overhead\nRatio of local memory traffic to total memory traffic between the L1 and L2 caches expressed as percentage\nMulti-context\n*\nlocal_store_requests\nTotal number of local store requests from Multiprocessor\nMulti-context\n*\nlocal_store_throughput\nLocal memory store throughput\nMulti-context\n*\nlocal_store_transactions\nNumber of local memory store transactions\nMulti-context\n*\nlocal_store_transactions_per_request\nAverage number of local memory store transactions performed for each local memory store\nMulti-context\n*\npcie_total_data_received\nTotal data bytes received through PCIe\nDevice\npcie_total_data_transmitted\nTotal data bytes transmitted through PCIe\nDevice\nshared_efficiency\nRatio of requested shared memory throughput to required shared memory throughput expressed as percentage\nMulti-context\n*\nshared_load_throughput\nShared memory load throughput\nMulti-context\n*\nshared_load_transactions\nNumber of shared memory load transactions\nMulti-context\n*\nshared_load_transactions_per_request\nAverage number of shared memory load transactions performed for each shared memory load\nMulti-context\n*\nshared_store_throughput\nShared memory store throughput\nMulti-context\n*\nshared_store_transactions\nNumber of shared memory store transactions\nMulti-context\n*\nshared_store_transactions_per_request\nAverage number of shared memory store transactions performed for each shared memory store\nMulti-context\n*\nshared_utilization\nThe utilization level of the shared memory relative to peak utilization on a scale of 0 to 10\nMulti-context\n*\nsingle_precision_fu_utilization\nThe utilization level of the multiprocessor function units that execute single-precision floating-point instructions and integer instructions on a scale of 0 to 10\nMulti-context\nsm_efficiency\nThe percentage of time at least one warp is active on a specific multiprocessor\nMulti-context\n*\nspecial_fu_utilization\nThe utilization level of the multiprocessor function units that execute sin, cos, ex2, popc, flo, and similar instructions on a scale of 0 to 10\nMulti-context\nstall_constant_memory_dependency\nPercentage of stalls occurring because of immediate constant cache miss\nMulti-context\nstall_exec_dependency\nPercentage of stalls occurring because an input required by the instruction is not yet available\nMulti-context\nstall_inst_fetch\nPercentage of stalls occurring because the next assembly instruction has not yet been fetched\nMulti-context\nstall_memory_dependency\nPercentage of stalls occurring because a memory operation cannot be performed due to the required resources not being available or fully utilized, or because too many requests of a given type are outstanding\nMulti-context\nstall_memory_throttle\nPercentage of stalls occurring because of memory throttle\nMulti-context\nstall_not_selected\nPercentage of stalls occurring because warp was not selected\nMulti-context\nstall_other\nPercentage of stalls occurring due to miscellaneous reasons\nMulti-context\nstall_pipe_busy\nPercentage of stalls occurring because a compute operation cannot be performed because the compute pipeline is busy\nMulti-context\nstall_sync\nPercentage of stalls occurring because the warp is blocked at a __syncthreads() call\nMulti-context\nstall_texture\nPercentage of stalls occurring because the texture sub-system is fully utilized or has too many outstanding requests\nMulti-context\nsurface_atomic_requests\nTotal number of surface atomic(Atom and Atom CAS) requests from Multiprocessor\nMulti-context\nsurface_load_requests\nTotal number of surface load requests from Multiprocessor\nMulti-context\nsurface_reduction_requests\nTotal number of surface reduction requests from Multiprocessor\nMulti-context\nsurface_store_requests\nTotal number of surface store requests from Multiprocessor\nMulti-context\nsysmem_read_bytes\nNumber of bytes read from system memory\nMulti-context\n*\nsysmem_read_throughput\nSystem memory read throughput\nMulti-context\n*\nsysmem_read_transactions\nNumber of system memory read transactions\nMulti-context\n*\nsysmem_read_utilization\nThe read utilization level of the system memory relative to the peak utilization on a scale of 0 to 10. This is available for compute capability 5.0 and 5.2.\nMulti-context\nsysmem_utilization\nThe utilization level of the system memory relative to the peak utilization on a scale of 0 to 10. This is available for compute capability 5.0 and 5.2.\nMulti-context\n*\nsysmem_write_bytes\nNumber of bytes written to system memory\nMulti-context\n*\nsysmem_write_throughput\nSystem memory write throughput\nMulti-context\n*\nsysmem_write_transactions\nNumber of system memory write transactions\nMulti-context\n*\nsysmem_write_utilization\nThe write utilization level of the system memory relative to the peak utilization on a scale of 0 to 10. This is available for compute capability 5.0 and 5.2.\nMulti-context\n*\ntex_cache_hit_rate\nUnified cache hit rate\nMulti-context\n*\ntex_cache_throughput\nUnified cache throughput\nMulti-context\n*\ntex_cache_transactions\nUnified cache read transactions\nMulti-context\n*\ntex_fu_utilization\nThe utilization level of the multiprocessor function units that execute global, local and texture memory instructions on a scale of 0 to 10\nMulti-context\ntex_utilization\nThe utilization level of the unified cache relative to the peak utilization on a scale of 0 to 10\nMulti-context\n*\ntexture_load_requests\nTotal number of texture Load requests from Multiprocessor\nMulti-context\nwarp_execution_efficiency\nRatio of the average active threads per warp to the maximum number of threads per warp supported on a multiprocessor\nMulti-context\nwarp_nonpred_execution_efficiency\nRatio of the average active threads per warp executing non-predicated instructions to the maximum number of threads per warp supported on a multiprocessor\nMulti-context\n* The “Multi-context” scope for this metric is supported only for devices with compute capability 5.0 and 5.2.\n9.2.\nMetrics for Capability 6.x\n\nDevices with compute capability 6.x implement the metrics shown in the following table.\nTable 5. Capability 6.x Metrics\n\nMetric Name\nDescription\nScope\nachieved_occupancy\nRatio of the average active warps per active cycle to the maximum number of warps supported on a multiprocessor\nMulti-context\natomic_transactions\nGlobal memory atomic and reduction transactions\nMulti-context\natomic_transactions_per_request\nAverage number of global memory atomic and reduction transactions performed for each atomic and reduction instruction\nMulti-context\nbranch_efficiency\nRatio of non-divergent branches to total branches expressed as percentage\nMulti-context\ncf_executed\nNumber of executed control-flow instructions\nMulti-context\ncf_fu_utilization\nThe utilization level of the multiprocessor function units that execute control-flow instructions on a scale of 0 to 10\nMulti-context\ncf_issued\nNumber of issued control-flow instructions\nMulti-context\ndouble_precision_fu_utilization\nThe utilization level of the multiprocessor function units that execute double-precision floating-point instructions on a scale of 0 to 10\nMulti-context\ndram_read_bytes\nTotal bytes read from DRAM to L2 cache\nMulti-context\ndram_read_throughput\nDevice memory read throughput. This is available for compute capability 6.0 and 6.1.\nMulti-context\ndram_read_transactions\nDevice memory read transactions. This is available for compute capability 6.0 and 6.1.\nMulti-context\ndram_utilization\nThe utilization level of the device memory relative to the peak utilization on a scale of 0 to 10\nMulti-context\ndram_write_bytes\nTotal bytes written from L2 cache to DRAM\nMulti-context\ndram_write_throughput\nDevice memory write throughput. This is available for compute capability 6.0 and 6.1.\nMulti-context\ndram_write_transactions\nDevice memory write transactions. This is available for compute capability 6.0 and 6.1.\nMulti-context\necc_throughput\nECC throughput from L2 to DRAM. This is available for compute capability 6.1.\nMulti-context\necc_transactions\nNumber of ECC transactions between L2 and DRAM. This is available for compute capability 6.1.\nMulti-context\neligible_warps_per_cycle\nAverage number of warps that are eligible to issue per active cycle\nMulti-context\nflop_count_dp\nNumber of double-precision floating-point operations executed by non-predicated threads (add, multiply, and multiply-accumulate). Each multiply-accumulate operation contributes 2 to the count.\nMulti-context\nflop_count_dp_add\nNumber of double-precision floating-point add operations executed by non-predicated threads.\nMulti-context\nflop_count_dp_fma\nNumber of double-precision floating-point multiply-accumulate operations executed by non-predicated threads. Each multiply-accumulate operation contributes 1 to the count.\nMulti-context\nflop_count_dp_mul\nNumber of double-precision floating-point multiply operations executed by non-predicated threads.\nMulti-context\nflop_count_hp\nNumber of half-precision floating-point operations executed by non-predicated threads (add, multiply, and multiply-accumulate). Each multiply-accumulate operation contributes 2 to the count.\nMulti-context\nflop_count_hp_add\nNumber of half-precision floating-point add operations executed by non-predicated threads.\nMulti-context\nflop_count_hp_fma\nNumber of half-precision floating-point multiply-accumulate operations executed by non-predicated threads. Each multiply-accumulate operation contributes 1 to the count.\nMulti-context\nflop_count_hp_mul\nNumber of half-precision floating-point multiply operations executed by non-predicated threads.\nMulti-context\nflop_count_sp\nNumber of single-precision floating-point operations executed by non-predicated threads (add, multiply, and multiply-accumulate). Each multiply-accumulate operation contributes 2 to the count. The count does not include special operations.\nMulti-context\nflop_count_sp_add\nNumber of single-precision floating-point add operations executed by non-predicated threads.\nMulti-context\nflop_count_sp_fma\nNumber of single-precision floating-point multiply-accumulate operations executed by non-predicated threads. Each multiply-accumulate operation contributes 1 to the count.\nMulti-context\nflop_count_sp_mul\nNumber of single-precision floating-point multiply operations executed by non-predicated threads.\nMulti-context\nflop_count_sp_special\nNumber of single-precision floating-point special operations executed by non-predicated threads.\nMulti-context\nflop_dp_efficiency\nRatio of achieved to peak double-precision floating-point operations\nMulti-context\nflop_hp_efficiency\nRatio of achieved to peak half-precision floating-point operations\nMulti-context\nflop_sp_efficiency\nRatio of achieved to peak single-precision floating-point operations\nMulti-context\ngld_efficiency\nRatio of requested global memory load throughput to required global memory load throughput expressed as percentage.\nMulti-context\ngld_requested_throughput\nRequested global memory load throughput\nMulti-context\ngld_throughput\nGlobal memory load throughput\nMulti-context\ngld_transactions\nNumber of global memory load transactions\nMulti-context\ngld_transactions_per_request\nAverage number of global memory load transactions performed for each global memory load.\nMulti-context\nglobal_atomic_requests\nTotal number of global atomic(Atom and Atom CAS) requests from Multiprocessor\nMulti-context\nglobal_hit_rate\nHit rate for global loads in unified l1/tex cache. Metric value maybe wrong if malloc is used in kernel.\nMulti-context\nglobal_load_requests\nTotal number of global load requests from Multiprocessor\nMulti-context\nglobal_reduction_requests\nTotal number of global reduction requests from Multiprocessor\nMulti-context\nglobal_store_requests\nTotal number of global store requests from Multiprocessor. This does not include atomic requests.\nMulti-context\ngst_efficiency\nRatio of requested global memory store throughput to required global memory store throughput expressed as percentage.\nMulti-context\ngst_requested_throughput\nRequested global memory store throughput\nMulti-context\ngst_throughput\nGlobal memory store throughput\nMulti-context\ngst_transactions\nNumber of global memory store transactions\nMulti-context\ngst_transactions_per_request\nAverage number of global memory store transactions performed for each global memory store\nMulti-context\nhalf_precision_fu_utilization\nThe utilization level of the multiprocessor function units that execute 16 bit floating-point instructions on a scale of 0 to 10\nMulti-context\ninst_bit_convert\nNumber of bit-conversion instructions executed by non-predicated threads\nMulti-context\ninst_compute_ld_st\nNumber of compute load/store instructions executed by non-predicated threads\nMulti-context\ninst_control\nNumber of control-flow instructions executed by non-predicated threads (jump, branch, etc.)\nMulti-context\ninst_executed\nThe number of instructions executed\nMulti-context\ninst_executed_global_atomics\nWarp level instructions for global atom and atom cas\nMulti-context\ninst_executed_global_loads\nWarp level instructions for global loads\nMulti-context\ninst_executed_global_reductions\nWarp level instructions for global reductions\nMulti-context\ninst_executed_global_stores\nWarp level instructions for global stores\nMulti-context\ninst_executed_local_loads\nWarp level instructions for local loads\nMulti-context\ninst_executed_local_stores\nWarp level instructions for local stores\nMulti-context\ninst_executed_shared_atomics\nWarp level shared instructions for atom and atom CAS\nMulti-context\ninst_executed_shared_loads\nWarp level instructions for shared loads\nMulti-context\ninst_executed_shared_stores\nWarp level instructions for shared stores\nMulti-context\ninst_executed_surface_atomics\nWarp level instructions for surface atom and atom cas\nMulti-context\ninst_executed_surface_loads\nWarp level instructions for surface loads\nMulti-context\ninst_executed_surface_reductions\nWarp level instructions for surface reductions\nMulti-context\ninst_executed_surface_stores\nWarp level instructions for surface stores\nMulti-context\ninst_executed_tex_ops\nWarp level instructions for texture\nMulti-context\ninst_fp_16\nNumber of half-precision floating-point instructions executed by non-predicated threads (arithmetic, compare, etc.)\nMulti-context\ninst_fp_32\nNumber of single-precision floating-point instructions executed by non-predicated threads (arithmetic, compare, etc.)\nMulti-context\ninst_fp_64\nNumber of double-precision floating-point instructions executed by non-predicated threads (arithmetic, compare, etc.)\nMulti-context\ninst_integer\nNumber of integer instructions executed by non-predicated threads\nMulti-context\ninst_inter_thread_communication\nNumber of inter-thread communication instructions executed by non-predicated threads\nMulti-context\ninst_issued\nThe number of instructions issued\nMulti-context\ninst_misc\nNumber of miscellaneous instructions executed by non-predicated threads\nMulti-context\ninst_per_warp\nAverage number of instructions executed by each warp\nMulti-context\ninst_replay_overhead\nAverage number of replays for each instruction executed\nMulti-context\nipc\nInstructions executed per cycle\nMulti-context\nissue_slot_utilization\nPercentage of issue slots that issued at least one instruction, averaged across all cycles\nMulti-context\nissue_slots\nThe number of issue slots used\nMulti-context\nissued_ipc\nInstructions issued per cycle\nMulti-context\nl2_atomic_throughput\nMemory read throughput seen at L2 cache for atomic and reduction requests\nMulti-context\nl2_atomic_transactions\nMemory read transactions seen at L2 cache for atomic and reduction requests\nMulti-context\nl2_global_atomic_store_bytes\nBytes written to L2 from Unified cache for global atomics (ATOM and ATOM CAS)\nMulti-context\nl2_global_load_bytes\nBytes read from L2 for misses in Unified Cache for global loads\nMulti-context\nl2_global_reduction_bytes\nBytes written to L2 from Unified cache for global reductions\nMulti-context\nl2_local_global_store_bytes\nBytes written to L2 from Unified Cache for local and global stores. This does not include global atomics.\nMulti-context\nl2_local_load_bytes\nBytes read from L2 for misses in Unified Cache for local loads\nMulti-context\nl2_read_throughput\nMemory read throughput seen at L2 cache for all read requests\nMulti-context\nl2_read_transactions\nMemory read transactions seen at L2 cache for all read requests\nMulti-context\nl2_surface_atomic_store_bytes\nBytes transferred between Unified Cache and L2 for surface atomics (ATOM and ATOM CAS)\nMulti-context\nl2_surface_load_bytes\nBytes read from L2 for misses in Unified Cache for surface loads\nMulti-context\nl2_surface_reduction_bytes\nBytes written to L2 from Unified Cache for surface reductions\nMulti-context\nl2_surface_store_bytes\nBytes written to L2 from Unified Cache for surface stores. This does not include surface atomics.\nMulti-context\nl2_tex_hit_rate\nHit rate at L2 cache for all requests from texture cache\nMulti-context\nl2_tex_read_hit_rate\nHit rate at L2 cache for all read requests from texture cache. This is available for compute capability 6.0 and 6.1.\nMulti-context\nl2_tex_read_throughput\nMemory read throughput seen at L2 cache for read requests from the texture cache\nMulti-context\nl2_tex_read_transactions\nMemory read transactions seen at L2 cache for read requests from the texture cache\nMulti-context\nl2_tex_write_hit_rate\nHit Rate at L2 cache for all write requests from texture cache. This is available for compute capability 6.0 and 6.1.\nMulti-context\nl2_tex_write_throughput\nMemory write throughput seen at L2 cache for write requests from the texture cache\nMulti-context\nl2_tex_write_transactions\nMemory write transactions seen at L2 cache for write requests from the texture cache\nMulti-context\nl2_utilization\nThe utilization level of the L2 cache relative to the peak utilization on a scale of 0 to 10\nMulti-context\nl2_write_throughput\nMemory write throughput seen at L2 cache for all write requests\nMulti-context\nl2_write_transactions\nMemory write transactions seen at L2 cache for all write requests\nMulti-context\nldst_executed\nNumber of executed local, global, shared and texture memory load and store instructions\nMulti-context\nldst_fu_utilization\nThe utilization level of the multiprocessor function units that execute shared load, shared store and constant load instructions on a scale of 0 to 10\nMulti-context\nldst_issued\nNumber of issued local, global, shared and texture memory load and store instructions\nMulti-context\nlocal_hit_rate\nHit rate for local loads and stores\nMulti-context\nlocal_load_requests\nTotal number of local load requests from Multiprocessor\nMulti-context\nlocal_load_throughput\nLocal memory load throughput\nMulti-context\nlocal_load_transactions\nNumber of local memory load transactions\nMulti-context\nlocal_load_transactions_per_request\nAverage number of local memory load transactions performed for each local memory load\nMulti-context\nlocal_memory_overhead\nRatio of local memory traffic to total memory traffic between the L1 and L2 caches expressed as percentage\nMulti-context\nlocal_store_requests\nTotal number of local store requests from Multiprocessor\nMulti-context\nlocal_store_throughput\nLocal memory store throughput\nMulti-context\nlocal_store_transactions\nNumber of local memory store transactions\nMulti-context\nlocal_store_transactions_per_request\nAverage number of local memory store transactions performed for each local memory store\nMulti-context\nnvlink_overhead_data_received\nRatio of overhead data to the total data, received through NVLink. This is available for compute capability 6.0.\nDevice\nnvlink_overhead_data_transmitted\nRatio of overhead data to the total data, transmitted through NVLink. This is available for compute capability 6.0.\nDevice\nnvlink_receive_throughput\nNumber of bytes received per second through NVLinks. This is available for compute capability 6.0.\nDevice\nnvlink_total_data_received\nTotal data bytes received through NVLinks including headers. This is available for compute capability 6.0.\nDevice\nnvlink_total_data_transmitted\nTotal data bytes transmitted through NVLinks including headers. This is available for compute capability 6.0.\nDevice\nnvlink_total_nratom_data_transmitted\nTotal non-reduction atomic data bytes transmitted through NVLinks. This is available for compute capability 6.0.\nDevice\nnvlink_total_ratom_data_transmitted\nTotal reduction atomic data bytes transmitted through NVLinks This is available for compute capability 6.0.\nDevice\nnvlink_total_response_data_received\nTotal response data bytes received through NVLink, response data includes data for read requests and result of non-reduction atomic requests. This is available for compute capability 6.0.\nDevice\nnvlink_total_write_data_transmitted\nTotal write data bytes transmitted through NVLinks. This is available for compute capability 6.0.\nDevice\nnvlink_transmit_throughput\nNumber of Bytes Transmitted per second through NVLinks. This is available for compute capability 6.0.\nDevice\nnvlink_user_data_received\nUser data bytes received through NVLinks, doesn’t include headers. This is available for compute capability 6.0.\nDevice\nnvlink_user_data_transmitted\nUser data bytes transmitted through NVLinks, doesn’t include headers. This is available for compute capability 6.0.\nDevice\nnvlink_user_nratom_data_transmitted\nTotal non-reduction atomic user data bytes transmitted through NVLinks. This is available for compute capability 6.0.\nDevice\nnvlink_user_ratom_data_transmitted\nTotal reduction atomic user data bytes transmitted through NVLinks. This is available for compute capability 6.0.\nDevice\nnvlink_user_response_data_received\nTotal user response data bytes received through NVLink, response data includes data for read requests and result of non-reduction atomic requests. This is available for compute capability 6.0.\nDevice\nnvlink_user_write_data_transmitted\nUser write data bytes transmitted through NVLinks. This is available for compute capability 6.0.\nDevice\npcie_total_data_received\nTotal data bytes received through PCIe\nDevice\npcie_total_data_transmitted\nTotal data bytes transmitted through PCIe\nDevice\nshared_efficiency\nRatio of requested shared memory throughput to required shared memory throughput expressed as percentage\nMulti-context\nshared_load_throughput\nShared memory load throughput\nMulti-context\nshared_load_transactions\nNumber of shared memory load transactions\nMulti-context\nshared_load_transactions_per_request\nAverage number of shared memory load transactions performed for each shared memory load\nMulti-context\nshared_store_throughput\nShared memory store throughput\nMulti-context\nshared_store_transactions\nNumber of shared memory store transactions\nMulti-context\nshared_store_transactions_per_request\nAverage number of shared memory store transactions performed for each shared memory store\nMulti-context\nshared_utilization\nThe utilization level of the shared memory relative to peak utilization on a scale of 0 to 10\nMulti-context\nsingle_precision_fu_utilization\nThe utilization level of the multiprocessor function units that execute single-precision floating-point instructions and integer instructions on a scale of 0 to 10\nMulti-context\nsm_efficiency\nThe percentage of time at least one warp is active on a specific multiprocessor\nMulti-context\nspecial_fu_utilization\nThe utilization level of the multiprocessor function units that execute sin, cos, ex2, popc, flo, and similar instructions on a scale of 0 to 10\nMulti-context\nstall_constant_memory_dependency\nPercentage of stalls occurring because of immediate constant cache miss\nMulti-context\nstall_exec_dependency\nPercentage of stalls occurring because an input required by the instruction is not yet available\nMulti-context\nstall_inst_fetch\nPercentage of stalls occurring because the next assembly instruction has not yet been fetched\nMulti-context\nstall_memory_dependency\nPercentage of stalls occurring because a memory operation cannot be performed due to the required resources not being available or fully utilized, or because too many requests of a given type are outstanding\nMulti-context\nstall_memory_throttle\nPercentage of stalls occurring because of memory throttle\nMulti-context\nstall_not_selected\nPercentage of stalls occurring because warp was not selected\nMulti-context\nstall_other\nPercentage of stalls occurring due to miscellaneous reasons\nMulti-context\nstall_pipe_busy\nPercentage of stalls occurring because a compute operation cannot be performed because the compute pipeline is busy\nMulti-context\nstall_sync\nPercentage of stalls occurring because the warp is blocked at a __syncthreads() call\nMulti-context\nstall_texture\nPercentage of stalls occurring because the texture sub-system is fully utilized or has too many outstanding requests\nMulti-context\nsurface_atomic_requests\nTotal number of surface atomic(Atom and Atom CAS) requests from Multiprocessor\nMulti-context\nsurface_load_requests\nTotal number of surface load requests from Multiprocessor\nMulti-context\nsurface_reduction_requests\nTotal number of surface reduction requests from Multiprocessor\nMulti-context\nsurface_store_requests\nTotal number of surface store requests from Multiprocessor\nMulti-context\nsysmem_read_bytes\nNumber of bytes read from system memory\nMulti-context\nsysmem_read_throughput\nSystem memory read throughput\nMulti-context\nsysmem_read_transactions\nNumber of system memory read transactions\nMulti-context\nsysmem_read_utilization\nThe read utilization level of the system memory relative to the peak utilization on a scale of 0 to 10. This is available for compute capability 6.0 and 6.1.\nMulti-context\nsysmem_utilization\nThe utilization level of the system memory relative to the peak utilization on a scale of 0 to 10. This is available for compute capability 6.0 and 6.1.\nMulti-context\nsysmem_write_bytes\nNumber of bytes written to system memory\nMulti-context\nsysmem_write_throughput\nSystem memory write throughput\nMulti-context\nsysmem_write_transactions\nNumber of system memory write transactions\nMulti-context\nsysmem_write_utilization\nThe write utilization level of the system memory relative to the peak utilization on a scale of 0 to 10. This is available for compute capability 6.0 and 6.1.\nMulti-context\ntex_cache_hit_rate\nUnified cache hit rate\nMulti-context\ntex_cache_throughput\nUnified cache throughput\nMulti-context\ntex_cache_transactions\nUnified cache read transactions\nMulti-context\ntex_fu_utilization\nThe utilization level of the multiprocessor function units that execute global, local and texture memory instructions on a scale of 0 to 10\nMulti-context\ntex_utilization\nThe utilization level of the unified cache relative to the peak utilization on a scale of 0 to 10\nMulti-context\ntexture_load_requests\nTotal number of texture Load requests from Multiprocessor\nMulti-context\nunique_warps_launched\nNumber of warps launched. Value is unaffected by compute preemption.\nMulti-context\nwarp_execution_efficiency\nRatio of the average active threads per warp to the maximum number of threads per warp supported on a multiprocessor\nMulti-context\nwarp_nonpred_execution_efficiency\nRatio of the average active threads per warp executing non-predicated instructions to the maximum number of threads per warp supported on a multiprocessor\nMulti-context\n9.3.\nMetrics for Capability 7.x\n\nDevices with compute capability 7.x implement the metrics shown in the following table. (7.x refers to 7.0 and 7.2 here.)\nTable 6. Capability 7.x (7.0 and 7.2) Metrics\n\nMetric Name\nDescription\nScope\nachieved_occupancy\nRatio of the average active warps per active cycle to the maximum number of warps supported on a multiprocessor\nMulti-context\natomic_transactions\nGlobal memory atomic and reduction transactions\nMulti-context\natomic_transactions_per_request\nAverage number of global memory atomic and reduction transactions performed for each atomic and reduction instruction\nMulti-context\nbranch_efficiency\nRatio of branch instruction to sum of branch and divergent branch instruction\nMulti-context\ncf_executed\nNumber of executed control-flow instructions\nMulti-context\ncf_fu_utilization\nThe utilization level of the multiprocessor function units that execute control-flow instructions on a scale of 0 to 10\nMulti-context\ncf_issued\nNumber of issued control-flow instructions\nMulti-context\ndouble_precision_fu_utilization\nThe utilization level of the multiprocessor function units that execute double-precision floating-point instructions on a scale of 0 to 10\nMulti-context\ndram_read_bytes\nTotal bytes read from DRAM to L2 cache\nMulti-context\ndram_read_throughput\nDevice memory read throughput\nMulti-context\ndram_read_transactions\nDevice memory read transactions\nMulti-context\ndram_utilization\nThe utilization level of the device memory relative to the peak utilization on a scale of 0 to 10\nMulti-context\ndram_write_bytes\nTotal bytes written from L2 cache to DRAM\nMulti-context\ndram_write_throughput\nDevice memory write throughput\nMulti-context\ndram_write_transactions\nDevice memory write transactions\nMulti-context\neligible_warps_per_cycle\nAverage number of warps that are eligible to issue per active cycle\nMulti-context\nflop_count_dp\nNumber of double-precision floating-point operations executed by non-predicated threads (add, multiply, and multiply-accumulate). Each multiply-accumulate operation contributes 2 to the count.\nMulti-context\nflop_count_dp_add\nNumber of double-precision floating-point add operations executed by non-predicated threads.\nMulti-context\nflop_count_dp_fma\nNumber of double-precision floating-point multiply-accumulate operations executed by non-predicated threads. Each multiply-accumulate operation contributes 1 to the count.\nMulti-context\nflop_count_dp_mul\nNumber of double-precision floating-point multiply operations executed by non-predicated threads.\nMulti-context\nflop_count_hp\nNumber of half-precision floating-point operations executed by non-predicated threads (add, multiply, and multiply-accumulate). Each multiply-accumulate contributes 2 or 4 to the count based on the number of inputs.\nMulti-context\nflop_count_hp_add\nNumber of half-precision floating-point add operations executed by non-predicated threads.\nMulti-context\nflop_count_hp_fma\nNumber of half-precision floating-point multiply-accumulate operations executed by non-predicated threads. Each multiply-accumulate contributes 2 or 4 to the count based on the number of inputs.\nMulti-context\nflop_count_hp_mul\nNumber of half-precision floating-point multiply operations executed by non-predicated threads.\nMulti-context\nflop_count_sp\nNumber of single-precision floating-point operations executed by non-predicated threads (add, multiply, and multiply-accumulate). Each multiply-accumulate operation contributes 2 to the count. The count does not include special operations.\nMulti-context\nflop_count_sp_add\nNumber of single-precision floating-point add operations executed by non-predicated threads.\nMulti-context\nflop_count_sp_fma\nNumber of single-precision floating-point multiply-accumulate operations executed by non-predicated threads. Each multiply-accumulate operation contributes 1 to the count.\nMulti-context\nflop_count_sp_mul\nNumber of single-precision floating-point multiply operations executed by non-predicated threads.\nMulti-context\nflop_count_sp_special\nNumber of single-precision floating-point special operations executed by non-predicated threads.\nMulti-context\nflop_dp_efficiency\nRatio of achieved to peak double-precision floating-point operations\nMulti-context\nflop_hp_efficiency\nRatio of achieved to peak half-precision floating-point operations\nMulti-context\nflop_sp_efficiency\nRatio of achieved to peak single-precision floating-point operations\nMulti-context\ngld_efficiency\nRatio of requested global memory load throughput to required global memory load throughput expressed as percentage.\nMulti-context\ngld_requested_throughput\nRequested global memory load throughput\nMulti-context\ngld_throughput\nGlobal memory load throughput\nMulti-context\ngld_transactions\nNumber of global memory load transactions\nMulti-context\ngld_transactions_per_request\nAverage number of global memory load transactions performed for each global memory load.\nMulti-context\nglobal_atomic_requests\nTotal number of global atomic(Atom and Atom CAS) requests from Multiprocessor\nMulti-context\nglobal_hit_rate\nHit rate for global load and store in unified l1/tex cache\nMulti-context\nglobal_load_requests\nTotal number of global load requests from Multiprocessor\nMulti-context\nglobal_reduction_requests\nTotal number of global reduction requests from Multiprocessor\nMulti-context\nglobal_store_requests\nTotal number of global store requests from Multiprocessor. This does not include atomic requests.\nMulti-context\ngst_efficiency\nRatio of requested global memory store throughput to required global memory store throughput expressed as percentage.\nMulti-context\ngst_requested_throughput\nRequested global memory store throughput\nMulti-context\ngst_throughput\nGlobal memory store throughput\nMulti-context\ngst_transactions\nNumber of global memory store transactions\nMulti-context\ngst_transactions_per_request\nAverage number of global memory store transactions performed for each global memory store\nMulti-context\nhalf_precision_fu_utilization\nThe utilization level of the multiprocessor function units that execute 16 bit floating-point instructions on a scale of 0 to 10. Note that this doesn’t specify the utilization level of tensor core unit\nMulti-context\ninst_bit_convert\nNumber of bit-conversion instructions executed by non-predicated threads\nMulti-context\ninst_compute_ld_st\nNumber of compute load/store instructions executed by non-predicated threads\nMulti-context\ninst_control\nNumber of control-flow instructions executed by non-predicated threads (jump, branch, etc.)\nMulti-context\ninst_executed\nThe number of instructions executed\nMulti-context\ninst_executed_global_atomics\nWarp level instructions for global atom and atom cas\nMulti-context\ninst_executed_global_loads\nWarp level instructions for global loads\nMulti-context\ninst_executed_global_reductions\nWarp level instructions for global reductions\nMulti-context\ninst_executed_global_stores\nWarp level instructions for global stores\nMulti-context\ninst_executed_local_loads\nWarp level instructions for local loads\nMulti-context\ninst_executed_local_stores\nWarp level instructions for local stores\nMulti-context\ninst_executed_shared_atomics\nWarp level shared instructions for atom and atom CAS\nMulti-context\ninst_executed_shared_loads\nWarp level instructions for shared loads\nMulti-context\ninst_executed_shared_stores\nWarp level instructions for shared stores\nMulti-context\ninst_executed_surface_atomics\nWarp level instructions for surface atom and atom cas\nMulti-context\ninst_executed_surface_loads\nWarp level instructions for surface loads\nMulti-context\ninst_executed_surface_reductions\nWarp level instructions for surface reductions\nMulti-context\ninst_executed_surface_stores\nWarp level instructions for surface stores\nMulti-context\ninst_executed_tex_ops\nWarp level instructions for texture\nMulti-context\ninst_fp_16\nNumber of half-precision floating-point instructions executed by non-predicated threads (arithmetic, compare, etc.)\nMulti-context\ninst_fp_32\nNumber of single-precision floating-point instructions executed by non-predicated threads (arithmetic, compare, etc.)\nMulti-context\ninst_fp_64\nNumber of double-precision floating-point instructions executed by non-predicated threads (arithmetic, compare, etc.)\nMulti-context\ninst_integer\nNumber of integer instructions executed by non-predicated threads\nMulti-context\ninst_inter_thread_communication\nNumber of inter-thread communication instructions executed by non-predicated threads\nMulti-context\ninst_issued\nThe number of instructions issued\nMulti-context\ninst_misc\nNumber of miscellaneous instructions executed by non-predicated threads\nMulti-context\ninst_per_warp\nAverage number of instructions executed by each warp\nMulti-context\ninst_replay_overhead\nAverage number of replays for each instruction executed\nMulti-context\nipc\nInstructions executed per cycle\nMulti-context\nissue_slot_utilization\nPercentage of issue slots that issued at least one instruction, averaged across all cycles\nMulti-context\nissue_slots\nThe number of issue slots used\nMulti-context\nissued_ipc\nInstructions issued per cycle\nMulti-context\nl2_atomic_throughput\nMemory read throughput seen at L2 cache for atomic and reduction requests\nMulti-context\nl2_atomic_transactions\nMemory read transactions seen at L2 cache for atomic and reduction requests\nMulti-context\nl2_global_atomic_store_bytes\nBytes written to L2 from L1 for global atomics (ATOM and ATOM CAS)\nMulti-context\nl2_global_load_bytes\nBytes read from L2 for misses in L1 for global loads\nMulti-context\nl2_local_global_store_bytes\nBytes written to L2 from L1 for local and global stores. This does not include global atomics.\nMulti-context\nl2_local_load_bytes\nBytes read from L2 for misses in L1 for local loads\nMulti-context\nl2_read_throughput\nMemory read throughput seen at L2 cache for all read requests\nMulti-context\nl2_read_transactions\nMemory read transactions seen at L2 cache for all read requests\nMulti-context\nl2_surface_load_bytes\nBytes read from L2 for misses in L1 for surface loads\nMulti-context\nl2_surface_store_bytes\nBytes read from L2 for misses in L1 for surface stores\nMulti-context\nl2_tex_hit_rate\nHit rate at L2 cache for all requests from texture cache\nMulti-context\nl2_tex_read_hit_rate\nHit rate at L2 cache for all read requests from texture cache\nMulti-context\nl2_tex_read_throughput\nMemory read throughput seen at L2 cache for read requests from the texture cache\nMulti-context\nl2_tex_read_transactions\nMemory read transactions seen at L2 cache for read requests from the texture cache\nMulti-context\nl2_tex_write_hit_rate\nHit Rate at L2 cache for all write requests from texture cache\nMulti-context\nl2_tex_write_throughput\nMemory write throughput seen at L2 cache for write requests from the texture cache\nMulti-context\nl2_tex_write_transactions\nMemory write transactions seen at L2 cache for write requests from the texture cache\nMulti-context\nl2_utilization\nThe utilization level of the L2 cache relative to the peak utilization on a scale of 0 to 10\nMulti-context\nl2_write_throughput\nMemory write throughput seen at L2 cache for all write requests\nMulti-context\nl2_write_transactions\nMemory write transactions seen at L2 cache for all write requests\nMulti-context\nldst_executed\nNumber of executed local, global, shared and texture memory load and store instructions\nMulti-context\nldst_fu_utilization\nThe utilization level of the multiprocessor function units that execute shared load, shared store and constant load instructions on a scale of 0 to 10\nMulti-context\nldst_issued\nNumber of issued local, global, shared and texture memory load and store instructions\nMulti-context\nlocal_hit_rate\nHit rate for local loads and stores\nMulti-context\nlocal_load_requests\nTotal number of local load requests from Multiprocessor\nMulti-context\nlocal_load_throughput\nLocal memory load throughput\nMulti-context\nlocal_load_transactions\nNumber of local memory load transactions\nMulti-context\nlocal_load_transactions_per_request\nAverage number of local memory load transactions performed for each local memory load\nMulti-context\nlocal_memory_overhead\nRatio of local memory traffic to total memory traffic between the L1 and L2 caches expressed as percentage\nMulti-context\nlocal_store_requests\nTotal number of local store requests from Multiprocessor\nMulti-context\nlocal_store_throughput\nLocal memory store throughput\nMulti-context\nlocal_store_transactions\nNumber of local memory store transactions\nMulti-context\nlocal_store_transactions_per_request\nAverage number of local memory store transactions performed for each local memory store\nMulti-context\nnvlink_overhead_data_received\nRatio of overhead data to the total data, received through NVLink.\nDevice\nnvlink_overhead_data_transmitted\nRatio of overhead data to the total data, transmitted through NVLink.\nDevice\nnvlink_receive_throughput\nNumber of bytes received per second through NVLinks.\nDevice\nnvlink_total_data_received\nTotal data bytes received through NVLinks including headers.\nDevice\nnvlink_total_data_transmitted\nTotal data bytes transmitted through NVLinks including headers.\nDevice\nnvlink_total_nratom_data_transmitted\nTotal non-reduction atomic data bytes transmitted through NVLinks.\nDevice\nnvlink_total_ratom_data_transmitted\nTotal reduction atomic data bytes transmitted through NVLinks.\nDevice\nnvlink_total_response_data_received\nTotal response data bytes received through NVLink, response data includes data for read requests and result of non-reduction atomic requests.\nDevice\nnvlink_total_write_data_transmitted\nTotal write data bytes transmitted through NVLinks.\nDevice\nnvlink_transmit_throughput\nNumber of Bytes Transmitted per second through NVLinks.\nDevice\nnvlink_user_data_received\nUser data bytes received through NVLinks, doesn’t include headers.\nDevice\nnvlink_user_data_transmitted\nUser data bytes transmitted through NVLinks, doesn’t include headers.\nDevice\nnvlink_user_nratom_data_transmitted\nTotal non-reduction atomic user data bytes transmitted through NVLinks.\nDevice\nnvlink_user_ratom_data_transmitted\nTotal reduction atomic user data bytes transmitted through NVLinks.\nDevice\nnvlink_user_response_data_received\nTotal user response data bytes received through NVLink, response data includes data for read requests and result of non-reduction atomic requests.\nDevice\nnvlink_user_write_data_transmitted\nUser write data bytes transmitted through NVLinks.\nDevice\npcie_total_data_received\nTotal data bytes received through PCIe\nDevice\npcie_total_data_transmitted\nTotal data bytes transmitted through PCIe\nDevice\nshared_efficiency\nRatio of requested shared memory throughput to required shared memory throughput expressed as percentage\nMulti-context\nshared_load_throughput\nShared memory load throughput\nMulti-context\nshared_load_transactions\nNumber of shared memory load transactions\nMulti-context\nshared_load_transactions_per_request\nAverage number of shared memory load transactions performed for each shared memory load\nMulti-context\nshared_store_throughput\nShared memory store throughput\nMulti-context\nshared_store_transactions\nNumber of shared memory store transactions\nMulti-context\nshared_store_transactions_per_request\nAverage number of shared memory store transactions performed for each shared memory store\nMulti-context\nshared_utilization\nThe utilization level of the shared memory relative to peak utilization on a scale of 0 to 10\nMulti-context\nsingle_precision_fu_utilization\nThe utilization level of the multiprocessor function units that execute single-precision floating-point instructions on a scale of 0 to 10\nMulti-context\nsm_efficiency\nThe percentage of time at least one warp is active on a specific multiprocessor\nMulti-context\nspecial_fu_utilization\nThe utilization level of the multiprocessor function units that execute sin, cos, ex2, popc, flo, and similar instructions on a scale of 0 to 10\nMulti-context\nstall_constant_memory_dependency\nPercentage of stalls occurring because of immediate constant cache miss\nMulti-context\nstall_exec_dependency\nPercentage of stalls occurring because an input required by the instruction is not yet available\nMulti-context\nstall_inst_fetch\nPercentage of stalls occurring because the next assembly instruction has not yet been fetched\nMulti-context\nstall_memory_dependency\nPercentage of stalls occurring because a memory operation cannot be performed due to the required resources not being available or fully utilized, or because too many requests of a given type are outstanding\nMulti-context\nstall_memory_throttle\nPercentage of stalls occurring because of memory throttle\nMulti-context\nstall_not_selected\nPercentage of stalls occurring because warp was not selected\nMulti-context\nstall_other\nPercentage of stalls occurring due to miscellaneous reasons\nMulti-context\nstall_pipe_busy\nPercentage of stalls occurring because a compute operation cannot be performed because the compute pipeline is busy\nMulti-context\nstall_sleeping\nPercentage of stalls occurring because warp was sleeping\nMulti-context\nstall_sync\nPercentage of stalls occurring because the warp is blocked at a __syncthreads() call\nMulti-context\nstall_texture\nPercentage of stalls occurring because the texture sub-system is fully utilized or has too many outstanding requests\nMulti-context\nsurface_atomic_requests\nTotal number of surface atomic(Atom and Atom CAS) requests from Multiprocessor\nMulti-context\nsurface_load_requests\nTotal number of surface load requests from Multiprocessor\nMulti-context\nsurface_reduction_requests\nTotal number of surface reduction requests from Multiprocessor\nMulti-context\nsurface_store_requests\nTotal number of surface store requests from Multiprocessor\nMulti-context\nsysmem_read_bytes\nNumber of bytes read from system memory\nMulti-context\nsysmem_read_throughput\nSystem memory read throughput\nMulti-context\nsysmem_read_transactions\nNumber of system memory read transactions\nMulti-context\nsysmem_read_utilization\nThe read utilization level of the system memory relative to the peak utilization on a scale of 0 to 10\nMulti-context\nsysmem_utilization\nThe utilization level of the system memory relative to the peak utilization on a scale of 0 to 10\nMulti-context\nsysmem_write_bytes\nNumber of bytes written to system memory\nMulti-context\nsysmem_write_throughput\nSystem memory write throughput\nMulti-context\nsysmem_write_transactions\nNumber of system memory write transactions\nMulti-context\nsysmem_write_utilization\nThe write utilization level of the system memory relative to the peak utilization on a scale of 0 to 10\nMulti-context\ntensor_precision_fu_utilization\nThe utilization level of the multiprocessor function units that execute tensor core instructions on a scale of 0 to 10\nMulti-context\ntensor_int_fu_utilization\nThe utilization level of the multiprocessor function units that execute tensor core int8 instructions on a scale of 0 to 10. This metric is only available for device with compute capability 7.2.\nMulti-context\ntex_cache_hit_rate\nUnified cache hit rate\nMulti-context\ntex_cache_throughput\nUnified cache to Multiprocessor read throughput\nMulti-context\ntex_cache_transactions\nUnified cache to Multiprocessor read transactions\nMulti-context\ntex_fu_utilization\nThe utilization level of the multiprocessor function units that execute global, local and texture memory instructions on a scale of 0 to 10\nMulti-context\ntex_utilization\nThe utilization level of the unified cache relative to the peak utilization on a scale of 0 to 10\nMulti-context\ntexture_load_requests\nTotal number of texture Load requests from Multiprocessor\nMulti-context\nwarp_execution_efficiency\nRatio of the average active threads per warp to the maximum number of threads per warp supported on a multiprocessor\nMulti-context\nwarp_nonpred_execution_efficiency\nRatio of the average active threads per warp executing non-predicated instructions to the maximum number of threads per warp supported on a multiprocessor\nMulti-context\n10.\nWarp State\n\nThis section contains a description of each warp state. The warp can have following states:\nInstruction issued\n- An instruction or a pair of independent instructions was issued from a warp.\nStalled\n- Warp can be stalled for one of the following reasons. The stall reason distribution can be seen at source level in\nPC Sampling View\nor at kernel level in Latency analysis using ‘Examine Stall Reasons’\nStalled for instruction fetch\n- The next instruction was not yet available.\nTo reduce instruction fetch stalls:\nIf large loop have been unrolled in kernel, try reducing them.\nIf the kernel contains many calls to small function, try inlining more of them with the __inline__ or __forceinline__ qualifiers. Conversely, if inlining many functions or large functions, try __noinline__ to disable inlining of those functions.\nFor very short kernels, consider fusing into a single kernels.\nIf blocks with fewer threads are used, consider using fewer blocks of more threads. Occasional calls to __syncthreads() will then keep the warps in sync which may improve instruction cache hit rate.\nStalled for execution dependency\n- The next instruction is waiting for one or more of its inputs to be computed by earlier instruction(s).\nTo reduce execution dependency stalls, try to increase instruction-level parallelism (ILP). This can be done by, for example, increasing loop unrolling or processing several elements per thread. This prevents the thread from idling through the full latency of each instruction.\nStalled for memory dependency\n- The next instruction is waiting for a previous memory accesses to complete.\nTo reduce the memory dependency stalls\nTry to improve memory coalescing and/or efficiency of bytes fetched (alignment, etc.). Look at the source level analysis ‘Global Memory Access Pattern’ and/or the metrics gld_efficiency and gst_efficiency.\nTry to increase memory-level parallelism (MLP): the number of independent memory operations in flight per thread. Loop unrolling, loading vector types such as float4, and processing multiple elements per thread are all ways to increase memory-level parallelism.\nConsider moving frequently-accessed data closer to SM, such as by use of shared memory or read-only data cache.\nConsider re-computing data where possible instead of loading it from device memory.\nIf local memory accesses are high, consider increasing register count per thread to reduce spilling, even at the expense of occupancy since local memory accesses are cached only in L2 for GPUs with compute capability major = 5.\nStalled for memory throttle\n- A large number of outstanding memory requests prevents forward progress. On GPUs with compute capability major = 3, memory throttle indicates high number of memory replays.\nTo reduce memory throttle stalls:\nTry to find ways to combine several memory transactions into one (e.g., use 64-bit memory requests instead of two 32-bit requests).\nCheck for un-coalesced memory accesses using the source level analysis ‘Global Memory Access Pattern’ and/or the profiler metrics gld_efficiency and gst_efficiency; minimize them wherever possible.\nOn GPUs with compute capability major >= 3, consider using read-only data cache using LDG for un-coalesced global reads\nStalled for texture\n- The texture sub-system is fully utilized or has too many outstanding requests.\nTo reduce texture stalls:\nConsider combining several texture fetch operations into one (e.g., packing data in texture and unpacking in SM or using vector loads).\nConsider moving frequently-accessed data closer to SM by use of shared memory.\nConsider re-computing data where possible instead of fetching it from memory.\nOn GPUs with compute capability major < 5: Consider changing some texture accesses into regular global loads to reduce pressure on the texture unit, especially if you do not use texture-specific features such as interpolation.\nOn GPUs with compute capability major = 3: If global loads through the read-only data cache (LDG) are the source of texture accesses for this kernel, consider changing some of them back to regular global loads. Note that if LDG is being generated due to use of the __ldg() intrinsic, this simply means changing back to a normal pointer dereference, but if LDG is being generated automatically by the compiler due to the use of the const and __restrict__ qualifiers, this may be more difficult.\nStalled for sync\n- The warp is waiting for all threads to synchronize after a barrier instruction.\nTo reduce sync stalls:\nTry to improve load balancing i.e. try to increase work done between synchronization points; consider reducing thread block size.\nMinimize use of threadfence_*().\nOn GPUs with compute capability major >= 3: If __syncthreads() is being used because of data exchange through shared memory within a threadblock, consider whether warp shuffle operations can be used in place of some of these exchange/synchronize sequences.\nStalled for constant memory dependency\n- The warp is stalled on a miss in the cache for __constant__ memory and immediate.\nThis may be high the first time each constant is accessed (e.g., at the beginning of a kernel). To reduce these stalls,\nConsider reducing use of __constant__ or increase kernel runtime by increasing block count\nConsider increasing number of items processed per thread\nConsider merging several kernels that use the same __constant__ data to amortize the cost of misses in the constant cache.\nTry using regular global memory accesses instead of constant memory accesses.\nStalled for pipe busy - The warp is stalled because the functional unit required to execute the next instruction is busy.\nTo reduce stalls due to pipe busy:\nPrefer high-throughput operations over low-throughput operations. If precision doesn’t matter, use float instead of double precision arithmetic.\nLook for arithmetic improvements (e.g., order-of-operations changes) that may be mathematically valid but unsafe for the compiler to do automatically. Due to e.g. floating-point non-associativity.\nStalled for not selected\n- Warp was ready but did not get a chance to issue as some other warp was selected for issue. This reason generally indicates that kernel is possibly optimized well but in some cases, you may be able to decrease occupancy without impacting latency hiding, and doing so may help improve cache hit rates.\nStalled for other\n- Warp is blocked for an uncommon reason like compiler or hardware reasons. Developers do not have control over these stalls.\n11.\nMigrating to Nsight Tools from Visual Profiler and nvprof\n\nVisual Profiler and nvprof are deprecated and will be removed in a future CUDA release. It is recommended to use next-generation tools\nNVIDIA Nsight Systems\nfor GPU and CPU sampling and tracing and\nNVIDIA Nsight Compute\nfor GPU kernel profiling. The new tools still offer the same profiling / optimization / deployment workflow. The type of data you need to look at is the same. The commands have changed and the output looks a little different. The new tools are powerful, fast, and feature rich, allowing you to find solutions even more quickly.\nNVIDIA Nsight Systems\nis a system-wide performance analysis tool designed to visualize an application’s algorithms, help you identify the largest opportunities to optimize, and tune to scale efficiently across any quantity or size of CPUs and GPUs; from large servers to our smallest SoC. Refer to the\nMigrating from NVIDIA nvprof section\nsection in the NVIDIA Nsight Systems User Guide\nNVIDIA Nsight Compute\nis an interactive kernel profiler for CUDA applications. It provides detailed performance metrics and API debugging via a user interface and command line tool. In addition, its baseline feature allows users to compare results within the tool. Nsight Compute provides a customizable and data-driven user interface and metric collection and can be extended with analysis scripts for post-processing results. Refer to the\nnvprof Transition Guide\nsection in the Nsight Compute CLI document. Refer to the\nVisual Profiler Transition Guide\nsection in the Nsight Compute document.\nAlso refer to the blog posts on how to move your development to the next-generation tools:\nMigrating to Nsight Tools from Visual Profiler and nvprof\nTransitioning to Nsight Systems from Visual Profiler and nvprof\nUsing Nsight Compute to Inspect your Kernels\nTable 7. Which tools are available on which GPU architectures\n\nGPU architecture\nVisual Profiler and nvprof\nNsight Systems\nNsight Compute\nMaxwell\nYes\nNo\nNo\nPascal\nYes\nYes\nNo\nVolta\nYes\nYes\nYes\nTuring\nYes* (only tracing)\nYes\nYes\nAmpere and later GPU architectures\nNo\nYes\nYes\n* Only Tracing functionality is supported - Timeline, Activity, API. CUDA kernel profiling functionality i.e. collecting GPU performance metrics is not supported.\nThe following table maps the key features of Visual Profiler and nvprof to the NVIDIA Nsight tools\nTable 8. Mapping of key Visual Profiler and nvprof features\n\nVisual Profiler/nvprof feature categories\nNsight Systems\nNsight Compute\nTimeline/Activity/API Tracing\nYes\nCPU Sampling\nYes\nOpenACC\nYes\nOpenMP\nYes\nMPI\nYes\nMPS\nYes\nApplication Dependency Analysis\nUnified Memory Transfers\nYes\nUnified Memory Page Faults\nYes\nApplication Unified Memory Analysis\nApplication NVLink Analysis\nYes (per kernel)\nEvents and Metrics (per kernel)\nYes\nGuided and Unguided Kernel Analysis\nYes\nKernel Source-Disassembly View\nYes\nKernel PC Sampling\nYes\nNVTX\nYes\nYes\nRemote Profiling\nYes\nYes\n12.\nProfiler Known Issues\n\nThe following are known issues with the current release.\nVisual Profiler and nvprof don’t support devices with compute capability 8.0 and higher. Next-gen tools NVIDIA Nsight Compute and NVIDIA Nsight Systems should be used instead.\nStarting with the CUDA 11.0, Visual Profiler and nvprof don’t support macOS as the target platform. However Visual Profiler supported remote profiling from the macOS host until CUDA 12.5 release. This support is dropped in the CUDA 12.6 release. Visual Profiler was provided in a separate installer package to maintain the remote profiling workflow for CUDA developers on macOS. See\nDeveloper Tools for macOS\nfor download instructions.\nStarting with CUDA 10.2, Visual Profiler and nvprof use dynamic/shared CUPTI library. Thus it’s required to set the path to the CUPTI library before launching Visual Profiler and nvprof on Windows. CUPTI library can be found at\n\"C:\\Program\nFiles\\NVIDIA\nGPU\nComputing\nToolkit\\CUDA\\<cuda-toolkit>\\extras\\CUPTI\\lib64\"\nfor Windows.\nA security vulnerability issue required profiling tools to disable features using GPU performance counters for non-root or non-admin users when using a Windows 419.17 or Linux 418.43 or later driver. By default, NVIDIA drivers require elevated permissions to access GPU performance counters. On Tegra platforms, profile as root or using sudo. On other platforms, you can either start profiling as root or using sudo, or by enabling non-admin profiling. More details about the issue and the solutions can be found on the ERR_NVGPUCTRPERM\nweb page\n.\nNote\nVisual Profiler and nvprof allow tracing features for non-root and non-admin users on desktop platforms only, Tegra platforms require root or sudo access.\nUse of the environment variable LD_PRELOAD to load some versions of MPI libraries may result in a crash on Linux platforms. The workaround is to start the profiling session as a root user. For the normal user, the SUID permission for\nnvprof\nmust be set.\nTo ensure that all profile data is collected and flushed to a file, cudaDeviceSynchronize() followed by either cudaProfilerStop() or cuProfilerStop() should be called before the application exits. Refer the section\nFlush Profile Data\n.\nConcurrent kernel mode can add significant overhead if used on kernels that execute a large number of blocks and that have short execution durations.\nIf the kernel launch rate is very high, the device memory used to collect profiling data can run out. In such a case some profiling data might be dropped. This will be indicated by a warning.\nWhen profiling an application that uses CUDA Dynamic Parallelism (CDP) there are several limitations to the profiling tools.\nCDP kernel launch tracing has a limitation for devices with compute capability 7.0 and higher. Profiler traces all the host launched kernels until it encounters a host launched kernel which launches child kernels. Subsequent kernels are not traced.\nSource level analysis is not supported on devices with compute capability 7.0 and higher.\nThe Visual Profiler timeline does not display CUDA API calls invoked from within device-launched kernels.\nThe Visual Profiler does not display detailed event, metric, and source-level results for device-launched kernels. Event, metric, and source-level results collected for CPU-launched kernels will include event, metric, and source-level results for the entire call-tree of kernels launched from within that kernel.\nThe\nnvprof\nevent/metric output does not include results for device-launched kernels. Events/metrics collected for CPU-launched kernels will include events/metrics for the entire call-tree of kernels launched from within that kernel.\nProfiling APK binaries is not supported.\nUnified memory profiling is not supported on the ARM architecture (aarch64).\nWhen profiling an application in which a device kernel was stopped due to an assertion the profiling data will be incomplete and a warning or error message is displayed. But the message is not precise as the exact cause of the failure is not detected.\nFor dependency analysis, in cases where activity timestamps in the trace are slightly distorted such that they violate the programming model constraints, no dependencies or waiting times can be analyzed.\nDevices with compute capability 6.0 and higher introduce a new feature, compute preemption, to give fair chance for all compute contexts while running long tasks. With compute preemption feature-\nIf multiple contexts are running in parallel it is possible that long kernels will get preempted.\nSome kernels may get preempted occasionally due to timeslice expiry for the context.\nIf kernel has been preempted, the time the kernel spends preempted is still counted towards kernel duration. This can affect the kernel optimization priorities given by Visual Profiler as there is randomness introduced due to preemption.\nCompute preemption can affect events and metrics collection. The following are known issues with the current release:\nEvents and metrics collection for a MPS client can result in higher counts than expected on devices with compute capability 7.0 and higher, since MPS client may get preempted due to termination of another MPS client.\nEvents warps_launched and sm_cta_launched and metric inst_per_warp might provide higher counts than expected on devices with compute capability 6.0 and 6.1. Metric unique_warps_launched can be used in place of warps_launched to get correct count of actual warps launched as it is not affected by compute preemption.\nTo avoid compute preemption affecting profiler results try to isolate the context being profiled:\nRun the application on secondary GPU where display is not connected.\nOn Linux if the application is running on the primary GPU where the display driver is connected then unload the display driver.\nRun only one process that uses GPU at one time.\nDevices with compute capability 6.0 and higher support demand paging. When the kernel is scheduled for the first time, all the pages allocated using cudaMallocManaged and that are required for execution of the kernel are fetched in the global memory when GPU faults are generated. Profiler requires multiple passes to collect all the metrics required for kernel analysis. The kernel state needs to be saved and restored for each kernel replay pass. For devices with compute capability 6.0 and higher and platforms supporting Unified memory, in the first kernel iteration the GPU faults will be generated and all pages will be fetched in the global memory. Second iteration onwards GPU page faults will not occur. This will significantly affect the memory related events and timing. The time taken from trace will include the time required to fetch the pages but most of the metrics profiled in multiple iterations will not include time/cycles required to fetch the pages. This causes inconsistency in the profiler results.\nCUDA device enumeration and order, typically controlled through environment variables\nCUDA_VISIBLE_DEVICES\nand\nCUDA_DEVICE_ORDER\n, should remain the same for the profiler and the application.\nCUDA profiling might not work on systems that contain a mixture of supported and unsupported GPUs. On such systems, either set option\n--devices\nto supported devices in\nnvprof\n, or set environment variable\nCUDA_VISIBLE_DEVICES\nbefore launching\nnvprof\nor the Visual Profiler.\nBecause of the low resolution of the timer on Windows, the start and end timestamps can be same for activities having short execution duration on Windows. As a result, the\nnvprof\nand Visual Profiler report the following warning: “Found N invalid records in the result.”\nProfiler cannot interoperate with other Nvidia tools such as cuda-gdb, cuda-memcheck, Nsight Systems and Nsight Compute.\nOpenACC profiling might fail when OpenACC library is linked statically in the user application. This happens due to the missing definition of the OpenACC API routines needed for the OpenACC profiling, as compiler might ignore definitions for the functions not used in the application. This issue can be mitigated by linking the OpenACC library dynamically.\nVisual Profiler and nvprof versions shipped in the CUDA Toolkit 11.7 and CUDA Toolkit 11.8 don’t support Kepler (sm_35 and sm_37) devices. This issue can be resolved by upgrading the CUPTI library. Refer to the webpages\nCUPTI 11.7\nand\nCUPTI 11.8\nfor location of the CUPTI packages having the support for these Kepler devices.\nApplications using Optix SDK cannot be profiled using Visual Profiler and nvprof starting with the CUDA 12.4 release.\nProfiler is not supported on below system configurations:\n64-bit ARM Server CPU architecture (arm64 SBSA).\nVirtual GPUs (vGPU).\nWindows Subsystem for Linux (WSL).\nNVIDIA Crypto Mining Processors (CMP). For more information, please visit the\nweb page\n.\nVisual Profiler\nThe following are known issues related to Visual Profiler:\nVisual Profiler requires Java Runtime Environment (JRE) 1.8 to be available on the local system. However, starting with CUDA Toolkit version 10.1 Update 2, the JRE is no longer included in the CUDA Toolkit due to Oracle upgrade licensing changes. The user must install the required version of JRE 1.8 in order to use Visual Profiler. Refer to the section\nSetting up Java Runtime Environment\nfor more information.\nSome analysis results require metrics that are not available on all devices. When these analyses are attempted on a device where the metric is not available the analysis results will show that the required data is “not available”.\nUsing the mouse wheel button to scroll does not work within the Visual Profiler on Windows.\nSince Visual Profiler uses\nnvprof\nfor collecting profiling data,\nnvprof\nlimitations also apply to Visual Profiler.\nVisual Profiler cannot load profiler data larger than the memory size limited by JVM or available memory on the system. Refer\nImprove Loading of Large Profiles\nfor more information.\nVisual Profiler global menus do not show properly or are empty on some versions of Ubuntu. One workaround is to set environment variable “UBUNTU_MENUPROXY=0” before running Visual Profiler\nIn the Visual Profiler the NVLink Analysis diagram can be incorrect after scrolling the diagram. This can be corrected by horizontally resizing the diagram panel.\nVisual Profiler might not be able to show NVLink events on the timeline when large number of samples are collected. To work around this issue, refresh the timeline by doing zoom-in or zoom-out. Alternate solution is to save and open the session.\nFor unified memory profiling on a remote setup having different version of GCC than host machine, Visual Profiler might not be able to show the source code location for CPU page fault events.\nFor unified memory profiling on a remote setup having different architecture than the host machine (x86 versus POWER), Visual Profiler might not be able to show the source code location for CPU page fault and allocation tracking events.\nVisual Profiler is not supported on the ARM architecture (aarch64). You can use Remote Profiling. Refer the\nRemote Profiling\nsection for more information.\nVisual Profiler doesn’t support remote profiling for the Android target. The workaround is to run nvprof on the target and load the nvprof output in the Visual Profiler.\nFor remote profiling, the CUDA Toolkit installed on the host system must support the target device on the remote system.\nVisual Profiler might show strange symbol fonts on platforms which don’t have required fonts installed.\nWhen using remote profiling if there is a connection failure due to key exchange failure, then you will get an error message “Unable to establish shell connection to\n‘user\n@\nxxx\n’”. You can follow these steps to mitigate the issue.\nCheck the SSH daemon config file (default path is /etc/ssh/sshd_config) on the target\nComment out lines starting with:\nKexAlgorithms\nHostbasedAcceptedKeyTypes\nCiphers\nHostKey\nAuthorizedKeysFile\nRe-generate keys\nsudo ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key\nRestart sshd service\nsudo services sshd restart\nAccessing the local help document from Visual Profiler leads to HTTP Error 500. The workaround is to refer to this document (online document or pdf).\nVisual Profiler can’t remote into a target machine running Ubuntu 20.04 and later.\nnvprof\nThe following are known issues related to\nnvprof\n:\nnvprof\ncannot profile processes that\nfork()\nbut do not then\nexec()\n.\nnvprof\nassumes it has access to the temporary directory on the system, which it uses to store temporary profiling data. On Linux the default is\n/tmp\n. On Windows it’s specified by the system environment variables. To specify a custom location, change\n$TMPDIR\non Linux or\n%TMP%\non Windows.\nWhen multiple\nnvprof\nprocesses are run simultaneously on the same node, there is an issue of contention for files under the temporary directory. One workaround is to set a different temporary directory for each process.\nMultiple\nnvprof\nprocesses running concurrently using application replay may generate incorrect results or no results at all. To work around this issue you need to set a unique temporary directory per process. Set NVPROF_TMPDIR before launching\nnvprof\n.\nTo profile application on Android\n$TMPDIR\nenvironment variable has to be defined and point to a user-writable folder.\nProfiling results might be inconsistent when auto boost is enabled.\nnvprof\ntries to disable auto boost by default, it might fail to do so in some conditions, but profiling will continue.\nnvprof\nwill report a warning when auto boost cannot be disabled. Note that auto boost is supported only on certain Tesla devices from the Kepler+ family.\nProfiling a C++ application which overloads the new operator at the global scope and uses any CUDA APIs like\ncudaMalloc()\nor\ncudaMallocManaged()\ninside the overloaded new operator will result in a hang.\nNVTX annotations will not work when profiling all processes using the\nnvprof\noption\n--profile-all-processes\n. It is advised to set the environment variable NVTX_INJECTION64_PATH to point to the profiler injection library, libcuinj64.so on Linux and cuinj64_*.dll on Windows, before launching the application.\nEvents and Metrics\nThe following are known issues related to Events and Metrics profiling:\nProfiling features for devices with compute capability 7.5 and higher are supported in the\nNVIDIA Nsight Compute\n. Visual Profiler does not support Guided Analysis, some stages under Unguided Analysis and events and metrics collection for devices with compute capability 7.5 and higher. One can launch the NVIDIA Nsight Compute UI for devices with compute capability 7.5 and higher from Visual Profiler. Also nvprof does not support query and collection of events and metrics, source level analysis and other options used for profiling on devices with compute capability 7.5 and higher. The NVIDIA Nsight Compute command line interface can be used for these features.\nEvents or metrics collection may significantly change the overall performance characteristics of the application because all kernel executions are serialized on the GPU.\nIn event or metric profiling, kernel launches are blocking. Thus kernels waiting on updates from host or another kernel may hang. This includes synchronization between the host and the device build upon value-based CUDA stream synchronization APIs such as\ncuStreamWaitValue32()\nand\ncuStreamWriteValue32()\n.\nEvent and metric collection requiring multiple passes will not work with the\nnvprof\nkernel replay option for any kernel performing IPC or data communication between the kernel and CPU, kernel and regular CPU allocated memory, kernel and Peer GPU, or kernel and other Peer devices (e.g. GPU direct).\nFor some metrics, the required events can only be collected for a single CUDA context. For an application that uses multiple CUDA contexts, these metrics will only be collected for one of the contexts. The metrics that can be collected only for a single CUDA context are indicated in the\nmetric reference tables\n.\nSome metric values are calculated assuming a kernel is large enough to occupy all device multiprocessors with approximately the same amount of work. If a kernel launch does not have this characteristic, then those metric values may not be accurate.\nSome metrics are not available on all devices. To see a list of all available metrics on a particular NVIDIA GPU, type\nnvprof\n--query-metrics\n. You can also refer to the\nmetric reference tables\n.\nThe profilers may fail to collect events or metrics when “application replay” mode is turned on. This is most likely to happen if the application is multi-threaded and non-deterministic. Instead use “kernel replay” mode in this case.\nFor applications that allocate large amount of device memory, the profiler may take significant time to collect all events or metrics when “kernel replay” mode is used. Instead use “application replay” mode in this case.\nHere are a couple of reasons why Visual Profiler may fail to gather metric or event information.\nMore than one tool is trying to access the GPU. To fix this issue please make sure only one tool is using the GPU at any given point. Tools include Nsight Compute, Nsight Systems, Nsight Graphics, and applications that use either CUPTI or PerfKit API (NVPM) to read event values.\nMore than one application is using the GPU at the same time Visual Profiler is profiling a CUDA application. To fix this issue please close all applications and just run the one with Visual Profiler. Interacting with the active desktop should be avoided while the application is generating event information. Please note that for some types of event Visual Profiler gathers events for only one context if the application is using multiple contexts within the same application.\nWhen collecting events or metrics with the\n--events\n,\n--metrics\n, or\n--analysis-metrics\noptions,\nnvprof\nwill use kernel replay to execute each kernel multiple times as needed to collect all the requested data. If a large number of events or metrics are requested then a large number of replays may be required, resulting in a significant increase in application execution time.\nSome events are not available on all devices. To see a list of all available events on a particular device, type\nnvprof\n--query-events\n.\nEnabling certain events can cause GPU kernels to run longer than the driver’s watchdog time-out limit. In these cases the driver will terminate the GPU kernel resulting in an application error and profiling data will not be available. Please disable the driver watchdog time out before profiling such long running CUDA kernels\nOn Linux, setting the X Config option Interactive to false is recommended.\nFor Windows, detailed information about TDR (Timeout Detection and Recovery) and how to disable it is available at\nhttps://docs.microsoft.com/en-us/windows-hardware/drivers/display/timeout-detection-and-recovery\nnvprof\ncan give out of memory error for event and metrics profiling, it could be due to large number of instructions in the kernel.\nProfiling results might be incorrect for CUDA applications compiled with nvcc version older than 9.0 for devices with compute capability 6.0 and 6.1. It is advised to recompile the application with nvcc version 9.0 or later. Ignore this warning if code is already compiled with the recommended nvcc version.\nPC Sampling is not supported on Tegra platforms.\nProfiling is not supported for multidevice cooperative kernels, that is, kernels launched by using the API functions cudaLaunchCooperativeKernelMultiDevice or cuLaunchCooperativeKernelMultiDevice.\nProfiling is not supported for CUDA kernel nodes launched by a CUDA Graph.\n13.\nChangelog\n\nProfiler changes in CUDA 12.8\nList of changes done as part of the CUDA Toolkit 12.8 release.\nVisual Profiler and nvprof are deprecated and will be removed in a future CUDA release.\nGeneral bug fixes. No new feature is added in this release.\nProfiler changes in CUDA 12.6\nList of changes done as part of the CUDA Toolkit 12.6 release.\nDropped Visual Profiler’s remote profiling support from the macOS host.\nGeneral bug fixes. No new feature is added in this release.\nProfiler changes in CUDA 12.5\nList of changes done as part of the CUDA Toolkit 12.5 release.\nVisual Profiler’s remote profiling support from the macOS host is deprecated. It will be dropped in an upcoming release.\nSupport for IBM Power architecture is dropped.\nGeneral bug fixes. No new feature is added in this release.\nProfiler changes in CUDA 12.4\nList of changes done as part of the CUDA Toolkit 12.4 release.\nGeneral bug fixes. No new feature is added in this release.\nProfiler changes in CUDA 12.3\nList of changes done as part of the CUDA Toolkit 12.3 release.\nGeneral bug fixes. No new feature is added in this release.\nProfiler changes in CUDA 12.2\nList of changes done as part of the CUDA Toolkit 12.2 release.\nGeneral bug fixes. No new feature is added in this release.\nProfiler changes in CUDA 12.1\nList of changes done as part of the CUDA Toolkit 12.1 release.\nGeneral bug fixes. No new feature is added in this release.\nProfiler changes in CUDA 12.0\nList of changes done as part of the CUDA Toolkit 12.0 release.\nGeneral bug fixes. No new feature is added in this release.\nProfiler changes in CUDA 11.8\nList of changes done as part of the CUDA Toolkit 11.8 release.\nGeneral bug fixes. No new feature is added in this release.\nProfiler changes in CUDA 11.7\nList of changes done as part of the CUDA Toolkit 11.7 release.\nGeneral bug fixes. No new feature is added in this release.\nProfiler changes in CUDA 11.6\nList of changes done as part of the CUDA Toolkit 11.6 release.\nGeneral bug fixes. No new feature is added in this release.\nProfiler changes in CUDA 11.5\nList of changes done as part of the CUDA Toolkit 11.5 release.\nGeneral bug fixes. No new feature is added in this release.\nProfiler changes in CUDA 11.4\nList of changes done as part of the CUDA Toolkit 11.4 release.\nGeneral bug fixes. No new feature is added in this release.\nProfiler changes in CUDA 11.3\nList of changes done as part of the CUDA Toolkit 11.3 release.\nVisual Profiler extends remote profiling support to macOS host running version 11 (Big Sur) on Intel x86_64 architecture.\nGeneral bug fixes.\nProfiler changes in CUDA 11.2\nList of changes done as part of the CUDA Toolkit 11.2 release.\nGeneral bug fixes. No new feature is added in this release.\nProfiler changes in CUDA 11.1\nList of changes done as part of the CUDA Toolkit 11.1 release.\nGeneral bug fixes. No new feature is added in this release.\nProfiler changes in CUDA 11.0\nList of changes done as part of the CUDA Toolkit 11.0 release.\nVisual Profiler and nvprof don’t support devices with compute capability 8.0 and higher. Next-gen tools NVIDIA Nsight Compute and NVIDIA Nsight Systems should be used instead.\nStarting with the CUDA 11.0, Visual Profiler and nvprof won’t support Mac as the target platform. However Visual Profiler will continue to support remote profiling from the Mac host. Visual Profiler will be provided in a separate installer package to maintain the remote profiling workflow for CUDA developers on Mac.\nAdded support to trace Optix applications.\nFixed the nvprof option –annotate-mpi which was broken since CUDA 10.0.\nProfiler changes in CUDA 10.2\nList of changes done as part of the CUDA Toolkit 10.2 release.\nVisual Profiler and nvprof allow tracing features for non-root and non-admin users on desktop platforms. Note that events and metrics profiling is still restricted for non-root and non-admin users. More details about the issue and the solutions can be found on this\nweb page\n.\nStarting with CUDA 10.2, Visual Profiler and nvprof use dynamic/shared CUPTI library. Thus it’s required to set the path to the CUPTI library before launching Visual Profiler and nvprof. CUPTI library can be found at\n/usr/local/<cuda-toolkit>/extras/CUPTI/lib64\nor\n/usr/local/<cuda-toolkit>/targets/<arch>/lib\nfor POSIX platforms and\n\"C:\\Program\nFiles\\NVIDIA\nGPU\nComputing\nToolkit\\CUDA\\<cuda-toolkit>\\extras\\CUPTI\\lib64\"\nfor Windows.\nProfilers no longer turn off the performance characteristics of CUDA Graph when tracing the application.\nAdded an option to enable/disable the OpenMP profiling in Visual Profiler.\nFixed the incorrect timing issue for the asynchronous cuMemset/cudaMemset activity.\nProfiler changes in CUDA 10.1 Update 2\nList of changes done as part of the CUDA Toolkit 10.1 Update 2 release.\nThis release is focused on bug fixes and stability of the profiling tools.\nA security vulnerability issue required profiling tools to disable all the features for non-root or non-admin users. As a result, Visual Profiler and nvprof cannot profile the application when using a Windows 419.17 or Linux 418.43 or later driver. More details about the issue and the solutions can be found on this\nweb page\n.\nVisual Profiler requires Java Runtime Environment (JRE) 1.8 to be available on the local system. However, starting with CUDA Toolkit version 10.1 Update 2, the JRE is no longer included in the CUDA Toolkit due to Oracle upgrade licensing changes. The user must install the required version of JRE 1.8 in order to use Visual Profiler. Refer to the section\nSetting up Java Runtime Environment\nfor more information.\nProfiler changes in CUDA 10.1\nList of changes done as part of the CUDA Toolkit 10.1 release.\nThis release is focused on bug fixes and stability of the profiling tools.\nSupport for NVTX string registration API nvtxDomainRegisterStringA().\nProfiler changes in CUDA 10.0\nList of changes done as part of the CUDA Toolkit 10.0 release.\nAdded tracing support for devices with compute capability 7.5.\nProfiling features for devices with compute capability 7.5 and higher are supported in the\nNVIDIA Nsight Compute\n. Visual Profiler does not support Guided Analysis, some stages under Unguided Analysis and events and metrics collection for devices with compute capability 7.5 and higher. One can launch the NVIDIA Nsight Compute UI for devices with compute capability 7.5 and higher from Visual Profiler. Also nvprof does not support query and collection of events and metrics, source level analysis and other options used for profiling on devices with compute capability 7.5 and higher. The NVIDIA Nsight Compute command line interface can be used for these features.\nVisual Profiler and nvprof now support OpenMP profiling where available. See\nOpenMP\nfor more information.\nTracing support for CUDA kernels, memcpy and memset nodes launched by a CUDA Graph.\nProfiler supports version 3 of NVIDIA Tools Extension API (NVTX). This is a header-only implementation of NVTX version 2.\nProfiler changes in CUDA 9.2\nList of changes done as part of the CUDA Toolkit 9.2 release.\nThe Visual Profiler allows to switch multiple segments to non-segment mode for Unified Memory profiling on the timeline. Earlier it was restircted to single segment only.\nThe Visual Profiler shows a summary view of the memory hierarchy of the CUDA programming model. This is available for devices with compute capability 5.0 and higher. Refer\nMemory Statistics\nfor more information.\nThe Visual Profiler can correctly import profiler data generated by nvprof when the option\n--kernels\nkernel-filter\nis used.\nnvprof supports display of basic PCIe topolgy including PCI bridges between NVIDIA GPUs and Host Bridge.\nTo view and analyze bandwidth of memory transfers over PCIe topologies, new set of metrics to collect total data bytes transmitted and recieved through PCIe are added. Those give accumulated count for all devices in the system. These metrics are collected at the device level for the entire application. And those are made available for devices with compute capability 5.2 and higher.\nThe Visual Profiler and nvprof added support for new metrics:\nInstruction executed for different types of load and store\nTotal number of cached global/local load requests from SM to texture cache\nGlobal atomic/non-atomic/reduction bytes written to L2 cache from texture cache\nSurface atomic/non-atomic/reduction bytes written to L2 cache from texture cache\nHit rate at L2 cache for all requests from texture cache\nDevice memory (DRAM) read and write bytes\nThe utilization level of the multiprocessor function units that execute tensor core instructions for devices with compute capability 7.0\nnvprof allows to collect tracing infromation along with the profiling information in the same pass. Use new option\n--trace\n<api|gpu>\nto enable trace along with collection of events/metrics.\nProfiler changes in CUDA 9.1\nList of changes done as part of the CUDA Toolkit 9.1 release.\nThe Visual Profiler shows the breakdown of the time spent on the CPU for each thread in the\nCPU Details View\n.\nThe Visual Profiler supports a new option to select the PC sampling frequency.\nThe Visual Profiler shows NVLink version in the NVLink topology.\nnvprof\nprovides the correlation ID when profiling data is generated in CSV format.\nProfiler changes in CUDA 9.0\nList of changes done as part of the CUDA Toolkit 9.0 release.\nVisual Profiler and\nnvprof\nnow support profiling on devices with compute capability 7.0.\nTools and extensions for profiling are hosted on Github at\nhttps://github.com/NVIDIA/cuda-profiler\nThere are several enhancements to Unified Memory profiling:\nThe Visual Profiler now associates unified memory events with the source code at which the memory is allocated.\nThe Visual Profiler now correlates a CPU page fault to the source code resulting in the page fault.\nNew Unified Memory profiling events for page thrashing, throttling and remote map are added.\nThe Visual Profiler provides an option to switch between segment and non-segment mode on the timeline.\nThe Visual Profiler supports filtering of Unified Memory profiling events based on the virtual address, migration reason or the page fault access type.\nCPU page fault support is extended to Mac platforms.\nTracing and profiling of cooperative kernel launches is supported.\nThe Visual Profiler shows NVLink events on the timeline.\nThe Visual Profiler color codes links in the NVLink topology diagram based on throughput.\nThe Visual Profiler supports new options to make it easier to do multi-hop remote profiling.\nnvprof\nsupports a new option to select the PC sampling frequency.\nThe Visual Profiler supports remote profiling to systems supporting\nssh\nkey exchange algorithms with a key length of 2048 bits.\nOpenACC profiling is now also supported on non-NVIDIA systems.\nnvprof\nflushes all profiling data when a\nSIGINT\nor\nSIGKILL\nsignal is encountered.\nProfiler changes in CUDA 8.0\nList of changes done as part of the CUDA Toolkit 8.0 release.\nVisual Profiler and nvprof now support NVLink analysis for devices with compute capability 6.0. See\nNVLink view\nfor more information.\nVisual Profiler and nvprof now support dependency analysis which enables optimization of the program runtime and concurrency of applications utilizing multiple CPU threads and CUDA streams. It allows computing the critical path of a specific execution, detect waiting time and inspect dependencies between functions executing in different threads or streams. See\nDependency Analysis\nfor more information.\nVisual Profiler and nvprof now support OpenACC profiling. See\nOpenACC\nfor more information.\nVisual Profiler now supports CPU profiling. Refer\nCPU Details View\nand\nCPU Source View\nfor more information.\nUnified Memory profiling now provides GPU page fault information on devices with compute capability 6.0 and 64 bit Linux platforms.\nUnified Memory profiling now provides CPU page fault information on 64 bit Linux platforms.\nUnified Memory profiling support is extended to the Mac platform.\nThe Visual Profiler source-disassembly view has several enhancements. There is now a single integrated view for the different source level analysis results collected for a kernel instance. Results of different analysis steps can be viewed together. See\nSource-Disassembly View\nfor more information.\nThe PC sampling feature is enhanced to point out the true latency issues for devices with compute capability 6.0 and higher.\nSupport for 16-bit floating point (FP16) data format profiling.\nIf the new NVIDIA Tools Extension API(NVTX) feature of domains is used then Visual Profiler and nvprof will show the NVTX markers and ranges grouped by domain.\nThe Visual Profiler now adds a default file extension\n.nvvp\nif an extension is not specified when saving or opening a session file.\nThe Visual Profiler now supports timeline filtering options in create new session and import dialogs. Refer “Timeline Options” section under\nCreating a Session\nfor more details.\nProfiler changes in CUDA 7.5\nList of changes done as part of the CUDA Toolkit 7.5 release.\nVisual\nProfiler\nnow supports PC sampling for devices with compute capability 5.2. Warp state including stall reasons are shown at source level for kernel latency analysis. See\nPC Sampling View\nfor more information.\nVisual\nProfiler\nnow supports profiling child processes and profiling all processes launched on the same system. See\nCreating a Session\nfor more information on the new multi-process profiling options. For profiling CUDA applications using Multi-Process Service(MPS) see\nMPS profiling with Visual Profiler\nVisual\nProfiler\nimport now supports browsing and selecting files on a remote system.\nnvprof\nnow supports CPU profiling. See\nCPU Sampling\nfor more information.\nAll events and metrics for devices with compute capability 5.2 can now be collected accurately in presence of multiple contexts on the GPU.\nProfiler changes in CUDA 7.0\nThe profiling tools contain a number of changes and new features as part of the CUDA Toolkit 7.0 release.\nThe Visual Profiler has been updated with several enhancements:\nPerformance is improved when loading large data file. Memory usage is also reduced.\nVisual Profiler timeline is improved to view multi-gpu MPS profile data.\nUnified memory profiling is enhanced by providing fine grain data transfers to and from the GPU, coupled with more accurate timestamps with each transfer.\nnvprof\nhas been updated with several enhancements:\nAll events and metrics for devices with compute capability 3.x and 5.0 can now be collected accurately in presence of multiple contexts on the GPU.\nProfiler changes in CUDA 6.5\nList of changes done as part of the CUDA Toolkit 6.5 release.\nThe Visual Profiler kernel memory analysis has been updated with several enhancements:\nECC overhead is added which provides a count of memory transactions required for ECC\nUnder L2 cache a split up of transactions for L1 Reads, L1 Writes, Texture Reads, Atomic and Noncoherent reads is shown\nUnder L1 cache a count of Atomic transactions is shown\nThe Visual Profiler kernel profile analysis view has been updated with several enhancements:\nInitially the instruction with maximum execution count is highlighted\nA bar is shown in the background of the counter value for the “Exec Count” column to make it easier to identify instruction with high execution counts\nThe current assembly instruction block is highlighted using two horizontal lines around the block. Also “next” and “previous” buttons are added to move to the next or previous block of assembly instructions.\nSyntax highlighting is added for the CUDA C source.\nSupport is added for showing or hiding columns.\nA tooltip describing each column is added.\nnvprof\nnow supports a new application replay mode for collecting multiple events and metrics. In this mode the application is run multiple times instead of using kernel replay. This is useful for cases when the kernel uses a large amount of device memory and use of kernel replay can be slow due to a high overhead of saving and restoring device memory for each kernel replay run. See\nEvent/metric Summary Mode\nfor more information. Visual Profiler also supports this new application replay mode and it can enabled in the Visual Profiler “New Session” dialog.\nVisual Profiler now displays peak single precision flops and double precision flops for a GPU under device properties.\nImproved source-to-assembly code correlation for CUDA Fortran applications compiled by the PGI CUDA Fortran compiler.\nProfiler changes in CUDA 6.0\nList of changes done as part of the CUDA Toolkit 6.0 release.\nUnified Memory is fully supported by both the Visual Profiler and\nnvprof\n. Both profilers allow you to see the Unified Memory related memory traffic to and from each GPU on your system.\nThe standalone Visual Profiler,\nnvvp\n, now provides a multi-process timeline view. You can import multiple timeline data sets collected with\nnvprof\ninto\nnvvp\nand view them on the same timeline to see how they are sharing the GPU(s). This multi-process import capability also includes support for CUDA applications using MPS. See\nMPS Profiling\nfor more information.\nThe Visual Profiler now supports a remote profiling mode that allows you to collect a profile on a remote Linux system and view the timeline, analysis results, and detailed results on your local Linux, Mac, or Windows system. See\nRemote Profiling\nfor more information.\nThe Visual Profiler analysis system now includes a side-by-side source and disassembly view annotated with instruction execution counts, inactive thread counts, and predicated instruction counts. This new view enables you to find hotspots and inefficient code sequences within your kernels.\nThe Visual Profiler analysis system has been updated with several new analysis passes: 1) kernel instructions are categorized into classes so that you can see if instruction mix matches your expectations, 2) inefficient shared memory access patterns are detected and reported, and 3) per-SM activity level is presented to help you detect detect load-balancing issues across the blocks of your kernel.\nThe Visual Profiler guided analysis system can now generate a kernel analysis report. The report is a PDF version of the per-kernel information presented by the guided analysis system.\nBoth\nnvvp\nand\nnvprof\ncan now operate on a system that does not have an NVIDIA GPU. You can import profile data collected from another system and view and analyze it on your GPU-less system.\nProfiling overheads for both\nnvvp\nand\nnvprof\nhave been significantly reduced.\n14.\nNotices\n\n14.1.\nNotice\n\nThis document is provided for information purposes only and shall not be regarded as a warranty of a certain functionality, condition, or quality of a product. NVIDIA Corporation (“NVIDIA”) makes no representations or warranties, expressed or implied, as to the accuracy or completeness of the information contained in this document and assumes no responsibility for any errors contained herein. NVIDIA shall have no liability for the consequences or use of such information or for any infringement of patents or other rights of third parties that may result from its use. This document is not a commitment to develop, release, or deliver any Material (defined below), code, or functionality.\nNVIDIA reserves the right to make corrections, modifications, enhancements, improvements, and any other changes to this document, at any time without notice.\nCustomer should obtain the latest relevant information before placing orders and should verify that such information is current and complete.\nNVIDIA products are sold subject to the NVIDIA standard terms and conditions of sale supplied at the time of order acknowledgement, unless otherwise agreed in an individual sales agreement signed by authorized representatives of NVIDIA and customer (“Terms of Sale”). NVIDIA hereby expressly objects to applying any customer general terms and conditions with regards to the purchase of the NVIDIA product referenced in this document. No contractual obligations are formed either directly or indirectly by this document.\nNVIDIA products are not designed, authorized, or warranted to be suitable for use in medical, military, aircraft, space, or life support equipment, nor in applications where failure or malfunction of the NVIDIA product can reasonably be expected to result in personal injury, death, or property or environmental damage. NVIDIA accepts no liability for inclusion and/or use of NVIDIA products in such equipment or applications and therefore such inclusion and/or use is at customer’s own risk.\nNVIDIA makes no representation or warranty that products based on this document will be suitable for any specified use. Testing of all parameters of each product is not necessarily performed by NVIDIA. It is customer’s sole responsibility to evaluate and determine the applicability of any information contained in this document, ensure the product is suitable and fit for the application planned by customer, and perform the necessary testing for the application in order to avoid a default of the application or the product. Weaknesses in customer’s product designs may affect the quality and reliability of the NVIDIA product and may result in additional or different conditions and/or requirements beyond those contained in this document. NVIDIA accepts no liability related to any default, damage, costs, or problem which may be based on or attributable to: (i) the use of the NVIDIA product in any manner that is contrary to this document or (ii) customer product designs.\nNo license, either expressed or implied, is granted under any NVIDIA patent right, copyright, or other NVIDIA intellectual property right under this document. Information published by NVIDIA regarding third-party products or services does not constitute a license from NVIDIA to use such products or services or a warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual property rights of the third party, or a license from NVIDIA under the patents or other intellectual property rights of NVIDIA.\nReproduction of information in this document is permissible only if approved in advance by NVIDIA in writing, reproduced without alteration and in full compliance with all applicable export laws and regulations, and accompanied by all associated conditions, limitations, and notices.\nTHIS DOCUMENT AND ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, “MATERIALS”) ARE BEING PROVIDED “AS IS.” NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL NVIDIA BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Notwithstanding any damages that customer might incur for any reason whatsoever, NVIDIA’s aggregate and cumulative liability towards customer for the products described herein shall be limited in accordance with the Terms of Sale for the product.\n14.2.\nOpenCL\n\nOpenCL is a trademark of Apple Inc. used under license to the Khronos Group Inc.\n14.3.\nTrademarks\n\nNVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated.", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://docs.nvidia.com/cuda/profiler-users-guide/index.html"}}
{"text": "CUDA Installation Guide for Linux — Installation Guide for Linux 13.0 documentation\n»\nCUDA Installation Guide for Linux\nv13.0 |\nPDF\n|\nArchive\nCUDA Installation Guide for Linux\n1.\nOverview\nï\nThe NVIDIA CUDA Installation Guide for Linux provides comprehensive instructions for installing the CUDA Toolkit across multiple Linux distributions and architectures. CUDAÂ® is NVIDIAâs parallel computing platform that enables\ndramatic performance increases by harnessing GPU power for computational workloads. This guide covers four primary installation methods: package manager installation (recommended for most users, supporting RPM and DEB packages\nwith native package management integration), runfile installation (distribution-independent standalone installer), Conda installation (for environment management), and pip wheels (Python-focused runtime installation). The guide\nsupports major Linux distributions including Ubuntu, Red Hat Enterprise Linux, SUSE, Debian, Fedora, and specialized distributions like Amazon Linux and Azure Linux, across x86_64, ARM64-SBSA, and ARM64-Jetson architectures.\nEach installation method includes detailed pre-installation requirements (CUDA-capable GPU, supported OS version, GCC compiler), step-by-step procedures, and post-installation configuration including environment setup, sample\nverification, and integration with development tools like Nsight and CUDA-GDB.\n2.\nIntroduction\nï\nCUDA\nÂ®\nis a parallel computing platform and programming model invented by NVIDIA\nÂ®\n. It enables dramatic increases in computing performance by harnessing the power of the graphics processing unit (GPU).\nCUDA was developed with several design goals in mind:\nProvide a small set of extensions to standard programming languages, like C, that enable a straightforward implementation of parallel algorithms. With CUDA C/Cï»¿+ï»¿+, programmers can focus on the task of parallelization of the algorithms rather than spending time on their implementation.\nSupport heterogeneous computation where applications use both the CPU and GPU. Serial portions of applications are run on the CPU, and parallel portions are offloaded to the GPU. As such, CUDA can be incrementally applied to existing applications. The CPU and GPU are treated as separate devices that have their own memory spaces. This configuration also allows simultaneous computation on the CPU and GPU without contention for memory resources.\nCUDA-capable GPUs have hundreds of cores that can collectively run thousands of computing threads. These cores have shared resources including a register file and a shared memory. The on-chip shared memory allows parallel tasks running on these cores to share data without sending it over the system memory bus.\nThis guide will show you how to install and check the correct operation of the CUDA development tools.\nNote\nInstructions for installing NVIDIA Drivers are now in the\nDriver installation guide\n.\n2.1.\nSystem Requirements\nï\nTo use NVIDIA CUDA on your system, you will need the following installed:\nCUDA-capable GPU\nA supported version of Linux with a gcc compiler and toolchain\nCUDA Toolkit (available at\nhttps://developer.nvidia.com/cuda-downloads\n)\nThe CUDA development environment relies on tight integration with the host development environment, including the host compiler and C runtime libraries, and is therefore only supported on distribution versions that have been qualified for this CUDA Toolkit release.\nThe following table lists the supported Linux distributions. Please review the footnotes associated with the table.\nNote\nThe value of the columns âCodenameâ and the architecture in parenthesis should be used to replace occurrences of the\n<distro>\nand the\n<arch>\nreferences across this document.\nTable 1\nNative Linux Distribution Support in CUDA 13.0 Update 2\nï\nDistribution\nOS Version\nKernelÂ¹\nDefault GCC\nGLIBC\nx86_64\nRHEL 10.x\n(x = 0)\n6.12.0-55\n14.2.1\n2.39\nRHEL 9.x\n(x â¤ 6)\n5.14.0-570.12.1\n11.5.0\n2.34\nRHEL 8.x\n(x â¤ 10)\n4.18.0-553\n8.5.0\n2.28\nRocky Linux 10.x\n(x = 0)\n6.12.0-55.21.1\n14.2.1\n2.39\nRocky Linux 9.x\n(x â¤ 6)\n5.14.0-570.19.1\n11.5.0\n2.34\nRocky Linux 8.x\n(x â¤ 10)\n4.18.0-553\n8.5.0\n2.28\nOracle Linux\n9\n5.14.0-427\n11.4.1\n2.34\nOracle Linux\n8\n4.18.0-553\n8.5.0\n2.28\nSUSE SLES 15.x\n(x = 6/7)\n6.4.0-150600.21\n7.5.0\n2.38\nUbuntu 24.04.x LTS\n(x â¤ 3)\n6.14.0-29\n13.3.0\n2.39\nUbuntu 22.04.x LTS\n(x â¤ 5)\n6.5.0-45\n12.3.0\n2.35\nDebian 12.x\n(x â¤ 12)\n6.1.148-1\n12.2.0\n2.36\nOpenSUSE Leap 15.x\n(x = 6)\n6.4.0-150600.21\n7.5.0\n2.38\nFedora\n42\n6.14.0-63\n15.1.1\n2.41\nKylinOS\nV10 SP3 2403\n4.19.90-89.11.v2401\n10.x\n2.28\nAmazon Linux 2023\nAL2023\n6.1.82-99.168\n11.4.1\n2.34\nMSFT Azure Linux\n3.0\n6.6.64.2-9.azl3\n11.2.0\n2.38-8\nMSFT Azure Linux\n2.0\n5.15.158.2-1\n13.2.0\n2.35\nGeneric arm64 systems (sbsa)\nRHEL 10.x\n(x = 0)\n6.12.0-55.7.1.el10_0\n14.2.1\n2.39\nRHEL 9.x\n(x â¤ 6)\n5.14.0-570.17.1\n11.5.0\n2.35\n-2-63\nRHEL 8.x\n(x â¤ 10)\n4.18.0-553\n8.5.0\n2.28\nUbuntu 22.04.x LTS\n(x â¤ 5)\n6.5.0-1019\n11.4.0\n2.35\nUbuntu 24.04.x LTS\n(x â¤ 3)\n6.8.0-83-generic\n13.3.0\n2.39\nSUSE SLES 15.x\n(x = 6/7)\n6.4.0-150700.51\n7.5.0\n2.38\nKylinOS V10 SP3\nV10 SP3 2403\n4.19.90-52\n7.3.0\n2.28\nGRACE only arm64 systems (sbsa)\nAmazon Linux 2023\nAL2023\n6.12.16-18\n11.4.1\n2.34\nMSFT Azure Linux\n3.0\n6.6.64.2-9.azl3\n13.2.0\n2.38-8\nUbuntu 22.04.x LTS\n(x â¤ 5)\n6.8.0-1030-nvidia-64k\n11.4.0\n2.35\nUbuntu 24.04.x LTS\n(x â¤ 3)\n6.8.0-1031-nvidia-64k\n13.2.0\n2.39\nRHEL 10.x\n(x = 0)\n6.12.0-55.9.1.el10_0\n14.2.1\n2.39\nRHEL 9.x\n(x = 4/5/6)\n5.14.0-570.28.1.el9_6.aarch64+64k\n11.5.0\n2.34\nSUSE SLES 15.x\n(x = 6/7)\n6.4.0-150700.51\n7.5.0\n2.38\narm64 sbsa Jetson (dGPU + iGPU with OpenRM)\nUbuntu 24.04.x LTS Rel37 (JP7.x)\nnative\n6.8.12-tegra\n13.3.0\n2.39\nUbuntu 24.04.x LTS Rel37 (JP7.x)\ncross\n6.11.0-28-generic\n13.3.0\n2.39\nFor specific kernel versions supported on Red Hat Enterprise Linux (RHEL), visit\nhttps://access.redhat.com/articles/3078\n.\nA list of kernel versions including the release dates for SUSE Linux Enterprise Server (SLES) is available at\nhttps://www.suse.com/support/kb/doc/?id=000019587\n.\n2.2.\nOS Support Policy\nï\nSupport for the different operating systems will be until the standard EOSS/EOL date as defined for each operating system. Please refer to the support lifecycle for these operating systems to know their support timelines and plan to move to newer releases accordingly.\nCUDA supports the latest Fedora release version. The version supported might require a specific GCC compatibility package. For Fedora release timelines, visit\nhttps://docs.fedoraproject.org/en-US/releases/\n.\nCUDA supports a single KylinOS release version. For details, visit\nhttps://www.kylinos.cn/\n.\nRefer to the support lifecycle for these supported OSes to know their support timelines and plan to move to newer releases accordingly.\n2.3.\nHost Compiler Support Policy\nï\nIn order to compile the CPU âHostâ code in the CUDA source, the CUDA compiler NVCC requires a compatible host compiler to be installed on the system. The version of the host compiler supported on Linux platforms is tabulated as below. NVCC performs a version check on the host compilerâs major version and so newer minor versions of the compilers listed below will be supported, but major versions falling outside the range will not be supported.\nTable 2\nSupported Compilers\nï\nDistribution\nGCC\nClang\nNVHPC\nXLC\nArmC/C++\nx86_64\n6.x â 15.x\n7.x â 20.x\n24.9â25.5\nNo\nNo\nArm64 sbsa\n6.x â 15.x\n7.x â 20.x\n24.9â25.5\nNo\n24.04â24.10\nFor GCC and Clang, the preceding table indicates the minimum version and the latest version supported. If you are on a Linux distribution that may use an older version of GCC toolchain as default than what is listed above, it is recommended to upgrade to a newer toolchain CUDA 11.0 or later toolkit. Newer GCC toolchains are available with the Red Hat Developer Toolset for example. For platforms that ship a compiler version older than GCC 6 by default, linking to static or dynamic libraries that are shipped with the CUDA Toolkit is not supported. We only support libstdc++ (GCCâs implementation) for all the supported host compilers for the platforms listed above.\n2.3.1.\nHost Compiler Compatibility Packages\nï\nReally up to date distributions might ship with a newer compiler than what is covered by the Supported Compilers table above. Usually, those distribution also provide a GCC compatibility package that can be used instead of the default one.\nDepending on the distribution, the package that needs to be installed is different, but the logic for configuring it is the same. If required, configuration steps are described in the relevant section for the specific Linux distribution, but they always end up with configuring the\nNVCC_BIN\nenvironment variable as described in the\nNVCC documentation\n.\n2.3.2.\nSupported C++ Dialects\nï\nNVCC and NVRTC (CUDA Runtime Compiler) support the following C++ dialect: C++11, C++14, C++17, C++20 on supported host compilers. The default C++ dialect of NVCC  is determined by the default dialect of the host compiler used for compilation. Refer to host compiler documentation and the\nCUDA Programming Guide\nfor more details on language support.\nC++20 is supported with the following flavors of host compiler in both host and device code.\nGCC\nClang\nNVHPC\nArm C/C++\n>=10.x\n>=11.x\n>=22.x\n>=22.x\n2.4.\nAbout This Document\nï\nThis document is intended for readers familiar with the Linux environment and the compilation of C programs from the command line. You do not need previous experience with CUDA or experience with parallel computation.\n2.4.1.\nAdministrative Privileges\nï\nCommands which can be executed as a normal user will be prefixed by a\n$\nat the beginning of the line\nCommands which require administrative privilege (\nroot\n) will be prefixed by a\n#\nat the beginning of the line\nMany commands in this document might require\nsuperuser\nprivileges. On most distributions of Linux, this will require you to log in as\nroot\n. For systems that have enabled the\nsudo\npackage, use the\nsudo\nprefix or a\nsudo\nshell (\nsudo\n-i\n) for all the necessary commands.\n3.\nPre-installation Actions\nï\nSome actions must be taken before the CUDA Toolkit can be installed on Linux:\nVerify the system has a CUDA-capable GPU.\nVerify the system is running a supported version of Linux.\nVerify the system has\ngcc\ninstalled.\nDownload the NVIDIA CUDA Toolkit.\nHandle conflicting installation methods.\nNote\nYou can override the install-time prerequisite checks by running the installer with the\n-override\nflag. Remember that the prerequisites will still be required to use the NVIDIA CUDA Toolkit.\n3.1.\nVerify You Have a CUDA-Capable GPU\nï\nTo verify that your GPU is CUDA-capable, go to your distributionâs equivalent of System Properties, or, from the command line, enter:\n$ lspci | grep -i nvidia\nIf you do not see any settings, update the PCI hardware database that Linux maintains by entering\nupdate-pciids\n(generally found in\n/sbin\n) at the command line and rerun the previous\nlspci\ncommand.\nIf your graphics card is from NVIDIA and it is listed in\nhttps://developer.nvidia.com/cuda-gpus\n, your GPU is CUDA-capable. The Release Notes for the CUDA Toolkit also contain a list of supported products.\n3.2.\nVerify You Have a Supported Version of Linux\nï\nThe CUDA Development Tools are only supported on some specific distributions of Linux. These are listed in the CUDA Toolkit release notes.\nTo determine which distribution and release number youâre running, type the following at the command line:\n$ hostnamectl\n3.3.\nVerify the System Has gcc Installed\nï\nThe\ngcc\ncompiler is required for development using the CUDA Toolkit. It is not required for running CUDA applications. It is generally installed as part of the Linux installation, and in most cases the version of gcc installed with a supported version of Linux will work correctly.\nTo verify the version of gcc installed on your system, type the following on the command line:\ngcc --version\nIf an error message displays, you need to install the development tools from your Linux distribution or obtain a version of\ngcc\nand its accompanying toolchain from the Web.\n3.4.\nChoose an Installation Method\nï\nThe CUDA Toolkit can be installed using either of two different installation mechanisms: distribution-specific packages (RPM and Deb packages), or a distribution-independent package (runfile packages).\nThe distribution-independent package has the advantage of working across a wider set of Linux distributions, but does not update the distributionâs native package management system. The distribution-specific packages interface with the distributionâs native package management system. It is recommended to use the distribution-specific packages, where possible.\nNote\nFor both native as well as cross development, the toolkit must be installed using the distribution-specific installer. See the\nCUDA Cross-Platform Installation\nsection for more details.\n3.5.\nDownload the NVIDIA CUDA Toolkit\nï\nThe NVIDIA CUDA Toolkit is available at\nhttps://developer.nvidia.com/cuda-downloads\n.\nChoose the platform you are using and download the NVIDIA CUDA Toolkit. The CUDA Toolkit contains the tools needed to create, build and run a CUDA application as well as libraries, header files, and other resources.\nDownload Verification\nIf you are using the local stand alone or run file installer, the download can be verified by comparing the MD5 checksum posted at\nhttps://developer.download.nvidia.com/compute/cuda/13.0.0/docs/sidebar/md5sum.txt\nwith that of the downloaded file. If either of the checksums differ, the downloaded file is corrupt and needs to be downloaded again.\nTo calculate the MD5 checksum of the downloaded file, run the following:\nmd5sum <file>\n3.6.\nHandle Conflicting Installation Methods\nï\nBefore installing CUDA, any previous installations that could conflict should be uninstalled. This will not affect systems which have not had CUDA installed previously, or systems where the installation method has been preserved (RPM/Deb vs. Runfile). See the following charts for specifics.\nTable 3\nCUDA Toolkit Installation Compatibility Matrix\nï\nInstalled Toolkit Version == X.Y\nInstalled Toolkit Version != X.Y\nRPM/deb\nrun\nRPM/deb\nrun\nInstalling Toolkit Version X.Y\nRPM/deb\nNo Action\nUninstall Run\nNo Action\nNo Action\nrun\nUninstall RPM/deb\nUninstall Run\nNo Action\nNo Action\nUse the following command to uninstall a Toolkit runfile installation:\n# /usr/local/cuda-X.Y/bin/cuda-uninstaller\nUse the following commands to uninstall an RPM/Deb installation:\nRed Hat Enterprise Linux, Rocky Linux, Oracle Linux, Fedora, KylinOS, Amazon Linux:\n# dnf remove <package_name>\nAzure Linux:\n# tdnf remove <package_name>\nOpenSUSE Leap, SUSE Linux Enterprise Server:\n# zypper remove <package_name>\nDebian / Ubuntu:\n# apt --purge remove <package_name>\n4.\nPackage Manager Installation\nï\nBasic instructions can be found in the\nQuick Start Guide\n. Read on for more detailed instructions.\n4.1.\nOverview\nï\nInstallation using RPM or Debian packages interfaces with your systemâs package management system. When using RPM or Debian local repo installers, the downloaded package contains a repository snapshot stored on the local filesystem in /var/. Such a package only informs the package manager where to find the actual installation packages, but will not install them.\nIf the online network repository is enabled, RPM or Debian packages will be automatically downloaded at installation time using the package manager: apt-get, dnf, tdnf, or zypper.\nDistribution-specific instructions detail how to install CUDA:\nRed Hat Enterprise Linux / Rocky Linux / Oracle Linux\nKylinOS\nFedora\nSUSE Linux Enterprise Server\nOpenSUSE Leap\nWindows Subsystem for Linux\nUbuntu\nDebian\nAmazon Linux\nAzure Linux\nFinally, some helpful\npackage manager capabilities\nare detailed.\nThese instructions are for native development only. For cross-platform development, see the\nCUDA Cross-Platform Environment\nsection.\nNote\nOptional components such as\nnvidia-fs\n,\nlibnvidia-nscq\n, and\nfabricmanager\nare not installed by default and will have to be installed separately as needed.\n4.2.\nRed Hat Enterprise Linux / Rocky Linux / Oracle Linux\nï\n4.2.1.\nPreparation\nï\nPerform the\nPre-installation Actions\n.\nSatisfy third-party package dependencies by enabling optional repositories:\nRed Hat Enterprise Linux 10:\n# subscription-manager repos --enable=rhel-10-for-<arch>-appstream-rpms\n# subscription-manager repos --enable=rhel-10-for-<arch>-baseos-rpms\n# subscription-manager repos --enable=codeready-builder-for-rhel-10-<arch>-rpms\nRed Hat Enterprise Linux 9:\n# subscription-manager repos --enable=rhel-9-for-<arch>-appstream-rpms\n# subscription-manager repos --enable=rhel-9-for-<arch>-baseos-rpms\n# subscription-manager repos --enable=codeready-builder-for-rhel-9-<arch>-rpms\nRed Hat Enterprise Linux 8:\n# subscription-manager repos --enable=rhel-8-for-<arch>-appstream-rpms\n# subscription-manager repos --enable=rhel-8-for-<arch>-baseos-rpms\n# subscription-manager repos --enable=codeready-builder-for-rhel-8-<arch>-rpms\nRocky Linux 9/10:\n# dnf config-manager --set-enabled crb\nRocky Linux 8:\n# dnf config-manager --set-enabled powertools\nOracle Linux 9:\n# dnf config-manager --set-enabled ol9_codeready_builder\nOracle Linux 8:\n# dnf config-manager --set-enabled ol8_codeready_builder\nChoose an installation method:\nLocal Repository Installation\nor\nNetwork Repository Installation\n.\n4.2.2.\nLocal Repository Installation\nï\nInstall local repository on file system:\n# rpm --install cuda-repo-<distro>-X-Y-local-<version>*.<arch>.rpm\n4.2.3.\nNetwork Repository Installation\nï\nEnable the network repository:\n# dnf config-manager --add-repo https://developer.download.nvidia.com/compute/cuda/repos/<distro>/<arch>/cuda-<distro>.repo\n4.2.4.\nCommon Instructions\nï\nNote\nInstall\nnvidia-gds\nonly after the NVIDIA driver and the CUDA Toolkit are fully installed.\nThe\nnvidia-fs\nkernel module is built against the current driver, and installing out of order\ncan cause application hangs.\nThese instructions apply to both local and network installations.\nInstall CUDA SDK:\n# dnf install cuda-toolkit\nInstall GPUDirect Filesystem:\n# dnf install nvidia-gds\nReboot the system:\n# reboot\nPerform the\npost-installation actions\n.\n4.3.\nKylinOS\nï\n4.3.1.\nPreparation\nï\nPerform the\npre-installation actions\n.\nChoose an installation method:\nLocal Repository Installation\nor\nNetwork Repository Installation\n.\n4.3.2.\nLocal Repository Installation\nï\nInstall local repository on file system:\n# rpm --install cuda-repo-<distro>-X-Y-local-<version>*.<arch>.rpm\n4.3.3.\nNetwork Repository Installation\nï\nEnable the network repository:\n# dnf config-manager --add-repo https://developer.download.nvidia.com/compute/cuda/repos/<distro>/<arch>/cuda-<distro>.repo\n4.3.4.\nCommon Instructions\nï\nNote\nInstall\nnvidia-gds\nonly after the NVIDIA driver and the CUDA Toolkit are fully installed.\nThe\nnvidia-fs\nkernel module is built against the current driver, and installing out of order\ncan cause application hangs.\nThese instructions apply to both local and network installation.\nInstall CUDA SDK:\n# dnf install cuda-toolkit\nInstall GPUDirect Filesystem:\n# dnf install nvidia-gds\nReboot the system:\n# reboot\nPerform the\npost-installation actions\n.\n4.4.\nFedora\nï\n4.4.1.\nPreparation\nï\nPerform the\npre-installation actions\n.\nChoose an installation method:\nLocal Repository Installation\nor\nNetwork Repository Installation\n.\n4.4.2.\nLocal Repository Installation\nï\nInstall local repository on file system:\n# rpm --install cuda-repo-<distro>-X-Y-local-<version>*.x86_64.rpm\n4.4.3.\nNetwork Repository Installation\nï\nEnable the network repository:\n# dnf config-manager addrepo --from-repofile=https://developer.download.nvidia.com/compute/cuda/repos/<distro>/x86_64/cuda-<distro>.repo\n4.4.4.\nCommon Installation Instructions\nï\nNote\nInstall\nnvidia-gds\nonly after the NVIDIA driver and the CUDA Toolkit are fully installed.\nThe\nnvidia-fs\nkernel module is built against the current driver, and installing out of order\ncan cause application hangs.\nThese instructions apply to both local and network installation for Fedora.\nInstall CUDA SDK:\n# dnf install cuda-toolkit\nReboot the system:\n# reboot\nPerform the\nPost-installation Actions\n.\n4.4.5.\nGCC Compatibility Package for Fedora\nï\nThe Fedora version supported might ship with a newer compiler than what is actually supported by NVCC. This can be overcome by installing the GCC compatibility package and setting a few environment variables.\nAs an example, besides the default GCC 15, itâs also possible to install GCC 14 or 13, which can be used for NVCC. To install and configure the local NVCC binary to use a custom version, proceed as follows. The following instructions use GCC 13 as an example, replace with the appropriate version:\nInstall the packages required:\n# dnf install gcc13-c++\nThe binaries then appear on the system in the following way:\n/usr/bin/gcc-13\n/usr/bin/g++-13\nOverride the default\ng++\ncompiler. Refer to the\ndocumentation for NVCC regarding the environment variables\n. For example:\n$ export NVCC_CCBIN='g++-13'\n4.5.\nSUSE Linux Enterprise Server\nï\n4.5.1.\nPreparation\nï\nPerform the\nPre-installation Actions\n.\nChoose an installation method:\nLocal Repository Installation\nor\nNetwork Repository Installation\n.\n4.5.2.\nLocal Repository Installation\nï\nInstall local repository on file system:\n# rpm --install cuda-repo-<distro>-X-Y-local-<version>*.<arch>.rpm\n4.5.3.\nNetwork Repository Installation\nï\nEnable the network repository:\n# zypper addrepo https://developer.download.nvidia.com/compute/cuda/repos/<distro>/<arch>/cuda-<distro>.repo\nRefresh Zypper repository cache:\n# SUSEConnect --product PackageHub/<SLES version number>/<arch>\n# zypper refresh\n4.5.4.\nCommon Installation Instructions\nï\nThese instructions apply to both local and network installation for SUSE Linux Enterprise Server.\nInstall CUDA SDK:\n# zypper install cuda-toolkit\nReboot the system:\n# reboot\nPerform the\nPost-installation Actions\n.\n4.6.\nOpenSUSE Leap\nï\n4.6.1.\nPreparation\nï\nPerform the\nPre-installation Actions\n.\nChoose an installation method:\nLocal Repository Installation\nor\nNetwork Repository Installation\n.\n4.6.2.\nLocal Repository Installation\nï\nInstall local repository on file system:\n# rpm --install cuda-repo-<distro>-X-Y-local-<version>*.x86_64.rpm\n4.6.3.\nNetwork Repository Installation\nï\nEnable the network repository:\n# zypper addrepo https://developer.download.nvidia.com/compute/cuda/repos/<distro>/x86_64/cuda-<distro>.repo\nRefresh Zypper repository cache:\n# zypper refresh\n4.6.4.\nCommon Installation Instructions\nï\nThese instructions apply to both local and network installation for OpenSUSE Leap.\nInstall CUDA SDK:\n# zypper install cuda-toolkit\nReboot the system:\n# reboot\nPerform the\nPost-installation Actions\n.\n4.7.\nWindows Subsystem for Linux\nï\nThese instructions must be used if you are installing in a WSL environment.\n4.7.1.\nPreparation\nï\nPerform the\nPre-installation Actions\n.\nChoose an installation method:\nLocal Repository Installation\nor\nNetwork Repository Installation\n.\n4.7.2.\nLocal Repository Installation\nï\nInstall local repository on file system:\n# dpkg -i cuda-repo-<distro>-X-Y-local_<version>*_amd64.deb\nEnroll ephemeral public GPG key:\n# cp /var/cuda-repo-<distro>-X-Y-local/cuda-*-keyring.gpg /usr/share/keyrings/\nAdd pin file to prioritize CUDA repository:\n$ wget https://developer.download.nvidia.com/compute/cuda/repos/<distro>/x86_64/cuda-<distro>.pin\n# mv cuda-<distro>.pin /etc/apt/preferences.d/cuda-repository-pin-600\n4.7.3.\nNetwork Repository Installation\nï\nInstall the\ncuda-keyring\npackage:\n$ wget https://developer.download.nvidia.com/compute/cuda/repos/<distro>/x86_64/cuda-keyring_1.1-1_all.deb\n# dpkg -i cuda-keyring_1.1-1_all.deb\n4.7.4.\nCommon Installation Instructions\nï\nThese instructions apply to both local and network installation for WSL.\nUpdate the Apt repository cache:\n# apt update\nInstall CUDA SDK:\n# apt install cuda-toolkit\nPerform the\nPost-installation Actions\n.\n4.8.\nUbuntu\nï\n4.8.1.\nPrepare Ubuntu\nï\nPerform the\nPre-installation Actions\n.\nChoose an installation method:\nLocal Repository Installation\nor\nNetwork Repository Installation\n.\n4.8.2.\nLocal Repository Installation\nï\nInstall local repository on file system:\n# dpkg -i cuda-repo-<distro>-X-Y-local_<version>*_<arch>.deb\nEnroll ephemeral public GPG key:\n# cp /var/cuda-repo-<distro>-X-Y-local/cuda-*-keyring.gpg /usr/share/keyrings/\nAdd pin file to prioritize CUDA repository:\n$ wget https://developer.download.nvidia.com/compute/cuda/repos/<distro>/<arch>/cuda-<distro>.pin\n# mv cuda-<distro>.pin /etc/apt/preferences.d/cuda-repository-pin-600\n4.8.3.\nNetwork Repository Installation\nï\nInstall the\ncuda-keyring\npackage:\n$ wget https://developer.download.nvidia.com/compute/cuda/repos/<distro>/<arch>/cuda-keyring_1.1-1_all.deb\n# sudo dpkg -i cuda-keyring_1.1-1_all.deb\n# dpkg -i cuda-keyring_1.1-1_all.deb\n4.8.4.\nCommon Installation Instructions\nï\nNote\nInstall\nnvidia-gds\nonly after the NVIDIA driver and the CUDA Toolkit are fully installed.\nThe\nnvidia-fs\nkernel module is built against the current driver, and installing out of order\ncan cause application hangs.\nThese instructions apply to both local and network installation for Ubuntu.\nUpdate the APT repository cache:\n# apt update\nInstall CUDA SDK:\nNote\nThese two commands must be executed separately.\n# apt install cuda-toolkit\nTo include all GDS packages:\n# apt install nvidia-gds\nFor native\narm64-jetson\nrepositories, install the additional packages:\n# apt install cuda-compat\nReboot the system:\n# reboot\nPerform the\nPost-installation Actions\n.\n4.9.\nDebian\nï\n4.9.1.\nPreparation\nï\nPerform the\nPre-installation Actions\n.\nEnable the\ncontrib\nrepository:\n# add-apt-repository contrib\nChoose an installation method:\nLocal Repository Installation\nor\nNetwork Repository Installation\n.\n4.9.2.\nLocal Repository Installation\nï\nInstall local repository on file system:\n# dpkg -i cuda-repo-<distro>-X-Y-local_<version>*_amd64.deb\nEnroll public GPG key:\n# cp /var/cuda-repo-<distro>-X-Y-local/cuda-*-keyring.gpg /usr/share/keyrings/\n4.9.3.\nNetwork Repository Installation\nï\nInstall the\ncuda-keyring\npackage:\n$ wget https://developer.download.nvidia.com/compute/cuda/repos/<distro>/<arch>/cuda-keyring_1.1-1_all.deb\n# dpkg -i cuda-keyring_1.1-1_all.deb\n4.9.4.\nCommon Installation Instructions\nï\nThese instructions apply to both local and network installation for Debian.\nUpdate the APT repository cache:\n# apt update\nInstall CUDA SDK:\n# apt install cuda-toolkit\nReboot the system:\n# reboot\nPerform the\nPost-installation Actions\n.\n4.10.\nAmazon Linux\nï\n4.10.1.\nPrepare Amazon Linux\nï\nPerform the\nPre-installation Actions\n.\nChoose an installation method:\nLocal Repository Installation\nor\nNetwork Repository Installation\n.\n4.10.2.\nLocal Repository Installation\nï\nInstall local repository on file system:\n# rpm --install cuda-repo-<distro>-X-Y-local-<version>*.x86_64.rpm\n4.10.3.\nNetwork Repository Installation\nï\nEnable the network repository:\n# dnf config-manager --add-repo https://developer.download.nvidia.com/compute/cuda/repos/<distro>/x86_64/cuda-<distro>.repo\n4.10.4.\nCommon Installation Instructions\nï\nNote\nInstall\nnvidia-gds\nonly after the NVIDIA driver and the CUDA Toolkit are fully installed.\nThe\nnvidia-fs\nkernel module is built against the current driver, and installing out of order\ncan cause application hangs.\nThese instructions apply to both local and network installation for Amazon Linux.\nInstall CUDA SDK:\n# dnf install cuda-toolkit\nInstall GPUDirect Filesystem:\n# dnf install nvidia-gds\nReboot the system:\n# reboot\nPerform the\npost-installation actions\n.\n4.11.\nAzure Linux\nï\n4.11.1.\nPrepare Azure Linux\nï\nPerform the\nPre-installation Actions\n.\nChoose an installation method:\nLocal Repository Installation\nor\nNetwork Repository Installation\n.\n4.11.2.\nLocal Repository Installation\nï\nInstall local repository on file system:\n# rpm --install cuda-repo-<distro>-X-Y-local-<version>*.x86_64.rpm\n4.11.3.\nNetwork Repository Installation\nï\nEnable the network repository:\n# curl https://developer.download.nvidia.com/compute/cuda/repos/<distro>/x86_64/cuda-<distro>.repo -o /etc/yum.repos.d/cuda-<distro>.repo\n4.11.4.\nCommon Installation Instructions\nï\nThese instructions apply to both local and network installation for Azure Linux.\nNote\nInstall\nnvidia-gds\nonly after the NVIDIA driver and the CUDA Toolkit are fully installed.\nThe\nnvidia-fs\nkernel module is built against the current driver, and installing out of order\ncan cause application hangs.\nEnable the extended repository:\nAzure Linux 2 (CBL Mariner 2.0):\n# tdnf install mariner-repos-extended\nAzure Linux 3:\n# tdnf install azurelinux-repos-extended\nInstall Cuda SDK:\n# tdnf install cuda-toolkit\nInstall GPUDirect Filesystem:\n# tdnf install nvidia-gds\nReboot the system:\n# reboot\nPerform the\npost-installation-actions\n.\n4.12.\nAdditional Package Manager Capabilities\nï\nBelow are some additional capabilities of the package manager that users can take advantage of.\n4.12.1.\nAvailable Packages\nï\nThe recommended installation package is the\ncuda-toolkit\npackage. This package will install the full set of other CUDA packages required for native development and should cover most scenarios. This includes the compiler, the debugger, the profiler, the math libraries, and so on. For x86_64 platforms, this also includes Nsight Eclipse Edition and the visual profilers.\nOn supported platforms, the\ncuda-cross-aarch64\nand\ncuda-cross-sbsa\npackages install all the packages required for cross-platform development to\narm64-jetson\nand SBSA, respectively.\nNote\n32-bit compilation native and cross-compilation is removed from CUDA 12.0 and later Toolkit. Use the CUDA Toolkit from earlier releases for 32-bit compilation. Hopper does not support 32-bit applications.\nThe packages installed by the packages above can also be installed individually by specifying their names explicitly. The list of available packages be can obtained with:\nAmazon Linux / Fedora / KylinOS / Red Hat Enterprise Linux / Rocky Linux / Oracle Linux:\n# dnf --disablerepo=\"*\" --enablerepo=\"cuda*\" list\nAzure Linux:\n# tdnf --disablerepo=\"*\" --enablerepo=\"cuda-cm2-<cuda X-Y version>-local\" list\nSUSE Linux Enterprise Server / openSUSE Leap:\n# zypper packages -r cuda\nDebian / Ubuntu:\n# cat /var/lib/apt/lists/*cuda*Packages | grep \"Package:\"\n4.12.2.\nMeta Packages\nï\nMeta packages are RPM/Deb/Conda packages which contain no (or few) files but have multiple dependencies. They are used to install many CUDA packages when you may not know the details of the packages you want. The following table lists the meta packages.\nTable 4\nMeta Packages Available for CUDA 13.0\nï\nMeta Package\nPurpose\ncuda\nInstalls all CUDA Toolkit\nand\ndriver packages with a full desktop experience. Installs also the next version of the\ncuda\npackage when itâs released.\ncuda-13.0\nInstalls all CUDA Toolkit\nand\ndriver packages at the version specified until an additional version of CUDA is installed.\ncuda-toolkit\nInstalls all CUDA Toolkit packages with a full desktop experience. Installs also the next version of the\ncuda-toolkit\npackage when itâs released.\ncuda-toolkit-13\nInstalls all CUDA Toolkit packages with a full desktop experience. Will not upgrade beyond the 13.x series toolkits.\ncuda-toolkit-13\nInstalls all CUDA Toolkit packages with a full desktop experienc at the version specified until an additional version of CUDA is installed.\ncuda-tools-13.0\nInstalls all CUDA command line and visual tools. Will not upgrade beyond the 13.x series toolkits.\ncuda-runtime-13.0\nInstalls all CUDA Toolkit packages required to run CUDA applications\nand\ndriver, without any desktop component. Specific for compute nodes\ncuda-compiler-13.0\nInstalls all CUDA compiler packages.\ncuda-libraries-13.0\nInstalls all runtime CUDA Library packages.\ncuda-libraries-dev-13.0\nInstalls all development CUDA Library packages.\n4.12.3.\nPackage Upgrades\nï\nThe\ncuda\npackage points to the latest stable release of the CUDA Toolkit. When a new version is available, use the following commands to upgrade the toolkit:\n4.12.3.1.\nAmazon Linux\nï\n# dnf install cuda-toolkit\n4.12.3.2.\nFedora\nï\nWhen upgrading the toolkit to a new\nmajor\nbranch:\n# dnf install cuda-toolkit\nWhen upgrading the toolkit to a new\nminor\nbranch:\n# dnf upgrade cuda-toolkit\n4.12.3.3.\nKylinOS / Red Hat Enterprise Linux / Rocky Linux / Oracle Linux\nï\n# dnf install cuda-toolkit\n4.12.3.4.\nAzure Linux\nï\n# tdnf install cuda-toolkit\n4.12.3.5.\nOpenSUSE / SUSE Linux Enterprise Server\nï\n# zypper install cuda-toolkit\n4.12.3.6.\nDebian / Ubuntu\nï\n# apt install cuda-toolkit\n4.12.3.7.\nOther Package Notes\nï\nThe\ncuda-cross-aarch64\n,\ncuda-cross-sbsa\nand\ncuda-cross-qnx\npackages can also be upgraded in the same manner.\nTo avoid any automatic upgrade, and lock down the toolkit installation to the X.Y release, install the\ncuda-toolkit-X-Y\nor\ncuda-cross-<arch>-X-Y\npackage.\nSide-by-side installations are supported. As described in the\nMeta Packages\nsection, depending on the package you can avoid the upgrades or get the new version installed automatically.\n5.\nDriver Installation\nï\nMore information about driver installation can be found in the\nDriver Installation Guide for Linux\n6.\nRunfile Installation\nï\nBasic instructions can be found in the\nQuick Start Guide\n. Read on for more detailed instructions.\nThis section describes the installation and configuration of CUDA when using the standalone installer. The standalone installer is a\n.run\nfile and is completely self-contained.\n6.1.\nRunfile Overview\nï\nThe Runfile installation installs the CUDA Toolkit via an interactive ncurses-based interface.\nThe\ninstallation steps\nare listed below.\nFinally,\nadvanced options\nfor the installer and\nuninstallation steps\nare detailed below.\nThe Runfile installation does not include support for cross-platform development. For cross-platform development, see the\nCUDA Cross-Platform Environment\nsection.\n6.2.\nInstallation\nï\nPerform the\npre-installation actions\n.\nReboot into text mode (runlevel 3).\nThis can usually be accomplished by adding the number â3â to the end of the systemâs kernel boot parameters.\nSince the NVIDIA drivers are not yet installed, the text terminals may not display correctly. Temporarily adding ânomodesetâ to the systemâs kernel boot parameters may fix this issue.\nConsult your systemâs bootloader documentation for information on how to make the above boot parameter changes.\nRun the installer and follow the on-screen prompts:\n# sh cuda_<version>_linux.run\nThe installer will prompt for the following:\nEULA Acceptance\nCUDA Toolkit installation, location, and\n/usr/local/cuda\nsymbolic link\nThe default installation location for the toolkit is\n/usr/local/cuda-13.0\n:\nThe\n/usr/local/cuda\nsymbolic link points to the location where the CUDA Toolkit was installed. This link allows projects to use the latest CUDA Toolkit without any configuration file update.\nThe installer must be executed with sufficient privileges to perform some actions. When the current privileges are insufficient to perform an action, the installer will ask for the userâs password to attempt to install with root privileges. Actions that cause the installer to attempt to install with root privileges are:\ninstalling the CUDA Toolkit to a location the user does not have permission to write to\ncreating the\n/usr/local/cuda\nsymbolic link\nRunning the installer with\nsudo\n, as shown above, will give permission to install to directories that require root permissions. Directories and files created while running the installer with\nsudo\nwill have root ownership.\nReboot the system to reload the graphical interface:\n# reboot\nPerform the\npost-installation actions\n.\n6.3.\nAdvanced Options\nï\nAction\nOptions Used\nExplanation\nSilent Installation\n--silent\nRequired for any silent installation. Performs an installation with no further user-input and minimal command-line output based on the options provided below. Silent installations are useful for scripting the installation of CUDA. Using this option implies acceptance of the EULA. The following flags can be used to customize the actions taken during installation. At least one of\n--driver\n,\n--uninstall\n, and\n--toolkit\nmust be passed if running with non-root permissions.\n--driver\nInstall the CUDA Driver.\n--toolkit\nInstall the CUDA Toolkit.\n--toolkitpath=<path>\nInstall the CUDA Toolkit to the <path> directory. If not provided, the default path of\n/usr/local/cuda-13.0\nis used.\n--defaultroot=<path>\nInstall libraries to the <path> directory. If the <path> is not provided, then the default path of your distribution is used.\nThis only applies to the libraries installed outside of the CUDA Toolkit path.\nExtraction\n--extract=<path>\nExtracts to the <path> the following: the driver runfile, the raw files of the toolkit to <path>.\nThis is especially useful when one wants to install the driver using one or more of the command-line options provided by the driver installer which are not exposed in this installer.\nOverriding Installation Checks\n--override\nIgnores compiler, third-party library, and toolkit detection checks which would prevent the CUDA Toolkit from installing.\nNo OpenGL Libraries\n--no-opengl-libs\nPrevents the driver installation from installing NVIDIAâs GL libraries. Useful for systems where the display is driven by a non-NVIDIA GPU. In such systems, NVIDIAâs GL libraries could prevent X from loading properly.\nNo man pages\n--no-man-page\nDo not install the man pages under\n/usr/share/man\n.\nOverriding Kernel Source\n--kernel-source-path=<path>\nTells the driver installation to use <path> as the kernel source directory when building the NVIDIA kernel module. Required for systems where the kernel source is installed to a non-standard location.\nRunning nvidia-xconfig\n--run-nvidia-xconfig\nTells the driver installation to run nvidia-xconfig to update the system X configuration file so that the NVIDIA X driver is used. The pre-existing X configuration file will be backed up.\nNo nvidia-drm kernel module\n--no-drm\nDo not install the nvidia-drm kernel module. This option should only be used to work around failures to build or install the nvidia-drm kernel module on systems that do not need the provided features.\nCustom Temporary Directory Selection\n--tmpdir=<path>\nPerforms any temporary actions within <path> instead of\n/tmp\n. Useful in cases where\n/tmp\ncannot be used (doesnât exist, is full, is mounted with ânoexecâ, etc.).\nKernel Module Build Directory\n--kernel-module-build-directory=<kernel|kernel-open>\nTells the driver installation to use legacy or open flavor of kernel source when building the NVIDIA kernel module. The kernel-open flavor is only supported on Turing GPUs and newer.\n-m=kernel\nTells the driver installation to use legacy flavor of kernel source when building the NVIDIA kernel module. Shorthand for\n--kernel-module-build-directory=kernel\nm=kernel-open\nTells the driver installation to use open flavor of kernel source when building the NVIDIA kernel module. The kernel-open flavor is only supported on Turing GPUs and newer. Shorthand for\n--kernel-module-build-directory=kernel-open\nShow Installer Options\n--help\nPrints the list of command-line options to stdout.\n6.4.\nUninstallation\nï\nTo uninstall the CUDA Toolkit, run the uninstallation script provided in the bin directory of the toolkit. By default, it is located in\n/usr/local/cuda-13.0/bin\n:\n# /usr/local/cuda-13.0/bin/cuda-uninstaller\n7.\nConda Installation\nï\nThis section describes the installation and configuration of CUDA when using the Conda installer. The Conda packages are available at\nhttps://anaconda.org/nvidia\n.\n7.1.\nConda Overview\nï\nThe Conda installation installs the CUDA Toolkit. The installation steps are listed below.\n7.2.\nInstalling CUDA Using Conda\nï\nTo perform a basic install of all CUDA Toolkit components using Conda, run the following command:\n$ conda install cuda -c nvidia\nNote\nInstall CUDA in a dedicated Conda environment instead of the base environment to avoid installation issues.\n7.3.\nUninstalling CUDA Using Conda\nï\nTo uninstall the CUDA Toolkit using Conda, run the following command:\n$ conda remove cuda\n7.4.\nInstalling Previous CUDA Releases\nï\nAll Conda packages released under a specific CUDA version are labeled with that release version. To install a previous version, include that label in the\ninstall\ncommand such as:\n$ conda install cuda -c nvidia/label/cuda-12.4.0\n7.5.\nUpgrading from cudatoolkit Package\nï\nIf you had previously installed CUDA using the\ncudatoolkit\npackage and want to maintain a similar install footprint, you can limit your installation to the following packages:\ncuda-libraries-dev\ncuda-nvcc\ncuda-nvtx\ncuda-cupti\nNote\nSome extra files, such as headers, will be included in this installation which were not included in the\ncudatoolkit\npackage. If you need to reduce your installation further, replace\ncuda-libraries-dev\nwith the specific libraries you need.\n8.\nPip Wheels\nï\nNVIDIA provides Python Wheels for installing CUDA through pip, primarily for using CUDA with Python. These packages are intended for runtime use and do not currently include developer tools (these can be installed separately).\nPlease note that with this installation method, CUDA installation environment is managed via pip and additional care must be taken to set up your host environment to use CUDA outside the pip environment.\n8.1.\nPrerequisites\nï\nTo install Wheels, you must first install the\nnvidia-pyindex\npackage, which is required in order to set up your pip installation to fetch additional Python modules from the NVIDIA NGC PyPI repo. If your pip and setuptools Python modules are not up-to-date, then use the following command to upgrade these Python modules. If these Python modules are out-of-date then the commands which follow later in this section may fail.\n$ python3 -m pip install --upgrade setuptools pip wheel\nYou should now be able to install the\nnvidia-pyindex\nmodule.\n$ python3 -m pip install nvidia-pyindex\nIf your project is using a\nrequirements.txt\nfile, then you can add the following line to your\nrequirements.txt\nfile as an alternative to installing the\nnvidia-pyindex\npackage:\n--extra-index-url https://pypi.org/simple\n8.2.\nProcedure\nï\nInstall the CUDA runtime package:\n$ python3 -m pip install nvidia-cuda-runtime-cu12\nOptionally, install additional packages as listed below using the following command:\n$ python3 -m pip install nvidia-<library>\n8.3.\nMetapackages\nï\nThe following metapackages will install the latest version of the named component on Linux for the indicated CUDA version. âcu12â should be read as âcuda12â.\nnvidia-cublas-cu12\nnvidia-cuda-cccl-cu12\nnvidia-cuda-cupti-cu12\nnvidia-cuda-nvcc-cu12\nnvidia-cuda-nvrtc-cu12\nnvidia-cuda-opencl-cu12\nnvidia-cuda-runtime-cu12\nnvidia-cuda-sanitizer-api-cu12\nnvidia-cufft-cu12\nnvidia-curand-cu12\nnvidia-cusolver-cu12\nnvidia-cusparse-cu12\nnvidia-npp-cu12\nnvidia-nvfatbin-cu12\nnvidia-nvjitlink-cu12\nnvidia-nvjpeg-cu12\nnvidia-nvml-dev-cu12\nnvidia-nvtx-cu12\nThese metapackages install the following packages:\nnvidia-cublas-cu129\nnvidia-cuda-cccl-cu129\nnvidia-cuda-cupti-cu129\nnvidia-cuda-nvcc-cu129\nnvidia-cuda-nvrtc-cu129\nnvidia-cuda-opencl-cu129\nnvidia-cuda-runtime-cu129\nnvidia-cuda-sanitizer-api-cu129\nnvidia-cufft-cu129\nnvidia-curand-cu129\nnvidia-cusolver-cu129\nnvidia-cusparse-cu129\nnvidia-npp-cu129\nnvidia-nvfatbin-cu129\nnvidia-nvjitlink-cu129\nnvidia-nvjpeg-cu129\nnvidia-nvml-dev-cu129\nnvidia-nvtx-cu129\n9.\nCUDA Cross-Platform Environment\nï\nCross development for\narm64-sbsa\nis supported on Ubuntu 20.04, Ubuntu 22.04, Ubuntu 24.04, KylinOS 10, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 9, and SUSE Linux Enterprise Server 15.\nCross development for\narm64-jetson\nis only supported on Ubuntu 22.04.\nWe recommend selecting a host development environment that matches the supported cross-target environment. This selection helps prevent possible host/target incompatibilities, such as\ngcc\nor\nglibc\nversion mismatches.\n9.1.\nCUDA Cross-Platform Installation\nï\nSome of the following steps may have already been performed as part of the\nnative installation sections\n. Such steps can safely be skipped.\nThese steps should be performed on the\nx86_64\nhost system, rather than the target system. To install the native CUDA Toolkit on the target system, refer to the native installation sections in\nPackage Manager Installation\n.\n9.1.1.\nUbuntu\nï\nPerform the\nPre-installation Actions\n.\nChoose an installation method:\nLocal Cross Repository Installation\nor\nNetwork Cross Repository Installation\n.\n9.1.1.1.\nLocal Cross Repository Installation\nï\nInstall repository meta-data package with:\n# dpkg -i cuda-repo-cross-<arch>-<distro>-X-Y-local-<version>*_all.deb\n9.1.1.2.\nNetwork Cross Repository Installation\nï\nInstall the\ncuda-keyring\npackage:\n$ wget https://developer.download.nvidia.com/compute/cuda/repos/<distro>/cross-linux-<arch>/cuda-keyring_1.1-1_all.deb\n# dpkg -i cuda-keyring_1.1-1_all.deb\n9.1.1.3.\nCommon Installation Instructions\nï\nUpdate the APT repository cache:\n# apt update\nInstall the appropriate cross-platform CUDA Toolkit:\nFor\narm64-sbsa\n:\n# apt install cuda-cross-sbsa\nFor\narm64-jetson\n:\n# apt install cuda-cross-aarch64\nFor QNX:\n# apt install cuda-cross-qnx\nPerform the\nPost-installation Actions\n.\n9.1.2.\nRed Hat Enterprise Linux / Rocky Linux / Oracle Linux\nï\nPerform the\nPre-installation Actions\nChoose an installation method:\nLocal Cross Repository Installation\nor\nNetwork Cross Repository Installation\n.\n9.1.2.1.\nLocal Cross Repository Installation\nï\nInstall repository meta-data package with:\n# rpm -i cuda-repo-cross-<arch>-<distro>-X-Y-local-<version>*.noarch.rpm\n9.1.2.2.\nNetwork Cross Repository Installation\nï\nEnable the network repository:\n# dnf config-manager --add-repo https://developer.download.nvidia.com/compute/cuda/repos/<distro>/cross-linux-<arch>/cuda-<distro>-cross-linux-sbsa.repo\n9.1.2.3.\nCommon Installation Instructions\nï\nInstall the CUDA SDK:\n# dnf install cuda-cross-sbsa\n9.1.3.\nSUSE Linux Enterprise Server\nï\nPerform the\nPre-installation Actions\nChoose an installation method:\nLocal Cross Repository Installation\nor\nNetwork Cross Repository Installation\n.\n9.1.3.1.\nLocal Cross Repository Installation\nï\nInstall repository meta-data package with:\n# rpm -i cuda-repo-cross-<arch>-<distro>-X-Y-local-<version>*.noarch.rpm\n9.1.3.2.\nNetwork Cross Repository Installation\nï\nEnable the network repo:\n# zypper addrepo https://developer.download.nvidia.com/compute/cuda/repos/<distro>/<arch>/cuda-<distro>-cross-linux-sbsa.repo\n9.1.3.3.\nCommon Installation Instructions\nï\nRefresh Zypper repository cache:\n# zypper refresh\nInstall CUDA SDK:\n# zypper install cuda-cross-sbsa\n10.\nTarball and Zip Archive Deliverables\nï\nIn an effort to meet the needs of a growing customer base requiring alternative installer packaging formats, as well as a means of input into community CI/CD systems, tarball and zip archives are available for each component.\nThese tarball and zip archives, known as binary archives, are provided at\nhttps://developer.download.nvidia.com/compute/cuda/redist/\n.\nThese component .tar.xz and .zip binary archives do not replace existing packages such as .deb, .rpm, runfile, conda, etc. and are not meant for general consumption, as they are not installers. However this standardized approach will replace existing .txz archives.\nFor each release, a JSON manifest is provided such as\nredistrib_11.4.2.json\n, which corresponds to the CUDA 11.4.2 release label (CUDA 11.4 update 2) which includes the release date, the name of each component, license name, relative URL for each platform and checksums.\nPackage maintainers are advised to check the provided LICENSE for each component prior to redistribution. Instructions for developers using CMake and Bazel build systems are provided in the next sections.\n10.1.\nParsing Redistrib JSON\nï\nThe following example of a JSON manifest contains keys for each component: name, license, version, and a platform array which includes relative_path, sha256, md5, and size (bytes) for each archive.\n{\n\"release_date\": \"2021-09-07\",\n\"cuda_cudart\": {\n\"name\": \"CUDA Runtime (cudart)\",\n\"license\": \"CUDA Toolkit\",\n\"version\": \"11.4.108\",\n\"linux-x86_64\": {\n\"relative_path\": \"cuda_cudart/linux-x86_64/cuda_cudart-linux-x86_64-11.4.108-archive.tar.xz\",\n\"sha256\": \"d08a1b731e5175aa3ae06a6d1c6b3059dd9ea13836d947018ea5e3ec2ca3d62b\",\n\"md5\": \"da198656b27a3559004c3b7f20e5d074\",\n\"size\": \"828300\"\n},\n\"linux-ppc64le\": {\n\"relative_path\": \"cuda_cudart/linux-ppc64le/cuda_cudart-linux-ppc64le-11.4.108-archive.tar.xz\",\n\"sha256\": \"831dffe062ae3ebda3d3c4010d0ee4e40a01fd5e6358098a87bb318ea7c79e0c\",\n\"md5\": \"ca73328e3f8e2bb5b1f2184c98c3a510\",\n\"size\": \"776840\"\n},\n\"linux-sbsa\": {\n\"relative_path\": \"cuda_cudart/linux-sbsa/cuda_cudart-linux-sbsa-11.4.108-archive.tar.xz\",\n\"sha256\": \"2ab9599bbaebdcf59add73d1f1a352ae619f8cb5ccec254093c98efd4c14553c\",\n\"md5\": \"aeb5c19661f06b6398741015ba368102\",\n\"size\": \"782372\"\n},\n\"windows-x86_64\": {\n\"relative_path\": \"cuda_cudart/windows-x86_64/cuda_cudart-windows-x86_64-11.4.108-archive.zip\",\n\"sha256\": \"b59756c27658d1ea87a17c06d064d1336576431cd64da5d1790d909e455d06d3\",\n\"md5\": \"7f6837a46b78198402429a3760ab28fc\",\n\"size\": \"2897751\"\n}\n}\n}\nA JSON schema is provided at\nhttps://developer.download.nvidia.com/compute/redist/redistrib-v2.schema.json\n.\nA sample script that parses these JSON manifests is available on\nGitHub\n:\nDownloads each archive\nValidates SHA256 checksums\nExtracts archives\nFlattens into a collapsed directory structure\nTable 5\nAvailable Tarball and Zip Archives\nï\nProduct\nExample\nCUDA Toolkit\n./parse_redist.py\n--product\ncuda\n--label\n13.0.0\ncuBLASMp\n./parse_redist.py\n--product\ncublasmp\n--label\n0.2.1\ncuDNN\n./parse_redist.py\n--product\ncudnn\n--label\n9.2.1\ncuDSS\n./parse_redist.py\n--product\ncudss\n--label\n0.3.0\ncuQuantum\n./parse_redist.py\n--product\ncuquantum\n--label\n24.03.0\ncuSPARSELt\n./parse_redist.py\n--product\ncusparselt\n--label\n0.6.2\ncuTENSOR\n./parse_redist.py\n--product\ncutensor\n--label\n2.0.2.1\nNVIDIA driver\n./parse_redist.py\n--product\nnvidia-driver\n--label\n550.90.07\nnvJPEG2000\n./parse_redist.py\n--product\nnvjpeg2000\n--label\n0.7.5\nNVPL\n./parse_redist.py\n--product\nnvpl\n--label\n24.7\nnvTIFF\n./parse_redist.py\n--product\nnvtiff\n--label\n0.3.0\n10.2.\nImporting Tarballs into CMake\nï\nThe recommended module for importing these tarballs into the CMake build system is via\nFindCUDAToolkit\n(3.17 and newer).\nNote\nThe FindCUDA module is deprecated.\nThe path to the extraction location can be specified with the\nCUDAToolkit_ROOT\nenvironmental variable. For example\nCMakeLists.txt\nand commands, see\ncmake/1_FindCUDAToolkit/\n.\nFor older versions of CMake, the\nExternalProject_Add\nmodule is an alternative method. For example\nCMakeLists.txt\nfile and commands, see\ncmake/2_ExternalProject/\n.\n10.3.\nImporting Tarballs into Bazel\nï\nThe recommended method of importing these tarballs into the Bazel build system is using\nhttp_archive\nand\npkg_tar\n.\nFor an example, see\nbazel/1_pkg_tar/\n.\n11.\nPost-installation Actions\nï\nThe post-installation actions must be manually performed. These actions are split into mandatory, recommended, and optional sections.\n11.1.\nMandatory Actions\nï\nSome actions must be taken after the installation before the CUDA Toolkit can be used.\n11.1.1.\nEnvironment Setup\nï\nThe\nPATH\nvariable needs to include\nexport\nPATH=/usr/local/cuda-13.0/bin${PATH:+:${PATH}}\n. Nsight Compute has moved to\n/opt/nvidia/nsight-compute/\nonly in rpm/deb installation method. When using\n.run\ninstaller it is still located under\n/usr/local/cuda-13.0/\n.\nTo add this path to the\nPATH\nvariable:\n$ export PATH=${PATH}:/usr/local/cuda-13.0/bin\nIn addition, when using the runfile installation method, the\nLD_LIBRARY_PATH\nvariable needs to contain\n/usr/local/cuda-13.0/lib64\non a 64-bit system and\n/usr/local/cuda-13.0/lib\nfor the 32 bit compatibility:\n$ export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:/usr/local/cuda-13.0/lib64\nNote that the above paths change when using a custom install path with the runfile installation method.\n11.2.\nRecommended Actions\nï\nOther actions are recommended to verify the integrity of the installation.\n11.2.1.\nInstall Writable Samples\nï\nCUDA Samples are now located in\nhttps://github.com/nvidia/cuda-samples\n, which includes instructions for obtaining, building, and running the samples.\n11.2.2.\nVerify the Installation\nï\nBefore continuing, it is important to verify that the CUDA toolkit can find and communicate correctly with the CUDA-capable hardware. To do this, you need to compile and run some of the sample programs, located in\nhttps://github.com/nvidia/cuda-samples\n.\nNote\nEnsure the PATH and, if using the runfile installation method,\nLD_LIBRARY_PATH\nvariables are\nset correctly\n.\n11.2.2.1.\nRunning the Binaries\nï\nAfter compilation, find and run\ndeviceQuery\nfrom\nhttps://github.com/nvidia/cuda-samples\n. If the CUDA software is installed and configured correctly, the output for\ndeviceQuery\nshould look similar to that shown in\nFigure 1\n.\nFigure 1\nValid Results from deviceQuery CUDA Sample\nï\nThe exact appearance and the output lines might be different on your system. The important outcomes are that a device was found (the first highlighted line), that the device matches the one on your system (the second highlighted line), and that the test passed (the final highlighted line).\nIf a CUDA-capable device is installed but\ndeviceQuery\nreports that no CUDA-capable devices are present, this likely means that the\n/dev/nvidia*\nfiles are missing or have the wrong permissions.\nOn systems where\nSELinux\nis enabled, you might need to temporarily disable this security feature to run\ndeviceQuery\n. To do this, type:\nsetenforce 0\nfrom the command line as the superuser.\nRunning the\nbandwidthTest\nprogram ensures that the system and the CUDA-capable device are able to communicate correctly. Its output is shown in\nFigure 2\n.\nFigure 2\nValid Results from bandwidthTest CUDA Sample\nï\nNote that the measurements for your CUDA-capable device description will vary from system to system. The important point is that you obtain measurements, and that the second-to-last line (in\nFigure 2\n) confirms that all necessary tests passed.\nShould the tests not pass, make sure you have a CUDA-capable NVIDIA GPU on your system and make sure it is properly installed.\nIf you run into difficulties with the link step (such as libraries not being found), consult the Linux Release Notes found in\nhttps://github.com/nvidia/cuda-samples\n.\n11.2.3.\nInstall Nsight Eclipse Plugins\nï\nTo install Nsight Eclipse plugins, an installation script is provided:\n$ /usr/local/cuda-13.0/bin/nsight_ee_plugins_manage.sh install <eclipse-dir>\nRefer to\nNsight Eclipse Plugins Installation Guide\nfor more details.\n11.2.4.\nLocal Repo Removal\nï\nRemoval of the local repo installer is recommended after installation of\nCUDA SDK\n.\nDebian / Ubuntu\n# apt-get remove --purge \"cuda-repo-<distro>-X-Y-local*\"\nAmazon Linux / Fedora / KylinOS / RHEL / Rocky Linux / Oracle Linux\n# dnf remove \"cuda-repo-<distro>-X-Y-local*\"\nAzure Linux\n# tdnf remove \"cuda-repo-<distro>-X-Y-local*\"\nOpenSUSE / SLES\n# zypper remove \"cuda-repo-<distro>-X-Y-local*\"\n11.3.\nOptional Actions\nï\nOther options are not necessary to use the CUDA Toolkit, but are available to provide additional features.\n11.3.1.\nInstall Third-party Libraries\nï\nSome CUDA samples use third-party libraries which may not be installed by default on your system. These samples attempt to detect any required libraries when building.\nIf a library is not detected, it waives itself and warns you which library is missing. To build and run these samples, you must install the missing libraries. In cases where these dependencies are not installed, follow the instructions below.\nAmazon Linux / Fedora / KylinOS / RHEL / Rocky Linux / Oracle Linux\n# dnf install freeglut-devel libX11-devel libXi-devel libXmu-devel make mesa-libGLU-devel freeimage-devel libglfw3-devel\nSLES\n# zypper install libglut3 libX11-devel libXi6 libXmu6 libGLU1 make\nOpenSUSE\n# zypper install freeglut-devel libX11-devel libXi-devel libXmu-devel make Mesa-libGL-devel freeimage-devel\nDebian / Ubuntu\n# apt-get install g++ freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libglu1-mesa-dev libfreeimage-dev libglfw3-dev\n11.3.2.\nInstall the Source Code for cuda-gdb\nï\nThe\ncuda-gdb\nsource must be explicitly selected for installation with the runfile installation method. During the installation, in the component selection page, expand the component âCUDA Tools 13.0â and select\ncuda-gdb-src\nfor installation. It is unchecked by default.\nTo obtain a copy of the source code for\ncuda-gdb\nusing the RPM and Debian installation methods, the\ncuda-gdb-src\npackage must be installed.\nThe source code is installed as a tarball in the\n/usr/local/cuda-13.0/extras\ndirectory.\n11.3.3.\nSelect the Active Version of CUDA\nï\nFor applications that rely on the symlinks\n/usr/local/cuda\nand\n/usr/local/cuda-MAJOR\n, you may wish to change to a different installed version of CUDA using the provided alternatives.\nTo show the active version of CUDA and all available versions:\n$ update-alternatives --display cuda\nTo show the active minor version of a given major CUDA release:\n$ update-alternatives --display cuda-12\nTo update the active version of CUDA:\n# update-alternatives --config cuda\n12.\nRemoving CUDA Toolkit\nï\nFollow the below steps to properly uninstall the CUDA Toolkit from your system. These steps will ensure that the uninstallation will be clean.\nAmazon Linux / Fedora / Kylin OS / Red Hat Enterprise Linux / Rocky Linux / Oracle Linux:\n# dnf remove \"cuda*\" \"*cublas*\" \"*cufft*\" \"*cufile*\" \"*curand*\" \"*cusolver*\" \"*cusparse*\" \"*gds-tools*\" \"*npp*\" \"*nvjpeg*\" \"nsight*\" \"*nvvm*\"\nAzure Linux:\n# tdnf remove \"cuda*\" \"*cublas*\" \"*cufft*\" \"*cufile*\" \"*curand*\" \"*cusolver*\" \"*cusparse*\" \"*gds-tools*\" \"*npp*\" \"*nvjpeg*\" \"nsight*\" \"*nvvm*\"\nAnd then to clean up the uninstall:\n# tdnf autoremove\nOpenSUSE / SUSE Linux Enterprise Server:\n# zypper remove \"cuda*\" \"*cublas*\" \"*cufft*\" \"*cufile*\" \"*curand*\" \"*cusolver*\" \"*cusparse*\" \"*gds-tools*\" \"*npp*\" \"*nvjpeg*\" \"nsight*\" \"*nvvm*\"\nDebian / Ubuntu:\n# apt remove --autoremove --purge \"*cuda*\" \"*cublas*\" \"*cufft*\" \"*cufile*\" \"*curand*\" \"*cusolver*\" \"*cusparse*\" \"*gds-tools*\" \"*npp*\" \"*nvjpeg*\" \"nsight*\" \"*nvvm*\"\n13.\nAdvanced Setup\nï\nBelow is information on some advanced setup scenarios which are not covered in the basic instructions above.\nTable 6\nAdvanced Setup Scenarios when Installing CUDA\nï\nScenario\nInstructions\nInstall GPUDirect Storage\nRefer to\nInstalling GPUDirect Storage\n.\nGDS is supported in two different modes:\nGDS (default/full perf mode)\nCompatibility mode.\nInstallation instructions for them differ slightly. Compatibility mode is the only mode that is supported on certain distributions due to software dependency limitations.\nFull GDS support is restricted to the following Linux distros:\nUbuntu 20.04, Ubuntu 22.04, Ubuntu 24.04\nRHEL 8.y (y <= 10), RHEL 9.y (y <= 6), and RHEL 10.0\nInstall CUDA to a specific directory using the Package Manager installation method.\nRPM\nThe RPM packages donât support custom install locations through the package managers (Yum and Zypper), but it is possible to install the RPM packages to a custom location using rpmâs\n--relocate\nparameter:\nsudo rpm --install --relocate /usr/local/cuda-13.0=/new/toolkit package.rpm\nYou will need to install the packages in the correct dependency order; this task is normally taken care of by the package managers. For example, if package âfooâ has a dependency on package âbarâ, you should install package âbarâ first, and package âfooâ second. You can check the dependencies of a RPM package as follows:\nrpm -qRp package.rpm\nNote that the driver packages cannot be relocated.\ndeb\nThe Deb packages do not support custom install locations. It is however possible to extract the contents of the Deb packages and move the files to the desired install location. See the next scenario for more details one xtracting Deb packages.\nExtract the contents of the installers.\nRunfile\nThe Runfile can be extracted into the standalone Toolkit Runfiles by using the\n--extract\nparameter. The Toolkit standalone Runfiles can be further extracted by running:\n./runfile.run --tar mxvf\n./runfile.run -x\nRPM\nThe RPM packages can be extracted by running:\nrpm2cpio package.rpm | cpio -idmv\ndeb\nThe Deb packages can be extracted by running:\ndpkg-deb -x package.deb output_dir\nModify Ubuntuâs apt package manager to query specific architectures for specific repositories.\nThis is useful when a foreign architecture has been added, causing â404 Not Foundâ errors to appear when the repository meta-data is updated.\nEach repository you wish to restrict to specific architectures must have its\nsources.list\nentry modified. This is done by modifying the\n/etc/apt/sources.list\nfile and any files containing repositories you wish to restrict under the\n/etc/apt/sources.list.d/\ndirectory. Normally, it is sufficient to modify only the entries in\n/etc/apt/sources.list\nAn architecture-restricted repository entry looks like:\ndeb [arch=<arch1>,<arch2>] <url>\nFor example, if you wanted to restrict a repository to only the amd64 and i386 architectures, it would look like:\ndeb [arch=amd64,i386] <url>\nIt is not necessary to restrict the\ndeb-src\nrepositories, as these repositories donât provide architecture-specific packages.\nFor more details, see the\nsources.list\nmanpage.\nThe runfile installer fails to extract due to limited space in the TMP directory.\nThis can occur on systems with limited storage in the TMP directory (usually\n/tmp\n), or on systems which use a tmpfs in memory to handle temporary storage. In this case, the\n--tmpdir\ncommand-line option should be used to instruct the runfile to use a directory with sufficient space to extract into. More information on this option can be found in\nAdvanced Options\n.\nIn case of the error:\nE:\nFailed\nto\nfetch\nfile:/var/cuda-repo\nFile\nnot\nfound\nDebian and Ubuntu\nThis can occur when installing CUDA after uninstalling a different version. Use the following command before installation:\nsudo rm -v /var/lib/apt/lists/*cuda* /var/lib/apt/lists/*nvidia*\nVerbose installation on Debian and Ubuntu\nUse the\n--verbose-versions\nflag, for example:\nsudo apt-get install --verbose-versions cuda\n14.\nAdditional Considerations\nï\nNow that you have CUDA-capable hardware and the NVIDIA CUDA Toolkit installed, you can examine and enjoy the numerous included programs. To begin using CUDA to accelerate the performance of your own applications, consult the CUDA C++ Programming Guide, located in\n/usr/local/cuda-13.0/doc\n.\nA number of helpful development tools are included in the CUDA Toolkit to assist you as you develop your CUDA programs, such as NVIDIA\nÂ®\nNsightâ¢ Eclipse Edition, NVIDIA Visual Profiler, CUDA-GDB, and CUDA-MEMCHECK.\nFor technical support on programming questions, consult and participate in the developer forums at\nhttps://forums.developer.nvidia.com/c/accelerated-computing/cuda/206\n.\n15.\nFrequently Asked Questions\nï\n15.1.\nHow do I install the Toolkit in a different location?\nï\nThe Runfile installation asks where you wish to install the Toolkit during an interactive install. If installing using a non-interactive install, you can use the\n--toolkitpath\nparameter to change the install location:\n# ./runfile.run --silent --toolkit --toolkitpath=/my/new/toolkit\nThe RPM and Deb packages cannot be installed to a custom install location directly using the package managers. See the âInstall CUDA to a specific directory using the Package Manager installation methodâ scenario in the\nAdvanced Setup\nsection for more information.\n15.2.\nWhy do I see ânvcc: No such file or directoryâ when I try to build a CUDA application?\nï\nYour PATH environment variable is not set up correctly. Ensure that your PATH includes the bin directory where you installed the Toolkit, usually\n/usr/local/cuda-13.0/bin\n.\n$ export PATH=/usr/local/cuda-13.0/bin${PATH:+:${PATH}}\n15.3.\nWhy do I see âerror while loading shared libraries: <lib name>: cannot open shared object file: No such file or directoryâ when I try to run a CUDA application that uses a CUDA library?\nï\nYour LD_LIBRARY_PATH environment variable is not set up correctly. Ensure that your LD_LIBRARY_PATH includes the lib and/or lib64 directory where you installed the Toolkit, usually\n/usr/local/cuda-13.0/lib{,64}\n:\n$ export LD_LIBRARY_PATH=/usr/local/cuda-13.0/lib ${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}\n15.4.\nWhy do I see multiple â404 Not Foundâ errors when updating my repository meta-data on Ubuntu?\nï\nThese errors occur after adding a foreign architecture because apt is attempting to query for each architecture within each repository listed in the systemâs sources.list file. Repositories that do not host packages for the newly added architecture will present this error. While noisy, the error itself does no harm. Please see the\nAdvanced Setup\nsection for details on how to modify your\nsources.list\nfile to prevent these errors.\n15.5.\nHow can I tell X to ignore a GPU for compute-only use?\nï\nTo make sure X doesnât use a certain GPU for display, you need to specify which\nother\nGPU to use for display. For more information, please refer to the âUse a specific GPU for rendering the displayâ scenario in the\nAdvanced Setup\nsection.\n15.6.\nWhy doesnât the cuda-repo package install the CUDA Toolkit?\nï\nWhen using RPM or Deb, the downloaded package is a repository package. Such a package only informs the package manager where to find the actual installation packages, but will not install them.\nSee the\nPackage Manager Installation\nsection for more details.\n15.7.\nHow do I install an older CUDA version using a network repo?\nï\nDepending on your system configuration, you may not be able to install old versions of CUDA using the cuda metapackage. In order to install a specific version of CUDA, you may need to specify all of the packages that would normally be installed by the cuda metapackage at the version you want to install.\nIf you are using yum to install certain packages at an older version, the dependencies may not resolve as expected. In this case you may need to pass â\n--setopt=obsoletes=0\nâ to yum to allow an install of packages which are obsoleted at a later version than you are trying to install.\n15.8.\nHow do I handle âErrors were encountered while processing: glx-diversionsâ?\nï\nThis sometimes occurs when trying to uninstall CUDA after a clean .deb installation. Run the following commands:\n# apt install glx-diversions --reinstall\n# apt remove nvidia-alternative\nThen re-run the commands from\nRemoving CUDA Toolkit\n.\n16.\nNotices\nï\n16.1.\nNotice\nï\nThis document is provided for information purposes only and shall not be regarded as a warranty of a certain functionality, condition, or quality of a product. NVIDIA Corporation (âNVIDIAâ) makes no representations or warranties, expressed or implied, as to the accuracy or completeness of the information contained in this document and assumes no responsibility for any errors contained herein. NVIDIA shall have no liability for the consequences or use of such information or for any infringement of patents or other rights of third parties that may result from its use. This document is not a commitment to develop, release, or deliver any Material (defined below), code, or functionality.\nNVIDIA reserves the right to make corrections, modifications, enhancements, improvements, and any other changes to this document, at any time without notice.\nCustomer should obtain the latest relevant information before placing orders and should verify that such information is current and complete.\nNVIDIA products are sold subject to the NVIDIA standard terms and conditions of sale supplied at the time of order acknowledgement, unless otherwise agreed in an individual sales agreement signed by authorized representatives of NVIDIA and customer (âTerms of Saleâ). NVIDIA hereby expressly objects to applying any customer general terms and conditions with regards to the purchase of the NVIDIA product referenced in this document. No contractual obligations are formed either directly or indirectly by this document.\nNVIDIA products are not designed, authorized, or warranted to be suitable for use in medical, military, aircraft, space, or life support equipment, nor in applications where failure or malfunction of the NVIDIA product can reasonably be expected to result in personal injury, death, or property or environmental damage. NVIDIA accepts no liability for inclusion and/or use of NVIDIA products in such equipment or applications and therefore such inclusion and/or use is at customerâs own risk.\nNVIDIA makes no representation or warranty that products based on this document will be suitable for any specified use. Testing of all parameters of each product is not necessarily performed by NVIDIA. It is customerâs sole responsibility to evaluate and determine the applicability of any information contained in this document, ensure the product is suitable and fit for the application planned by customer, and perform the necessary testing for the application in order to avoid a default of the application or the product. Weaknesses in customerâs product designs may affect the quality and reliability of the NVIDIA product and may result in additional or different conditions and/or requirements beyond those contained in this document. NVIDIA accepts no liability related to any default, damage, costs, or problem which may be based on or attributable to: (i) the use of the NVIDIA product in any manner that is contrary to this document or (ii) customer product designs.\nNo license, either expressed or implied, is granted under any NVIDIA patent right, copyright, or other NVIDIA intellectual property right under this document. Information published by NVIDIA regarding third-party products or services does not constitute a license from NVIDIA to use such products or services or a warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual property rights of the third party, or a license from NVIDIA under the patents or other intellectual property rights of NVIDIA.\nReproduction of information in this document is permissible only if approved in advance by NVIDIA in writing, reproduced without alteration and in full compliance with all applicable export laws and regulations, and accompanied by all associated conditions, limitations, and notices.\nTHIS DOCUMENT AND ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, âMATERIALSâ) ARE BEING PROVIDED âAS IS.â NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL NVIDIA BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Notwithstanding any damages that customer might incur for any reason whatsoever, NVIDIAâs aggregate and cumulative liability towards customer for the products described herein shall be limited in accordance with the Terms of Sale for the product.\n16.2.\nOpenCL\nï\nOpenCL is a trademark of Apple Inc. used under license to the Khronos Group Inc.\n16.3.\nTrademarks\nï\nNVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated.\n17.\nCopyright\nï\nÂ© 2009-2024 NVIDIA Corporation & affiliates. All rights reserved.\nThis product includes software developed by the Syncro Soft SRL (\nhttp://www.sync.ro/\n).", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html"}}
{"text": "CUDA Quick Start Guide — Quick Start Guide 13.0 documentation\n»\nCUDA Quick Start Guide\nv13.0 |\nPDF\n|\nArchive\nCUDA Quick Start Guide\n1.\nOverview\n\nMinimal first-steps instructions to get CUDA running on a standard system.\n2.\nIntroduction\n\nThis guide covers the basic instructions needed to install CUDA and verify that a CUDA application can run on each supported platform.\nThese instructions are intended to be used on a clean installation of a supported platform. For questions which are not answered in this document, please refer to the\nWindows Installation Guide\nand\nLinux Installation Guide\n.\nThe CUDA installation packages can be found on the\nCUDA Downloads Page\n.\n3.\nWindows\n\nWhen installing CUDA on Windows, you can choose between the Network Installer and the Local Installer. The Network Installer allows you to download only the files you need. The Local Installer is a stand-alone installer with a large initial download. For more details, refer to the\nWindows Installation Guide\n.\n3.1.\nNetwork Installer\n\nPerform the following steps to install CUDA and verify the installation.\nLaunch the downloaded installer package.\nRead and accept the EULA.\nSelect\nnext\nto download and install all components.\nOnce the download completes, the installation will begin automatically.\nOnce the installation completes, click “next” to acknowledge the Nsight Visual Studio Edition installation summary.\nClick\nclose\nto close the installer.\nNavigate to the Samples’\nnbody\ndirectory in\nhttps://github.com/NVIDIA/cuda-samples/tree/master/Samples/5_Domain_Specific/nbody\n.\nOpen the\nnbody\nVisual Studio solution file for the version of Visual Studio you have installed, for example,\nnbody_vs2019.sln\n.\nOpen the\nBuild\nmenu within Visual Studio and click\nBuild Solution\n.\nNavigate to the CUDA Samples build directory and run the nbody sample.\nNote\nRun samples by navigating to the executable’s location, otherwise it will fail to locate dependent resources.\n3.2.\nLocal Installer\n\nPerform the following steps to install CUDA and verify the installation.\nLaunch the downloaded installer package.\nRead and accept the EULA.\nSelect\nnext\nto install all components.\nOnce the installation completes, click\nnext\nto acknowledge the Nsight Visual Studio Edition installation summary.\nClick\nclose\nto close the installer.\nNavigate to the Samples’\nnbody\ndirectory in\nhttps://github.com/NVIDIA/cuda-samples/tree/master/Samples/5_Domain_Specific/nbody\n.\nOpen the nbody Visual Studio solution file for the version of Visual Studio you have installed.\nOpen the\nBuild\nmenu within Visual Studio and click\nBuild Solution\n.\nNavigate to the CUDA Samples build directory and run the nbody sample.\nNote\nRun samples by navigating to the executable’s location, otherwise it will fail to locate dependent resources.\n3.3.\nPip Wheels - Windows\n\nNVIDIA provides Python Wheels for installing CUDA through pip, primarily for using CUDA with Python. These packages are intended for runtime use and do not currently include developer tools (these can be installed separately).\nPlease note that with this installation method, CUDA installation environment is managed via pip and additional care must be taken to set up your host environment to use CUDA outside the pip environment.\nPrerequisites\nTo install Wheels, you must first install the\nnvidia-pyindex\npackage, which is required in order to set up your pip installation to fetch additional Python modules from the NVIDIA NGC PyPI repo. If your pip and setuptools Python modules are not up-to-date, then use the following command to upgrade these Python modules. If these Python modules are out-of-date then the commands which follow later in this section may fail.\npy -m pip install --upgrade setuptools pip wheel\nYou should now be able to install the\nnvidia-pyindex\nmodule.\npy -m pip install nvidia-pyindex\nIf your project is using a\nrequirements.txt\nfile, then you can add the following line to your\nrequirements.txt\nfile as an alternative to installing the\nnvidia-pyindex\npackage:\n--extra-index-url https://pypi.ngc.nvidia.com\nProcedure\nInstall the CUDA runtime package:\npy -m pip install nvidia-cuda-runtime-cu12\nOptionally, install additional packages as listed below using the following command:\npy -m pip install nvidia-<library>\nMetapackages\nThe following metapackages will install the latest version of the named component on Windows for the indicated CUDA version. “cu12” should be read as “cuda12”.\nnvidia-cuda-runtime-cu12\nnvidia-cuda-cupti-cu12\nnvidia-cuda-nvcc-cu12\nnvidia-nvml-dev-cu12\nnvidia-cuda-nvrtc-cu12\nnvidia-nvtx-cu12\nnvidia-cuda-sanitizer-api-cu12\nnvidia-cublas-cu12\nnvidia-cufft-cu12\nnvidia-curand-cu12\nnvidia-cusolver-cu12\nnvidia-cusparse-cu12\nnvidia-npp-cu12\nnvidia-nvjpeg-cu12\nThese metapackages install the following packages:\nnvidia-nvml-dev-cu126\nnvidia-cuda-nvcc-cu126\nnvidia-cuda-runtime-cu126\nnvidia-cuda-cupti-cu126\nnvidia-cublas-cu126\nnvidia-cuda-sanitizer-api-cu126\nnvidia-nvtx-cu126\nnvidia-cuda-nvrtc-cu126\nnvidia-npp-cu126\nnvidia-cusparse-cu126\nnvidia-cusolver-cu126\nnvidia-curand-cu126\nnvidia-cufft-cu126\nnvidia-nvjpeg-cu126\n3.4.\nConda\n\nThe Conda packages are available at\nhttps://anaconda.org/nvidia\n.\nInstallation\nTo perform a basic install of all CUDA Toolkit components using Conda, run the following command:\nconda install cuda -c nvidia\nUninstallation\nTo uninstall the CUDA Toolkit using Conda, run the following command:\nconda remove cuda\n4.\nLinux\n\nCUDA on Linux can be installed using an RPM, Debian, Runfile, or Conda package, depending on the platform being installed on.\n4.1.\nLinux x86_64\n\nFor development on the x86_64 architecture. In some cases, x86_64 systems may act as host platforms targeting other architectures. See the\nLinux Installation Guide\nfor more details.\n4.1.1.\nRedhat / CentOS\n\nWhen installing CUDA on Redhat or CentOS, you can choose between the Runfile Installer and the RPM Installer. The Runfile Installer is only available as a Local Installer. The RPM Installer is available as both a Local Installer and a Network Installer. The Network Installer allows you to download only the files you need. The Local Installer is a stand-alone installer with a large initial download. In the case of the RPM installers, the instructions for the Local and Network variants are the same. For more details, refer to the\nLinux Installation Guide\n.\n4.1.1.1.\nRPM Installer\n\nPerform the following steps to install CUDA and verify the installation.\nInstall EPEL to satisfy the DKMS dependency by following the instructions at\nEPEL’s website\n.\nEnable optional repos\n:\nOn\nRHEL 8 Linux\nonly, execute the following steps to enable optional repositories.\nOn x86_64 workstation:\nsubscription-manager repos --enable=rhel-8-for-x86_64-appstream-rpms\nsubscription-manager repos --enable=rhel-8-for-x86_64-baseos-rpms\nsubscription-manager repos --enable=codeready-builder-for-rhel-8-x86_64-rpms\nInstall the repository meta-data, clean the yum cache, and install CUDA:\nsudo rpm --install cuda-repo-<distro>-<version>.<architecture>.rpm\nsudo rpm --erase gpg-pubkey-7fa2af80*\nsudo yum clean expire-cache\nsudo yum install cuda\nReboot the system to load the NVIDIA drivers:\nsudo reboot\nSet up the development environment by modifying the\nPATH\nand\nLD_LIBRARY_PATH\nvariables:\nexport PATH=/usr/local/cuda-12.8/bin${PATH:+:${PATH}}\nexport LD_LIBRARY_PATH=/usr/local/cuda-12.8/lib64\\\n${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}\nInstall a writable copy of the samples from\nhttps://github.com/nvidia/cuda-samples\n, then build and run the nbody sample using the Linux instructions in\nhttps://github.com/NVIDIA/cuda-samples/tree/master/Samples/5_Domain_Specific/nbody\n.\nNote\nRun samples by navigating to the executable’s location, otherwise it will fail to locate dependent resources.\n4.1.1.2.\nRunfile Installer\n\nPerform the following steps to install CUDA and verify the installation.\nDisable the Nouveau drivers:\nCreate a file at\n/etc/modprobe.d/blacklist-nouveau.conf\nwith the following contents:\nblacklist nouveau\noptions nouveau modeset=0\nRegenerate the kernel initramfs:\nsudo dracut --force\nReboot into runlevel 3 by temporarily adding the number “3” and the word “nomodeset” to the end of the system’s kernel boot parameters.\nRun the installer silently to install with the default selections (implies acceptance of the EULA):\nsudo sh cuda_<version>_linux.run --silent\nCreate an xorg.conf file to use the NVIDIA GPU for display:\nsudo nvidia-xconfig\nReboot the system to load the graphical interface:\nsudo reboot\nSet up the development environment by modifying the PATH and LD_LIBRARY_PATH variables:\nexport PATH=/usr/local/cuda-12.8/bin${PATH:+:${PATH}}\nexport LD_LIBRARY_PATH=/usr/local/cuda-12.8/lib64\\\n${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}\nInstall a writable copy of the samples from\nhttps://github.com/nvidia/cuda-samples\n, then build and run the nbody sample using the Linux instructions in\nhttps://github.com/NVIDIA/cuda-samples/tree/master/Samples/5_Domain_Specific/nbody\n.\nNote\nRun samples by navigating to the executable’s location, otherwise it will fail to locate dependent resources.\n4.1.2.\nFedora\n\nWhen installing CUDA on Fedora, you can choose between the Runfile Installer and the RPM Installer. The Runfile Installer is only available as a Local Installer. The RPM Installer is available as both a Local Installer and a Network Installer. The Network Installer allows you to download only the files you need. The Local Installer is a stand-alone installer with a large initial download. In the case of the RPM installers, the instructions for the Local and Network variants are the same. For more details, refer to the\nLinux Installation Guide\n.\n4.1.2.1.\nRPM Installer\n\nPerform the following steps to install CUDA and verify the installation.\nInstall the RPMFusion free repository to satisfy the Akmods dependency:\nsu -c 'dnf install --nogpgcheck http://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm'\nInstall the repository meta-data, clean the dnf cache, and install CUDA:\nsudo rpm --install cuda-repo-<distro>-<version>.<architecture>.rpm\nsudo rpm --erase gpg-pubkey-7fa2af80*\nsudo dnf clean expire-cache\nsudo dnf install cuda\nReboot the system to load the NVIDIA drivers:\nsudo reboot\nSet up the development environment by modifying the PATH and LD_LIBRARY_PATH variables:\nexport PATH=/usr/local/cuda-12.8/bin${PATH:+:${PATH}}\nexport LD_LIBRARY_PATH=/usr/local/cuda-12.8/lib64\\\n${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}\nInstall a writable copy of the samples from\nhttps://github.com/nvidia/cuda-samples\n, then build and run the nbody sample using the Linux instructions in\nhttps://github.com/NVIDIA/cuda-samples/tree/master/Samples/5_Domain_Specific/nbody\n.\nNote\nRun samples by navigating to the executable’s location, otherwise it will fail to locate dependent resources.\n4.1.2.2.\nRunfile Installer\n\nPerform the following steps to install CUDA and verify the installation.\nDisable the Nouveau drivers:\nCreate a file at\n/usr/lib/modprobe.d/blacklist-nouveau.conf\nwith the following contents:\nblacklist nouveau\noptions nouveau modeset=0\nRegenerate the kernel initramfs:\nsudo dracut --force\nRun the below command:\nsudo grub2-mkconfig -o /boot/grub2/grub.cfg\nReboot the system:\nsudo reboot\nReboot into runlevel 3 by temporarily adding the number “3” and the word “nomodeset” to the end of the system’s kernel boot parameters.\nRun the installer silently to install with the default selections (implies acceptance of the EULA):\nsudo sh cuda_<version>_linux.run --silent\nCreate an xorg.conf file to use the NVIDIA GPU for display:\nsudo nvidia-xconfig\nReboot the system to load the graphical interface.\nSet up the development environment by modifying the PATH and LD_LIBRARY_PATH variables:\nexport PATH=/usr/local/cuda-12.8/bin${PATH:+:${PATH}}\nexport LD_LIBRARY_PATH=/usr/local/cuda-12.8/lib64\\\n${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}\nInstall a writable copy of the samples from\nhttps://github.com/nvidia/cuda-samples\n, then build and run the nbody sample using the Linux instructions in\nhttps://github.com/NVIDIA/cuda-samples/tree/master/Samples/5_Domain_Specific/nbody\n.\nNote\nRun samples by navigating to the executable’s location, otherwise it will fail to locate dependent resources.\n4.1.3.\nSUSE Linux Enterprise Server\n\nWhen installing CUDA on SUSE Linux Enterprise Server, you can choose between the Runfile Installer and the RPM Installer. The Runfile Installer is only available as a Local Installer. The RPM Installer is available as both a Local Installer and a Network Installer. The Network Installer allows you to download only the files you need. The Local Installer is a stand-alone installer with a large initial download. In the case of the RPM installers, the instructions for the Local and Network variants are the same. For more details, refer to the\nLinux Installation Guide\n.\n4.1.3.1.\nRPM Installer\n\nPerform the following steps to install CUDA and verify the installation.\nInstall the repository meta-data, refresh the Zypper cache, update the GPG key, and install CUDA:\nsudo rpm --install cuda-repo-<distro>-<version>.<architecture>.rpm\nsudo SUSEConnect --product PackageHub/15/x86_64\nsudo zypper refresh\nsudo rpm --erase gpg-pubkey-7fa2af80*\nsudo dnf config-manager --add-repo https://developer.download.nvidia.com/compute/cuda/repos/$distro/$arch/cuda-$distro.repo\nsudo zypper install cuda\nAdd the user to the video group:\nsudo usermod -a -G video <username>\nReboot the system to load the NVIDIA drivers:\nsudo reboot\nSet up the development environment by modifying the PATH and LD_LIBRARY_PATH variables:\nexport PATH=/usr/local/cuda-12.8/bin${PATH:+:${PATH}}\nexport LD_LIBRARY_PATH=/usr/local/cuda-12.8/lib64\\\n${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}\nInstall a writable copy of the samples from\nhttps://github.com/nvidia/cuda-samples\n, then build and run the vectorAdd sample using the Linux instructions in\nhttps://github.com/NVIDIA/cuda-samples/tree/master/Samples/0_Introduction/vectorAdd\n.\nNote\nRun samples by navigating to the executable’s location, otherwise it will fail to locate dependent resources.\n4.1.3.2.\nRunfile Installer\n\nPerform the following steps to install CUDA and verify the installation.\nReboot into runlevel 3 by temporarily adding the number “3” and the word “nomodeset” to the end of the system’s kernel boot parameters.\nRun the installer silently to install with the default selections (implies acceptance of the EULA):\nsudo sh cuda_<version>_linux.run --silent\nCreate an xorg.conf file to use the NVIDIA GPU for display:\nsudo nvidia-xconfig\nReboot the system to load the graphical interface:\nsudo reboot\nSet up the development environment by modifying the PATH and LD_LIBRARY_PATH variables:\nexport PATH=/usr/local/cuda-12.8/bin${PATH:+:${PATH}}\nexport LD_LIBRARY_PATH=/usr/local/cuda-12.8/lib64\\\n${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}\nInstall a writable copy of the samples from\nhttps://github.com/nvidia/cuda-samples\n, then build and run the vectorAdd sample using the Linux instructions in\nhttps://github.com/NVIDIA/cuda-samples/tree/master/Samples/0_Introduction/vectorAdd\n.\nNote\nRun samples by navigating to the executable’s location, otherwise it will fail to locate dependent resources.\n4.1.4.\nOpenSUSE\n\nWhen installing CUDA on OpenSUSE, you can choose between the Runfile Installer and the RPM Installer. The Runfile Installer is only available as a Local Installer. The RPM Installer is available as both a Local Installer and a Network Installer. The Network Installer allows you to download only the files you need. The Local Installer is a stand-alone installer with a large initial download. In the case of the RPM installers, the instructions for the Local and Network variants are the same. For more details, refer to the\nLinux Installation Guide\n.\n4.1.4.1.\nRPM Installer\n\nPerform the following steps to install CUDA and verify the installation.\nInstall the repository meta-data, refresh the Zypper cache, and install CUDA:\nsudo rpm --install cuda-repo-<distro>-<version>.<architecture>.rpm\nsudo rpm --erase gpg-pubkey-7fa2af80*\nsudo zypper refresh\nsudo zypper install cuda\nAdd the user to the video group:\nsudo usermod -a -G video <username>\nReboot the system to load the NVIDIA drivers:\nsudo reboot\nSet up the development environment by modifying the PATH and LD_LIBRARY_PATH variables:\nexport PATH=/usr/local/cuda-12.8/bin${PATH:+:${PATH}}\nexport LD_LIBRARY_PATH=/usr/local/cuda-12.8/lib64\\\n${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}\nInstall a writable copy of the samples from\nhttps://github.com/nvidia/cuda-samples\n, then build and run the nbody sample using the Linux instructions in\nhttps://github.com/NVIDIA/cuda-samples/tree/master/Samples/5_Domain_Specific/nbody\n.\nNote\nRun samples by navigating to the executable’s location, otherwise it will fail to locate dependent resources.\n4.1.4.2.\nRunfile Installer\n\nPerform the following steps to install CUDA and verify the installation.\nDisable the Nouveau drivers:\nCreate a file at\n/etc/modprobe.d/blacklist-nouveau.conf\nwith the following contents:\nblacklist nouveau\noptions nouveau modeset=0\nRegenerate the kernel initrd:\nsudo /sbin/mkinitrd\nReboot into runlevel 3 by temporarily adding the number “3” and the word “nomodeset” to the end of the system’s kernel boot parameters.\nRun the installer silently to install with the default selections (implies acceptance of the EULA):\nsudo sh cuda_<version>_linux.run --silent\nCreate an xorg.conf file to use the NVIDIA GPU for display:\nsudo nvidia-xconfig\nReboot the system to load the graphical interface:\nsudo reboot\nSet up the development environment by modifying the PATH and LD_LIBRARY_PATH variables:\nexport PATH=/usr/local/cuda-12.8/bin${PATH:+:${PATH}}\nexport LD_LIBRARY_PATH=/usr/local/cuda-12.8/lib64\\\n${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}\nInstall a writable copy of the samples from\nhttps://github.com/nvidia/cuda-samples\n, then build and run the nbody sample using the Linux instructions in\nhttps://github.com/NVIDIA/cuda-samples/tree/master/Samples/5_Domain_Specific/nbody\n.\nNote\nRun samples by navigating to the executable’s location, otherwise it will fail to locate dependent resources.\n4.1.5.\nAmazon Linux 2023\n\n4.1.5.1.\nPrepare Amazon Linux 2023\n\nPerform the\npre-installation actions.\nThe kernel headers and development packages for the currently running kernel can be installed with:\nsudo dnf install kernel-devel-$(uname -r) kernel-headers-$(uname -r) kernel-modules-extra-$(uname -r)\nChoose an installation method:\nlocal repo\nor\nnetwork repo\n.\n4.1.5.2.\nLocal Repo Installation for Amazon Linux\n\nInstall local repository on file system:\nsudo rpm --install cuda-repo-amzn2023-X-Y-local-<version>*.x86_64.rpm\n4.1.5.3.\nNetwork Repo Installation for Amazon Linux\n\nEnable the network repository and clean the DN cache:\nsudo dnf config-manager --add-repo https://developer.download.nvidia.com/compute/cuda/repos/amzn2023/x86_64/cuda-amzn2023.repo\nsudo dnf clean expire-cache\n4.1.5.4.\nCommon Installation Instructions for Amazon Linux\n\nThese instructions apply to both local and network installation for Amazon Linux.\nInstall CUDA SDK:\nsudo dnf module install nvidia-driver:latest-dkms\nsudo dnf install cuda-toolkit\nInstall GPUDirect Filesystem:\nsudo dnf install nvidia-gds\nAdd libcuda.so symbolic link, if necessary:\nThe\nlibcuda.so\nlibrary is installed in the\n/usr/lib{,64}/nvidia\ndirectory. For pre-existing projects which use\nlibcuda.so\n, it may be useful to add a symbolic link from\nlibcuda.so\nin the\n/usr/lib{,64}\ndirectory.\nReboot the system:\nsudo reboot\nPerform the\npost-installation actions.\n4.1.6.\nPip Wheels - Linux\n\nNVIDIA provides Python Wheels for installing CUDA through pip, primarily for using CUDA with Python. These packages are intended for runtime use and do not currently include developer tools (these can be installed separately).\nPlease note that with this installation method, CUDA installation environment is managed via pip and additional care must be taken to set up your host environment to use CUDA outside the pip environment.\nPrerequisites\nTo install Wheels, you must first install the\nnvidia-pyindex\npackage, which is required in order to set up your pip installation to fetch additional Python modules from the NVIDIA NGC PyPI repo. If your pip and setuptools Python modules are not up-to-date, then use the following command to upgrade these Python modules. If these Python modules are out-of-date then the commands which follow later in this section may fail.\npython3 -m pip install --upgrade setuptools pip wheel\nYou should now be able to install the\nnvidia-pyindex\nmodule.\npython3 -m pip install nvidia-pyindex\nIf your project is using a\nrequirements.txt\nfile, then you can add the following line to your\nrequirements.txt\nfile as an alternative to installing the\nnvidia-pyindex\npackage:\n--extra-index-url https://pypi.ngc.nvidia.com\nProcedure\nInstall the CUDA runtime package:\npython3 -m pip install nvidia-cuda-runtime-cu12\nOptionally, install additional packages as listed below using the following command:\npython3 -m pip install nvidia-<library>\nMetapackages\nThe following metapackages will install the latest version of the named component on Linux for the indicated CUDA version. “cu12” should be read as “cuda12”.\nnvidia-cuda-runtime-cu12\nnvidia-cuda-cupti-cu12\nnvidia-cuda-nvcc-cu12\nnvidia-nvml-dev-cu12\nnvidia-cuda-nvrtc-cu12\nnvidia-nvtx-cu12\nnvidia-cuda-sanitizer-api-cu12\nnvidia-cublas-cu12\nnvidia-cufft-cu12\nnvidia-curand-cu12\nnvidia-cusolver-cu12\nnvidia-cusparse-cu12\nnvidia-npp-cu12\nnvidia-nvjpeg-cu12\nnvidia-opencl-cu12\nnvidia-nvjitlink-cu12\nThese metapackages install the following packages:\nnvidia-nvml-dev-cu127\nnvidia-cuda-nvcc-cu127\nnvidia-cuda-runtime-cu127\nnvidia-cuda-cupti-cu127\nnvidia-cublas-cu127\nnvidia-cuda-sanitizer-api-cu127\nnvidia-nvtx-cu127\nnvidia-cuda-nvrtc-cu127\nnvidia-npp-cu127\nnvidia-cusparse-cu127\nnvidia-cusolver-cu127\nnvidia-curand-cu127\nnvidia-cufft-cu127\nnvidia-nvjpeg-cu127\nnvidia-opencl-cu127\nnvidia-nvjitlink-cu127\n4.1.7.\nConda\n\nThe Conda packages are available at\nhttps://anaconda.org/nvidia\n.\nInstallation\nTo perform a basic install of all CUDA Toolkit components using Conda, run the following command:\nconda install cuda -c nvidia\nUninstallation\nTo uninstall the CUDA Toolkit using Conda, run the following command:\nconda remove cuda\n4.1.8.\nWSL\n\nThese instructions must be used if you are installing in a WSL environment. Do not use the Ubuntu instructions in this case.\nInstall repository meta-data\nsudo dpkg -i cuda-repo-<distro>_<version>_<architecture>.deb\nUpdate the CUDA public GPG key\nsudo apt-key del 7fa2af80\nWhen installing using the local repo:\nsudo cp /var/cuda-repo-wsl-ubuntu-13-0-local/cuda-*-keyring.gpg /usr/share/keyrings/\nWhen installing using the network repo:\nwget https://developer.download.nvidia.com/compute/cuda/repos/<distro>/<arch>/cuda-keyring_1.1-1_all.deb\nsudo dpkg -i cuda-keyring_1.1-1_all.deb\nPin file to prioritize CUDA repository:\nwget https://developer.download.nvidia.com/compute/cuda/repos/<distro>/<architecture>/cuda-<distro>.pin\nsudo mv cuda-<distro>.pin /etc/apt/preferences.d/cuda-repository-pin-600\nUpdate the Apt repository cache and install CUDA\nsudo apt-get update\nsudo apt-get install cuda\n4.1.9.\nUbuntu\n\nWhen installing CUDA on Ubuntu, you can choose between the Runfile Installer and the Debian Installer. The Runfile Installer is only available as a Local Installer. The Debian Installer is available as both a Local Installer and a Network Installer. The Network Installer allows you to download only the files you need. The Local Installer is a stand-alone installer with a large initial download. In the case of the Debian installers, the instructions for the Local and Network variants are the same. For more details, refer to the\nLinux Installation Guide\n.\n4.1.9.1.\nDebian Installer\n\nPerform the following steps to install CUDA and verify the installation.\nInstall the repository meta-data, update the GPG key, update the apt-get cache, and install CUDA:\nsudo dpkg --install cuda-repo-<distro>-<version>.<architecture>.deb\nsudo apt-key del 7fa2af80\nwget https://developer.download.nvidia.com/compute/cuda/repos/<distro>/<arch>/cuda-keyring_1.1-1_all.deb\nsudo dpkg -i cuda-keyring_1.1-1_all.deb\nsudo add-apt-repository contrib\nsudo apt-get update\nsudo apt-get -y install cuda\nReboot the system to load the NVIDIA drivers:\nsudo reboot\nSet up the development environment by modifying the PATH and LD_LIBRARY_PATH variables:\nexport PATH=/usr/local/cuda-12.8/bin${PATH:+:${PATH}}\nexport LD_LIBRARY_PATH=/usr/local/cuda-12.8/lib64\\\n${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}\nInstall a writable copy of the samples from\nhttps://github.com/nvidia/cuda-samples\n, then build and run the nbody sample using the Linux instructions in\nhttps://github.com/NVIDIA/cuda-samples/tree/master/Samples/5_Domain_Specific/nbody\n.\nNote\nRun samples by navigating to the executable’s location, otherwise it will fail to locate dependent resources.\n4.1.9.2.\nRunfile Installer\n\nPerform the following steps to install CUDA and verify the installation.\nDisable the Nouveau drivers:\nCreate a file at\n/etc/modprobe.d/blacklist-nouveau.conf\nwith the following contents:\nblacklist nouveau\noptions nouveau modeset=0\nRegenerate the kernel initramfs:\nsudo update-initramfs -u\nReboot into runlevel 3 by temporarily adding the number “3” and the word “nomodeset” to the end of the system’s kernel boot parameters.\nRun the installer silently to install with the default selections (implies acceptance of the EULA):\nsudo sh cuda_<version>_linux.run --silent\nCreate an\nxorg.conf\nfile to use the NVIDIA GPU for display:\nsudo nvidia-xconfig\nReboot the system to load the graphical interface:\nsudo reboot\nSet up the development environment by modifying the PATH and LD_LIBRARY_PATH variables:\nexport PATH=/usr/local/cuda-12.8/bin${PATH:+:${PATH}}\nexport LD_LIBRARY_PATH=/usr/local/cuda-12.8/lib64\\\n${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}\nInstall a writable copy of the samples from\nhttps://github.com/nvidia/cuda-samples\n, then build and run the nbody sample using the Linux instructions in\nhttps://github.com/NVIDIA/cuda-samples/tree/master/Samples/5_Domain_Specific/nbody\n.\nNote\nRun samples by navigating to the executable’s location, otherwise it will fail to locate dependent resources.\n4.1.10.\nDebian\n\nWhen installing CUDA on Debian 10, you can choose between the Runfile Installer and the Debian Installer. The Runfile Installer is only available as a Local Installer. The Debian Installer is available as both a Local Installer and a Network Installer. The Network Installer allows you to download only the files you need. The Local Installer is a stand-alone installer with a large initial download. For more details, refer to the\nLinux Installation Guide\n.\n4.1.10.1.\nDebian Installer\n\nPerform the following steps to install CUDA and verify the installation.\nInstall the repository meta-data, remove old GPG key, install GPG key, update the apt-get cache, and install CUDA:\nsudo dpkg -i cuda-repo-<distro>_<version>_<architecture>.deb\nsudo apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/cuda/repos/debian10/x86_64/7fa2af80.pub\nsudo apt-key del 7fa2af80\nwget https://developer.download.nvidia.com/compute/cuda/repos/<distro>/<arch>/cuda-keyring_1.1-1_all.deb\nsudo dpkg -i cuda-keyring_1.1-1_all.deb\nsudo add-apt-repository contrib\nsudo apt-get update\nsudo apt-get -y install cuda\nReboot the system to load the NVIDIA drivers:\nsudo reboot\nSet up the development environment by modifying the PATH and LD_LIBRARY_PATH variables:\nexport PATH=/usr/local/cuda-12.8/bin${PATH:+:${PATH}}\nexport LD_LIBRARY_PATH=/usr/local/cuda-12.8/lib64\\\n${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}\nInstall a writable copy of the samples from\nhttps://github.com/nvidia/cuda-samples\n, then build and run the nbody sample using the Linux instructions in\nhttps://github.com/NVIDIA/cuda-samples/tree/master/Samples/5_Domain_Specific/nbody\n.\nNote\nRun samples by navigating to the executable’s location, otherwise it will fail to locate dependent resources.\n4.1.10.2.\nRunfile Installer\n\nPerform the following steps to install CUDA and verify the installation.\nDisable the Nouveau drivers:\nCreate a file at\n/etc/modprobe.d/blacklist-nouveau.conf\nwith the following contents:\nblacklist nouveau\noptions nouveau modeset=0\nRegenerate the kernel initramfs:\nsudo update-initramfs -u\nReboot into runlevel 3 by temporarily adding the number “3” and the word “nomodeset” to the end of the system’s kernel boot parameters.\nRun the installer silently to install with the default selections (implies acceptance of the EULA):\nsudo sh cuda_<version>_linux.run --silent\nCreate an xorg.conf file to use the NVIDIA GPU for display:\nsudo nvidia-xconfig\nReboot the system to load the graphical interface:\nsudo reboot\nSet up the development environment by modifying the PATH and LD_LIBRARY_PATH variables:\nexport PATH=/usr/local/cuda-12.8/bin${PATH:+:${PATH}}\nexport LD_LIBRARY_PATH=/usr/local/cuda-12.8/lib64\\\n${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}\nInstall a writable copy of the samples from\nhttps://github.com/nvidia/cuda-samples\n, then build and run the nbody sample using the Linux instructions in\nhttps://github.com/NVIDIA/cuda-samples/tree/master/Samples/5_Domain_Specific/nbody\n.\nNote\nRun samples by navigating to the executable’s location, otherwise it will fail to locate dependent resources.\n5.\nNotices\n\n5.1.\nNotice\n\nThis document is provided for information purposes only and shall not be regarded as a warranty of a certain functionality, condition, or quality of a product. NVIDIA Corporation (“NVIDIA”) makes no representations or warranties, expressed or implied, as to the accuracy or completeness of the information contained in this document and assumes no responsibility for any errors contained herein. NVIDIA shall have no liability for the consequences or use of such information or for any infringement of patents or other rights of third parties that may result from its use. This document is not a commitment to develop, release, or deliver any Material (defined below), code, or functionality.\nNVIDIA reserves the right to make corrections, modifications, enhancements, improvements, and any other changes to this document, at any time without notice.\nCustomer should obtain the latest relevant information before placing orders and should verify that such information is current and complete.\nNVIDIA products are sold subject to the NVIDIA standard terms and conditions of sale supplied at the time of order acknowledgement, unless otherwise agreed in an individual sales agreement signed by authorized representatives of NVIDIA and customer (“Terms of Sale”). NVIDIA hereby expressly objects to applying any customer general terms and conditions with regards to the purchase of the NVIDIA product referenced in this document. No contractual obligations are formed either directly or indirectly by this document.\nNVIDIA products are not designed, authorized, or warranted to be suitable for use in medical, military, aircraft, space, or life support equipment, nor in applications where failure or malfunction of the NVIDIA product can reasonably be expected to result in personal injury, death, or property or environmental damage. NVIDIA accepts no liability for inclusion and/or use of NVIDIA products in such equipment or applications and therefore such inclusion and/or use is at customer’s own risk.\nNVIDIA makes no representation or warranty that products based on this document will be suitable for any specified use. Testing of all parameters of each product is not necessarily performed by NVIDIA. It is customer’s sole responsibility to evaluate and determine the applicability of any information contained in this document, ensure the product is suitable and fit for the application planned by customer, and perform the necessary testing for the application in order to avoid a default of the application or the product. Weaknesses in customer’s product designs may affect the quality and reliability of the NVIDIA product and may result in additional or different conditions and/or requirements beyond those contained in this document. NVIDIA accepts no liability related to any default, damage, costs, or problem which may be based on or attributable to: (i) the use of the NVIDIA product in any manner that is contrary to this document or (ii) customer product designs.\nNo license, either expressed or implied, is granted under any NVIDIA patent right, copyright, or other NVIDIA intellectual property right under this document. Information published by NVIDIA regarding third-party products or services does not constitute a license from NVIDIA to use such products or services or a warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual property rights of the third party, or a license from NVIDIA under the patents or other intellectual property rights of NVIDIA.\nReproduction of information in this document is permissible only if approved in advance by NVIDIA in writing, reproduced without alteration and in full compliance with all applicable export laws and regulations, and accompanied by all associated conditions, limitations, and notices.\nTHIS DOCUMENT AND ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, “MATERIALS”) ARE BEING PROVIDED “AS IS.” NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL NVIDIA BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Notwithstanding any damages that customer might incur for any reason whatsoever, NVIDIA’s aggregate and cumulative liability towards customer for the products described herein shall be limited in accordance with the Terms of Sale for the product.\n5.2.\nOpenCL\n\nOpenCL is a trademark of Apple Inc. used under license to the Khronos Group Inc.\n5.3.\nTrademarks\n\nNVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated.", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://docs.nvidia.com/cuda/cuda-quick-start-guide/index.html"}}
