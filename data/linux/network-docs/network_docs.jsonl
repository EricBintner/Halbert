{"text": "WireGuard: fast, modern, secure VPN tunnel\nToggle navigation\nWireGuard\nInstallation\nQuick Start\nInterworkings\nCompilation from Source Code\nProtocol & Cryptography\nFormal Verification\nCross-platform Interface\nRouting & Network Namespaces\nEmbedding into Applications\nBuild Status\nKnown Limitations\nPerformance\nProject Todo\nPresentations\nWhitepaper\nDonate\nConceptual Overview\nSimple Network Interface\nCryptokey Routing\nBuilt-in Roaming\nReady for Containers\nLearning More\nAbout The Project\nSource Code\nLicense\nWireGuard\n®\nis an extremely simple yet fast and modern VPN that utilizes\nstate-of-the-art\ncryptography\n. It aims to be\nfaster\n,\nsimpler\n, leaner, and more useful than IPsec, while avoiding the massive headache. It intends to be considerably more performant than OpenVPN. WireGuard is designed as a general purpose VPN for running on embedded interfaces and super computers alike, fit for many different circumstances. Initially released for the Linux kernel, it is now cross-platform (Windows, macOS, BSD, iOS, Android) and widely deployable. It is currently under heavy development, but already it might be regarded as the most secure, easiest to use, and simplest VPN solution in the industry.\nSimple & Easy-to-use\nWireGuard aims to be as easy to configure and deploy as SSH. A VPN connection is made simply by exchanging very simple public keys – exactly like exchanging SSH keys – and all the rest is transparently handled by WireGuard. It is even capable of roaming between IP addresses, just like\nMosh\n. There is no need to manage connections, be concerned about state, manage daemons, or worry about what's under the hood. WireGuard presents an extremely basic yet powerful interface.\nCryptographically Sound\nWireGuard uses state-of-the-art cryptography, like the\nNoise protocol framework\n,\nCurve25519\n,\nChaCha20\n,\nPoly1305\n,\nBLAKE2\n,\nSipHash24\n,\nHKDF\n, and secure trusted constructions. It makes conservative and reasonable choices and has been reviewed by cryptographers.\nMinimal Attack Surface\nWireGuard has been designed with ease-of-implementation and simplicity in mind. It is meant to be easily implemented in very few lines of code, and easily auditable for security vulnerabilities. Compared to behemoths like *Swan/IPsec or OpenVPN/OpenSSL, in which auditing the gigantic codebases is an overwhelming task even for large teams of security experts, WireGuard is meant to be comprehensively reviewable by single individuals.\nHigh Performance\nA combination of extremely high-speed cryptographic primitives and the fact that WireGuard lives inside the Linux kernel means that secure networking can be very high-speed. It is suitable for both small embedded devices like smartphones and fully loaded backbone routers.\nWell Defined & Thoroughly Considered\nWireGuard is the result of a lengthy and thoroughly considered academic process, resulting in the\ntechnical whitepaper\n, an academic research paper which clearly defines the protocol and the intense considerations that went into each decision.\nConceptual Overview\nIf you'd like a general conceptual overview of what WireGuard is about, read onward here. You then may progress to\ninstallation\nand reading\nthe quickstart instructions\non how to use it.\nIf you're interested in the internal inner workings, you might be interested in the brief summary of the\nprotocol\n, or go more in depth by reading the\ntechnical whitepaper\n, which goes into more detail on the protocol, cryptography, and fundamentals. If you intend to implement WireGuard for a new platform, please read the\ncross-platform notes\n.\nWireGuard securely encapsulates IP packets over UDP. You add a WireGuard interface, configure it with your private key and your peers' public keys, and then you send packets across it. All issues of key distribution and pushed configurations are\nout of scope\nof WireGuard; these are issues much better left for other layers, lest we end up with the bloat of IKE or OpenVPN. In contrast, it more mimics the model of SSH and Mosh; both parties have each other's public keys, and then they're simply able to begin exchanging packets through the interface.\nSimple Network Interface\nWireGuard works by adding a network interface (or multiple), like\neth0\nor\nwlan0\n, called\nwg0\n(or\nwg1\n,\nwg2\n,\nwg3\n, etc). This network interface can then be configured normally using\nifconfig(8)\nor\nip-address(8)\n, with routes for it added and removed using\nroute(8)\nor\nip-route(8)\n, and so on with all the ordinary networking utilities. The specific WireGuard aspects of the interface are configured using the\nwg(8)\ntool. This interface acts as a tunnel interface.\nWireGuard associates tunnel IP addresses with public keys and remote endpoints. When the interface sends a packet to a peer, it does the following:\nThis packet is meant for 192.168.30.8. Which peer is that? Let me look... Okay, it's for peer\nABCDEFGH\n. (Or if it's not for any configured peer, drop the packet.)\nEncrypt entire IP packet using peer\nABCDEFGH\n's public key.\nWhat is the remote endpoint of peer\nABCDEFGH\n? Let me look... Okay, the endpoint is UDP port 53133 on host 216.58.211.110.\nSend encrypted bytes from step 2 over the Internet to 216.58.211.110:53133 using UDP.\nWhen the interface receives a packet, this happens:\nI just got a packet from UDP port 7361 on host 98.139.183.24. Let's decrypt it!\nIt decrypted and authenticated properly for peer\nLMNOPQRS\n. Okay, let's remember that peer\nLMNOPQRS\n's most recent Internet endpoint is 98.139.183.24:7361 using UDP.\nOnce decrypted, the plain-text packet is from 192.168.43.89. Is peer\nLMNOPQRS\nallowed to be sending us packets as 192.168.43.89?\nIf so, accept the packet on the interface. If not, drop it.\nBehind the scenes there is much happening to provide proper privacy, authenticity, and perfect forward secrecy, using state-of-the-art cryptography.\nCryptokey Routing\nAt the heart of WireGuard is a concept called\nCryptokey Routing\n, which works by associating public keys with a list of tunnel IP addresses that are allowed inside the tunnel. Each network interface has a private key and a list of peers. Each peer has a public key. Public keys are short and simple, and are used by peers to authenticate each other. They can be passed around for use in configuration files by any out-of-band method, similar to how one might send their SSH public key to a friend for access to a shell server.\nFor example, a server computer might have this configuration:\n[Interface]\nPrivateKey = yAnz5TF+lXXJte14tji3zlMNq+hd2rYUIgJBgB3fBmk=\nListenPort = 51820\n[Peer]\nPublicKey = xTIBA5rboUvnH4htodjb6e697QjLERt1NAB4mZqp8Dg=\nAllowedIPs = 10.192.122.3/32, 10.192.124.1/24\n[Peer]\nPublicKey = TrMvSoP4jYQlY6RIzBgbssQqY3vxI2Pi+y71lOWWXX0=\nAllowedIPs = 10.192.122.4/32, 192.168.0.0/16\n[Peer]\nPublicKey = gN65BkIKy1eCE9pP1wdc8ROUtkHLF2PfAqYdyYBz6EA=\nAllowedIPs = 10.10.10.230/32\nAnd a client computer might have this simpler configuration:\n[Interface]\nPrivateKey = gI6EdUSYvn8ugXOt8QQD6Yc+JyiZxIhp3GInSWRfWGE=\nListenPort = 21841\n[Peer]\nPublicKey = HIgo9xNzJMWLKASShiTqIybxZ0U3wGLiUeJ1PKf8ykw=\nEndpoint = 192.95.5.69:51820\nAllowedIPs = 0.0.0.0/0\nIn the server configuration, each peer (a client) will be able to send packets to the network interface with a source IP matching his corresponding list of allowed IPs. For example, when a packet is received by the server from peer\ngN65BkIK...\n, after being decrypted and authenticated, if its source IP is 10.10.10.230, then it's allowed onto the interface; otherwise it's dropped.\nIn the server configuration, when the network interface wants to send a packet to a peer (a client), it looks at that packet's destination IP and compares it to each peer's list of allowed IPs to see which peer to send it to. For example, if the network interface is asked to send a packet with a destination IP of 10.10.10.230, it will encrypt it using the public key of peer\ngN65BkIK...\n, and then send it to that peer's most recent Internet endpoint.\nIn the client configuration, its single peer (the server) will be able to send packets to the network interface with\nany\nsource IP (since 0.0.0.0/0 is a wildcard). For example, when a packet is received from peer\nHIgo9xNz...\n, if it decrypts and authenticates correctly, with any source IP, then it's allowed onto the interface; otherwise it's dropped.\nIn the client configuration, when the network interface wants to send a packet to its single peer (the server), it will encrypt packets for the single peer with\nany\ndestination IP address (since 0.0.0.0/0 is a wildcard). For example, if the network interface is asked to send a packet with any destination IP, it will encrypt it using the public key of the single peer\nHIgo9xNz...\n, and then send it to the single peer's most recent Internet endpoint.\nIn other words, when sending packets, the list of allowed IPs behaves as a sort of routing table, and when receiving packets, the list of allowed IPs behaves as a sort of access control list.\nThis is what we call a\nCryptokey Routing Table\n: the simple association of public keys and allowed IPs.\nAny combination of IPv4 and IPv6 can be used, for any of the fields. WireGuard is fully capable of encapsulating one inside the other if necessary.\nBecause all packets sent on the WireGuard interface are encrypted and authenticated, and because there is such a tight coupling between the identity of a peer and the allowed IP address of a peer, system administrators do not need complicated firewall extensions, such as in the case of IPsec, but rather they can simply match on \"is it from this IP? on this interface?\", and be assured that it is a secure and authentic packet. This greatly simplifies network management and access control, and provides a great deal more assurance that your iptables rules are actually doing what you intended for them to do.\nBuilt-in Roaming\nThe client configuration contains an\ninitial\nendpoint of its single peer (the server), so that it knows where to send encrypted data before it has received encrypted data. The server configuration doesn't have any initial endpoints of its peers (the clients). This is because the server discovers the endpoint of its peers by examining from where correctly authenticated data originates. If the server itself changes its own endpoint, and sends data to the clients, the clients will discover the new server endpoint and update the configuration just the same. Both client and server send encrypted data to the most recent IP endpoint for which they authentically decrypted data. Thus, there is full IP roaming on both ends.\nReady for Containers\nWireGuard\nsends and receives encrypted packets using the network namespace in which the WireGuard interface was originally created\n. This means that you can create the WireGuard interface in your main network namespace, which has access to the Internet, and then move it into a network namespace belonging to a Docker container as that container's\nonly\ninterface. This ensures that the only possible way that container is able to access the network is through a secure encrypted WireGuard tunnel.\nLearning More\nConsider glancing at the\ncommands & quick start\nfor a good idea of how WireGuard is used in practice. There is also a\ndescription of the protocol, cryptography, & key exchange\n, in addition to the\ntechnical whitepaper\n, which provides the most detail.\nAbout The Project\nSource Code\nWireGuard is divided into\nseveral repositories\nhosted in the ZX2C4 Git Repository and elsewhere. Consult the project\nrepository list\n.\nIRC Discussions\nIf you're having trouble setting up WireGuard or using it, the best place to get help is the\n#wireguard\nIRC channel on Libera.Chat\n. We also discuss development tasks there and plan the future of the project.\nMailing List\nGet involved in the WireGuard development discussion by\njoining the mailing list\n. This is where all development activities occur. Submit patches using\ngit-send-email\n, similar to the style of LKML.\nEmail Contact\nIf you'd like to contact us privately for a particular reason, you may reach us at\nteam@wireguard.com\n. Keep in mind, though, that \"support\" requests are much better suited for our IRC channel.\nSecurity Contact\nPlease report any security issues to, and only to,\nsecurity@wireguard.com\n. Do not send non-security-related issues to this email alias. Do not send security-related issues to different email addresses.\nLicense\nThe kernel components are released under the GPLv2, as is the Linux kernel itself. Other projects are licensed under MIT, BSD, Apache 2.0, or GPL, depending on context.", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://www.wireguard.com/"}}
{"text": "Quick Start - WireGuard\nToggle navigation\nWireGuard\nInstallation\nQuick Start\nInterworkings\nCompilation from Source Code\nProtocol & Cryptography\nFormal Verification\nCross-platform Interface\nRouting & Network Namespaces\nEmbedding into Applications\nBuild Status\nKnown Limitations\nPerformance\nProject Todo\nPresentations\nWhitepaper\nDonate\nQuick Start\nSide by Side Video\nCommand-line Interface\nKey Generation\nNAT and Firewall Traversal Persistence\nDemo Server\nDebug Info\nQuick Start\nYou'll first want to make sure you have a decent grasp of the\nconceptual overview\n, and then\ninstall WireGuard\n. After that, read onwards here.\nSide by Side Video\nBefore explaining the actual comands in detail, it may be extremely instructive to first watch them being used by two peers being configured side by side:\nOr individually, a single configuration looks like:\nCommand-line Interface\nA new interface can be added via\nip-link(8)\n, which should automatically handle module loading:\n# ip link add dev wg0 type wireguard\n(Non-Linux users will instead write\nwireguard-go wg0\n.)\nAn IP address and peer can be assigned with\nifconfig(8)\nor\nip-address(8)\n# ip address add dev wg0 192.168.2.1/24\nOr, if there are only two peers total, something like this might be more desirable:\n# ip address add dev wg0 192.168.2.1 peer 192.168.2.2\nThe interface can be configured with keys and peer endpoints with the included\nwg(8)\nutility:\n# wg setconf wg0 myconfig.conf\nor\n# wg set wg0 listen-port 51820 private-key /path/to/private-key peer ABCDEF... allowed-ips 192.168.88.0/24 endpoint 209.202.254.14:8172\nFinally, the interface can then be activated with\nifconfig(8)\nor\nip-link(8)\n:\n# ip link set up dev wg0\nThere are also the\nwg show\nand\nwg showconf\ncommands, for viewing the current configuration. Calling\nwg\nwith no arguments defaults to calling\nwg show\non all WireGuard interfaces.\nConsult the man page of\nwg(8)\nfor more information.\nMuch of the routine bring-up and tear-down dance of\nwg(8)\nand\nip(8)\ncan be automated by the included\nwg-quick(8)\ntool\n:\nKey Generation\nWireGuard requires base64-encoded public and private keys. These can be generated using the\nwg(8)\nutility:\n$ umask 077\n$ wg genkey > privatekey\nThis will create\nprivatekey\non stdout containing a new private key.\nYou can then derive your public key from your private key:\n$ wg pubkey < privatekey > publickey\nThis will read\nprivatekey\nfrom stdin and write the corresponding public key to\npublickey\non stdout.\nOf course, you can do this all at once:\n$ wg genkey | tee privatekey | wg pubkey > publickey\nNAT and Firewall Traversal Persistence\nBy default, WireGuard tries to be as silent as possible when not being used; it is not a chatty protocol. For the most part, it only transmits data when a peer wishes to send packets. When it's not being asked to send packets, it stops sending packets until it is asked again. In the majority of configurations, this works well. However, when a peer is behind NAT or a firewall, it might wish to be able to receive incoming packets even when it is not sending any packets. Because NAT and stateful firewalls keep track of \"connections\", if a peer behind NAT or a firewall wishes to receive incoming packets, he must keep the NAT/firewall mapping valid, by periodically sending keepalive packets. This is called\npersistent keepalives\n. When this option is enabled, a keepalive packet is sent to the server endpoint once every\ninterval\nseconds. A sensible interval that works with a wide variety of firewalls is 25 seconds. Setting it to 0 turns the feature off, which is the default, since most users will not need this, and it makes WireGuard slightly more chatty. This feature may be specified by adding the\nPersistentKeepalive =\nfield to a peer in the configuration file, or setting\npersistent-keepalive\nat the command line. If you don't need this feature, don't enable it. But if you're behind NAT or a firewall and you want to receive incoming connections long after network traffic has gone silent, this option will keep the \"connection\" open in the eyes of NAT.\nDemo Server\nAfter\ninstalling\nWireGuard, if you'd like to try sending some packets through WireGuard, you may use, for testing purposes only, the script in\ncontrib/ncat-client-server/client.sh\n.\n$ sudo contrib/examples/ncat-client-server/client.sh\nThis will automatically setup interface\nwg0\n, through a very insecure transport that is only suitable for demonstration purposes. You can then try loading the hidden website or sending pings:\n$ chromium http://192.168.4.1\n$ ping 192.168.4.1\nIf you'd like to redirect your internet traffic, you can run it like this:\n$ sudo contrib/examples/ncat-client-server/client.sh default-route\n$ curl zx2c4.com/ip\n163.172.161.0\ndemo.wireguard.com\ncurl/7.49.1\nBy connecting to this server, you acknowledge that you will not use it for any abusive or illegal purposes and that your traffic may be monitored.\nDebug Info\nIf you're using the Linux kernel module and your kernel supports dynamic debugging, you can get useful runtime output by enabling dynamic debug for the module:\n# modprobe wireguard && echo module wireguard +p > /sys/kernel/debug/dynamic_debug/control\nIf you're using a userspace implementation, set the environment variable\nexport LOG_LEVEL=verbose\n.", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://www.wireguard.com/quickstart/"}}
{"text": "Installation - WireGuard\nToggle navigation\nWireGuard\nInstallation\nQuick Start\nInterworkings\nCompilation from Source Code\nProtocol & Cryptography\nFormal Verification\nCross-platform Interface\nRouting & Network Namespaces\nEmbedding into Applications\nBuild Status\nKnown Limitations\nPerformance\nProject Todo\nPresentations\nWhitepaper\nDonate\nInstallation\nWindows [7, 8.1, 10, 11, 2008R2, 2012R2, 2016, 2019, 2022]\nmacOS [app store]\nUbuntu [module & tools]\nAndroid [play store & direct apk file]\niOS [app store]\nDebian [module & tools]\nFedora [tools]\nMageia [tools]\nArch [module & tools]\nOpenSUSE/SLE [tools]\nSlackware [tools]\nAlpine [tools]\nGentoo [module & tools]\nExherbo [module & tools]\nNixOS [module & tools]\nNix on Darwin [userspace go & tools]\nOpenWRT [tools]\nOracle Linux 8 [UEK6 & tools]\nRed Hat Enterprise Linux 8 [module-kmod, module-dkms, & tools]\nCentOS 8 [module-plus, module-kmod, module-dkms, & tools]\nOracle Linux 7 [UEK6 & tools]\nRed Hat Enterprise Linux 7 [module-kmod, module-dkms, & tools]\nCentOS 7 [module-plus, module-kmod, module-dkms, & tools]\nFreeBSD [kmod, userspace go & tools]\nOpenBSD [tools]\nTermux [tools]\nVoid [module & tools]\nAdélie Linux [module & tools]\nSource Mage [tools]\nBuildroot [module & tools]\nEdgeOS [module & tools]\nAstLinux [module & tools]\nMilis [module & tools]\nmacOS Homebrew and MacPorts – Basic CLI [homebrew userspace go & homebrew tools] & [macports userspace go & macports tools]\nInstallation\nWindows\n[7, 8.1, 10, 11, 2008R2, 2012R2, 2016, 2019, 2022\n]\nDownload Windows Installer\nBrowse MSIs\nmacOS\n[\napp store\n]\nDownload from App Store\nUbuntu\n[\nmodule\n&\ntools\n]\n$ sudo apt install wireguard\nAndroid\n[\nplay store\n& direct apk file\n]\nDownload from Play Store\nDownload APK File\niOS\n[\napp store\n]\nDownload from App Store\nDebian\n[\nmodule\n&\ntools\n]\n# apt install wireguard\nUsers with Debian releases older than Bullseye should\nenable backports\n.\nFedora\n[\ntools\n]\n$ sudo dnf install wireguard-tools\nMageia\n[\ntools\n]\n$ sudo urpmi wireguard-tools\nArch\n[\nmodule\n&\ntools\n]\n$ sudo pacman -S wireguard-tools\nUsers of kernels < 5.6 may also choose\nwireguard-lts\nor\nwireguard-dkms\n+\nlinux-headers\n, depending on which kernel is used.\nOpenSUSE/SLE\n[\ntools\n]\n$ sudo zypper install wireguard-tools\nSlackware\n[\ntools\n]\n$ sudo slackpkg install wireguard-tools\nAlpine\n[\ntools\n]\n# apk add -U wireguard-tools\nGentoo\n[\nmodule\n&\ntools\n]\n# emerge wireguard-tools\nThe\nwireguard-modules\nebuild also exists for compatibility with older kernels.\nExherbo\n[\nmodule\n&\ntools\n]\n# cave resolve -x wireguard\nNixOS\n[\nmodule\n&\ntools\n]\nboot.extraModulePackages = [ config.boot.kernelPackages.wireguard ];\nenvironment.systemPackages = [ pkgs.wireguard pkgs.wireguard-tools ];\nNix on Darwin\n[\nuserspace go\n&\ntools\n]\n$ nix-env -iA nixpkgs.wireguard-tools\nOpenWRT\n[\ntools\n]\n# opkg install wireguard\nFurther installation and configuration instructions may be found on the\nwiki\n.\nOracle Linux 8\n[\nUEK6 & tools\n]\n# dnf install oraclelinux-developer-release-el8\n# dnf config-manager --disable ol8_developer\n# dnf config-manager --enable ol8_developer_UEKR6\n# dnf config-manager --save --setopt=ol8_developer_UEKR6.includepkgs='wireguard-tools*'\n# dnf install wireguard-tools\nRed Hat Enterprise Linux 8\n[\nmodule-kmod\n,\nmodule-dkms\n, &\ntools\n]\nMethod 1: the easiest way is via ELRepo's pre-built module:\n$ sudo yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm https://www.elrepo.org/elrepo-release-8.el8.elrepo.noarch.rpm\n$ sudo yum install kmod-wireguard wireguard-tools\nMethod 2: users running non-standard kernels may wish to use the DKMS package instead:\n$ sudo yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm\n$ sudo subscription-manager repos --enable codeready-builder-for-rhel-8-$(arch)-rpms\n$ sudo yum copr enable jdoss/wireguard\n$ sudo yum install wireguard-dkms wireguard-tools\nCentOS 8\n[\nmodule-plus\n,\nmodule-kmod\n,\nmodule-dkms\n, &\ntools\n]\nMethod 1: a signed module is available as built-in to CentOS's kernel-plus:\n$ sudo yum install yum-utils epel-release\n$ sudo yum-config-manager --setopt=centosplus.includepkgs=\"kernel-plus, kernel-plus-*\" --setopt=centosplus.enabled=1 --save\n$ sudo sed -e 's/^DEFAULTKERNEL=kernel-core$/DEFAULTKERNEL=kernel-plus-core/' -i /etc/sysconfig/kernel\n$ sudo yum install kernel-plus wireguard-tools\n$ sudo reboot\nMethod 2: the easiest way is via ELRepo's pre-built module:\n$ sudo yum install elrepo-release epel-release\n$ sudo yum install kmod-wireguard wireguard-tools\nMethod 3: users running non-standard kernels may wish to use the DKMS package instead:\n$ sudo yum install epel-release\n$ sudo yum config-manager --set-enabled PowerTools\n$ sudo yum copr enable jdoss/wireguard\n$ sudo yum install wireguard-dkms wireguard-tools\nOracle Linux 7\n[\nUEK6 & tools\n]\n# yum install oraclelinux-developer-release-el7\n# yum-config-manager --disable ol7_developer\n# yum-config-manager --enable ol7_developer_UEKR6\n# yum-config-manager --save --setopt=ol7_developer_UEKR6.includepkgs='wireguard-tools*'\n# yum install wireguard-tools\nRed Hat Enterprise Linux 7\n[\nmodule-kmod\n,\nmodule-dkms\n, &\ntools\n]\nMethod 1: the easiest way is via ELRepo's pre-built module:\n$ sudo yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm\n$ sudo yum install kmod-wireguard wireguard-tools\nMethod 2: users running non-standard kernels may wish to use the DKMS package instead:\n$ sudo yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm\n$ sudo curl -o /etc/yum.repos.d/jdoss-wireguard-epel-7.repo https://copr.fedorainfracloud.org/coprs/jdoss/wireguard/repo/epel-7/jdoss-wireguard-epel-7.repo\n$ sudo yum install wireguard-dkms wireguard-tools\nCentOS 7\n[\nmodule-plus\n,\nmodule-kmod\n,\nmodule-dkms\n, &\ntools\n]\nMethod 1: a signed module is available as built-in to CentOS's kernel-plus:\n$ sudo yum install yum-utils epel-release\n$ sudo yum-config-manager --setopt=centosplus.includepkgs=kernel-plus --enablerepo=centosplus --save\n$ sudo sed -e 's/^DEFAULTKERNEL=kernel$/DEFAULTKERNEL=kernel-plus/' -i /etc/sysconfig/kernel\n$ sudo yum install kernel-plus wireguard-tools\n$ sudo reboot\nMethod 2: users wishing to stick with the standard kernel may use ELRepo's pre-built module:\n$ sudo yum install epel-release elrepo-release\n$ sudo yum install yum-plugin-elrepo\n$ sudo yum install kmod-wireguard wireguard-tools\nMethod 3: users running non-standard kernels may wish to use the DKMS package instead:\n$ sudo yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm\n$ sudo curl -o /etc/yum.repos.d/jdoss-wireguard-epel-7.repo https://copr.fedorainfracloud.org/coprs/jdoss/wireguard/repo/epel-7/jdoss-wireguard-epel-7.repo\n$ sudo yum install wireguard-dkms wireguard-tools\nFreeBSD\n[\nkmod\n,\nuserspace go\n&\ntools\n]\n# pkg install wireguard\nOpenBSD\n[\ntools\n]\n# pkg_add wireguard-tools\nTermux\n[\ntools\n]\n# pkg install wireguard-tools\nVoid\n[\nmodule\n&\ntools\n]\n# xbps-install -S wireguard-tools wireguard-dkms\nAdélie Linux\n[\nmodule\n&\ntools\n]\n# apk add wireguard-tools wireguard-module\nSource Mage\n[\ntools\n]\n# cast wireguard-tools\nBuildroot\n[\nmodule\n&\ntools\n]\nBR2_PACKAGE_WIREGUARD_LINUX_COMPAT=y\nBR2_PACKAGE_WIREGUARD_TOOLS=y\nEdgeOS\n[\nmodule\n&\ntools\n]\n$ sudo dpkg -i wireguard-{type}-{version}.deb\nFirst download the correct prebuilt file from the\nrelease page\n, and then install it with\ndpkg\nas above.\nAstLinux\n[\nmodule\n&\ntools\n]\nBR2_PACKAGE_WIREGUARD_TOOLS=y\nBR2_PACKAGE_WIREGUARD=y\nMilis\n[\nmodule\n&\ntools\n]\n# mps kur wireguard-tools wireguard-linux-compat\nmacOS Homebrew and MacPorts – Basic CLI\n[\nhomebrew userspace go\n&\nhomebrew tools\n] & [\nmacports userspace go\n&\nmacports tools\n]\n$ brew install wireguard-tools\nor\n$ port install wireguard-tools\nSee the\ncross-platform documentation\nfor more information.\n*** Move on to the\nquick start walkthrough\n. *** Or, if your distribution isn't listed above, you may easily\ncompile from source instead\n, a fairly simple procedure.", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://www.wireguard.com/install/"}}
{"text": "2x HOW TO\nSkip to main content\nToggle navigation\nSelect version\nVideos\nprint\nToggle navigation\nCommunity Documentation\nGetting Started\n2x HOW TO\nPrev\nNext\n2x HOW TO\nAbstract\nStep-by-step guides and tutorials for OpenVPN. Learn how to configure and set up VPNs.\nIntroduction\nOpenVPN is a full-featured SSL VPN that implements OSI layer 2 or 3 secure network extension using the industry standard SSL/TLS protocol, supports flexible client authentication methods based on certificates, smart cards, and/or username/password credentials, and allows user or group-specific access control policies using firewall rules applied to the VPN virtual interface. OpenVPN is not a web application proxy and does not operate through a web browser.\nOpenVPN 2.0 expands on the capabilities ofÂ OpenVPN 1.xÂ by offering a scalable client/server mode, allowing multiple clients to connect to a single OpenVPN server process over a single TCP or UDP port.\nOpenVPN 2.3 includesÂ many improvements\n, including complete IPv6 and PolarSSL support.\nThis topic provides step-by-step instructions for configuring an OpenVPN 2.x client/server VPN, including:\nOpenVPN Quickstart\n.\nInstalling OpenVPN\n.\nDetermining Whether To Use a Routed or Bridged VPN\n.\nNumbering Private Subnets\n.\nSetting Up Your Own Certificate Authority (CA) and Generating Certificates and Keys for an OpenVPN Server and Multiple Clients\n.\nCreating Configuration Files for Server and Clients\n.\nStarting Up the VPN and Testing for Initial Connectivity\n.\nConfiguring OpenVPN To Run Automatically On System Startup\n.\nControlling a Running OpenVPN Process\n.\nExpanding the Scope of the VPN to Include Additional Machines on Either the Client or Server Subnet\n.\nPushing DHCP Options to Clients\n.\nConfiguring Client-Specific Rules and Access Policies\n.\nUsing Alternative Authentication Methods\n.\nHow to Add Dual-Factor Authentication to an OpenVPN Configuration Using Client-Side Smart Cards\n.\nHow to Add Dual-Factor Authentication to an OpenVPN Configuration Using Client-Side Smart Cards\nRouting All Client Traffic (Including Web Traffic) Through the VPN\n.\nRunning an OpenVPN Server on a Dynamic IP Address\n.\nConnecting To an OpenVPN Server Via an HTTP Proxy\n.\nConnecting To a Samba Share Over OpenVPN\n.\nImplementing a Load-Balancing/Failover Configuration\n.\nHardening OpenVPN Security\n.\nRevoking Certificates\n.\nImportant Note On Possible \"Man-in-the-Middle\" Attack if Clients Do Not Verify the Certificate of the Server They Are Connecting To\n.\nThe impatient may wish to jump straight to the sample configuration files:\nServer configuration file\n.\nClient configuration file\n.\nIntended Audience\nThis HOWTO assumes that readers possess a prior understanding of basic networking concepts such as IP addresses, DNS names, netmasks, subnets, IP routing, routers, network interfaces, LANs, gateways, and firewall rules.\nAdditional Documentation\nOpenVPN Books\nRefer to the\nOpenVPN books page\n.\nOpenVPN Articles\nFor additional documentation:\nOpenVPN articles\nOpenVPN wiki\nIn this section\n:\n2x HOW TO\nIntroduction\nIntended Audience\nAdditional Documentation\nOpenVPN Books\nOpenVPN Articles\nSearch results\nNo results found\nWas this helpful?\nYes\nNo\nPrev\nNext", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://openvpn.net/community-resources/how-to/"}}
{"text": "OpenVPN 2.6 Manual\nSkip to main content\nToggle navigation\nSelect version\nVideos\nprint\nToggle navigation\nCommunity Articles\nOpenVPN 2.6 Manual\nPrev\nNext\nOpenVPN 2.6 Manual\nAbstract\nOpen-source OpenVPN 2.6 user manual for VPN server and client configurations.\nINTRODUCTION\nOpenVPN is an open-source VPN daemon by James Yonan. Because OpenVPN aims to be a universal VPN tool, offering a great deal of flexibility, this manual page presents numerous options. If you're new to OpenVPN, you might want to skip ahead to the examples section, where you will see how to construct simple VPNs on the command line without even needing a configuration file.\nThe\nOpenVPN website\nhas more documentation and examples.\nIf you would like to see a shorter version of this manual, refer to the OpenVPN usage message, which can be obtained by running\nopenvpn\nwithout any parameters.\nDESCRIPTION\nOpenVPN is a robust and highly flexible VPN daemon. OpenVPN supports:\nSSL/TLS security.\nEthernet bridging.\nTCP or UDP tunnel transport through proxies or Network Address Translation (NAT).\nDynamic IP addresses and DHCP.\nScalability to hundreds or thousands of users.\nPortability to most major OS platforms.\nOpenVPN is tightly integrated with the OpenSSL library and derives many of its cryptographic capabilities from it.\nOpenVPN supports conventional encryption using a pre-shared secret key\n(Static Key mode)\nor public key security\n(SSL/TLS mode)\nusing client and server certificates. OpenVPN also supports non-encrypted TCP and UDP tunnels.\nOpenVPN is designed to work with the\nTUN/TAP\nvirtual networking interface, which is available on most platforms.\nOverall, OpenVPN aims to offer many of the key features of IPSec but with a relatively lightweight footprint.\nOPTIONS\nOpenVPN allows any option to be placed either on the command line or in a configuration file. Though all command line options are preceded by a double-leading-dash (\"--\"), this prefix can be removed when an option is placed in a configuration file.\nGeneric Options\nThis section covers generic options which are accessible regardless of which mode OpenVPN is configured as.\n--help\nShow options.\n--auth-nocache\nDon't cache --askpass or --auth-user-pass username/passwords in virtual memory.\nIf specified, this directive will cause OpenVPN to immediately forget username/password inputs after they are used. As a result, when OpenVPN needs a username/password, it will prompt for input from stdin, which may be multiple times during the duration of an OpenVPN session. When using --auth-nocache in combination with a user/password file and --chroot or --daemon, make sure to use an absolute path.\nThis directive does not affect the --http-proxy username/password. It is always cached.\n--cd dir\nChange directory to dir prior to reading any files such as configuration files, key files, scripts, etc. dir should be an absolute path, with a leading \"/\", and without any references to the current directory such as\n.\nor\n..\n.\nThis option is useful when you are running OpenVPN in --daemon mode, and you want to consolidate all of your OpenVPN control files in one location.\n--chroot dir\nChroot to dir after initialization. --chroot essentially redefines dir as being the top level directory tree (/). OpenVPN will therefore be unable to access any files outside this tree. This can be desirable from a security standpoint.\nSince the chroot operation is delayed until after initialization, most OpenVPN options that reference files will operate in a pre-chroot context. In many cases, the dir parameter can point to an empty directory, however complications can result when scripts or restarts are executed after the chroot operation.\nNote: The SSL library will probably need /dev/urandom to be available inside the chroot directory dir. This is because SSL libraries occasionally need to collect fresh randomness. Newer linux kernels and some BSDs implement a getrandom() or getentropy() syscall that removes the need for /dev/urandom to be available.\n--compat-mode version\nThis option provides a convenient way to alter the defaults of OpenVPN to be more compatible with the version version specified. All of the changes this option applies can also be achieved using individual configuration options.\nThe version specified with this option is the version of OpenVPN peer OpenVPN should try to be compatible with. In general OpenVPN should be compatible with the last two previous version without this option. E.g. OpenVPN 2.6.0 should be compatible with 2.5.x and 2.4.x without this option. However, there might be some edge cases that still require this option even in these cases. Note: Using this option reverts defaults to no longer recommended values and should be avoided if possible. The following table details what defaults are changed depending on the version specified.\n2.5.x or lower: --allow-compression asym is automatically added to the configuration if no other compression options are present.\n2.4.x or lower: The cipher in --cipher is appended to --data-ciphers.\n2.3.x or lower: --data-ciphers-fallback is automatically added with the same cipher as --cipher.\n2.3.6 or lower: --tls-version-min 1.0 is added to the configuration when --tls-version-min is not explicitly set.\nIf not required, this is option should be avoided. Setting this option can lower security or disable features like data-channel offloading.\n--config file\nLoad additional config options from file where each line corresponds to one command line option, but with the leading\n--\nremoved.\nIf --config file is the only option to the openvpn command, the --config can be removed, and the command can be given as openvpn file Note that configuration files can be nested to a reasonable depth. Double quotation or single quotation characters (\"\", '') can be used to enclose single parameters containing whitespace, and \"#\" or \";\" characters in the first column can be used to denote comments. Note that OpenVPN 2.0 and higher performs backslash-based shell escaping for characters not in single quotations, so the following mappings should be observed:\n\\\\       Maps to a single backslash character (\\).\n\\\"       Pass a literal doublequote character (\"), don't\ninterpret it as enclosing a parameter.\n\\[SPACE] Pass a literal space or tab character, don't\ninterpret it as a parameter delimiter.\nFor example on Windows, use double backslashes to represent pathnames:\nsecret \"c:\\\\OpenVPN\\\\secret.key\"\nFor examples of configuration files, see\nHow To\n. Here is an example configuration file:\n#\n# Sample OpenVPN configuration file for\n# using a pre-shared static key.\n#\n# '#' or ';' may be used to delimit comments.\n# Use a dynamic tun device.\ndev tun\n# Our remote peer\nremote mypeer.mydomain\n# 10.1.0.1 is our local VPN endpoint\n# 10.1.0.2 is our remote VPN endpoint\nifconfig 10.1.0.1 10.1.0.2\n# Our pre-shared static key\nsecret static.key\n--daemon progname\nBecome a daemon after all initialization functions are completed.\nValid syntaxes:\ndaemon\ndaemon progname\nThis option will cause all message and error output to be sent to the syslog file (such as\n/var/log/messages\n), except for the output of scripts and ifconfig commands, which will go to\n/dev/null\nunless otherwise redirected. The syslog redirection occurs immediately at the point that --daemon is parsed on the command line even though the daemonization point occurs later. If one of the --log options is present, it will supersede syslog redirection. The optional progname parameter will cause OpenVPN to report its program name to the system logger as progname. This can be useful in linking OpenVPN messages in the syslog file with specific tunnels. When unspecified, progname defaults to\nopenvpn\n. When OpenVPN is run with the --daemon option, it will try to delay daemonization until the majority of initialization functions which are capable of generating fatal errors are complete. This means that initialization scripts can test the return status of the openvpn command for a fairly reliable indication of whether the command has correctly initialized and entered the packet forwarding event loop. In OpenVPN, the vast majority of errors which occur after initialization are non-fatal. Note: as soon as OpenVPN has daemonized, it can not ask for usernames, passwords, or key pass phrases anymore. This has certain consequences, namely that using a password-protected private key will fail unless the --askpass option is used to tell OpenVPN to ask for the pass phrase (this requirement is new in v2.3.7, and is a consequence of calling daemon() before initializing the crypto layer).\nFurther, using --daemon together with --auth-user-pass (entered on console) and --auth-nocache will fail as soon as key renegotiation (and reauthentication) occurs.\n--disable-dco\nDisable \"data channel offload\" (DCO).\nOn Linux don't use the ovpn-dco device driver, but rather rely on the legacy tun module.\nYou may want to use this option if your server needs to allow clients older than version 2.4 to connect.\n--disable-occ\nDEPRECATED\nDisable \"options consistency check\" (OCC) in configurations that do not use TLS.\nDon't output a warning message if option inconsistencies are detected between peers. An example of an option inconsistency would be where one peer uses --dev tun while the other peer uses --dev tap.\nUse of this option is discouraged, but is provided as a temporary fix in situations where a recent version of OpenVPN must connect to an old version.\n--engine engine-name\nEnable OpenSSL hardware-based crypto engine functionality.\nValid syntaxes:\nengine\nengine engine-name\nIf engine-name is specified, use a specific crypto engine. Use the --show-engines standalone option to list the crypto engines which are supported by OpenSSL.\n--fast-io\nOptimize TUN/TAP/UDP I/O writes by avoiding a call to poll/epoll/select prior to the write operation. The purpose of such a call would normally be to block until the device or socket is ready to accept the write. Such blocking is unnecessary on some platforms which don't support write blocking on UDP sockets or TUN/TAP devices. In such cases, one can optimize the event loop by avoiding the poll/epoll/select call, improving CPU efficiency by 5% to 10%.\nThis option can only be used on non-Windows systems, when --proto udp is specified, and when --shaper is\nNOT\nspecified.\n--group group\nSimilar to the --user option, this option changes the group ID of the OpenVPN process to group after initialization.\n--ignore-unknown-option args\nValid syntax:\nignore-unknown-options opt1 opt2 opt3 ... optN\nWhen one of options opt1 ... optN is encountered in the configuration file the configuration file parsing does not fail if this OpenVPN version does not support the option. Multiple --ignore-unknown-option options can be given to support a larger number of options to ignore. This option should be used with caution, as there are good security reasons for having OpenVPN fail if it detects problems in a config file. Having said that, there are valid reasons for wanting new software features to gracefully degrade when encountered by older software versions.\n--ignore-unknown-option is available since OpenVPN 2.3.3.\n--iproute cmd\nSet alternate command to execute instead of default iproute2 command. May be used in order to execute OpenVPN in unprivileged environment.\n--keying-material-exporter args\nSave Exported Keying Material [RFC5705] of len bytes (must be between 16 and 4095 bytes) using label in environment (\nexported_keying_material\n) for use by plugins in\nOPENVPN_PLUGIN_TLS_FINAL\ncallback.\nValid syntax:\nkeying-material-exporter label len\nNote that exporter labels have the potential to collide with existing PRF labels. In order to prevent this, labels\nMUST\nbegin with\nEXPORTER\n.\n--mlock\nDisable paging by calling the POSIX mlockall function. Requires that OpenVPN be initially run as root (though OpenVPN can subsequently downgrade its UID using the --user option).\nUsing this option ensures that key material and tunnel data are never written to disk due to virtual memory paging operations which occur under most modern operating systems. It ensures that even if an attacker was able to crack the box running OpenVPN, he would not be able to scan the system swap file to recover previously used ephemeral keys, which are used for a period of time governed by the --reneg options (see below), then are discarded. The downside of using --mlock is that it will reduce the amount of physical memory available to other applications. The limit on how much memory can be locked and how that limit is enforced are OS-dependent. On Linux the default limit that an unprivileged process may lock (RLIMIT_MEMLOCK) is low, and if privileges are dropped later, future memory allocations will very likely fail. The limit can be increased using ulimit or systemd directives depending on how OpenVPN is started.\nIf the platform has the getrlimit(2) system call, OpenVPN will check for the amount of mlock-able memory before calling mlockall(2), and tries to increase the limit to 100 MB if less than this is configured. 100 Mb is somewhat arbitrary - it is enough for a moderately-sized OpenVPN deployment, but the memory usage might go beyond that if the number of concurrent clients is high.\n--nice n\nChange process priority after initialization (n greater than 0 is lower priority, n less than zero is higher priority).\n--persist-key\nDon't re-read key files across\nSIGUSR1\nor --ping-restart.\nThis option can be combined with --user to allow restarts triggered by the\nSIGUSR1\nsignal. Normally if you drop root privileges in OpenVPN, the daemon cannot be restarted since it will now be unable to re-read protected key files.\nThis option solves the problem by persisting keys across\nSIGUSR1\nresets, so they don't need to be re-read.\n--providers providers\nLoad the list of (OpenSSL) providers. This is mainly useful for using an external provider for key management like tpm2-openssl or to load the legacy provider with\n--providers legacy default\nBehaviour of changing this option between\nSIGHUP\nmight not be well behaving. If you need to change/add/remove this option, fully restart OpenVPN.\n--remap-usr1 signal\nControl whether internally or externally generated\nSIGUSR1\nsignals are remapped to\nSIGHUP\n(restart without persisting state) or\nSIGTERM\n(exit).\nsignal can be set to\nSIGHUP\nor\nSIGTERM\n. By default, no remapping occurs.\n--script-security level\nThis directive offers policy-level control over OpenVPN's usage of external programs and scripts. Lower level values are more restrictive, higher values are more permissive. Settings for level:\n0\nStrictly no calling of external programs.\n1\n(Default) Only call built-in executables such as ifconfig, ip, route, or netsh.\n2\nAllow calling of built-in executables and user-defined scripts.\n3\nAllow passwords to be passed to scripts via environmental variables (potentially unsafe).\nOpenVPN releases before v2.3 also supported a method flag which indicated how OpenVPN should call external commands and scripts. This could be either\nexecve\nor\nsystem\n. As of OpenVPN 2.3, this flag is no longer accepted. In most *nix environments the execve() approach has been used without any issues. Some directives such as --up allow options to be passed to the external script. In these cases make sure the script name does not contain any spaces or the configuration parser will choke because it can't determine where the script name ends and script options start. To run scripts in Windows in earlier OpenVPN versions you needed to either add a full path to the script interpreter which can parse the script or use the system flag to run these scripts. As of OpenVPN 2.3 it is now a strict requirement to have full path to the script interpreter when running non-executables files. This is not needed for executable files, such as .exe, .com, .bat or .cmd files. For example, if you have a Visual Basic script, you must use this syntax now:\n--up 'C:\\\\Windows\\\\System32\\\\wscript.exe C:\\\\Program\\ Files\\\\OpenVPN\\\\config\\\\my-up-script.vbs'\nPlease note the single quote marks and the escaping of the backslashes (\\) and the space character.\nThe reason the support for the\nsystem\nflag was removed is due to the security implications with shell expansions when executing scripts via the\nsystem()\ncall.\n--setcon context\nApply SELinux context after initialization. This essentially provides the ability to restrict OpenVPN's rights to only network I/O operations, thanks to SELinux. This goes further than --user and --chroot in that those two, while being great security features, unfortunately do not protect against privilege escalation by exploitation of a vulnerable system call. You can of course combine all three, but please note that since setcon requires access to /proc you will have to provide it inside the chroot directory (e.g. with mount --bind).\nSince the setcon operation is delayed until after initialization, OpenVPN can be restricted to just network-related system calls, whereas by applying the context before startup (such as the OpenVPN one provided in the SELinux Reference Policies) you will have to allow many things required only during initialization.\nLike with chroot, complications can result when scripts or restarts are executed after the setcon operation, which is why you should really consider using the --persist-key and --persist-tun options.\n--status args\nWrite operational status to file every n seconds. n defaults to\n60\nif not specified.\nValid syntaxes:\nstatus file\nstatus file n\nStatus can also be written to the syslog by sending a\nSIGUSR2\nsignal. With multi-client capability enabled on a server, the status file includes a list of clients and a routing table. The output format can be controlled by the --status-version option in that case.\nFor clients or instances running in point-to-point mode, it will contain the traffic statistics.\n--status-version n\nSet the status file format version number to n.\nThis only affects the status file on servers with multi-client capability enabled. Valid status version values:\n1\nTraditional format (default). The client list contains the following fields comma-separated: Common Name, Real Address, Bytes Received, Bytes Sent, Connected Since.\n2\nA more reliable format for external processing. Compared to versionÂ 1, the client list contains some additional fields: Virtual Address, Virtual IPv6 Address, Username, Client ID, Peer ID, Data Channel Cipher. Future versions may extend the number of fields.\n3\nIdentical toÂ 2, but fields are tab-separated.\n--test-crypto\nDo a self-test of OpenVPN's crypto options by encrypting and decrypting test packets using the data channel encryption options specified above. This option does not require a peer to function, and therefore can be specified without --dev or --remote.\nThe typical usage of --test-crypto would be something like this:\nopenvpn --test-crypto --secret key\nor\nopenvpn --test-crypto --secret key --verb 9\nThis option is very useful to test OpenVPN after it has been ported to a new platform, or to isolate problems in the compiler, OpenSSL crypto library, or OpenVPN's crypto code. Since it is a self-test mode, problems with encryption and authentication can be debugged independently of network and tunnel issues.\n--tmp-dir dir\nSpecify a directory dir for temporary files. This directory will be used by openvpn processes and script to communicate temporary data with openvpn main process. Note that the directory must be writable by the OpenVPN process after it has dropped it's root privileges.\nThis directory will be used by in the following cases:\n--client-connect scripts and\nOPENVPN_PLUGIN_CLIENT_CONNECT\nplug-in hook to dynamically generate client-specific configuration\nclient_connect_config_file\nand return success/failure via\nclient_connect_deferred_file\nwhen using deferred client connect method\nOPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY\nplug-in hooks returns success/failure via\nauth_control_file\nwhen using deferred auth method and pending authentication via\npending_auth_file\n.\n--use-prediction-resistance\nEnable prediction resistance on mbed TLS's RNG.\nEnabling prediction resistance causes the RNG to reseed in each call for random. Reseeding this often can quickly deplete the kernel entropy pool.\nIf you need this option, please consider running a daemon that adds entropy to the kernel pool.\n--user user\nChange the user ID of the OpenVPN process to user after initialization, dropping privileges in the process. This option is useful to protect the system in the event that some hostile party was able to gain control of an OpenVPN session. Though OpenVPN's security features make this unlikely, it is provided as a second line of defense.\nBy setting user to an unprivileged user dedicated to run openvpn, the hostile party would be limited in what damage they could cause. Of course once you take away privileges, you cannot return them to an OpenVPN session. This means, for example, that if you want to reset an OpenVPN daemon with a\nSIGUSR1\nsignal (for example in response to a DHCP reset), you should make use of one or more of the --persist options to ensure that OpenVPN doesn't need to execute any privileged operations in order to restart (such as re-reading key files or running ifconfig on the TUN device).\nNOTE: Previous versions of openvpn used\nnobody\nas the example unpriviledged user. It is not recommended to actually use that user since it is usually used by other system services already. Always create a dedicated user for openvpn.\n--writepid file\nWrite OpenVPN's main process ID to file.\nLog options\n--echo parms\nEcho parms to log output.\nDesigned to be used to send messages to a controlling application which is receiving the OpenVPN log output.\n--errors-to-stderr\nOutput errors to stderr instead of stdout unless log output is redirected by one of the --log options.\n--log file\nOutput logging messages to file, including output to stdout/stderr which is generated by called scripts. If file already exists it will be truncated. This option takes effect immediately when it is parsed in the command line and will supersede syslog output if --daemon is also specified. This option is persistent over the entire course of an OpenVPN instantiation and will not be reset by\nSIGHUP\n,\nSIGUSR1\n, or --ping-restart.\nNote that on Windows, when OpenVPN is started as a service, logging occurs by default without the need to specify this option.\n--log-append file\nAppend logging messages to file. If file does not exist, it will be created. This option behaves exactly like --log except that it appends to rather than truncating the log file.\n--machine-readable-output\nAlways write timestamps and message flags to log messages, even when they otherwise would not be prefixed. In particular, this applies to log messages sent to stdout.\n--mute n\nLog at most n consecutive messages in the same category. This is useful to limit repetitive logging of similar message types.\n--mute-replay-warnings\nSilence the output of replay warnings, which are a common false alarm on WiFi networks. This option preserves the security of the replay protection code without the verbosity associated with warnings about duplicate packets.\n--suppress-timestamps\nAvoid writing timestamps to log messages, even when they otherwise would be prepended. In particular, this applies to log messages sent to stdout.\n--syslog progname\nDirect log output to system logger, but do not become a daemon. See --daemon directive above for description of progname parameter.\n--verb n\nSet output verbosity to n (default\n1\n). Each level shows all info from the previous levels. Level\n3\nis recommended if you want a good summary of what's happening without being swamped by output.\n0\nNo output except fatal errors.\n1\nto\n4\nNormal usage range.\n5\nOutputsÂ RÂ andÂ WÂ characters to the console for each packet read and write, uppercase is used for TCP/UDP packets and lowercase is used for TUN/TAP packets.\n6\nto\n11\nDebug info range (seeÂ errlevel.hÂ in the source code for additional information on debug levels).\nProtocol options\nOptions in this section affect features available in the OpenVPN wire protocol. Many of these options also define the encryption options of the data channel in the OpenVPN wire protocol. These options must be configured in a compatible way between both the local and remote side.\n--allow-compression mode\nAs described in the --compress option, compression is a potentially dangerous option. This option allows controlling the behaviour of OpenVPN when compression is used and allowed.\nValid syntaxes:\nallow-compression\nallow-compression mode\nThe mode argument can be one of the following values:\nasym\nOpenVPN will onlyÂ decompress downlink packetsÂ butÂ not compress uplink packets. This also allows migrating to disable compression when changing both server and client configurations to remove compression at the same time is not a feasible option.\nno\n(default)\nOpenVPN will refuse any compression. If data-channel offloading is enabled, OpenVPN will additionally also refuse compression framing (stub).\nyes\nOpenVPN will send and receive compressed packets.\n--auth alg\nAuthenticate data channel packets and (if enabled) tls-auth control channel packets with HMAC using message digest algorithm alg. (The default is SHA1 ). HMAC is a commonly used message authentication algorithm (MAC) that uses a data string, a secure hash algorithm and a key to produce a digital signature.\nThe OpenVPN data channel protocol uses encrypt-then-mac (i.e. first encrypt a packet then HMAC the resulting ciphertext), which prevents padding oracle attacks. If an AEAD cipher mode (e.g. GCM) is chosen then the specified --auth algorithm is ignored for the data channel and the authentication method of the AEAD cipher is used instead. Note that alg still specifies the digest used for tls-auth. In static-key encryption mode, the HMAC key is included in the key file generated by --genkey. In TLS mode, the HMAC key is dynamically generated and shared between peers via the TLS control channel. If OpenVPN receives a packet with a bad HMAC it will drop the packet. HMAC usually adds 16 or 20 bytes per packet. Set alg=none to disable authentication.\n--cipher alg\nThis option should not be used any longer in TLS mode and still exists for two reasons:\ncompatibility with old configurations still carrying it around;\nallow users connecting to OpenVPN peers older than 2.6.0 to have --cipher configured the same way as the remote counterpart. This can avoid MTU/frame size warnings.\nBefore 2.4.0, this option was used to select the cipher to be configured on the data channel, however, later versions usually ignored this directive in favour of a negotiated cipher. Starting with 2.6.0, this option is always ignored in TLS mode when it comes to configuring the cipher and will only control the cipher for --secret pre-shared-key mode (note: this mode is deprecated and strictly not recommended). If you wish to specify the cipher to use on the data channel, please see --data-ciphers (for regular negotiation) and --data-ciphers-fallback (for a fallback option when the negotiation cannot take place because the other peer is old or has negotiation disabled). To see ciphers that are available with OpenVPN, use the --show-ciphers option.\nSet alg to\nnone\nto disable encryption.\n--compress algorithm\nDEPRECATED\nEnable a compression algorithm. Compression is generally not recommended. VPN tunnels which use compression are susceptible to the VORALCE attack vector. See also the\nmigrate\nparameter below.\nThe algorithm parameter may be\nlzo\n,\nlz4\n,\nlz4-v2\n,\nstub\n,\nstub-v2\n,\nmigrate\nor empty. LZO and LZ4 are different compression algorithms, with LZ4 generally offering the best performance with least CPU usage. The\nlz4-v2\nand\nstub-v2\nvariants implement a better framing that does not add overhead when packets cannot be compressed. All other variants always add one extra framing byte compared to no compression framing. Especially\nstub-v2\nis essentially identical to no compression and no compression framing as its header indicates IP version 5 in a tun setup and can (ab)used to complete disable compression to clients. (See the\nmigrate\noption below) If the algorithm parameter is\nstub\n,\nstub-v2\nor empty, compression will be turned off, but the packet framing for compression will still be enabled, allowing a different setting to be pushed later. Additionally,\nstub\nand\nstub-v2\nwil disable announcing lzo and lz4 compression support via\nIV_\nvariables to the server. Note: the\nstub\n(or empty) option is NOT compatible with the older option --comp-lzo no. Using\nmigrate\nas compression algorithm enables a special migration mode. It allows migration away from the --compress/--comp-lzo options to no compression. This option sets the server to no compression mode and the server behaves identical to a server without a compression option for all clients without a compression in their config. However, if a client is detected that indicates that compression is used (via OCC), the server will automatically add --push compress stub-v2 to the client specific configuration if supported by the client and otherwise switch to comp-lzo no and add --push comp-lzo to the client specific configuration.\n*Security Considerations*\nCompression and encryption is a tricky combination. If an attacker knows or is able to control (parts of) the plain-text of packets that contain secrets, the attacker might be able to extract the secret if compression is enabled. See e.g. the\nCRIME\nand\nBREACH\nattacks on TLS and\nVORACLE\non VPNs which also leverage to break encryption. If you are not entirely sure that the above does not apply to your traffic, you are advised to\nnot\nenable compression.\n--comp-lzo mode\nDEPRECATED\nEnable LZO compression algorithm. Compression is generally not recommended. VPN tunnels which uses compression are suspectible to the VORALCE attack vector.\nUse LZO compression -- may add up to 1 byte per packet for incompressible data. mode may be\nyes\n,\nno\n, or\nadaptive\n(default). In a server mode setup, it is possible to selectively turn compression on or off for individual clients. First, make sure the client-side config file enables selective compression by having at least one --comp-lzo directive, such as --comp-lzo no. This will turn off compression by default, but allow a future directive push from the server to dynamically change the\non\n/\noff\n/\nadaptive\nsetting. Next in a --client-config-dir file, specify the compression setting for the client, for example:\ncomp-lzo yes\npush \"comp-lzo yes\"\nThe first line sets the comp-lzo setting for the server side of the link, the second sets the client side.\n--comp-noadapt\nDEPRECATED\nWhen used in conjunction with --comp-lzo, this option will disable OpenVPN's adaptive compression algorithm. Normally, adaptive compression is enabled with --comp-lzo.\nAdaptive compression tries to optimize the case where you have compression enabled, but you are sending predominantly incompressible (or pre-compressed) packets over the tunnel, such as an FTP or rsync transfer of a large, compressed file. With adaptive compression, OpenVPN will periodically sample the compression process to measure its efficiency. If the data being sent over the tunnel is already compressed, the compression efficiency will be very low, triggering openvpn to disable compression for a period of time until the next re-sample test.\n--key-direction\nAlternative way of specifying the optional direction parameter for the --tls-auth and --secret options. Useful when using inline files (See section on inline files).\n--data-ciphers cipher-list\nRestrict the allowed ciphers to be negotiated to the ciphers in cipher-list. cipher-list is a colon-separated list of ciphers, and defaults to\nAES-256-GCM:AES-128-GCM:CHACHA20-POLY1305\nwhen Chacha20-Poly1305 is available and otherwise\nAES-256-GCM:AES-128-GCM\n.\nFor servers, the first cipher from cipher-list that is also supported by the client will be pushed to clients that support cipher negotiation. For more details see the chapter on\nData channel cipher negotiation\n.\nEspecially\nif you need to support clients with OpenVPN versions older than 2.4! Starting with OpenVPN 2.6 a cipher can be prefixed with a\n?\nto mark it as optional. This allows including ciphers in the list that may not be available on all platforms. E.g.\nAES-256-GCM:AES-128-GCM:?CHACHA20-POLY1305\nwould only enable Chacha20-Poly1305 if the underlying SSL library (and its configuration) supports it. Cipher negotiation is enabled in client-server mode only. I.e. if --mode is set to server (server-side, implied by setting --server ), or if --pull is specified (client-side, implied by setting --client). If no common cipher is found during cipher negotiation, the connection is terminated. To support old clients/old servers that do not provide any cipher negotiation support see --data-ciphers-fallback. If --compat-mode is set to a version older than 2.5.0 the cipher specified by --cipher will be appended to --data-ciphers if not already present. This list is restricted to be 127 chars long after conversion to OpenVPN ciphers.\nThis option was called --ncp-ciphers in OpenVPN 2.4 but has been renamed to --data-ciphers in OpenVPN 2.5 to more accurately reflect its meaning.\n--data-ciphers-fallback alg\nConfigure a cipher that is used to fall back to if we could not determine which cipher the peer is willing to use.\nThis option should only be needed to connect to peers that are running OpenVPN 2.3 or older versions, and have been configured with --enable-small (typically used on routers or other embedded devices).\n--secret args\nDEPRECATED\nEnable Static Key encryption mode (non-TLS). Use pre-shared secret file which was generated with --genkey.\nValid syntaxes:\nsecret file\nsecret file direction\nThe optional direction parameter enables the use of 4 distinct keys (HMAC-send, cipher-encrypt, HMAC-receive, cipher-decrypt), so that each data flow direction has a different set of HMAC and cipher keys. This has a number of desirable security properties including eliminating certain kinds of DoS and message replay attacks. When the direction parameter is omitted, 2 keys are used bidirectionally, one for HMAC and the other for encryption/decryption. The direction parameter should always be complementary on either side of the connection, i.e. one side should use\n0\nand the other should use\n1\n, or both sides should omit it altogether. The direction parameter requires that file contains a 2048 bit key. While pre-1.5 versions of OpenVPN generate 1024 bit key files, any version of OpenVPN which supports the direction parameter, will also support 2048 bit key file generation using the --genkey option. Static key encryption mode has certain advantages, the primary being ease of configuration. There are no certificates or certificate authorities or complicated negotiation handshakes and protocols. The only requirement is that you have a pre-existing secure channel with your peer (such as ssh) to initially copy the key. This requirement, along with the fact that your key never changes unless you manually generate a new one, makes it somewhat less secure than TLS mode (see below). If an attacker manages to steal your key, everything that was ever encrypted with it is compromised. Contrast that to the perfect forward secrecy features of TLS mode (using Diffie Hellman key exchange), where even if an attacker was able to steal your private key, he would gain no information to help him decrypt past sessions.\nAnother advantageous aspect of Static Key encryption mode is that it is a handshake-free protocol without any distinguishing signature or feature (such as a header or protocol handshake sequence) that would mark the ciphertext packets as being generated by OpenVPN. Anyone eavesdropping on the wire would see nothing but random-looking data.\n--tran-window n\nTransition window -- our old key can live this many seconds after a new a key renegotiation begins (default\n3600\nseconds). This feature allows for a graceful transition from old to new key, and removes the key renegotiation sequence from the critical path of tunnel data forwarding.\n--force-tls-key-material-export\nThis option is only available in --mode server and forces to use Keying Material Exporters (RFC 5705) for clients. This can be used to simulate an environment where the cryptographic library does not support the older method to generate data channel keys anymore. This option is intended to be a test option and might be removed in a future OpenVPN version without notice.\nClient Options\nThe client options are used when connecting to an OpenVPN server configured to use --server, --server-bridge, or --mode server in its configuration.\n--allow-pull-fqdn\nAllow client to pull DNS names from server (rather than being limited to IP address) for --ifconfig, --route, and --route-gateway.\n--allow-recursive-routing\nWhen this option is set, OpenVPN will not drop incoming tun packets with same destination as host.\n--auth-token token\nThis is not an option to be used directly in any configuration files, but rather push this option from a --client-connect script or a --plugin which hooks into the\nOPENVPN_PLUGIN_CLIENT_CONNECT\nor\nOPENVPN_PLUGIN_CLIENT_CONNECT_V2\ncalls. This option provides a possibility to replace the clients password with an authentication token during the lifetime of the OpenVPN client.\nWhenever the connection is renegotiated and the --auth-user-pass-verify script or --plugin making use of the\nOPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY\nhook is triggered, it will pass over this token as the password instead of the password the user provided. The authentication token can only be reset by a full reconnect where the server can push new options to the client. The password the user entered is never preserved once an authentication token has been set. If the OpenVPN server side rejects the authentication token then the client will receive an\nAUTH_FAILED\nand disconnect. The purpose of this is to enable two factor authentication methods, such as HOTP or TOTP, to be used without needing to retrieve a new OTP code each time the connection is renegotiated. Another use case is to cache authentication data on the client without needing to have the users password cached in memory during the life time of the session. To make use of this feature, the --client-connect script or --plugin needs to put\npush \"auth-token UNIQUE_TOKEN_VALUE\"\ninto the file/buffer for dynamic configuration data. This will then make the OpenVPN server to push this value to the client, which replaces the local password with the UNIQUE_TOKEN_VALUE.\nNewer clients (2.4.7+) will fall back to the original password method after a failed auth. Older clients will keep using the token value and react according to --auth-retry\n--auth-token-user base64username\nCompanion option to --auth-token. This options allows one to override the username used by the client when reauthenticating with the auth-token. It also allows one to use --auth-token in setups that normally do not use username and password.\nThe username has to be base64 encoded.\n--auth-user-pass\nAuthenticate with server using username/password.\nValid syntaxes:\nauth-user-pass\nauth-user-pass up\nIf up is present, it must be a file containing username/password on 2 lines. If the password line is missing, OpenVPN will prompt for one. If up is omitted, username/password will be prompted from the console. This option can also be inlined\n<auth-user-pass>\nusername\n[password]\n</auth-user-pass>\nwhere password is optional, and will be prompted from the console if missing.\nThe server configuration must specify an --auth-user-pass-verify script to verify the username/password provided by the client.\n--auth-retry type\nControls how OpenVPN responds to username/password verification errors such as the client-side response to an\nAUTH_FAILED\nmessage from the server or verification failure of the private key password.\nNormally used to prevent auth errors from being fatal on the client side, and to permit username/password requeries in case of error. An\nAUTH_FAILED\nmessage is generated by the server if the client fails --auth-user-pass authentication, or if the server-side --client-connect script returns an error status when the client tries to connect. type can be one of:\nnone\nClient will exit with a fatal error (this is the default).\nnointeract\nClient will retry the connection without requerying for anÂ --auth-user-passÂ username/password. Use this option for unattended clients.\ninteract\nClient will requery for anÂ --auth-user-passÂ username/password and/or private key password before attempting a reconnection.\nNote that while this option cannot be pushed, it can be controlled from the management interface.\n--client\nA helper directive designed to simplify the configuration of OpenVPN's client mode. This directive is equivalent to:\npull\ntls-client\n--client-nat args\nThis pushable client option sets up a stateless one-to-one NAT rule on packet addresses (not ports), and is useful in cases where routes or ifconfig settings pushed to the client would create an IP numbering conflict.\nExamples:\nclient-nat snat 192.168.0.0/255.255.0.0\nclient-nat dnat 10.64.0.0/255.255.0.0\nnetwork/netmask (for example\n192.168.0.0/255.255.0.0\n) defines the local view of a resource from the client perspective, while alias/netmask (for example\n10.64.0.0/255.255.0.0\n) defines the remote view from the server perspective. Use\nsnat\n(source NAT) for resources owned by the client and\ndnat\n(destination NAT) for remote resources.\nSet --verb 6 for debugging info showing the transformation of src/dest addresses in packets.\n--connect-retry args\nWait n seconds between connection attempts (default\n1\n). Repeated reconnection attempts are slowed down after 5 retries per remote by doubling the wait time after each unsuccessful attempt.\nValid syntaxes:\nconnect retry n\nconnect retry n max\nIf the optional argument max is specified, the maximum wait time in seconds gets capped at that value (default\n300\n).\n--connect-retry-max n\nn specifies the number of times each --remote or <connection> entry is tried. Specifying n as\n1\nwould try each entry exactly once. A successful connection resets the counter. (default\nunlimited\n).\n--connect-timeout n\nSee --server-poll-timeout.\n--dns args\nClient DNS configuration to be used with the connection.\nValid syntaxes:\ndns search-domains domain [domain ...]\ndns server n address addr[:port] [addr[:port] ...]\ndns server n resolve-domains domain [domain ...]\ndns server n dnssec yes|optional|no\ndns server n transport DoH|DoT|plain\ndns server n sni server-name\nThe --dns search-domains directive takes one or more domain names to be added as DNS domain suffixes. If it is repeated multiple times within a configuration the domains are appended, thus e.g. domain names pushed by a server will amend locally defined ones. The --dns server directive is used to configure DNS server n. The server id n must be a value between -128 and 127. For pushed DNS server options it must be between 0 and 127. The server id is used to group options and also for ordering the list of configured DNS servers; lower numbers come first. DNS servers being pushed to a client replace already configured DNS servers with the same server id. The address option configures the IPv4 and / or IPv6 address(es) of the DNS server. Up to eight addresses can be specified per DNS server. Optionally a port can be appended after a colon. IPv6 addresses need to be enclosed in brackets if a port is appended. The resolve-domains option takes one or more DNS domains used to define a split-dns or dns-routing setup, where only the given domains are resolved by the server. Systems which do not support fine grained DNS domain configuration will ignore this setting. The dnssec option is used to configure validation of DNSSEC records. While the exact semantics may differ for resolvers on different systems, yes likely makes validation mandatory, no disables it, and optional uses it opportunistically. The transport option enables DNS-over-HTTPS (DoH) or DNS-over-TLS (DoT) for a DNS server. The sni option can be used with them to specify the server-name for TLS server name indication. Each server has to have at least one address configured for a configuration to be valid. All the other options can be omitted. Note that not all options may be supported on all platforms. As soon support for different systems is implemented, information will be added here how unsupported options are treated.\nThe --dns option will eventually obsolete the --dhcp-option directive. Until then it will replace configuration at the places --dhcp-option puts it, so that --dns overrides --dhcp-option. Thus, --dns can be used today to migrate from --dhcp-option.\n--explicit-exit-notify n\nIn UDP client mode or point-to-point mode, send server/peer an exit notification if tunnel is restarted or OpenVPN process is exited. In client mode, on exit/restart, this option will tell the server to immediately close its client instance object rather than waiting for a timeout.\nIf both server and client support sending this message using the control channel, the message will be sent as control-channel message. Otherwise the message is sent as data-channel message, which will be ignored by data-channel offloaded peers. The\nn\nparameter (default\n1\nif not present) controls the maximum number of attempts that the client will try to resend the exit notification message if messages are sent in data-channel mode. In UDP server mode, send\nRESTART\ncontrol channel command to connected clients. The n parameter (default\n1\nif not present) controls client behavior. With n =\n1\nclient will attempt to reconnect to the same server, with n =\n2\nclient will advance to the next server.\nOpenVPN will not send any exit notifications unless this option is enabled.\n--inactive args\nCauses OpenVPN to exit after n seconds of inactivity on the TUN/TAP device. The time length of inactivity is measured since the last incoming or outgoing tunnel packet. The default value is 0 seconds, which disables this feature.\nValid syntaxes:\ninactive n\ninactive n bytes\nIf the optional bytes parameter is included, exit if less than bytes of combined in/out traffic are produced on the tun/tap device in n seconds.\nIn any case, OpenVPN's internal ping packets (which are just keepalives) and TLS control packets are not considered \"activity\", nor are they counted as traffic, as they are used internally by OpenVPN and are not an indication of actual user activity.\n--proto-force p\nWhen iterating through connection profiles, only consider profiles using protocol p (\ntcp\n|\nudp\n).\nNote that this specifically only filters by the transport layer protocol, i.e. UDP or TCP. This does not affect whether IPv4 or IPv6 is used as IP protocol.\nFor implementation reasons the option accepts the\n4\nand\n6\nsuffixes when specifying the protocol (i.e.\nudp4\n/\nudp6\n/\ntcp4\n/\ntcp6\n). However, these behave the same as without the suffix and should be avoided to prevent confusion.\n--pull\nThis option must be used on a client which is connecting to a multi-client server. It indicates to OpenVPN that it should accept options pushed by the server, provided they are part of the legal set of pushable options (note that the --pull option is implied by --client ).\nIn particular, --pull allows the server to push routes to the client, so you should not use --pull or --client in situations where you don't trust the server to have control over the client's routing table.\n--pull-filter args\nFilter options on the client pushed by the server to the client.\nValid syntaxes:\npull-filter accept text\npull-filter ignore text\npull-filter reject text\nFilter options received from the server if the option starts with\ntext\n. The action flag\naccept\nallows the option,\nignore\nremoves it and\nreject\nflags an error and triggers a\nSIGUSR1\nrestart. The filters may be specified multiple times, and each filter is applied in the order it is specified. The filtering of each option stops as soon as a match is found. Unmatched options are accepted by default. Prefix comparison is used to match\ntext\nagainst the received option so that\npull-filter ignore \"route\"\nwould remove all pushed options starting with route which would include, for example, route-gateway. Enclose\ntext\nin quotes to embed spaces.\npull-filter accept \"route 192.168.1.\"\npull-filter ignore \"route \"\nwould remove all routes that do not start with 192.168.1.\nNote\nthat\nreject\nmay result in a repeated cycle of failure and reconnect, unless multiple remotes are specified and connection to the next remote succeeds. To silently ignore an option pushed by the server, use\nignore\n.\n--push-peer-info\nPush additional information about the client to server. The following data is always pushed to the server:\nIV_VER=<version>\nThe client OpenVPN version\nIV_PLAT=[linux|solaris|openbsd|mac|netbsd|freebsd|win]\nThe client OS platform\nIV_PROTO\nDetails about protocol extensions that the peer supports. The variable is a bitfield and the bits are defined as follows:bit 0: Reserved, should always be zerobit 1: The peer supports peer-id floating mechanismbit 2: The client expects a push-reply and the server may send this reply without waiting for a push-request first.bit 3: The client is capable of doing key derivation using RFC5705 key material exporter.bit 4: The client is capable of accepting additional arguments to theÂ AUTH_PENDINGÂ message.bit 5: The client supports doing feature negotiation in P2P modebit 6: The client is capable of parsing and receiving theÂ --dnsÂ pushed optionbit 7: The client is capable of sending exit notification via control channel usingÂ EXITÂ message. Also, the client is accepting the protocol-flags pushed option for the EKM capabilitybit 8: The client is capable of acceptingÂ AUTH_FAILED,TEMPÂ messagesbit 9: The client is capable of dynamic tls-crypt\nIV_NCP=2\nNegotiable ciphers, client supportsÂ --cipherÂ pushed by the server, a value of 2 or greater indicates client supportsÂ AES-GCM-128Â andÂ AES-GCM-256. IV_NCP isÂ deprecatedÂ in favor ofÂ IV_CIPHERS.\nIV_CIPHERS=<data-ciphers>\nThe client announces the list of supported ciphers configured with theÂ --data-ciphersÂ option to the server.\nIV_MTU=<max_mtu>\nThe client announces the support of pushable MTU and the maximum MTU it is willing to accept.\nIV_GUI_VER=<gui_id> <version>\nThe UI version of a UI if one is running, for exampleÂ de.blinkt.openvpn 0.5.47Â for the Android app. This may be set by the client UI/GUI usingÂ --setenv.\nIV_SSO=[crtext,][openurl,][proxy_url]\nAdditional authentication methods supported by the client. This may be set by the client UI/GUI usingÂ --setenv.\nThe following flags depend on which compression formats are compiled in and whether compression is allowed by options. See\nProtocol options\nfor more details.\nIV_LZO=1\nIf client supports LZO compression.\nIV_LZO_STUB=1\nIf client was built with LZO stub capability. This is only sent ifÂ IV_LZO=1Â is not sent. This means the client can talk to a server configured withÂ --comp-lzoÂ no.\nIV_LZ4=1\nand\nIV_LZ4v2=1\nIf the client supports LZ4 compression.\nIV_COMP_STUB=1\nand\nIV_COMP_STUBv2=1\nIf the client supports stub compression. This means the client can talk to a server configured withÂ --compress.\nWhen --push-peer-info is enabled the additional information consists of the following data:\nIV_HWADDR=<string>\nThis is intended to be a unique and persistent ID of the client. The string value can be any readable ASCII string up to 64 bytes. OpenVPN 2.x and some other implementations use the MAC address of the client's interface used to reach the default gateway. If this string is generated by the client, it should be consistent and preserved across independent sessions and preferably re-installations and upgrades.\nIV_SSL=<version string>\nThe ssl library version used by the client, e.g.Â OpenSSL 1.0.2f 28 Jan 2016.\nIV_PLAT_VER=x.y\nThe version of the operating system, e.g. 6.1 for Windows 7. This may be set by the client UI/GUI usingÂ --setenv. On Windows systems it is automatically determined by openvpn itself.\nUV_<name>=<value>\nClient environment variables whose names start withÂ UV_\n--remote args\nRemote host name or IP address, port and protocol.\nValid syntaxes:\nremote host\nremote host port\nremote host port proto\nThe port and proto arguments are optional. The OpenVPN client will try to connect to a server at host:port. The proto argument indicates the protocol to use when connecting with the remote, and may be\ntcp\nor\nudp\n. To enforce IPv4 or IPv6 connections add a\n4\nor\n6\nsuffix; like\nudp4\n/\nudp6\n/\ntcp4\n/\ntcp6\n. On the client, multiple --remote options may be specified for redundancy, each referring to a different OpenVPN server, in the order specified by the list of --remote options. Specifying multiple --remote options for this purpose is a special case of the more general connection-profile feature. See the <connection> documentation below. The client will move on to the next host in the list, in the event of connection failure. Note that at any given time, the OpenVPN client will at most be connected to one server. Examples:\nremote server1.example.net\nremote server1.example.net 1194\nremote server2.example.net 1194 tcp\nNote:\nSince UDP is connectionless, connection failure is defined by theÂ --pingÂ andÂ --ping-restartÂ options.Also, if you use multipleÂ --remoteÂ options, AND you are dropping root privileges on the client withÂ --userÂ and/orÂ --groupÂ AND the client is running a non-Windows OS, if the client needs to switch to a different server, and that server pushes back different TUN/TAP or route settings, the client may lack the necessary privileges to close and reopen the TUN/TAP interface. This could cause the client to exit with a fatal error.\nIf --remote is unspecified, OpenVPN will listen for packets from any IP address, but will not act on those packets unless they pass all authentication tests. This requirement for authentication is binding on all potential peers, even those from known and supposedly trusted IP addresses (it is very easy to forge a source IP address on a UDP packet). When used in TCP mode, --remote will act as a filter, rejecting connections from any host which does not match host.\nIf host is a DNS name which resolves to multiple IP addresses, OpenVPN will try them in the order that the system getaddrinfo() presents them, so priorization and DNS randomization is done by the system library. Unless an IP version is forced by the protocol specification (4/6 suffix), OpenVPN will try both IPv4 and IPv6 addresses, in the order getaddrinfo() returns them.\n--remote-random\nWhen multiple --remote address/ports are specified, or if connection profiles are being used, initially randomize the order of the list as a kind of basic load-balancing measure.\n--remote-random-hostname\nPrepend a random string (6 bytes, 12 hex characters) to hostname to prevent DNS caching. For example, \"foo.bar.gov\" would be modified to \"<random-chars>.foo.bar.gov\".\n--resolv-retry n\nIf hostname resolve fails for --remote, retry resolve for n seconds before failing.\nSet n to\ninfinite\nto retry indefinitely.\nBy default, --resolv-retry infinite is enabled. You can disable by setting n=0.\n--single-session\nAfter initially connecting to a remote peer, disallow any new connections. Using this option means that a remote peer cannot connect, disconnect, and then reconnect.\nIf the daemon is reset by a signal or --ping-restart, it will allow one new connection.\n--single-session can be used with --ping-exit or --inactive to create a single dynamic session that will exit when finished.\n--server-poll-timeout n\nWhen connecting to a remote server do not wait for more than n seconds for a response before trying the next server. The default value is\n120\n. This timeout includes proxy and TCP connect timeouts.\n--static-challenge args\nEnable static challenge/response protocol\nValid syntax:\nstatic-challenge text echo\nThe text challenge text is presented to the user which describes what information is requested. The echo flag indicates if the user's input should be echoed on the screen. Valid echo values are\n0\nor\n1\n.\nSee management-notes.txt in the OpenVPN distribution for a description of the OpenVPN challenge/response protocol.\n--http-proxy args\nConnect to remote host through an HTTP proxy. This requires at least an address server and port argument. If HTTP Proxy-Authenticate is required, a file name to an authfile file containing a username and password on 2 lines can be given, or\nstdin\nto prompt from console. Its content can also be specified in the config file with the --http-proxy-user-pass option (See\nINLINE FILE SUPPORT\n).\nThe last optional argument is an auth-method which should be one of\nnone\n,\nbasic\n, or\nntlm\n. HTTP Digest authentication is supported as well, but only via the\nauto\nor\nauto-nct\nflags (below). This must replace the authfile argument. The\nauto\nflag causes OpenVPN to automatically determine the auth-method and query stdin or the management interface for username/password credentials, if required. This flag exists on OpenVPN 2.1 or higher. The auto-nct flag (no clear-text auth) instructs OpenVPN to automatically determine the authentication method, but to reject weak authentication protocols such as HTTP Basic Authentication. Examples:\n# no authentication\nhttp-proxy proxy.example.net 3128\n# basic authentication, load credentials from file\nhttp-proxy proxy.example.net 3128 authfile.txt\n# basic authentication, ask user for credentials\nhttp-proxy proxy.example.net 3128 stdin\n# NTLM authentication, load credentials from file\nhttp-proxy proxy.example.net 3128 authfile.txt ntlm2\n# determine which authentication is required, ask user for credentials\nhttp-proxy proxy.example.net 3128 auto\n# determine which authentication is required, but reject basic\nhttp-proxy proxy.example.net 3128 auto-nct\n# determine which authentication is required, but set credentials\nhttp-proxy proxy.example.net 3128 auto\nhttp-proxy-user-pass authfile.txt\n# basic authentication, specify credentials inline\nhttp-proxy proxy.example.net 3128 \"\" basic\n<http-proxy-user-pass>\nusername\npassword\n</http-proxy-user-pass>\n--http-proxy-user-pass userpass\nOverwrite the username/password information for --http-proxy. If specified as an inline option (see\nINLINE FILE SUPPORT\n), it will be interpreted as username/password separated by a newline. When specified on the command line it is interpreted as a filename same as the third argument to --http-proxy.\nExample:\n<http-proxy-user-pass>\nusername\npassword\n</http-proxy-user-pass>\n--http-proxy-option args\nSet extended HTTP proxy options. Requires an option type as argument and an optional parameter to the type. Repeat to set multiple options.\nVERSION\nversion\nSet HTTP version number toÂ versionÂ (defaultÂ 1.0).\nAGENT\nuser-agent\nSet HTTP \"User-Agent\" string toÂ user-agent.\nCUSTOM-HEADER\nname content\nAdds the custom Header withÂ nameÂ as name andÂ contentÂ as the content of the custom HTTP header.\nExamples:\nhttp-proxy-option VERSION 1.1\nhttp-proxy-option AGENT OpenVPN/2.4\nhttp-proxy-option X-Proxy-Flag some-flags\n--socks-proxy args\nConnect to remote host through a Socks5 proxy. A required server argument is needed. Optionally a port (default\n1080\n) and authfile can be given. The authfile is a file containing a username and password on 2 lines, or\nstdin\ncan be used to prompt from console.\nServer Options\nStarting with OpenVPN 2.0, a multi-client TCP/UDP server mode is supported, and can be enabled with the --mode server option. In server mode, OpenVPN will listen on a single port for incoming client connections. All client connections will be routed through a single tun or tap interface. This mode is designed for scalability and should be able to support hundreds or even thousands of clients on sufficiently fast hardware. SSL/TLS authentication must be used in this mode.\n--auth-gen-token args\nReturns an authentication token to successfully authenticated clients.\nValid syntax:\nauth-gen-token [lifetime] [renewal-time] [external-auth]\nAfter successful user/password authentication, the OpenVPN server will with this option generate a temporary authentication token and push that to the client. On the following renegotiations, the OpenVPN client will pass this token instead of the users password. On the server side the server will do the token authentication internally and it will NOT do any additional authentications against configured external user/password authentication mechanisms. The tokens implemented by this mechanism include an initial timestamp and a renew timestamp and are secured by HMAC. The lifetime argument defines how long the generated token is valid. The lifetime is defined in seconds. If lifetime is not set or it is set to\n0\n, the token will never expire. If renewal-time is not set it defaults to reneg-sec. The token will expire either after the configured lifetime of the token is reached or after not being renewed for more than 2 * renewal-time seconds. Clients will be sent renewed tokens on every TLS renegotiation. If renewal-time is lower than reneg-sec the server will push an updated temporary authentication token every reneweal-time seconds. This is done to invalidate a token if a client is disconnected for a sufficiently long time, while at the same time permitting much longer token lifetimes for active clients. This feature is useful for environments which are configured to use One Time Passwords (OTP) as part of the user/password authentications and that authentication mechanism does not implement any auth-token support. When the\nexternal-auth\nkeyword is present the normal authentication method will always be called even if auth-token succeeds. Normally other authentications method are skipped if auth-token verification succeeds or fails. This option postpones this decision to the external authentication methods and checks the validity of the account and do other checks. In this mode the environment will have a session_id variable that holds the session id from auth-gen-token. Also an environment variable session_state is present. This variable indicates whether the auth-token has succeeded or not. It can have the following values:\nInitial\nNo token from client.\nAuthenticated\nToken is valid and not expired.\nExpired\nToken is valid but has expired.\nInvalid\nToken is invalid (failed HMAC or wrong length)\nAuthenticatedEmptyUser\n/\nExpiredEmptyUser\nThe token is not valid with the username sent from the client but would be valid (or expired) if we assume an empty username was used instead. These two cases are a workaround for behaviour in OpenVPN 3. If this workaround is not needed these two cases should be handled in the same way asÂ Invalid.\nWarning:\nUse this feature only if you want your authentication method called on every verification. Since the external authentication is called it needs to also indicate a success or failure of the authentication. It is strongly recommended to return an authentication failure in the case of the Invalid/Expired auth-token with the external-auth option unless the client could authenticate in another acceptable way (e.g. client certificate), otherwise returning success will lead to authentication bypass (as does returning success on a wrong password from a script).\n--auth-gen-token-secret file\nSpecifies a file that holds a secret for the HMAC used in --auth-gen-token If file is not present OpenVPN will generate a random secret on startup. This file should be used if auth-token should validate after restarting a server or if client should be able to roam between multiple OpenVPN servers with their auth-token.\n--auth-user-pass-optional\nAllow connections by clients that do not specify a username/password. Normally, when --auth-user-pass-verify or --management-client-auth are specified (or an authentication plugin module), the OpenVPN server daemon will require connecting clients to specify a username and password. This option makes the submission of a username/password by clients optional, passing the responsibility to the user-defined authentication module/script to accept or deny the client based on other factors (such as the setting of X509 certificate fields). When this option is used, and a connecting client does not submit a username/password, the user-defined authentication module/script will see the username and password as being set to empty strings (\"\"). The authentication module/script MUST have logic to detect this condition and respond accordingly.\n--ccd-exclusive\nRequire, as a condition of authentication, that a connecting client has a --client-config-dir file.\n--client-config-dir dir\nSpecify a directory dir for custom client config files. After a connecting client has been authenticated, OpenVPN will look in this directory for a file having the same name as the client's X509 common name. If a matching file exists, it will be opened and parsed for client-specific configuration options. If no matching file is found, OpenVPN will instead try to open and parse a default file called \"DEFAULT\", which may be provided but is not required. Note that the configuration files must be readable by the OpenVPN process after it has dropped it's root privileges.\nThis file can specify a fixed IP address for a given client using --ifconfig-push, as well as fixed subnets owned by the client using --iroute. One of the useful properties of this option is that it allows client configuration files to be conveniently created, edited, or removed while the server is live, without needing to restart the server.\nThe following options are legal in a client-specific context: --push, --push-reset, --push-remove, --iroute, --ifconfig-push, --vlan-pvid and --config.\n--client-to-client\nBecause the OpenVPN server mode handles multiple clients through a single tun or tap interface, it is effectively a router. The --client-to-client flag tells OpenVPN to internally route client-to-client traffic rather than pushing all client-originating traffic to the TUN/TAP interface.\nWhen this option is used, each client will \"see\" the other clients which are currently connected. Otherwise, each client will only see the server. Don't use this option if you want to firewall tunnel traffic using custom, per-client rules.\nPlease note that when using data channel offload this option has no effect. Packets are always sent to the tunnel interface and then routed based on the system routing table.\n--disable\nDisable a particular client (based on the common name) from connecting. Don't use this option to disable a client due to key or password compromise. Use a CRL (certificate revocation list) instead (see the --crl-verify option).\nThis option must be associated with a specific client instance, which means that it must be specified either in a client instance config file using --client-config-dir or dynamically generated using a --client-connect script.\n--connect-freq args\nAllow a maximum of n new connections per sec seconds from clients.\nValid syntax:\nconnect-freq n sec\nThis is designed to contain DoS attacks which flood the server with connection requests using certificates which will ultimately fail to authenticate. This limit applies after --connect-freq-initial and only applies to client that have completed the three-way handshake or client that use --tls-crypt-v2 without cookie support (allow-noncookie argument to --tls-crypt-v2). This is an imperfect solution however, because in a real DoS scenario, legitimate connections might also be refused.\nFor the best protection against DoS attacks in server mode, use --proto udp and either --tls-auth or --tls-crypt.\n--connect-freq-initial args\n(UDP only) Allow a maximum of n initial connection packet responses per sec seconds from the OpenVPN server to clients.\nValid syntax:\nconnect-freq-initial n sec\nOpenVPN starting at 2.6 is very efficient in responding to initial connection packets. When not limiting the initial responses an OpenVPN daemon can be abused in reflection attacks. This option is designed to limit the rate OpenVPN will respond to initial attacks.\nConnection attempts that complete the initial three-way handshake will not be counted against the limit. The default is to allow 100 initial connection per 10s.\n--duplicate-cn\nAllow multiple clients with the same common name to concurrently connect. In the absence of this option, OpenVPN will disconnect a client instance upon connection of a new client having the same common name.\n--ifconfig-pool args\nSet aside a pool of subnets to be dynamically allocated to connecting clients, similar to a DHCP server.\nValid syntax:\nifconfig-pool start-IP end-IP [netmask]\nFor tun-style tunnels, each client will be given a /30 subnet (for interoperability with Windows clients). For tap-style tunnels, individual addresses will be allocated, and the optional netmask parameter will also be pushed to clients.\n--ifconfig-ipv6-pool args\nSpecify an IPv6 address pool for dynamic assignment to clients.\nValid args:\nifconfig-ipv6-pool ipv6addr/bits\nThe pool starts at ipv6addr and matches the offset determined from the start of the IPv4 pool. If the host part of the given IPv6 address is 0, the pool starts at ipv6addr +1.\n--ifconfig-pool-persist args\nPersist/unpersist ifconfig-pool data to file, at seconds intervals (default\n600\n), as well as on program startup and shutdown.\nValid syntax:\nifconfig-pool-persist file [seconds]\nThe goal of this option is to provide a long-term association between clients (denoted by their common name) and the virtual IP address assigned to them from the ifconfig-pool. Maintaining a long-term association is good for clients because it allows them to effectively use the --persist-tun option. file is a comma-delimited ASCII file, formatted as\n<Common-Name>,<IP-address>\n. If seconds =\n0\n, file will be treated as read-only. This is useful if you would like to treat file as a configuration file.\nNote that the entries in this file are treated by OpenVPN as\nsuggestions\nonly, based on past associations between a common name and IP address. They do not guarantee that the given common name will always receive the given IP address. If you want guaranteed assignment, use --ifconfig-push\n--ifconfig-push args\nPush virtual IP endpoints for client tunnel, overriding the --ifconfig-pool dynamic allocation.\nValid syntax:\nifconfig-push local remote-netmask [alias]\nThe parameters local and remote-netmask are set according to the --ifconfig directive which you want to execute on the client machine to configure the remote end of the tunnel. Note that the parameters local and remote-netmask are from the perspective of the client, not the server. They may be DNS names rather than IP addresses, in which case they will be resolved on the server at the time of client connection. The optional alias parameter may be used in cases where NAT causes the client view of its local endpoint to differ from the server view. In this case local/remote-netmask will refer to the server view while alias/remote-netmask will refer to the client view. This option must be associated with a specific client instance, which means that it must be specified either in a client instance config file using --client-config-dir or dynamically generated using a --client-connect script. Remember also to include a --route directive in the main OpenVPN config file which encloses local, so that the kernel will know to route it to the server's TUN/TAP interface. OpenVPN's internal client IP address selection algorithm works as follows:\nUse --client-connect script generated file for static IP (first choice).\nUse --client-config-dir file for static IP (next choice).\nUse --ifconfig-pool allocation for dynamic IP (last choice).\n--ifconfig-ipv6-push args\nfor --client-config-dir per-client static IPv6 interface configuration, see --client-config-dir and --ifconfig-push for more details.\nValid syntax:\nifconfig-ipv6-push ipv6addr/bits ipv6remote\n--multihome\nConfigure a multi-homed UDP server. This option needs to be used when a server has more than one IP address (e.g. multiple interfaces, or secondary IP addresses), and is not using --local to force binding to one specific address only. This option will add some extra lookups to the packet path to ensure that the UDP reply packets are always sent from the address that the client is talking to. This is not supported on all platforms, and it adds more processing, so it's not enabled by default.\nNotes:\nThis option is only relevant for UDP servers.If you do an IPv6+IPv4 dual-stack bind on a Linux machine with multiple IPv4 address, connections to IPv4 addresses will not work right on kernels before 3.15, due to missing kernel support for the IPv4-mapped case (some distributions have ported this to earlier kernel versions, though).\n--iroute args\nGenerate an internal route to a specific client. The netmask parameter, if omitted, defaults to\n255.255.255.255\n.\nValid syntax:\niroute network [netmask]\nThis directive can be used to route a fixed subnet from the server to a particular client, regardless of where the client is connecting from. Remember that you must also add the route to the system routing table as well (such as by using the --route directive). The reason why two routes are needed is that the --route directive routes the packet from the kernel to OpenVPN. Once in OpenVPN, the --iroute directive routes to the specific client. However, when using DCO, the --iroute directive is usually enough for DCO to fully configure the routing table. The extra --route directive is required only if the expected behaviour is to route the traffic for a specific network to the VPN interface also when the responsible client is not connected (traffic will then be dropped). This option must be specified either in a client instance config file using --client-config-dir or dynamically generated using a --client-connect script.\nThe --iroute directive also has an important interaction with --push \"route ...\". --iroute essentially defines a subnet which is owned by a particular client (we will call this client\nA\n). If you would like other clients to be able to reach\nA\n's subnet, you can use --push \"route ...\" together with --client-to-client to effect this. In order for all clients to see\nA\n's subnet, OpenVPN must push this route to all clients EXCEPT for\nA\n, since the subnet is already owned by\nA\n. OpenVPN accomplishes this by not not pushing a route to a client if it matches one of the client's iroutes.\n--iroute-ipv6 args\nfor --client-config-dir per-client static IPv6 route configuration, see --iroute for more details how to setup and use this, and how --iroute and --route interact.\nValid syntax:\niroute-ipv6 ipv6addr/bits\n--max-clients n\nLimit server to a maximum of n concurrent clients.\n--max-routes-per-client n\nAllow a maximum of n internal routes per client (default\n256\n). This is designed to help contain DoS attacks where an authenticated client floods the server with packets appearing to come from many unique MAC addresses, forcing the server to deplete virtual memory as its internal routing table expands. This directive can be used in a --client-config-dir file or auto-generated by a --client-connect script to override the global value for a particular client.\nNote that this directive affects OpenVPN's internal routing table, not the kernel routing table.\n--opt-verify\nDEPRECATED\nClients that connect with options that are incompatible with those of the server will be disconnected.\nOptions that will be compared for compatibility include dev-type, link-mtu, tun-mtu, proto, ifconfig, comp-lzo, fragment, keydir, cipher, auth, keysize, secret, no-replay, tls-auth, key-method, tls-server and tls-client.\nThis option requires that --disable-occ NOT be used.\n--port-share args\nShare OpenVPN TCP with another service\nValid syntax:\nport-share host port [dir]\nWhen run in TCP server mode, share the OpenVPN port with another application, such as an HTTPS server. If OpenVPN senses a connection to its port which is using a non-OpenVPN protocol, it will proxy the connection to the server at host:port. Currently only designed to work with HTTP/HTTPS, though it would be theoretically possible to extend to other protocols such as ssh. dir specifies an optional directory where a temporary file with name N containing content C will be dynamically generated for each proxy connection, where N is the source IP:port of the client connection and C is the source IP:port of the connection to the proxy receiver. This directory can be used as a dictionary by the proxy receiver to determine the origin of the connection. Each generated file will be automatically deleted when the proxied connection is torn down.\nNot implemented on Windows.\n--push option\nPush a config file option back to the client for remote execution. Note that option must be enclosed in double quotes (\n\"\"\n). The client must specify --pull in its config file. The set of options which can be pushed is limited by both feasibility and security. Some options such as those which would execute scripts are banned, since they would effectively allow a compromised server to execute arbitrary code on the client. Other options such as TLS or MTU parameters cannot be pushed because the client needs to know them before the connection to the server can be initiated.\nThis is a partial list of options which can currently be pushed: --route, --route-gateway, --route-delay, --redirect-gateway, --ip-win32, --dhcp-option, --dns, --inactive, --ping, --ping-exit, --ping-restart, --setenv, --auth-token, --persist-key, --persist-tun, --echo, --comp-lzo, --socket-flags, --sndbuf, --rcvbuf, --session-timeout\n--push-remove opt\nSelectively remove all --push options matching \"opt\" from the option list for a client. opt is matched as a substring against the whole option string to-be-pushed to the client, so --push-remove route would remove all --push route ... and --push route-ipv6 ... statements, while --push-remove \"route-ipv6 2001:\" would only remove IPv6 routes for\n2001:...\nnetworks.\n--push-remove can only be used in a client-specific context, like in a --client-config-dir file, or --client-connect script or plugin -- similar to --push-reset, just more selective.\nNOTE\n: to\nchange\nan option, --push-remove can be used to first remove the old value, and then add a new --push option with the new value.\nNOTE 2\n: due to implementation details, 'ifconfig' and 'ifconfig-ipv6' can only be removed with an exact match on the option (\npush-remove ifconfig\n), no substring matching and no matching on the IPv4/IPv6 address argument is possible.\n--push-reset\nDon't inherit the global push list for a specific client instance. Specify this option in a client-specific context such as with a --client-config-dir configuration file. This option will ignore --push options at the global config file level.\nNOTE\n: --push-reset is very thorough: it will remove almost all options from the list of to-be-pushed options. In many cases, some of these options will need to be re-configured afterwards - specifically, --topology subnet and --route-gateway will get lost and this will break client configs in many cases. Thus, for most purposes, --push-remove is better suited to selectively remove push options for individual clients.\n--server args\nA helper directive designed to simplify the configuration of OpenVPN's server mode. This directive will set up an OpenVPN server which will allocate addresses to clients out of the given network/netmask. The server itself will take the\n.1\naddress of the given network for use as the server-side endpoint of the local TUN/TAP interface. If the optional\nnopool\nflag is given, no dynamic IP address pool will prepared for VPN clients.\nValid syntax:\nserver network netmask [nopool]\nFor example, --server 10.8.0.0 255.255.255.0 expands as follows:\nmode server\ntls-server\npush \"topology [topology]\"\nif dev tun AND (topology == net30 OR topology == p2p):\nifconfig 10.8.0.1 10.8.0.2\nif !nopool:\nifconfig-pool 10.8.0.4 10.8.0.251\nroute 10.8.0.0 255.255.255.0\nif client-to-client:\npush \"route 10.8.0.0 255.255.255.0\"\nelse if topology == net30:\npush \"route 10.8.0.1\"\nif dev tap OR (dev tun AND topology == subnet):\nifconfig 10.8.0.1 255.255.255.0\nif !nopool:\nifconfig-pool 10.8.0.2 10.8.0.253 255.255.255.0\npush \"route-gateway 10.8.0.1\"\nif route-gateway unset:\nroute-gateway 10.8.0.2\nDon't use --server if you are ethernet bridging. Use --server-bridge instead.\n--server-bridge args\nA helper directive similar to --server which is designed to simplify the configuration of OpenVPN's server mode in ethernet bridging configurations.\nValid syntaxes:\nserver-bridge gateway netmask pool-start-IP pool-end-IP\nserver-bridge [nogw]\nIf --server-bridge is used without any parameters, it will enable a DHCP-proxy mode, where connecting OpenVPN clients will receive an IP address for their TAP adapter from the DHCP server running on the OpenVPN server-side LAN. Note that only clients that support the binding of a DHCP client with the TAP adapter (such as Windows) can support this mode. The optional\nnogw\nflag (advanced) indicates that gateway information should not be pushed to the client. To configure ethernet bridging, you must first use your OS's bridging capability to bridge the TAP interface with the ethernet NIC interface. For example, on Linux this is done with the\nbrctl\ntool, and with Windows XP it is done in the Network Connections Panel by selecting the ethernet and TAP adapters and right-clicking on \"Bridge Connections\". Next you you must manually set the IP/netmask on the bridge interface. The gateway and netmask parameters to --server-bridge can be set to either the IP/netmask of the bridge interface, or the IP/netmask of the default gateway/router on the bridged subnet. Finally, set aside a IP range in the bridged subnet, denoted by pool-start-IP and pool-end-IP, for OpenVPN to allocate to connecting clients. For example, server-bridge 10.8.0.4 255.255.255.0 10.8.0.128 10.8.0.254 expands as follows:\nmode server\ntls-server\nifconfig-pool 10.8.0.128 10.8.0.254 255.255.255.0\npush \"route-gateway 10.8.0.4\"\nIn another example, --server-bridge (without parameters) expands as follows:\nmode server\ntls-server\npush \"route-gateway dhcp\"\nOr --server-bridge nogw expands as follows:\nmode server\ntls-server\n--server-ipv6 args\nConvenience-function to enable a number of IPv6 related options at once, namely --ifconfig-ipv6, --ifconfig-ipv6-pool and --push tun-ipv6.\nValid syntax:\nserver-ipv6 ipv6addr/bits\nPushing of the --tun-ipv6 directive is done for older clients which require an explicit --tun-ipv6 in their configuration.\n--stale-routes-check args\nRemove routes which haven't had activity for n seconds (i.e. the ageing time). This check is run every t seconds (i.e. check interval).\nValid syntax:\nstale-routes-check n [t]\nIf t is not present it defaults to n.\nThis option helps to keep the dynamic routing table small. See also --max-routes-per-client\n--username-as-common-name\nUse the authenticated username as the common-name, rather than the common-name from the client certificate. Requires that some form of --auth-user-pass verification is in effect. As the replacement happens after --auth-user-pass verification, the verification script or plugin will still receive the common-name from the certificate.\nThe common_name environment variable passed to scripts and plugins invoked after authentication (e.g, client-connect script) and file names parsed in client-config directory will match the username.\n--verify-client-cert mode\nSpecify whether the client is required to supply a valid certificate.\nPossible mode options are:\nnone\nA client certificate is not required. the client needs to authenticate using username/password only. Be aware that using this directive is less secure than requiring certificates from all clients.If you use this directive, the entire responsibility of authentication will rest on yourÂ --auth-user-pass-verifyÂ script, so keep in mind that bugs in your script could potentially compromise the security of your VPN. --verify-client-certÂ noneÂ is functionally equivalent toÂ --client-cert-not-required.\noptional\nA client may present a certificate but it is not required to do so. When using this directive, you should also use aÂ --auth-user-pass-verifyÂ script to ensure that clients are authenticated using a certificate, a username and password, or possibly even both.Again, the entire responsibility of authentication will rest on yourÂ --auth-user-pass-verifyÂ script, so keep in mind that bugs in your script could potentially compromise the security of your VPN.\nrequire\nThis is the default option. A client is required to present a certificate, otherwise VPN access is refused.\nIf you don't use this directive (or use --verify-client-cert require) but you also specify an --auth-user-pass-verify script, then OpenVPN will perform double authentication. The client certificate verification AND the --auth-user-pass-verify script will need to succeed in order for a client to be authenticated and accepted onto the VPN.\n--vlan-tagging\nServer-only option. Turns the OpenVPN server instance into a switch that understands VLAN-tagging, based on IEEE 802.1Q.\nThe server TAP device and each of the connecting clients is seen as a port of the switch. All client ports are in untagged mode and the server TAP device is VLAN-tagged, untagged or accepts both, depending on the --vlan-accept setting. Ethernet frames with a prepended 802.1Q tag are called \"tagged\". If the VLAN Identifier (VID) field in such a tag is non-zero, the frame is called \"VLAN-tagged\". If the VID is zero, but the Priority Control Point (PCP) field is non-zero, the frame is called \"prio-tagged\". If there is no 802.1Q tag, the frame is \"untagged\". Using the --vlan-pvid v option once per client (see --client-config-dir), each port can be associated with a certain VID. Packets can only be forwarded between ports having the same VID. Therefore, clients with differing VIDs are completely separated from one-another, even if --client-to-client is activated. The packet filtering takes place in the OpenVPN server. Clients should not have any VLAN tagging configuration applied. The --vlan-tagging option is off by default. While turned off, OpenVPN accepts any Ethernet frame and does not perform any special processing for VLAN-tagged packets.\nThis option can only be activated in --dev tap mode.\n--vlan-accept args\nConfigure the VLAN tagging policy for the server TAP device.\nValid syntax:\nvlan-accept  all|tagged|untagged\nThe following modes are available:\ntagged\nAdmit only VLAN-tagged frames. Only VLAN-tagged packets are accepted, while untagged or priority-tagged packets are dropped when entering the server TAP device.\nuntagged\nAdmit only untagged and prio-tagged frames. VLAN-tagged packets are not accepted, while untagged or priority-tagged packets entering the server TAP device are tagged with the value configured for the globalÂ --vlan-pvidÂ setting.\nall\n(default)\nAdmit all frames. All packets are admitted and then treated like untagged or tagged mode respectively.\nNote\n:\nSome vendors refer to switch ports running inÂ taggedÂ mode as \"trunk ports\" and switch ports running inÂ untaggedÂ mode as \"access ports\".\nPackets forwarded from clients to the server are VLAN-tagged with the originating client's PVID, unless the VID matches the global --vlan-pvid, in which case the tag is removed.\nIf no\nPVID\nis configured for a given client (see --vlan-pvid) packets are tagged with 1 by default.\n--vlan-pvid v\nSpecifies which VLAN identifier a \"port\" is associated with. Only valid when --vlan-tagging is specified.\nIn the client context, the setting specifies which VLAN ID a client is associated with. In the global context, the VLAN ID of the server TAP device is set. The latter only makes sense for --vlan-accept untagged and --vlan-accept all modes. Valid values for v go from\n1\nthrough to\n4094\n. The global value defaults to\n1\n. If no --vlan-pvid is specified in the client context, the global value is inherited.\nIn some switch implementations, the\nPVID\nis also referred to as \"Native VLAN\".\nEncryption Options\nSSL Library information\n--show-ciphers\n(Standalone) Show all cipher algorithms to use with the --cipher option.\n--show-digests\n(Standalone) Show all message digest algorithms to use with the --auth option.\n--show-tls\n(Standalone) Show all TLS ciphers supported by the crypto library. OpenVPN uses TLS to secure the control channel, over which the keys that are used to protect the actual VPN traffic are exchanged. The TLS ciphers will be sorted from highest preference (most secure) to lowest.\nBe aware that whether a cipher suite in this list can actually work depends on the specific setup of both peers (e.g. both peers must support the cipher, and an ECDSA cipher suite will not work if you are using an RSA certificate, etc.).\n--show-engines\n(Standalone) Show currently available hardware-based crypto acceleration engines supported by the OpenSSL library.\n--show-groups\n(Standalone) Show all available elliptic curves/groups to use with the --ecdh-curve and tls-groups options.\nGenerating key material\n--genkey args\n(Standalone) Generate a key to be used of the type keytype. if keyfile is left out or empty the key will be output on stdout. See the following sections for the different keytypes.\nValid syntax:\n--genkey keytype keyfile\nValid keytype arguments are:\nsecret\nStandard OpenVPN shared secret keys\ntls-crypt\nAlias for\nsecret\ntls-auth\nAlias for\nsecret\nauth-token\nKey used for --auth-gen-token-key\ntls-crypt-v2-server\nTLS Crypt v2 server key\ntls-crypt-v2-client\nTLS Crypt v2 client key Examples:\n$ openvpn --genkey secret shared.key\n$ openvpn --genkey tls-crypt shared.key\n$ openvpn --genkey tls-auth shared.key\n$ openvpn --genkey tls-crypt-v2-server v2crypt-server.key\n$ openvpn --tls-crypt-v2 v2crypt-server.key --genkey tls-crypt-v2-client v2crypt-client-1.key\nGenerating\nShared Secret Keys\nGenerate a shared secret, for use with the --secret, --tls-auth or --tls-crypt options.\nSyntax:\n$ openvpn --genkey secret|tls-crypt|tls-auth keyfile\nThe key is saved in keyfile. All three variants (--secret, tls-crypt and tls-auth) generate the same type of key. The aliases are added for convenience. If using this for --secret, this file must be shared with the peer over a pre-existing secure channel such as scp(1).\nGenerating\nTLS Crypt v2 Server key\nGenerate a --tls-crypt-v2 key to be used by an OpenVPN server. The key is stored in keyfile.\nSyntax:\n--genkey tls-crypt-v2-server keyfile\nGenerating\nTLS Crypt v2 Client key\nGenerate a --tls-crypt-v2 key to be used by OpenVPN clients. The key is stored in keyfile.\nSyntax\n--genkey tls-crypt-v2-client keyfile [metadata]\nIf supplied, include the supplied metadata in the wrapped client key. This metadata must be supplied in base64-encoded form. The metadata must be at most 733 bytes long (980 characters in base64, though note that 980 base64 characters can encode more than 733 bytes). If no metadata is supplied, OpenVPN will use a 64-bit unix timestamp representing the current time in UTC, encoded in network order, as metadata for the generated key. A tls-crypt-v2 client key is wrapped using a server key. To generate a client key, the user must therefore supply the server key using the --tls-crypt-v2 option. Servers can use --tls-crypt-v2-verify to specify a metadata verification command.\nGenerate\nAuthentication Token key\nGenerate a new secret that can be used with\n--auth-gen-token-secret\nSyntax:\n--genkey auth-token [keyfile]\nNote:\nThis file should be kept secret to the server as anyone that has access to this file will be able to generate auth tokens that the OpenVPN server will accept as valid.\nData Channel Renegotiation\nWhen running OpenVPN in client/server mode, the data channel will use a separate ephemeral encryption key which is rotated at regular intervals.\n--reneg-bytes n\nRenegotiate data channel key after n bytes sent or received (disabled by default with an exception, see below). OpenVPN allows the lifetime of a key to be expressed as a number of bytes encrypted/decrypted, a number of packets, or a number of seconds. A key renegotiation will be forced if any of these three criteria are met by either peer.\nIf using ciphers with cipher block sizes less than 128-bits, --reneg-bytes is set to 64MB by default, unless it is explicitly disabled by setting the value to\n0\n, but this is\nHIGHLY DISCOURAGED\nas this is designed to add some protection against the SWEET32 attack vector. For more information see the --cipher option.\n--reneg-pkts n\nRenegotiate data channel key after\nn\npackets sent and received (disabled by default).\n--reneg-sec args\nRenegotiate data channel key after at most max seconds (default\n3600\n) and at least min seconds (default is 90% of max for servers, and equal to max for clients).\nreneg-sec max [min]\nThe effective --reneg-sec value used is per session pseudo-uniform-randomized between min and max. With the default value of\n3600\nthis results in an effective per session value in the range of\n3240\n..\n3600\nseconds for servers, or just 3600 for clients. When using dual-factor authentication, note that this default value may cause the end user to be challenged to reauthorize once per hour.\nAlso, keep in mind that this option can be used on both the client and server, and whichever uses the lower value will be the one to trigger the renegotiation. A common mistake is to set --reneg-sec to a higher value on either the client or server, while the other side of the connection is still using the default value of\n3600\nseconds, meaning that the renegotiation will still occur once per\n3600\nseconds. The solution is to increase --reneg-sec on both the client and server, or set it to\n0\non one side of the connection (to disable), and to your chosen value on the other side.\nTLS Mode Options\nTLS mode is the most powerful crypto mode of OpenVPN in both security and flexibility. TLS mode works by establishing control and data channels which are multiplexed over a single TCP/UDP port. OpenVPN initiates a TLS session over the control channel and uses it to exchange cipher and HMAC keys to protect the data channel. TLS mode uses a robust reliability layer over the UDP connection for all control channel communication, while the data channel, over which encrypted tunnel data passes, is forwarded without any mediation. The result is the best of both worlds: a fast data channel that forwards over UDP with only the overhead of encrypt, decrypt, and HMAC functions, and a control channel that provides all of the security features of TLS, including certificate-based authentication and Diffie Hellman forward secrecy. To use TLS mode, each peer that runs OpenVPN should have its own local certificate/key pair (--cert and --key), signed by the root certificate which is specified in --ca. When two OpenVPN peers connect, each presents its local certificate to the other. Each peer will then check that its partner peer presented a certificate which was signed by the master root certificate as specified in --ca. If that check on both peers succeeds, then the TLS negotiation will succeed, both OpenVPN peers will exchange temporary session keys, and the tunnel will begin passing data. The OpenVPN project provides a set of scripts for managing RSA certificates and keys:\nhttps://github.com/OpenVPN/easy-rsa\n--askpass file\nGet certificate password from console or file before we daemonize.\nValid syntaxes:\naskpass\naskpass file\nFor the extremely security conscious, it is possible to protect your private key with a password. Of course this means that every time the OpenVPN daemon is started you must be there to type the password. The --askpass option allows you to start OpenVPN from the command line. It will query you for a password before it daemonizes. To protect a private key with a password you should omit the -nodes option when you use the openssl command line tool to manage certificates and private keys.\nIf file is specified, read the password from the first line of file. Keep in mind that storing your password in a file to a certain extent invalidates the extra security provided by using an encrypted key.\n--ca file\nCertificate authority (CA) file in .pem format, also referred to as the\nroot\ncertificate. This file can have multiple certificates in .pem format, concatenated together. You can construct your own certificate authority certificate and private key by using a command such as:\nopenssl req -nodes -new -x509 -keyout ca.key -out ca.crt\nThen edit your openssl.cnf file and edit the certificate variable to point to your new root certificate ca.crt.\nFor testing purposes only, the OpenVPN distribution includes a sample CA certificate (ca.crt). Of course you should never use the test certificates and test keys distributed with OpenVPN in a production environment, since by virtue of the fact that they are distributed with OpenVPN, they are totally insecure.\n--capath dir\nDirectory containing trusted certificates (CAs and CRLs). Not available with mbed TLS.\nCAs in the capath directory are expected to be named <hash>.<n>. CRLs are expected to be named <hash>.r<n>. See the -CApath option of openssl verify, and the -hash option of openssl x509, openssl crl and X509_LOOKUP_hash_dir()(3) for more information.\nSimilar to the --crl-verify option, CRLs are not mandatory - OpenVPN will log the usual warning in the logs if the relevant CRL is missing, but the connection will be allowed.\n--cert file\nLocal peer's signed certificate in .pem format -- must be signed by a certificate authority whose certificate is in --ca file. Each peer in an OpenVPN link running in TLS mode should have its own certificate and private key file. In addition, each certificate should have been signed by the key of a certificate authority whose public key resides in the --ca certificate authority file. You can easily make your own certificate authority (see above) or pay money to use a commercial service such as thawte.com (in which case you will be helping to finance the world's second space tourist :). To generate a certificate, you can use a command such as:\nopenssl req -nodes -new -keyout mycert.key -out mycert.csr\nIf your certificate authority private key lives on another machine, copy the certificate signing request (mycert.csr) to this other machine (this can be done over an insecure channel such as email). Now sign the certificate with a command such as:\nopenssl ca -out mycert.crt -in mycert.csr\nNow copy the certificate (mycert.crt) back to the peer which initially generated the .csr file (this can be over a public medium). Note that the openssl ca command reads the location of the certificate authority key from its configuration file such as\n/usr/share/ssl/openssl.cnf\n-- note also that for certificate authority functions, you must set up the files\nindex.txt\n(may be empty) and\nserial\n(initialize to\n01\n).\n--crl-verify args\nCheck peer certificate against a Certificate Revocation List.\nValid syntax:\ncrl-verify file/directory flag\nExamples:\ncrl-verify crl-file.pem\ncrl-verify /etc/openvpn/crls dir\nA CRL (certificate revocation list) is used when a particular key is compromised but when the overall PKI is still intact. Suppose you had a PKI consisting of a CA, root certificate, and a number of client certificates. Suppose a laptop computer containing a client key and certificate was stolen. By adding the stolen certificate to the CRL file, you could reject any connection which attempts to use it, while preserving the overall integrity of the PKI. The only time when it would be necessary to rebuild the entire PKI from scratch would be if the root certificate key itself was compromised. The option is not mandatory - if the relevant CRL is missing, OpenVPN will log a warning in the logs - e.g.\nVERIFY WARNING: depth=0, unable to get certificate CRL\nbut the connection will be allowed. If the optional\ndir\nflag is specified, enable a different mode where the crl-verify is pointed at a directory containing files named as revoked serial numbers (the files may be empty, the contents are never read). If a client requests a connection, where the client certificate serial number (decimal string) is the name of a file present in the directory, it will be rejected.\nNote:\nAs the crl file (or directory) is read every time a peer connects, if you are dropping root privileges withÂ --user, make sure that this user has sufficient privileges to read the file.\n--dh file\nFile containing Diffie Hellman parameters in .pem format (required for --tls-server only).\nSet file to\nnone\nto disable Diffie Hellman key exchange (and use ECDH only). Note that this requires peers to be using an SSL library that supports ECDH TLS cipher suites (e.g. OpenSSL 1.0.1+, or mbed TLS 2.0+).\nUse openssl dhparam -out dh2048.pem 2048 to generate 2048-bit DH parameters. Diffie Hellman parameters may be considered public.\n--ecdh-curve name\nSpecify the curve to use for elliptic curve Diffie Hellman. Available curves can be listed with --show-curves. The specified curve will only be used for ECDH TLS-ciphers.\nThis option is not supported in mbed TLS builds of OpenVPN.\n--extra-certs file\nSpecify a file containing one or more PEM certs (concatenated together) that complete the local certificate chain.\nThis option is useful for \"split\" CAs, where the CA for server certs is different than the CA for client certs. Putting certs in this file allows them to be used to complete the local certificate chain without trusting them to verify the peer-submitted certificate, as would be the case if the certs were placed in the ca file.\n--hand-window n\nHandshake Window -- the TLS-based key exchange must finalize within n seconds of handshake initiation by any peer (default\n60\nseconds). If the handshake fails we will attempt to reset our connection with our peer and try again. Even in the event of handshake failure we will still use our expiring key for up to --tran-window seconds to maintain continuity of transmission of tunnel data.\nThe --hand-window parameter also controls the amount of time that the OpenVPN client repeats the pull request until it times out.\n--key file\nLocal peer's private key in .pem format. Use the private key which was generated when you built your peer's certificate (see --cert file above).\n--pkcs12 file\nSpecify a PKCS #12 file containing local private key, local certificate, and root CA certificate. This option can be used instead of --ca, --cert, and --key. Not available with mbed TLS.\n--remote-cert-eku oid\nRequire that peer certificate was signed with an explicit\nextended key usage\n.\nThis is a useful security option for clients, to ensure that the host they connect to is a designated server.\nThe extended key usage should be encoded in\noid notation\n, or\nOpenSSL symbolic representation\n.\n--remote-cert-ku key-usage\nRequire that peer certificate was signed with an explicit key-usage.\nIf present in the certificate, the\nkeyUsage\nvalue is validated by the TLS library during the TLS handshake. Specifying this option without arguments requires this extension to be present (so the TLS library will verify it). If key-usage is a list of usage bits, the\nkeyUsage\nfield must have\nat least\nthe same bits set as the bits in\none of\nthe values supplied in the key-usage list. The key-usage values in the list must be encoded in hex, e.g.\nremote-cert-ku a0\n--remote-cert-tls type\nRequire that peer certificate was signed with an explicit\nkey usage\nand\nextended key usage\nbased on RFC3280 TLS rules.\nValid syntaxes:\nremote-cert-tls server\nremote-cert-tls client\nThis is a useful security option for clients, to ensure that the host they connect to is a designated server. Or the other way around; for a server to verify that only hosts with a client certificate can connect. The --remote-cert-tls client option is equivalent to\nremote-cert-ku\nremote-cert-eku \"TLS Web Client Authentication\"\nThe --remote-cert-tls server option is equivalent to\nremote-cert-ku\nremote-cert-eku \"TLS Web Server Authentication\"\nThis is an important security precaution to protect against a man-in-the-middle attack where an authorized client attempts to connect to another client by impersonating the server. The attack is easily prevented by having clients verify the server certificate using any one of --remote-cert-tls, --verify-x509-name, --peer-fingerprint or --tls-verify.\n--tls-auth args\nAdd an additional layer of HMAC authentication on top of the TLS control channel to mitigate DoS attacks and attacks on the TLS stack.\nValid syntaxes:\ntls-auth file\ntls-auth file 0\ntls-auth file 1\nIn a nutshell, --tls-auth enables a kind of \"HMAC firewall\" on OpenVPN's TCP/UDP port, where TLS control channel packets bearing an incorrect HMAC signature can be dropped immediately without response. file (required) is a file in OpenVPN static key format which can be generated by --genkey. Older versions (up to OpenVPN 2.3) supported a freeform passphrase file. This is no longer supported in newer versions (v2.4+). See the --secret option for more information on the optional direction parameter. --tls-auth is recommended when you are running OpenVPN in a mode where it is listening for packets from any IP address, such as when --remote is not specified, or --remote is specified with --float. The rationale for this feature is as follows. TLS requires a multi-packet exchange before it is able to authenticate a peer. During this time before authentication, OpenVPN is allocating resources (memory and CPU) to this potential peer. The potential peer is also exposing many parts of OpenVPN and the OpenSSL library to the packets it is sending. Most successful network attacks today seek to either exploit bugs in programs (such as buffer overflow attacks) or force a program to consume so many resources that it becomes unusable. Of course the first line of defense is always to produce clean, well-audited code. OpenVPN has been written with buffer overflow attack prevention as a top priority. But as history has shown, many of the most widely used network applications have, from time to time, fallen to buffer overflow attacks. So as a second line of defense, OpenVPN offers this special layer of authentication on top of the TLS control channel so that every packet on the control channel is authenticated by an HMAC signature and a unique ID for replay protection. This signature will also help protect against DoS (Denial of Service) attacks. An important rule of thumb in reducing vulnerability to DoS attacks is to minimize the amount of resources a potential, but as yet unauthenticated, client is able to consume. --tls-auth does this by signing every TLS control channel packet with an HMAC signature, including packets which are sent before the TLS level has had a chance to authenticate the peer. The result is that packets without the correct signature can be dropped immediately upon reception, before they have a chance to consume additional system resources such as by initiating a TLS handshake. --tls-auth can be strengthened by adding the --replay-persist option which will keep OpenVPN's replay protection state in a file so that it is not lost across restarts. It should be emphasized that this feature is optional and that the key file used with --tls-auth gives a peer nothing more than the power to initiate a TLS handshake. It is not used to encrypt or authenticate any tunnel data.\nUse --tls-crypt instead if you want to use the key file to not only authenticate, but also encrypt the TLS control channel.\n--tls-groups list\nA list of allowable groups/curves in order of preference.\nSet the allowed elliptic curves/groups for the TLS session. These groups are allowed to be used in signatures and key exchange. mbedTLS currently allows all known curves per default. OpenSSL 1.1+ restricts the list per default to\n\"X25519:secp256r1:X448:secp521r1:secp384r1\".\nIf you use certificates that use non-standard curves, you might need to add them here. If you do not force the ecdh curve by using --ecdh-curve, the groups for ecdh will also be picked from this list. OpenVPN maps the curve name secp256r1 to prime256v1 to allow specifying the same tls-groups option for mbedTLS and OpenSSL.\nWarning: this option not only affects elliptic curve certificates but also the key exchange in TLS 1.3 and using this option improperly will disable TLS 1.3.\n--tls-cert-profile profile\nSet the allowed cryptographic algorithms for certificates according to profile.\nThe following profiles are supported:\ninsecure\nIdentical for mbed TLS toÂ legacy\nlegacy\n(default)\nSHA1 and newer, RSA 2048-bit+, any elliptic curve.\npreferred\nSHA2 and newer, RSA 2048-bit+, any elliptic curve.\nsuiteb\nSHA256/SHA384, ECDSA with P-256 or P-384.\nThis option is only fully supported for mbed TLS builds. OpenSSL builds use the following approximation:\ninsecure\nsets \"security level 0\"\nlegacy\n(default)\nsets \"security level 1\"\npreferred\nsets \"security level 2\"\nsuiteb\nsets \"security level 3\" andÂ --tls-cipherÂ \"SUITEB128\".\nOpenVPN will migrate to 'preferred' as default in the future. Please ensure that your keys already comply.\nWARNING:\n--tls-ciphers, --tls-ciphersuites and tls-groups\nThese options are expert features, which - if used correctly - can improve the security of your VPN connection. But it is also easy to unwittingly use them to carefully align a gun with your foot, or just break your connection. Use with care!\n--tls-cipher l\nA list l of allowable TLS ciphers delimited by a colon (\"\n:\n\").\nThese setting can be used to ensure that certain cipher suites are used (or not used) for the TLS connection. OpenVPN uses TLS to secure the control channel, over which the keys that are used to protect the actual VPN traffic are exchanged. The supplied list of ciphers is (after potential OpenSSL/IANA name translation) simply supplied to the crypto library. Please see the OpenSSL and/or mbed TLS documentation for details on the cipher list interpretation. For OpenSSL, the --tls-cipher is used for TLS 1.2 and below. Use --show-tls to see a list of TLS ciphers supported by your crypto library.\nThe default for --tls-cipher is to use mbed TLS's default cipher list when using mbed TLS or\nDEFAULT:!EXP:!LOW:!MEDIUM:!kDH:!kECDH:!DSS:!PSK:!SRP:!kRSA\nwhen using OpenSSL.\n--tls-ciphersuites l\nSame as --tls-cipher but for TLS 1.3 and up. mbed TLS has no TLS 1.3 support yet and only the --tls-cipher setting is used.\nThe default for --tls-ciphersuites is to use the crypto library's default.\n--tls-client\nEnable TLS and assume client role during TLS handshake.\n--tls-crypt keyfile\nEncrypt and authenticate all control channel packets with the key from keyfile. (See --tls-auth for more background.)\nEncrypting (and authenticating) control channel packets:\nprovides more privacy by hiding the certificate used for the TLS connection,\nmakes it harder to identify OpenVPN traffic as such,\nprovides \"poor-man's\" post-quantum security, against attackers who will never know the pre-shared key (i.e. no forward secrecy).\nIn contrast to --tls-auth, --tls-crypt does\nnot\nrequire the user to set --key-direction.\nSecurity Considerations\nAll peers use the same --tls-crypt pre-shared group key to authenticate and encrypt control channel messages. To ensure that IV collisions remain unlikely, this key should not be used to encrypt more than 2^48 client-to-server or 2^48 server-to-client control channel messages. A typical initial negotiation is about 10 packets in each direction. Assuming both initial negotiation and renegotiations are at most 2^16 (65536) packets (to be conservative), and (re)negotiations happen each minute for each user (24/7), this limits the tls-crypt key lifetime to 8171 years divided by the number of users. So a setup with 1000 users should rotate the key at least once each eight years. (And a setup with 8000 users each year.) If IV collisions were to occur, this could result in the security of --tls-crypt degrading to the same security as using --tls-auth. That is, the control channel still benefits from the extra protection against active man-in-the-middle-attacks and DoS attacks, but may no longer offer extra privacy and post-quantum security on top of what TLS itself offers.\nFor large setups or setups where clients are not trusted, consider using --tls-crypt-v2 instead. That uses per-client unique keys, and thereby improves the bounds to 'rotate a client key at least once per 8000 years'.\n--tls-crypt-v2 keyfile\nValid syntax:\ntls-crypt-v2 keyfile\ntls-crypt-v2 keyfile force-cookie\ntls-crypt-v2 keyfile allow-noncookie\nUse client-specific tls-crypt keys. For clients, keyfile is a client-specific tls-crypt key. Such a key can be generated using the\n--genkey tls-crypt-v2-client\noption. For servers, keyfile is used to unwrap client-specific keys supplied by the client during connection setup. This key must be the same as the key used to generate the client-specific key (see\n--genkey tls-crypt-v2-client\n). On servers, this option can be used together with the --tls-auth or --tls-crypt option. In that case, the server will detect whether the client is using client-specific keys, and automatically select the right mode.\nThe optional parameters\nforce-cookie\nallows only tls-crypt-v2 clients that support a cookie based stateless three way handshake that avoids replay attacks and state exhaustion on the server side (OpenVPN 2.6 and later). The option\nallow-noncookie\nexplicitly allows older tls-crypt-v2 clients. The default is (currently)\nallow-noncookie\n.\n--tls-crypt-v2-verify cmd\nRun command cmd to verify the metadata of the client-specific tls-crypt-v2 key of a connecting client. This allows server administrators to reject client connections, before exposing the TLS stack (including the notoriously dangerous X.509 and ASN.1 stacks) to the connecting client.\nOpenVPN supplies the following environment variables to the command (and only these variables. The normal environment variables available for other scripts are NOT present):\nscript_type\nis set to\ntls-crypt-v2-verify\nmetadata_type\nis set to\n0\nif the metadata was user supplied, or\n1\nif it's a 64-bit unix timestamp representing the key creation time.\nmetadata_file\ncontains the filename of a temporary file that contains the client metadata.\nThe command can reject the connection by exiting with a non-zero exit code.\n--tls-exit\nExit on TLS negotiation failure. This option can be useful when you only want to make one attempt at connecting, e.g. in a test or monitoring script. (OpenVPN's own test suite uses it this way.)\n--tls-server\nEnable TLS and assume server role during TLS handshake. Note that OpenVPN is designed as a peer-to-peer application. The designation of client or server is only for the purpose of negotiating the TLS control channel.\n--tls-timeout n\nPacket retransmit timeout on TLS control channel if no acknowledgment from remote within n seconds (default\n2\n). When OpenVPN sends a control packet to its peer, it will expect to receive an acknowledgement within n seconds or it will retransmit the packet, subject to a TCP-like exponential backoff algorithm. This parameter only applies to control channel packets. Data channel packets (which carry encrypted tunnel data) are never acknowledged, sequenced, or retransmitted by OpenVPN because the higher level network protocols running on top of the tunnel such as TCP expect this role to be left to them.\n--tls-version-min args\nSets the minimum TLS version we will accept from the peer (default in 2.6.0 and later is \"1.2\").\nValid syntax:\ntls-version-min version ['or-highest']\nExamples for version include\n1.0\n,\n1.1\n, or\n1.2\n. If\nor-highest\nis specified and version is not recognized, we will only accept the highest TLS version supported by the local SSL implementation.\n--tls-version-max version\nSet the maximum TLS version we will use (default is the highest version supported). Examples for version include\n1.0\n,\n1.1\n, or\n1.2\n.\n--verify-hash args\nDEPRECATED\nSpecify SHA1 or SHA256 fingerprint for level-1 cert.\nValid syntax:\nverify-hash hash [algo]\nThe level-1 cert is the CA (or intermediate cert) that signs the leaf certificate, and is one removed from the leaf certificate in the direction of the root. When accepting a connection from a peer, the level-1 cert fingerprint must match hash or certificate verification will fail. Hash is specified as XX:XX:... For example:\nAD:B0:95:D8:09:C8:36:45:12:A9:89:C8:90:09:CB:13:72:A6:AD:16\nThe algo flag can be either\nSHA1\nor\nSHA256\n. If not provided, it defaults to\nSHA1\n. This option can also be inlined\n<verify-hash>\n00:11:22:33:44:55:66:77:88:99:aa:bb:cc:dd:ee:ff:00:11:22:33:44:55:66:77:88:99:aa:bb:cc:dd:ee:ff\n11:22:33:44:55:66:77:88:99:aa:bb:cc:dd:ee:ff:00:11:22:33:44:55:66:77:88:99:aa:bb:cc:dd:ee:ff:00\n</verify-hash>\nIf the option is inlined, algo is always\nSHA256\n.\n--peer-fingerprint args\nSpecify a SHA256 fingerprint or list of SHA256 fingerprints to verify the peer certificate against. The peer certificate must match one of the fingerprint or certificate verification will fail. The option can also be inlined\nValid syntax:\npeer-fingerprint AD:B0:95:D8:09:...\nor inline:\n<peer-fingerprint>\n00:11:22:33:44:55:66:77:88:99:aa:bb:cc:dd:ee:ff:00:11:22:33:44:55:66:77:88:99:aa:bb:cc:dd:ee:ff\n11:22:33:44:55:66:77:88:99:aa:bb:cc:dd:ee:ff:00:11:22:33:44:55:66:77:88:99:aa:bb:cc:dd:ee:ff:00\n</peer-fingerprint>\nWhen the --peer-fingerprint option is used, specifying a CA with --ca or --capath is optional. This allows the he --peer-fingerprint to be used as alternative to a PKI with self-signed certificates for small setups. See the examples section for such a setup.\n--verify-x509-name args\nAccept connections only if a host's X.509 name is equal to\nname.\nThe remote host must also pass all other tests of verification.\nValid syntax:\nverify-x509 name type\nWhich X.509 name is compared to name depends on the setting of type. type can be\nsubject\nto match the complete subject DN (default),\nname\nto match a subject RDN or\nname-prefix\nto match a subject RDN prefix. Which RDN is verified as name depends on the --x509-username-field option. But it defaults to the common name (CN), e.g. a certificate with a subject DN\nC=KG, ST=NA, L=Bishkek, CN=Server-1\nwould be matched by:\nverify-x509-name 'C=KG, ST=NA, L=Bishkek, CN=Server-1'\nverify-x509-name Server-1 name\nverify-x509-name Server- name-prefix\nThe last example is useful if you want a client to only accept connections to\nServer-1\n,\nServer-2\n, etc. --verify-x509-name is a useful replacement for the --tls-verify option to verify the remote host, because --verify-x509-name works in a --chroot environment without any dependencies. Using a name prefix is a useful alternative to managing a CRL (Certificate Revocation List) on the client, since it allows the client to refuse all certificates except for those associated with designated servers.\nNOTE:\nTest against a name prefix only when you are using OpenVPN with a custom CA certificate that is under your control. Never use this option with typeÂ name-prefixÂ when your client certificates are signed by a third party, such as a commercial web CA.\n--x509-track attribute\nSave peer X509\nattribute\nvalue in environment for use by plugins and management interface. Prepend a\n+\nto attribute to save values from full cert chain. Otherwise the attribute will only be exported for the leaf cert (i.e. depth\n0\nof the cert chain). Values will be encoded as\nX509_<depth>_<attribute>=<value>\n. Multiple --x509-track options can be defined to track multiple attributes.\nattribute can be any part of the X509 Subject field or any X509v3 extension (RFC 3280). X509v3 extensions might not be supported when not using the default TLS backend library (OpenSSL). You can also request the SHA1 and SHA256 fingerprints of the cert, but that is always exported as\ntls_digest_{n}\nand\ntls_digest_sha256_{n}\nanyway. Note that by default\nall\nparts of the X509 Subject field are exported in the environment for the whole cert chain. If you use --x509-track at least once\nonly\nthe attributes specified by these options are exported. Examples:\nx509-track CN               # exports only X509_0_CN\nx509-track +CN              # exports X509_{n}_CN for chain\nx509-track basicConstraints # exports value of \"X509v3 Basic Constraints\"\nx509-track SHA256           # exports SHA256 fingerprint\n--x509-username-field args\nFields in the X.509 certificate subject to be used as the username (default\nCN\n). If multiple fields are specified their values will be concatenated into the one username using\n_\nsymbol as a separator.\nValid syntax:\nx509-username-field [ext:]fieldname [[ext:]fieldname...]\nTypically, this option is specified with\nfieldname\narguments as either of the following:\nx509-username-field emailAddress\nx509-username-field ext:subjectAltName\nx509-username-field CN serialNumber\nThe first example uses the value of the\nemailAddress\nattribute in the certificate's Subject field as the username. The second example uses the\next:\nprefix to signify that the X.509 extension fieldname\nsubjectAltName\nbe searched for an rfc822Name (email) field to be used as the username. In cases where there are multiple email addresses in\next:fieldname\n, the last occurrence is chosen. The last example uses the value of the\nCN\nattribute in the Subject field, combined with the\n_\nseparator and the hexadecimal representation of the certificate's\nserialNumber\n. When this option is used, the --verify-x509-name option will match against the chosen fieldname instead of the Common Name. Only the\nsubjectAltName\nand\nissuerAltName\nX.509 extensions and\nserialNumber\nX.509 attribute are supported.\nPlease note:\nThis option has a feature which will convert an all-lowercase fieldname to uppercase characters, e.g.,\nou\n->\nOU\n. A mixed-case fieldname or one having the\next:\nprefix will be left as-is. This automatic upcasing feature is deprecated and will be removed in a future release.\nNon-compliant symbols are being replaced with the\n_\nsymbol, same as the field separator, so concatenating multiple fields with such or\n_\nsymbols can potentially lead to username collisions.\nPKCS#11 / SmartCard options\n--pkcs11-cert-private args\nSet if access to certificate object should be performed after login. Every provider has its own setting.\nValid syntaxes:\npkcs11-cert-private 0\npkcs11-cert-private 1\n--pkcs11-id name\nSpecify the serialized certificate id to be used. The id can be gotten by the standalone --show-pkcs11-ids option. See also the description of --pkcs11-providers option.\n--pkcs11-id-management\nAcquire PKCS#11 id from management interface. In this case a\nNEED-STR 'pkcs11-id-request'\nreal-time message will be triggered, application may use pkcs11-id-count command to retrieve available number of certificates, and pkcs11-id-get command to retrieve certificate id and certificate body. See also the description of --pkcs11-providers option.\n--pkcs11-pin-cache seconds\nSpecify how many seconds the PIN can be cached, the default is until the token is removed.\n--pkcs11-private-mode mode\nSpecify which method to use in order to perform private key operations. A different mode can be specified for each provider. Mode is encoded as hex number, and can be a mask one of the following:\n0\n(default) Try to determine automatically.\n1\nUse sign.\n2\nUse sign recover.\n4\nUse decrypt.\n8\nUse unwrap.\n--pkcs11-protected-authentication args\nUse PKCS#11 protected authentication path, useful for biometric and external keypad devices. Every provider has its own setting.\nValid syntaxes:\npkcs11-protected-authentication 0\npkcs11-protected-authentication 1\n--pkcs11-providers providers\nSpecify an RSA Security Inc. PKCS #11 Cryptographic Token Interface (Cryptoki) providers to load. A space-separated list of one or more provider library names may be specified. This option along with --pkcs11-id or pkcs11-id-management can be used instead of --cert and --key or --pkcs12.\nIf p11-kit is present on the system and was enabled during build, its\np11-kit-proxy.so\nmodule will be loaded by default if either the --pkcs11-id or --pkcs11-id-management options is present without --pkcs11-providers. If default loading is not enabled in the build and no providers are specified, the former options will be ignored.\n--show-pkcs11-ids args\n(Standalone) Show PKCS#11 token object list.\nValid syntax:\nshow-pkcs11 [provider] [cert_private]\nSpecify cert_private as\n1\nif certificates are stored as private objects. If\np11-kit\nis present on the system, the provider argument is optional; if omitted the default\np11-kit-proxy.so\nmodule will be queried.\n--verb option can be used BEFORE this option to produce debugging information.\nData channel cipher negotiation\nOpenVPN 2.4 and higher have the capability to negotiate the data cipher that is used to encrypt data packets. This section describes the mechanism in more detail and the different backwards compatibility mechanism with older server and clients.\nOpenVPN 2.5 and later behaviour\nWhen both client and server are at least running OpenVPN 2.5, that the order of the ciphers of the server's --data-ciphers is used to pick the data cipher. That means that the first cipher in that list that is also in the client's --data-ciphers list is chosen. If no common cipher is found the client is rejected with a AUTH_FAILED message (as seen in client log):\nAUTH: Received control message: AUTH_FAILED,Data channel cipher negotiation failed (no shared cipher)\nOpenVPN 2.5 and later will only allow the ciphers specified in --data-ciphers. If --data-ciphers is not set the default is\nAES-256-GCM:AES-128-GCM\n. In 2.6 and later the default is changed to\nAES-256-GCM:AES-128-GCM:CHACHA20-POLY1305\nwhen Chacha20-Poly1305 is available. For backwards compatibility OpenVPN 2.6 and later with --compat-mode 2.4.x (or lower) and OpenVPN 2.5 will automatically add a cipher specified using the --cipher option to this list.\nOpenVPN 2.4 clients\nThe negotiation support in OpenVPN 2.4 was the first iteration of the implementation and still had some quirks. Its main goal was \"upgrade to AES-256-GCM when possible\". An OpenVPN 2.4 client that is built against a crypto library that supports AES in GCM mode and does not have --ncp-disable will always announce support for AES-256-GCM and AES-128-GCM to a server by sending\nIV_NCP=2\n. This only causes a problem if --ncp-ciphers option has been changed from the default of\nAES-256-GCM:AES-128-GCM\nto a value that does not include these two ciphers. When an OpenVPN server tries to use AES-256-GCM or AES-128-GCM the connection will then fail. It is therefore recommended to always have the AES-256-GCM and AES-128-GCM ciphers to the --ncp-ciphers options to avoid this behaviour.\nOpenVPN 3 clients\nClients based on the OpenVPN 3.x library (\nhttps://github.com/openvpn/openvpn3/\n) do not have a configurable --ncp-ciphers or --data-ciphers option. Newer versions by default disable legacy AES-CBC, BF-CBC, and DES-CBC ciphers. These clients will always announce support for all their supported AEAD ciphers (AES-256-GCM, AES-128-GCM and in newer versions also Chacha20-Poly1305). To support OpenVPN 3.x based clients at least one of these ciphers needs to be included in the server's --data-ciphers option.\nOpenVPN 2.3 and older clients (and clients with --ncp-disable)\nWhen a client without cipher negotiation support connects to a server the cipher specified with the --cipher option in the client configuration must be included in the --data-ciphers option of the server to allow the client to connect. Otherwise the client will be sent the AUTH_FAILED message that indicates no shared cipher. If the client is 2.3 or older and has been configured with the --enable-small\n./configure\nargument, using data-ciphers-fallback cipher in the server config file with the explicit cipher used by the client is necessary.\nOpenVPN 2.4 server\nWhen a client indicates support for AES-128-GCM and AES-256-GCM (with IV_NCP=2) an OpenVPN 2.4 server will send the first cipher of the --ncp-ciphers to the OpenVPN client regardless of what the cipher is. To emulate the behaviour of an OpenVPN 2.4 client as close as possible and have compatibility to a setup that depends on this quirk, adding AES-128-GCM and AES-256-GCM to the client's --data-ciphers option is required. OpenVPN 2.5+ will only announce the IV_NCP=2 flag if those ciphers are present.\nOpenVPN 2.3 and older servers (and servers with --ncp-disable)\nThe cipher used by the server must be included in --data-ciphers to allow the client connecting to a server without cipher negotiation support. (For compatibility OpenVPN 2.5 will also accept the cipher set with --cipher) If the server is 2.3 or older and has been configured with the --enable-small\n./configure\nargument, adding --data-ciphers-fallback cipher to the client config with the explicit cipher used by the server is necessary.\nBlowfish in CBC mode (BF-CBC) deprecation\nThe --cipher option defaulted to BF-CBC in OpenVPN 2.4 and older version. The default was never changed to ensure backwards compatibility. In OpenVPN 2.5 this behaviour has now been changed so that if the --cipher is not explicitly set it does not allow the weak BF-CBC cipher any more and needs to explicitly added as --cipher BFC-CBC or added to --data-ciphers. We strongly recommend to switching away from BF-CBC to a more secure cipher as soon as possible instead.\nNETWORK CONFIGURATION\nOpenVPN consists of two sides of network configuration. One side is the\nlink\nbetween the local and remote side, the other side is the\nvirtual network adapter\n(tun/tap device).\nLink Options\nThis link options section covers options related to the connection between the local and the remote host.\n--bind keywords\nBind to local address and port. This is the default unless any of --proto tcp-client , --http-proxy or --socks-proxy are used.\nIf the optional\nipv6only\nkeyword is present OpenVPN will bind only to IPv6 (as opposed to IPv6 and IPv4) when a IPv6 socket is opened.\n--float\nAllow remote peer to change its IP address and/or port number, such as due to DHCP (this is the default if --remote is not used). --float when specified with --remote allows an OpenVPN session to initially connect to a peer at a known address, however if packets arrive from a new address and pass all authentication tests, the new address will take control of the session. This is useful when you are connecting to a peer which holds a dynamic address such as a dial-in user or DHCP client.\nEssentially, --float tells OpenVPN to accept authenticated packets from any address, not only the address which was specified in the --remote option.\n--fragment args\nValid syntax:\nfragment max\nfragment max mtu\nEnable internal datagram fragmentation so that no UDP datagrams are sent which are larger than max bytes. If the\nmtu\nparameter is present the max parameter is interpreted to include IP and UDP encapsulation overhead. The\nmtu\nparameter is introduced in OpenVPN version 2.6.0. If the\nmtu\nparameter is absent, the max parameter is interpreted in the same way as the --link-mtu parameter, i.e. the UDP packet size after encapsulation overhead has been added in, but not including the UDP header itself. The --fragment option only makes sense when you are using the UDP protocol (--proto udp). --fragment adds 4 bytes of overhead per datagram. See the --mssfix option below for an important related option to --fragment. It should also be noted that this option is not meant to replace UDP fragmentation at the IP stack level. It is only meant as a last resort when path MTU discovery is broken. Using this option is less efficient than fixing path MTU discovery for your IP link and using native IP fragmentation instead.\nHaving said that, there are circumstances where using OpenVPN's internal fragmentation capability may be your only option, such as tunneling a UDP multicast stream which requires fragmentation.\n--keepalive args\nA helper directive designed to simplify the expression of --ping and --ping-restart.\nValid syntax:\nkeepalive interval timeout\nSend ping once every interval seconds, restart if ping is not received for timeout seconds. This option can be used on both client and server side, but it is enough to add this on the server side as it will push appropriate --ping and --ping-restart options to the client. If used on both server and client, the values pushed from server will override the client local values. The timeout argument will be twice as long on the server side. This ensures that a timeout is detected on client side before the server side drops the connection. For example, --keepalive 10 60 expands as follows:\nif mode server:\nping 10                    # Argument: interval\nping-restart 120           # Argument: timeout*2\npush \"ping 10\"             # Argument: interval\npush \"ping-restart 60\"     # Argument: timeout\nelse\nping 10                    # Argument: interval\nping-restart 60            # Argument: timeout\n--link-mtu n\nDEPRECATED\nSets an upper bound on the size of UDP packets which are sent between OpenVPN peers.\nIt's best not to set this parameter unless you know what you're doing.\nDue to variable header size of IP header (20 bytes for IPv4 and 40 bytes for IPv6) and dynamically negotiated data channel cipher, this option is not reliable. It is recommended to set tun-mtu with enough headroom instead.\n--local host\nLocal host name or IP address for bind. If specified, OpenVPN will bind to this address only. If unspecified, OpenVPN will bind to all interfaces.\n--lport port\nSet local TCP/UDP port number or name. Cannot be used together with --nobind option.\n--mark value\nMark encrypted packets being sent with value. The mark value can be matched in policy routing and packetfilter rules. This option is only supported in Linux and does nothing on other operating systems.\n--mode m\nSet OpenVPN major mode. By default, OpenVPN runs in point-to-point mode (\np2p\n). OpenVPN 2.0 introduces a new mode (\nserver\n) which implements a multi-client server capability.\n--mssfix args\nValid syntax:\nmssfix max [mtu]\nmssfix max [fixed]\nmssfix\nAnnounce to TCP sessions running over the tunnel that they should limit their send packet sizes such that after OpenVPN has encapsulated them, the resulting UDP packet size that OpenVPN sends to its peer will not exceed max bytes. The default value is\n1492 mtu\n. Use\n0\nas max to disable mssfix. If the\nmtu\nparameter is specified the max value is interpreted as the resulting packet size of VPN packets including the IP and UDP header. Support for the\nmtu\nparameter was added with OpenVPN version 2.6.0. If the\nmtu\nparameter is not specified, the max parameter is interpreted in the same way as the --link-mtu parameter, i.e. the UDP packet size after encapsulation overhead has been added in, but not including the UDP header itself. Resulting packet would be at most 28 bytes larger for IPv4 and 48 bytes for IPv6 (20/40 bytes for IP header and 8 bytes for UDP header). Default value of 1450 allows OpenVPN packets to be transmitted over IPv4 on a link with MTU 1478 or higher without IP level fragmentation (and 1498 for IPv6). If the\nfixed\nparameter is specified, OpenVPN will make no attempt to calculate the VPN encapsulation overhead but instead will set the MSS to limit the size of the payload IP packets to the specified number. IPv4 packets will have the MSS value lowered to mssfix - 40 and IPv6 packets to mssfix - 60. if --mssfix is specified is specified without any parameter it inherits the parameters of --fragment if specified or uses the default for --mssfix otherwise. The --mssfix option only makes sense when you are using the UDP protocol for OpenVPN peer-to-peer communication, i.e. --proto udp. --mssfix and --fragment can be ideally used together, where --mssfix will try to keep TCP from needing packet fragmentation in the first place, and if big packets come through anyhow (from protocols other than TCP), --fragment will internally fragment them. --max-packet-size, --fragment, and --mssfix are designed to work around cases where Path MTU discovery is broken on the network path between OpenVPN peers. The usual symptom of such a breakdown is an OpenVPN connection which successfully starts, but then stalls during active usage. If --fragment and --mssfix are used together, --mssfix will take its default max parameter from the --fragment max option. Therefore, one could lower the maximum UDP packet size to 1300 (a good first try for solving MTU-related connection problems) with the following options:\n--tun-mtu 1500 --fragment 1300 --mssfix\nIf the max-packet-size size option is used in the configuration it will also act as if mssfix size mtu was specified in the configuration.\n--mtu-disc type\nShould we do Path MTU discovery on TCP/UDP channel? Only supported on OSes such as Linux that supports the necessary system call to set.\nValid types:\nno\nNever send DF (Don't Fragment) frames\nmaybe\nUse per-route hints\nyes\nAlways DF (Don't Fragment)\n--mtu-test\nTo empirically measure MTU on connection startup, add the --mtu-test option to your configuration. OpenVPN will send ping packets of various sizes to the remote peer and measure the largest packets which were successfully received. The --mtu-test process normally takes about 3 minutes to complete.\n--nobind\nDo not bind to local address and port. The IP stack will allocate a dynamic port for returning packets. Since the value of the dynamic port could not be known in advance by a peer, this option is only suitable for peers which will be initiating connections by using the --remote option.\n--passtos\nSet the TOS field of the tunnel packet to what the payload's TOS is.\n--ping n\nPing remote over the TCP/UDP control channel if no packets have been sent for at least n seconds (specify --ping on both peers to cause ping packets to be sent in both directions since OpenVPN ping packets are not echoed like IP ping packets). When used in one of OpenVPN's secure modes (where --secret, --tls-server or --tls-client is specified), the ping packet will be cryptographically secure.\nThis option has two intended uses:\nCompatibility with stateful firewalls. The periodic ping will ensure that a stateful firewall rule which allows OpenVPN UDP packets to pass will not time out.\nTo provide a basis for the remote to test the existence of its peer using the --ping-exit option.\nWhen using OpenVPN in server mode see also --keepalive.\n--ping-exit n\nCauses OpenVPN to exit after n seconds pass without reception of a ping or other packet from remote. This option can be combined with --inactive, --ping and --ping-exit to create a two-tiered inactivity disconnect.\nFor example,\nopenvpn [options...] --inactive 3600 --ping 10 --ping-exit 60\nwhen used on both peers will cause OpenVPN to exit within 60 seconds if its peer disconnects, but will exit after one hour if no actual tunnel data is exchanged.\n--ping-restart n\nSimilar to --ping-exit, but trigger a\nSIGUSR1\nrestart after n seconds pass without reception of a ping or other packet from remote.\nThis option is useful in cases where the remote peer has a dynamic IP address and a low-TTL DNS name is used to track the IP address using a service such as\nhttps://www.nsupdate.info/\n+ a dynamic DNS client such as ddclient. If the peer cannot be reached, a restart will be triggered, causing the hostname used with --remote to be re-resolved (if --resolv-retry is also specified). In server mode, --ping-restart, --inactive or any other type of internally generated signal will always be applied to individual client instance objects, never to whole server itself. Note also in server mode that any internally generated signal which would normally cause a restart, will cause the deletion of the client instance object instead. In client mode, the --ping-restart parameter is set to 120 seconds by default. This default will hold until the client pulls a replacement value from the server, based on the --keepalive setting in the server configuration. To disable the 120 second default, set --ping-restart 0 on the client. See the signals section below for more information on\nSIGUSR1\n. Note that the behavior of SIGUSR1 can be modified by the --persist-tun, --persist-key, --persist-local-ip and --persist-remote-ip options.\nAlso note that --ping-exit and --ping-restart are mutually exclusive and cannot be used together.\n--ping-timer-rem\nRun the --ping-exit / --ping-restart timer only if we have a remote address. Use this option if you are starting the daemon in listen mode (i.e. without an explicit --remote peer), and you don't want to start clocking timeouts until a remote peer connects.\n--proto p\nUse protocol p for communicating with remote host. p can be\nudp\n,\ntcp-client\n, or\ntcp-server\n. You can also limit OpenVPN to use only IPv4 or only IPv6 by specifying p as\nudp4\n,\ntcp4-client\n,\ntcp4-server\nor\nudp6\n,\ntcp6-client\n,\ntcp6-server\n, respectively.\nThe default protocol is\nudp\nwhen --proto is not specified. For UDP operation, --proto udp should be specified on both peers. For TCP operation, one peer must use --proto tcp-server and the other must use --proto tcp-client. A peer started with\ntcp-server\nwill wait indefinitely for an incoming connection. A peer started with\ntcp-client\nwill attempt to connect, and if that fails, will sleep for 5 seconds (adjustable via the --connect-retry option) and try again infinite or up to N retries (adjustable via the --connect-retry-max option). Both TCP client and server will simulate a SIGUSR1 restart signal if either side resets the connection. OpenVPN is designed to operate optimally over UDP, but TCP capability is provided for situations where UDP cannot be used. In comparison with UDP, TCP will usually be somewhat less efficient and less robust when used over unreliable or congested networks.\nThere are certain cases, however, where using TCP may be advantageous from a security and robustness perspective, such as tunneling non-IP or application-level UDP protocols, or tunneling protocols which don't possess a built-in reliability layer.\n--port port\nTCP/UDP port number or port name for both local and remote (sets both --lport and --rport options to given port). The current default of 1194 represents the official IANA port number assignment for OpenVPN and has been used since version 2.0-beta17. Previous versions used port 5000 as the default.\n--rport port\nSet TCP/UDP port number or name used by the --remote option. The port can also be set directly using the --remote option.\n--replay-window args\nModify the replay protection sliding-window size and time window.\nValid syntaxes:\nreplay-window n\nreplay-window n t\nUse a replay protection sliding-window of size n and a time window of t seconds. By default n is\n64\n(the IPSec default) and t is\n15\nseconds. This option is only relevant in UDP mode, i.e. when either --proto udp is specified, or no --proto option is specified. When OpenVPN tunnels IP packets over UDP, there is the possibility that packets might be dropped or delivered out of order. Because OpenVPN, like IPSec, is emulating the physical network layer, it will accept an out-of-order packet sequence, and will deliver such packets in the same order they were received to the TCP/IP protocol stack, provided they satisfy several constraints.\nThe packet cannot be a replay (unless --no-replay is specified, which disables replay protection altogether).\nIf a packet arrives out of order, it will only be accepted if the difference between its sequence number and the highest sequence number received so far is less than n.\nIf a packet arrives out of order, it will only be accepted if it arrives no later than t seconds after any packet containing a higher sequence number.\nIf you are using a network link with a large pipeline (meaning that the product of bandwidth and latency is high), you may want to use a larger value for n. Satellite links in particular often require this. If you run OpenVPN at --verb 4, you will see the message \"PID_ERR replay-window backtrack occurred [x]\" every time the maximum sequence number backtrack seen thus far increases. This can be used to calibrate n. There is some controversy on the appropriate method of handling packet reordering at the security layer. Namely, to what extent should the security layer protect the encapsulated protocol from attacks which masquerade as the kinds of normal packet loss and reordering that occur over IP networks? The IPSec and OpenVPN approach is to allow packet reordering within a certain fixed sequence number window. OpenVPN adds to the IPSec model by limiting the window size in time as well as sequence space. OpenVPN also adds TCP transport as an option (not offered by IPSec) in which case OpenVPN can adopt a very strict attitude towards message deletion and reordering: Don't allow it. Since TCP guarantees reliability, any packet loss or reordering event can be assumed to be an attack. In this sense, it could be argued that TCP tunnel transport is preferred when tunneling non-IP or UDP application protocols which might be vulnerable to a message deletion or reordering attack which falls within the normal operational parameters of IP networks.\nSo I would make the statement that one should never tunnel a non-IP protocol or UDP application protocol over UDP, if the protocol might be vulnerable to a message deletion or reordering attack that falls within the normal operating parameters of what is to be expected from the physical IP layer. The problem is easily fixed by simply using TCP as the VPN transport layer.\n--replay-persist file\nPersist replay-protection state across sessions using file to save and reload the state.\nThis option will keep a disk copy of the current replay protection state (i.e. the most recent packet timestamp and sequence number received from the remote peer), so that if an OpenVPN session is stopped and restarted, it will reject any replays of packets which were already received by the prior session.\nThis option only makes sense when replay protection is enabled (the default) and you are using either --secret (shared-secret key mode) or TLS mode with --tls-auth.\n--session-timeout n\nRaises\nSIGTERM\nfor the client instance after n seconds since the beginning of the session, forcing OpenVPN to disconnect. In client mode, OpenVPN will disconnect and exit, while in server mode all client sessions are terminated.\nThis option can also be specified in a client instance config file using --client-config-dir or dynamically generated using a --client-connect script. In these cases, only the related client session is terminated.\n--socket-flags flags\nApply the given flags to the OpenVPN transport socket. Currently, only\nTCP_NODELAY\nis supported.\nThe\nTCP_NODELAY\nsocket flag is useful in TCP mode, and causes the kernel to send tunnel packets immediately over the TCP connection without trying to group several smaller packets into a larger packet. This can result in a considerably improvement in latency.\nThis option is pushable from server to client, and should be used on both client and server for maximum effect.\n--tcp-nodelay\nThis macro sets the\nTCP_NODELAY\nsocket flag on the server as well as pushes it to connecting clients. The\nTCP_NODELAY\nflag disables the Nagle algorithm on TCP sockets causing packets to be transmitted immediately with low latency, rather than waiting a short period of time in order to aggregate several packets into a larger containing packet. In VPN applications over TCP,\nTCP_NODELAY\nis generally a good latency optimization.\nThe macro expands as follows:\nif mode server:\nsocket-flags TCP_NODELAY\npush \"socket-flags TCP_NODELAY\"\n--max-packet-size size\nThis option will instruct OpenVPN to try to limit the maximum on-write packet size by restricting the control channel packet size and setting --mssfix.\nOpenVPN will try to keep its control channel messages below this size but due to some constraints in the protocol this is not always possible. If the option is not set, the control packet maximum size defaults to 1250. The control channel packet size will be restricted to values between 154 and 2048. The maximum packet size includes encapsulation overhead like UDP and IP. In terms of --mssfix it will expand to:\nmssfix size mtu\nIf you need to set --mssfix for data channel and control channel maximum packet size independently, use --max-packet-size first, followed by a --mssfix in the configuration.\nIn general the default size of 1250 should work almost universally apart from specific corner cases, especially since IPv6 requires a MTU of 1280 or larger.\nVirtual Network Adapter (VPN interface)\nOptions in this section relates to configuration of the virtual tun/tap network interface, including setting the VPN IP address and network routing.\n--bind-dev device\n(Linux only) Set device to bind the server socket to a\nVirtual Routing and Forwarding\ndevice.\n--block-ipv6\nOn the client, instead of sending IPv6 packets over the VPN tunnel, all IPv6 packets are answered with an ICMPv6 no route host message. On the server, all IPv6 packets from clients are answered with an ICMPv6 no route to host message. This options is intended for cases when IPv6 should be blocked and other options are not available. --block-ipv6 will use the remote IPv6 as source address of the ICMPv6 packets if set, otherwise will use\nfe80::7\nas source address.\nFor this option to make sense you actually have to route traffic to the tun interface. The following example config block would send all IPv6 traffic to OpenVPN and answer all requests with no route to host, effectively blocking IPv6 (to avoid IPv6 connections from dual-stacked clients leaking around IPv4-only VPN services).\nClient config\n--ifconfig-ipv6 fd15:53b6:dead::2/64 fd15:53b6:dead::1 --redirect-gateway ipv6 --block-ipv6\nServer config\nPush a \"valid\" ipv6 config to the client and block on the server--push \"ifconfig-ipv6 fd15:53b6:dead::2/64 fd15:53b6:dead::1\" --push \"redirect-gateway ipv6\" --block-ipv6\nNote: this option does not influence traffic sent from the server towards the client (neither on the server nor on the client side). This is not seen as necessary, as such traffic can be most easily avoided by not configuring IPv6 on the server tun, or setting up a server-side firewall rule.\n--dev device\nTUN/TAP virtual network device which can be\ntunX\n,\ntapX\n,\nnull\nor an arbitrary name string (\nX\ncan be omitted for a dynamic device.)\nSee examples section below for an example on setting up a TUN device. You must use either tun devices on both ends of the connection or tap devices on both ends. You cannot mix them, as they represent different underlying network layers:\ntun\ndevices encapsulate IPv4 or IPv6 (OSI Layer 3)\ntap\ndevices encapsulate Ethernet 802.3 (OSI Layer 2).\nValid syntaxes:\ndev tun2\ndev tap4\ndev ovpn\nWhat happens if the device name is not\ntun\nor\ntap\nis platform dependent. On most platforms,\ntunN\n(e.g. tun2, tun30) and\ntapN\n(e.g. tap3) will create a numbered tun/tap interface with the number specified - this is useful if multiple OpenVPN instances are active, and the instance-to-device mapping needs to be known. Some platforms do not support \"numbered tap\", so trying --dev tap3 will fail. Arbitrary device names (e.g. --dev tun-home) will only work on FreeBSD (with the DCO kernel driver for tun devices) and Linux (for both tun and tap devices, DCO and tun/tap driver). If such a device name starts with tun or tap (e.g. tun-home), OpenVPN will choose the right device type automatically. Otherwise the desired device type needs to be specified with --dev-type tun or --dev-type tap.\nOn Windows, only the names\ntun\nand\ntap\nare supported. Selection among multiple installed drivers or driver instances is done with --dev-node and --windows-driver.\n--dev-node node\nThis is a highly system dependent option to influence tun/tap driver selection.\nOn Linux, tun/tap devices are created by accessing\n/dev/net/tun\n, and this device name can be changed using --dev-node .... Under Mac OS X this option can be used to specify the default tun implementation. Using --dev-node utun forces usage of the native Darwin tun kernel support. Use --dev-node utunN to select a specific utun instance. To force using the\ntun.kext\n(\n/dev/tunX\n) use --dev-node tun. When not specifying a --dev-node option openvpn will first try to open utun, and fall back to tun.kext. On Windows systems, select the TAP-Win32 adapter which is named node in the Network Connections Control Panel or the raw GUID of the adapter enclosed by braces. The --show-adapters option under Windows can also be used to enumerate all available TAP-Win32 adapters and will show both the network connections control panel name and the GUID for each TAP-Win32 adapter.\nOn other platforms, --dev-node node will influence the naming of the created tun/tap device, if supported on that platform. If OpenVPN cannot figure out whether node is a TUN or TAP device based on the name, you should also specify --dev-type tun or --dev-type tap.\n--dev-type device-type\nWhich device type are we using? device-type should be\ntun\n(OSI Layer 3) or\ntap\n(OSI Layer 2). Use this option only if the TUN/TAP device used with --dev does not begin with\ntun\nor\ntap\n.\n--dhcp-option args\nSet additional network parameters on supported platforms. May be specified on the client or pushed from the server. On Windows these options are handled by the tap-windows6 driver by default or directly by OpenVPN if dhcp is disabled or the wintun driver is in use. The OpenVPN for Android client also handles them internally.\nOn all other platforms these options are only saved in the client's environment under the name\nforeign_option_{n}\nbefore the --up script is called. A plugin or an --up script must be used to pick up and interpret these as required. Many Linux distributions include such scripts and some third-party user interfaces such as tunnelblick also come with scripts that process these options. Valid syntax:\ndhcp-option type [parm]\nDOMAIN\nname\nSet Connection-specific DNS Suffix toÂ name.\nADAPTER_DOMAIN_SUFFIX\nname\nAlias toÂ DOMAIN. This is a compatibility option, it should not be used in new deployments.\nDOMAIN-SEARCH\nname\nAddÂ nameÂ to the domain search list. Repeat this option to add more entries. Up to 10 domains are supported.\nDNS\naddress\nSet primary domain name server IPv4 or IPv6 address. Repeat this option to set secondary DNS server addresses.Note: DNS IPv6 servers are currently set using netsh (the existing DHCP code can only do IPv4 DHCP, and that protocol only permits IPv4 addresses anywhere). The option will be put into the environment, so anÂ --upÂ script could act upon it if needed.\nWINS\naddress\nSet primary WINS server address (NetBIOS over TCP/IP Name Server). Repeat this option to set secondary WINS server addresses.\nNBDD\naddress\nSet primary NBDD server address (NetBIOS over TCP/IP Datagram Distribution Server). Repeat this option to set secondary NBDD server addresses.\nNTP\naddress\nSet primary NTP server address (Network Time Protocol). Repeat this option to set secondary NTP server addresses.\nNBT\ntype\nSet NetBIOS over TCP/IP Node type. Possible options:1b-node (broadcasts)2p-node (point-to-point name queries to a WINS server)4m-node (broadcast then query name server)8h-node (query name server, then broadcast).\nNBS\nscope-id\nSet NetBIOS over TCP/IP Scope. A NetBIOS Scope ID provides an extended naming service for the NetBIOS over TCP/IP (Known as NBT) module. The primary purpose of a NetBIOS scope ID is to isolate NetBIOS traffic on a single network to only those nodes with the same NetBIOS scope ID. The NetBIOS scope ID is a character string that is appended to the NetBIOS name. The NetBIOS scope ID on two hosts must match, or the two hosts will not be able to communicate. The NetBIOS Scope ID also allows computers to use the same computer name, as they have different scope IDs. The Scope ID becomes a part of the NetBIOS name, making the name unique. (This description of NetBIOS scopes courtesy ofÂ NeonSurge@abyss.com)\nDISABLE-NBT\nDisable Netbios-over-TCP/IP.\ncode:\nPROXY_HTTP host port Sets a HTTP proxy that should be used when connected to the VPN. This option currently only works on OpenVPN for Android and requires Android 10 or later.\n--ifconfig args\nSet TUN/TAP adapter parameters. It requires the\nIP address\nof the local VPN endpoint. For TUN devices in point-to-point mode, the next argument must be the VPN IP address of the remote VPN endpoint. For TAP devices, or TUN devices used with --topology subnet, the second argument is the subnet mask of the virtual network segment which is being created or connected to.\nFor TUN devices, which facilitate virtual point-to-point IP connections (when used in --topology net30 or p2p mode), the proper usage of --ifconfig is to use two private IP addresses which are not a member of any existing subnet which is in use. The IP addresses may be consecutive and should have their order reversed on the remote peer. After the VPN is established, by pinging rn, you will be pinging across the VPN. For TAP devices, which provide the ability to create virtual ethernet segments, or TUN devices in --topology subnet mode (which create virtual \"multipoint networks\"), --ifconfig is used to set an IP address and subnet mask just as a physical ethernet adapter would be similarly configured. If you are attempting to connect to a remote ethernet bridge, the IP address and subnet should be set to values which would be valid on the bridged ethernet segment (note also that DHCP can be used for the same purpose). This option, while primarily a proxy for the ifconfig(8) command, is designed to simplify TUN/TAP tunnel configuration by providing a standard interface to the different ifconfig implementations on different platforms. --ifconfig parameters which are IP addresses can also be specified as a DNS or /etc/hosts file resolvable name. For TAP devices, --ifconfig should not be used if the TAP interface will be getting an IP address lease from a DHCP server. Examples:\n# tun device in net30/p2p mode\nifconfig 10.8.0.2 10.8.0.1\n# tun/tap device in subnet mode\nifconfig 10.8.0.2 255.255.255.0\n--ifconfig-ipv6 args\nConfigure an IPv6 address on the\ntun\ndevice.\nValid syntax:\nifconfig-ipv6 ipv6addr/bits [ipv6remote]\nThe ipv6addr/bits argument is the IPv6 address to use. The second parameter is used as route target for --route-ipv6 if no gateway is specified.\nThe --topology option has no influence with --ifconfig-ipv6\n--ifconfig-noexec\nDon't actually execute ifconfig/netsh commands, instead pass --ifconfig parameters to scripts using environmental variables.\n--ifconfig-nowarn\nDon't output an options consistency check warning if the --ifconfig option on this side of the connection doesn't match the remote side. This is useful when you want to retain the overall benefits of the options consistency check (also see --disable-occ option) while only disabling the ifconfig component of the check.\nFor example, if you have a configuration where the local host uses --ifconfig but the remote host does not, use --ifconfig-nowarn on the local host.\nThis option will also silence warnings about potential address conflicts which occasionally annoy more experienced users by triggering \"false positive\" warnings.\n--lladdr address\nSpecify the link layer address, more commonly known as the MAC address. Only applied to TAP devices.\n--persist-tun\nDon't close and reopen TUN/TAP device or run up/down scripts across\nSIGUSR1\nor --ping-restart restarts.\nSIGUSR1\nis a restart signal similar to\nSIGHUP\n, but which offers finer-grained control over reset options.\n--redirect-gateway flags\nAutomatically execute routing commands to cause all outgoing IP traffic to be redirected over the VPN. This is a client-side option.\nThis option performs three steps:\nCreate a static route for the --remote address which forwards to the pre-existing default gateway. This is done so that (3) will not create a routing loop.\nDelete the default gateway route.\nSet the new default gateway to be the VPN endpoint address (derived either from --route-gateway or the second parameter to --ifconfig when --dev tun is specified).\nWhen the tunnel is torn down, all of the above steps are reversed so that the original default route is restored. Option flags:\nlocal\nAdd theÂ localÂ flag if both OpenVPN peers are directly connected via a common subnet, such as with wireless. TheÂ localÂ flag will cause stepÂ (1)Â above to be omitted.\nautolocal\nTry to automatically determine whether to enableÂ localÂ flag above.\ndef1\nUse this flag to override the default gateway by usingÂ 0.0.0.0/1Â andÂ 128.0.0.0/1Â rather thanÂ 0.0.0.0/0. This has the benefit of overriding but not wiping out the original default gateway.\nbypass-dhcp\nAdd a direct route to the DHCP server (if it is non-local) which bypasses the tunnel (Available on Windows clients, may not be available on non-Windows clients).\nbypass-dns\nAdd a direct route to the DNS server(s) (if they are non-local) which bypasses the tunnel (Available on Windows clients, may not be available on non-Windows clients).\nblock-local\nBlock access to local LAN when the tunnel is active, except for the LAN gateway itself. This is accomplished by routing the local LAN (except for the LAN gateway address) into the tunnel.\nipv6\nRedirect IPv6 routing into the tunnel. This works similar to theÂ def1Â flag, that is, more specific IPv6 routes are added (2000::/4,Â 3000::/4), covering the whole IPv6 unicast space.\n!ipv4\nDo not redirect IPv4 traffic - typically used in the flag pairÂ ipv6 !ipv4Â to redirect IPv6-only.\n--redirect-private flags\nLike --redirect-gateway, but omit actually changing the default gateway. Useful when pushing private subnets.\n--route args\nAdd route to routing table after connection is established. Multiple routes can be specified. Routes will be automatically torn down in reverse order prior to TUN/TAP device close.\nValid syntaxes:\nroute network/IP\nroute network/IP netmask\nroute network/IP netmask gateway\nroute network/IP netmask gateway metric\nThis option is intended as a convenience proxy for the route(8) shell command, while at the same time providing portable semantics across OpenVPN's platform space.\nnetmask\ndefaults toÂ 255.255.255.255Â when not given\ngateway\ndefault taken fromÂ --route-gatewayÂ or the second parameter toÂ --ifconfigÂ whenÂ --devÂ tunÂ is specified.\nmetric\ndefault taken fromÂ --route-metricÂ if set, otherwiseÂ 0.\nThe default can be specified by leaving an option blank or setting it to\ndefault\n. The network and gateway parameters can also be specified as a DNS or\n/etc/hosts\nfile resolvable name, or as one of three special keywords:\nvpn_gateway\nThe remote VPN endpoint address (derived either fromÂ --route-gatewayÂ or the second parameter toÂ --ifconfigÂ whenÂ --devÂ tunÂ is specified).\nnet_gateway\nThe pre-existing IP default gateway, read from the routing table (not supported on all OSes).\nremote_host\nTheÂ --remoteÂ address if OpenVPN is being run in client mode, and is undefined in server mode.\n--route-delay args\nValid syntaxes:\nroute-delay\nroute-delay n\nroute-delay n w\nDelay n seconds (default\n0\n) after connection establishment, before adding routes. If n is\n0\n, routes will be added immediately upon connection establishment. If --route-delay is omitted, routes will be added immediately after TUN/TAP device open and --up script execution, before any --user or --group privilege downgrade (or --chroot execution.) This option is designed to be useful in scenarios where DHCP is used to set tap adapter addresses. The delay will give the DHCP handshake time to complete before routes are added.\nOn Windows, --route-delay tries to be more intelligent by waiting w seconds (default\n30\n) for the TAP-Win32 adapter to come up before adding routes.\n--route-ipv6 args\nSetup IPv6 routing in the system to send the specified IPv6 network into OpenVPN's\ntun\n.\nValid syntax:\nroute-ipv6 ipv6addr/bits [gateway] [metric]\nThe gateway parameter is only used for IPv6 routes across\ntap\ndevices, and if missing, the ipv6remote field from --ifconfig-ipv6 or --route-ipv6-gateway is used.\n--route-gateway arg\nSpecify a default\ngateway\nfor use with --route.\nIf\ndhcp\nis specified as the parameter, the gateway address will be extracted from a DHCP negotiation with the OpenVPN server-side LAN. Valid syntaxes:\nroute-gateway gateway\nroute-gateway dhcp\n--route-ipv6-gateway gw\nSpecify a default gateway gw for use with --route-ipv6.\n--route-metric m\nSpecify a default metric m for use with --route.\n--route-noexec\nDon't add or remove routes automatically. Instead pass routes to --route-up script using environmental variables.\n--route-nopull\nWhen used with --client or --pull, accept options pushed by server EXCEPT for routes, block-outside-dns and dhcp options like DNS servers.\nWhen used on the client, this option effectively bars the server from adding routes to the client's routing table, however note that this option still allows the server to set the TCP/IP properties of the client's TUN/TAP interface.\n--topology mode\nConfigure virtual addressing topology when running in --dev tun mode. This directive has no meaning in --dev tap mode, which always uses a\nsubnet\ntopology.\nIf you set this directive on the server, the --server and --server-bridge directives will automatically push your chosen topology setting to clients as well. This directive can also be manually pushed to clients. Like the --dev directive, this directive must always be compatible between client and server. mode can be one of:\nnet30\nUse a point-to-point topology, by allocating one /30 subnet per client. This is designed to allow point-to-point semantics when some or all of the connecting clients might be Windows systems. This is the default.\np2p\nUse a point-to-point topology where the remote endpoint of the client's tun interface always points to the local endpoint of the server's tun interface. This mode allocates a single IP address per connecting client. Only use when none of the connecting clients are Windows systems.\nsubnet\nUse a subnet rather than a point-to-point topology by configuring the tun interface with a local IP address and subnet mask, similar to the topology used inÂ --devÂ tapÂ and ethernet bridging mode. This mode allocates a single IP address per connecting client and works on Windows as well.\nNote:\nUsing --topology subnet changes the interpretation of the arguments of --ifconfig to mean \"address netmask\", no longer \"local remote\".\n--tun-mtu args\nValid syntaxes:\ntun-mtu tun-mtu\ntun-mtu tun-mtu occ-mtu\nTake the TUN device MTU to be tun-mtu and derive the link MTU from it. In most cases, you will probably want to leave this parameter set to its default value. The default for\ntun-mtu\nis 1500. The OCC MTU can be used to avoid warnings about mismatched MTU from clients. If\nocc-mtu\nis not specified, it will to default to the tun-mtu. The MTU (Maximum Transmission Units) is the maximum datagram size in bytes that can be sent unfragmented over a particular network path. OpenVPN requires that packets on the control and data channels be sent unfragmented. MTU problems often manifest themselves as connections which hang during periods of active usage. It's best to use the --fragment and/or --mssfix options to deal with MTU sizing issues.\nNote: Depending on the platform, the operating system allows one to receive packets larger than tun-mtu (e.g. Linux and FreeBSD) but other platforms (like macOS) limit received packets to the same size as the MTU.\n--tun-max-mtu maxmtu\nThis configures the maximum MTU size that a server can push to maxmtu, by configuring the internal buffers to allow at least this packet size. The default for maxmtu is 1600. Currently, only increasing beyond 1600 is possible, and attempting to reduce max-mtu below 1600 will be ignored.\n--tun-mtu-extra n\nAssume that the TUN/TAP device might return as many as n bytes more than the --tun-mtu size on read. This parameter defaults to 0, which is sufficient for most TUN devices. TAP devices may introduce additional overhead in excess of the MTU size, and a setting of 32 is the default when TAP devices are used. This parameter only controls internal OpenVPN buffer sizing, so there is no transmission overhead associated with using a larger value.\nTUN/TAP standalone operations\nThese two standalone operations will require --dev and optionally --user and/or --group.\n--mktun\n(Standalone) Create a persistent tunnel on platforms which support them such as Linux. Normally TUN/TAP tunnels exist only for the period of time that an application has them open. This option takes advantage of the TUN/TAP driver's ability to build persistent tunnels that live through multiple instantiations of OpenVPN and die only when they are deleted or the machine is rebooted.\nOne of the advantages of persistent tunnels is that they eliminate the need for separate --up and --down scripts to run the appropriate ifconfig(8) and route(8) commands. These commands can be placed in the same shell script which starts or terminates an OpenVPN session. Another advantage is that open connections through the TUN/TAP-based tunnel will not be reset if the OpenVPN peer restarts. This can be useful to provide uninterrupted connectivity through the tunnel in the event of a DHCP reset of the peer's public IP address (see the --ipchange option above). One disadvantage of persistent tunnels is that it is harder to automatically configure their MTU value (see --link-mtu and --tun-mtu above).\nOn some platforms such as Windows, TAP-Win32 tunnels are persistent by default.\n--rmtun\n(Standalone) Remove a persistent tunnel.\nVirtual Routing and Forwarding\nOptions in this section relates to configuration of virtual routing and forwarding in combination with the underlying operating system. As of today this is only supported on Linux, a kernel >= 4.9 is recommended. This could come in handy when for example the external network should be only used as a means to connect to some VPN endpoints and all regular traffic should only be routed through any tunnel(s). This could be achieved by setting up a VRF and configuring the interface connected to the external network to be part of the VRF. The examples below will cover this setup. Another option would be to put the tun/tap interface into a VRF. This could be done by an up-script which uses the\nip link set\ncommand shown below.\nSCRIPTING INTEGRATION\nOpenVPN can execute external scripts in various phases of the lifetime of the OpenVPN process.\nScript Order of Execution\n--up\nExecuted after TCP/UDP socket bind and TUN/TAP open.\n--tls-verify\nExecuted when we have a still untrusted remote peer.\n--ipchange\nExecuted after connection authentication, or remote IP address change.\n--client-connect\nExecuted in\n--mode server\nmode immediately after client authentication.\n--route-up\nExecuted after connection authentication, either immediately after, or some number of seconds after as defined by the\n--route-delay\noption.\n--route-pre-down\nExecuted right before the routes are removed.\n--client-disconnect\nExecuted in --mode server mode on client instance shutdown.\n--down\nExecuted after TCP/UDP and TUN/TAP close.\n--learn-address\nExecuted in --mode server mode whenever an IPv4 address/route or MAC address is added to OpenVPN's internal routing table.\n--auth-user-pass-verify\nExecuted in --mode server mode on new client connections, when the client is still untrusted.\n--client-crresponse\nExecute in --mode server whenever a client sends a\nCR_RESPONSE\nmessage\nSCRIPT HOOKS\n--auth-user-pass-verify args\nRequire the client to provide a username/password (possibly in addition to a client certificate) for authentication.\nValid syntax:\nauth-user-pass-verify cmd method\nOpenVPN will run command cmd to validate the username/password provided by the client. cmd consists of a path to a script (or executable program), optionally followed by arguments. The path and arguments may be single- or double-quoted and/or escaped using a backslash, and should be separated by one or more spaces. If method is set to\nvia-env\n, OpenVPN will call cmd with the environmental variables\nusername\nand\npassword\nset to the username/password strings provided by the client.\nBeware\nthat this method is insecure on some platforms which make the environment of a process publicly visible to other unprivileged processes. If method is set to\nvia-file\n, OpenVPN will write the username and password to the first two lines of a temporary file. The filename will be passed as an argument to cmd, and the file will be automatically deleted by OpenVPN after the script returns. The location of the temporary file is controlled by the --tmp-dir option, and will default to the current directory if unspecified. For security, consider setting --tmp-dir to a volatile storage medium such as\n/dev/shm\n(if available) to prevent the username/password file from touching the hard drive. The script should examine the username and password, returning a success exit code (\n0\n) if the client's authentication request is to be accepted, a failure code (\n1\n) to reject the client, or a that the authentication is deferred (\n2\n). If the authentication is deferred, the script must fork/start a background or another non-blocking operation to continue the authentication in the background. When finshing the authentication, a\n1\nor\n0\nmust be written to the file specified by the\nauth_control_file\n. If the file specified by\nauth_failed_reason_file\nexists and has non-empty content, the content of this file will be used as AUTH_FAILED message. To avoid race conditions, this file should be written before\nauth_control_file\n. This auth fail reason can be something simple like \"User has been permanently disabled\" but there are also some special auth failed messages. The TEMP message indicates that the authentication temporarily failed and that the client should continue to retry to connect. The server can optionally give a user readable message and hint the client a behavior how to proceed. The keywords of the AUTH_FAILED,TEMP message are comma separated keys/values and provide a hint to the client how to proceed. Currently defined keywords are:\nbackoff\ns\ninstructs the client to wait at leastÂ sÂ seconds before the next connection attempt. If the client already uses a higher delay for reconnection attempt, the delay will not be shortened.\nadvance addr\nInstructs the client to reconnect to the next (IP) address of the current server.\nadvance remote\nInstructs the client to skip the remaining IP addresses of the current server and instead connect to the next server specified in the configuration file.\nadvance no\nInstructs the client to retry connecting to the same server again.\nFor example, the message TEMP[backoff 42,advance no]: No free IP addresses indicates that the VPN connection can currently not succeed and instructs the client to retry in 42 seconds again. When deferred authentication is in use, the script can also request pending authentication by writing to the file specified by the\nauth_pending_file\n. The first line must be the timeout in seconds, the required method on the second line (e.g. crtext) and third line must be the EXTRA as documented in the client-pending-auth section of doc/management.txt. This directive is designed to enable a plugin-style interface for extending OpenVPN's authentication capabilities. To protect against a client passing a maliciously formed username or password string, the username string must consist only of these characters: alphanumeric, underbar ('\n_\n'), dash ('\n-\n'), dot ('\n.\n'), or at ('\n@\n'). The password string can consist of any printable characters except for CR or LF. Any illegal characters in either the username or password string will be converted to underbar ('\n_\n'). Care must be taken by any user-defined scripts to avoid creating a security vulnerability in the way that these strings are handled. Never use these strings in such a way that they might be escaped or evaluated by a shell interpreter.\nFor a sample script that performs PAM authentication, see\nsample-scripts/auth-pam.pl\nin the OpenVPN source distribution.\n--client-crresponse\nExecuted when the client sends a text-based challenge response. Valid syntax:\nclient-crresponse cmd\nOpenVPN will write the response of the client into a temporary file. The filename will be passed as an argument to cmd, and the file will be automatically deleted by OpenVPN after the script returns. The response is passed as is from the client. The script needs to check itself if the input is valid, e.g. if the input is valid base64 encoding. The script can either directly write the result of the verification to\nauth_control_file or further defer it. See `\n--auth-user-pass-verify`` for details.\nFor a sample script that implement TOTP (RFC 6238) based two-factor authentication, see\nsample-scripts/totpauth.py\n.\n--client-connect cmd\nRun command cmd on client connection.\ncmd consists of a path to a script (or executable program), optionally followed by arguments. The path and arguments may be single- or double-quoted and/or escaped using a backslash, and should be separated by one or more spaces. The command is passed the common name and IP address of the just-authenticated client as environmental variables (see environmental variable section below). The command is also passed the pathname of a freshly created temporary file as the last argument (after any arguments specified in cmd ), to be used by the command to pass dynamically generated config file directives back to OpenVPN. If the script wants to generate a dynamic config file to be applied on the server when the client connects, it should write it to the file named by the last argument. See the --client-config-dir option below for options which can be legally used in a dynamically generated config file. Note that the return value of script is significant. If script returns a non-zero error status, it will cause the client to be disconnected.\nIf a --client-connect wants to defer the generating of the configuration then the script needs to use the\nclient_connect_deferred_file\nand\nclient_connect_config_file\nenvironment variables, and write status accordingly into these files. See the\nEnvironmental Variables\nsection for more details.\n--client-disconnect cmd\nLike --client-connect but called on client instance shutdown. Will not be called unless the --client-connect script and plugins (if defined) were previously called on this instance with successful (0) status returns.\nThe exception to this rule is if the --client-disconnect command or plugins are cascaded, and at least one client-connect function succeeded, then ALL of the client-disconnect functions for scripts and plugins will be called on client instance object deletion, even in cases where some of the related client-connect functions returned an error status.\nThe --client-disconnect command is not passed any extra arguments (only those arguments specified in cmd, if any).\n--down cmd\nRun command cmd after TUN/TAP device close (post --user UID change and/or --chroot ). cmd consists of a path to script (or executable program), optionally followed by arguments. The path and arguments may be single- or double-quoted and/or escaped using a backslash, and should be separated by one or more spaces.\nCalled with the same parameters and environmental variables as the --up option above.\nNote that if you reduce privileges by using --user and/or --group, your --down script will also run at reduced privilege.\n--down-pre\nCall --down cmd/script before, rather than after, TUN/TAP close.\n--ipchange cmd\nRun command cmd when our remote ip-address is initially authenticated or changes.\ncmd consists of a path to a script (or executable program), optionally followed by arguments. The path and arguments may be single- or double-quoted and/or escaped using a backslash, and should be separated by one or more spaces. When cmd is executed two arguments are appended after any arguments specified in cmd , as follows:\ncmd ip address port number\nDon't use --ipchange in --mode server mode. Use a --client-connect script instead. See the\nEnvironmental Variables\nsection below for additional parameters passed as environmental variables. If you are running in a dynamic IP address environment where the IP addresses of either peer could change without notice, you can use this script, for example, to edit the\n/etc/hosts\nfile with the current address of the peer. The script will be run every time the remote peer changes its IP address.\nSimilarly if\nour\nIP address changes due to DHCP, we should configure our IP address change script (see man page for dhcpcd(8)) to deliver a SIGHUP or SIGUSR1 signal to OpenVPN. OpenVPN will then re-establish a connection with its most recently authenticated peer on its new IP address.\n--learn-address cmd\nRun command cmd to validate client virtual addresses or routes.\ncmd consists of a path to a script (or executable program), optionally followed by arguments. The path and arguments may be single- or double-quoted and/or escaped using a backslash, and should be separated by one or more spaces. Three arguments will be appended to any arguments in cmd as follows:\n$1\n- [operation]\n\"add\",Â \"update\", orÂ \"delete\"Â based on whether or not the address is being added to, modified, or deleted from OpenVPN's internal routing table.\n$2\n- [address]\nThe address being learned or unlearned. This can be an IPv4 address such asÂ \"198.162.10.14\", an IPv4 subnet such asÂ \"198.162.10.0/24\", or an ethernet MAC address (whenÂ --devÂ tapÂ is being used) such asÂ \"00:FF:01:02:03:04\".\n$3\n- [common name]\nThe common name on the certificate associated with the client linked to this address. Only present forÂ \"add\"Â orÂ \"update\"Â operations, notÂ \"delete\".\nOn\n\"add\"\nor\n\"update\"\nmethods, if the script returns a failure code (non-zero), OpenVPN will reject the address and will not modify its internal routing table.\nNormally, the cmd script will use the information provided above to set appropriate firewall entries on the VPN TUN/TAP interface. Since OpenVPN provides the association between virtual IP or MAC address and the client's authenticated common name, it allows a user-defined script to configure firewall access policies with regard to the client's high-level common name, rather than the low level client virtual addresses.\n--route-up cmd\nRun command cmd after routes are added, subject to --route-delay.\ncmd consists of a path to a script (or executable program), optionally followed by arguments. The path and arguments may be single- or double-quoted and/or escaped using a backslash, and should be separated by one or more spaces.\nSee the\nEnvironmental Variables\nsection below for additional parameters passed as environmental variables.\n--route-pre-down cmd\nRun command cmd before routes are removed upon disconnection.\ncmd consists of a path to a script (or executable program), optionally followed by arguments. The path and arguments may be single- or double-quoted and/or escaped using a backslash, and should be separated by one or more spaces.\nSee the\nEnvironmental Variables\nsection below for additional parameters passed as environmental variables.\n--setenv args\nSet a custom environmental variable\nname=value\nto pass to script.\nValid syntaxes:\nsetenv name value\nsetenv FORWARD_COMPATIBLE 1\nsetenv opt config_option\nBy setting\nFORWARD_COMPATIBLE\nto\n1\n, the config file syntax checking is relaxed so that unknown directives will trigger a warning but not a fatal error, on the assumption that a given unknown directive might be valid in future OpenVPN versions. This option should be used with caution, as there are good security reasons for having OpenVPN fail if it detects problems in a config file. Having said that, there are valid reasons for wanting new software features to gracefully degrade when encountered by older software versions. It is also possible to tag a single directive so as not to trigger a fatal error if the directive isn't recognized. To do this, prepend the following before the directive: setenv opt Versions prior to OpenVPN 2.3.3 will always ignore options set with the setenv opt directive.\nSee also --ignore-unknown-option\n--setenv-safe args\nSet a custom environmental variable\nOPENVPN_name\nto\nvalue\nto pass to scripts.\nValid syntaxes:\nsetenv-safe name value\nThis directive is designed to be pushed by the server to clients, and the prepending of\nOPENVPN_\nto the environmental variable is a safety precaution to prevent a\nLD_PRELOAD\nstyle attack from a malicious or compromised server.\n--tls-verify cmd\nRun command cmd to verify the X509 name of a pending TLS connection that has otherwise passed all other tests of certification (except for revocation via --crl-verify directive; the revocation test occurs after the --tls-verify test).\ncmd should return\n0\nto allow the TLS handshake to proceed, or\n1\nto fail. cmd consists of a path to a script (or executable program), optionally followed by arguments. The path and arguments may be single- or double-quoted and/or escaped using a backslash, and should be separated by one or more spaces. When cmd is executed two arguments are appended after any arguments specified in cmd, as follows:\ncmd certificate_depth subject\nThese arguments are, respectively, the current certificate depth and the X509 subject distinguished name (dn) of the peer. This feature is useful if the peer you want to trust has a certificate which was signed by a certificate authority who also signed many other certificates, where you don't necessarily want to trust all of them, but rather be selective about which peer certificate you will accept. This feature allows you to write a script which will test the X509 name on a certificate and decide whether or not it should be accepted. For a simple perl script which will test the common name field on the certificate, see the file verify-cn in the OpenVPN distribution.\nSee the\nEnvironmental Variables\nsection below for additional parameters passed as environmental variables.\n--tls-export-cert dir\nAdds an environment variable peer_cert when calling the --tls-verify script or executing the OPENVPN_PLUGIN_TLS_VERIFY plugin hook to verify the certificate.\nThe environment variable contains the path to a PEM encoded certificate of the current peer certificate in the directory dir.\n--up cmd\nRun command cmd after successful TUN/TAP device open (pre --user UID change).\ncmd consists of a path to a script (or executable program), optionally followed by arguments. The path and arguments may be single- or double-quoted and/or escaped using a backslash, and should be separated by one or more spaces. The up command is useful for specifying route commands which route IP traffic destined for private subnets which exist at the other end of the VPN connection into the tunnel. For --dev tun execute as:\ncmd tun_dev tun_mtu 0 ifconfig_local_ip ifconfig_remote_ip [init | restart]\nFor --dev tap execute as:\ncmd tap_dev tap_mtu 0 ifconfig_local_ip ifconfig_netmask [init | restart]\nSee the\nEnvironmental Variables\nsection below for additional parameters passed as environmental variables. The 0 argument used to be link_mtu which is no longer passed to scripts - to keep the argument order, it was replaced with 0. Note that if cmd includes arguments, all OpenVPN-generated arguments will be appended to them to build an argument list with which the executable will be called. Typically, cmd will run a script to add routes to the tunnel. Normally the up script is called after the TUN/TAP device is opened. In this context, the last command line parameter passed to the script will be\ninit.\nIf the --up-restart option is also used, the up script will be called for restarts as well. A restart is considered to be a partial reinitialization of OpenVPN where the TUN/TAP instance is preserved (the --persist-tun option will enable such preservation). A restart can be generated by a SIGUSR1 signal, a --ping-restart timeout, or a connection reset when the TCP protocol is enabled with the --proto option. If a restart occurs, and --up-restart has been specified, the up script will be called with\nrestart\nas the last parameter.\nNOTE:\nOn restart, OpenVPN will not pass the full set of environment variables to the script. Namely, everything related to routing and gateways will not be passed, as nothing needs to be done anyway - all the routing setup is already in place. Additionally, the up-restart script will run with the downgraded UID/GID settings (if configured).\nThe following standalone example shows how the --up script can be called in both an initialization and restart context. (\nNOTE:\nfor security reasons, don't run the following example unless UDP port 9999 is blocked by your firewall. Also, the example will run indefinitely, so you should abort with control-c).\nopenvpn --dev tun --port 9999 --verb 4 --ping-restart 10 \\\n--up 'echo up' --down 'echo down' --persist-tun  \\\n--up-restart\nNote that OpenVPN also provides the --ifconfig option to automatically ifconfig the TUN device, eliminating the need to define an --up script, unless you also want to configure routes in the --up script. If --ifconfig is also specified, OpenVPN will pass the ifconfig local and remote endpoints on the command line to the --up script so that they can be used to configure routes such as:\nroute add -net 10.0.0.0 netmask 255.255.255.0 gw $5\n--up-delay\nDelay TUN/TAP open and possible --up script execution until after TCP/UDP connection establishment with peer.\nIn --proto udp mode, this option normally requires the use of --ping to allow connection initiation to be sensed in the absence of tunnel data, since UDP is a \"connectionless\" protocol.\nOn Windows, this option will delay the TAP-Win32 media state transitioning to \"connected\" until connection establishment, i.e. the receipt of the first authenticated packet from the peer.\n--up-restart\nEnable the --up and --down scripts to be called for restarts as well as initial program start. This option is described more fully above in the --up option documentation.\nString Types and Remapping\nIn certain cases, OpenVPN will perform remapping of characters in strings. Essentially, any characters outside the set of permitted characters for each string type will be converted to underbar ('_').\nQ: Why is string remapping necessary?\nIt's an important security feature to prevent the malicious coding of strings from untrusted sources to be passed as parameters to scripts, saved in the environment, used as a common name, translated to a filename, etc.\nQ: Can string remapping be disabled?\nYes, by using theÂ --no-name-remappingÂ option, however this should be considered an advanced option.\nHere is a brief rundown of OpenVPN's current string types and the permitted character class for each string:\nX509 Names\nAlphanumeric, underbar ('_'), dash ('-'), dot ('.'), at ('@'), colon (':'), slash ('/'), and equal ('='). Alphanumeric is defined as a character which will cause the C library isalnum() function to return true.\nCommon Names\nAlphanumeric, underbar ('_'), dash ('-'), dot ('.'), and at ('@').\n--auth-user-pass username\nSame as Common Name, with one exception: starting with OpenVPN 2.0.1, the username is passed to theÂ OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFYÂ plugin in its raw form, without string remapping.\n--auth-user-pass password\nAny \"printable\" character except CR or LF. Printable is defined to be a character which will cause the C library isprint() function to return true.\n--client-config-dir filename as derived from common name or`username\nAlphanumeric, underbar ('_'), dash ('-'), and dot ('.') except for \".\" or \"..\" as standalone strings. As of v2.0.1-rc6, the at ('@') character has been added as well for compatibility with the common name character class.\nEnvironmental variable names\nAlphanumeric or underbar ('_').\nEnvironmental variable values\nAny printable character.\nFor all cases, characters in a string which are not members of the legal character class for that string type will be remapped to underbar ('_').\nEnvironmental Variables\nOnce set, a variable is persisted indefinitely until it is reset by a new value or a restart, As of OpenVPN 2.0-beta12, in server mode, environmental variables set by OpenVPN are scoped according to the client objects they are associated with, so there should not be any issues with scripts having access to stale, previously set variables which refer to different client instances.\nbytes_received\nTotal number of bytes received from client during VPN session. Set prior to execution of theÂ --client-disconnectÂ script.\nbytes_sent\nTotal number of bytes sent to client during VPN session. Set prior to execution of theÂ --client-disconnectÂ script.\nclient_connect_config_file\nThe path to the configuration file that should be written to by theÂ --client-connectÂ script (optional, if per-session configuration is desired). This is the same file name as passed via command line argument on the call to theÂ --client-connectÂ script.\nclient_connect_deferred_file\nThis file can be optionally written to in order to to communicate a status code of theÂ --client-connectÂ script or plgin. Only the first character in the file is relevant. It must be eitherÂ 1Â to indicate normal script execution,Â 0Â indicates an error (in the same way that a non zero exit status does) orÂ 2Â to indicate that the script deferred returning the config file.For deferred (background) handling, the script or plugin MUST writeÂ 2Â to the file to indicate the deferral and then return with exit codeÂ 0Â to signalÂ deferred handler started OK. A background process or similar must then take care of writing the configuration to the file indicated by theÂ client_connect_config_fileÂ environment variable and when finished, write the aÂ 1Â to this file (orÂ 0Â in case of an error). The absence of any character in the file when the script finishes executing is interpreted the same asÂ 1. This allows scripts that are not written to support the defer mechanism to be used unmodified.\ncommon_name\nThe X509 common name of an authenticated client. Set prior to execution ofÂ --client-connect,Â --client-disconnectÂ andÂ --auth-user-pass-verifyÂ scripts.\nconfig\nName of firstÂ --configÂ file. Set on program initiation and reset on SIGHUP.\ndaemon\nSet to \"1\" if theÂ --daemonÂ directive is specified, or \"0\" otherwise. Set on program initiation and reset on SIGHUP.\ndaemon_log_redirect\nSet to \"1\" if theÂ --logÂ orÂ --log-appendÂ directives are specified, or \"0\" otherwise. Set on program initiation and reset on SIGHUP.\ndev\nThe actual name of the TUN/TAP device, including a unit number if it exists. Set prior toÂ --upÂ orÂ --downÂ script execution.\ndev_idx\nOn Windows, the device index of the TUN/TAP adapter (to be used in netsh.exe calls which sometimes just do not work right with interface names). Set prior toÂ --upÂ orÂ --downÂ script execution.\ndns_*\nTheÂ --dnsÂ configuration options will be made available to script execution through this set of environment variables. Variables appear only if the corresponding option has a value assigned. For the semantics of each individual variable, please refer to the documentation forÂ --dns.dns_search_domain_{n} dns_server_{n}_address_{m} dns_server_{n}_port_{m} dns_server_{n}_resolve_domain_{m} dns_server_{n}_dnssec dns_server_{n}_transport dns_server_{n}_sni\nforeign_option_{n}\nAn option pushed viaÂ --pushÂ to a client which does not natively support it, such asÂ --dhcp-optionÂ on a non-Windows system, will be recorded to this environmental variable sequence prior toÂ --upÂ script execution.\nifconfig_ipv6_local\nThe local VPN endpoint IPv6 address specified in theÂ --ifconfig-ipv6Â option (first parameter). Set prior to OpenVPN calling theÂ ifconfigÂ or code:netshÂ (windows version of ifconfig) commands which normally occurs prior toÂ --upÂ script execution.\nifconfig_ipv6_netbits\nThe prefix length of the IPv6 network on the VPN interface. Derived from the /nnn parameter of the IPv6 address in theÂ --ifconfig-ipv6Â option (first parameter). Set prior to OpenVPN calling theÂ ifconfigÂ orÂ netshÂ (windows version of ifconfig) commands which normally occurs prior toÂ --upÂ script execution.\nifconfig_ipv6_remote\nThe remote VPN endpoint IPv6 address specified in theÂ --ifconfig-ipv6Â option (second parameter). Set prior to OpenVPN calling theÂ ifconfigÂ orÂ netshÂ (windows version of ifconfig) commands which normally occurs prior toÂ --upÂ script execution.\nifconfig_local\nThe local VPN endpoint IP address specified in theÂ --ifconfigÂ option (first parameter). Set prior to OpenVPN calling theÂ ifconfigÂ orÂ netshÂ (windows version of ifconfig) commands which normally occurs prior toÂ --upÂ script execution.\nifconfig_remote\nThe remote VPN endpoint IP address specified in theÂ --ifconfigÂ option (second parameter) whenÂ --devÂ tunÂ is used. Set prior to OpenVPN calling theÂ ifconfigÂ orÂ netshÂ (windows version of ifconfig) commands which normally occurs prior toÂ --upÂ script execution.\nifconfig_netmask\nThe subnet mask of the virtual ethernet segment that is specified as the second parameter toÂ --ifconfigÂ whenÂ --devÂ tapÂ is being used. Set prior to OpenVPN calling theÂ ifconfigÂ orÂ netshÂ (windows version of ifconfig) commands which normally occurs prior toÂ --upÂ script execution.\nifconfig_pool_local_ip\nThe local virtual IPv4 address for the TUN/TAP tunnel taken from anÂ --ifconfig-pushÂ directive if specified, or otherwise from the ifconfig pool (controlled by theÂ --ifconfig-poolÂ config file directive). Only set forÂ --devÂ tunÂ tunnels. This option is set on the server prior to execution of theÂ --client-connectÂ andÂ --client-disconnectÂ scripts.\nifconfig_pool_local_ip6\nThe local virtual IPv6 address for the TUN/TAP tunnel taken from anÂ --ifconfig-ipv6-pushÂ directive if specified, or otherwise from the ifconfig pool (controlled by theÂ --ifconfig-ipv6-poolÂ config file directive). Only set forÂ --devÂ tunÂ tunnels. This option is set on the server prior to execution of theÂ --client-connectÂ andÂ --client-disconnectÂ scripts.\nifconfig_pool_netmask\nThe virtual IPv4 netmask for the TUN/TAP tunnel taken from anÂ --ifconfig-pushÂ directive if specified, or otherwise from the ifconfig pool (controlled by theÂ --ifconfig-poolÂ config file directive). Only set forÂ --devÂ tapÂ tunnels. This option is set on the server prior to execution of theÂ --client-connectÂ andÂ --client-disconnectÂ scripts.\nifconfig_pool_ip6_netbits\nThe virtual IPv6 prefix length for the TUN/TAP tunnel taken from anÂ --ifconfig-ipv6-pushÂ directive if specified, or otherwise from the ifconfig pool (controlled by theÂ --ifconfig-ipv6-poolÂ config file directive). Only set forÂ --devÂ tapÂ tunnels. This option is set on the server prior to execution of theÂ --client-connectÂ andÂ --client-disconnectÂ scripts.\nifconfig_pool_remote_ip\nThe remote virtual IPv4 address for the TUN/TAP tunnel taken from anÂ --ifconfig-pushÂ directive if specified, or otherwise from the ifconfig pool (controlled by theÂ --ifconfig-poolÂ config file directive). This option is set on the server prior to execution of theÂ --client-connectÂ andÂ --client-disconnectÂ scripts.\nifconfig_pool_remote_ip6\nThe remote virtual IPv6 address for the TUN/TAP tunnel taken from anÂ --ifconfig-ipv6-pushÂ directive if specified, or otherwise from the ifconfig pool (controlled by theÂ --ifconfig-ipv6-poolÂ config file directive). This option is set on the server prior to execution of theÂ --client-connectÂ andÂ --client-disconnectÂ scripts.\nlink_mtu\nREMOVEDÂ No longer passed to scripts since OpenVPN 2.6.0. Used to be the maximum packet size (not including the IP header) of tunnel data in UDP tunnel transport mode.\nlocal\nTheÂ --localÂ parameter. Set on program initiation and reset on SIGHUP.\nlocal_port\nThe local port number or name, specified byÂ --portÂ orÂ --lport. Set on program initiation and reset on SIGHUP.\npassword\nThe password provided by a connecting client. Set prior toÂ --auth-user-pass-verifyÂ script execution only when theÂ via-envÂ modifier is specified, and deleted from the environment after the script returns.\npeer_cert\nIf the optionÂ --tls-export-certÂ is enabled, this option contains the path to the current peer certificate to be verified in PEM format. See also the argument certificate_depth to theÂ --tls-verifyÂ command.\nproto\nTheÂ --protoÂ parameter. Set on program initiation and reset on SIGHUP.\nremote_{n}\nTheÂ --remoteÂ parameter. Set on program initiation and reset on SIGHUP.\nremote_port_{n}\nThe remote port number, specified byÂ --portÂ orÂ --rport. Set on program initiation and reset on SIGHUP.\nroute_net_gateway\nThe pre-existing default IP gateway in the system routing table. Set prior toÂ --upÂ script execution.\nroute_vpn_gateway\nThe default gateway used byÂ --routeÂ options, as specified in either theÂ --route-gatewayÂ option or the second parameter toÂ --ifconfigÂ whenÂ --devÂ tunÂ is specified. Set prior toÂ --upÂ script execution.\nroute_{parm}_{n}\nA set of variables which define each route to be added, and are set prior toÂ --upÂ script execution.parmÂ will be one ofÂ network,Â netmask\",Â gateway, orÂ metric. nÂ is the OpenVPN route number, starting from 1. If the network or gateway are resolvable DNS names, their IP address translations will be recorded rather than their names as denoted on the command line or configuration file.\nroute_ipv6_{parm}_{n}\nA set of variables which define each IPv6 route to be added, and are set prior toÂ --upÂ script execution.parmÂ will be one ofÂ network,Â gatewayÂ orÂ metric.Â route_ipv6_network_{n}Â containsÂ netmaskÂ asÂ /nnn, unlike IPv4 where it is passed in a separate environment variable. nÂ is the OpenVPN route number, starting from 1. If the network or gateway are resolvable DNS names, their IP address translations will be recorded rather than their names as denoted on the command line or configuration file.\nscript_context\nSet to \"init\" or \"restart\" prior to up/down script execution. For more information, see documentation forÂ --up.\nscript_type\nPrior to execution of any script, this variable is set to the type of script being run. It can be one of the following:Â up,Â down,Â ipchange,Â route-up,Â tls-verify,Â auth-user-pass-verify,Â client-connect,Â client-disconnectÂ orÂ learn-address. Set prior to execution of any script.\nsignal\nThe reason for exit or restart. Can be one ofÂ sigusr1,Â sighup,Â sigterm,Â sigint,Â inactiveÂ (controlled byÂ --inactiveÂ option),Â ping-exitÂ (controlled byÂ --ping-exitÂ option),Â ping-restartÂ (controlled byÂ --ping-restartÂ option),Â connection-resetÂ (triggered on TCP connection reset),Â errorÂ orÂ unknownÂ (unknown signal). This variable is set just prior to down script execution.\ntime_ascii\nClient connection timestamp, formatted as a human-readable time string. Set prior to execution of theÂ --client-connectÂ script.\ntime_duration\nThe duration (in seconds) of the client session which is now disconnecting. Set prior to execution of theÂ --client-disconnectÂ script.\ntime_unix\nClient connection timestamp, formatted as a unix integer date/time value. Set prior to execution of theÂ --client-connectÂ script.\ntls_digest_{n}\n/\ntls_digest_sha256_{n}\nContains the certificate SHA1 / SHA256 fingerprint, whereÂ nÂ is the verification level. Only set for TLS connections. Set prior to execution ofÂ --tls-verifyÂ script.\ntls_id_{n}\nA series of certificate fields from the remote peer, whereÂ nÂ is the verification level. Only set for TLS connections. Set prior to execution ofÂ --tls-verifyÂ script.\ntls_serial_{n}\nThe serial number of the certificate from the remote peer, whereÂ nÂ is the verification level. Only set for TLS connections. Set prior to execution ofÂ --tls-verifyÂ script. This is in the form of a decimal string like \"933971680\", which is suitable for doing serial-based OCSP queries (with OpenSSL, do not prepend \"0x\" to the string) If something goes wrong while reading the value from the certificate it will be an empty string, so your code should check that. See theÂ contrib/OCSP_check/OCSP_check.shÂ script for an example.\ntls_serial_hex_{n}\nLikeÂ tls_serial_{n}, but in hex form (e.g.Â 12:34:56:78:9A).\ntun_mtu\nThe MTU of the TUN/TAP device. Set prior toÂ --upÂ orÂ --downÂ script execution.\ntrusted_ip\n/\ntrusted_ip6\n)\nActual IP address of connecting client or peer which has been authenticated. Set prior to execution ofÂ --ipchange,Â --client-connectÂ andÂ --client-disconnectÂ scripts. If using ipv6 endpoints (udp6, tcp6),Â trusted_ip6Â will be set instead.\ntrusted_port\nActual port number of connecting client or peer which has been authenticated. Set prior to execution ofÂ --ipchange,Â --client-connectÂ andÂ --client-disconnectÂ scripts.\nuntrusted_ip\n/\nuntrusted_ip6\nActual IP address of connecting client or peer which has not been authenticated yet. Sometimes used toÂ nmapÂ the connecting host in aÂ --tls-verifyÂ script to ensure it is firewalled properly. Set prior to execution ofÂ --tls-verifyÂ andÂ --auth-user-pass-verifyÂ scripts. If using ipv6 endpoints (udp6, tcp6),Â untrusted_ip6Â will be set instead.\nuntrusted_port\nActual port number of connecting client or peer which has not been authenticated yet. Set prior to execution ofÂ --tls-verifyÂ andÂ --auth-user-pass-verifyÂ scripts.\nusername\nThe username provided by a connecting client. Set prior toÂ --auth-user-pass-verifyÂ script execution only when theÂ via-envÂ modifier is specified.\nX509_{n}_{subject_field}\nAn X509 subject field from the remote peer certificate, whereÂ nÂ is the verification level. Only set for TLS connections. Set prior to execution ofÂ --tls-verifyÂ script. This variable is similar toÂ tls_id_{n}Â except the component X509 subject fields are broken out, and no string remapping occurs on these field values (except for remapping of control characters to \"_\"). For example, the following variables would be set on the OpenVPN server using the sample client certificate in sample-keys (client.crt). Note that the verification level is 0 for the client certificate and 1 for the CA certificate.You can use theÂ --x509-trackÂ option to export more or less information from the certificates. X509_0_emailAddress=me@myhost.mydomain X509_0_CN=Test-Client X509_0_O=OpenVPN-TEST X509_0_ST=NA X509_0_C=KG X509_1_emailAddress=me@myhost.mydomain X509_1_O=OpenVPN-TEST X509_1_L=BISHKEK X509_1_ST=NA X509_1_C=KG\nManagement Interface Options\nOpenVPN provides a feature rich socket based management interface for both server and client mode operations.\n--management args\nEnable a management server on a socket-name Unix socket on those platforms supporting it, or on a designated TCP port.\nValid syntaxes:\nmanagement socket-name unix          #\nmanagement socket-name unix pw-file  # (recommended)\nmanagement IP port                   # (INSECURE)\nmanagement IP port pw-file           #\npw-file, if specified, is a password file where the password must be on first line. Instead of a filename it can use the keyword stdin which will prompt the user for a password to use when OpenVPN is starting. For unix sockets, the default behaviour is to create a unix domain socket that may be connected to by any process. Use the --management-client-user and --management-client-group directives to restrict access. The management interface provides a special mode where the TCP management link can operate over the tunnel itself. To enable this mode, set IP to tunnel. Tunnel mode will cause the management interface to listen for a TCP connection on the local VPN address of the TUN/TAP interface.\n*BEWARE*\nof enabling the management interface over TCP. In these cases you should\nALWAYS\nmake use of pw-file to password protect the management interface. Any user who can connect to this TCP IP:port will be able to manage and control (and interfere with) the OpenVPN process. It is also strongly recommended to set IP to 127.0.0.1 (localhost) to restrict accessibility of the management server to local clients. While the management port is designed for programmatic control of OpenVPN by other applications, it is possible to telnet to the port, using a telnet client in \"raw\" mode. Once connected, type\nhelp\nfor a list of commands.\nFor detailed documentation on the management interface, see the\nmanagement-notes.txt\nfile in the management folder of the OpenVPN source distribution.\n--management-client\nManagement interface will connect as a TCP/unix domain client to IP:port specified by --management rather than listen as a TCP server or on a unix domain socket.\nIf the client connection fails to connect or is disconnected, a SIGTERM signal will be generated causing OpenVPN to quit.\n--management-client-auth\nGives management interface client the responsibility to authenticate clients after their client certificate has been verified. See\nmanagement-notes.txt\nin OpenVPN distribution for detailed notes.\n--management-client-group g\nWhen the management interface is listening on a unix domain socket, only allow connections from group g.\n--management-client-user u\nWhen the management interface is listening on a unix domain socket, only allow connections from user u.\n--management-external-cert certificate-hint\nAllows usage for external certificate instead of --cert option (client-only). certificate-hint is an arbitrary string which is passed to a management interface client as an argument of\nNEED-CERTIFICATE\nnotification. Requires --management-external-key.\n--management-external-key args\nAllows usage for external private key file instead of --key option (client-only).\nValid syntaxes:\nmanagement-external-key\nmanagement-external-key nopadding\nmanagement-external-key pkcs1\nmanagement-external-key pss\nor any combination like:\nmanagement-external-key nopadding pkcs1\nmanagement-external-key pkcs1 pss\nThe optional parameters\nnopadding\npkcs1\nand\npss\nsignal support for different padding algorithms. See\ndoc/mangement-notes.txt\nfor a complete description of this feature.\n--management-forget-disconnect\nMake OpenVPN forget passwords when management session disconnects.\nThis directive does not affect the --http-proxy username/password. It is always cached.\n--management-hold\nStart OpenVPN in a hibernating state, until a client of the management interface explicitly starts it with the\nhold release\ncommand.\n--management-log-cache n\nCache the most recent n lines of log file history for usage by the management channel.\n--management-query-passwords\nQuery management channel for private key password and --auth-user-pass username/password. Only query the management channel for inputs which ordinarily would have been queried from the console.\n--management-query-proxy\nQuery management channel for proxy server information for a specific --remote (client-only).\n--management-query-remote\nAllow management interface to override --remote directives (client-only).\n--management-signal\nSend SIGUSR1 signal to OpenVPN if management session disconnects. This is useful when you wish to disconnect an OpenVPN session on user logoff. For --management-client this option is not needed since a disconnect will always generate a\nSIGTERM\n.\n--management-up-down\nReport tunnel up/down events to management interface.\nPlug-in Interface Options\nOpenVPN can be extended by loading external plug-in modules at runtime. These plug-ins must be prebuilt and adhere to the OpenVPN Plug-In API.\n--plugin args\nLoads an OpenVPN plug-in module.\nValid syntax:\nplugin module-name\nplugin module-name \"arguments\"\nThe module-name needs to be the first argument, indicating the plug-in to load. The second argument is an optional init string which will be passed directly to the plug-in. If the init consists of multiple arguments it must be enclosed in double-quotes (\"). Multiple plugin modules may be loaded into one OpenVPN process. The module-name argument can be just a filename or a filename with a relative or absolute path. The format of the filename and path defines if the plug-in will be loaded from a default plug-in directory or outside this directory.\n--plugin path         Effective directory used\n===================== =============================\nmyplug.so            DEFAULT_DIR/myplug.so\nsubdir/myplug.so     DEFAULT_DIR/subdir/myplug.so\n./subdir/myplug.so   CWD/subdir/myplug.so\n/usr/lib/my/plug.so  /usr/lib/my/plug.so\nDEFAULT_DIR is replaced by the default plug-in directory, which is configured at the build time of OpenVPN. CWD is the current directory where OpenVPN was started or the directory OpenVPN have switched into via the --cd option before the --plugin option. For more information and examples on how to build OpenVPN plug-in modules, see the README file in the plugin folder of the OpenVPN source distribution. If you are using an RPM install of OpenVPN, see\n/usr/share/openvpn/plugin\n. The documentation is in doc and the actual plugin modules are in lib. Multiple plugin modules can be cascaded, and modules can be used in tandem with scripts. The modules will be called by OpenVPN in the order that they are declared in the config file. If both a plugin and script are configured for the same callback, the script will be called last. If the return code of the module/script controls an authentication function (such as tls-verify, auth-user-pass-verify, or client-connect), then every module and script must return success (\n0\n) in order for the connection to be authenticated.\nWARNING\n:\nPlug-ins may do deferred execution, meaning the plug-in will return the control back to the main OpenVPN process and provide the plug-in result later on via a different thread or process. OpenVPN doesÂ NOTÂ support multiple authentication plug-insÂ where more than one pluginÂ tries to do deferred authentication. If this behaviour is detected, OpenVPN will shut down upon first authentication.\nWindows-Specific Options\n--allow-nonadmin TAP-adapter\n(Standalone) Set TAP-adapter to allow access from non-administrative accounts. If TAP-adapter is omitted, all TAP adapters on the system will be configured to allow non-admin access. The non-admin access setting will only persist for the length of time that the TAP-Win32 device object and driver remain loaded, and will need to be re-enabled after a reboot, or if the driver is unloaded and reloaded. This directive can only be used by an administrator.\n--block-outside-dns\nBlock DNS servers on other network adapters to prevent DNS leaks. This option prevents any application from accessing TCP or UDP port 53 except one inside the tunnel. It uses Windows Filtering Platform (WFP) and works on Windows Vista or later.\nThis option is considered unknown on non-Windows platforms and unsupported on Windows XP, resulting in fatal error. You may want to use --setenv opt or --ignore-unknown-option (not suitable for Windows XP) to ignore said error. Note that pushing unknown options from server does not trigger fatal errors.\n--cryptoapicert select-string\n(Windows/OpenSSL Only)\nLoad the certificate and private key from the Windows Certificate System Store.\nUse this option instead of --cert and --key. This makes it possible to use any smart card, supported by Windows, but also any kind of certificate, residing in the Cert Store, where you have access to the private key. This option has been tested with a couple of different smart cards (GemSAFE, Cryptoflex, and Swedish Post Office eID) on the client side, and also an imported PKCS12 software certificate on the server side. To select a certificate, based on a substring search in the certificate's subject:\ncryptoapicert \"SUBJ:Peter Runestig\"\nTo select a certificate, based on certificate's thumbprint (SHA1 hash):\ncryptoapicert \"THUMB:f6 49 24 41 01 b4 ...\"\nThe thumbprint hex string can easily be copy-and-pasted from the Windows Certificate Store GUI. The embedded spaces in the hex string are optional. To select a certificate based on a substring in certificate's issuer name:\ncryptoapicert \"ISSUER:Sample CA\"\nTo select a certificate based on a certificate's template name or OID of the template:\ncryptoapicert \"TMPL:Name of Template\"\ncryptoapicert \"TMPL:1.3.6.1.4...\"\nThe first non-expired certificate found in the user's store or the machine store that matches the select-string is used.\n--dhcp-release\nAsk Windows to release the TAP adapter lease on shutdown. This option has no effect now, as it is enabled by default starting with OpenVPN 2.4.1.\n--dhcp-renew\nAsk Windows to renew the TAP adapter lease on startup. This option is normally unnecessary, as Windows automatically triggers a DHCP renegotiation on the TAP adapter when it comes up, however if you set the TAP-Win32 adapter Media Status property to \"Always Connected\", you may need this flag.\n--ip-win32 method\nWhen using --ifconfig on Windows, set the TAP-Win32 adapter IP address and netmask using method. Don't use this option unless you are also using --ifconfig.\nmanual\nDon't set the IP address or netmask automatically. Instead output a message to the console telling the user to configure the adapter manually and indicating the IP/netmask which OpenVPN expects the adapter to be set to.\ndynamic [offset] [lease-time]\nAutomatically set the IP address and netmask by replying to DHCP query messages generated by the kernel. This mode is probably the \"cleanest\" solution for setting the TCP/IP properties since it uses the well-known DHCP protocol. There are, however, two prerequisites for using this mode:The TCP/IP properties for the TAP-Win32 adapter must be set to \"Obtain an IP address automatically\", andOpenVPN needs to claim an IP address in the subnet for use as the virtual DHCP server address.By default inÂ --devÂ tapÂ mode, OpenVPN will take the normally unused first address in the subnet. For example, if your subnet isÂ 192.168.4.0 netmask 255.255.255.0, then OpenVPN will take the IP addressÂ 192.168.4.0Â to use as the virtual DHCP server address. InÂ --devÂ tunÂ mode, OpenVPN will cause the DHCP server to masquerade as if it were coming from the remote endpoint. The optional offset parameter is an integer which is >Â -256Â and <Â 256Â and which defaults to 0. If offset is positive, the DHCP server will masquerade as the IP address at network address + offset. If offset is negative, the DHCP server will masquerade as the IP address at broadcast address + offset. The WindowsÂ ipconfig /allÂ command can be used to show what Windows thinks the DHCP server address is. OpenVPN will \"claim\" this address, so make sure to use a free address. Having said that, different OpenVPN instantiations, including different ends of the same connection, can share the same virtual DHCP server address. TheÂ lease-timeÂ parameter controls the lease time of the DHCP assignment given to the TAP-Win32 adapter, and is denoted in seconds. Normally a very long lease time is preferred because it prevents routes involving the TAP-Win32 adapter from being lost when the system goes to sleep. The default lease time is one year.\nnetsh\nAutomatically set the IP address and netmask using the Windows command-line \"netsh\" command. This method appears to work correctly on Windows XP but not Windows 2000.\nipapi\nAutomatically set the IP address and netmask using the Windows IP Helper API. This approach does not have ideal semantics, though testing has indicated that it works okay in practice. If you use this option, it is best to leave the TCP/IP properties for the TAP-Win32 adapter in their default state, i.e. \"Obtain an IP address automatically.\"\nadaptive\n(Default)\nTryÂ dynamicÂ method initially and fail over toÂ netshÂ if the DHCP negotiation with the TAP-Win32 adapter does not succeed in 20 seconds. Such failures have been known to occur when certain third-party firewall packages installed on the client machine block the DHCP negotiation used by the TAP-Win32 adapter. Note that if theÂ netshÂ failover occurs, the TAP-Win32 adapter TCP/IP properties will be reset from DHCP to static, and this will cause future OpenVPN startups using theÂ adaptiveÂ mode to useÂ netshÂ immediately, rather than tryingÂ dynamicÂ first.To \"unstick\" theÂ adaptiveÂ mode from usingÂ netsh, run OpenVPN at least once using theÂ dynamicÂ mode to restore the TAP-Win32 adapter TCP/IP properties to a DHCP configuration.\n--pause-exit\nPut up a \"press any key to continue\" message on the console prior to OpenVPN program exit. This option is automatically used by the Windows explorer when OpenVPN is run on a configuration file using the right-click explorer menu.\n--register-dns\nRun\nipconfig /flushdns\nand\nipconfig /registerdns\non connection initiation. This is known to kick Windows into recognizing pushed DNS servers.\n--route-method m\nWhich method m to use for adding routes on Windows?\nadaptive\n(default)\nTry IP helper API first. If that fails, fall back to the route.exe shell command.\nipapi\nUse IP helper API.\nexe\nCall the route.exe shell command.\n--service args\nShould be used when OpenVPN is being automatically executed by another program in such a context that no interaction with the user via display or keyboard is possible.\nValid syntax:\nservice exit-event [0|1]\nIn general, end-users should never need to explicitly use this option, as it is automatically added by the OpenVPN service wrapper when a given OpenVPN configuration is being run as a service. exit-event is the name of a Windows global event object, and OpenVPN will continuously monitor the state of this event object and exit when it becomes signaled. The second parameter indicates the initial state of exit-event and normally defaults to 0. Multiple OpenVPN processes can be simultaneously executed with the same exit-event parameter. In any case, the controlling process can signal exit-event, causing all such OpenVPN processes to exit.\nWhen executing an OpenVPN process using the --service directive, OpenVPN will probably not have a console window to output status/error messages, therefore it is useful to use --log or --log-append to write these messages to a file.\n--show-adapters\n(Standalone) Show available TAP-Win32 adapters which can be selected using the --dev-node option. On non-Windows systems, the ifconfig(8) command provides similar functionality.\n--show-net\n(Standalone) Show OpenVPN's view of the system routing table and network adapter list.\n--show-net-up\nOutput OpenVPN's view of the system routing table and network adapter list to the syslog or log file after the TUN/TAP adapter has been brought up and any routes have been added.\n--show-valid-subnets\n(Standalone) Show valid subnets for --dev tun emulation. Since the TAP-Win32 driver exports an ethernet interface to Windows, and since TUN devices are point-to-point in nature, it is necessary for the TAP-Win32 driver to impose certain constraints on TUN endpoint address selection.\nNamely, the point-to-point endpoints used in TUN device emulation must be the middle two addresses of a /30 subnet (netmask 255.255.255.252).\n--tap-sleep n\nCause OpenVPN to sleep for n seconds immediately after the TAP-Win32 adapter state is set to \"connected\".\nThis option is intended to be used to troubleshoot problems with the --ifconfig and --ip-win32 options, and is used to give the TAP-Win32 adapter time to come up before Windows IP Helper API operations are applied to it.\n--win-sys path\nSet the Windows system directory pathname to use when looking for system executables such as route.exe and netsh.exe. By default, if this directive is not specified, OpenVPN will use the SystemRoot environment variable.\nThis option has changed behaviour since OpenVPN 2.3. Earlier you had to define --win-sys env to use the SystemRoot environment variable, otherwise it defaulted to\nC:\\\\WINDOWS\n. It is not needed to use the env keyword any more, and it will just be ignored. A warning is logged when this is found in the configuration file.\n--windows-driver drv\nSpecifies which tun driver to use. Values are\novpn-dco\n(default),\ntap-windows6\nand\nwintun\n.\novpn-dco\nand\nwintun\nrequire --dev tun.\nwintun\nalso requires OpenVPN process to run elevated, or be invoked using the Interactive Service.\nStandalone Debug Options\n--show-gateway args\n(Standalone) Show current IPv4 and IPv6 default gateway and interface towards the gateway (if the protocol in question is enabled).\nValid syntax:\n--show-gateway\n--show-gateway IPv6-target\nFor IPv6 this queries the route towards ::/128, or the specified IPv6 target address if passed as argument. For IPv4 on Linux, Windows, MacOS and BSD it looks for a 0.0.0.0/0 route. If there are more specific routes, the result will not always be matching the route of the IPv4 packets to the VPN gateway.\nAdvanced Expert Options\nThese are options only required when special tweaking is needed, often used when debugging or testing out special usage scenarios.\n--hash-size args\nSet the size of the real address hash table to r and the virtual address table to v.\nValid syntax:\nhash-size r v\nBy default, both tables are sized at 256 buckets.\n--bcast-buffers n\nAllocate n buffers for broadcast datagrams (default\n256\n).\n--persist-local-ip\nPreserve initially resolved local IP address and port number across SIGUSR1 or --ping-restart restarts.\n--persist-remote-ip\nPreserve most recently authenticated remote IP address and port number across\nSIGUSR1\nor --ping-restart restarts.\n--rcvbuf size\nSet the TCP/UDP socket receive buffer size. Defaults to operating system default.\n--shaper n\nLimit bandwidth of outgoing tunnel data to n bytes per second on the TCP/UDP port. Note that this will only work if mode is set to\np2p\n. If you want to limit the bandwidth in both directions, use this option on both peers.\nOpenVPN uses the following algorithm to implement traffic shaping: Given a shaper rate of n bytes per second, after a datagram write of b bytes is queued on the TCP/UDP port, wait a minimum of (b / n) seconds before queuing the next write. It should be noted that OpenVPN supports multiple tunnels between the same two peers, allowing you to construct full-speed and reduced bandwidth tunnels at the same time, routing low-priority data such as off-site backups over the reduced bandwidth tunnel, and other data over the full-speed tunnel. Also note that for low bandwidth tunnels (under 1000 bytes per second), you should probably use lower MTU values as well (see above), otherwise the packet latency will grow so large as to trigger timeouts in the TLS layer and TCP connections running over the tunnel.\nOpenVPN allows n to be between 100 bytes/sec and 100 Mbytes/sec.\n--sndbuf size\nSet the TCP/UDP socket send buffer size. Defaults to operating system default.\n--tcp-queue-limit n\nMaximum number of output packets queued before TCP (default\n64\n).\nWhen OpenVPN is tunneling data from a TUN/TAP device to a remote client over a TCP connection, it is possible that the TUN/TAP device might produce data at a faster rate than the TCP connection can support. When the number of output packets queued before sending to the TCP socket reaches this limit for a given client connection, OpenVPN will start to drop outgoing packets directed at this client.\n--txqueuelen n\n(Linux only)\nSet the TX queue length on the TUN/TAP interface. Currently defaults to operating system default.\n--disable-dco\nDisables the opportunistic use of data channel offloading if available. Without this option, OpenVPN will opportunistically use DCO mode if the config options and the running kernel supports using DCO.\nData channel offload currently requires data-ciphers to only contain AEAD ciphers (AES-GCM and Chacha20-Poly1305) and Linux with the ovpn-dco module. Note that some options have no effect or cannot be used when DCO mode is enabled.\nOn platforms that do not support DCO disable-dco has no effect.\nUNSUPPORTED OPTIONS\nOptions listed in this section have been removed from OpenVPN and are no longer supported\n--client-cert-not-required\nRemoved in OpenVPN 2.5. This should be replaxed with --verify-client-cert none.\n--ifconfig-pool-linear\nRemoved in OpenVPN 2.5. This should be replaced with --topology p2p.\n--key-method\nRemoved in OpenVPN 2.5. This option should not be used, as using the old key-method weakens the VPN tunnel security. The old key-method was also only needed when the remote side was older than OpenVPN 2.0.\n--management-client-pf\nRemoved in OpenVPN 2.6. The built-in packet filtering (pf) functionality has been removed.\n--ncp-disable\nRemoved in OpenVPN 2.6. This option mainly served a role as debug option when NCP was first introduced. It should no longer be necessary.\n--no-iv\nRemoved in OpenVPN 2.5. This option should not be used as it weakens the VPN tunnel security. This has been a NOOP option since OpenVPN 2.4.\n--no-replay\nRemoved in OpenVPN 2.5. This option should not be used as it weakens the VPN tunnel security.\n--ns-cert-type\nRemoved in OpenVPN 2.5. The nsCertType field is no longer supported in recent SSL/TLS libraries. If your certificates does not include\nkey usage\nand\nextended key usage\nfields, they must be upgraded and the --remote-cert-tls option should be used instead.\n--prng\nRemoved in OpenVPN 2.6. We now always use the PRNG of the SSL library.\nCONNECTION PROFILES\nClient configuration files may contain multiple remote servers which it will attempt to connect against. But there are some configuration options which are related to specific --remote options. For these use cases, connection profiles are the solution. By enacpulating the --remote option and related options within <connection> and </connection>, these options are handled as a group. An OpenVPN client will try each connection profile sequentially until it achieves a successful connection. --remote-random can be used to initially \"scramble\" the connection list. Here is an example of connection profile usage:\nclient\ndev tun\n<connection>\nremote 198.19.34.56 1194 udp\n</connection>\n<connection>\nremote 198.19.34.56 443 tcp\n</connection>\n<connection>\nremote 198.19.34.56 443 tcp\nhttp-proxy 192.168.0.8 8080\n</connection>\n<connection>\nremote 198.19.36.99 443 tcp\nhttp-proxy 192.168.0.8 8080\n</connection>\npersist-key\npersist-tun\npkcs12 client.p12\nremote-cert-tls server\nverb 3\nFirst we try to connect to a server at 198.19.34.56:1194 using UDP. If that fails, we then try to connect to 198.19.34.56:443 using TCP. If that also fails, then try connecting through an HTTP proxy at 192.168.0.8:8080 to 198.19.34.56:443 using TCP. Finally, try to connect through the same proxy to a server at 198.19.36.99:443 using TCP. The following OpenVPN options may be used inside of a <connection> block: bind, connect-retry, connect-retry-max, connect-timeout, explicit-exit-notify, float, fragment, http-proxy, http-proxy-option, key-direction, link-mtu, local, lport, mssfix, mtu-disc, nobind, port, proto, remote, rport, socks-proxy, tls-auth, tls-crypt, tun-mtu and, tun-mtu-extra. A defaulting mechanism exists for specifying options to apply to all <connection> profiles. If any of the above options (with the exception of remote ) appear outside of a <connection> block, but in a configuration file which has one or more <connection> blocks, the option setting will be used as a default for <connection> blocks which follow it in the configuration file. For example, suppose the nobind option were placed in the sample configuration file above, near the top of the file, before the first <connection> block. The effect would be as if nobind were declared in all <connection> blocks below it.\nINLINE FILE SUPPORT\nOpenVPN allows including files in the main configuration for the --ca, --cert, --dh, --extra-certs, --key, --pkcs12, --secret, --crl-verify, --http-proxy-user-pass, --tls-auth, --auth-gen-token-secret, --peer-fingerprint, --tls-crypt, --tls-crypt-v2, --verify-hash and --auth-user-pass options. Each inline file started by the line <option> and ended by the line </option> Here is an example of an inline file usage\n<cert>\n-----BEGIN CERTIFICATE-----\n[...]\n-----END CERTIFICATE-----\n</cert>\nWhen using the inline file feature with --pkcs12 the inline file has to be base64 encoded. Encoding of a .p12 file into base64 can be done for example with OpenSSL by running\nopenssl base64 -in input.p12\nSIGNALS\nSIGHUP\nCause OpenVPN to close all TUN/TAP and network connections, restart, re-read the configuration file (if any), and reopen TUN/TAP and network connections.\nSIGUSR1\nLikeÂ SIGHUP`, except don't re-read configuration file, and possibly don't close and reopen TUN/TAP device, re-read key files, preserve local IP address/port, or preserve most recently authenticated remote IP address/port based onÂ --persist-tun,Â --persist-key,Â --persist-local-ipÂ andÂ --persist-remote-ipÂ options respectively (see above).This signal may also be internally generated by a timeout condition, governed by theÂ --ping-restartÂ option. This signal, when combined withÂ --persist-remote-ip, may be sent when the underlying parameters of the host's network interface change such as when the host is a DHCP client and is assigned a new IP address. SeeÂ --ipchangeÂ for more information.\nSIGUSR2\nCauses OpenVPN to display its current statistics (to the syslog file ifÂ --daemonÂ is used, or stdout otherwise).\nSIGINT\n,\nSIGTERM\nCauses OpenVPN to exit gracefully.\nFAQ\nhttps://community.openvpn.net/FAQ\nHOWTO\nThe manual\nopenvpn-examples\ngives some examples, especially for small setups.\nFor a more comprehensive guide to setting up OpenVPN in a production setting, see the\nOpenVPN HOWTO.\nPROTOCOL\nAn ongoing effort to document the OpenVPN protocol can be found under\nhttps://github.com/openvpn/openvpn-rfc\n.\nWEB\nRefer to\nOpenVPN's website\nto download the latest version of OpenVPN, subscribe to the mailing lists, read the mailing list archives, or browse the Git repository.\nBUGS\nReport all bugs to the OpenVPN team\ninfo@openvpn.net\n.\nSEE ALSO\nopenvpn-examples, dhcpcd, ifconfig, openssl, route, scp, ssh\nNOTES\nThis product includes software developed by\nthe OpenSSL Project\n.\nFor more information on the TLS protocol, seeÂ\nhttp://www.ietf.org/rfc/rfc2246.txt\n.\nFor more information on the LZO real-time compression library seeÂ\nhttp://www.oberhumer.com/opensource/lzo/\n.\nCOPYRIGHT\nCopyright (C) 2002-2020 OpenVPN Inc. This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation.\nAUTHORS\nJames Yonan\njames@openvpn.net\nIn this section\n:\nOpenVPN 2.6 Manual\nINTRODUCTION\nDESCRIPTION\nOPTIONS\nGeneric Options\nLog options\nProtocol options\nClient Options\nServer Options\nEncryption Options\nData channel cipher negotiation\nNETWORK CONFIGURATION\nLink Options\nVirtual Network Adapter (VPN interface)\nTUN/TAP standalone operations\nVirtual Routing and Forwarding\nSCRIPTING INTEGRATION\nScript Order of Execution\nSCRIPT HOOKS\nString Types and Remapping\nEnvironmental Variables\nManagement Interface Options\nPlug-in Interface Options\nWindows-Specific Options\nStandalone Debug Options\nAdvanced Expert Options\nUNSUPPORTED OPTIONS\nCONNECTION PROFILES\nINLINE FILE SUPPORT\nSIGNALS\nFAQ\nHOWTO\nPROTOCOL\nWEB\nBUGS\nSEE ALSO\nNOTES\nCOPYRIGHT\nAUTHORS\nSearch results\nNo results found\nWas this helpful?\nYes\nNo\nPrev\nNext", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://openvpn.net/community-resources/reference-manual-for-openvpn-2-6/"}}
{"text": "SambaWiki\nJump to content\nSambaWiki\nSearch\nSearch\nMain Page\nFrom SambaWiki\nWelcome\nSamba\nis an\nOpen Source\n/\nFree Software\nsuite that has,\nsince 1992\n, provided file and print services to all manner of SMB/CIFS clients, including the numerous versions of Microsoft Windows operating systems. Samba is freely available under the\nGNU General Public License\n.\nThe Samba project is a member of the\nSoftware Freedom Conservancy\n.\nUser Documentation\nSetting up Samba as an Active Directory Domain Controller\nSetting up Samba as a Domain Member\nJoining a Samba DC to an Existing Active Directory\nUpdating Samba\nSetting up a Share Using POSIX ACLs\nSetting up a Share Using Windows ACLs\nSetting up Samba as a Print Server\nCTDB and Clustered Samba\nFAQ - Frequently Asked Questions\nOnline man page documentation for Samba\nmore...\nDeveloper Documentation\nWriting Torture Tests\nUsing Git for Samba Development\nSamba CI on gitlab\nWireshark with keytab to decrypt encrypted traffic\nGoogle Summer of Code\nmore...\nContribution\nBug reporting\nCapture packets\nContributing Code to Samba\nCode review\nmore...\nLatest Releases\nCurrent Stable Release\n:\n4.23.3\n(\nRelease Notes\n)\nMaintenance Mode\n:\n4.22.6\n(\nRelease Notes\n)\nSecurity Fixes Only Mode\n:\n4.21.10\n(\nRelease Notes\n)\nRelease Planning\nUpcoming Events\nUpcoming Events\nNews\nSamba News\nPresentations\nVideos\nCommunity\nHow to do Samba: Nicely\nRetrieved from \"\nhttps://wiki.samba.org/index.php?title=Main_Page&oldid=19718\n\"", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://wiki.samba.org/index.php/Main_Page"}}
{"text": "Setting up Samba as a Standalone Server - SambaWiki\nJump to content\nSambaWiki\nSearch\nSearch\nSetting up Samba as a Standalone Server\nFrom SambaWiki\nIntroduction\nIn small networks, such as a home network, or to share folders on a host that is not part of a domain, you often do not want to set up an\nActive Directory\nor\nNT4 domain\n.\nThe following documentation describes how to set up a Samba standalone server providing:\na share that is accessible anonymously (guest access).\na share that requires authentication against a local user database on the Samba host.\nCreating a Basic guest only smb.conf File\nThe following is a minimal configuration for a Samba standalone server that only allows guest access:\n[global]\nmap to guest = Bad User\nlog file = /var/log/samba/%m\nlog level = 1\nserver role = standalone server\n[guest]\n# This share allows anonymous (guest) access\n# without authentication!\npath = /srv/samba/guest/\nread only = no\nguest ok = yes\nguest only = yes\nThis example defines a share that is accessible without authentication. Guest shares can be a security problem. For example on a laptop that is connected to different networks, such as home, school, and work networks. Use guest shares with care and never use a guest share with authenticated users.\nStarting from Windows 10 1709, guest access in SMB2 and SMB3 may be disabled by default. This means that guest access from Windows 10, or later, to a Samba share may not work, for more information, see\nhere\n.\nIf you share anything from a users home directory, you should be aware that anything inside the directory you share, or anything inside directories beneath the shared directory will be accessible by whomever you allow to access the share. Never store anything private in such a share.\nCreating a Basic authenticated access smb.conf File\nThe following is a minimal configuration for a Samba standalone server:\n[global]\nlog file = /var/log/samba/%m\nlog level = 1\nserver role = standalone server\n[demo]\n# This share requires authentication to access\npath = /srv/samba/demo/\nread only = no\ninherit permissions = yes\nYou can set a workgroup name with\nworkgroup = xxxxxxxx\n, where 'xxxxxxxx' is the required name. If the parameter isn't set, the default workgroup name 'WORKGROUP' will be used.\nYou can restrict access to members of a specified group by adding\nvalid users = @demoGroup\nto the share, you will need to replace\ndemoGroup\nwith the required Unix group name.\nThe log parameters are not necessary for a minimal setup. However they are useful to set the log file and increasing the log level in case of problems.\nWhilst these are only minimal smb.conf files, you can add other parameters, such as 'unix password sync = yes' to ensure the Unix & Samba passwords are kept in sync. See 'man smb.conf' for more info.\nCreating Local User Accounts, option #1\nTo provide authentication on a standalone host, you have to create the accounts locally on the operating system and additionally in the Samba database. By default, Samba uses the\ntdbsam\nback end and stores the database in the\n/usr/local/samba/private/passdb.tdb\nfile. Optionally set a different location in the\nsmb.conf\nfile using the\npassdb backend\nparameter. See the\nsmb.conf 5\nman page for details.\nCreate a\ndemoUser\naccount on the local system:\n# useradd -M -s /sbin/nologin demoUser\nOmit the\n-M\nparameter if the user requires a home directory on this host. For Samba access, the account does not require a valid shell.\nTo enable the\ndemoUser\naccount on the local system:\n# passwd demoUser\nEnter new UNIX password: Passw0rd\nRetype new UNIX password: Passw0rd\npasswd: password updated successfully\nSetting a local password is required to enable the account. Samba denies access if the account is disabled locally. Local log ins using this password are not possible if the account was created without a valid shell.\nAdd the\ndemoUser\naccount to the Samba database:\n# smbpasswd -a demoUser\nNew SMB password: Passw0rd\nRetype new SMB password: Passw0rd\nAdded user demoUser.\nThe password assigned in these steps is the one used by the user to log in to the domain.\nCreating Local User Accounts, option #2\nTo provide authentication on a standalone host, users have to exist both on the operating system and in the Samba database.\nSamba can be configured to automatically create linux user accounts after successful samba authentication, using the [global]\nadd user script\nsmb.conf option. Unfortunately this option does\nnot\nwork as intended at end-user access time, but it can be leveraged to simplify adding users to your samba Standalone Server. Because, when adding a samba user with\n# smbpasswd -a demoUser\nNew SMB password: Passw0rd\nRetype new SMB password: Passw0rd\nAdded user demoUser.\nsamba will automatically call the configured\nadd user script\n, and create the local linux user for you.\nA very simple sample add_user.sh script could be something like:\n#!/bin/bash\nadduser --no-create-home --shell /usr/sbin/nologin --user-group $1\nBoth the linux and the samba user will be deleted with\n# pdbedit -x demoUser\nLocal Group Management\nTo create a\ndemoGroup\ngroup:\n# groupadd demoGroup\nTo add the\ndemoUser\naccount to the group:\n# usermod -aG demoGroup demoUser\nCreating the Shared Directories\nTo create the shares directories:\n# mkdir -p /srv/samba/guest/\n# mkdir -p /srv/samba/demo/\nIf you are using (enforcing) SElinux, samba access to these locations might be denied, unless:\n# semanage fcontext -a -t samba_share_t \"/srv/samba/guest(/.*)?\"\n# restorecon -Rv /srv/samba/guest/\nand\n# semanage fcontext -a -t samba_share_t \"/srv/samba/demo(/.*)?\"\n# restorecon -Rv /srv/samba/demo/\nSetting ACLs on the Shared Directories\nSet the following POSIX permissions:\n# chown -R nobody:nogroup /srv/samba/guest/\n# chgrp -R demoGroup /srv/samba/demo/\n# chmod 2770 /srv/samba/guest/\n# chmod 2770 /srv/samba/demo/\nThis configures write access to  members of the\ndemoGroup\ngroup in both directories. Other users have read access in the\n/srv/samba/guest/\nand no access in the\n/srv/samba/demo/\ndirectory. The SGID bit - represented by the first bit (\n2\n) in the mode set on the directories - inherits the group of the parent directory instead setting it to the users primary group when new files are created.\nFor further information, see\nSetting up a Share Using POSIX ACLs\n.\nVerifying the Samba configuration\nYou should verify the Samba configuration every time the /etc/samba/smb.conf file is updated by using the  testparm utility\nYou can simply execute it as follows:\n# testparm -s\nSample output:\nLoad smb config files from /etc/samba/smb.conf\nLoaded services file OK.\nServer role: ROLE_STANDALONE\nPress enter to see a dump of your service definitions\n...\nIf any errors are shown (you can ignore deprecation warnings), fix them before proceeding.\nStarting Samba\nStart the\nsmbd\ndaemon:\n# smbd\nSamba does not include start scripts. See your distribution's documentation how further information how to automatically start a service at boot time.\nTesting the Share Access\nAccess the\ndemo\nshare as user\ndemoUser\n:\n# smbclient -U demoUser //SA/demo\nEnter demoUser's password: Passw0rd\nDomain=[WORKGROUP] OS=[Windows 6.1] Server=[Samba x.y.z]\nsmb: \\> ls\n.                                   D        0  Sun Jan  3 21:00:00 2016\n..                                  D        0  Sun Jan  3 19:00:00 2016\ndemo.txt                            A        0  Sun Jan  3 21:00:00 2016\n9943040 blocks of size 1024. 7987416 blocks available\nsmb: \\> quit\nAccess the\ndemo\nshare as guest. The access is denied:\n# smbclient -U guest //SA/demo\nEnter guest's password:\nDomain=[WORKGROUP] OS=[Windows 6.1] Server=[Samba x.y.z]\ntree connect failed: NT_STATUS_ACCESS_DENIED\n.\nAdvanced share settings\nThis section describes some advanced share configuration parameters. For further information about the used parameters, see the\nsmb.conf (5)\nman page.\nUsing the\nforce\nParameters\n[demo]\npath = /srv/samba/demo/\nread only = no\nforce create mode = 0660\nforce directory mode = 2770\nforce user = demoUser\nforce group = demoGroup\nThe\nforce create mode\nand\nforce directory mode\nparameters force Samba to create new files and folders with the set permissions.\nThe\nforce user\nand\nforce group\nparameters map all connections to the specified user and group. Note that this can cause security problems if all users connecting to a share are mapped to a specific user account or group in the background.\nUser and Group-based Share Access\nSee\nConfiguring User and Group-based Share Access\n.\nHost-based Share Access\nSee\nConfiguring Host-based Share Access\n.\nRetrieved from \"\nhttps://wiki.samba.org/index.php?title=Setting_up_Samba_as_a_Standalone_Server&oldid=19486\n\"\nCategory\n:\nStandalone Server", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://wiki.samba.org/index.php/Setting_up_Samba_as_a_Standalone_Server"}}
{"text": "Main Page - Linux NFS\nMain Page\nFrom Linux NFS\nJump to:\nnavigation\n,\nsearch\nDevelopment\nMailing lists:\nlinux-nfs@vger.kernel.org (\narchive\n)\nlinux-fsdevel@vger.kernel.org (\narchive\n)\nlinux-kernel@vger.kernel.org (\narchive\n)\ndefunct pnfs list\narchive\ndefunct nfsv4 list\narchive\nIRC: #linux-nfs at oftc.net (mainly for developer chat; questions are better sent to the mailing list)\nCode repositories:\nupstream kernel\nnfs-utils\nrpcbind\nlibtirpc\nnfs4-acl-tools\nClient tools for manipulating NFSv4 ACLs directly.\nnfs4-acl-tools tarballs\nBugzilla:\nbugzilla.kernel.org\nfor upstream bugs\nbugzilla.linux-nfs.org\nfor out-of-tree projects and other miscellaneous NFS uses\nIETF NFSv4 working group\n: protocol specifications\nnfsv4bat.org/Documents\n: Bakeathon, Connectathon, and other presentations\nIntroduction to Linux NFS hacking\nTo do\n(projects looking for volunteers)\nDual-protocol support\npNFS Development\nCluster Coherent NFS\nNfsd4 server recovery\nNFS related files for download\nPeer-to-peer NFS\nhigh availability SCSI layout\nAlternate Data Streams\nNFS re-export\nDocumentation\nNFS Howto\nNFS FAQ\nNFSv4.1 End user documentation\nGeneral troubleshooting recommendations\nFeature Design Documents\nLinux, AD, and NetApp filers\nGSS-Proxy\nReporting bugs\nReaddir performance results\nJenkins CI\nNFS and FreeIPA\npNFS block server setup\nNFS over SoftRoCE setup\nNFS over soft iWARP setup\nTesting\nConnectathon test suite\npynfs\nNFSometer\n: NFS performance measurement tool\nNFStest\n: NFS test suite\nxfstests\n: xfstests setup & expected output\nOld stuff\n(design documents for stalled or completed projects, etc.)\nRetrieved from \"\nhttps://wiki.linux-nfs.org/wiki/index.php/Main_Page\n\"\nViews\nPage\nDiscussion\nView source\nHistory\nPersonal tools\nLog in\nNavigation\nMain Page\nRecent changes\nRandom page\nHelp\nSearch\nToolbox\nWhat links here\nRelated changes\nSpecial pages\nPrintable version\nPermanent link\nCite this page\nThis page was last modified on 7 June 2022, at 17:15.\nThis page has been accessed 112,847 times.\nPrivacy policy\nAbout Linux NFS\nDisclaimers", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://wiki.linux-nfs.org/wiki/index.php/Main_Page"}}
{"text": "nftables wiki\nMain Page\nFrom nftables wiki\nJump to navigation\nJump to search\nWelcome to the\nnftables\nHOWTO documentation page. Here you will find documentation on how to build, install, configure and use nftables.\nIf you have any suggestion to improve it, please send your comments to Netfilter users mailing list <netfilter@vger.kernel.org>.\nContents\n1\nNews\n2\nIntroduction\n3\nReference\n4\nInstalling nftables\n5\nUpgrading from xtables to nftables\n6\nBasic operation\n7\nExpressions: Matching packets\n8\nStatements: Acting on packet matches\n9\nAdvanced data structures for performance packet classification\n10\nExamples\n11\nDevelopment\n12\nExternal links\n13\nThanks\nNews\nIntroduction\nWhat is nftables?\nHow to obtain help/support\nReference\nman nft - netfilter website\nman nft - mankier.com\nQuick reference, nftables in 10 minutes\nNetfilter hooks\nand nftables integration with existing Netfilter components\nUnderstanding nftables families\nData types\nConnection tracking system (conntrack)\n, used for stateful firewalling and NAT\nTroubleshooting and FAQ\nAdditional documentation\nInstalling nftables\nUsing nftables from distributions\nBuilding and installing nftables from sources\nUpgrading from xtables to nftables\nLegacy xtables tools\nMoving from iptables to nftables\nMoving from ipset to nftables\nBasic operation\nConfiguring tables\nConfiguring chains\nSimple rule management\nAtomic rule replacement\nError reporting from the command line\nBuilding rules through expressions\nOperations at ruleset level\nMonitoring ruleset updates\nScripting\nRuleset debug/tracing\nRuleset debug/VM code analysis\nOutput text modifiers\nExpressions: Matching packets\nMatching packet metainformation\nMatching packet headers\nMatching connection tracking stateful metainformation\nMatching routing information\nRate limiting matchings\nStatements: Acting on packet matches\nAccepting and dropping packets\nRejecting traffic\nJumping to chain\nCounters\nLogging traffic\nPerforming Network Address Translation (NAT)\nSetting packet metainformation\nSetting packet connection tracking metainformation\nMangling packet headers\n(including stateless NAT)\nDuplicating packets\nLoad balancing\nQueueing to userspace\nAdvanced data structures for performance packet classification\nIntervals\nConcatenations\nMath operations\nStateful objects\nCounters\nQuotas\nLimits\nConnlimits\n(\nct count\n)\nOther objects\nConntrack helpers\n(\nct helper\n, Layer 7 ALG)\nConntrack timeout policies\n(\nct timeout\n)\nConntrack expectations\n(\nct expectation\n)\nSynproxy\nSecmarks\nGeneric set infrastructure\nSets\nElement timeouts\nUpdating sets from the packet path\nMaps\nVerdict maps\nMetering\n(formerly known as flow tables before nftables 0.8.1)\nFlowtables\n(the fastpath network stack bypass)\nExamples\nSimple ruleset for a workstation\nSimple ruleset for a server\nSimple ruleset for a home router\nBridge filtering\nMultiple NATs using nftables maps\nClassic perimetral firewall example\nPort knocking example\nClassification to tc structure example\nUsing configuration management systems\n(like puppet, ansible, etc)\nGeoIP matching\nDevelopment\nCheck\nPortal:DeveloperDocs - documentation for netfilter developers\n.\nSome hints on the general development progress:\nList of updates since Linux kernel 3.13\nList of updates in the nft command line tool\nSupported features compared to {ip,ip6,eb,arp}tables\nList of available translations via iptables-translate tool\nExternal links\nWatch some videos:\nWatch\nGetting a grasp of nftables\n, thanks to\nNLUUG association\nfor recording this.\nWatch\nThe ultimate packet classifier for GNU/Linux\n, thanks to the FSFE for paying my trip to Barcelona and for recommending me as speaker to the KDE Spanish branch.\nFlorian Westphal - Why nftables?\nWatch\nNLUUG - Goodbye iptables, Hello nftables\nWatch videos to track updates:\nWatch\nNetdev 2.1 - Netfilter mini-workshop (2017)\nWatch\nNetdev 2.2 - Netf‌ilter mini-workshop (2018)\nWatch\nNetdev 0x12 - Netf‌ilter mini-workshop (2019)\nWatch\nNetdev 0x14 - Netfilter mini-Workshop (2020)\nAdditional documentations and articles:\nTutorial\nExtending nftables by Xiang Gao\nArticle\nNew in Debian stable Stretch: nftables\nArticle\nHow to use nftables from python\nand git repository\npython-nftables-tutorial.git\nThanks\nTo the NLnet foundation for initial sponsorship of this HOWTO:\nTo Eric Leblond, for boostrapping the\nNftables quick howto\nin 2013.\nRetrieved from \"\nhttp://wiki.nftables.org/wiki-nftables/index.php?title=Main_Page&oldid=1152\n\"\nNavigation menu\nSearch", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://wiki.nftables.org/wiki-nftables/index.php/Main_Page"}}
{"text": "Quick reference-nftables in 10 minutes - nftables wiki\nQuick reference-nftables in 10 minutes\nFrom nftables wiki\nJump to navigation\nJump to search\nFind below some basic concepts to know before using nftables.\ntable\nrefers to a container of\nchains\nwith no specific semantics.\nchain\nwithin a\ntable\nrefers to a container of\nrules\n.\nrule\nrefers to an action to be configured within a\nchain\n.\nContents\n1\nnft command line\n1.1\nTables\n1.2\nChains\n1.3\nRules\n1.3.1\nMatches\n1.3.1.1\nIp\n1.3.1.2\nIp6\n1.3.1.3\nTcp\n1.3.1.4\nUdp\n1.3.1.5\nUdplite\n1.3.1.6\nSctp\n1.3.1.7\nDccp\n1.3.1.8\nAh\n1.3.1.9\nEsp\n1.3.1.10\nComp\n1.3.1.11\nIcmp\n1.3.1.12\nIcmpv6\n1.3.1.13\nEther\n1.3.1.14\nDst\n1.3.1.15\nFrag\n1.3.1.16\nHbh\n1.3.1.17\nMh\n1.3.1.18\nRt\n1.3.1.19\nVlan\n1.3.1.20\nArp\n1.3.1.21\nCt\n1.3.1.22\nMeta\n1.3.2\nStatements\n1.3.2.1\nVerdict statements\n1.3.2.2\nLog\n1.3.2.3\nReject\n1.3.2.4\nCounter\n1.3.2.5\nLimit\n1.3.2.6\nNat\n1.3.2.7\nQueue\n1.4\nExtras\n1.4.1\nExport Configuration\n1.4.2\nMonitor Events\n2\nNft scripting\n2.1\nList ruleset\n2.2\nFlush ruleset\n2.3\nLoad ruleset\n3\nExamples\n3.1\nSimple IP/IPv6 Firewall\nnft command line\nnft\nis the command line tool in order to interact with nftables at userspace.\nTables\nfamily\nrefers to a one of the following table types:\nip\n,\narp\n,\nip6\n,\nbridge\n,\ninet\n,\nnetdev\n. It defaults to\nip\n.\n% nft list tables\n[\n<family>\n]\n% nft\n[\n-n\n]\n[\n-a\n]\nlist table\n[\n<family>\n]\n<name>\n% nft\n(\nadd\n|\ndelete\n|\nflush\n)\ntable\n[\n<family>\n]\n<name>\nThe argument\n-n\nshows the addresses and other information that use names in numeric format. The\n-a\nargument is used to display each rule's\nhandle\n(i.e., a numerical identifier).\nChains\ntype\nrefers to the kind of chain to be created. Possible types are:\nfilter\n: Supported by\narp\n,\nbridge\n,\nip\n,\nip6\nand\ninet\ntable families.\nroute\n: Mark packets (like mangle for the\noutput\nhook, for other hooks use the type\nfilter\ninstead), supported by\nip\nand\nip6\n.\nnat\n: In order to perform Network Address Translation, supported by\nip\nand\nip6\n.\nhook\nrefers to an specific stage of the packet while it's being processed through the kernel. More info in\nNetfilter hooks\n.\nThe hooks for\nip\n,\nip6\nand\ninet\nfamilies are:\nprerouting\n,\ninput\n,\nforward\n,\noutput\n,\npostrouting\n.\nThe hooks for\narp\nfamily are:\ninput\n,\noutput\n.\nThe\nbridge\nfamily handles ethernet packets traversing bridge devices.\nThe hooks for\nnetdev\nare:\ningress\n,\negress\n.\npriority\nrefers to a number used to order the chains or to set them between some Netfilter operations. Possible values are:\nNF_IP_PRI_CONNTRACK_DEFRAG (-400)\n,\nNF_IP_PRI_RAW (-300)\n,\nNF_IP_PRI_SELINUX_FIRST (-225)\n,\nNF_IP_PRI_CONNTRACK (-200)\n,\nNF_IP_PRI_MANGLE (-150)\n,\nNF_IP_PRI_NAT_DST (-100)\n,\nNF_IP_PRI_FILTER (0)\n,\nNF_IP_PRI_SECURITY (50)\n,\nNF_IP_PRI_NAT_SRC (100)\n,\nNF_IP_PRI_SELINUX_LAST (225)\n,\nNF_IP_PRI_CONNTRACK_HELPER (300)\n.\npolicy\nis the default verdict statement to control the flow in the base chain. Possible values are:\naccept\n(default) and\ndrop\n. Warning: Setting the policy to\ndrop\ndiscards all packets that\nhave not been accepted by the ruleset.\n% nft\n(\nadd\n|\ncreate\n)\nchain\n[\n<family>\n]\n<table> <name>\n[\n\\{\ntype\n<type> hook <hook>\n[\ndevice <device>\n]\npriority <priority>\n\\;\n[\npolicy <policy>\n\\;\n]\n\\}\n]\n% nft\n(\ndelete\n|\nlist\n|\nflush\n)\nchain\n[\n<family>\n]\n<table> <name>\n% nft rename chain\n[\n<family>\n]\n<table> <name> <newname>\nRules\nhandle\nis an internal number that identifies a certain\nrule\n.\n% nft add rule\n[\n<family>\n]\n<table> <chain> <matches> <statements>\n% nft insert rule\n[\n<family>\n]\n<table> <chain>\n[\nposition <handle>\n]\n<matches> <statements>\n% nft replace rule\n[\n<family>\n]\n<table> <chain>\n[\nhandle <handle>\n]\n<matches> <statements>\n% nft delete rule\n[\n<family>\n]\n<table> <chain>\n[\nhandle <handle>\n]\nInserted rules are placed at the beginning of the chain, by default. However, if you specify a\nposition\nhandle, then the new rule is inserted just before the existing rule with that handle.\nMatches\nmatches\nare clues used to access to certain packet information and create filters according to them.\nIp\nip match\ndscp <value>\nip dscp cs1\nip dscp !\n=\ncs1\nip dscp 0x38\nip dscp !\n=\n0x20\nip dscp\n{\ncs0, cs1, cs2, cs3, cs4, cs5, cs6, cs7, af11, af12, af13, af21,\naf22, af23, af31, af32, af33, af41, af42, af43, ef\n}\nlength <length>\nTotal packet length\nip length\n232\nip length !\n=\n233\nip length\n333\n-435\nip length !\n=\n333\n-453\nip length\n{\n333\n,\n553\n,\n673\n,\n838\n}\nid <id>\nIP ID\nip id\n22\nip id !\n=\n233\nip id\n33\n-45\nip id !\n=\n33\n-45\nip id\n{\n33\n,\n55\n,\n67\n,\n88\n}\nfrag-off <value>\nFragmentation offset\nip frag-off\n&\n0x1fff !\n=\n0\n# match fragments\nip frag-off\n&\n0x2000 !\n=\n0\n# match MF flag\nip frag-off\n&\n0x4000 !\n=\n0\n# match DF flag\nttl <ttl>\nTime to live\nip ttl\n0\nip ttl\n233\nip ttl\n33\n-55\nip ttl !\n=\n45\n-50\nip ttl\n{\n43\n,\n53\n,\n45\n}\nip ttl\n{\n33\n-55\n}\nprotocol <protocol>\nUpper layer protocol\nip protocol tcp\nip protocol\n6\nip protocol !\n=\ntcp\nip protocol\n{\nicmp, esp, ah, comp, udp, udplite, tcp, dccp, sctp\n}\nchecksum <checksum>\nIP header checksum\nip checksum\n13172\nip checksum\n22\nip checksum !\n=\n233\nip checksum\n33\n-45\nip checksum !\n=\n33\n-45\nip checksum\n{\n33\n,\n55\n,\n67\n,\n88\n}\nip checksum\n{\n33\n-55\n}\nsaddr <ip source address>\nSource address\nip saddr\n192\n.168.2.0/24\nip saddr !\n=\n192\n.168.2.0/24\nip saddr\n192\n.168.3.1 ip daddr\n192\n.168.3.100\nip saddr !\n=\n1\n.1.1.1\nip saddr\n1\n.1.1.1\nip saddr\n&\n0xff\n==\n1\nip saddr\n&\n0\n.0.0.255 <\n0\n.0.0.127\ndaddr <ip destination address>\nDestination address\nip daddr\n192\n.168.0.1\nip daddr !\n=\n192\n.168.0.1\nip daddr\n192\n.168.0.1-192.168.0.250\nip daddr\n10\n.0.0.0-10.255.255.255\nip daddr\n172\n.16.0.0-172.31.255.255\nip daddr\n192\n.168.3.1-192.168.4.250\nip daddr !\n=\n192\n.168.0.1-192.168.0.250\nip daddr\n{\n192\n.168.0.1-192.168.0.250\n}\nip daddr\n{\n192\n.168.5.1,\n192\n.168.5.2,\n192\n.168.5.3\n}\nversion <version>\nIp Header version\nip version\n4\nhdrlength <header length>\nIP header length\nip hdrlength\n0\nip hdrlength\n15\nIp6\nip6 match\ndscp <value>\nip6 dscp cs1\nip6 dscp !\n=\ncs1\nip6 dscp 0x38\nip6 dscp !\n=\n0x20\nip6 dscp\n{\ncs0, cs1, cs2, cs3, cs4, cs5, cs6, cs7, af11, af12, af13, af21, af22, af23, af31, af32, af33, af41, af42, af43, ef\n}\nflowlabel <label>\nFlow label\nip6 flowlabel\n22\nip6 flowlabel !\n=\n233\nip6 flowlabel\n{\n33\n,\n55\n,\n67\n,\n88\n}\nip6 flowlabel\n{\n33\n-55\n}\nlength <length>\nPayload length\nip6 length\n232\nip6 length !\n=\n233\nip6 length\n333\n-435\nip6 length !\n=\n333\n-453\nip6 length\n{\n333\n,\n553\n,\n673\n,\n838\n}\nnexthdr <header>\nNext header type (Upper layer protocol number)\nip6 nexthdr\n{\nesp, udp, ah, comp, udplite, tcp, dccp, sctp, icmpv6\n}\nip6 nexthdr esp\nip6 nexthdr !\n=\nesp\nip6 nexthdr\n{\n33\n-44\n}\nip6 nexthdr\n33\n-44\nip6 nexthdr !\n=\n33\n-44\nhoplimit <hoplimit>\nHop limit\nip6 hoplimit\n1\nip6 hoplimit !\n=\n233\nip6 hoplimit\n33\n-45\nip6 hoplimit !\n=\n33\n-45\nip6 hoplimit\n{\n33\n,\n55\n,\n67\n,\n88\n}\nip6 hoplimit\n{\n33\n-55\n}\nsaddr <ip source address>\nSource Address\nip6 saddr\n1234\n:1234:1234:1234:1234:1234:1234:1234\nip6 saddr ::1234:1234:1234:1234:1234:1234:1234\nip6 saddr ::/64\nip6 saddr ::1 ip6 daddr ::2\ndaddr <ip destination address>\nDestination Address\nip6 daddr\n1234\n:1234:1234:1234:1234:1234:1234:1234\nip6 daddr !\n=\n::1234:1234:1234:1234:1234:1234:1234-1234:1234::1234:1234:1234:1234:1234\nversion <version>\nIP header version\nip6 version\n6\nTcp\ntcp match\ndport <destination port>\nDestination port\ntcp dport\n22\ntcp dport !\n=\n33\n-45\ntcp dport\n{\n33\n-55\n}\ntcp dport\n{\ntelnet, http, https\n}\ntcp dport vmap\n{\n22\n: accept,\n23\n: drop\n}\ntcp dport vmap\n{\n25\n:accept,\n28\n:drop\n}\nsport < source port>\nSource port\ntcp sport\n22\ntcp sport !\n=\n33\n-45\ntcp sport\n{\n33\n,\n55\n,\n67\n,\n88\n}\ntcp sport\n{\n33\n-55\n}\ntcp sport vmap\n{\n25\n:accept,\n28\n:drop\n}\ntcp sport\n1024\ntcp dport\n22\nsequence <value>\nSequence number\ntcp sequence\n22\ntcp sequence !\n=\n33\n-45\nackseq <value>\nAcknowledgement number\ntcp ackseq\n22\ntcp ackseq !\n=\n33\n-45\ntcp ackseq\n{\n33\n,\n55\n,\n67\n,\n88\n}\ntcp ackseq\n{\n33\n-55\n}\nflags <flags>\nTCP flags\ntcp flags\n{\nfin, syn, rst, psh, ack, urg, ecn, cwr\n}\ntcp flags cwr\ntcp flags !\n=\ncwr\nwindow <value>\nWindow\ntcp window\n22\ntcp window !\n=\n33\n-45\ntcp window\n{\n33\n,\n55\n,\n67\n,\n88\n}\ntcp window\n{\n33\n-55\n}\nchecksum <checksum>\nIP header checksum\ntcp checksum\n22\ntcp checksum !\n=\n33\n-45\ntcp checksum\n{\n33\n,\n55\n,\n67\n,\n88\n}\ntcp checksum\n{\n33\n-55\n}\nurgptr <pointer>\nUrgent pointer\ntcp urgptr\n22\ntcp urgptr !\n=\n33\n-45\ntcp urgptr\n{\n33\n,\n55\n,\n67\n,\n88\n}\ndoff <offset>\nData offset\ntcp doff\n8\nUdp\nudp match\ndport <destination port>\nDestination port\nudp dport\n22\nudp dport !\n=\n33\n-45\nudp dport\n{\n33\n-55\n}\nudp dport\n{\ntelnet, http, https\n}\nudp dport vmap\n{\n22\n: accept,\n23\n: drop\n}\nudp dport vmap\n{\n25\n:accept,\n28\n:drop\n}\nsport < source port>\nSource port\nudp sport\n22\nudp sport !\n=\n33\n-45\nudp sport\n{\n33\n,\n55\n,\n67\n,\n88\n}\nudp sport\n{\n33\n-55\n}\nudp sport vmap\n{\n25\n:accept,\n28\n:drop\n}\nudp sport\n1024\nudp dport\n22\nlength <length>\nTotal packet length\nudp length\n6666\nudp length !\n=\n50\n-65\nudp length\n{\n50\n,\n65\n}\nudp length\n{\n35\n-50\n}\nchecksum <checksum>\nUDP checksum\nudp checksum\n22\nudp checksum !\n=\n33\n-45\nudp checksum\n{\n33\n,\n55\n,\n67\n,\n88\n}\nudp checksum\n{\n33\n-55\n}\nUdplite\nudplite match\ndport <destination port>\nDestination port\nudplite dport\n22\nudplite dport !\n=\n33\n-45\nudplite dport\n{\n33\n-55\n}\nudplite dport\n{\ntelnet, http, https\n}\nudplite dport vmap\n{\n22\n: accept,\n23\n: drop\n}\nudplite dport vmap\n{\n25\n:accept,\n28\n:drop\n}\nsport < source port>\nSource port\nudplite sport\n22\nudplite sport !\n=\n33\n-45\nudplite sport\n{\n33\n,\n55\n,\n67\n,\n88\n}\nudplite sport\n{\n33\n-55\n}\nudplite sport vmap\n{\n25\n:accept,\n28\n:drop\n}\nudplite sport\n1024\nudplite dport\n22\nchecksum <checksum>\nChecksum\nudplite checksum\n22\nudplite checksum !\n=\n33\n-45\nudplite checksum\n{\n33\n,\n55\n,\n67\n,\n88\n}\nudplite checksum\n{\n33\n-55\n}\nSctp\nsctp match\ndport <destination port>\nDestination port\nsctp dport\n22\nsctp dport !\n=\n33\n-45\nsctp dport\n{\n33\n-55\n}\nsctp dport\n{\ntelnet, http, https\n}\nsctp dport vmap\n{\n22\n: accept,\n23\n: drop\n}\nsctp dport vmap\n{\n25\n:accept,\n28\n:drop\n}\nsport < source port>\nSource port\nsctp sport\n22\nsctp sport !\n=\n33\n-45\nsctp sport\n{\n33\n,\n55\n,\n67\n,\n88\n}\nsctp sport\n{\n33\n-55\n}\nsctp sport vmap\n{\n25\n:accept,\n28\n:drop\n}\nsctp sport\n1024\nsctp dport\n22\nchecksum <checksum>\nChecksum\nsctp checksum\n22\nsctp checksum !\n=\n33\n-45\nsctp checksum\n{\n33\n,\n55\n,\n67\n,\n88\n}\nsctp checksum\n{\n33\n-55\n}\nvtag <tag>\nVerification tag\nsctp vtag\n22\nsctp vtag !\n=\n33\n-45\nsctp vtag\n{\n33\n,\n55\n,\n67\n,\n88\n}\nsctp vtag\n{\n33\n-55\n}\nchunk <type>\nExistence of a chunk with given type in packet\nsctp chunk init exists\nsctp chunk error missing\nchunk <type> <field>\nA chunk's field value (implies chunk existence)\n<sourcex lang=\"bash\">\nsctp chunk init flags 0x1\nsctp chunk data tsn 0x23\n</source>\nDccp\ndccp match\ndport <destination port>\nDestination port\ndccp dport\n22\ndccp dport !\n=\n33\n-45\ndccp dport\n{\n33\n-55\n}\ndccp dport\n{\ntelnet, http, https\n}\ndccp dport vmap\n{\n22\n: accept,\n23\n: drop\n}\ndccp dport vmap\n{\n25\n:accept,\n28\n:drop\n}\nsport < source port>\nSource port\ndccp sport\n22\ndccp sport !\n=\n33\n-45\ndccp sport\n{\n33\n,\n55\n,\n67\n,\n88\n}\ndccp sport\n{\n33\n-55\n}\ndccp sport vmap\n{\n25\n:accept,\n28\n:drop\n}\ndccp sport\n1024\ndccp dport\n22\ntype <type>\nType of packet\ndccp\ntype\n{\nrequest, response, data, ack, dataack, closereq, close, reset, sync, syncack\n}\ndccp\ntype\nrequest\ndccp\ntype\n!\n=\nrequest\nAh\nah match\nhdrlength <length>\nAH header length\nah hdrlength\n11\n-23\nah hdrlength !\n=\n11\n-23\nah hdrlength\n{\n11\n,\n23\n,\n44\n}\nreserved <value>\nah reserved\n22\nah reserved !\n=\n33\n-45\nah reserved\n{\n23\n,\n100\n}\nah reserved\n{\n33\n-55\n}\nspi <value>\nah spi\n111\nah spi !\n=\n111\n-222\nah spi\n{\n111\n,\n122\n}\nsequence <sequence>\nSequence Number\nah sequence\n123\nah sequence\n{\n23\n,\n25\n,\n33\n}\nah sequence !\n=\n23\n-33\nEsp\nesp match\nspi <value>\nesp spi\n111\nesp spi !\n=\n111\n-222\nesp spi\n{\n111\n,\n122\n}\nsequence <sequence>\nSequence Number\nesp sequence\n123\nesp sequence\n{\n23\n,\n25\n,\n33\n}\nesp sequence !\n=\n23\n-33\nComp\ncomp match\nnexthdr <protocol>\nNext header protocol (Upper layer protocol)\ncomp nexthdr !\n=\nesp\ncomp nexthdr\n{\nesp, ah, comp, udp, udplite, tcp, tcp, dccp, sctp\n}\nflags <flags>\nFlags\ncomp flags 0x0\ncomp flags !\n=\n0x33-0x45\ncomp flags\n{\n0x33, 0x55, 0x67, 0x88\n}\ncpi <value>\nCompression Parameter Index\ncomp cpi\n22\ncomp cpi !\n=\n33\n-45\ncomp cpi\n{\n33\n,\n55\n,\n67\n,\n88\n}\nIcmp\nicmp match\ntype <type>\nICMP packet type\nicmp\ntype\n{\necho-reply, destination-unreachable, source-quench, redirect, echo-request, time-exceeded, parameter-problem, timestamp-request, timestamp-reply, info-request, info-reply, address-mask-request, address-mask-reply, router-advertisement, router-solicitation\n}\ncode\nICMP packet code\nicmp code\n111\nicmp code !\n=\n33\n-55\nicmp code\n{\n2\n,\n4\n,\n54\n,\n33\n,\n56\n}\nchecksum <value>\nICMP packet checksum\nicmp checksum\n12343\nicmp checksum !\n=\n11\n-343\nicmp checksum\n{\n1111\n,\n222\n,\n343\n}\nid <value>\nICMP packet id\nicmp id\n12343\nicmp id !\n=\n11\n-343\nicmp id\n{\n1111\n,\n222\n,\n343\n}\nsequence <value>\nICMP packet sequence\nicmp sequence\n12343\nicmp sequence !\n=\n11\n-343\nicmp sequence\n{\n1111\n,\n222\n,\n343\n}\nmtu <value>\nICMP packet mtu\nicmp mtu\n12343\nicmp mtu !\n=\n11\n-343\nicmp mtu\n{\n1111\n,\n222\n,\n343\n}\ngateway <value>\nICMP packet gateway\nicmp gateway\n12343\nicmp gateway !\n=\n11\n-343\nicmp gateway\n{\n1111\n,\n222\n,\n343\n}\nIcmpv6\nicmpv6 match\ntype <type>\nICMPv6 packet type\nicmpv6\ntype\n{\ndestination-unreachable, packet-too-big, time-exceeded, echo-request, echo-reply, mld-listener-query, mld-listener-report, mld-listener-reduction, nd-router-solicit, nd-router-advert, nd-neighbor-solicit, nd-neighbor-advert, parameter-problem, mld2-listener-report\n}\ncode\nICMPv6 packet code\nicmpv6 code\n4\nicmpv6 code\n3\n-66\nicmpv6 code\n{\n5\n,\n6\n,\n7\n}\nchecksum <value>\nICMPv6 packet checksum\nicmpv6 checksum\n12343\nicmpv6 checksum !\n=\n11\n-343\nicmpv6 checksum\n{\n1111\n,\n222\n,\n343\n}\nid <value>\nICMPv6 packet id\nicmpv6 id\n12343\nicmpv6 id !\n=\n11\n-343\nicmpv6 id\n{\n1111\n,\n222\n,\n343\n}\nsequence <value>\nICMPv6 packet sequence\nicmpv6 sequence\n12343\nicmpv6 sequence !\n=\n11\n-343\nicmpv6 sequence\n{\n1111\n,\n222\n,\n343\n}\nmtu <value>\nICMPv6 packet mtu\nicmpv6 mtu\n12343\nicmpv6 mtu !\n=\n11\n-343\nicmpv6 mtu\n{\n1111\n,\n222\n,\n343\n}\nmax-delay <value>\nICMPv6 packet max delay\nicmpv6 max-delay\n33\n-45\nicmpv6 max-delay !\n=\n33\n-45\nicmpv6 max-delay\n{\n33\n,\n55\n,\n67\n,\n88\n}\nEther\nether match\nsaddr <mac address>\nSource mac address\nether saddr\n00\n:0f:54:0c:11:04\ntype <type>\nether\ntype\nvlan\nDst\ndst match\nnexthdr <proto>\nNext protocol header\ndst nexthdr\n{\nudplite, ipcomp, udp, ah, sctp, esp, dccp, tcp, ipv6-icmp\n}\ndst nexthdr\n22\ndst nexthdr !\n=\n33\n-45\nhdrlength <length>\nHeader Length\ndst hdrlength\n22\ndst hdrlength !\n=\n33\n-45\ndst hdrlength\n{\n33\n,\n55\n,\n67\n,\n88\n}\nFrag\nfrag match\nnexthdr <proto>\nNext protocol header\nfrag nexthdr\n{\nudplite, comp, udp, ah, sctp, esp, dccp, tcp, ipv6-icmp, icmp\n}\nfrag nexthdr\n6\nfrag nexthdr !\n=\n50\n-51\nreserved <value>\nfrag reserved\n22\nfrag reserved !\n=\n33\n-45\nfrag reserved\n{\n33\n,\n55\n,\n67\n,\n88\n}\nfrag-off <value>\nfrag frag-off\n22\nfrag frag-off !\n=\n33\n-45\nfrag frag-off\n{\n33\n,\n55\n,\n67\n,\n88\n}\nmore-fragments <value>\nfrag more-fragments\n0\nfrag more-fragments\n0\nid <value>\nfrag id\n1\nfrag id\n33\n-45\nHbh\nhbh match\nnexthdr <proto>\nNext protocol header\nhbh nexthdr\n{\nudplite, comp, udp, ah, sctp, esp, dccp, tcp, icmpv6\n}\nhbh nexthdr\n22\nhbh nexthdr !\n=\n33\n-45\nhdrlength <length>\nHeader Length\nhbh hdrlength\n22\nhbh hdrlength !\n=\n33\n-45\nhbh hdrlength\n{\n33\n,\n55\n,\n67\n,\n88\n}\nMh\nmh match\nnexthdr <proto>\nNext protocol header\nmh nexthdr\n{\nudplite, ipcomp, udp, ah, sctp, esp, dccp, tcp, ipv6-icmp\n}\nmh nexthdr\n22\nmh nexthdr !\n=\n33\n-45\nhdrlength <length>\nHeader Length\nmh hdrlength\n22\nmh hdrlength !\n=\n33\n-45\nmh hdrlength\n{\n33\n,\n55\n,\n67\n,\n88\n}\ntype <type>\nmh\ntype\n{\nbinding-refresh-request, home-test-init, careof-test-init, home-test, careof-test, binding-update, binding-acknowledgement, binding-error, fast-binding-update, fast-binding-acknowledgement, fast-binding-advertisement, experimental-mobility-header, home-agent-switch-message\n}\nmh\ntype\nhome-agent-switch-message\nmh\ntype\n!\n=\nhome-agent-switch-message\nreserved <value>\nmh reserved\n22\nmh reserved !\n=\n33\n-45\nmh reserved\n{\n33\n,\n55\n,\n67\n,\n88\n}\nchecksum <value>\nmh checksum\n22\nmh checksum !\n=\n33\n-45\nmh checksum\n{\n33\n,\n55\n,\n67\n,\n88\n}\nRt\nrt match\nnexthdr <proto>\nNext protocol header\nrt nexthdr\n{\nudplite, ipcomp, udp, ah, sctp, esp, dccp, tcp, ipv6-icmp\n}\nrt nexthdr\n22\nrt nexthdr !\n=\n33\n-45\nhdrlength <length>\nHeader Length\nrt hdrlength\n22\nrt hdrlength !\n=\n33\n-45\nrt hdrlength\n{\n33\n,\n55\n,\n67\n,\n88\n}\ntype <type>\nrt\ntype\n22\nrt\ntype\n!\n=\n33\n-45\nrt\ntype\n{\n33\n,\n55\n,\n67\n,\n88\n}\nseg-left <value>\nrt seg-left\n22\nrt seg-left !\n=\n33\n-45\nrt seg-left\n{\n33\n,\n55\n,\n67\n,\n88\n}\nVlan\nvlan match\nid <value>\nVlan tag ID\nvlan id\n4094\nvlan id\n0\ncfi <value>\nvlan cfi\n0\nvlan cfi\n1\npcp <value>\nvlan pcp\n7\nvlan pcp\n3\nArp\narp match\nptype <value>\nPayload type\narp ptype 0x0800\nhtype <value>\nHeader type\narp htype\n1\narp htype !\n=\n33\n-45\narp htype\n{\n33\n,\n55\n,\n67\n,\n88\n}\nhlen <length>\nHeader Length\narp hlen\n1\narp hlen !\n=\n33\n-45\narp hlen\n{\n33\n,\n55\n,\n67\n,\n88\n}\nplen <length>\nPayload length\narp plen\n1\narp plen !\n=\n33\n-45\narp plen\n{\n33\n,\n55\n,\n67\n,\n88\n}\noperation <value>\narp operation\n{\nnak, inreply, inrequest, rreply, rrequest, reply, request\n}\nCt\nct match\nstate <state>\nState of the connection\nct state\n{\nnew, established, related, untracked\n}\nct state !\n=\nrelated\nct state established\nct state\n8\ndirection <value>\nDirection of the packet relative to the connection\nct direction original\nct direction !\n=\noriginal\nct direction\n{\nreply, original\n}\nstatus <status>\nStatus of the connection\nct status expected\n(\nct status\n&\nexpected\n)\n!\n=\nexpected\nct status\n{\nexpected, seen-reply, assured, confirmed, snat, dnat, dying\n}\nmark [set]\nMark of the connection\nct mark\n0\nct mark or\n0x23\n==\n0x11\nct mark or 0x3 !\n=\n0x1\nct mark and\n0x23\n==\n0x11\nct mark and 0x3 !\n=\n0x1\nct mark xor\n0x23\n==\n0x11\nct mark xor 0x3 !\n=\n0x1\nct mark 0x00000032\nct mark !\n=\n0x00000032\nct mark 0x00000032-0x00000045\nct mark !\n=\n0x00000032-0x00000045\nct mark\n{\n0x32, 0x2222, 0x42de3\n}\nct mark\n{\n0x32-0x2222, 0x4444-0x42de3\n}\nct mark\nset\n0x11 xor 0x1331\nct mark\nset\n0x11333 and 0x11\nct mark\nset\n0x12 or 0x11\nct mark\nset\n0x11\nct mark\nset\nmark\nct mark\nset\nmark map\n{\n1\n:\n10\n,\n2\n:\n20\n,\n3\n:\n30\n}\nexpiration\nConnection expiration time\nct expiration\n30\nct expiration 30s\nct expiration !\n=\n233\nct expiration !\n=\n3m53s\nct expiration\n33\n-45\nct expiration 33s-45s\nct expiration !\n=\n33\n-45\nct expiration !\n=\n33s-45s\nct expiration\n{\n33\n,\n55\n,\n67\n,\n88\n}\nct expiration\n{\n1m7s, 33s, 55s, 1m28s\n}\nhelper \"<helper>\"\nHelper associated with the connection\nct helper\n\"ftp\"\n[original | reply] bytes <value>\nct original bytes >\n100000\nct bytes >\n100000\n[original | reply] packets <value>\nct reply packets <\n100\n[original | reply] ip saddr <ip source address>\nct original ip saddr\n192\n.168.0.1\nct reply ip saddr\n192\n.168.0.1\nct original ip saddr\n192\n.168.1.0/24\nct reply ip saddr\n192\n.168.1.0/24\n[original | reply] ip daddr <ip destination address>\nct original ip daddr\n192\n.168.0.1\nct reply ip daddr\n192\n.168.0.1\nct original ip daddr\n192\n.168.1.0/24\nct reply ip daddr\n192\n.168.1.0/24\n[original | reply] l3proto <protocol>\nct original l3proto ipv4\n[original | reply] protocol <protocol>\nct original protocol\n6\n[original | reply] proto-dst <port>\nct original proto-dst\n22\n[original | reply] proto-src <port>\nct reply proto-src\n53\ncount [over] <number of connections>\nct count over\n2\ntcp dport\n22\nadd @ssh_flood\n{\nip saddr ct count over\n2\n}\nreject\n[\nwhich requires an existing ssh_flood set, ie. add\nset\nfilter ssh_flood\n{\ntype\nipv4_addr\n;\nflags dynamic\n;\n}\n]\nMeta\nmeta\nmatches packet by metainformation.\nmeta match\niifname <input interface name>\nInput interface name\nmeta iifname\n\"eth0\"\nmeta iifname !\n=\n\"eth0\"\nmeta iifname\n{\n\"eth0\"\n,\n\"lo\"\n}\nmeta iifname\n\"eth*\"\noifname <output interface name>\nOutput interface name\nmeta oifname\n\"eth0\"\nmeta oifname !\n=\n\"eth0\"\nmeta oifname\n{\n\"eth0\"\n,\n\"lo\"\n}\nmeta oifname\n\"eth*\"\niif <input interface index>\nInput interface index\nmeta iif eth0\nmeta iif !\n=\neth0\noif <output interface index>\nOutput interface index\nmeta oif lo\nmeta oif !\n=\nlo\nmeta oif\n{\neth0, lo\n}\niiftype <input interface type>\nInput interface type\nmeta iiftype\n{\nether, ppp, ipip, ipip6, loopback, sit, ipgre\n}\nmeta iiftype !\n=\nether\nmeta iiftype ether\noiftype <output interface type>\nOutput interface hardware type\nmeta oiftype\n{\nether, ppp, ipip, ipip6, loopback, sit, ipgre\n}\nmeta oiftype !\n=\nether\nmeta oiftype ether\nlength <length>\nLength of the packet in bytes\nmeta length\n1000\nmeta length !\n=\n1000\nmeta length >\n1000\nmeta length\n33\n-45\nmeta length !\n=\n33\n-45\nmeta length\n{\n33\n,\n55\n,\n67\n,\n88\n}\nmeta length\n{\n33\n-55,\n67\n-88\n}\nprotocol <protocol>\nethertype protocol\nmeta protocol ip\nmeta protocol !\n=\nip\nmeta protocol\n{\nip, arp, ip6, vlan\n}\nnfproto <protocol>\nmeta nfproto ipv4\nmeta nfproto !\n=\nipv6\nmeta nfproto\n{\nipv4, ipv6\n}\nl4proto <protocol>\nmeta l4proto\n22\nmeta l4proto !\n=\n233\nmeta l4proto\n33\n-45\nmeta l4proto\n{\n33\n,\n55\n,\n67\n,\n88\n}\nmeta l4proto\n{\n33\n-55\n}\nmark [set]\nPacket mark\nmeta mark 0x4\nmeta mark 0x00000032\nmeta mark and\n0x03\n==\n0x01\nmeta mark and 0x03 !\n=\n0x01\nmeta mark !\n=\n0x10\nmeta mark or\n0x03\n==\n0x01\nmeta mark or 0x03 !\n=\n0x01\nmeta mark xor\n0x03\n==\n0x01\nmeta mark xor 0x03 !\n=\n0x01\nmeta mark\nset\n0xffffffc8 xor 0x16\nmeta mark\nset\n0x16 and 0x16\nmeta mark\nset\n0xffffffe9 or 0x16\nmeta mark\nset\n0xffffffde and 0x16\nmeta mark\nset\n0x32 or 0xfffff\nmeta mark\nset\n0xfffe xor 0x16\npriority [set] <priority>\ntc class id\nmeta priority none\nmeta priority 0x1:0x1\nmeta priority 0x1:0xffff\nmeta priority 0xffff:0xffff\nmeta priority\nset\n0x1:0x1\nmeta priority\nset\n0x1:0xffff\nmeta priority\nset\n0xffff:0xffff\nskuid <user id>\nUID associated with originating socket\nmeta skuid\n{\nbin, root, daemon\n}\nmeta skuid root\nmeta skuid !\n=\nroot\nmeta skuid lt\n3000\nmeta skuid gt\n3000\nmeta skuid eq\n3000\nmeta skuid\n3001\n-3005\nmeta skuid !\n=\n2001\n-2005\nmeta skuid\n{\n2001\n-2005\n}\nskgid <group id>\nGID associated with originating socket\nmeta skgid\n{\nbin, root, daemon\n}\nmeta skgid root\nmeta skgid !\n=\nroot\nmeta skgid lt\n3000\nmeta skgid gt\n3000\nmeta skgid eq\n3000\nmeta skgid\n3001\n-3005\nmeta skgid !\n=\n2001\n-2005\nmeta skgid\n{\n2001\n-2005\n}\nrtclassid <class>\nRouting realm\nmeta rtclassid cosmos\npkttype <type>\nPacket type\nmeta pkttype broadcast\nmeta pkttype !\n=\nbroadcast\nmeta pkttype\n{\nbroadcast, unicast, multicast\n}\ncpu <cpu index>\nCPU ID\nmeta cpu\n1\nmeta cpu !\n=\n1\nmeta cpu\n1\n-3\nmeta cpu !\n=\n1\n-2\nmeta cpu\n{\n2\n,3\n}\nmeta cpu\n{\n2\n-3,\n5\n-7\n}\niifgroup <input group>\nInput interface group\nmeta iifgroup\n0\nmeta iifgroup !\n=\n0\nmeta iifgroup default\nmeta iifgroup !\n=\ndefault\nmeta iifgroup\n{\ndefault\n}\nmeta iifgroup\n{\n11\n,33\n}\nmeta iifgroup\n{\n11\n-33\n}\noifgroup <group>\nOutput interface group\nmeta oifgroup\n0\nmeta oifgroup !\n=\n0\nmeta oifgroup default\nmeta oifgroup !\n=\ndefault\nmeta oifgroup\n{\ndefault\n}\nmeta oifgroup\n{\n11\n,33\n}\nmeta oifgroup\n{\n11\n-33\n}\ncgroup <group>\nmeta cgroup\n1048577\nmeta cgroup !\n=\n1048577\nmeta cgroup\n{\n1048577\n,\n1048578\n}\nmeta cgroup\n1048577\n-1048578\nmeta cgroup !\n=\n1048577\n-1048578\nmeta cgroup\n{\n1048577\n-1048578\n}\nStatements\nstatement\nis the action performed when the packet match the rule. It could be\nterminal\nand\nnon-terminal\n. In a certain rule we can consider several non-terminal statements but only a single terminal statement.\nVerdict statements\nThe\nverdict statement\nalters control flow in the ruleset and issues policy decisions for packets. The valid verdict statements are:\naccept\n: Accept the packet and stop the remain rules evaluation.\ndrop\n: Drop the packet and stop the remain rules evaluation.\nqueue\n: Queue the packet to userspace and stop the remain rules evaluation.\ncontinue\n: Continue the ruleset evaluation with the next rule.\nreturn\n: Return from the current chain and continue at the next rule of the last chain. In a base chain it is equivalent to accept\njump <chain>\n: Continue at the first rule of <chain>. It will continue at the next rule after a return statement is issued\ngoto <chain>\n: Similar to jump, but after the new chain the evaluation will continue at the last chain instead of the one containing the goto statement\nLog\nlog statement\nlevel [over] <value> <unit> [burst <value> <unit>]\nLog level\nlog\nlog level emerg\nlog level alert\nlog level crit\nlog level err\nlog level warn\nlog level notice\nlog level info\nlog level debug\ngroup <value> [queue-threshold <value>] [snaplen <value>] [prefix \"<prefix>\"]\nlog prefix aaaaa-aaaaaa group\n2\nsnaplen\n33\nlog group\n2\nqueue-threshold\n2\nlog group\n2\nsnaplen\n33\nReject\nThe default\nreject\nwill be the ICMP type\nport-unreachable\n. The\nicmpx\nis only used for inet family support.\nMore information on the\nRejecting_traffic\npage.\nreject statement\nwith <protocol> type <type>\nreject\nreject with icmp\ntype\nhost-unreachable\nreject with icmp\ntype\nnet-unreachable\nreject with icmp\ntype\nprot-unreachable\nreject with icmp\ntype\nport-unreachable\nreject with icmp\ntype\nnet-prohibited\nreject with icmp\ntype\nhost-prohibited\nreject with icmp\ntype\nadmin-prohibited\nreject with icmpv6\ntype\nno-route\nreject with icmpv6\ntype\nadmin-prohibited\nreject with icmpv6\ntype\naddr-unreachable\nreject with icmpv6\ntype\nport-unreachable\nreject with icmpx\ntype\nhost-unreachable\nreject with icmpx\ntype\nno-route\nreject with icmpx\ntype\nadmin-prohibited\nreject with icmpx\ntype\nport-unreachable\nip protocol tcp reject with tcp reset\nCounter\ncounter statement\npackets <packets> bytes <bytes>\ncounter\ncounter packets\n0\nbytes\n0\nLimit\nlimit statement\nrate [over] <value> <unit> [burst <value> <unit>]\nRate limit\nlimit rate\n400\n/minute\nlimit rate\n400\n/hour\nlimit rate over\n40\n/day\nlimit rate over\n400\n/week\nlimit rate over\n1023\n/second burst\n10\npackets\nlimit rate\n1025\nkbytes/second\nlimit rate\n1023000\nmbytes/second\nlimit rate\n1025\nbytes/second burst\n512\nbytes\nlimit rate\n1025\nkbytes/second burst\n1023\nkbytes\nlimit rate\n1025\nmbytes/second burst\n1025\nkbytes\nlimit rate\n1025000\nmbytes/second burst\n1023\nmbytes\nNat\nnat statement\ndnat to <destination address>\nDestination address translation\ndnat to\n192\n.168.3.2\ndnat to ct mark map\n{\n0x00000014 :\n1\n.2.3.4\n}\nsnat to <ip source address>\nSource address translation\nsnat to\n192\n.168.3.2\nsnat to\n2001\n:838:35f:1::-2001:838:35f:2:::100\nmasquerade [<type>] [to :<port>]\nMasquerade\nmasquerade\nmasquerade persistent,fully-random,random\nmasquerade to :1024\nmasquerade to :1024-2048\nQueue\nqueue statement\nnum <value> <scheduler>\nqueue\nqueue num\n2\nqueue num\n2\n-3\nqueue num\n4\n-5 fanout bypass\nqueue num\n4\n-5 fanout\nqueue num\n4\n-5 bypass\nExtras\nExport Configuration\n% nft\nexport\n(\nxml\n|\njson\n)\nMonitor Events\nMonitor events from Netlink creating filters.\n% nft monitor\n[\nnew\n|\ndestroy\n]\n[\ntables\n|\nchains\n|\nsets\n|\nrules\n|\nelements\n]\n[\nxml\n|\njson\n]\nNft scripting\nList ruleset\n% nft list ruleset\nFlush ruleset\n% nft flush ruleset\nLoad ruleset\nCreate a command batch file and load it with the nft interpreter,\n%\necho\n\"flush ruleset\"\n> /etc/nftables.rules\n%\necho\n\"add table filter\"\n>> /etc/nftables.rules\n%\necho\n\"add chain filter input\"\n>> /etc/nftables.rules\n%\necho\n\"add rule filter input meta iifname lo accept\"\n>> /etc/nftables.rules\n% nft -f /etc/nftables.rules\nor create an executable nft script file,\n% cat\n<< EOF > /etc/nftables.rules\n> #!/usr/local/sbin/nft -f\n> flush ruleset\n> add table filter\n> add chain filter input\n> add rule filter input meta iifname lo accept\n> EOF\n% chmod u+x /etc/nftables.rules\n% /etc/nftables.rules\nor create an executable nft script file from an already created ruleset,\n% nft list ruleset > /etc/nftables.rules\n% nft flush ruleset\n% nft -f /etc/nftables.rules\nExamples\nSimple IP/IPv6 Firewall\nflush ruleset\ntable firewall\n{\nchain incoming\n{\ntype\nfilter hook input priority\n0\n;\npolicy drop\n;\n# established/related connections\nct state established,related accept\n# loopback interface\niifname lo accept\n# icmp\nicmp\ntype\necho-request accept\n# open tcp ports: sshd (22), httpd (80)\ntcp dport\n{\nssh, http\n}\naccept\n}\n}\ntable ip6 firewall\n{\nchain incoming\n{\ntype\nfilter hook input priority\n0\n;\npolicy drop\n;\n# established/related connections\nct state established,related accept\n# invalid connections\nct state invalid drop\n# loopback interface\niifname lo accept\n# icmp\n# routers may also want: mld-listener-query, nd-router-solicit\nicmpv6\ntype\n{\necho-request, nd-neighbor-solicit\n}\naccept\n# open tcp ports: sshd (22), httpd (80)\ntcp dport\n{\nssh, http\n}\naccept\n}\n}\nRetrieved from \"\nhttp://wiki.nftables.org/wiki-nftables/index.php?title=Quick_reference-nftables_in_10_minutes&oldid=1132\n\"\nCategory\n:\nPages using deprecated source tags\nNavigation menu\nSearch", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://wiki.nftables.org/wiki-nftables/index.php/Quick_reference-nftables_in_10_minutes"}}
