{"text": "What is Podman? — Podman  documentation\nWhat is Podman?\n¶\nPodman\nis a daemonless, open source, Linux native tool designed to make it easy to find, run, build, share and deploy applications using Open Containers Initiative (\nOCI\n)\nContainers\nand\nContainer Images\n. Podman provides a command line interface (CLI) familiar to anyone who has used the Docker\nContainer Engine\n. Most users can simply alias Docker to Podman (\nalias docker=podman\n) without any problems. Similar to other common\nContainer Engines\n(Docker, CRI-O, containerd), Podman relies on an OCI compliant\nContainer Runtime\n(runc, crun, runv, etc) to interface with the operating system and create the running containers. This makes the running containers created by Podman nearly indistinguishable from those created by any other common container engine.\nContainers under the control of Podman can either be run by root or by a non-privileged user. Podman manages the entire container ecosystem which includes pods, containers, container images, and container volumes using the\nlibpod\nlibrary. Podman specializes in all of the commands and functions that help you to maintain and modify OCI container images, such as pulling and tagging. It allows you to create, run, and maintain those containers and container images in a production environment.\nThere is a RESTFul API to manage containers.  We also have a remote Podman client that can interact with\nthe RESTFul service.  We currently support clients on Linux, Mac, and Windows.  The RESTFul service is only\nsupported on Linux.\nIf you are completely new to containers, we recommend that you check out the\nIntroduction\n. For power users or those coming from Docker, check out our\nTutorials\n. For advanced users and contributors, you can get very detailed information about the Podman CLI by looking at our\nCommands\npage. Finally, for Developers looking at how to interact with the Podman API, please see our API documentation\nReference\n.\nContents:\nIntroduction\nCommands\nReference\nTutorials\nSearch\nPodman Python\nPodman\nNavigation\nContents:\nIntroduction\nCommands\nReference\nTutorials\nSearch\nPodman Python\nRelated Topics\nDocumentation overview\nNext:\nIntroduction\n©2019, team.\n|\nPowered by\nSphinx 8.2.3\n&\nAlabaster 1.0.0\n|\nPage source", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://docs.podman.io/en/latest/"}}
{"text": "Introduction — Podman  documentation\nIntroduction\n¶\nContainers\nsimplify the production, distribution, discoverability, and usage of applications with all of their dependencies and default configuration files. Users test drive or deploy a new application with one or two commands instead of following pages of installation instructions. Here’s how to find your first\nContainer Image\n:\npodman\nsearch\ndocker.io/busybox\nOutput:\nNAME\nDESCRIPTION\ndocker.io/library/busybox\nBusybox\nbase\nimage.\ndocker.io/rancher/busybox\ndocker.io/openebs/busybox-client\ndocker.io/antrea/busybox\ndocker.io/hugegraph/busybox\ntest\nimage\n...\nThe previous command returned a list of publicly available container images on DockerHub. These container images are easy to consume, but of differing levels of quality and maintenance. Let’s use the first one listed because it seems to be well maintained.\nTo run the busybox container image, it’s just a single command:\npodman\nrun\n-it\ndocker.io/library/busybox\nOutput:\n/\n#\nYou can poke around in the busybox container for a while, but you’ll quickly find that running small container with a few Linux utilities in it provides limited value, so exit out:\nexit\nThere’s an old saying that “nobody runs an operating system just to run an operating system” and the same is true with containers. It’s the workload running on top of an operating system or in a container that’s interesting and valuable.\nSometimes we can find a publicly available container image for the exact workload we’re looking for and it will already be packaged exactly how we want. But, more often than not, there’s something that we want to add, remove, or customize. It can be as simple as a configuration setting for security or performance, or as complex as adding a complex workload. Either way, containers make it fairly easy to make the changes we need.\nContainer Images aren’t actually images. They are repositories often made up of multiple layers. These layers can easily be added, saved, and shared with others by using a\nContainerfile\n(Dockerfile). This single file often contains all the instructions needed to build a new container image and can easily be shared with others publicly using tools like GitHub.\nHere’s an example of how to build a container image from content that resides in a git repository:\npodman\nbuild\n-t\nhello\nhttps://github.com/containers/PodmanHello.git\nOnce, the image build completes, it’s easy to run the new image from our local cache:\npodman\nrun\n-it\nhello\nOutput:\n!...\nHello\nPodman\nWorld\n...!\n.--\n\"--.\n/ -     - \\\n/ (O)   (O) \\\n~~~| -=(,Y,)=- |\n.---. /`  \\   |~~\n~/  o  o \\~~~~.----. ~~\n| =(X)= |~  / (O (O) \\\n~~~~~~~  ~| =(Y_)=-  |\n~~~~    ~~~|   U      |~~\nProject:   https://github.com/containers/podman\nWebsite:   https://podman.io\nDesktop:   https://podman-desktop.io\nDocuments: https://docs.podman.io\nYouTube:   https://youtube.com/@Podman\nX/Twitter: @Podman_io\nMastodon:  @Podman_io@fosstodon.org\nBuilding new images is great, but sharing our work with others lets them review our work, critique how we built them, and offer improved versions. Our newly built\nhello\nimage can be published at quay.io or docker.io to share it with the world. Everything needed to run the\nhello\napplication is provided in the container image. Others can easily pull it down and use it, or make improvements to it.\nStandardizing on container images and\nContainer Registries\nenable a new level of collaboration through simple consumption. This simple consumption model is possible because every major Container Engine and Registry Server uses the Open Containers Initiative (\nOCI\n) format. This allows users to find, run, build, share and deploy containers anywhere they want. Podman and other\nContainer Engines\nlike CRI-O, Docker, or containerd can create and consume container images from docker.io, quay.io, an on premise registry or even one provided by a cloud provider. The OCI image format facilitates this ecosystem through a single standard.\nFor example, if we wanted to share our newly built\nhello\ncontainer image on quay.io it’s easy. First log in to quay:\npodman\nlogin\nquay.io\nInput:\nUsername:\nUSERNAME\nPassword:\n********\nLogin\nSucceeded!\nNext, tag the image so that we can push it into our user account:\npodman\ntag\nlocalhost/hello\nquay.io/USERNAME/hello\nFinally, push the image:\npodman\npush\nquay.io/USERNAME/hello\nOutput:\nGetting\nimage\nsource\nsignatures\nCopying\nblob\nbf62b9b17289\ndone\n|\nCopying\nconfig\n17a4bf5a30\ndone\n|\nWriting\nmanifest\nto\nimage\ndestination\nNotice that we pushed one layer to our registry and now it’s available for others to share. Take a quick look:\npodman\ninspect\nquay.io/USERNAME/hello\nOutput:\n[\n{\n\"Id\"\n:\n\"17a4bf5a301a374771ac66dd09c33d1d765af5265d20d6b4da7ac578381efd87\"\n,\n\"Digest\"\n:\n\"sha256:ee693991b0c8c8c12dfe0e90c25db1b73867e672478fd7a187a2fae31f72531a\"\n,\n\"RepoTags\"\n:\n[\n\"quay.io/USERNAME/hello:latest\"\n,\n...\nTo summarize, Podman makes it easy to find, run, build and share containers.\nFind: whether finding a container on dockerhub.io or quay.io, an internal registry server, or directly from a vendor, a couple of\npodman search\n, and\npodman pull\ncommands make it easy\nRun: it’s easy to consume pre-built images with everything needed to run an entire application, or start from a Linux distribution base image with the\npodman run\ncommand\nBuild: creating new layers with small tweaks, or major overhauls is easy with\npodman build\nShare: Podman lets you push your newly built containers anywhere you want with a single\npodman push\ncommand\nFor more instructions on use cases, take a look at our\nTutorials\npage.\nPodman\nNavigation\nContents:\nIntroduction\nCommands\nReference\nTutorials\nSearch\nPodman Python\nRelated Topics\nDocumentation overview\nPrevious:\nWhat is Podman?\nNext:\nCommands\n©2019, team.\n|\nPowered by\nSphinx 8.2.3\n&\nAlabaster 1.0.0\n|\nPage source", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://docs.podman.io/en/latest/Introduction.html"}}
{"text": "Commands — Podman  documentation\nCommands\n¶\nPodman\n(Pod Manager) Global Options, Environment Variables, Exit Codes, Configuration Files, and more\nartifact\nManage OCI artifacts\nattach\nAttach to a running container\nauto-update\nAuto update containers according to their auto-update policy\nbuild\nBuild an image using instructions from Containerfiles\ncommit\nCreate new image based on the changed container\ncontainer\nManage containers\ncp\nCopy files/folders between a container and the local filesystem\ncreate\nCreate but do not start a container\ndiff\nDisplay the changes to the object’s file system\nevents\nShow podman system events\nexec\nRun a process in a running container\nexport\nExport container’s filesystem contents as a tar archive\nfarm\nFarm out builds to remote machines\ngenerate\nGenerate structured data based on containers, pods or volumes\nhealthcheck\nManage health checks on containers\nhistory\nShow history of a specified image\nimage\nManage images\nimages\nList images in local storage\nimport\nImport a tarball to create a filesystem image\ninfo\nDisplay podman system information\ninit\nInitialize one or more containers\ninspect\nDisplay the configuration of object denoted by ID\nkill\nKill one or more running containers with a specific signal\nkube\nPlay containers, pods or volumes from a structured file\nload\nLoad image(s) from a tar archive\nlogin\nLog in to a container registry\nlogout\nLog out of a container registry\nlogs\nFetch the logs of one or more containers\nmachine\nManage a virtual machine\nmanifest\nManipulate manifest lists and image indexes\nmount\nMount a working container’s root filesystem\nnetwork\nManage networks\npause\nPause all the processes in one or more containers\npod\nManage pods\nport\nList port mappings or a specific mapping for the container\nps\nList containers\npull\nPull an image from a registry\npush\nPush an image to a specified destination\nquadlet\nAllows users to manage Quadlets\nrename\nRename an existing container\nrestart\nRestart one or more containers\nrm\nRemove one or more containers\nrmi\nRemove one or more images from local storage\nrun\nRun a command in a new container\nsave\nSave image(s) to an archive\nsearch\nSearch registry for image\nsecret\nManage secrets\nstart\nStart one or more containers\nstats\nDisplay a live stream of container resource usage statistics\nstop\nStop one or more containers\nsystem\nManage podman\ntag\nAdd an additional name to a local image\ntop\nDisplay the running processes of a container\nunmount\nUnmount working container’s root filesystem\nunpause\nUnpause the processes in one or more containers\nunshare\nRun a command in a modified user namespace\nuntag\nRemove a name from a local image\nupdate\nUpdate an existing container\nversion\nDisplay the Podman version information\nvolume\nManage volumes\nwait\nBlock on one or more containers\nPodman\nNavigation\nContents:\nIntroduction\nCommands\nReference\nTutorials\nSearch\nPodman Python\nRelated Topics\nDocumentation overview\nPrevious:\nIntroduction\nNext:\nReference\n©2019, team.\n|\nPowered by\nSphinx 8.2.3\n&\nAlabaster 1.0.0\n|\nPage source", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://docs.podman.io/en/latest/Commands.html"}}
{"text": "podman — Podman  documentation\nNAME\n¶\npodman - Simple management tool for pods, containers and images\nSYNOPSIS\n¶\npodman\n[\noptions\n]\ncommand\nDESCRIPTION\n¶\nPodman (Pod Manager) is a fully featured container engine that is a simple daemonless tool.\nPodman provides a Docker-CLI comparable command line that eases the transition from other\ncontainer engines and allows the management of pods, containers and images.  Simply put:\nalias\ndocker=podman\n.\nMost Podman commands can be run as a regular user, without requiring additional\nprivileges.\nPodman uses Buildah(1) internally to create container images. Both tools share image\n(not container) storage, hence each can use or manipulate images (but not containers)\ncreated by the other.\nDefault settings for flags are defined in\ncontainers.conf\n. Most settings for\nRemote connections use the server’s containers.conf, except when documented in\nman pages.\nTo manage containers, pods, volumes, networks, and images declaratively via systemd,\nuse quadlet files. See\npodman-quadlet\n(1) and\npodman-systemd.unit\n(5).\npodman [GLOBAL OPTIONS]\nGLOBAL OPTIONS\n¶\n--cdi-spec-dir\n=\npath\n¶\nThe CDI spec directory path (may be set multiple times). Default path is\n/etc/cdi\n.\n--cgroup-manager\n=\nmanager\n¶\nThe CGroup manager to use for container cgroups. Supported values are\ncgroupfs\nor\nsystemd\n. Default is\nsystemd\nunless overridden in the containers.conf file.\nNote: Setting this flag can cause certain commands to break when called on containers previously created by the other CGroup manager type.\n--config\n¶\nLocation of config file. Mainly for docker compatibility, only the authentication parts of the config are supported.\n--conmon\n¶\nPath of the conmon binary (Default path is configured in\ncontainers.conf\n)\n--connection\n,\n-c\n¶\nConnection to use for remote podman, including Mac and Windows (excluding WSL2) machines, (Default connection is configured in\ncontainers.conf\n)\nSetting this option switches the\n--remote\noption to true.\nRemote connections use local containers.conf for default.\n--events-backend\n=\ntype\n¶\nBackend to use for storing events. Allowed values are\nfile\n,\njournald\n, and\nnone\n. When\nfile\nis specified, the events are stored under\n<tmpdir>/events/events.log\n(see\n--tmpdir\nbelow).\n--help\n,\n-h\n¶\nPrint usage statement\n--hooks-dir\n=\npath\n¶\nEach\n*.json\nfile in the path configures a hook for Podman containers.  For more details on the syntax of the JSON files and the semantics of hook injection, see\noci-hooks(5)\n.  Podman and libpod currently support both the 1.0.0 and 0.1.0 hook schemas, although the 0.1.0 schema is deprecated.\nThis option may be set multiple times; paths from later options have higher precedence (\noci-hooks(5)\ndiscusses directory precedence).\nFor the annotation conditions, libpod uses any annotations set in the generated OCI configuration.\nFor the bind-mount conditions, only mounts explicitly requested by the caller via\n--volume\nare considered.  Bind mounts that libpod inserts by default (e.g.\n/dev/shm\n) are not considered.\nIf\n--hooks-dir\nis unset for root callers, Podman and libpod currently default to\n/usr/share/containers/oci/hooks.d\nand\n/etc/containers/oci/hooks.d\nin order of increasing precedence.  Using these defaults is deprecated. Migrate to explicitly setting\n--hooks-dir\n.\nPodman and libpod currently support an additional\nprecreate\nstate which is called before the runtime’s\ncreate\noperation.  Unlike the other stages, which receive the container state on their standard input,\nprecreate\nhooks receive the proposed runtime configuration on their standard input.  They may alter that configuration as they see fit, and write the altered form to their standard output.\nWARNING\n: the\nprecreate\nhook allows powerful changes to occur, such as adding additional mounts to the runtime configuration.  That power also makes it easy to break things.  Before reporting libpod errors, try running a container with\nprecreate\nhooks disabled to see if the problem is due to one of the hooks.\n--identity\n=\npath\n¶\nPath to ssh identity file. If the identity file has been encrypted, podman prompts the user for the passphrase.\nIf no identity file is provided and no user is given, podman defaults to the user running the podman command.\nPodman prompts for the login password on the remote server.\nIdentity value resolution precedence:\ncommand line value\nenvironment variable\nCONTAINER_SSHKEY\n, if\nCONTAINER_HOST\nis found\ncontainers.conf\nRemote connections use local containers.conf for default.\n--imagestore\n=\npath\n¶\nPath of the imagestore where images are stored.  By default, the storage library stores all the images in the graphroot but if an imagestore is provided, then the storage library will store newly pulled images in the provided imagestore and keep using the graphroot for everything else. If the user is using the overlay driver, then the images which were already part of the graphroot will still be accessible.\nThis will override\nimagestore\noption in\ncontainers-storage.conf(5)\n, refer to\ncontainers-storage.conf(5)\nfor more details.\n--log-level\n=\nlevel\n¶\nLog messages at and above specified level:\ndebug\n,\ninfo\n,\nwarn\n,\nerror\n,\nfatal\nor\npanic\n(default:\nwarn\n)\n--module\n=\npath\n¶\nLoad the specified\ncontainers.conf(5)\nmodule.  Can be an absolute or relative path.  Please refer to\ncontainers.conf(5)\nfor details.\nThis flag is not supported on the remote client, including Mac and Windows (excluding WSL2) machines.\nFurther note that the flag is a root-level flag and must be specified before any Podman sub-command.\n--network-cmd-path\n=\npath\n¶\nPath to the\nslirp4netns(1)\ncommand binary to use for setting up a slirp4netns network.\nIf “” is used, then the binary will first be searched using the\nhelper_binaries_dir\noption in\ncontainers.conf\n, and second using the\n$PATH\nenvironment variable.\nNote:\nThis option is deprecated and will be removed with Podman 6.0. Use the\nhelper_binaries_dir\noption in\ncontainers.conf\ninstead.\n--network-config-dir\n=\ndirectory\n¶\nPath to the directory where network configuration files are located.\nFor the netavark backend “/etc/containers/networks” is used as root\nand “$graphroot/networks” as rootless.\nFor the CNI backend the default is “/etc/cni/net.d” as root\nand “$HOME/.config/cni/net.d” as rootless.\nCNI is deprecated and will be removed in the next major Podman version 5.0 in preference of Netavark.\n--out\n=\npath\n¶\nRedirect the output of podman to the specified path without affecting the container output or its logs. This parameter can be used to capture the output from any of podman’s commands directly into a file and enable suppression of podman’s output by specifying /dev/null as the path. To explicitly disable the container logging, the\n--log-driver\noption should be used.\n--remote\n,\n-r\n¶\nWhen true, access to the Podman service is remote. Defaults to false.\nSettings can be modified in the containers.conf file. If the CONTAINER_HOST\nenvironment variable is set, the\n--remote\noption defaults to true.\n--root\n=\nvalue\n¶\nStorage root dir in which data, including images, is stored (default: “/var/lib/containers/storage” for UID 0, “$HOME/.local/share/containers/storage” for other users).\nDefault root dir configured in\ncontainers-storage.conf(5)\n.\nOverriding this option causes the\nstorage-opt\nsettings in\ncontainers-storage.conf(5)\nto be ignored.  The user must specify additional options via the\n--storage-opt\nflag.\n--runroot\n=\nvalue\n¶\nStorage state directory where all state information is stored (default: “/run/containers/storage” for UID 0, “/run/user/$UID/run” for other users).\nDefault state dir configured in\ncontainers-storage.conf(5)\n.\n--runtime\n=\nvalue\n¶\nName of the OCI runtime as specified in containers.conf or absolute path to the OCI compatible binary used to run containers.\n--runtime-flag\n=\nflag\n¶\nAdds global flags for the container runtime. To list the supported flags, please\nconsult the manpages of the selected container runtime (\nrunc\nis the default\nruntime, the manpage to consult is\nrunc(8)\n.  When the machine is configured\nfor cgroup V2, the default runtime is\ncrun\n, the manpage to consult is\ncrun(8)\n.).\nDefault runtime flags can be added in containers.conf.\nNote: Do not pass the leading\n--\nto the flag. To pass the runc flag\n--log-format\njson\nto podman build, the option given can be\n--runtime-flag\nlog-format=json\n.\n--ssh\n=\nvalue\n¶\nThis option allows the user to change the ssh mode, meaning that rather than using the default\ngolang\nmode, one can instead use\n--ssh=native\nto use the installed ssh binary and config file declared in containers.conf.\n--storage-driver\n=\nvalue\n¶\nStorage driver.  The default storage driver is configured in\ncontainers-storage.conf(5)\n. The\nSTORAGE_DRIVER\nenvironment variable overrides the default. The --storage-driver specified driver overrides all.\nOverriding this option causes the\nstorage-opt\nsettings in\ncontainers-storage.conf(5)\nto be ignored.  The user must\nspecify additional options via the\n--storage-opt\nflag.\n--storage-opt\n=\nvalue\n¶\nSpecify a storage driver option. Default storage driver options are configured in\ncontainers-storage.conf(5)\n. The\nSTORAGE_OPTS\nenvironment variable overrides the default. The --storage-opt specified options override all. Specify --storage-opt=”” so no storage options is used.\n--syslog\n¶\nOutput logging information to syslog as well as the console (default\nfalse\n).\nOn remote clients, including Mac and Windows (excluding WSL2) machines, logging is directed to the file $HOME/.config/containers/podman.log.\n--tls-ca\n=\npath\n¶\nPath to a PEM file containing the certificate authority bundle to verify the server’s certificate against.\n--tls-cert\n=\npath\n¶\nPath to a PEM file containing the TLS client certificate to present to the server.\n--tls-key\nmust also be provided.\n--tls-key\n=\npath\n¶\nPath to a PEM file containing the private key matching\n--tls-cert\n.\n--tls-cert\nmust also be provided.\n--tmpdir\n=\npath\n¶\nPath to the tmp directory, for libpod runtime content. Defaults to\n$XDG_RUNTIME_DIR/libpod/tmp\nas rootless and\n/run/libpod/tmp\nas rootful.\nNOTE --tmpdir is not used for the temporary storage of downloaded images.  Use the environment variable\nTMPDIR\nto change the temporary storage location of downloaded container images. Podman defaults to use\n/var/tmp\n.\n--transient-store\n¶\nEnables a global transient storage mode where all container metadata is stored on non-persistent media (i.e. in the location specified by\n--runroot\n).\nThis mode allows starting containers faster, as well as guaranteeing a fresh state on boot in case of unclean shutdowns or other problems. However\nit is not compatible with a traditional model where containers persist across reboots.\nDefault value for this is configured in\ncontainers-storage.conf(5)\n.\n--url\n=\nvalue\n¶\nURL to access Podman service (default from\ncontainers.conf\n, rootless\nunix:///run/user/$UID/podman/podman.sock\nor as root\nunix:///run/podman/podman.sock\n).\nSetting this option switches the\n--remote\noption to true.\nCONTAINER_HOST\nis of the format\n<schema>://[<user[:<password>]@]<host>[:<port>][<path>]\nDetails:\nschema\nis one of:\nssh\n(default): a local unix(7) socket on the named\nhost\nand\nport\n, reachable via SSH\ntcp\n: an unencrypted, unauthenticated TCP connection to the named\nhost\nand\nport\nunix\n: a local unix(7) socket at the specified\npath\n, or the default for the user\nuser\ndefaults to either\nroot\nor the current running user (\nssh\nonly)\npassword\nhas no default (\nssh\nonly)\nhost\nmust be provided and is either the IP or name of the machine hosting the Podman service (\nssh\nand\ntcp\n)\nport\ndefaults to 22 (\nssh\nand\ntcp\n)\npath\ndefaults to either\n/run/podman/podman.sock\n, or\n/run/user/$UID/podman/podman.sock\nif running rootless (\nunix\n), or must be explicitly specified (\nssh\n)\nURL value resolution precedence:\ncommand line value\nenvironment variable\nCONTAINER_HOST\nengine.service_destinations\ntable in containers.conf, excluding the /usr/share/containers directory\nunix:///run/podman/podman.sock\nRemote connections use local containers.conf for default.\nSome example URL values in valid formats:\nunix:///run/podman/podman.sock\nunix:///run/user/$UID/podman/podman.sock\nssh://notroot@localhost:22/run/user/$UID/podman/podman.sock\nssh://root@localhost:22/run/podman/podman.sock\ntcp://localhost:34451\ntcp://127.0.0.1:34451\n--version\n,\n-v\n¶\nPrint the version\n--volumepath\n=\nvalue\n¶\nVolume directory where builtin volume information is stored (default: “/var/lib/containers/storage/volumes” for UID 0, “$HOME/.local/share/containers/storage/volumes” for other users). Default volume path can be overridden in\ncontainers.conf\n.\nEnvironment Variables\n¶\nPodman can set up environment variables from env of [engine] table in containers.conf. These variables can be overridden by passing  environment variables before the\npodman\ncommands.\nCONTAINERS_CONF\n¶\nSet default locations of containers.conf file\nCONTAINERS_REGISTRIES_CONF\n¶\nSet default location of the registries.conf file.\nCONTAINERS_STORAGE_CONF\n¶\nSet default location of the storage.conf file.\nCONTAINER_CONNECTION\n¶\nOverride default\n--connection\nvalue to access Podman service. Automatically enables the --remote option.\nCONTAINER_HOST\n¶\nSet default\n--url\nvalue to access Podman service. Automatically enables --remote option.\nCONTAINER_SSHKEY\n¶\nSet default\n--identity\npath to ssh key file value used to access Podman service.\nPODMAN_CONNECTIONS_CONF\n¶\nThe path to the file where the system connections and farms created with\npodman\nsystem\nconnection\nadd\nand\npodman\nfarm\nadd\nare stored, by default it uses\n~/.config/containers/podman-connections.json\n.\nSTORAGE_DRIVER\n¶\nSet default\n--storage-driver\nvalue.\nSTORAGE_OPTS\n¶\nSet default\n--storage-opt\nvalue.\nTMPDIR\n¶\nSet the temporary storage location of downloaded container images. Podman defaults to use\n/var/tmp\n.\nXDG_CONFIG_HOME\n¶\nIn Rootless mode configuration files are read from\nXDG_CONFIG_HOME\nwhen\nspecified, otherwise in the home directory of the user under\n$HOME/.config/containers\n.\nXDG_DATA_HOME\n¶\nIn Rootless mode images are pulled under\nXDG_DATA_HOME\nwhen specified,\notherwise in the home directory of the user under\n$HOME/.local/share/containers/storage\n.\nXDG_RUNTIME_DIR\n¶\nIn Rootless mode temporary configuration data is stored in\n${XDG_RUNTIME_DIR}/containers\n.\nRemote Access\n¶\nThe Podman command can be used with remote services using the\n--remote\nflag. Connections can\nbe made using local unix domain sockets, ssh or directly to tcp sockets. When specifying the\npodman --remote flag, only the global options\n--url\n,\n--identity\n,\n--log-level\n,\n--connection\nare used.\nConnection information can also be managed using the containers.conf file.\nExit Codes\n¶\nThe exit code from\npodman\ngives information about why the container\nfailed to run or why it exited.  When\npodman\ncommands exit with a non-zero code,\nthe exit codes follow the\nchroot\nstandard, see below:\n125\nThe error is with podman\nitself\n$ podman run --foo busybox; echo $?\nError: unknown flag: --foo\n125\n126\nExecuting a\ncontainer command\nand the\ncommand\ncannot be invoked\n$ podman run busybox /etc; echo $?\nError: container_linux.go:346: starting container process caused \"exec: \\\"/etc\\\": permission denied\": OCI runtime error\n126\n127\nExecuting a\ncontainer command\nand the\ncommand\ncannot be found\n$ podman run busybox foo; echo $?\nError: container_linux.go:346: starting container process caused \"exec: \\\"foo\\\": executable file not found in $PATH\": OCI runtime error\n127\nExit code\notherwise,\npodman\nreturns the exit code of the\ncontainer command\n$ podman run busybox /bin/sh -c 'exit 3'; echo $?\n3\nCOMMANDS\n¶\nCommand\nDescription\npodman-artifact(1)\nManage OCI artifacts.\npodman-attach(1)\nAttach to a running container.\npodman-auto-update(1)\nAuto update containers according to their auto-update policy\npodman-build(1)\nBuild a container image using a Containerfile.\npodman-farm(1)\nFarm out builds to machines running podman for different architectures\npodman-commit(1)\nCreate new image based on the changed container.\npodman-completion(1)\nGenerate shell completion scripts\npodman-compose(1)\nRun Compose workloads via an external compose provider.\npodman-container(1)\nManage containers.\npodman-cp(1)\nCopy files/folders between a container and the local filesystem.\npodman-create(1)\nCreate a new container.\npodman-diff(1)\nInspect changes on a container or image’s filesystem.\npodman-events(1)\nMonitor Podman events\npodman-exec(1)\nExecute a command in a running container.\npodman-export(1)\nExport a container’s filesystem contents as a tar archive.\npodman-generate(1)\nGenerate structured data based on containers, pods or volumes.\npodman-healthcheck(1)\nManage healthchecks for containers\npodman-history(1)\nShow the history of an image.\npodman-image(1)\nManage images.\npodman-images(1)\nList images in local storage.\npodman-import(1)\nImport a tarball and save it as a filesystem image.\npodman-info(1)\nDisplay Podman related system information.\npodman-init(1)\nInitialize one or more containers\npodman-inspect(1)\nDisplay artifact, container, image, volume, network, or pod’s configuration.\npodman-kill(1)\nKill the main process in one or more containers.\npodman-load(1)\nLoad image(s) from a tar archive into container storage.\npodman-login(1)\nLog in to a container registry.\npodman-logout(1)\nLog out of a container registry.\npodman-logs(1)\nDisplay the logs of one or more containers.\npodman-machine(1)\nManage Podman’s virtual machine\npodman-manifest(1)\nCreate and manipulate manifest lists and image indexes.\npodman-mount(1)\nMount a working container’s root filesystem.\npodman-network(1)\nManage Podman networks.\npodman-pause(1)\nPause one or more containers.\npodman-kube(1)\nPlay containers, pods or volumes based on a structured input file.\npodman-pod(1)\nManagement tool for groups of containers, called pods.\npodman-port(1)\nList port mappings for a container.\npodman-ps(1)\nPrint out information about containers.\npodman-pull(1)\nPull an image from a registry.\npodman-push(1)\nPush an image, manifest list or image index from local storage to elsewhere.\npodman-quadlet(1)\nAllows users to manage Quadlets.\npodman-rename(1)\nRename an existing container.\npodman-restart(1)\nRestart one or more containers.\npodman-rm(1)\nRemove one or more containers.\npodman-rmi(1)\nRemove one or more locally stored images.\npodman-run(1)\nRun a command in a new container.\npodman-save(1)\nSave image(s) to an archive.\npodman-search(1)\nSearch a registry for an image.\npodman-secret(1)\nManage podman secrets.\npodman-start(1)\nStart one or more containers.\npodman-stats(1)\nDisplay a live stream of one or more container’s resource usage statistics.\npodman-stop(1)\nStop one or more running containers.\npodman-system(1)\nManage podman.\npodman-tag(1)\nAdd an additional name to a local image.\npodman-top(1)\nDisplay the running processes of a container.\npodman-unmount(1)\nUnmount a working container’s root filesystem.\npodman-unpause(1)\nUnpause one or more containers.\npodman-unshare(1)\nRun a command inside of a modified user namespace.\npodman-untag(1)\nRemove one or more names from a locally-stored image.\npodman-update(1)\nUpdate the configuration of a given container.\npodman-version(1)\nDisplay the Podman version information.\npodman-volume(1)\nSimple management tool for volumes.\npodman-wait(1)\nWait on one or more containers to stop and print their exit codes.\nCONFIGURATION FILES\n¶\ncontainers.conf\n(\n/usr/share/containers/containers.conf\n,\n/etc/containers/containers.conf\n,\n$HOME/.config/containers/containers.conf\n)\nPodman has builtin defaults for command line options. These defaults can be overridden using the containers.conf configuration files.\nDistributions ship the\n/usr/share/containers/containers.conf\nfile with their default settings. Administrators can override fields in this file by creating the\n/etc/containers/containers.conf\nfile.  Users can further modify defaults by creating the\n$HOME/.config/containers/containers.conf\nfile. Podman merges its builtin defaults with the specified fields from these files, if they exist. Fields specified in the users file override the administrator’s file, which overrides the distribution’s file, which override the built-in defaults.\nPodman uses builtin defaults if no containers.conf file is found.\nIf the\nCONTAINERS_CONF\nenvironment variable is set, then its value is used for the containers.conf file rather than the default.\nmounts.conf\n(\n/usr/share/containers/mounts.conf\n)\nThe mounts.conf file specifies volume mount directories that are automatically mounted inside containers when executing the\npodman\nrun\nor\npodman\nstart\ncommands. Administrators can override the defaults file by creating\n/etc/containers/mounts.conf\n.\nWhen Podman runs in rootless mode, the file\n$HOME/.config/containers/mounts.conf\noverrides the default if it exists. For details, see containers-mounts.conf(5).\npolicy.json\n(\n/etc/containers/policy.json\n,\n$HOME/.config/containers/policy.json\n)\nSignature verification policy files are used to specify policy, e.g. trusted keys, applicable when deciding whether to accept an image, or individual signatures of that image, as valid. For details, see containers-policy.json(5).\nregistries.conf\n(\n/etc/containers/registries.conf\n,\n$HOME/.config/containers/registries.conf\n)\nregistries.conf is the configuration file which specifies which container registries is consulted when completing image names which do not include a registry or domain portion.\nNon root users of Podman can create the\n$HOME/.config/containers/registries.conf\nfile to be used instead of the system defaults.\nIf the\nCONTAINERS_REGISTRIES_CONF\nenvironment variable is set, then its value is used for the registries.conf file rather than the default.\nstorage.conf\n(\n/etc/containers/storage.conf\n,\n$HOME/.config/containers/storage.conf\n)\nstorage.conf is the storage configuration file for all tools using containers/storage\nThe storage configuration file specifies all of the available container storage options for tools using shared container storage.\nWhen Podman runs in rootless mode, the file\n$HOME/.config/containers/storage.conf\nis used instead of the system defaults.\nIf the\nCONTAINERS_STORAGE_CONF\nenvironment variable is set, then its value is used for the storage.conf file rather than the default.\nRootless mode\n¶\nPodman can also be used as non-root user. When podman runs in rootless mode, a user namespace is automatically created for the user, defined in\n/etc/subuid\nand\n/etc/subgid\n.\nContainers created by a non-root user are not visible to other users and are not seen or managed by Podman running as root.\nIt is required to have multiple UIDS/GIDS set for a user.  Be sure the user is present in the files\n/etc/subuid\nand\n/etc/subgid\n.\nExecute the following commands to add the ranges to the files\n$ sudo usermod --add-subuids 10000-75535 USERNAME\n$ sudo usermod --add-subgids 10000-75535 USERNAME\nOr just add the content manually.\n$ echo USERNAME:10000:65536 >> /etc/subuid\n$ echo USERNAME:10000:65536 >> /etc/subgid\nSee the\nsubuid(5)\nand\nsubgid(5)\nman pages for more information.\nNote: whitespace in any row of\n/etc/subuid\nor\n/etc/subgid\n, including trailing blanks, may result in no entry failures.\nImages are pulled under\nXDG_DATA_HOME\nwhen specified, otherwise in the home directory of the user under\n.local/share/containers/storage\n.\nCurrently slirp4netns or pasta is required to be installed to create a network\ndevice, otherwise rootless containers need to run in the network namespace of\nthe host.\nIn certain environments like HPC (High Performance Computing), users cannot take advantage of the additional UIDs and GIDs from the\n/etc/subuid\nand\n/etc/subgid\nsystems.  However, in this environment, rootless Podman can operate with a single UID.  To make this work, set the\nignore_chown_errors\noption in the\ncontainers-storage.conf(5)\nfile. This option tells Podman when pulling an image to ignore chown errors when attempting to change a file in a container image to match the non-root UID in the image. This means all files get saved as the user’s UID. Note this can cause issues when running the container.\nNOTE:\nUnsupported file systems in rootless mode\n¶\nThe Overlay file system (OverlayFS) is not supported with kernels prior to 5.12.9 in rootless mode.  The fuse-overlayfs package is a tool that provides the functionality of OverlayFS in user namespace that allows mounting file systems in rootless environments.  It is recommended to install the fuse-overlayfs package.  In rootless mode, Podman automatically uses the fuse-overlayfs program as the mount_program if installed, as long as the\n$HOME/.config/containers/storage.conf\nfile was not previously created.  If storage.conf exists in the homedir, add\nmount_program\n=\n\"/usr/bin/fuse-overlayfs\"\nunder\n[storage.options.overlay]\nto enable this feature.\nThe Network File System (NFS) and other distributed file systems (for example: Lustre, Spectrum Scale, the General Parallel File System (GPFS)) are not supported when running in rootless mode as these file systems do not understand user namespace.  However, rootless Podman can make use of an NFS Homedir by modifying the\n$HOME/.config/containers/storage.conf\nto have the\ngraphroot\noption point to a directory stored on local (Non NFS) storage.\nSEE ALSO\n¶\ncontainers-mounts.conf(5)\n,\ncontainers.conf(5)\n,\ncontainers-registries.conf(5)\n,\ncontainers-storage.conf(5)\n,\nbuildah(1)\n,\noci-hooks(5)\n,\ncontainers-policy.json(5)\n,\ncrun(1)\n,\nrunc(8)\n,\nsubuid(5)\n,\nsubgid(5)\n,\nslirp4netns(1)\n,\npasta(1)\n,\nconmon(8)\n,\npodman-quadlet(1)\n,\npodman-systemd.unit(5)\nTroubleshooting\n¶\nSee\npodman-troubleshooting(7)\nfor solutions to common issues.\nSee\npodman-rootless(7)\nfor rootless issues.\nHISTORY\n¶\nDec 2016, Originally compiled by Dan Walsh\ndwalsh\n@\nredhat\n.\ncom\nPodman\nNavigation\nContents:\nIntroduction\nCommands\nReference\nTutorials\nSearch\nPodman Python\nRelated Topics\nDocumentation overview\n©2019, team.\n|\nPowered by\nSphinx 8.2.3\n&\nAlabaster 1.0.0\n|\nPage source", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://docs.podman.io/en/latest/markdown/podman.1.html"}}
{"text": "podman-run — Podman  documentation\nNAME\n¶\npodman-run - Run a command in a new container\nSYNOPSIS\n¶\npodman run\n[\noptions\n]\nimage\n[\ncommand\n[\narg\n…]]\npodman container run\n[\noptions\n]\nimage\n[\ncommand\n[\narg\n…]]\nDESCRIPTION\n¶\nRun a process in a new container.\npodman run\nstarts a process with its own\nfile system, its own networking, and its own isolated process tree. The\nimage\nwhich starts the process may define defaults related to the process that will be\nrun in the container, the networking to expose, and more, but\npodman run\ngives final control to the operator or administrator who starts the container\nfrom the image. For that reason\npodman run\nhas more options than any other\nPodman command.\nIf the\nimage\nis not already loaded then\npodman run\nwill pull the\nimage\n, and\nall image dependencies, from the repository in the same way running\npodman\npull\nimage\n, before it starts the container from that image.\nSeveral files will be automatically created within the container. These include\n/etc/hosts\n,\n/etc/hostname\n, and\n/etc/resolv.conf\nto manage networking.\nThese will be based on the host’s version of the files, though they can be\ncustomized with options (for example,\n--dns\nmay override the host’s DNS\nservers in the created\nresolv.conf\n). Additionally, a container environment\nfile is created in each container to indicate to programs they are running in a\ncontainer. This file is located at\n/run/.containerenv\n(or\n/var/run/.containerenv\nfor FreeBSD containers). When using the\n--privileged flag the .containerenv contains name/value pairs indicating the\ncontainer engine version, whether the engine is running in rootless mode, the\ncontainer name and ID, as well as the image name and ID that the container is based on. Note:\n/run/.containerenv\nwill not be created when a volume is mounted on /run.\nWhen running from a user defined network namespace, the\n/etc/netns/NSNAME/resolv.conf\nwill be used if it exists, otherwise\n/etc/resolv.conf\nwill be used.\nDefault settings are defined in\ncontainers.conf\n. Most settings for remote\nconnections use the servers containers.conf, except when documented in man\npages.\nIMAGE\n¶\nThe image is specified using transport:path format. If no transport is specified, the\ndocker\n(container registry)\ntransport is used by default. For remote Podman, including Mac and Windows (excluding WSL2) machines,\ndocker\nis the only allowed transport.\ndir:\npath\nAn existing local directory\npath\nstoring the manifest, layer tarballs and signatures as individual files. This\nis a non-standardized format, primarily useful for debugging or noninvasive container inspection.\n$ podman save --format docker-dir fedora -o /tmp/fedora\n$ podman run dir:/tmp/fedora echo hello\ndocker://\ndocker-reference\n(Default)\nAn image reference stored in a remote container image registry. Example: “quay.io/podman/stable:latest”.\nThe reference can include a path to a specific registry; if it does not, the\nregistries listed in registries.conf are queried to find a matching image.\nBy default, credentials from\npodman\nlogin\n(stored at\n$XDG_RUNTIME_DIR/containers/auth.json by default) are used to authenticate;\notherwise it falls back to using credentials in $HOME/.docker/config.json.\n$ podman run registry.fedoraproject.org/fedora:latest echo hello\ndocker-archive:\npath\n[\n:\ndocker-reference\n]\nAn image stored in the\ndocker\nsave\nformatted file.\ndocker-reference\nis only used when creating such a\nfile, and it must not contain a digest.\n$ podman save --format docker-archive fedora -o /tmp/fedora\n$ podman run docker-archive:/tmp/fedora echo hello\nNote: On remote clients, including Mac and Windows (excluding WSL2) machines, this transport is not supported.\ndocker-daemon:\ndocker-reference\nAn image in\ndocker-reference\nformat stored in the docker daemon internal storage. The\ndocker-reference\ncan also be an image ID (docker-daemon:algo:digest).\n$ sudo docker pull fedora\n$ sudo podman run docker-daemon:docker.io/library/fedora echo hello\nNote: On remote clients, including Mac and Windows (excluding WSL2) machines, this transport is not supported.\noci-archive:\npath\n:\ntag\nAn image in a directory compliant with the “Open Container Image Layout Specification” at the specified\npath\nand specified with a\ntag\n.\n$ podman save --format oci-archive fedora -o /tmp/fedora\n$ podman run oci-archive:/tmp/fedora echo hello\nNote: On remote clients, including Mac and Windows (excluding WSL2) machines, this transport is not supported.\nOPTIONS\n¶\n--add-host\n=\nhostname[;hostname[;…]]\n:\nip\n¶\nAdd a custom host-to-IP mapping to the container’s\n/etc/hosts\nfile.\nThe option takes one or multiple semicolon-separated hostnames to be mapped to\na single IPv4 or IPv6 address, separated by a colon. It can also be used to\noverwrite the IP addresses of hostnames Podman adds to\n/etc/hosts\nby default\n(also see the\n--name\nand\n--hostname\noptions). This option can be\nspecified multiple times to add additional mappings to\n/etc/hosts\n. It\nconflicts with the\n--no-hosts\noption and conflicts with\nno_hosts=true\nin\ncontainers.conf\n.\nInstead of an IP address, the special flag\nhost-gateway\ncan be given. This\nresolves to an IP address the container can use to connect to the host. The\nIP address chosen depends on your network setup, thus there’s no guarantee that\nPodman can determine the\nhost-gateway\naddress automatically, which will then\ncause Podman to fail with an error message. You can overwrite this IP address\nusing the\nhost_containers_internal_ip\noption in\ncontainers.conf\n.\nThe\nhost-gateway\naddress is also used by Podman to automatically add the\nhost.containers.internal\nand\nhost.docker.internal\nhostnames to\n/etc/hosts\n.\nYou can prevent that by either giving the\n--no-hosts\noption, or by setting\nhost_containers_internal_ip=”none”\nin\ncontainers.conf\n. If no\nhost-gateway\naddress was configured manually and Podman fails to determine the IP address\nautomatically, Podman will silently skip adding these internal hostnames to\n/etc/hosts\n. If Podman is running in a virtual machine using\npodman\nmachine\n(this includes Mac and Windows hosts), Podman will silently skip adding the\ninternal hostnames to\n/etc/hosts\n, unless an IP address was configured\nmanually; the internal hostnames are resolved by the gvproxy DNS resolver\ninstead.\nPodman will use the\n/etc/hosts\nfile of the host as a basis by default, i.e.\nany hostname present in this file will also be present in the\n/etc/hosts\nfile\nof the container. A different base file can be configured using the\nbase_hosts_file\nconfig in\ncontainers.conf\n.\n--annotation\n=\nkey=value\n¶\nAdd an annotation to the container. This option can be set multiple times.\n--arch\n=\nARCH\n¶\nOverride the architecture, defaults to hosts, of the image to be pulled. For example,\narm\n.\nUnless overridden, subsequent lookups of the same image in the local storage matches this architecture, regardless of the host.\n--attach\n,\n-a\n=\nstdin\n|\nstdout\n|\nstderr\n¶\nAttach to STDIN, STDOUT or STDERR.\nIn foreground mode (the default when\n-d\nis not specified),\npodman run\ncan start the process in the container\nand attach the console to the process’s standard input, output, and\nerror. It can even pretend to be a TTY (this is what most command-line\nexecutables expect) and pass along signals. The\n-a\noption can be set for\neach of\nstdin\n,\nstdout\n, and\nstderr\n.\n--authfile\n=\npath\n¶\nPath of the authentication file. Default is\n${XDG_RUNTIME_DIR}/containers/auth.json\non Linux, and\n$HOME/.config/containers/auth.json\non Windows/macOS.\nThe file is created by\npodman login\n. If the authorization state is not found there,\n$HOME/.docker/config.json\nis checked, which is set using\ndocker login\n.\nNote: There is also the option to override the default path of the authentication file by setting the\nREGISTRY_AUTH_FILE\nenvironment variable. This can be done with\nexport REGISTRY_AUTH_FILE=\npath\n.\n--blkio-weight\n=\nweight\n¶\nBlock IO relative weight. The\nweight\nis a value between\n10\nand\n1000\n.\nThis option is not supported on cgroups V1 rootless systems.\n--blkio-weight-device\n=\ndevice:weight\n¶\nBlock IO relative device weight.\n--cap-add\n=\ncapability\n¶\nAdd Linux capabilities.\nGranting additional capabilities increases the privileges of the\nprocesses running inside the container and potentially allow it to\nbreak out of confinement.  Capabilities like\nCAP_SYS_ADMIN\n,\nCAP_SYS_PTRACE\n,\nCAP_MKNOD\nand\nCAP_SYS_MODULE\nare particularly\ndangerous when they are not used within a user namespace.  Please\nrefer to\nuser_namespaces(7)\nfor a more detailed explanation of the\ninteraction between user namespaces and capabilities.\nBefore adding any capability, review its security implications and\nensure it is really necessary for the container’s functionality.  See\ncapabilities(7)\nfor more information.\n--cap-drop\n=\ncapability\n¶\nDrop Linux capabilities.\n--cert-dir\n=\npath\n¶\nUse certificates at\npath\n(*.crt, *.cert, *.key) to connect to the registry. (Default: /etc/containers/certs.d)\nFor details, see\ncontainers-certs.d(5)\n.\n(This option is not available with the remote Podman client, including Mac and Windows (excluding WSL2) machines)\n--cgroup-conf\n=\nKEY=VALUE\n¶\nWhen running on cgroup v2, specify the cgroup file to write to and its value. For example\n--cgroup-conf=memory.high=1073741824\nsets the memory.high limit to 1GB.\n--cgroup-parent\n=\npath\n¶\nPath to cgroups under which the cgroup for the container is created. If the\npath is not absolute, the path is considered to be relative to the cgroups path\nof the init process. Cgroups are created if they do not already exist.\n--cgroupns\n=\nmode\n¶\nSet the cgroup namespace mode for the container.\nhost\n: use the host’s cgroup namespace inside the container.\ncontainer:\nid\n: join the namespace of the specified container.\nprivate\n: create a new cgroup namespace.\nns:\npath\n: join the namespace at the specified path.\nIf the host uses cgroups v1, the default is set to\nhost\n. On cgroups v2, the default is\nprivate\n.\n--cgroups\n=\nhow\n¶\nDetermines whether the container creates cgroups.\nDefault is\nenabled\n.\nThe\nenabled\noption creates a new cgroup under the cgroup-parent.\nThe\ndisabled\noption forces the container to not create cgroups, and thus conflicts with cgroup options (\n--cgroupns\nand\n--cgroup-parent\n).\nThe\nno-conmon\noption disables a new cgroup only for the\nconmon\nprocess.\nThe\nsplit\noption splits the current cgroup in two sub-cgroups: one for conmon and one for the container payload. It is not possible to set\n--cgroup-parent\nwith\nsplit\n.\n--chrootdirs\n=\npath\n¶\nPath to a directory inside the container that is treated as a\nchroot\ndirectory.\nAny Podman managed file (e.g., /etc/resolv.conf, /etc/hosts, /etc/hostname) that is mounted into the root directory is mounted into that location as well.\nMultiple directories are separated with a comma.\n--cidfile\n=\nfile\n¶\nWrite the container ID to\nfile\n.  The file is removed along with the container, except\nwhen used with podman --remote run on detached containers.\n--conmon-pidfile\n=\nfile\n¶\nWrite the pid of the\nconmon\nprocess to a file. As\nconmon\nruns in a separate process than Podman, this is necessary when using systemd to restart Podman containers.\n(This option is not available with the remote Podman client, including Mac and Windows (excluding WSL2) machines)\n--cpu-period\n=\nlimit\n¶\nSet the CPU period for the Completely Fair Scheduler (CFS), which is a\nduration in microseconds. Once the container’s CPU quota is used up, it will not\nbe scheduled to run until the current period ends. Defaults to 100000\nmicroseconds.\nOn some systems, changing the resource limits may not be allowed for non-root\nusers. For more details, see\nhttps://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-resource-limits-fails-with-a-permissions-error\nThis option is not supported on cgroups V1 rootless systems.\n--cpu-quota\n=\nlimit\n¶\nLimit the CPU Completely Fair Scheduler (CFS) quota.\nLimit the container’s CPU usage. By default, containers run with the full\nCPU resource. The limit is a number in microseconds. If a number is provided,\nthe container is allowed to use that much CPU time until the CPU period\nends (controllable via\n--cpu-period\n).\nOn some systems, changing the resource limits may not be allowed for non-root\nusers. For more details, see\nhttps://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-resource-limits-fails-with-a-permissions-error\nThis option is not supported on cgroups V1 rootless systems.\n--cpu-rt-period\n=\nmicroseconds\n¶\nLimit the CPU real-time period in microseconds.\nLimit the container’s Real Time CPU usage. This option tells the kernel to restrict the container’s Real Time CPU usage to the period specified.\nThis option is only supported on cgroups V1 rootful systems.\n--cpu-rt-runtime\n=\nmicroseconds\n¶\nLimit the CPU real-time runtime in microseconds.\nLimit the containers Real Time CPU usage. This option tells the kernel to limit the amount of time in a given CPU period Real Time tasks may consume. Ex:\nPeriod of 1,000,000us and Runtime of 950,000us means that this container can consume 95% of available CPU and leave the remaining 5% to normal priority tasks.\nThe sum of all runtimes across containers cannot exceed the amount allotted to the parent cgroup.\nThis option is only supported on cgroups V1 rootful systems.\n--cpu-shares\n,\n-c\n=\nshares\n¶\nCPU shares (relative weight).\nBy default, all containers get the same proportion of CPU cycles. This\nproportion can be modified by changing the container’s CPU share weighting\nrelative to the combined weight of all the running containers.\nDefault weight is\n1024\n.\nThe proportion only applies when CPU-intensive processes are running.\nWhen tasks in one container are idle, other containers can use the\nleft-over CPU time. The actual amount of CPU time varies depending on\nthe number of containers running on the system.\nFor example, consider three containers, one has a cpu-share of 1024 and\ntwo others have a cpu-share setting of 512. When processes in all three\ncontainers attempt to use 100% of CPU, the first container receives\n50% of the total CPU time. If a fourth container is added with a cpu-share\nof 1024, the first container only gets 33% of the CPU. The remaining containers\nreceive 16.5%, 16.5% and 33% of the CPU.\nOn a multi-core system, the shares of CPU time are distributed over all CPU\ncores. Even if a container is limited to less than 100% of CPU time, it can\nuse 100% of each individual CPU core.\nFor example, consider a system with more than three cores.\nIf the container\nC0\nis started with\n--cpu-shares=512\nrunning one process,\nand another container\nC1\nwith\n--cpu-shares=1024\nrunning two processes,\nthis can result in the following division of CPU shares:\nPID\ncontainer\nCPU\nCPU share\n100\nC0\n0\n100% of CPU0\n101\nC1\n1\n100% of CPU1\n102\nC1\n2\n100% of CPU2\nOn some systems, changing the resource limits may not be allowed for non-root\nusers. For more details, see\nhttps://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-resource-limits-fails-with-a-permissions-error\nThis option is not supported on cgroups V1 rootless systems.\n--cpus\n=\nnumber\n¶\nNumber of CPUs. The default is\n0.0\nwhich means no limit. This is shorthand\nfor\n--cpu-period\nand\n--cpu-quota\n, therefore the option cannot be specified with\n--cpu-period\nor\n--cpu-quota\n.\nOn some systems, changing the CPU limits may not be allowed for non-root\nusers. For more details, see\nhttps://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-resource-limits-fails-with-a-permissions-error\nThis option is not supported on cgroups V1 rootless systems.\n--cpuset-cpus\n=\nnumber\n¶\nCPUs in which to allow execution. Can be specified as a comma-separated list\n(e.g.\n0,1\n), as a range (e.g.\n0-3\n), or any combination thereof\n(e.g.\n0-3,7,11-15\n).\nOn some systems, changing the resource limits may not be allowed for non-root\nusers. For more details, see\nhttps://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-resource-limits-fails-with-a-permissions-error\nThis option is not supported on cgroups V1 rootless systems.\n--cpuset-mems\n=\nnodes\n¶\nMemory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on\nNUMA systems.\nIf there are four memory nodes on the system (0-3), use\n--cpuset-mems=0,1\nthen processes in the container only uses memory from the first\ntwo memory nodes.\nOn some systems, changing the resource limits may not be allowed for non-root\nusers. For more details, see\nhttps://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-resource-limits-fails-with-a-permissions-error\nThis option is not supported on cgroups V1 rootless systems.\n--creds\n=\n[username[:password]]\n¶\nThe [username[:password]] to use to authenticate with the registry, if required.\nIf one or both values are not supplied, a command line prompt appears and the\nvalue can be entered. The password is entered without echo.\nNote that the specified credentials are only used to authenticate against\ntarget registries.  They are not used for mirrors or when the registry gets\nrewritten (see\ncontainers-registries.conf(5)\n); to authenticate against those\nconsider using a\ncontainers-auth.json(5)\nfile.\n--decryption-key\n=\nkey[:passphrase]\n¶\nThe [key[:passphrase]] to be used for decryption of images. Key can point to keys and/or certificates. Decryption is tried with all keys. If the key is protected by a passphrase, it is required to be passed in the argument and omitted otherwise.\n--detach\n,\n-d\n¶\nDetached mode: run the container in the background and print the new container ID. The default is\nfalse\n.\nAt any time run\npodman ps\nin\nthe other shell to view a list of the running containers. Reattach to a\ndetached container with\npodman attach\ncommand.\nWhen attached via tty mode, detach from the container (and leave it\nrunning) using a configurable key sequence. The default sequence is\nctrl-p,ctrl-q\n.\nSpecify the key sequence using the\n--detach-keys\noption, or configure\nit in the\ncontainers.conf\nfile: see\ncontainers.conf(5)\nfor more information.\n--detach-keys\n=\nsequence\n¶\nSpecify the key sequence for detaching a container. Format is a single character\n[a-Z]\nor one or more\nctrl-<value>\ncharacters where\n<value>\nis one of:\na-z\n,\n@\n,\n^\n,\n[\n,\n,\nor\n_\n. Specifying “” disables this feature. The default is\nctrl-p,ctrl-q\n.\nThis option can also be set in\ncontainers.conf\n(5) file.\n--device\n=\nhost-device[:container-device][:permissions]\n¶\nAdd a host device to the container. Optional\npermissions\nparameter\ncan be used to specify device permissions by combining\nr\nfor read,\nw\nfor write, and\nm\nfor\nmknod\n(2).\nExample:\n--device=/dev/sdc:/dev/xvdc:rwm\n.\nNote: if\nhost-device\nis a symbolic link then it is resolved first.\nThe container only stores the major and minor numbers of the host device.\nPodman may load kernel modules required for using the specified\ndevice. The devices that Podman loads modules for when necessary are:\n/dev/fuse.\nIn rootless mode, the new device is bind mounted in the container from the host\nrather than Podman creating it within the container space. Because the bind\nmount retains its SELinux label on SELinux systems, the container can get\npermission denied when accessing the mounted device. Modify SELinux settings to\nallow containers to use all device labels via the following command:\n$ sudo setsebool -P  container_use_devices=true\nNote: if the user only has access rights via a group, accessing the device\nfrom inside a rootless container fails. Use the\n--group-add\nkeep-groups\nflag to pass the user’s supplementary group access into the container.\n--device-cgroup-rule\n=\n”type major:minor mode”\n¶\nAdd a rule to the cgroup allowed devices list. The rule is expected to be\nin the format specified in the Linux kernel documentation\nadmin-guide/cgroup-v1/devices\n:\ntype\n:\na\n(all),\nc\n(char), or\nb\n(block);\nmajor\nand\nminor\n: either a number, or\n*\nfor all;\nmode\n: a composition of\nr\n(read),\nw\n(write), and\nm\n(mknod(2)).\n--device-read-bps\n=\npath:rate\n¶\nLimit read rate (in bytes per second) from a device (e.g.\n--device-read-bps=/dev/sda:1mb\n).\nOn some systems, changing the resource limits may not be allowed for non-root\nusers. For more details, see\nhttps://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-resource-limits-fails-with-a-permissions-error\nThis option is not supported on cgroups V1 rootless systems.\n--device-read-iops\n=\npath:rate\n¶\nLimit read rate (in IO operations per second) from a device (e.g.\n--device-read-iops=/dev/sda:1000\n).\nOn some systems, changing the resource limits may not be allowed for non-root\nusers. For more details, see\nhttps://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-resource-limits-fails-with-a-permissions-error\nThis option is not supported on cgroups V1 rootless systems.\n--device-write-bps\n=\npath:rate\n¶\nLimit write rate (in bytes per second) to a device (e.g.\n--device-write-bps=/dev/sda:1mb\n).\nOn some systems, changing the resource limits may not be allowed for non-root\nusers. For more details, see\nhttps://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-resource-limits-fails-with-a-permissions-error\nThis option is not supported on cgroups V1 rootless systems.\n--device-write-iops\n=\npath:rate\n¶\nLimit write rate (in IO operations per second) to a device (e.g.\n--device-write-iops=/dev/sda:1000\n).\nOn some systems, changing the resource limits may not be allowed for non-root\nusers. For more details, see\nhttps://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-resource-limits-fails-with-a-permissions-error\nThis option is not supported on cgroups V1 rootless systems.\n--disable-content-trust\n¶\nThis is a Docker-specific option to disable image verification to a container\nregistry and is not supported by Podman. This option is a NOOP and provided\nsolely for scripting compatibility.\n--dns\n=\nipaddr\n¶\nSet custom DNS servers.\nThis option can be used to override the DNS\nconfiguration passed to the container. Typically this is necessary when the\nhost DNS configuration is invalid for the container (e.g.,\n127.0.0.1\n). When this\nis the case the\n--dns\nflag is necessary for every run.\nThe special value\nnone\ncan be specified to disable creation of\n/etc/resolv.conf\nin the container by Podman.\nThe\n/etc/resolv.conf\nfile in the image is then used without changes.\nNote that\nipaddr\nmay be added directly to the container’s\n/etc/resolv.conf\n.\nThis is not guaranteed though.  For example, passing a custom network whose\ndns_enabled\nis set to\ntrue\nto\n--network\nwill result in\n/etc/resolv.conf\nonly referring to the aardvark-dns server.  aardvark-dns then forwards to the supplied\nipaddr\nfor all non-container name queries.\nThis option cannot be combined with\n--network\nthat is set to\nnone\nor\ncontainer:\nid\n.\n--dns-option\n=\noption\n¶\nSet custom DNS options. Invalid if using\n--dns-option\nwith\n--network\nthat is set to\nnone\nor\ncontainer:\nid\n.\n--dns-search\n=\ndomain\n¶\nSet custom DNS search domains. Invalid if using\n--dns-search\nwith\n--network\nthat is set to\nnone\nor\ncontainer:\nid\n.\nUse\n--dns-search=.\nto remove the search domain.\n--entrypoint\n=\n”command”\n|\n‘[“command”, “arg1”, …]’\n¶\nOverride the default ENTRYPOINT from the image.\nThe ENTRYPOINT of an image is similar to a COMMAND\nbecause it specifies what executable to run when the container starts, but it is\n(purposely) more difficult to override. The ENTRYPOINT gives a container its\ndefault nature or behavior. When the ENTRYPOINT is set, the\ncontainer runs as if it were that binary, complete with default options. More options can be\npassed in via the COMMAND. But, if a user wants to run\nsomething else inside the container, the\n--entrypoint\noption allows a new\nENTRYPOINT to be specified.\nSpecify multi option commands in the form of a JSON string.\n--env\n,\n-e\n=\nenv\n¶\nSet environment variables.\nThis option allows arbitrary environment variables that are available for the process to be launched inside of the container. If an environment variable is specified without a value, Podman checks the host environment for a value and set the variable only if it is set on the host. As a special case, if an environment variable ending in\n*\nis specified without a value, Podman searches the host environment for variables starting with the prefix and adds those variables to the container.\nSee\nEnvironment\nnote below for precedence and examples.\n--env-file\n=\nfile\n¶\nRead in a line-delimited file of environment variables.\nSee\nEnvironment\nnote below for precedence and examples.\n--env-host\n¶\nUse host environment inside of the container. See\nEnvironment\nnote below for precedence. (This option is not available with the remote Podman client, including Mac and Windows (excluding WSL2) machines)\n--env-merge\n=\nenv\n¶\nPreprocess default environment variables for the containers. For example\nif image contains environment variable\nhello=world\nuser can preprocess\nit using\n--env-merge\nhello=${hello}-some\nso new value is\nhello=world-some\n.\nPlease note that if the environment variable\nhello\nis not present in the image,\nthen it’ll be replaced by an empty string and so using\n--env-merge\nhello=${hello}-some\nwould result in the new value of\nhello=-some\n, notice the leading\n-\ndelimiter.\n--expose\n=\nport[/protocol]\n¶\nExpose a port or a range of ports (e.g.\n--expose=3300-3310\n).\nThe protocol can be\ntcp\n,\nudp\nor\nsctp\nand if not given\ntcp\nis assumed.\nThis option matches the EXPOSE instruction for image builds and has no effect on\nthe actual networking rules unless\n-P/--publish-all\nis used to forward to all\nexposed ports from random host ports. To forward specific ports from the host\ninto the container use the\n-p/--publish\noption instead.\n--gidmap\n=\n[flags]container_uid:from_uid[:amount]\n¶\nRun the container in a new user namespace using the supplied GID mapping. This\noption conflicts with the\n--userns\nand\n--subgidname\noptions. This\noption provides a way to map host GIDs to container GIDs in the same way as\n--uidmap\nmaps host UIDs to container UIDs. For details see\n--uidmap\n.\nNote: the\n--gidmap\noption cannot be called in conjunction with the\n--pod\noption as a gidmap cannot be set on the container level when in a pod.\n--gpus\n=\nENTRY\n¶\nGPU devices to add to the container (‘all’ to pass all GPUs) Currently only\nNvidia devices are supported.\n--group-add\n=\ngroup\n|\nkeep-groups\n¶\nAssign additional groups to the primary user running within the container process.\nkeep-groups\nis a special flag that tells Podman to keep the supplementary group access.\nAllows container to use the user’s supplementary group access. If file systems or\ndevices are only accessible by the rootless user’s group, this flag tells the OCI\nruntime to pass the group access into the container. Currently only available\nwith the\ncrun\nOCI runtime. Note:\nkeep-groups\nis exclusive, other groups cannot be specified\nwith this flag. (Not available for remote commands, including Mac and Windows (excluding WSL2) machines)\n--group-entry\n=\nENTRY\n¶\nCustomize the entry that is written to the\n/etc/group\nfile within the container when\n--user\nis used.\nThe variables $GROUPNAME, $GID, and $USERLIST are automatically replaced with their value at runtime if present.\n--health-cmd\n=\n”command”\n|\n‘[“command”, “arg1”, …]’\n¶\nSet or alter a healthcheck command for a container. The command is a command to be executed inside the\ncontainer that determines the container health. The command is required for other healthcheck options\nto be applied. A value of\nnone\ndisables existing healthchecks.\nMultiple options can be passed in the form of a JSON array; otherwise, the command is interpreted\nas an argument to\n/bin/sh -c\n.\nNote: The default values are used even if healthcheck is configured in the image.\n--health-interval\n=\ninterval\n¶\nSet an interval for the healthchecks. An\ninterval\nof\ndisable\nresults in no automatic timer setup. The default is\n30s\n.\nNote: This parameter will overwrite related healthcheck configuration from the image.\n--health-log-destination\n=\ndirectory_path\n¶\nSet the destination of the HealthCheck log. Directory path, local or events_logger (local use container state file) (Default: local)\nlocal\n: (default) HealthCheck logs are stored in overlay containers. (For example:\n$runroot/healthcheck.log\n)\ndirectory\n: creates a log file named\n<container-ID>-healthcheck.log\nwith HealthCheck logs in the specified directory.\nevents_logger\n: The log will be written with logging mechanism set by events_logger. It also saves the log to a default directory, for performance on a system with a large number of logs.\n--health-max-log-count\n=\nnumber of stored logs\n¶\nSet maximum number of attempts in the HealthCheck log file. (‘0’ value means an infinite number of attempts in the log file) (Default: 5 attempts)\n--health-max-log-size\n=\nsize of stored logs\n¶\nSet maximum length in characters of stored HealthCheck log. (“0” value means an infinite log length) (Default: 500 characters)\n--health-on-failure\n=\naction\n¶\nAction to take once the container transitions to an unhealthy state.  The default is\nnone\n.\nnone\n: Take no action.\nkill\n: Kill the container.\nrestart\n: Restart the container.  Do not combine the\nrestart\naction with the\n--restart\nflag.  When running inside of a systemd unit, consider using the\nkill\nor\nstop\naction instead to make use of systemd’s restart policy.\nstop\n: Stop the container.\n--health-retries\n=\nretries\n¶\nThe number of retries allowed before a healthcheck is considered to be unhealthy. The default value is\n3\n.\nNote: This parameter can overwrite the healthcheck configuration from the image.\n--health-start-period\n=\nperiod\n¶\nThe initialization time needed for a container to bootstrap. The value can be expressed in time format like\n2m3s\n. The default value is\n0s\n.\nNote: The health check command is executed as soon as a container is started, if the health check is successful\nthe container’s health state will be updated to\nhealthy\n. However, if the health check fails, the health state will\nstay as\nstarting\nuntil either the health check is successful or until the\n--health-start-period\ntime is over. If the\nhealth check command fails after the\n--health-start-period\ntime is over, the health state will be updated to\nunhealthy\n.\nThe health check command is executed periodically based on the value of\n--health-interval\n.\nNote: This parameter will overwrite related healthcheck configuration from the image.\n--health-startup-cmd\n=\n”command”\n|\n‘[“command”, “arg1”, …]’\n¶\nSet a startup healthcheck command for a container. This command is executed inside the container and is used to gate the regular\nhealthcheck. When the startup command succeeds, the regular healthcheck begins and the startup healthcheck ceases. Optionally,\nif the command fails for a set number of attempts, the container is restarted. A startup healthcheck can be used to ensure that\ncontainers with an extended startup period are not marked as unhealthy until they are fully started. Startup healthchecks can only be\nused when a regular healthcheck (from the container’s image or the\n--health-cmd\noption) is also set.\n--health-startup-interval\n=\ninterval\n¶\nSet an interval for the startup healthcheck. An\ninterval\nof\ndisable\nresults in no automatic timer setup. The default is\n30s\n.\n--health-startup-retries\n=\nretries\n¶\nThe number of attempts allowed before the startup healthcheck restarts the container. If set to\n0\n, the container is never restarted. The default is\n0\n.\n--health-startup-success\n=\nretries\n¶\nThe number of successful runs required before the startup healthcheck succeeds and the regular healthcheck begins. A value\nof\n0\nmeans that any success begins the regular healthcheck. The default is\n0\n.\n--health-startup-timeout\n=\ntimeout\n¶\nThe maximum time a startup healthcheck command has to complete before it is marked as failed. The value can be expressed in a time\nformat like\n2m3s\n. The default value is\n30s\n.\n--health-timeout\n=\ntimeout\n¶\nThe maximum time allowed to complete the healthcheck before an interval is considered failed. Like start-period, the\nvalue can be expressed in a time format such as\n1m22s\n. The default value is\n30s\n.\nNote: A timeout marks the healthcheck as failed. If the healthcheck command itself runs longer than the specified\ntimeout\n,\nit will be sent a\nSIGKILL\nsignal.\nNote: This parameter will overwrite related healthcheck configuration from the image.\n--help\n¶\nPrint usage statement\n--hostname\n,\n-h\n=\nname\n¶\nSet the container’s hostname inside the container.\nThis option can only be used with a private UTS namespace\n--uts=private\n(default). If\n--pod\nis given and the pod shares the same UTS namespace\n(default), the pod’s hostname is used. The given hostname is also added to the\n/etc/hosts\nfile using the container’s primary IP address (also see the\n--add-host\noption).\n--hosts-file\n=\npath\n|\nnone\n|\nimage\n¶\nBase file to create the\n/etc/hosts\nfile inside the container. This must either\nbe an absolute path to a file on the host system, or one of the following\nspecial flags:\n“”      Follow the\nbase_hosts_file\nconfiguration in\ncontainers.conf\n(the default)\nnone\nDo not use a base file (i.e. start with an empty file)\nimage\nUse the container image’s\n/etc/hosts\nfile as base file\n--hostuser\n=\nname\n¶\nAdd a user account to /etc/passwd from the host to the container. The Username\nor UID must exist on the host system.\n--http-proxy\n¶\nBy default proxy environment variables are passed into the container if set\nfor the Podman process. This can be disabled by setting the value to\nfalse\n.\nThe environment variables passed in include\nhttp_proxy\n,\nhttps_proxy\n,\nftp_proxy\n,\nno_proxy\n, and also the upper case versions of\nthose. This option is only needed when the host system must use a proxy but\nthe container does not use any proxy. Proxy environment variables specified\nfor the container in any other way overrides the values that have\nbeen passed through from the host. (Other ways to specify the proxy for the\ncontainer include passing the values with the\n--env\nflag, or hard coding the\nproxy environment at container build time.)\nWhen used with the remote client it uses the proxy environment variables\nthat are set on the server process.\nDefaults to\ntrue\n.\n--image-volume\n=\nbind\n|\ntmpfs\n|\nignore\n¶\nTells Podman how to handle the builtin image volumes. Default is\nbind\n.\nbind\n: An anonymous named volume is created and mounted into the container.\ntmpfs\n: The volume is mounted onto the container as a tmpfs, which allows the users to create\ncontent that disappears when the container is stopped.\nignore\n: All volumes are just ignored and no action is taken.\n--init\n¶\nRun an init inside the container that forwards signals and reaps processes.\nThe container-init binary is mounted at\n/run/podman-init\n.\nMounting over\n/run\nbreaks container execution.\n--init-path\n=\npath\n¶\nPath to the container-init binary.\n--interactive\n,\n-i\n¶\nWhen set to\ntrue\n, make stdin available to the contained process. If\nfalse\n, the stdin of the contained process is empty and immediately closed.\nIf attached, stdin is piped to the contained process. If detached, reading stdin will block until later attached.\nCaveat:\nPodman will consume input from stdin as soon as it becomes available, even if the contained process doesn’t request it.\n--ip\n=\nipv4\n¶\nSpecify a static IPv4 address for the container, for example\n10.88.64.128\n.\nThis option can only be used if the container is joined to only a single network - i.e.,\n--network=network-name\nis used at most once -\nand if the container is not joining another container’s network namespace via\n--network=container:\nid\n.\nThe address must be within the network’s IP address pool (default\n10.88.0.0/16\n).\nTo specify multiple static IP addresses per container, set multiple networks using the\n--network\noption with a static IP address specified for each using the\nip\nmode for that option.\n--ip6\n=\nipv6\n¶\nSpecify a static IPv6 address for the container, for example\nfd46:db93:aa76:ac37::10\n.\nThis option can only be used if the container is joined to only a single network - i.e.,\n--network=network-name\nis used at most once -\nand if the container is not joining another container’s network namespace via\n--network=container:\nid\n.\nThe address must be within the network’s IPv6 address pool.\nTo specify multiple static IPv6 addresses per container, set multiple networks using the\n--network\noption with a static IPv6 address specified for each using the\nip6\nmode for that option.\n--ipc\n=\nipc\n¶\nSet the IPC namespace mode for a container. The default is to create\na private IPC namespace.\n“”: Use Podman’s default, defined in containers.conf.\ncontainer:\nid\n: reuses another container’s shared memory, semaphores, and message queues\nhost\n: use the host’s shared memory, semaphores, and message queues inside the container. Note: the host mode gives the container full access to local shared memory and is therefore considered insecure.\nnone\n:  private IPC namespace, with /dev/shm not mounted.\nns:\npath\n: path to an IPC namespace to join.\nprivate\n: private IPC namespace.\nshareable\n: private IPC namespace with a possibility to share it with other containers.\n--label\n,\n-l\n=\nkey=value\n¶\nAdd metadata to a container.\n--label-file\n=\nfile\n¶\nRead in a line-delimited file of labels.\n--link-local-ip\n=\nip\n¶\nNot implemented.\n--log-driver\n=\ndriver\n¶\nLogging driver for the container. Currently available options are\nk8s-file\n,\njournald\n,\nnone\n,\npassthrough\nand\npassthrough-tty\n, with\njson-file\naliased to\nk8s-file\nfor scripting compatibility. (Default\njournald\n).\nThe podman info command below displays the default log-driver for the system.\n$ podman info --format '{{ .Host.LogDriver }}'\njournald\nThe\npassthrough\ndriver passes down the standard streams (stdin, stdout, stderr) to the\ncontainer.  It is not allowed with the remote Podman client, including Mac and Windows (excluding WSL2) machines, and on a tty, since it is\nvulnerable to attacks via TIOCSTI.\nThe\npassthrough-tty\ndriver is the same as\npassthrough\nexcept that it also allows it to be used on a TTY if the user really wants it.\n--log-opt\n=\nname=value\n¶\nLogging driver specific options.\nSet custom logging configuration. The following\nname\ns are supported:\npath\n: specify a path to the log file\n(e.g.\n--log-opt path=/var/log/container/mycontainer.json\n);\nmax-size\n: specify a max size of the log file\n(e.g.\n--log-opt max-size=10mb\n);\ntag\n: specify a custom log tag for the container\n(e.g.\n--log-opt tag=”{{.ImageName}}”\n.\nIt supports the same keys as\npodman inspect --format\n.\nThis option is currently supported only by the\njournald\nlog driver.\n--mac-address\n=\naddress\n¶\nContainer network interface MAC address (e.g. 92:d0:c6:0a:29:33)\nThis option can only be used if the container is joined to only a single network - i.e.,\n--network=\nnetwork-name\nis used at most once -\nand if the container is not joining another container’s network namespace via\n--network=container:\nid\n.\nRemember that the MAC address in an Ethernet network must be unique.\nThe IPv6 link-local address is based on the device’s MAC address\naccording to RFC4862.\nTo specify multiple static MAC addresses per container, set multiple networks using the\n--network\noption with a static MAC address specified for each using the\nmac\nmode for that option.\n--memory\n,\n-m\n=\nnumber[unit]\n¶\nMemory limit. A\nunit\ncan be\nb\n(bytes),\nk\n(kibibytes),\nm\n(mebibytes), or\ng\n(gibibytes).\nAllows the memory available to a container to be constrained. If the host\nsupports swap memory, then the\n-m\nmemory setting can be larger than physical\nRAM. If a limit of 0 is specified (not using\n-m\n), the container’s memory is\nnot limited. The actual limit may be rounded up to a multiple of the operating\nsystem’s page size (the value is very large, that’s millions of trillions).\nThis option is not supported on cgroups V1 rootless systems.\n--memory-reservation\n=\nnumber[unit]\n¶\nMemory soft limit. A\nunit\ncan be\nb\n(bytes),\nk\n(kibibytes),\nm\n(mebibytes), or\ng\n(gibibytes).\nAfter setting memory reservation, when the system detects memory contention\nor low memory, containers are forced to restrict their consumption to their\nreservation. So always set the value below\n--memory\n, otherwise the\nhard limit takes precedence. By default, memory reservation is the same\nas memory limit.\nThis option is not supported on cgroups V1 rootless systems.\n--memory-swap\n=\nnumber[unit]\n¶\nA limit value equal to memory plus swap.\nA\nunit\ncan be\nb\n(bytes),\nk\n(kibibytes),\nm\n(mebibytes), or\ng\n(gibibytes).\nMust be used with the\n-m\n(\n--memory\n) flag.\nThe argument value must be larger than that of\n-m\n(\n--memory\n) By default, it is set to double\nthe value of\n--memory\n.\nSet\nnumber\nto\n-1\nto enable unlimited swap.\nThis option is not supported on cgroups V1 rootless systems.\n--memory-swappiness\n=\nnumber\n¶\nTune a container’s memory swappiness behavior. Accepts an integer between\n0\nand\n100\n.\nThis flag is only supported on cgroups V1 rootful systems.\n--mount\n=\ntype=TYPE,TYPE-SPECIFIC-OPTION[,…]\n¶\nAttach a filesystem mount to the container.\nCurrent supported mount TYPEs are\nartifact\n,\nbind\n,\ndevpts\n,\nglob\n,\nimage\n,\nramfs\n,\ntmpfs\nand\nvolume\n.\nOptions common to all mount types:\nsrc\n,\nsource\n: mount source spec for\nbind\n,\nglob\n, and\nvolume\n.\nMandatory for\nartifact\n,\nbind\n,\nglob\n,\nimage\nand\nvolume\n.\ndst\n,\ndest\n,\ndestination\n,\ntarget\n: mount destination spec.\nWhen source globs are specified without the destination directory,\nthe files and directories are mounted with their complete path\nwithin the container. When the destination is specified, the\nfiles and directories matching the glob on the base file name\non the destination directory are mounted. The option\ntype=glob,src=/foo*,destination=/tmp/bar\ntells container engines\nto mount host files matching /foo* to the /tmp/bar/\ndirectory in the container.\nOptions specific to type=\nartifact\n:\ndigest\n: If the artifact source contains multiple blobs a digest can be\nspecified to only mount the one specific blob with the digest.\ntitle\n: If the artifact source contains multiple blobs a title can be set\nwhich is compared against\norg.opencontainers.image.title\nannotation.\nname\n: This can be used to overwrite the filename we use inside the container\nfor mounting. On a single blob artifact the name is used as is if\ndst\nis a\ndirectory and otherwise ignored. With a multi blob artifact the name will be\nused with an index suffix\n<name>-x\nwhere x is the layer index in the artifact\nstarting with 0.\nThe\nsrc\nargument contains the name of the artifact, which must already exist locally.\nThe\ndst\nargument contains the target path, if the path in the container is a\ndirectory the blob title (\norg.opencontainers.image.title\nannotation) will be used as\nfilename and joined to the path. If the annotation does not exist the digest will be\nused as filename instead. This results in all blobs of the artifact mounted into the\ncontainer at the given path.\nHowever, if the\ndst\npath is an existing file in the container, then the blob will be\nmounted directly on it. This only works when the artifact contains a single blob\nor when either\ndigest\nor\ntitle\nare specified.\nIf the\ndst\npath does not already exist in the container then if the artifact contains\na single blob it behaves like existing file case and mounts directly to that path.\nIf the artifact has more than one blob it works like the existing directory case and\nmounts each blob as file within the\ndst\npath.\nOptions specific to type=\nvolume\n:\nro\n,\nreadonly\n:\ntrue\nor\nfalse\n(default if unspecified:\nfalse\n).\nU\n,\nchown\n:\ntrue\nor\nfalse\n(default if unspecified:\nfalse\n). Recursively change the owner and group of the source volume based on the UID and GID of the container.\nsubpath\n: Mount only a specific subpath within the volume, instead of the whole volume.\nidmap\n: If specified, create an idmapped mount to the target user namespace in the container.\nThe idmap option is only supported by Podman in rootful mode. The Linux kernel does not allow the use of idmapped file systems for unprivileged users.\nThe idmap option supports a custom mapping that can be different than the user namespace used by the container.\nThe mapping can be specified after the idmap option like:\nidmap=uids=0-1-10#10-11-10;gids=0-100-10\n.  For each triplet, the first value is the\nstart of the backing file system IDs that are mapped to the second value on the host.  The length of this mapping is given in the third value.\nMultiple ranges are separated with #.  If the specified mapping is prepended with a ‘@’, then the mapping is considered relative to the container\nuser namespace. The host ID for the mapping is changed to account for the relative position of the container user in the container user namespace.\nOptions specific to type=\nimage\n:\nrw\n,\nreadwrite\n:\ntrue\nor\nfalse\n(default if unspecified:\nfalse\n).\nsubpath\n: Mount only a specific path within the image, instead of the whole image.\nOptions specific to\nbind\nand\nglob\n:\nro\n,\nreadonly\n:\ntrue\nor\nfalse\n(default if unspecified:\nfalse\n).\nbind-propagation\n:\nshared\n,\nslave\n,\nprivate\n,\nunbindable\n,\nrshared\n,\nrslave\n,\nrunbindable\n, or\nrprivate\n(default).\n[1]\nSee also mount(2).\nbind-nonrecursive\n: do not set up a recursive bind mount. By default it is recursive.\nrelabel\n:\nshared\n,\nprivate\n.\nidmap\n:\ntrue\nor\nfalse\n(default if unspecified:\nfalse\n).  If true, create an idmapped mount to the target user namespace in the container. The idmap option is only supported by Podman in rootful mode.\nU\n,\nchown\n:\ntrue\nor\nfalse\n(default if unspecified:\nfalse\n). Recursively change the owner and group of the source volume based on the UID and GID of the container.\nno-dereference\n: do not dereference symlinks but copy the link source into the mount destination.\nOptions specific to type=\ntmpfs\nand\nramfs\n:\nro\n,\nreadonly\n:\ntrue\nor\nfalse\n(default if unspecified:\nfalse\n).\ntmpfs-size\n: Size of the tmpfs/ramfs mount, in bytes. Unlimited by default in Linux.\ntmpfs-mode\n: Octal file mode of the tmpfs/ramfs (e.g. 700 or 0700.).\ntmpcopyup\n: Enable copyup from the image directory at the same location to the tmpfs/ramfs. Used by default.\nnoatime\n: Disable updating file access times when the file is read.\nnotmpcopyup\n: Disable copying files from the image to the tmpfs/ramfs.\nU\n,\nchown\n:\ntrue\nor\nfalse\n(default if unspecified:\nfalse\n). Set the uid and gid options for the tmpfs filesystem based on the UID and GID of the container. This is\nnot\nrecursive.\nOptions specific to type=\ndevpts\n:\nuid\n: numeric UID of the file owner (default: 0).\ngid\n: numeric GID of the file owner (default: 0).\nmode\n: octal permission mask for the file (default: 600).\nmax\n: maximum number of PTYs (default: 1048576).\nExamples:\ntype=bind,source=/path/on/host,destination=/path/in/container\ntype=bind,src=/path/on/host,dst=/path/in/container,relabel=shared\ntype=bind,src=/path/on/host,dst=/path/in/container,relabel=shared,U=true\ntype=devpts,destination=/dev/pts\ntype=glob,src=/usr/lib/libfoo*,destination=/usr/lib,ro=true\ntype=image,source=fedora,destination=/fedora-image,rw=true\ntype=ramfs,tmpfs-size=512M,destination=/path/in/container\ntype=tmpfs,tmpfs-size=512M,destination=/path/in/container\ntype=tmpfs,destination=/path/in/container,noswap\ntype=artifact,src=quay.io/libpod/testartifact:20250206-single,dst=/data\ntype=artifact,src=quay.io/libpod/testartifact:20250206-multi,dst=/data,title=test1\ntype=volume,src=test_vol,dst=/data,subpath=/code/docs\n--name\n=\nname\n¶\nAssign a name to the container.\nThe operator can identify a container in three ways:\nUUID long identifier (“f78375b1c487e03c9438c729345e54db9d20cfa2ac1fc3494b6eb60872e74778”);\nUUID short identifier (“f78375b1c487”);\nName (“jonah”).\nPodman generates a UUID for each container, and if no name is assigned to the\ncontainer using\n--name\n, Podman generates a random string name. The name can\nbe useful as a more human-friendly way to identify containers. This works for\nboth background and foreground containers. The container’s name is also added\nto the\n/etc/hosts\nfile using the container’s primary IP address (also see the\n--add-host\noption).\n--network\n=\nmode\n,\n--net\n¶\nSet the network mode for the container.\nValid\nmode\nvalues are:\nbridge[:OPTIONS,…]\n: Create a network stack on the default bridge. This is the default for rootful containers. It is possible to specify these additional options:\nalias=\nname\n: Add network-scoped alias for the container.\nip=\nIPv4\n: Specify a static IPv4 address for this container.\nip6=\nIPv6\n: Specify a static IPv6 address for this container.\nmac=\nMAC\n: Specify a static MAC address for this container.\ninterface_name=\nname\n: Specify a name for the created network interface inside the container.\nhost_interface_name=\nname\n: Specify a name for the created network interface outside the container.\nAny other options will be passed through to netavark without validation. This can be useful to pass arguments to netavark plugins.\nFor example, to set a static ipv4 address and a static mac address, use\n--network\nbridge:ip=10.88.0.10,mac=44:33:22:11:00:99\n.\n<network name or ID>\n[:OPTIONS,…]\n: Connect to a user-defined network; this is the network name or ID from a network created by\npodman network create\n. It is possible to specify the same options described under the bridge mode above. Use the\n--network\noption multiple times to specify additional networks.\nFor backwards compatibility it is also possible to specify comma-separated networks on the first\n--network\nargument, however this prevents you from using the options described under the bridge section above.\nnone\n: Create a network namespace for the container but do not configure network interfaces for it, thus the container has no network connectivity.\ncontainer:\nid\n: Reuse another container’s network stack.\nhost\n: Use the host’s network namespace for the container instead of creating an isolated namespace. Warning: This gives the container full access to abstract Unix domain sockets and to TCP/UDP sockets bound to localhost. Since these mechanisms are often used to prevent access to sensitive system services, isolating them from access by external entities, use of this option may be considered a security vulnerability.\nns:\npath\n: Path to a network namespace to join.\nprivate\n: Create a new namespace for the container. This uses the\nbridge\nmode for rootful containers and\nslirp4netns\nfor rootless ones.\nslirp4netns[:OPTIONS,…]\n: use\nslirp4netns\n(1) to create a user network stack. It is possible to specify these additional options, they can also be set with\nnetwork_cmd_options\nin containers.conf:\nallow_host_loopback=true|false\n: Allow slirp4netns to reach the host loopback IP (default is 10.0.2.2 or the second IP from slirp4netns cidr subnet when changed, see the cidr option below). The default is false.\nmtu=\nMTU\n: Specify the MTU to use for this network. (Default is\n65520\n).\ncidr=\nCIDR\n: Specify ip range to use for this network. (Default is\n10.0.2.0/24\n).\nenable_ipv6=true|false\n: Enable IPv6. Default is true. (Required for\noutbound_addr6\n).\noutbound_addr=\nINTERFACE\n: Specify the outbound interface slirp binds to (ipv4 traffic only).\noutbound_addr=\nIPv4\n: Specify the outbound ipv4 address slirp binds to.\noutbound_addr6=\nINTERFACE\n: Specify the outbound interface slirp binds to (ipv6 traffic only).\noutbound_addr6=\nIPv6\n: Specify the outbound ipv6 address slirp binds to.\nport_handler=rootlesskit\n: Use rootlesskit for port forwarding. Default.\nNote: Rootlesskit changes the source IP address of incoming packets to an IP address in the container network namespace, usually\n10.0.2.100\n. If the application requires the real source IP address, e.g. web server logs, use the slirp4netns port handler. The rootlesskit port handler is also used for rootless containers when connected to user-defined networks.\nport_handler=slirp4netns\n: Use the slirp4netns port forwarding, it is slower than rootlesskit but preserves the correct source IP address. This port handler cannot be used for user-defined networks.\npasta[:OPTIONS,…]\n: use\npasta\n(1) to create a user-mode networking\nstack.\nThis is the default for rootless containers and only supported in rootless mode.\nBy default, IPv4 and IPv6 addresses and routes, as well as the pod interface\nname, are copied from the host. Port forwarding preserves the original\nsource IP address. Options described in pasta(1) can be specified as\ncomma-separated arguments.\nIn terms of pasta(1) options,\n--config-net\nis given by default, in\norder to configure networking when the container is started, and\n--no-map-gw\nis also assumed by default, to avoid direct access from\ncontainer to host using the gateway address. The latter can be overridden\nby passing\n--map-gw\nin the pasta-specific options (despite not being an\nactual pasta(1) option).\nFor better integration with DNS handling,\n--dns-forward 169.254.1.1\nis passed,\nand this address is added to resolv.conf(5) as first resolver. It is possible to pass\n--dns-forward\nexplicitly in case a different IP address should be used.\nTo make the\nhost.containers.internal\n/etc/hosts entry work and allow connections\nto the host,\n--map-guest-addr 169.254.1.2\nis passed. Again, it can be set\nexplicitly to choose a different IP address.\nAlso,\n-t none\nand\n-u none\nare passed if, respectively, no TCP or\nUDP port forwarding from host to container is configured (via Podman’s\n--publish\nor by passing the pasta\n-t\n/\n-u\noptions directly),\nto disable automatic port forwarding based on bound ports. Similarly,\n-T none\nand\n-U none\nare given to disable the same functionality from container to\nhost.\nAll options can also be set in\ncontainers.conf(5)\n;\nsee the\npasta_options\nkey under the network section in that file.\nSome examples:\npasta:--map-gw\n: Allow the container to directly reach the host using the\ngateway address.\npasta:--mtu,1500\n: Specify a 1500 bytes MTU for the\ntap\ninterface in\nthe container.\npasta:--ipv4-only,-a,10.0.2.0,-n,24,-g,10.0.2.2,--dns-forward,10.0.2.3,-m,1500,--no-ndp,--no-dhcpv6,--no-dhcp\n,\nequivalent to default slirp4netns(1) options: disable IPv6, assign\n10.0.2.0/24\nto the\ntap0\ninterface in the container, with gateway\n10.0.2.3\n, enable DNS forwarder reachable at\n10.0.2.3\n, set MTU to 1500\nbytes, disable NDP, DHCPv6 and DHCP support.\npasta:-I,tap0,--ipv4-only,-a,10.0.2.0,-n,24,-g,10.0.2.2,--dns-forward,10.0.2.3,--no-ndp,--no-dhcpv6,--no-dhcp\n,\nequivalent to default slirp4netns(1) options with Podman overrides: same as\nabove, but leave the MTU to 65520 bytes\npasta:-t,auto,-u,auto,-T,auto,-U,auto\n: enable automatic port forwarding\nbased on observed bound ports from both host and container sides\npasta:-T,5201\n: enable forwarding of TCP port 5201 from container to\nhost, using the loopback interface instead of the tap interface for improved\nperformance\nInvalid if using\n--dns\n,\n--dns-option\n, or\n--dns-search\nwith\n--network\nset to\nnone\nor\ncontainer:\nid\n.\nIf used together with\n--pod\n, the container joins the pod’s network namespace.\n--network-alias\n=\nalias\n¶\nAdd a network-scoped alias for the container, setting the alias for all networks that the container joins. To set a\nname only for a specific network, use the alias option as described under the\n--network\noption.\nIf the network has DNS enabled (\npodman\nnetwork\ninspect\n-f\n{{.DNSEnabled}}\n<name>\n),\nthese aliases can be used for name resolution on the given network. This option can be specified multiple times.\nNOTE: When using CNI a container only has access to aliases on the first network that it joins. This limitation does\nnot exist with netavark/aardvark-dns.\n--no-healthcheck\n¶\nDisable any defined healthchecks for container.\n--no-hostname\n¶\nDo not create the\n/etc/hostname\nfile in the containers.\nBy default, Podman manages the\n/etc/hostname\nfile, adding the container’s own hostname.  When the\n--no-hostname\noption is set, the image’s\n/etc/hostname\nwill be preserved unmodified if it exists.\n--no-hosts\n¶\nDo not modify the\n/etc/hosts\nfile in the container.\nPodman assumes control over the container’s\n/etc/hosts\nfile by\ndefault and adds entries for the container’s name (see\n--name\noption) and\nhostname (see\n--hostname\noption), the internal\nhost.containers.internal\nand\nhost.docker.internal\nhosts, as well as any hostname added using the\n--add-host\noption. Refer to the\n--add-host\noption for details. Passing\n--no-hosts\ndisables this, so that the image’s\n/etc/hosts\nfile is kept\nunmodified. The same can be achieved globally by setting\nno_hosts=true\nin\ncontainers.conf\n.\nThis option conflicts with\n--add-host\n.\n--oom-kill-disable\n¶\nWhether to disable OOM Killer for the container or not.\nThis flag is not supported on cgroups V2 systems.\n--oom-score-adj\n=\nnum\n¶\nTune the host’s OOM preferences for containers (accepts values from\n-1000\nto\n1000\n).\nWhen running in rootless mode, the specified value can’t be lower than\nthe oom_score_adj for the current process. In this case, the\noom-score-adj is clamped to the current process value.\n--os\n=\nOS\n¶\nOverride the OS, defaults to hosts, of the image to be pulled. For example,\nwindows\n.\nUnless overridden, subsequent lookups of the same image in the local storage matches this OS, regardless of the host.\n--passwd\n¶\nAllow Podman to add entries to /etc/passwd and /etc/group when used in conjunction with the --user option.\nThis is used to override the Podman provided user setup in favor of entrypoint configurations such as libnss-extrausers.\n--passwd-entry\n=\nENTRY\n¶\nCustomize the entry that is written to the\n/etc/passwd\nfile within the container when\n--passwd\nis used.\nThe variables $USERNAME, $UID, $GID, $NAME, $HOME are automatically replaced with their value at runtime.\n--personality\n=\npersona\n¶\nPersonality sets the execution domain via Linux personality(2).\n--pid\n=\nmode\n¶\nSet the PID namespace mode for the container.\nThe default is to create a private PID namespace for the container.\ncontainer:\nid\n: join another container’s PID namespace;\nhost\n: use the host’s PID namespace for the container. Note the host mode gives the container full access to local PID and is therefore considered insecure;\nns:\npath\n: join the specified PID namespace;\nprivate\n: create a new namespace for the container (default).\n--pidfile\n=\npath\n¶\nWhen the pidfile location is specified, the container process’ PID is written to the pidfile. (This option is not available with the remote Podman client, including Mac and Windows (excluding WSL2) machines)\nIf the pidfile option is not specified, the container process’ PID is written to /run/containers/storage/${storage-driver}-containers/$CID/userdata/pidfile.\nAfter the container is started, the location for the pidfile can be discovered with the following\npodman\ninspect\ncommand:\n$ podman inspect --format '{{ .PidFile }}' $CID\n/run/containers/storage/${storage-driver}-containers/$CID/userdata/pidfile\n--pids-limit\n=\nlimit\n¶\nTune the container’s pids limit. Set to\n-1\nto have unlimited pids for the container. The default is\n2048\non systems that support “pids” cgroup controller.\n--platform\n=\nOS/ARCH\n¶\nSpecify the platform for selecting the image.  (Conflicts with --arch and --os)\nThe\n--platform\noption can be used to override the current architecture and operating system.\nUnless overridden, subsequent lookups of the same image in the local storage matches this platform, regardless of the host.\n--pod\n=\nname\n¶\nRun container in an existing pod. Podman makes the pod automatically if the pod name is prefixed with\nnew:\n.\nTo make a pod with more granular options, use the\npodman pod create\ncommand before creating a container.\nWhen a container is run with a pod with an infra-container, the infra-container is started first.\n--pod-id-file\n=\nfile\n¶\nRun container in an existing pod and read the pod’s ID from the specified\nfile\n.\nWhen a container is run within a pod which has an infra-container, the infra-container starts first.\n--preserve-fd\n=\nFD1[,FD2,…]\n¶\nPass down to the process the additional file descriptors specified in the comma separated list.  It can be specified multiple times.\nThis option is only supported with the crun OCI runtime.  It might be a security risk to use this option with other OCI runtimes.\n(This option is not available with the remote Podman client, including Mac and Windows (excluding WSL2) machines)\n--preserve-fds\n=\nN\n¶\nPass down to the process N additional file descriptors (in addition to 0, 1, 2).\nThe total FDs are 3+N.\n(This option is not available with the remote Podman client, including Mac and Windows (excluding WSL2) machines)\n--privileged\n¶\nGive extended privileges to this container. The default is\nfalse\n.\nBy default, Podman containers are unprivileged (\n=false\n) and cannot, for\nexample, modify parts of the operating system. This is because by default a\ncontainer is only allowed limited access to devices. A “privileged” container\nis given the same access to devices as the user launching the container, with\nthe exception of virtual consoles (\n/dev/tty\\d+\n) when running in systemd\nmode (\n--systemd=always\n).\nA privileged container turns off the security features that isolate the\ncontainer from the host. Dropped Capabilities, limited devices, read-only mount\npoints, Apparmor/SELinux separation, and Seccomp filters are all disabled.\nDue to the disabled security features, the privileged field should almost never\nbe set as containers can easily break out of confinement.\nContainers running in a user namespace (e.g., rootless containers) cannot have\nmore privileges than the user that launched them.\n--publish\n,\n-p\n=\n[[ip:][hostPort]:]containerPort[/protocol]\n¶\nPublish a container’s port, or range of ports, to the host.\nBoth\nhostPort\nand\ncontainerPort\ncan be specified as a range of ports.\nWhen specifying ranges for both, the number of container ports in the\nrange must match the number of host ports in the range.\nIf host IP is set to 0.0.0.0 or not set at all, the port is bound on all IPs on the host.\nBy default, Podman publishes TCP ports. To publish a UDP port instead, give\nudp\nas protocol. To publish both TCP and UDP ports, set\n--publish\ntwice,\nwith\ntcp\n, and\nudp\nas protocols respectively. Rootful containers can also\npublish ports using the\nsctp\nprotocol.\nHost port does not have to be specified (e.g.\npodman\nrun\n-p\n127.0.0.1::80\n).\nIf it is not, the container port is randomly assigned a port on the host.\nUse\npodman port\nto see the actual mapping:\npodman\nport\n$CONTAINER\n$CONTAINERPORT\n.\nPort publishing is only supported for containers utilizing their own network namespace\nthrough\nbridge\nnetworks, or the\npasta\nand\nslirp4netns\nnetwork modes.\nNote:\nIf a container runs within a pod, it is not necessary to publish the port for\nthe containers in the pod. The port must only be published by the pod itself. Pod network\nstacks act like the network stack on the host - meaning a variety of containers in the pod\nand programs in the container all share a single interface, IP address, and\nassociated ports. If one container binds to a port, no other container can use that port\nwithin the pod while it is in use. Containers in the pod can also communicate over localhost\nby having one container bind to localhost in the pod, and another connect to that port.\n--publish-all\n,\n-P\n¶\nPublish all exposed ports to random ports on the host interfaces. The default is\nfalse\n.\nWhen set to\ntrue\n, publish all exposed ports to the host interfaces.\nIf the operator uses\n-P\n(or\n-p\n) then Podman makes the\nexposed port accessible on the host and the ports are available to any\nclient that can reach the host.\nWhen using this option, Podman binds any exposed port to a random port on the host\nwithin an ephemeral port range defined by\n/proc/sys/net/ipv4/ip_local_port_range\n.\nTo find the mapping between the host ports and the exposed ports, use\npodman port\n.\n--pull\n=\npolicy\n¶\nPull image policy. The default is\nmissing\n.\nalways\n: Always pull the image and throw an error if the pull fails.\nmissing\n: Pull the image only when the image is not in the local containers storage.  Throw an error if no image is found and the pull fails.\nnever\n: Never pull the image but use the one from the local containers storage.  Throw an error if no image is found.\nnewer\n: Pull if the image on the registry is newer than the one in the local containers storage.  An image is considered to be newer when the digests are different.  Comparing the time stamps is prone to errors.  Pull errors are suppressed if a local image was found.\n--quiet\n,\n-q\n¶\nSuppress output information when pulling images\n--rdt-class\n=\nintel-rdt-class-of-service\n¶\nRdt-class sets the class of service (CLOS or COS) for the container to run in. Based on the Cache Allocation Technology (CAT) feature that is part of Intel’s Resource Director Technology (RDT) feature set, all container processes will run within the pre-configured COS, representing a part of the cache. The COS has to be created and configured using a pseudo file system (usually mounted at\n/sys/fs/resctrl\n) that the resctrl kernel driver provides. Assigning the container to a COS requires root privileges and thus doesn’t work in a rootless environment. Currently, the feature is only supported using\nrunc\nas a runtime. See\nhttps://docs.kernel.org/arch/x86/resctrl.html\nfor more details on creating a COS before a container can be assigned to it.\n--read-only\n¶\nMount the container’s root filesystem as read-only.\nBy default, container root filesystems are writable, allowing processes\nto write files anywhere. By specifying the\n--read-only\nflag, the containers root filesystem are mounted read-only prohibiting any writes.\n--read-only-tmpfs\n¶\nWhen running --read-only containers, mount a read-write tmpfs on\n/dev\n,\n/dev/shm\n,\n/run\n,\n/tmp\n, and\n/var/tmp\n. The default is\ntrue\n.\n--read-only\n--read-only-tmpfs\n/\n/run, /tmp, /var/tmp\ntrue\ntrue\nr/o\nr/w\ntrue\nfalse\nr/o\nr/o\nfalse\nfalse\nr/w\nr/w\nfalse\ntrue\nr/w\nr/w\nWhen\n--read-only=true\nand\n--read-only-tmpfs=true\nadditional tmpfs are mounted on\nthe /tmp, /run, and /var/tmp directories.\nWhen\n--read-only=true\nand\n--read-only-tmpfs=false\n/dev and /dev/shm are marked\nRead/Only and no tmpfs are mounted on /tmp, /run and /var/tmp. The directories\nare exposed from the underlying image, meaning they are read-only by default.\nThis makes the container totally read-only. No writable directories exist within\nthe container. In this mode writable directories need to be added via external\nvolumes or mounts.\nBy default, when\n--read-only=false\n, the /dev and /dev/shm are read/write, and the /tmp, /run, and /var/tmp are read/write directories from the container image.\n--replace\n¶\nIf another container with the same name already exists, replace and remove it. The default is\nfalse\n.\n--requires\n=\ncontainer\n¶\nSpecify one or more requirements.\nA requirement is a dependency container that is started before this container.\nContainers can be specified by name or ID, with multiple containers being separated by commas.\n--restart\n=\npolicy\n¶\nRestart policy to follow when containers exit.\nRestart policy does not take effect if a container is stopped via the\npodman kill\nor\npodman stop\ncommands.\nValid\npolicy\nvalues are:\nno\n: Do not restart containers on exit\nnever\n: Synonym for\nno\n; do not restart containers on exit\non-failure[:max_retries]\n: Restart containers when they exit with a non-zero exit code, retrying indefinitely or until the optional\nmax_retries\ncount is hit\nalways\n: Restart containers when they exit, regardless of status, retrying indefinitely\nunless-stopped\n: Identical to\nalways\nPodman provides a systemd unit file, podman-restart.service, which restarts containers after a system reboot.\nWhen running containers in systemd services, use the restart functionality provided by systemd.\nIn other words, do not use this option in a container unit, instead set the\nRestart=\nsystemd directive in the\n[Service]\nsection.\nSee\npodman-systemd.unit\n(5) and\nsystemd.service\n(5).\n--retry\n=\nattempts\n¶\nNumber of times to retry pulling or pushing images between the registry and\nlocal storage in case of failure. Default is\n3\n.\n--retry-delay\n=\nduration\n¶\nDuration of delay between retry attempts when pulling or pushing images between\nthe registry and local storage in case of failure. The default is to start at two seconds and then exponentially back off. The delay is used when this value is set, and no exponential back off occurs.\n--rm\n¶\nAutomatically remove the container and any anonymous unnamed volume associated with\nthe container when it exits. The default is\nfalse\n.\n--rmi\n¶\nAfter exit of the container, remove the image unless another\ncontainer is using it. Implies --rm on the new container. The default is\nfalse\n.\n--rootfs\n¶\nIf specified, the first argument refers to an exploded container on the file system.\nThis is useful to run a container without requiring any image management, the rootfs\nof the container is assumed to be managed externally.\nOverlay\nRootfs\nMounts\nThe\n:O\nflag tells Podman to mount the directory from the rootfs path as\nstorage using the\noverlay\nfile\nsystem\n. The container processes\ncan modify content within the mount point which is stored in the\ncontainer storage in a separate directory. In overlay terms, the source\ndirectory is the lower, and the container storage directory is the\nupper. Modifications to the mount point are destroyed when the container\nfinishes executing, similar to a tmpfs mount point being unmounted.\nNote: On\nSELinux\nsystems, the rootfs needs the correct label, which is by default\nunconfined_u:object_r:container_file_t:s0\n.\nidmap\nIf\nidmap\nis specified, create an idmapped mount to the target user\nnamespace in the container.\nThe idmap option supports a custom mapping that can be different than the user\nnamespace used by the container.  The mapping can be specified after the idmap\noption like:\nidmap=uids=0-1-10#10-11-10;gids=0-100-10\n.  For each triplet, the\nfirst value is the start of the backing file system IDs that are mapped to the\nsecond value on the host.  The length of this mapping is given in the third value.\nMultiple ranges are separated with #.\n--sdnotify\n=\ncontainer\n|\nconmon\n|\nhealthy\n|\nignore\n¶\nDetermines how to use the NOTIFY_SOCKET, as passed with systemd and Type=notify.\nDefault is\ncontainer\n, which means allow the OCI runtime to proxy the socket into the\ncontainer to receive ready notification. Podman sets the MAINPID to conmon’s pid.\nThe\nconmon\noption sets MAINPID to conmon’s pid, and sends READY when the container\nhas started. The socket is never passed to the runtime or the container.\nThe\nhealthy\noption sets MAINPID to conmon’s pid, and sends READY when the container\nhas turned healthy; requires a healthcheck to be set. The socket is never passed to the runtime or the container.\nThe\nignore\noption removes NOTIFY_SOCKET from the environment for itself and child processes,\nfor the case where some other process above Podman uses NOTIFY_SOCKET and Podman does not use it.\n--seccomp-policy\n=\npolicy\n¶\nSpecify the policy to select the seccomp profile. If set to\nimage\n, Podman looks for a “io.containers.seccomp.profile” label in the container-image config and use its value as a seccomp profile. Otherwise, Podman follows the\ndefault\npolicy by applying the default profile unless specified otherwise via\n--security-opt seccomp\nas described below.\nNote that this feature is experimental and may change in the future.\n--secret\n=\nsecret[,opt=opt …]\n¶\nGive the container access to a secret. Can be specified multiple times.\nA secret is a blob of sensitive data which a container needs at runtime but\nis not stored in the image or in source control, such as usernames and passwords,\nTLS certificates and keys, SSH keys or other important generic strings or binary content (up to 512 kB in size).\nWhen secrets are specified as type\nmount\n, the secrets are copied and mounted into the container when a container is created.\nWhen secrets are specified as type\nenv\n, the secret is set as an environment variable within the container.\nSecrets are written in the container at the time of container creation, and modifying the secret using\npodman\nsecret\ncommands\nafter the container is created affects the secret inside the container.\nSecrets and its storage are managed using the\npodman\nsecret\ncommand.\nSecret Options\ntype=mount|env\n: How the secret is exposed to the container.\nmount\nmounts the secret into the container as a file.\nenv\nexposes the secret as an environment variable.\nDefaults to\nmount\n.\ntarget=target\n: Target of secret.\nFor mounted secrets, this is the path to the secret inside the container.\nIf a fully qualified path is provided, the secret is mounted at that location.\nOtherwise, the secret is mounted to\n/run/secrets/target\nfor Linux containers or\n/var/run/secrets/target\nfor FreeBSD containers.\nIf the target is not set, the secret is mounted to\n/run/secrets/secretname\nby default.\nFor env secrets, this is the environment variable key. Defaults to\nsecretname\n.\nuid=0\n: UID of secret. Defaults to 0. Mount secret type only.\ngid=0\n: GID of secret. Defaults to 0. Mount secret type only.\nmode=0\n: Mode of secret. Defaults to 0444. Mount secret type only.\nExamples\nMount at\n/my/location/mysecret\nwith UID 1:\n--\nsecret\nmysecret\n,\ntarget\n=/\nmy\n/\nlocation\n/\nmysecret\n,\nuid\n=\n1\nMount at\n/run/secrets/customtarget\nwith mode 0777:\n--\nsecret\nmysecret\n,\ntarget\n=\ncustomtarget\n,\nmode\n=\n0777\nCreate a secret environment variable called\nENVSEC\n:\n--\nsecret\nmysecret\n,\ntype\n=\nenv\n,\ntarget\n=\nENVSEC\n--security-opt\n=\noption\n¶\nSecurity Options\napparmor=unconfined\n: Turn off apparmor confinement for the container\napparmor\n=\nalternate-profile\n: Set the apparmor confinement profile for the container\nlabel=user:\nUSER\n: Set the label user for the container processes\nlabel=role:\nROLE\n: Set the label role for the container processes\nlabel=type:\nTYPE\n: Set the label process type for the container processes\nlabel=level:\nLEVEL\n: Set the label level for the container processes\nlabel=filetype:\nTYPE\n: Set the label file type for the container files\nlabel=disable\n: Turn off label separation for the container\nNote: Labeling can be disabled for all containers by setting label=false in the\ncontainers.conf\n(\n/etc/containers/containers.conf\nor\n$HOME/.config/containers/containers.conf\n) file.\nlabel=nested\n: Allows SELinux modifications within the container. Containers are allowed to modify SELinux labels on files and processes, as long as SELinux policy allows. Without\nnested\n, containers view SELinux as disabled, even when it is enabled on the host. Containers are prevented from setting any labels.\nmask\n=\n/path/1:/path/2\n: The paths to mask separated by a colon. A masked path cannot be accessed inside the container.\nno-new-privileges\n: Disable container processes from gaining additional privileges through the\nexecve(2)\nsystem call (e.g. via setuid or setgid bits, or via file capabilities). Programs that rely on setuid/setgid bits set on their executable to change user id or group id are no longer able to do so, and any file capabilities added to the executable (e.g. via\nsetcap\n) are not added to the permitted capability set. For more details, see: https://docs.kernel.org/userspace-api/no_new_privs.html.\nseccomp=unconfined\n: Turn off seccomp confinement for the container.\nseccomp=profile.json\n: JSON file to be used as a seccomp filter. Note that the\nio.podman.annotations.seccomp\nannotation is set with the specified value as shown in\npodman\ninspect\n.\nproc-opts\n=\nOPTIONS\n: Comma-separated list of options to use for the /proc mount. More details\nfor the possible mount options are specified in the\nproc(5)\nman page.\nunmask\n=\nALL\nor\n/path/1:/path/2\n, or shell expanded paths (/proc/*): Paths to unmask separated by a colon. If set to\nALL\n, it unmasks all the paths that are masked or made read-only by default.\nThe default masked paths are\n/proc/acpi, /proc/kcore, /proc/keys, /proc/latency_stats, /proc/sched_debug, /proc/scsi, /proc/timer_list, /proc/timer_stats, /sys/firmware, and /sys/fs/selinux\n,\n/sys/devices/virtual/powercap\n.  The default paths that are read-only are\n/proc/asound\n,\n/proc/bus\n,\n/proc/fs\n,\n/proc/irq\n,\n/proc/sys\n,\n/proc/sysrq-trigger\n,\n/sys/fs/cgroup\n.\nNote: Labeling can be disabled for all containers by setting\nlabel=false\nin the\ncontainers.conf\n(5) file.\n--shm-size\n=\nnumber[unit]\n¶\nSize of\n/dev/shm\n. A\nunit\ncan be\nb\n(bytes),\nk\n(kibibytes),\nm\n(mebibytes), or\ng\n(gibibytes).\nIf the unit is omitted, the system uses bytes. If the size is omitted, the default is\n64m\n.\nWhen\nsize\nis\n0\n, there is no limit on the amount of memory used for IPC by the container.\nThis option conflicts with\n--ipc=host\n.\n--shm-size-systemd\n=\nnumber[unit]\n¶\nSize of systemd-specific tmpfs mounts such as /run, /run/lock, /var/log/journal and /tmp.\nA\nunit\ncan be\nb\n(bytes),\nk\n(kibibytes),\nm\n(mebibytes), or\ng\n(gibibytes).\nIf the unit is omitted, the system uses bytes. If the size is omitted, the default is\n64m\n.\nWhen\nsize\nis\n0\n, the usage is limited to 50% of the host’s available memory.\n--sig-proxy\n¶\nProxy received signals to the container process. SIGCHLD, SIGURG, SIGSTOP, and SIGKILL are not proxied.\nThe default is\ntrue\n.\n--stop-signal\n=\nsignal\n¶\nSignal to stop a container. Default is\nSIGTERM\n.\n--stop-timeout\n=\nseconds\n¶\nTimeout to stop a container. Default is\n10\n.\nRemote connections use local containers.conf for defaults.\n--subgidname\n=\nname\n¶\nRun the container in a new user namespace using the map with\nname\nin the\n/etc/subgid\nfile.\nIf running rootless, the user needs to have the right to use the mapping. See\nsubgid\n(5).\nThis flag conflicts with\n--userns\nand\n--gidmap\n.\n--subuidname\n=\nname\n¶\nRun the container in a new user namespace using the map with\nname\nin the\n/etc/subuid\nfile.\nIf running rootless, the user needs to have the right to use the mapping. See\nsubuid\n(5).\nThis flag conflicts with\n--userns\nand\n--uidmap\n.\n--sysctl\n=\nname=value\n¶\nConfigure namespaced kernel parameters at runtime.\nFor the IPC namespace, the following sysctls are allowed:\nkernel.msgmax\nkernel.msgmnb\nkernel.msgmni\nkernel.sem\nkernel.shmall\nkernel.shmmax\nkernel.shmmni\nkernel.shm_rmid_forced\nSysctls beginning with fs.mqueue.*\nNote: if using the\n--ipc=host\noption, the above sysctls are not allowed.\nFor the network namespace, only sysctls beginning with net.* are allowed.\nNote: if using the\n--network=host\noption, the above sysctls are not allowed.\n--systemd\n=\ntrue\n|\nfalse\n|\nalways\n¶\nRun container in systemd mode. The default is\ntrue\n.\ntrue\nenables systemd mode only when the command executed inside the container is\nsystemd\n,\n/usr/sbin/init\n,\n/sbin/init\nor\n/usr/local/sbin/init\n.\nfalse\ndisables systemd mode.\nalways\nenforces the systemd mode to be enabled.\nRunning the container in systemd mode causes the following changes:\nPodman mounts tmpfs file systems on the following directories\n/run\n/run/lock\n/tmp\n/sys/fs/cgroup/systemd\n(on a cgroup v1 system)\n/var/lib/journal\nPodman sets the default stop signal to\nSIGRTMIN+3\n.\nPodman sets\ncontainer_uuid\nenvironment variable in the container to the\nfirst 32 characters of the container ID.\nPodman does not mount virtual consoles (\n/dev/tty\\d+\n) when running with\n--privileged\n.\nOn cgroup v2,\n/sys/fs/cgroup\nis mounted writable.\nThis allows systemd to run in a confined container without any modifications.\nNote that on\nSELinux\nsystems, systemd attempts to write to the cgroup\nfile system. Containers writing to the cgroup file system are denied by default.\nThe\ncontainer_manage_cgroup\nboolean must be enabled for this to be allowed on an SELinux separated system.\nsetsebool\n-\nP\ncontainer_manage_cgroup\ntrue\n--timeout\n=\nseconds\n¶\nMaximum time a container is allowed to run before conmon sends it the kill\nsignal.  By default containers run until they exit or are stopped by\npodman\nstop\n.\n--tls-verify\n¶\nRequire HTTPS and verify certificates when contacting registries (default:\ntrue\n).\nIf explicitly set to\ntrue\n, TLS verification is used.\nIf set to\nfalse\n, TLS verification is not used.\nIf not specified, TLS verification is used unless the target registry\nis listed as an insecure registry in\ncontainers-registries.conf(5)\n--tmpfs\n=\nfs\n¶\nCreate a tmpfs mount.\nMount a temporary filesystem (\ntmpfs\n) mount into a container, for example:\n$ podman run -d --tmpfs /tmp:rw,size=787448k,mode=1777 my_image\nThis command mounts a\ntmpfs\nat\n/tmp\nwithin the container. The supported mount\noptions are the same as the Linux default mount flags. If no options are specified,\nthe system uses the following options:\nrw,noexec,nosuid,nodev\n.\n--tty\n,\n-t\n¶\nAllocate a pseudo-TTY. The default is\nfalse\n.\nWhen set to\ntrue\n, Podman allocates a pseudo-tty and attach to the standard\ninput of the container. This can be used, for example, to run a throwaway\ninteractive shell.\nNOTE\n: The --tty flag prevents redirection of standard output.  It combines STDOUT and STDERR, it can insert control characters, and it can hang pipes. This option is only used when run interactively in a terminal. When feeding input to Podman, use -i only, not -it.\necho\n\"asdf\"\n|\npodman\nrun\n--\nrm\n-\ni\nsomeimage\n/\nbin\n/\ncat\n--tz\n=\ntimezone\n¶\nSet timezone in container. This flag takes area-based timezones, GMT time, as well as\nlocal\n, which sets the timezone in the container to match the host machine. See\n/usr/share/zoneinfo/\nfor valid timezones.\nRemote connections use local containers.conf for defaults\n--uidmap\n=\n[flags]container_uid:from_uid[:amount]\n¶\nRun the container in a new user namespace using the supplied UID mapping. This\noption conflicts with the\n--userns\nand\n--subuidname\noptions. This\noption provides a way to map host UIDs to container UIDs. It can be passed\nseveral times to map different ranges.\nThe possible values of the optional\nflags\nare discussed further down on this page.\nThe\namount\nvalue is optional and assumed to be\n1\nif not given.\nThe\nfrom_uid\nvalue is based upon the user running the command, either rootful or rootless users.\nrootful user:  [\nflags\n]\ncontainer_uid\n:\nhost_uid\n[:\namount\n]\nrootless user: [\nflags\n]\ncontainer_uid\n:\nintermediate_uid\n[:\namount\n]\nRootful\nmappings\nWhen\npodman run\nis called by a privileged user, the option\n--uidmap\nworks as a direct mapping between host UIDs and container UIDs.\nhost UID -> container UID\nThe\namount\nspecifies the number of consecutive UIDs that is mapped.\nIf for example\namount\nis\n4\nthe mapping looks like:\nhost UID\ncontainer UID\nfrom_uid\ncontainer_uid\nfrom_uid\n+ 1\ncontainer_uid\n+ 1\nfrom_uid\n+ 2\ncontainer_uid\n+ 2\nfrom_uid\n+ 3\ncontainer_uid\n+ 3\nRootless\nmappings\nWhen\npodman run\nis called by an unprivileged user (i.e. running rootless),\nthe value\nfrom_uid\nis interpreted as an “intermediate UID”. In the rootless\ncase, host UIDs are not mapped directly to container UIDs. Instead the mapping\nhappens over two mapping steps:\nhost UID -> intermediate UID -> container UID\nThe\n--uidmap\noption only influences the second mapping step.\nThe first mapping step is derived by Podman from the contents of the file\n/etc/subuid\nand the UID of the user calling Podman.\nFirst mapping step:\nhost UID\nintermediate UID\nUID for Podman user\n0\n1st subordinate UID\n1\n2nd subordinate UID\n2\n3rd subordinate UID\n3\nnth subordinate UID\nn\nTo be able to use intermediate UIDs greater than zero, the user needs to have\nsubordinate UIDs configured in\n/etc/subuid\n. See\nsubuid\n(5).\nThe second mapping step is configured with\n--uidmap\n.\nIf for example\namount\nis\n5\nthe second mapping step looks like:\nintermediate UID\ncontainer UID\nfrom_uid\ncontainer_uid\nfrom_uid\n+ 1\ncontainer_uid\n+ 1\nfrom_uid\n+ 2\ncontainer_uid\n+ 2\nfrom_uid\n+ 3\ncontainer_uid\n+ 3\nfrom_uid\n+ 4\ncontainer_uid\n+ 4\nWhen running as rootless, Podman uses all the ranges configured in the\n/etc/subuid\nfile.\nThe current user ID is mapped to UID=0 in the rootless user namespace.\nEvery additional range is added sequentially afterward:\nhost\nrootless user namespace\nlength\n$UID\n0\n1\n1\n$FIRST_RANGE_ID\n$FIRST_RANGE_LENGTH\n1+$FIRST_RANGE_LENGTH\n$SECOND_RANGE_ID\n$SECOND_RANGE_LENGTH\nReferencing\na\nhost\nID\nfrom\nthe\nparent\nnamespace\nAs a rootless user, the given host ID in\n--uidmap\nor\n--gidmap\nis mapped from the\nintermediate namespace\ngenerated by Podman. Sometimes\nit is desirable to refer directly at the\nhost namespace\n. It is possible\nto manually do so, by running\npodman\nunshare\ncat\n/proc/self/gid_map\n,\nfinding the desired host id at the second column of the output, and getting\nthe corresponding intermediate id from the first column.\nPodman can perform all that by preceding the host id in the mapping\nwith the\n@\nsymbol. For instance, by specifying\n--gidmap\n100000:@2000:1\n,\npodman will look up the intermediate id corresponding to host id\n2000\nand\nit will map the found intermediate id to the container id\n100000\n. The\ngiven host id must have been subordinated (otherwise it would not be mapped\ninto the intermediate space in the first place).\nIf the length is greater than one, for instance with\n--gidmap\n100000:@2000:2\n,\nPodman will map host ids\n2000\nand\n2001\nto\n100000\nand\n100001\n, respectively,\nregardless of how the intermediate mapping is defined.\nExtending\nprevious\nmappings\nSome mapping modifications may be cumbersome. For instance, a user\nstarts with a mapping such as\n--gidmap=\"0:0:65000\"\n, that needs to be\nchanged such as the parent id\n1\nis mapped to container id\n100000\ninstead, leaving container id\n1\nunassigned. The corresponding\n--gidmap\nbecomes\n--gidmap=\"0:0:1\"\n--gidmap=\"2:2:65534\"\n--gidmap=\"100000:1:1\"\n.\nThis notation can be simplified using the\n+\nflag, that takes care of\nbreaking previous mappings removing any conflicting assignment with\nthe given mapping. The flag is given before the container id\nas follows:\n--gidmap=\"0:0:65000\"\n--gidmap=\"+100000:1:1\"\nFlag\nExample\nDescription\n+\n+100000:1:1\nExtend the previous mapping\nThis notation leads to gaps in the assignment, so it may be convenient to\nfill those gaps afterwards:\n--gidmap=\"0:0:65000\"\n--gidmap=\"+100000:1:1\"\n--gidmap=\"1:65001:1\"\nOne specific use case for this flag is in the context of rootless\nusers. A rootless user may specify mappings with the\n+\nflag as\nin\n--gidmap=\"+100000:1:1\"\n. Podman will then “fill the gaps” starting\nfrom zero with all the remaining intermediate ids. This is convenient when\na user wants to map a specific intermediate id to a container id, leaving\nthe rest of subordinate ids to be mapped by Podman at will.\nPassing\nonly\none\nof\n--uidmap\nor\n--gidmap\nUsually, subordinated user and group ids are assigned simultaneously, and\nfor any user the subordinated user ids match the subordinated group ids.\nFor convenience, if only one of\n--uidmap\nor\n--gidmap\nis given,\npodman assumes the mapping refers to both UIDs and GIDs and applies the\ngiven mapping to both. If only one value of the two needs to be changed,\nthe mappings should include the\nu\nor the\ng\nflags to specify that\nthey only apply to UIDs or GIDs and should not be copied over.\nflag\nExample\nDescription\nu\nu20000:2000:1\nThe mapping only applies to UIDs\ng\ng10000:1000:1\nThe mapping only applies to GIDs\nFor instance given the command\npodman run --gidmap \"0:0:1000\" --gidmap \"g2000:2000:1\"\nSince no\n--uidmap\nis given, the\n--gidmap\nis copied to\n--uidmap\n,\ngiving a command equivalent to\npodman run --gidmap \"0:0:1000\" --gidmap \"2000:2000:1\" --uidmap \"0:0:1000\"\nThe\n--gidmap\n\"g2000:2000:1\"\nused the\ng\nflag and therefore it was\nnot copied to\n--uidmap\n.\nRootless\nmapping\nof\nadditional\nhost\nGIDs\nA rootless user may desire to map a specific host group that has already been\nsubordinated within\n/etc/subgid\nwithout specifying the rest of the mapping.\nThis can be done with\n--gidmap “+g\ncontainer_gid\n:@\nhost_gid\n”\nWhere:\nThe host GID is given through the\n@\nsymbol\nThe mapping of this GID is not copied over to\n--usermap\nthanks to the\ng\nflag.\nThe rest of the container IDs will be mapped starting from 0 to n,\nwith all the remaining subordinated GIDs, thanks to the\n+\nflag.\nFor instance, if a user belongs to the group\n2000\nand that group is\nsubordinated to that user (with\nusermod\n--add-subgids\n2000-2000\n$USER\n),\nthe user can map the group into the container with:\n--gidmap=+g100000:@2000\n.\nIf this mapping is combined with the option,\n--group-add=keep-groups\n, the\nprocess in the container will belong to group\n100000\n, and files belonging\nto group\n2000\nin the host will appear as being owned by group\n100000\ninside the container.\npodman run --group-add=keep-groups --gidmap=\"+g100000:@2000\" ...\nNo\nsubordinate\nUIDs\nEven if a user does not have any subordinate UIDs in\n/etc/subuid\n,\n--uidmap\ncan be used to map the normal UID of the user to a\ncontainer UID by running\npodman\nrun\n--uidmap\n$container_uid:0:1\n--user\n$container_uid\n...\n.\nPods\nThe\n--uidmap\noption cannot be called in conjunction with the\n--pod\noption as a uidmap cannot be set on the container level when in a pod.\n--ulimit\n=\noption\n¶\nUlimit options. Sets the ulimits values inside of the container.\n--ulimit with a soft and hard limit in the format\n=\n[:\n]. For example:\n$ podman run --ulimit nofile=1024:1024 --rm ubi9 ulimit -n\n1024\nSet -1 for the soft or hard limit to set the limit to the maximum limit of the current\nprocess. In rootful mode this is often unlimited.\nIf nofile and nproc are unset, a default value of 1048576 will be used, unless overridden\nin containers.conf(5).  However, if the default value exceeds the hard limit for the current\nrootless user, the current hard limit will be applied instead.\nUse\nhost\nto copy the current configuration from the host.\nDon’t use nproc with the ulimit flag as Linux uses nproc to set the\nmaximum number of processes available to a user, not to a container.\nUse the --pids-limit option to modify the cgroup control to limit the number\nof processes within a container.\n--umask\n=\numask\n¶\nSet the umask inside the container. Defaults to\n0022\n.\nRemote connections use the local\ncontainers.conf\nfor defaults.\n--unsetenv\n=\nenv\n¶\nUnset default environment variables for the container. Default environment\nvariables include variables provided natively by Podman, environment variables\nconfigured by the image, and environment variables from containers.conf.\n--unsetenv-all\n¶\nUnset all default environment variables for the container. Default environment\nvariables include variables provided natively by Podman, environment variables\nconfigured by the image, and environment variables from containers.conf.\n--user\n,\n-u\n=\nuser[:group]\n¶\nSets the username or UID used and, optionally, the groupname or GID for the specified command. Both\nuser\nand\ngroup\nmay be symbolic or numeric.\nWithout this argument, the command runs as the user specified in the container image. Unless overridden by a\nUSER\ncommand in the Containerfile or by a value passed to this option, this user generally defaults to root.\nWhen a user namespace is not in use, the UID and GID used within the container and on the host match. When user namespaces are in use, however, the UID and GID in the container may correspond to another UID and GID on the host. In rootless containers, for example, a user namespace is always used, and root in the container by default corresponds to the UID and GID of the user invoking Podman.\n--userns\n=\nmode\n¶\nSet the user namespace mode for the container.\nIf\n--userns\nis not set, the default value is determined as follows.\nIf\n--pod\nis set,\n--userns\nis ignored and the user namespace of the pod is used.\nIf the environment variable\nPODMAN_USERNS\nis set its value is used.\nIf\nuserns\nis specified in\ncontainers.conf\nthis value is used.\nOtherwise,\n--userns=host\nis assumed.\n--userns=\"\"\n(i.e., an empty string) is an alias for\n--userns=host\n.\nThis option is incompatible with\n--gidmap\n,\n--uidmap\n,\n--subuidname\nand\n--subgidname\n.\nRootless user --userns=Key mappings:\nKey\nHost User\nContainer User\nauto\n$UID\nnil (Host User UID is not mapped into container.)\nhost\n$UID\n0 (Default User account mapped to root user in container.)\nkeep-id\n$UID\n$UID (Map user account to same UID within container.)\nkeep-id:uid=200,gid=210\n$UID\n200:210 (Map user account to specified UID, GID value within container.)\nnomap\n$UID\nnil (Host User UID is not mapped into container.)\nValid\nmode\nvalues are:\nauto\n[:\nOPTIONS,…\n]: automatically create a unique user namespace.\nrootful\nmode\n: The\n--userns=auto\nflag requires that the user name\ncontainers\nbe specified in the /etc/subuid and /etc/subgid files, with an unused range of subordinate user IDs that Podman containers are allowed to allocate.  Example:\ncontainers:2147483647:2147483648\n.\nrootless\nmode\n: The users range from the /etc/subuid and /etc/subgid files will be used. Note running a single container without using --userns=auto will use the entire range of UIDs and not allow further subdividing. See subuid(5).\nPodman allocates unique ranges of UIDs and GIDs from the\ncontainers\nsubordinate user IDs. The size of the ranges is based on the number of UIDs required in the image. The number of UIDs and GIDs can be overridden with the\nsize\noption.\nThe option\n--userns=keep-id\nuses all the subuids and subgids of the user.\nThe option\n--userns=nomap\nuses all the subuids and subgids of the user except the user’s own ID.\nUsing\n--userns=auto\nwhen starting new containers does not work as long as any containers exist that were started with\n--userns=nomap\nor\n--userns=keep-id\nwithout limiting the user namespace size.\nValid\nauto\noptions:\ngidmapping\n=\nCONTAINER_GID:HOST_GID:SIZE\n: to force a GID mapping to be present in the user namespace.\nsize\n=\nSIZE\n: to specify an explicit size for the automatic user namespace. e.g.\n--userns=auto:size=8192\n. If\nsize\nis not specified,\nauto\nestimates a size for the user namespace.\nuidmapping\n=\nCONTAINER_UID:HOST_UID:SIZE\n: to force a UID mapping to be present in the user namespace.\nThe host UID and GID in\ngidmapping\nand\nuidmapping\ncan optionally be prefixed with the\n@\nsymbol.\nIn this case, podman will look up the intermediate ID corresponding to host ID and it will map the found intermediate ID to the container id.\nFor details see\n--uidmap\n.\ncontainer:\nid\n: join the user namespace of the specified container.\nhost\nor\n“”\n(empty string): run in the user namespace of the caller. The processes running in the container have the same privileges on the host as any other process launched by the calling user.\nkeep-id\n: creates a user namespace where the current user’s UID:GID are mapped to the same values in the container. For containers created by root, the current mapping is created into a new user namespace.\nIn addition, the init process within the container will run under the current user’s UID. This behavior overrides the image’s\nUSER\ninstruction unless you explicitly set\n--user\n.\nValid\nkeep-id\noptions:\nuid\n=UID: override the UID inside the container that is used to map the current user to.\ngid\n=GID: override the GID inside the container that is used to map the current user to.\nsize\n=SIZE: override the size of the configured user namespace.  It is useful to not saturate all the available IDs.  Not supported when running as root.\nnomap\n: creates a user namespace where the current rootless user’s UID:GID are not mapped into the container. This option is not allowed for containers created by the root user.\nns:\nnamespace\n: run the container in the given existing user namespace.\n--uts\n=\nmode\n¶\nSet the UTS namespace mode for the container. The following values are supported:\nhost\n: use the host’s UTS namespace inside the container.\nprivate\n: create a new namespace for the container (default).\nns:[path]\n: run the container in the given existing UTS namespace.\ncontainer:[container]\n: join the UTS namespace of the specified container.\n--variant\n=\nVARIANT\n¶\nUse\nVARIANT\ninstead of the default architecture variant of the container image. Some images can use multiple variants of the arm architectures, such as arm/v5 and arm/v7.\n--volume\n,\n-v\n=\n[[SOURCE-VOLUME|HOST-DIR:]CONTAINER-DIR[:OPTIONS]]\n¶\nCreate a bind mount. If\n-v\n/HOST-DIR:/CONTAINER-DIR\nis specified, Podman\nbind mounts\n/HOST-DIR\nfrom the host into\n/CONTAINER-DIR\nin the Podman\ncontainer. Similarly,\n-v\nSOURCE-VOLUME:/CONTAINER-DIR\nmounts the named\nvolume from the host into the container. If no such named volume exists,\nPodman creates one. If no source is given, the volume is created\nas an anonymously named volume with a randomly generated name, and is\nremoved when the container is removed via the\n--rm\nflag or\nthe\npodman\nrm\n--volumes\ncommand.\n(Note when using the remote client, including Mac and Windows (excluding WSL2) machines, the volumes are mounted from the remote server, not necessarily the client machine.)\nThe\nOPTIONS\nis a comma-separated list and can be one or more of:\nrw\n|\nro\nz\n|\nZ\n[\nO\n]\n[\nU\n]\n[\nno\n]\ncopy\n[\nno\n]\ndev\n[\nno\n]\nexec\n[\nno\n]\nsuid\n[\nr\n]\nbind\n[\nr\n]\nshared\n|[\nr\n]\nslave\n|[\nr\n]\nprivate\n[\nr\n]\nunbindable\n[1]\nidmap\n[=\noptions\n]\nThe\nCONTAINER-DIR\nmust be an absolute path such as\n/src/docs\n. The volume\nis mounted into the container at this directory.\nIf a volume source is specified, it must be a path on the host or the name of a\nnamed volume. Host paths are allowed to be absolute or relative; relative paths\nare resolved relative to the directory Podman is run in. If the source does not\nexist, Podman returns an error. Users must pre-create the source files or\ndirectories.\nAny source that does not begin with a\n.\nor\n/\nis treated as the name of\na named volume. If a volume with that name does not exist, it is created.\nVolumes created with names are not anonymous, and they are not removed by the\n--rm\noption and the\npodman\nrm\n--volumes\ncommand.\nSpecify multiple\n-v\noptions to mount one or more volumes into a\ncontainer.\nWrite\nProtected\nVolume\nMounts\nAdd\n:ro\nor\n:rw\noption to mount a volume in read-only or\nread-write mode, respectively. By default, the volumes are mounted read-write.\nSee examples.\nChowning\nVolume\nMounts\nWhen a named volume is first mounted to a container, Podman\nautomatically adjusts the ownership of the volume’s mount point during\ncontainer initialization. This chown operation occurs under the\nfollowing conditions:\nThe volume was not used yet (has\nNeedsChown\nset to true)\nThe volume is empty or has not been copied up yet\nThe volume is not managed by an external volume driver\nThe volume driver is not “image”\nFor volumes with idmapped mounts (using the\nidmap\noption), the\nownership change takes into account the container’s user namespace\nmappings, but the idmapped volume retains proper UID/GID mapping. For\nvolumes without idmapping, the mount point is chowned to match the\ncontainer’s process user and group, mapped to the host user namespace\nif user namespace remapping is enabled.\nIf a container is created in a new user namespace, the UID and\nGID in the container may correspond to another UID and GID on the host.\nThe\n:U\nsuffix tells Podman to use the correct host UID and GID based on the\nUID and GID within the container, to change recursively the owner and\ngroup of the source volume. Chowning walks the file system under the volume and\nchanges the UID/GID on each file. If the volume has thousands of inodes, this\nprocess takes a long time, delaying the start of the container.\nWarning\nuse with caution since this modifies the host filesystem.\nLabeling\nVolume\nMounts\nLabeling systems like SELinux require that proper labels are placed on volume\ncontent mounted into a container. Without a label, the security system\nmight prevent the processes running inside the container from using the\ncontent. By default, Podman does not change the labels set by the OS.\nTo change a label in the container context, add either of two suffixes\n:z\nor\n:Z\nto the volume mount. These suffixes tell Podman to relabel file\nobjects on the shared volumes. The\nz\noption tells Podman that two or more\ncontainers share the volume content. As a result, Podman labels the\ncontent with a shared content label. Shared volume labels allow all containers\nto read/write content. The\nZ\noption tells Podman to label the content with\na private unshared label. Only the current container can use a private\nvolume.\nNote: all containers within a\npod\nshare the same SELinux label. This\nmeans all containers within said pod can read/write volumes shared into the\ncontainer created with the\n:Z\non any one of the containers. Relabeling walks\nthe file system under the volume and changes the label on each file; if the\nvolume has thousands of inodes, this process takes a long time, delaying the\nstart of the container. If the volume was previously relabeled with the\nz\noption, Podman is optimized to not relabel a second time. If files are\nmoved into the volume, then the labels can be manually changed with the\nchcon\n-Rt\ncontainer_file_t\nPATH\ncommand.\nNote: Do not relabel system files and directories. Relabeling system content\nmight cause other confined services on the machine to fail.  For these types\nof containers we recommend disabling SELinux separation.  The option\n--security-opt label=disable\ndisables SELinux separation for the container.\nFor example if a user wanted to volume mount their entire home directory into a\ncontainer, they need to disable SELinux separation.\n$ podman run --security-opt label=disable -v $HOME:/home/user fedora touch /home/user/file\nOverlay\nVolume\nMounts\nThe\n:O\nflag tells Podman to mount the directory from the host as a\ntemporary storage using the\noverlay\nfile\nsystem\n. The container processes\ncan modify content within the mountpoint which is stored in the\ncontainer storage in a separate directory. In overlay terms, the source\ndirectory is the lower, and the container storage directory is the\nupper. Modifications to the mount point are destroyed when the container\nfinishes executing, similar to a tmpfs mount point being unmounted.\nFor advanced users, the\noverlay\noption also supports custom non-volatile\nupperdir\nand\nworkdir\nfor the overlay mount. Custom\nupperdir\nand\nworkdir\ncan be fully managed by the users themselves, and Podman does not\nremove it on lifecycle completion.\nExample\n:O,upperdir=/some/upper,workdir=/some/work\nSubsequent executions of the container sees the original source directory\ncontent, any changes from previous container executions no longer exist.\nOne use case of the overlay mount is sharing the package cache from the\nhost into the container to allow speeding up builds.\nNote: The\nO\nflag conflicts with other options listed above.\nContent mounted into the container is labeled with the private label.\nOn SELinux systems, labels in the source directory must be readable\nby the  container label. Usually containers can read/execute\ncontainer_share_t\nand can read/write\ncontainer_file_t\n. If unable to change the labels on a\nsource volume, SELinux container separation must be disabled for the  container\nto work.\nDo not modify the source directory mounted into the container with an overlay mount,\nit can cause unexpected failures. Only modify the directory after the container finishes running.\nMounts\npropagation\nBy default, bind-mounted volumes are\nprivate\n. That means any mounts done\ninside the container are not visible on the host and vice versa.\nOne can change this behavior by specifying a volume mount propagation property.\nWhen a volume is\nshared\n, mounts done under that volume inside the container\nare visible on host and vice versa. Making a volume\nslave\n[1]\nenables only one-way mount propagation: mounts done on the host under that volume\nare visible inside the container but not the other way around.\nTo control mount propagation property of a volume one can use the [\nr\n]\nshared\n,\n[\nr\n]\nslave\n, [\nr\n]\nprivate\nor the [\nr\n]\nunbindable\npropagation flag.\nPropagation property can be specified only for bind mounted volumes and not for\ninternal volumes or named volumes. For mount propagation to work the source mount\npoint (the mount point where source dir is mounted on) has to have the right propagation\nproperties. For shared volumes, the source mount point has to be shared. And for\nslave volumes, the source mount point has to be either shared or slave.\n[1]\nTo recursively mount a volume and all of its submounts into a\ncontainer, use the\nrbind\noption. By default the bind option is\nused, and submounts of the source directory is not mounted into the\ncontainer.\nMounting the volume with a\ncopy\noption tells podman to copy content from\nthe underlying destination directory onto newly created internal volumes. The\ncopy\nonly happens on the initial creation of the volume. Content is not\ncopied up when the volume is subsequently used on different containers. The\ncopy\noption is ignored on bind mounts and has no effect.\nMounting volumes with the\nnosuid\noptions means that SUID executables on the\nvolume can not be used by applications to change their privilege. By default\nvolumes are mounted with\nnosuid\n.\nMounting the volume with the\nnoexec\noption means that no executables on the\nvolume can be executed within the container.\nMounting the volume with the\nnodev\noption means that no devices on the volume\ncan be used by processes within the container. By default volumes\nare mounted with\nnodev\n.\nIf the\nHOST-DIR\nis a mount point, then\ndev\n,\nsuid\n, and\nexec\noptions are\nignored by the kernel.\nUse\ndf HOST-DIR\nto figure out the source mount, then use\nfindmnt -o TARGET,PROPAGATION\nsource-mount-dir\nto figure out propagation\nproperties of source mount. If\nfindmnt\n(1) utility is not available, then one\ncan look at the mount entry for the source mount point in\n/proc/self/mountinfo\n. Look\nat the “optional fields” and see if any propagation properties are specified.\nIn there,\nshared:N\nmeans the mount is shared,\nmaster:N\nmeans mount\nis slave, and if nothing is there, the mount is private.\n[1]\nTo change propagation properties of a mount point, use\nmount\n(8) command. For\nexample, if one wants to bind mount source directory\n/foo\n, one can do\nmount --bind /foo /foo\nand\nmount --make-private --make-shared /foo\n. This\nconverts /foo into a shared mount point. Alternatively, one can directly\nchange propagation properties of source mount. Say\n/\nis source mount for\n/foo\n, then use\nmount --make-shared /\nto convert\n/\ninto a shared mount.\nNote: if the user only has access rights via a group, accessing the volume\nfrom inside a rootless container fails.\nIdmapped\nmount\nIf\nidmap\nis specified, create an idmapped mount to the target user\nnamespace in the container. The idmap option supports a custom mapping\nthat can be different than the user namespace used by the\ncontainer. The mapping can be specified after the idmap option like:\nidmap=uids=0-1-10#10-11-10;gids=0-100-10\n.\nFor each triplet, the first value is the start of the backing file\nsystem IDs that are mapped to the second value on the host.  The\nlength of this mapping is given in the third value.\nMultiple ranges are separated with #.\nUse the\n--group-add keep-groups\noption to pass the user’s supplementary group access into the container.\n--volumes-from\n=\nCONTAINER[:OPTIONS]\n¶\nMount volumes from the specified container(s). Used to share volumes between\ncontainers. The\noptions\nis a comma-separated list with the following available elements:\nrw\n|\nro\nz\nMounts already mounted volumes from a source container onto another\ncontainer.\nCONTAINER\nmay be a name or ID.\nTo share a volume, use the --volumes-from option when running\nthe target container. Volumes can be shared even if the source container\nis not running.\nBy default, Podman mounts the volumes in the same mode (read-write or\nread-only) as it is mounted in the source container.\nThis can be changed by adding a\nro\nor\nrw\noption\n.\nLabeling systems like SELinux require that proper labels are placed on volume\ncontent mounted into a container. Without a label, the security system might\nprevent the processes running inside the container from using the content. By\ndefault, Podman does not change the labels set by the OS.\nTo change a label in the container context, add\nz\nto the volume mount.\nThis suffix tells Podman to relabel file objects on the shared volumes. The\nz\noption tells Podman that two entities share the volume content. As a result,\nPodman labels the content with a shared content label. Shared volume labels allow\nall containers to read/write content.\nIf the location of the volume from the source container overlaps with\ndata residing on a target container, then the volume hides\nthat data on the target.\n--workdir\n,\n-w\n=\ndir\n¶\nWorking directory inside the container.\nThe default working directory for running binaries within a container is the root directory (\n/\n).\nThe image developer can set a different default with the WORKDIR instruction. The operator\ncan override the working directory by using the\n-w\noption.\nExit Status\n¶\nThe exit code from\npodman run\ngives information about why the container\nfailed to run or why it exited. When\npodman run\nexits with a non-zero code,\nthe exit codes follow the\nchroot\n(1) standard, see below:\n125\nThe error is with Podman itself\n$ podman run --foo busybox; echo $?\nError: unknown flag: --foo\n125\n126\nThe\ncontained command\ncannot be invoked\n$ podman run busybox /etc; echo $?\nError: container_linux.go:346: starting container process caused \"exec: \\\"/etc\\\": permission denied\": OCI runtime error\n126\n127\nThe\ncontained command\ncannot be found\n$ podman run busybox foo; echo $?\nError: container_linux.go:346: starting container process caused \"exec: \\\"foo\\\": executable file not found in $PATH\": OCI runtime error\n127\nExit code\ncontained command\nexit code\n$ podman run busybox /bin/sh -c 'exit 3'; echo $?\n3\nEXAMPLES\n¶\nRunning container in read-only mode\n¶\nDuring container image development, containers often need to write to the image\ncontent. Installing packages into\n/usr\n, for example. In production,\napplications seldom need to write to the image.  Container applications write\nto volumes if they need to write to file systems at all. Applications can be\nmade more secure by running them in read-only mode using the\n--read-only\nswitch.\nThis protects the container’s image from modification. By default read-only\ncontainers can write to temporary data. Podman mounts a tmpfs on\n/run\nand\n/tmp\nwithin the container.\n$ podman run --read-only -i -t fedora /bin/bash\nIf the container does not write to any file\nsystem within the container, including tmpfs, set --read-only-tmpfs=false.\n$ podman run --read-only --read-only-tmpfs=false --tmpfs /run -i -t fedora /bin/bash\nExposing shared libraries inside of container as read-only using a glob\n¶\n$ podman run --mount type=glob,src=/usr/lib64/libnvidia\\*,ro=true -i -t fedora /bin/bash\nExposing log messages from the container to the host’s log\n¶\nBind mount the\n/dev/log\ndirectory to have messages that are logged in the container  show up in the host’s\nsyslog/journal.\n$ podman run -v /dev/log:/dev/log -i -t fedora /bin/bash\nFrom inside the container test this by sending a message to the log.\n(\nbash\n)\n# logger \"Hello from my container\"\nThen exit and check the journal.\n(bash)# exit\n$ journalctl -b | grep Hello\nThis lists the message sent to the logger.\nAttaching to one or more from STDIN, STDOUT, STDERR\n¶\nWithout specifying the\n-a\noption, Podman attaches everything (stdin, stdout, stderr).\nOverride the default by specifying -a (stdin, stdout, stderr), as in:\n$ podman run -a stdin -a stdout -i -t fedora /bin/bash\nSharing IPC between containers\n¶\nUsing\nshm_server.c\navailable here: https://www.cs.cf.ac.uk/Dave/C/node27.html\nTesting\n--ipc=host\nmode:\nHost shows a shared memory segment with 7 pids attached, happens to be from httpd:\n$ sudo ipcs -m\n------ Shared Memory Segments --------\nkey        shmid      owner      perms      bytes      nattch     status\n0x01128e25 0          root       600        1000       7\nNow run a regular container, and it correctly does NOT see the shared memory segment from the host:\n$ podman run -it shm ipcs -m\n------ Shared Memory Segments --------\nkey        shmid      owner      perms      bytes      nattch     status\nRun a container with the new\n--ipc=host\noption, and it now sees the shared memory segment from the host httpd:\n$ podman run -it --ipc=host shm ipcs -m\n------ Shared Memory Segments --------\nkey        shmid      owner      perms      bytes      nattch     status\n0x01128e25 0          root       600        1000       7\nTesting\n--ipc=container:\nid\nmode:\nStart a container with a program to create a shared memory segment:\n$ podman run -it shm bash\n$ sudo shm/shm_server &\n$ sudo ipcs -m\n------ Shared Memory Segments --------\nkey        shmid      owner      perms      bytes      nattch     status\n0x0000162e 0          root       666        27         1\nCreate a 2nd container correctly shows no shared memory segment from 1st container:\n$ podman run shm ipcs -m\n------ Shared Memory Segments --------\nkey        shmid      owner      perms      bytes      nattch     status\nCreate a 3rd container using the\n--ipc=container:\nid\noption, now it shows the shared memory segment from the first:\n$ podman run -it --ipc=container:ed735b2264ac shm ipcs -m\n$ sudo ipcs -m\n------ Shared Memory Segments --------\nkey        shmid      owner      perms      bytes      nattch     status\n0x0000162e 0          root       666        27         1\nMapping Ports for External Usage\n¶\nThe exposed port of an application can be mapped to a host port using the\n-p\nflag. For example, an httpd port 80 can be mapped to the host port 8080 using the\nfollowing:\n$ podman run -p 8080:80 -d -i -t fedora/httpd\nMounting External Volumes\n¶\nTo mount a host directory as a container volume, specify the absolute path to\nthe directory and the absolute path for the container directory separated by a\ncolon. If the source is a named volume maintained by Podman, it is recommended to\nuse its name rather than the path to the volume. Otherwise the volume is\nconsidered an orphan and wiped by the\npodman volume prune\ncommand:\n$ podman run -v /var/db:/data1 -i -t fedora bash\n$ podman run -v data:/data2 -i -t fedora bash\n$ podman run -v /var/cache/dnf:/var/cache/dnf:O -ti fedora dnf -y update\nIf the container needs a writable mounted volume by a non root user inside the container, use the\nU\noption. This option tells Podman to chown the source volume to match the default UID and GID used within the container.\n$ podman run -d -e MARIADB_ROOT_PASSWORD=root --user mysql --userns=keep-id -v ~/data:/var/lib/mysql:Z,U mariadb\nAlternatively if the container needs a writable volume by a non root\nuser inside of the container, the --userns=keep-id option allows users to\nspecify the UID and GID of the user executing Podman to specific UIDs and GIDs\nwithin the container. Since the processes running in the container run as the user’s UID, they can read/write files owned by the user.\n$ podman run -d -e MARIADB_ROOT_PASSWORD=root --user mysql --userns=keep-id:uid=999,gid=999 -v ~/data:/var/lib/mysql:Z mariadb\nUsing\n--mount\nflags to mount a host directory as a container folder, specify\nthe absolute path to the directory or the volume name, and the absolute path\nwithin the container directory:\n$ podman run --mount type=bind,src=/var/db,target=/data1 busybox sh\n$ podman run --mount type=bind,src=volume-name,target=/data1 busybox sh\nThe\n--mount\nflag provides a structured, key-value style for defining mounts\ninside containers. It is similar in purpose to\n-v\nor\n--volume\n, but offers\ngreater clarity for complex or multi-option configurations. The general syntax\nis:\n--\nmount\ntype\n=<\nTYPE\n>\n,\nsrc\n=<\nSOURCE\n>\n,\ndst\n=<\nTARGET\n>\n[,\noptions\n...\n]\nSupported mount types include\nbind\n,\nvolume\n,\ntmpfs\n,\nartifact\n,\ndevpts\n,\nimage\n,\nglob\n, and\nramfs\n. Each type serves a different\npurpose in how data is attached to the container.\nBind mounts\n¶\nBind mounts directly link a directory or file on the host into the container.\nChanges made in one are immediately visible in the other. Use bind mounts when\nboth the host and container need access to the same files, such as configuration\nfiles or source code.\nExample:\npodman\nrun\n--\nmount\ntype\n=\nbind\n,\nsrc\n=/\netc\n/\nconfig\n,\ndst\n=/\napp\n/\nconfig\nalpine\ncat\n/\napp\n/\nconfig\n/\nfile\n.\nconf\nVolume mounts\n¶\nVolume mounts use Podman-managed named volumes that persist independently of\ncontainers. They are ideal for persistent data such as databases or logs and are\nisolated from direct host paths.\nExample:\npodman\nvolume\ncreate\nmydata\npodman\nrun\n--\nmount\ntype\n=\nvolume\n,\nsrc\n=\nmydata\n,\ndst\n=/\nvar\n/\nlib\n/\ndata\npostgres\nTmpfs mounts\n¶\nA tmpfs mount creates an in-memory filesystem on the host that is mounted inside\nthe container. Data stored here is temporary and removed when the container\nstops or the host reboots. tmpfs mounts are useful for temporary caches or\nsensitive data that should not persist to disk.\nExample:\npodman\nrun\n--\nmount\ntype\n=\ntmpfs\n,\ndst\n=/\ncache\n,\ntmpfs\n-\nsize\n=\n64\nm\nalpine\nArtifact, devpts, image, glob, and ramfs mounts\n¶\nOther specialized mount types are available for advanced use cases:\nartifact\n- Mounts read-only content from a container image or artifact.\ndevpts\n- Provides a pseudo-terminal device inside the container.\nimage\n- Mounts files directly from another container image.\nglob\n- Mounts multiple host files matching a glob pattern.\nramfs\n- Similar to tmpfs but backed directly by system RAM without size limits.\nThese mount types are less commonly used and often appear in internal or\nadvanced Podman workflows.\nIn summary,\n--mount\nprovides a single consistent interface for connecting\nexternal storage to containers. Choose the mount type that best fits your use\ncase:\nbind\nfor direct host access,\nvolume\nfor persistent data managed by\nPodman, and\ntmpfs\nfor ephemeral in-memory storage.\nWhen using SELinux, be aware that the host has no knowledge of container SELinux\npolicy. Therefore, in the above example, if SELinux policy is enforced, the\n/var/db\ndirectory is not writable to the container. A “Permission Denied”\nmessage occurs, and an\navc:\nmessage is added to the host’s syslog.\nTo work around this, at time of writing this man page, the following command\nneeds to be run in order for the proper SELinux policy type label to be attached\nto the host directory:\n$ chcon -Rt svirt_sandbox_file_t /var/db\nNow, writing to the\n/data1\nvolume in the container is allowed and the\nchanges are reflected on the host in\n/var/db\n.\nUsing alternative security labeling\n¶\nOverride the default labeling scheme for each container by specifying\nthe\n--security-opt\nflag. For example, specify the MCS/MLS level, a\nrequirement for MLS systems. Specifying the level in the following command\nallows the same content to be shared between containers.\npodman\nrun\n--\nsecurity\n-\nopt\nlabel\n=\nlevel\n:\ns0\n:\nc100\n,\nc200\n-\ni\n-\nt\nfedora\nbash\nAn MLS example might be:\n$ podman run --security-opt label=level:TopSecret -i -t rhel7 bash\nTo disable the security labeling for this container versus running with the\n--permissive\nflag, use the following command:\n¶\n$ podman run --security-opt label=disable -i -t fedora bash\nTighten the security policy on the processes within a container by specifying an\nalternate type for the container. For example, run a container\nthat is only allowed to listen on Apache ports by executing the following\ncommand:\n$ podman run --security-opt label=type:svirt_apache_t -i -t centos bash\nNote that an SELinux policy defining a\nsvirt_apache_t\ntype must be written.\nTo mask additional specific paths in the container, specify the paths\nseparated by a colon using the\nmask\noption with the\n--security-opt\nflag.\n$ podman run --security-opt mask=/foo/bar:/second/path fedora bash\nTo unmask all the paths that are masked by default, set the\nunmask\noption to\nALL\n. Or to only unmask specific paths, specify the paths as shown above with\nthe\nmask\noption.\n$ podman run --security-opt unmask=ALL fedora bash\nTo unmask all the paths that start with /proc, set the\nunmask\noption to\n/proc/\n*.\n$ podman run --security-opt unmask=/proc/* fedora bash\n$ podman run --security-opt unmask=/foo/bar:/sys/firmware fedora bash\nSetting device weight via\n--blkio-weight-device\nflag.\n¶\n$ podman run -it --blkio-weight-device \"/dev/sda:200\" ubuntu\nUsing a podman container with input from a pipe\n¶\n$ echo \"asdf\" | podman run --rm -i --entrypoint /bin/cat someimage\nasdf\nSetting automatic user namespace separated containers\n¶\n# podman run --userns=auto:size=65536 ubi8-micro cat /proc/self/uid_map\n0\n2147483647\n65536\n# podman run --userns=auto:size=65536 ubi8-micro cat /proc/self/uid_map\n0\n2147549183\n65536\nSetting Namespaced Kernel Parameters (Sysctls)\n¶\nThe\n--sysctl\nsets namespaced kernel parameters (sysctls) in the\ncontainer. For example, to turn on IP forwarding in the containers\nnetwork namespace, run this command:\n$ podman run --sysctl net.ipv4.ip_forward=1 someimage\nNote that not all sysctls are namespaced. Podman does not support changing sysctls\ninside of a container that also modify the host system. As the kernel\nevolves we expect to see more sysctls become namespaced.\nSee the definition of the\n--sysctl\noption above for the current list of\nsupported sysctls.\nSet UID/GID mapping in a new user namespace\n¶\nRunning a container in a new user namespace requires a mapping of\nthe UIDs and GIDs from the host.\n$ podman run --uidmap 0:30000:7000 --gidmap 0:30000:7000 fedora echo hello\nConfiguring Storage Options from the command line\n¶\nPodman allows for the configuration of storage by changing the values\nin the\n/etc/container/storage.conf\nor by using global options. This\nshows how to use an additional image store for a one-time run of busybox\nusing global options.\npodman\n--\nlog\n-\nlevel\n=\ndebug\n--\nstorage\n-\nopt\n\"additionalimagestore=/tmp/readonly-images\"\nrun\nbusybox\n/\nbin\n/\nsh\nConfigure timezone in a container\n¶\n$ podman run --tz=local alpine date\n$ podman run --tz=Asia/Shanghai alpine date\n$ podman run --tz=US/Eastern alpine date\nAdding dependency containers\n¶\nThe first container, container1, is not started initially, but must be running before container2 starts.\nThe\npodman\nrun\ncommand starts the container automatically before starting container2.\n$ podman create --name container1 -t -i fedora bash\n$ podman run --name container2 --requires container1 -t -i fedora bash\nMultiple containers can be required.\n$ podman create --name container1 -t -i fedora bash\n$ podman create --name container2 -t -i fedora bash\n$ podman run --name container3 --requires container1,container2 -t -i fedora bash\nConfigure keep supplemental groups for access to volume\n¶\n$ podman run -v /var/lib/design:/var/lib/design --group-add keep-groups ubi8\nConfigure execution domain for containers using personality flag\n¶\n$ podman run --name container1 --personality=LINUX32 fedora bash\nRun a container with external rootfs mounted as an overlay\n¶\n$ podman run --name container1 --rootfs /path/to/rootfs:O bash\nHandling Timezones in java applications in a container.\n¶\nIn order to use a timezone other than UTC when running a\nJava application within a container, the\nTZ\nenvironment variable must be\nset within the container. Java applications ignores the value set with the\n--tz\noption.\n# Example run\npodman\nrun\n-\nti\n--\nrm\n-\ne\nTZ\n=\nEST\nmytzimage\nlrwxrwxrwx\n.\n1\nroot\nroot\n29\nNov\n3\n08\n:\n51\n/\netc\n/\nlocaltime\n->\n../\nusr\n/\nshare\n/\nzoneinfo\n/\nEtc\n/\nUTC\nNow\nwith\ndefault\ntimezone\n:\nFri\nNov\n19\n18\n:\n10\n:\n55\nEST\n2021\nJava\ndefault\nsees\nthe\nfollowing\ntimezone\n:\n2021\n-\n11\n-\n19\nT18\n:\n10\n:\n55.651130\n-\n05\n:\n00\nForcing\nUTC\n:\nFri\nNov\n19\n23\n:\n10\n:\n55\nUTC\n2021\nRun a container connected to two networks (called net1 and net2) with a static ip\n¶\n$ podman run --network net1:ip=10.89.1.5 --network net2:ip=10.89.10.10 alpine ip addr\nRootless Containers\n¶\nPodman runs as a non-root user on most systems. This feature requires that a new enough version of\nshadow-utils\nbe installed. The\nshadow-utils\npackage must include the\nnewuidmap\n(1) and\nnewgidmap\n(1) executables.\nIn order for users to run rootless, there must be an entry for their username in\n/etc/subuid\nand\n/etc/subgid\nwhich lists the UIDs for their user namespace.\nRootless Podman works better if the fuse-overlayfs and slirp4netns packages are installed.\nThe\nfuse-overlayfs\npackage provides a userspace overlay storage driver, otherwise users need to use\nthe\nvfs\nstorage driver, which can be disk space expensive and less\nperformant than other drivers.\nTo enable VPN on the container, slirp4netns or pasta needs to be specified;\nwithout either, containers need to be run with the --network=host flag.\nENVIRONMENT\n¶\nEnvironment variables within containers can be set using multiple different options,\nin the following order of precedence (later entries override earlier entries):\nContainer image: Any environment variables specified in the container image.\n--http-proxy\n: By default, several environment variables are passed in from the host, such as\nhttp_proxy\nand\nno_proxy\n. See\n--http-proxy\nfor details.\n--env-host\n: Host environment of the process executing Podman is added.\n--env-file\n: Any environment variables specified via env-files. If multiple files are specified, then they override each other in order of entry.\n--env\n: Any environment variables specified overrides previous settings.\nRun containers and set the environment ending with a\n*\n.\nThe trailing\n*\nglob functionality is only active when no value is specified:\n$ export ENV1=a\n$ podman run --env 'ENV*' alpine env | grep ENV\nENV1=a\n$ podman run --env 'ENV*=b' alpine env | grep ENV\nENV*=b\nCONMON\n¶\nWhen Podman starts a container it actually executes the conmon program, which\nthen executes the OCI Runtime.  Conmon is the container monitor.  It is a small\nprogram whose job is to watch the primary process of the container, and if the\ncontainer dies, save the exit code.  It also holds open the tty of the\ncontainer, so that it can be attached to later. This is what allows Podman to\nrun in detached mode (backgrounded), so Podman can exit but conmon continues to\nrun.  Each container has their own instance of conmon. Conmon waits for the\ncontainer to exit, gathers and saves the exit code, and then launches a Podman\nprocess to complete the container cleanup, by shutting down the network and\nstorage.   For more information about conmon, see the conmon(8) man\npage.\nFILES\n¶\n/etc/subuid\n/etc/subgid\nNOTE: Use the environment variable\nTMPDIR\nto change the temporary storage location of downloaded container images. Podman defaults to use\n/var/tmp\n.\nSEE ALSO\n¶\npodman(1)\n,\npodman-save(1)\n,\npodman-ps(1)\n,\npodman-attach(1)\n,\npodman-pod-create(1)\n,\npodman-port(1)\n,\npodman-start(1)\n,\npodman-kill(1)\n,\npodman-stop(1)\n,\npodman-generate-systemd(1)\n,\npodman-rm(1)\n,\nsubgid(5)\n,\nsubuid(5)\n,\ncontainers.conf(5)\n,\npodman-systemd.unit(5)\n,\nsetsebool(8)\n,\nslirp4netns(1)\n,\npasta(1)\n,\nfuse-overlayfs(1)\n,\nproc(5)\n,\nconmon(8)\n,\npersonality(2)\nTroubleshooting\n¶\nSee\npodman-troubleshooting(7)\nfor solutions to common issues.\nSee\npodman-rootless(7)\nfor rootless issues.\nHISTORY\n¶\nSeptember 2018, updated by Kunal Kushwaha\n<kushwaha_kunal_v7@lab.ntt.co.jp>\nOctober 2017, converted from Docker documentation to Podman by Dan Walsh for Podman\n<dwalsh@redhat.com>\nNovember 2015, updated by Sally O’Malley\n<somalley@redhat.com>\nJune 2014, updated by Sven Dowideit\n<SvenDowideit@home.org.au>\nApril 2014, Originally compiled by William Henry\n<whenry@redhat.com>\nbased on docker.com source material and internal work.\nFOOTNOTES\n¶\n1\n: The Podman project is committed to inclusivity, a core value of open source. The\nmaster\nand\nslave\nmount propagation terminology used here is problematic and divisive, and needs to be changed. However, these terms are currently used within the Linux kernel and must be used as-is at this time. When the kernel maintainers rectify this usage, Podman will follow suit immediately.\nPodman\nNavigation\nContents:\nIntroduction\nCommands\nReference\nTutorials\nSearch\nPodman Python\nRelated Topics\nDocumentation overview\n©2019, team.\n|\nPowered by\nSphinx 8.2.3\n&\nAlabaster 1.0.0\n|\nPage source", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://docs.podman.io/en/latest/markdown/podman-run.1.html"}}
{"text": "podman-build — Podman  documentation\nNAME\n¶\npodman-build - Build a container image using a Containerfile\nSYNOPSIS\n¶\npodman build\n[\noptions\n] [\ncontext\n]\npodman image build\n[\noptions\n] [\ncontext\n]\nDESCRIPTION\n¶\npodman build\nBuilds an image using instructions from one or more\nContainerfiles or Dockerfiles and a specified build context directory. A\nContainerfile uses the same syntax as a Dockerfile internally. For this\ndocument, a file referred to as a Containerfile can be a file named\neither ‘Containerfile’ or ‘Dockerfile’ exclusively. Any file that has additional\nextension attached will not be recognized by\npodman\nbuild\n.\nunless a\n-f\nflag is\nused to specify the file.\nThe build context directory can be specified as the http(s) URL of an archive,\ngit repository or Containerfile.\nWhen invoked with\n-f\nand a path to a Containerfile, with no explicit CONTEXT\ndirectory, Podman uses the Containerfile’s parent directory as its build context.\nContainerfiles ending with a “.in” suffix are preprocessed via CPP(1).  This\ncan be useful to decompose Containerfiles into several reusable parts that can\nbe used via CPP’s\n#include\ndirective. Containerfiles ending in .in are\nrestricted to no comment lines unless they are CPP commands.\nNote, a Containerfile.in file can still be used by other tools when manually\npreprocessing them via\ncpp\n-E\n.\nWhen the URL is an archive, the contents of the URL is downloaded to a temporary\nlocation and extracted before execution.\nWhen the URL is a Containerfile, the Containerfile is downloaded to a temporary\nlocation.\nWhen a Git repository is set as the URL, the repository is cloned locally and\nthen set as the context.  A URL is treated as a Git repository if it\nhas a\ngit://\nprefix or a\n.git\nsuffix.\nNOTE:\npodman\nbuild\nuses code sourced from the\nBuildah\nproject to build\ncontainer images.  This\nBuildah\ncode creates\nBuildah\ncontainers for the\nRUN\noptions in container storage. In certain situations, when the\npodman\nbuild\ncrashes or users kill the\npodman\nbuild\nprocess, these external\ncontainers can be left in container storage. Use the\npodman\nps\n--all\n--external\ncommand to see these containers.\npodman\nbuildx\nbuild\ncommand is an alias of\npodman\nbuild\n.  Not all\nbuildx\nbuild\nfeatures are available in Podman. The\nbuildx\nbuild\noption is provided for scripting compatibility.\nOPTIONS\n¶\n--add-host\n=\nhostname[;hostname[;…]]\n:\nip\n¶\nAdd a custom host-to-IP mapping to the container’s\n/etc/hosts\nfile.\nThe option takes one or multiple semicolon-separated hostnames to be mapped to\na single IPv4 or IPv6 address, separated by a colon. It can also be used to\noverwrite the IP addresses of hostnames Podman adds to\n/etc/hosts\nby default\n(also see the\n--name\nand\n--hostname\noptions). This option can be\nspecified multiple times to add additional mappings to\n/etc/hosts\n. It\nconflicts with the\n--no-hosts\noption and conflicts with\nno_hosts=true\nin\ncontainers.conf\n.\nInstead of an IP address, the special flag\nhost-gateway\ncan be given. This\nresolves to an IP address the container can use to connect to the host. The\nIP address chosen depends on your network setup, thus there’s no guarantee that\nPodman can determine the\nhost-gateway\naddress automatically, which will then\ncause Podman to fail with an error message. You can overwrite this IP address\nusing the\nhost_containers_internal_ip\noption in\ncontainers.conf\n.\nThe\nhost-gateway\naddress is also used by Podman to automatically add the\nhost.containers.internal\nand\nhost.docker.internal\nhostnames to\n/etc/hosts\n.\nYou can prevent that by either giving the\n--no-hosts\noption, or by setting\nhost_containers_internal_ip=”none”\nin\ncontainers.conf\n. If no\nhost-gateway\naddress was configured manually and Podman fails to determine the IP address\nautomatically, Podman will silently skip adding these internal hostnames to\n/etc/hosts\n. If Podman is running in a virtual machine using\npodman\nmachine\n(this includes Mac and Windows hosts), Podman will silently skip adding the\ninternal hostnames to\n/etc/hosts\n, unless an IP address was configured\nmanually; the internal hostnames are resolved by the gvproxy DNS resolver\ninstead.\nPodman will use the\n/etc/hosts\nfile of the host as a basis by default, i.e.\nany hostname present in this file will also be present in the\n/etc/hosts\nfile\nof the container. A different base file can be configured using the\nbase_hosts_file\nconfig in\ncontainers.conf\n.\n--all-platforms\n¶\nInstead of building for a set of platforms specified using the\n--platform\noption, inspect the build’s base images, and build for all of the platforms for which they are all available.  Stages that use\nscratch\nas a starting point can not be inspected, so at least one non-\nscratch\nstage must be present for detection to work usefully.\n--annotation\n=\nannotation=value\n¶\nAdd an image\nannotation\n(e.g. annotation=\nvalue\n) to the image metadata. Can\nbe used multiple times.\nNote: this information is not present in Docker image formats, so it is\ndiscarded when writing images in Docker formats.\n--arch\n=\narch\n¶\nSet the architecture of the image to be built, and that of the base image to be\npulled, if the build uses one, to the provided value instead of using the\narchitecture of the build host. Unless overridden, subsequent lookups of the\nsame image in the local storage matches this architecture, regardless of the\nhost. (Examples: arm, arm64, 386, amd64, ppc64le, s390x)\n--authfile\n=\npath\n¶\nPath of the authentication file. Default is\n${XDG_RUNTIME_DIR}/containers/auth.json\non Linux, and\n$HOME/.config/containers/auth.json\non Windows/macOS.\nThe file is created by\npodman login\n. If the authorization state is not found there,\n$HOME/.docker/config.json\nis checked, which is set using\ndocker login\n.\nNote: There is also the option to override the default path of the authentication file by setting the\nREGISTRY_AUTH_FILE\nenvironment variable. This can be done with\nexport REGISTRY_AUTH_FILE=\npath\n.\n--build-arg\n=\narg=value\n¶\nSpecifies a build argument and its value, which is interpolated in\ninstructions read from the Containerfiles in the same way that environment variables are, but which are not added to environment variable list in the resulting image’s configuration.\n--build-arg-file\n=\npath\n¶\nSpecifies a file containing lines of build arguments of the form\narg=value\n.\nThe suggested file name is\nargfile.conf\n.\nComment lines beginning with\n#\nare ignored, along with blank lines.\nAll others must be of the\narg=value\nformat passed to\n--build-arg\n.\nIf several arguments are provided via the\n--build-arg-file\nand\n--build-arg\noptions, the build arguments are merged across all\nof the provided files and command line arguments.\nAny file provided in a\n--build-arg-file\noption is read before\nthe arguments supplied via the\n--build-arg\noption.\nWhen a given argument name is specified several times, the last instance\nis the one that is passed to the resulting builds. This means\n--build-arg\nvalues always override those in a\n--build-arg-file\n.\n--build-context\n=\nname=value\n¶\nSpecify an additional build context using its short name and its location.\nAdditional build contexts can be referenced in the same manner as we access\ndifferent stages in COPY instruction.\nValid values are:\nLocal directory – e.g. --build-context project2=../path/to/project2/src\nHTTP URL to a tarball – e.g. --build-context src=https://example.org/releases/src.tar\nContainer image – specified with a container-image:// prefix, e.g. --build-context alpine=container-image://alpine:3.15, (also accepts docker://, docker-image://)\nOn the Containerfile side, reference the build context on all\ncommands that accept the “from” parameter. Here’s how that might look:\nFROM\n[name]\nCOPY\n--from\n=[\nname\n]\n...\nRUN\n--mount\n=\nfrom\n=[\nname\n]\n…\nThe value of [name] is matched with the following priority order:\nNamed build context defined with --build-context [name]=..\nStage defined with AS [name] inside Containerfile\nImage [name], either local or in a remote registry\n--cache-from\n=\nimage\n¶\nRepository to utilize as a potential cache source. When specified, Buildah tries to look for\ncache images in the specified repository and attempts to pull cache images instead of actually\nexecuting the build steps locally. Buildah only attempts to pull previously cached images if they\nare considered as valid cache hits.\nUse the\n--cache-to\noption to populate a remote repository with cache content.\nExample\n# populate a cache and also consult it\nbuildah\nbuild\n-t\ntest\n--layers\n--cache-to\nregistry/myrepo/cache\n--cache-from\nregistry/myrepo/cache\n.\nNote:\n--cache-from\noption is ignored unless\n--layers\nis specified.\n--cache-to\n=\nimage\n¶\nSet this flag to specify a remote repository that is used to store cache images. Buildah attempts to\npush newly built cache image to the remote repository.\nNote: Use the\n--cache-from\noption in order to use cache content in a remote repository.\nExample\n# populate a cache and also consult it\nbuildah\nbuild\n-t\ntest\n--layers\n--cache-to\nregistry/myrepo/cache\n--cache-from\nregistry/myrepo/cache\n.\nNote:\n--cache-to\noption is ignored unless\n--layers\nis specified.\n--cache-ttl\n¶\nLimit the use of cached images to only consider images with created timestamps less than\nduration\nago.\nFor example if\n--cache-ttl=1h\nis specified, Buildah considers intermediate cache images which are created\nunder the duration of one hour, and intermediate cache images outside this duration is ignored.\nNote: Setting\n--cache-ttl=0\nmanually is equivalent to using\n--no-cache\nin the\nimplementation since this means that the user does not want to use cache at all.\n--cap-add\n=\nCAP_xxx\n¶\nWhen executing RUN instructions, run the command specified in the instruction\nwith the specified capability added to its capability set.\nCertain capabilities are granted by default; this option can be used to add\nmore.\n--cap-drop\n=\nCAP_xxx\n¶\nWhen executing RUN instructions, run the command specified in the instruction\nwith the specified capability removed from its capability set.\nThe CAP_CHOWN, CAP_DAC_OVERRIDE, CAP_FOWNER,\nCAP_FSETID, CAP_KILL, CAP_NET_BIND_SERVICE, CAP_SETFCAP,\nCAP_SETGID, CAP_SETPCAP, and CAP_SETUID capabilities are\ngranted by default; this option can be used to remove them.\nIf a capability is specified to both the\n--cap-add\nand\n--cap-drop\noptions, it is dropped, regardless of the order in which the options were\ngiven.\n--cert-dir\n=\npath\n¶\nUse certificates at\npath\n(*.crt, *.cert, *.key) to connect to the registry. (Default: /etc/containers/certs.d)\nFor details, see\ncontainers-certs.d(5)\n.\n(This option is not available with the remote Podman client, including Mac and Windows (excluding WSL2) machines)\n--cgroup-parent\n=\npath\n¶\nPath to cgroups under which the cgroup for the container is created. If the\npath is not absolute, the path is considered to be relative to the cgroups path\nof the init process. Cgroups are created if they do not already exist.\n--cgroupns\n=\nhow\n¶\nSets the configuration for cgroup namespaces when handling\nRUN\ninstructions.\nThe configured value can be “” (the empty string) or “private” to indicate\nthat a new cgroup namespace is created, or it can be “host” to indicate\nthat the cgroup namespace in which\nbuildah\nitself is being run is reused.\n--compat-volumes\n¶\nHandle directories marked using the VOLUME instruction (both in this build, and\nthose inherited from base images) such that their contents can only be modified\nby ADD and COPY instructions. Any changes made in those locations by RUN\ninstructions will be reverted. Before the introduction of this option, this\nbehavior was the default, but it is now disabled by default.\n--compress\n¶\nThis option is added to be aligned with other containers CLIs.\nPodman doesn’t communicate with a daemon or a remote server.\nThus, compressing the data before sending it is irrelevant to Podman. (This option is not available with the remote Podman client, including Mac and Windows (excluding WSL2) machines)\n--cpp-flag\n=\nflags\n¶\nSet additional flags to pass to the C Preprocessor cpp(1). Containerfiles ending with a “.in” suffix is preprocessed via cpp(1). This option can be used to pass additional flags to cpp.Note: You can also set default CPPFLAGS by setting the BUILDAH_CPPFLAGS environment variable (e.g., export BUILDAH_CPPFLAGS=”-DDEBUG”).\n--cpu-period\n=\nlimit\n¶\nSet the CPU period for the Completely Fair Scheduler (CFS), which is a\nduration in microseconds. Once the container’s CPU quota is used up, it will not\nbe scheduled to run until the current period ends. Defaults to 100000\nmicroseconds.\nOn some systems, changing the resource limits may not be allowed for non-root\nusers. For more details, see\nhttps://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-resource-limits-fails-with-a-permissions-error\nThis option is not supported on cgroups V1 rootless systems.\n--cpu-quota\n=\nlimit\n¶\nLimit the CPU Completely Fair Scheduler (CFS) quota.\nLimit the container’s CPU usage. By default, containers run with the full\nCPU resource. The limit is a number in microseconds. If a number is provided,\nthe container is allowed to use that much CPU time until the CPU period\nends (controllable via\n--cpu-period\n).\nOn some systems, changing the resource limits may not be allowed for non-root\nusers. For more details, see\nhttps://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-resource-limits-fails-with-a-permissions-error\nThis option is not supported on cgroups V1 rootless systems.\n--cpu-shares\n,\n-c\n=\nshares\n¶\nCPU shares (relative weight).\nBy default, all containers get the same proportion of CPU cycles. This\nproportion can be modified by changing the container’s CPU share weighting\nrelative to the combined weight of all the running containers.\nDefault weight is\n1024\n.\nThe proportion only applies when CPU-intensive processes are running.\nWhen tasks in one container are idle, other containers can use the\nleft-over CPU time. The actual amount of CPU time varies depending on\nthe number of containers running on the system.\nFor example, consider three containers, one has a cpu-share of 1024 and\ntwo others have a cpu-share setting of 512. When processes in all three\ncontainers attempt to use 100% of CPU, the first container receives\n50% of the total CPU time. If a fourth container is added with a cpu-share\nof 1024, the first container only gets 33% of the CPU. The remaining containers\nreceive 16.5%, 16.5% and 33% of the CPU.\nOn a multi-core system, the shares of CPU time are distributed over all CPU\ncores. Even if a container is limited to less than 100% of CPU time, it can\nuse 100% of each individual CPU core.\nFor example, consider a system with more than three cores.\nIf the container\nC0\nis started with\n--cpu-shares=512\nrunning one process,\nand another container\nC1\nwith\n--cpu-shares=1024\nrunning two processes,\nthis can result in the following division of CPU shares:\nPID\ncontainer\nCPU\nCPU share\n100\nC0\n0\n100% of CPU0\n101\nC1\n1\n100% of CPU1\n102\nC1\n2\n100% of CPU2\nOn some systems, changing the resource limits may not be allowed for non-root\nusers. For more details, see\nhttps://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-resource-limits-fails-with-a-permissions-error\nThis option is not supported on cgroups V1 rootless systems.\n--cpuset-cpus\n=\nnumber\n¶\nCPUs in which to allow execution. Can be specified as a comma-separated list\n(e.g.\n0,1\n), as a range (e.g.\n0-3\n), or any combination thereof\n(e.g.\n0-3,7,11-15\n).\nOn some systems, changing the resource limits may not be allowed for non-root\nusers. For more details, see\nhttps://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-resource-limits-fails-with-a-permissions-error\nThis option is not supported on cgroups V1 rootless systems.\n--cpuset-mems\n=\nnodes\n¶\nMemory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on\nNUMA systems.\nIf there are four memory nodes on the system (0-3), use\n--cpuset-mems=0,1\nthen processes in the container only uses memory from the first\ntwo memory nodes.\nOn some systems, changing the resource limits may not be allowed for non-root\nusers. For more details, see\nhttps://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-resource-limits-fails-with-a-permissions-error\nThis option is not supported on cgroups V1 rootless systems.\n--created-annotation\n¶\nAdd an image\nannotation\n(see also\n--annotation\n) to the image metadata\nsetting “org.opencontainers.image.created” to the current time, or to the\ndatestamp specified to the\n--source-date-epoch\nor\n--timestamp\nflag,\nif either was used.  If\nfalse\n, no such annotation will be present in the\nwritten image.\nNote: this information is not present in Docker image formats, so it is discarded when writing images in Docker formats.\n--creds\n=\n[username[:password]]\n¶\nThe [username[:password]] to use to authenticate with the registry, if required.\nIf one or both values are not supplied, a command line prompt appears and the\nvalue can be entered. The password is entered without echo.\nNote that the specified credentials are only used to authenticate against\ntarget registries.  They are not used for mirrors or when the registry gets\nrewritten (see\ncontainers-registries.conf(5)\n); to authenticate against those\nconsider using a\ncontainers-auth.json(5)\nfile.\n--cw\n=\noptions\n¶\nProduce an image suitable for use as a confidential workload running in a\ntrusted execution environment (TEE) using krun (i.e.,\ncrun\nbuilt with the\nlibkrun feature enabled and invoked as\nkrun\n).  Instead of the conventional\ncontents, the root filesystem of the image will contain an encrypted disk image\nand configuration information for krun.\nThe value for\noptions\nis a comma-separated list of key=value pairs, supplying\nconfiguration information which is needed for producing the additional data\nwhich will be included in the container image.\nRecognized\nkeys\nare:\nattestation_url\n: The location of a key broker / attestation server.\nIf a value is specified, the new image’s workload ID, along with the passphrase\nused to encrypt the disk image, will be registered with the server, and the\nserver’s location will be stored in the container image.\nAt run-time, krun is expected to contact the server to retrieve the passphrase\nusing the workload ID, which is also stored in the container image.\nIf no value is specified, a\npassphrase\nvalue\nmust\nbe specified.\ncpus\n: The number of virtual CPUs which the image expects to be run with at\nrun-time.  If not specified, a default value will be supplied.\nfirmware_library\n: The location of the libkrunfw-sev shared library.  If not\nspecified,\nbuildah\nchecks for its presence in a number of hard-coded\nlocations.\nmemory\n: The amount of memory which the image expects to be run with at\nrun-time, as a number of megabytes.  If not specified, a default value will be\nsupplied.\npassphrase\n: The passphrase to use to encrypt the disk image which will be\nincluded in the container image.\nIf no value is specified, but an\nattestation_url\nvalue is specified, a\nrandomly-generated passphrase will be used.\nThe authors recommend setting an\nattestation_url\nbut not a\npassphrase\n.\nslop\n: Extra space to allocate for the disk image compared to the size of the\ncontainer image’s contents, expressed either as a percentage (..%) or a size\nvalue (bytes, or larger units if suffixes like KB or MB are present), or a sum\nof two or more such specifications.  If not specified,\nbuildah\nguesses that\n25% more space than the contents will be enough, but this option is provided in\ncase its guess is wrong.\ntype\n: The type of trusted execution environment (TEE) which the image should\nbe marked for use with.  Accepted values are “SEV” (AMD Secure Encrypted\nVirtualization - Encrypted State) and “SNP” (AMD Secure Encrypted\nVirtualization - Secure Nested Paging).  If not specified, defaults to “SNP”.\nworkload_id\n: A workload identifier which will be recorded in the container\nimage, to be used at run-time for retrieving the passphrase which was used to\nencrypt the disk image.  If not specified, a semi-random value will be derived\nfrom the base image’s image ID.\nThis option is not supported on the remote client, including Mac and Windows\n(excluding WSL2) machines.\n--decryption-key\n=\nkey[:passphrase]\n¶\nThe [key[:passphrase]] to be used for decryption of images. Key can point to keys and/or certificates. Decryption is tried with all keys. If the key is protected by a passphrase, it is required to be passed in the argument and omitted otherwise.\n--device\n=\nhost-device[:container-device][:permissions]\n¶\nAdd a host device to the container. Optional\npermissions\nparameter\ncan be used to specify device permissions by combining\nr\nfor read,\nw\nfor write, and\nm\nfor\nmknod\n(2).\nExample:\n--device=/dev/sdc:/dev/xvdc:rwm\n.\nNote: if\nhost-device\nis a symbolic link then it is resolved first.\nThe container only stores the major and minor numbers of the host device.\nPodman may load kernel modules required for using the specified\ndevice. The devices that Podman loads modules for when necessary are:\n/dev/fuse.\nIn rootless mode, the new device is bind mounted in the container from the host\nrather than Podman creating it within the container space. Because the bind\nmount retains its SELinux label on SELinux systems, the container can get\npermission denied when accessing the mounted device. Modify SELinux settings to\nallow containers to use all device labels via the following command:\n$ sudo setsebool -P  container_use_devices=true\nNote: if the user only has access rights via a group, accessing the device\nfrom inside a rootless container fails. The\ncrun(1)\nruntime offers a\nworkaround for this by adding the option\n--annotation run.oci.keep_original_groups=1\n.\n--disable-compression\n,\n-D\n¶\nDon’t compress filesystem layers when building the image unless it is required\nby the location where the image is being written.  This is the default setting,\nbecause image layers are compressed automatically when they are pushed to\nregistries, and images being written to local storage only need to be\ndecompressed again to be stored.  Compression can be forced in all cases by\nspecifying\n--disable-compression=false\n.\n--disable-content-trust\n¶\nThis is a Docker-specific option to disable image verification to a container\nregistry and is not supported by Podman. This option is a NOOP and provided\nsolely for scripting compatibility.\n--dns\n=\nipaddr\n¶\nSet custom DNS servers.\nThis option can be used to override the DNS\nconfiguration passed to the container. Typically this is necessary when the\nhost DNS configuration is invalid for the container (e.g.,\n127.0.0.1\n). When this\nis the case the\n--dns\nflag is necessary for every run.\nThe special value\nnone\ncan be specified to disable creation of\n/etc/resolv.conf\nin the container by Podman.\nThe\n/etc/resolv.conf\nfile in the image is then used without changes.\nNote that\nipaddr\nmay be added directly to the container’s\n/etc/resolv.conf\n.\nThis is not guaranteed though.  For example, passing a custom network whose\ndns_enabled\nis set to\ntrue\nto\n--network\nwill result in\n/etc/resolv.conf\nonly referring to the aardvark-dns server.  aardvark-dns then forwards to the supplied\nipaddr\nfor all non-container name queries.\nThis option cannot be combined with\n--network\nthat is set to\nnone\n.\nNote: this option takes effect only during\nRUN\ninstructions in the build.\nIt does not affect\n/etc/resolv.conf\nin the final image.\n--dns-option\n=\noption\n¶\nSet custom DNS options to be used during the build.\n--dns-search\n=\ndomain\n¶\nSet custom DNS search domains to be used during the build.\n--env\n=\nenv[=value]\n¶\nAdd a value (e.g. env=\nvalue\n) to the built image.  Can be used multiple times.\nIf neither\n=\nnor a\nvalue\nare specified, but\nenv\nis set in the current\nenvironment, the value from the current environment is added to the image.\nTo remove an environment variable from the built image, use the\n--unsetenv\noption.\n--file\n,\n-f\n=\nContainerfile\n¶\nSpecifies a Containerfile which contains instructions for building the image,\neither a local file or an\nhttp\nor\nhttps\nURL.  If more than one\nContainerfile is specified,\nFROM\ninstructions are only be accepted from the\nlast specified file.\nIf a build context is not specified, and at least one Containerfile is a\nlocal file, the directory in which it resides is used as the build\ncontext.\nSpecifying the option\n-f\n-\ncauses the Containerfile contents to be read from stdin.\n--force-rm\n¶\nAlways remove intermediate containers after a build, even if the build fails (default true).\n--format\n¶\nControl the format for the built image’s manifest and configuration data.\nRecognized formats include\noci\n(OCI image-spec v1.0, the default) and\ndocker\n(version 2, using schema format 2 for the manifest).\nNote: You can also override the default format by setting the BUILDAH_FORMAT\nenvironment variable.\nexport\nBUILDAH_FORMAT=docker\n--from\n¶\nOverrides the first\nFROM\ninstruction within the Containerfile.  If there are multiple\nFROM instructions in a Containerfile, only the first is changed.\nWith the remote podman client, not all container transports work as\nexpected. For example, oci-archive:/x.tar references /x.tar on the remote\nmachine instead of on the client. When using podman remote clients it is\nbest to restrict use to\ncontainers-storage\n, and\ndocker:// transports\n.\n--group-add\n=\ngroup\n|\nkeep-groups\n¶\nAssign additional groups to the primary user running within the container process.\nkeep-groups\nis a special flag that tells Podman to keep the supplementary group access.\nAllows container to use the user’s supplementary group access. If file systems or\ndevices are only accessible by the rootless user’s group, this flag tells the OCI\nruntime to pass the group access into the container. Currently only available\nwith the\ncrun\nOCI runtime. Note:\nkeep-groups\nis exclusive, other groups cannot be specified\nwith this flag. (Not available for remote commands, including Mac and Windows (excluding WSL2) machines)\n--help\n,\n-h\n¶\nPrint usage statement\n--hooks-dir\n=\npath\n¶\nEach *.json file in the path configures a hook for buildah build containers. For more details on the syntax of the JSON files and the semantics of hook injection. Buildah currently support both the 1.0.0 and 0.1.0 hook schemas, although the 0.1.0 schema is deprecated.\nThis option may be set multiple times; paths from later options have higher precedence.\nFor the annotation conditions, buildah uses any annotations set in the generated OCI configuration.\nFor the bind-mount conditions, only mounts explicitly requested by the caller via --volume are considered. Bind mounts that buildah inserts by default (e.g. /dev/shm) are not considered.\nIf --hooks-dir is unset for root callers, Buildah currently defaults to /usr/share/containers/oci/hooks.d and /etc/containers/oci/hooks.d in order of increasing precedence. Using these defaults is deprecated. Migrate to explicitly setting --hooks-dir.\n--http-proxy\n¶\nBy default proxy environment variables are passed into the container if set\nfor the Podman process. This can be disabled by setting the value to\nfalse\n.\nThe environment variables passed in include\nhttp_proxy\n,\nhttps_proxy\n,\nftp_proxy\n,\nno_proxy\n, and also the upper case versions of\nthose. This option is only needed when the host system must use a proxy but\nthe container does not use any proxy. Proxy environment variables specified\nfor the container in any other way overrides the values that have\nbeen passed through from the host. (Other ways to specify the proxy for the\ncontainer include passing the values with the\n--env\nflag, or hard coding the\nproxy environment at container build time.)\nWhen used with the remote client it uses the proxy environment variables\nthat are set on the server process.\nDefaults to\ntrue\n.\n--identity-label\n¶\nAdds default identity label\nio.buildah.version\nif set. (default true).\n--ignorefile\n¶\nPath to an alternative .containerignore file.\n--iidfile\n=\nImageIDfile\n¶\nWrite the built image’s ID to the file.  When\n--platform\nis specified more than once, attempting to use this option triggers an error.\n--inherit-annotations\n=\nbool-value\n¶\nInherit the annotations from the base image or base stages. (default true).\nUse cases which set this flag to\nfalse\nmay need to do the same for the\n--created-annotation\nflag.\n--inherit-labels\n¶\nInherit the labels from the base image or base stages. (default true).\n--ipc\n=\nhow\n¶\nSets the configuration for IPC namespaces when handling\nRUN\ninstructions.\nThe configured value can be “” (the empty string) or “container” to indicate\nthat a new IPC namespace is created, or it can be “host” to indicate\nthat the IPC namespace in which\npodman\nitself is being run is reused,\nor it can be the path to an IPC namespace which is already in use by\nanother process.\n--isolation\n=\ntype\n¶\nControls what type of isolation is used for running processes as part of\nRUN\ninstructions.  Recognized types include\noci\n(OCI-compatible runtime, the\ndefault),\nrootless\n(OCI-compatible runtime invoked using a modified\nconfiguration and its --rootless option enabled, with\n--no-new-keyring\n--no-pivot\nadded to its\ncreate\ninvocation, with network and UTS namespaces\ndisabled, and IPC, PID, and user namespaces enabled; the default for\nunprivileged users), and\nchroot\n(an internal wrapper that leans more toward\nchroot(1) than container technology).\nNote: You can also override the default isolation type by setting the\nBUILDAH_ISOLATION environment variable.\nexport\nBUILDAH_ISOLATION=oci\n--jobs\n=\nnumber\n¶\nRun up to N concurrent stages in parallel.  If the number of jobs is greater\nthan 1, stdin is read from /dev/null.  If 0 is specified, then there is\nno limit in the number of jobs that run in parallel.\n--label\n=\nlabel\n¶\nAdd an image\nlabel\n(e.g. label=\nvalue\n) to the image metadata. Can be used\nmultiple times.\nUsers can set a special LABEL\nio.containers.capabilities=CAP1,CAP2,CAP3\nin\na Containerfile that specifies the list of Linux capabilities required for the\ncontainer to run properly. This label specified in a container image tells\nPodman to run the container with just these capabilities. Podman launches the\ncontainer with just the specified capabilities, as long as this list of\ncapabilities is a subset of the default list.\nIf the specified capabilities are not in the default set, Podman prints an error\nmessage and runs the container with the default capabilities.\n--layer-label\n=\nlabel[=value]\n¶\nAdd an intermediate image\nlabel\n(e.g. label=\nvalue\n) to the intermediate\nimage metadata. It can be used multiple times.\nIf\nlabel\nis named, but neither\n=\nnor a\nvalue\nis provided, then\nthe\nlabel\nis set to an empty value.\n--layers\n¶\nCache intermediate images during the build process (Default is\ntrue\n).\nNote: You can also override the default value of layers by setting the\nBUILDAH_LAYERS environment variable.\nexport\nBUILDAH_LAYERS=true\n--logfile\n=\nfilename\n¶\nLog output which is sent to standard output and standard error to the\nspecified file instead of to standard output and standard error.\nThis option is not supported on the remote client, including Mac and Windows (excluding WSL2) machines.\n--logsplit\n=\nbool-value\n¶\nIf\n--logfile\nand\n--platform\nare specified, the\n--logsplit\noption allows\nend-users to split the log file for each platform into different files in the\nfollowing format:\n${logfile}_${platform-os}_${platform-arch}\n.\nThis option is not supported on the remote client, including Mac and Windows\n(excluding WSL2) machines.\n--manifest\n=\nmanifest\n¶\nName of the manifest list to which the image is added. Creates the manifest list if it does not exist. This option is useful for building multi architecture images.\n--memory\n,\n-m\n=\nnumber[unit]\n¶\nMemory limit. A\nunit\ncan be\nb\n(bytes),\nk\n(kibibytes),\nm\n(mebibytes), or\ng\n(gibibytes).\nAllows the memory available to a container to be constrained. If the host\nsupports swap memory, then the\n-m\nmemory setting can be larger than physical\nRAM. If a limit of 0 is specified (not using\n-m\n), the container’s memory is\nnot limited. The actual limit may be rounded up to a multiple of the operating\nsystem’s page size (the value is very large, that’s millions of trillions).\nThis option is not supported on cgroups V1 rootless systems.\n--memory-swap\n=\nnumber[unit]\n¶\nA limit value equal to memory plus swap.\nA\nunit\ncan be\nb\n(bytes),\nk\n(kibibytes),\nm\n(mebibytes), or\ng\n(gibibytes).\nMust be used with the\n-m\n(\n--memory\n) flag.\nThe argument value must be larger than that of\n-m\n(\n--memory\n) By default, it is set to double\nthe value of\n--memory\n.\nSet\nnumber\nto\n-1\nto enable unlimited swap.\nThis option is not supported on cgroups V1 rootless systems.\n--network\n=\nmode\n,\n--net\n¶\nSets the configuration for network namespaces when handling\nRUN\ninstructions.\nValid\nmode\nvalues are:\nnone\n: no networking.\nhost\n: use the Podman host network stack. Note: the host mode gives the\ncontainer full access to local system services such as D-bus and is therefore\nconsidered insecure.\nns:\npath\n: path to a network namespace to join.\nprivate\n: create a new namespace for the container (default)\n<network name|ID>\n: Join the network with the given name or ID, e.g. use\n--network\nmynet\nto join the network with the name mynet. Only supported for rootful users.\nslirp4netns[:OPTIONS,…]\n: use\nslirp4netns\n(1) to create a user network stack. It is possible to specify these additional options, they can also be set with\nnetwork_cmd_options\nin containers.conf:\nallow_host_loopback=true|false\n: Allow slirp4netns to reach the host loopback IP (default is 10.0.2.2 or the second IP from slirp4netns cidr subnet when changed, see the cidr option below). The default is false.\nmtu=MTU\n: Specify the MTU to use for this network. (Default is\n65520\n).\ncidr=CIDR\n: Specify ip range to use for this network. (Default is\n10.0.2.0/24\n).\nenable_ipv6=true|false\n: Enable IPv6. Default is true. (Required for\noutbound_addr6\n).\noutbound_addr=INTERFACE\n: Specify the outbound interface slirp binds to (ipv4 traffic only).\noutbound_addr=IPv4\n: Specify the outbound ipv4 address slirp binds to.\noutbound_addr6=INTERFACE\n: Specify the outbound interface slirp binds to (ipv6 traffic only).\noutbound_addr6=IPv6\n: Specify the outbound ipv6 address slirp binds to.\npasta[:OPTIONS,…]\n: use\npasta\n(1) to create a user-mode networking\nstack.\nThis is the default for rootless containers and only supported in rootless mode.\nBy default, IPv4 and IPv6 addresses and routes, as well as the pod interface\nname, are copied from the host. If port forwarding isn’t configured, ports\nare forwarded dynamically as services are bound on either side (init\nnamespace or container namespace). Port forwarding preserves the original\nsource IP address. Options described in pasta(1) can be specified as\ncomma-separated arguments.\nIn terms of pasta(1) options,\n--config-net\nis given by default, in\norder to configure networking when the container is started, and\n--no-map-gw\nis also assumed by default, to avoid direct access from\ncontainer to host using the gateway address. The latter can be overridden\nby passing\n--map-gw\nin the pasta-specific options (despite not being an\nactual pasta(1) option).\nAlso,\n-t none\nand\n-u none\nare passed to disable\nautomatic port forwarding based on bound ports. Similarly,\n-T none\nand\n-U none\nare given to disable the same functionality from container to\nhost.\nSome examples:\npasta:--map-gw\n: Allow the container to directly reach the host using the\ngateway address.\npasta:--mtu,1500\n: Specify a 1500 bytes MTU for the\ntap\ninterface in\nthe container.\npasta:--ipv4-only,-a,10.0.2.0,-n,24,-g,10.0.2.2,--dns-forward,10.0.2.3,-m,1500,--no-ndp,--no-dhcpv6,--no-dhcp\n,\nequivalent to default slirp4netns(1) options: disable IPv6, assign\n10.0.2.0/24\nto the\ntap0\ninterface in the container, with gateway\n10.0.2.3\n, enable DNS forwarder reachable at\n10.0.2.3\n, set MTU to 1500\nbytes, disable NDP, DHCPv6 and DHCP support.\npasta:-I,tap0,--ipv4-only,-a,10.0.2.0,-n,24,-g,10.0.2.2,--dns-forward,10.0.2.3,--no-ndp,--no-dhcpv6,--no-dhcp\n,\nequivalent to default slirp4netns(1) options with Podman overrides: same as\nabove, but leave the MTU to 65520 bytes\npasta:-t,auto,-u,auto,-T,auto,-U,auto\n: enable automatic port forwarding\nbased on observed bound ports from both host and container sides\npasta:-T,5201\n: enable forwarding of TCP port 5201 from container to\nhost, using the loopback interface instead of the tap interface for improved\nperformance\n--no-cache\n¶\nDo not use existing cached images for the container build. Build from the start with a new set of cached layers.\n--no-hostname\n¶\nDo not create the\n/etc/hostname\nfile in the containers.\nBy default, Podman manages the\n/etc/hostname\nfile, adding the container’s own hostname.  When the\n--no-hostname\noption is set, the image’s\n/etc/hostname\nwill be preserved unmodified if it exists.\n--no-hosts\n¶\nDo not modify the\n/etc/hosts\nfile in the container.\nPodman assumes control over the container’s\n/etc/hosts\nfile by\ndefault and adds entries for the container’s name (see\n--name\noption) and\nhostname (see\n--hostname\noption), the internal\nhost.containers.internal\nand\nhost.docker.internal\nhosts, as well as any hostname added using the\n--add-host\noption. Refer to the\n--add-host\noption for details. Passing\n--no-hosts\ndisables this, so that the image’s\n/etc/hosts\nfile is kept\nunmodified. The same can be achieved globally by setting\nno_hosts=true\nin\ncontainers.conf\n.\nThis option conflicts with\n--add-host\n.\n--omit-history\n¶\nOmit build history information in the built image. (default false).\nThis option is useful for the cases where end users explicitly\nwant to set\n--omit-history\nto omit the optional\nHistory\nfrom\nbuilt images or when working with images built using build tools that\ndo not include\nHistory\ninformation in their images.\n--os\n=\nstring\n¶\nSet the OS of the image to be built, and that of the base image to be pulled, if the build uses one, instead of using the current operating system of the build host. Unless overridden, subsequent lookups of the same image in the local storage matches this OS, regardless of the host.\n--os-feature\n=\nfeature\n¶\nSet the name of a required operating system\nfeature\nfor the image which is built.  By default, if the image is not based on\nscratch\n, the base image’s required OS feature list is kept, if the base image specified any.  This option is typically only meaningful when the image’s OS is Windows.\nIf\nfeature\nhas a trailing\n-\n, then the\nfeature\nis removed from the set of required features which is listed in the image.\n--os-version\n=\nversion\n¶\nSet the exact required operating system\nversion\nfor the image which is built.  By default, if the image is not based on\nscratch\n, the base image’s required OS version is kept, if the base image specified one.  This option is typically only meaningful when the image’s OS is Windows, and is typically set in Windows base images, so using this option is usually unnecessary.\n--output\n,\n-o\n=\noutput-opts\n¶\nOutput destination (format: type=local,dest=path)\nThe --output (or -o) option extends the default behavior of building a container image by allowing users to export the contents of the image as files on the local filesystem, which can be useful for generating local binaries, code generation, etc. (This option is not available with the remote Podman client, including Mac and Windows (excluding WSL2) machines)\nThe value for --output is a comma-separated sequence of key=value pairs, defining the output type and options.\nSupported\nkeys\nare:\ndest\n: Destination path for exported output. Valid value is absolute or relative path,\n-\nmeans the standard output.\ntype\n: Defines the type of output to be used. Valid values is documented below.\nValid\ntype\nvalues are:\nlocal\n: write the resulting build files to a directory on the client-side.\ntar\n: write the resulting files as a single tarball (.tar).\nIf no type is specified, the value defaults to\nlocal\n.\nAlternatively, instead of a comma-separated sequence, the value of\n--output\ncan be just a destination (in the\ndest\nformat) (e.g.\n--output\nsome-path\n,\n--output\n-\n) where\n--output\nsome-path\nis treated as if\ntype=local\nand\n--output\n-\nis treated as if\ntype=tar\n.\n--pid\n=\npid\n¶\nSets the configuration for PID namespaces when handling\nRUN\ninstructions.\nThe configured value can be “” (the empty string) or “container” to indicate that a new PID namespace is created, or it can be “host” to indicate that the PID namespace in which\npodman\nitself is being run is reused, or it can be the path to a PID namespace which is already in use by another\nprocess.\n--platform\n=\nos/arch[/variant][,…]\n¶\nSet the\nos/arch\nof the built image (and its base image, when using one)\nto the provided value instead of using the current operating system and\narchitecture of the host (for example\nlinux/arm\n).  Unless overridden,\nsubsequent lookups of the same image in the local storage matches this\nplatform, regardless of the host.\nIf\n--platform\nis set, then the values of the\n--arch\n,\n--os\n, and\n--variant\noptions is overridden.\nThe\n--platform\noption can be specified more than once, or given a\ncomma-separated list of values as its argument.  When more than one platform is\nspecified, the\n--manifest\noption is used instead of the\n--tag\noption.\nOs/arch pairs are those used by the Go Programming Language.  In several cases\nthe\narch\nvalue for a platform differs from one produced by other tools such as\nthe\narch\ncommand.  Valid OS and architecture name combinations are listed as\nvalues for $GOOS and $GOARCH at https://golang.org/doc/install/source#environment,\nand can also be found by running\ngo\ntool\ndist\nlist\n.\nWhile\npodman\nbuild\nis happy to use base images and build images for any\nplatform that exists,\nRUN\ninstructions are unable to succeed without\nthe help of emulation provided by packages like\nqemu-user-static\n.\n--pull\n=\npolicy\n¶\nPull image policy. The default is\nmissing\n.\nalways\n: Always pull the image and throw an error if the pull fails.\nmissing\n: Only pull the image when it does not exist in the local containers storage.  Throw an error if no image is found and the pull fails.\nnever\n: Never pull the image but use the one from the local containers storage.  Throw an error when no image is found.\nnewer\n: Pull if the image on the registry is newer than the one in the local containers storage.  An image is considered to be newer when the digests are different.  Comparing the time stamps is prone to errors.  Pull errors are suppressed if a local image was found.\n--quiet\n,\n-q\n¶\nSuppress output messages which indicate which instruction is being processed, and of progress when pulling images from a registry, and when writing the output image.\n--retry\n=\nattempts\n¶\nNumber of times to retry pulling or pushing images between the registry and\nlocal storage in case of failure. Default is\n3\n.\n--retry-delay\n=\nduration\n¶\nDuration of delay between retry attempts when pulling or pushing images between\nthe registry and local storage in case of failure. The default is to start at two seconds and then exponentially back off. The delay is used when this value is set, and no exponential back off occurs.\n--rewrite-timestamp\n¶\nWhen generating new layers for the image, ensure that no newly added content\nbears a timestamp later than the value used by the\n--source-date-epoch\nflag, if one was provided, by replacing any timestamps which are later than\nthat value, with that value.\n--rm\n¶\nRemove intermediate containers after a successful build (default true).\n--runtime\n=\npath\n¶\nThe\npath\nto an alternate OCI-compatible runtime, which is used to run\ncommands specified by the\nRUN\ninstruction.\nNote: You can also override the default runtime by setting the BUILDAH_RUNTIME environment variable.\nexport\nBUILDAH_RUNTIME=/usr/local/bin/runc\n--runtime-flag\n=\nflag\n¶\nAdds global flags for the container runtime. To list the supported flags, please consult the manpages of the selected container runtime.\nDefault runtime flags can be added in containers.conf.\nNote: Do not pass the leading -- to the flag. To pass the runc flag --log-format json to buildah build, the option given is --runtime-flag log-format=json.\n--sbom\n=\npreset\n¶\nGenerate SBOMs (Software Bills Of Materials) for the output image by scanning\nthe working container and build contexts using the named combination of scanner\nimage, scanner commands, and merge strategy.  Must be specified with one or\nmore of\n--sbom-image-output\n,\n--sbom-image-purl-output\n,\n--sbom-output\n,\nand\n--sbom-purl-output\n.  Recognized presets, and the set of options which\nthey equate to:\n“syft”, “syft-cyclonedx”:\n--sbom-scanner-image=ghcr.io/anchore/syft\n--sbom-scanner-command=”/syft scan -q dir:{ROOTFS} --output cyclonedx-json={OUTPUT}”\n--sbom-scanner-command=”/syft scan -q dir:{CONTEXT} --output cyclonedx-json={OUTPUT}”\n--sbom-merge-strategy=merge-cyclonedx-by-component-name-and-version\n“syft-spdx”:\n--sbom-scanner-image=ghcr.io/anchore/syft\n--sbom-scanner-command=”/syft scan -q dir:{ROOTFS} --output spdx-json={OUTPUT}”\n--sbom-scanner-command=”/syft scan -q dir:{CONTEXT} --output spdx-json={OUTPUT}”\n--sbom-merge-strategy=merge-spdx-by-package-name-and-versioninfo\n“trivy”, “trivy-cyclonedx”:\n--sbom-scanner-image=ghcr.io/aquasecurity/trivy\n--sbom-scanner-command=”trivy filesystem -q {ROOTFS} --format cyclonedx --output {OUTPUT}”\n--sbom-scanner-command=”trivy filesystem -q {CONTEXT} --format cyclonedx --output {OUTPUT}”\n--sbom-merge-strategy=merge-cyclonedx-by-component-name-and-version\n“trivy-spdx”:\n--sbom-scanner-image=ghcr.io/aquasecurity/trivy\n--sbom-scanner-command=”trivy filesystem -q {ROOTFS} --format spdx-json --output {OUTPUT}”\n--sbom-scanner-command=”trivy filesystem -q {CONTEXT} --format spdx-json --output {OUTPUT}”\n--sbom-merge-strategy=merge-spdx-by-package-name-and-versioninfo\n--sbom-image-output\n=\npath\n¶\nWhen generating SBOMs, store the generated SBOM in the specified path in the\noutput image.  There is no default.\n--sbom-image-purl-output\n=\npath\n¶\nWhen generating SBOMs, scan them for PURL (\npackage\nURL\n)\ninformation, and save a list of found PURLs to the specified path in the output\nimage.  There is no default.\n--sbom-merge-strategy\n=\nmethod\n¶\nIf more than one\n--sbom-scanner-command\nvalue is being used, use the\nspecified method to merge the output from later commands with output from\nearlier commands.  Recognized values include:\ncat\nConcatenate the files.\nmerge-cyclonedx-by-component-name-and-version\nMerge the “component” fields of JSON documents, ignoring values from\ndocuments when the combination of their “name” and “version” values is\nalready present.  Documents are processed in the order in which they are\ngenerated, which is the order in which the commands that generate them\nwere specified.\nmerge-spdx-by-package-name-and-versioninfo\nMerge the “package” fields of JSON documents, ignoring values from\ndocuments when the combination of their “name” and “versionInfo” values is\nalready present.  Documents are processed in the order in which they are\ngenerated, which is the order in which the commands that generate them\nwere specified.\n--sbom-output\n=\nfile\n¶\nWhen generating SBOMs, store the generated SBOM in the named file on the local\nfilesystem.  There is no default.\n--sbom-purl-output\n=\nfile\n¶\nWhen generating SBOMs, scan them for PURL (\npackage\nURL\n)\ninformation, and save a list of found PURLs to the named file in the local\nfilesystem.  There is no default.\n--sbom-scanner-command\n=\nimage\n¶\nGenerate SBOMs by running the specified command from the scanner image.  If\nmultiple commands are specified, they are run in the order in which they are\nspecified.  These text substitutions are performed:\n{ROOTFS}\nThe root of the built image’s filesystem, bind mounted.\n{CONTEXT}\nThe build context and additional build contexts, bind mounted.\n{OUTPUT}\nThe name of a temporary output file, to be read and merged with others or copied elsewhere.\n--sbom-scanner-image\n=\nimage\n¶\nGenerate SBOMs using the specified scanner image.\n--secret\n=\nid=id[,src=\nenvOrFile\n][,env=\nENV\n][,type=\nfile\n|\nenv\n]\n¶\nPass secret information to be used in the Containerfile for building images\nin a safe way that will not end up stored in the final image, or be seen in other stages.\nThe value of the secret will be read from an environment variable or file named\nby the “id” option, or named by the “src” option if it is specified, or from an\nenvironment variable specified by the “env” option. See\nEXAMPLES\n.\nThe secret will be mounted in the container at\n/run/secrets/id\nby default.\nTo later use the secret, use the --mount flag in a\nRUN\ninstruction within a\nContainerfile\n:\nRUN\n--mount=type=secret,id=mysecret\ncat\n/run/secrets/mysecret\nThe location of the secret in the container can be overridden using the\n“target”, “dst”, or “destination” option of the\nRUN\n--mount\nflag.\nRUN\n--mount=type=secret,id=mysecret,target=/run/secrets/myothersecret\ncat\n/run/secrets/myothersecret\nNote: changing the contents of secret files will not trigger a rebuild of layers that use said secrets.\n--security-opt\n=\noption\n¶\nSecurity Options\napparmor=unconfined\n: Turn off apparmor confinement for the container\napparmor=alternate-profile\n: Set the apparmor confinement profile for the\ncontainer\nlabel=user:USER\n: Set the label user for the container processes\nlabel=role:ROLE\n: Set the label role for the container processes\nlabel=type:TYPE\n: Set the label process type for the container processes\nlabel=level:LEVEL\n: Set the label level for the container processes\nlabel=filetype:TYPE\n: Set the label file type for the container files\nlabel=disable\n: Turn off label separation for the container\nno-new-privileges\n: Disable container processes from gaining additional privileges\nseccomp=unconfined\n: Turn off seccomp confinement for the container\nseccomp=profile.json\n:  JSON file to be used as the seccomp filter for the container.\n--shm-size\n=\nnumber[unit]\n¶\nSize of\n/dev/shm\n. A\nunit\ncan be\nb\n(bytes),\nk\n(kibibytes),\nm\n(mebibytes), or\ng\n(gibibytes).\nIf the unit is omitted, the system uses bytes. If the size is omitted, the default is\n64m\n.\nWhen\nsize\nis\n0\n, there is no limit on the amount of memory used for IPC by the container.\nThis option conflicts with\n--ipc=host\n.\n--sign-by\n=\nfingerprint\n¶\nSign the image using a GPG key with the specified FINGERPRINT. (This option is not available with the remote Podman client, including Mac and Windows (excluding WSL2) machines,)\n--skip-unused-stages\n¶\nSkip stages in multi-stage builds which don’t affect the target stage. (Default:\ntrue\n).\n--source-date-epoch\n=\nseconds\n¶\nSet the “created” timestamp for the built image to this number of seconds since\nthe epoch (Unix time 0, i.e., 00:00:00 UTC on 1 January 1970) (default is to\nuse the value set in the\nSOURCE_DATE_EPOCH\nenvironment variable, or the\ncurrent time if it is not set).\nThe “created” timestamp is written into the image’s configuration and manifest\nwhen the image is committed, so running the same build two different times\nwill ordinarily produce images with different sha256 hashes, even if no other\nchanges were made to the Containerfile and build context.\nWhen this flag is set, a\nSOURCE_DATE_EPOCH\nbuild arg will provide its value\nfor a stage in which it is declared.\nWhen this flag is set, the image configuration’s “created” timestamp is always\nset to the time specified, which should allow for identical images to be built\nat different times using the same set of inputs.\nWhen this flag is set, output written as specified to the\n--output\nflag\nwill bear exactly the specified timestamp.\nConflicts with the similar\n--timestamp\nflag, which also sets its specified\ntime on the contents of new layers.\n--squash\n¶\nSquash all of the image’s new layers into a single new layer; any preexisting layers are not squashed.\n--squash-all\n¶\nSquash all of the new image’s layers (including those inherited from a base image) into a single new layer.\n--ssh\n=\ndefault\n|\nid[=socket>\n¶\nSSH agent socket or keys to expose to the build.\nThe socket path can be left empty to use the value of\ndefault=$SSH_AUTH_SOCK\nTo later use the ssh agent, use the --mount option in a\nRUN\ninstruction within a\nContainerfile\n:\nRUN\n--mount=type=ssh,id=id\nmycmd\n--stdin\n¶\nPass stdin into the RUN containers. Sometime commands being RUN within a Containerfile\nwant to request information from the user. For example apt asking for a confirmation for install.\nUse --stdin to be able to interact from the terminal during the build.\n--tag\n,\n-t\n=\nimageName\n¶\nSpecifies the name which is assigned to the resulting image if the build process completes successfully.\nIf\nimageName\ndoes not include a registry name, the registry name\nlocalhost\nis prepended to the image name.\n--target\n=\nstageName\n¶\nSet the target build stage to build.  When building a Containerfile with multiple build stages, --target can be used to specify an intermediate build stage by name as the final stage for the resulting image. Commands after the target stage is skipped.\n--timestamp\n=\nseconds\n¶\nSet the create timestamp to seconds since epoch to allow for deterministic builds (defaults to current time). By default, the created timestamp is changed and written into the image manifest with every commit, causing the image’s sha256 hash to be different even if the sources are exactly the same otherwise.\nWhen --timestamp is set, the created timestamp is always set to the time specified and therefore not changed, allowing the image’s sha256 hash to remain the same. All files committed to the layers of the image is created with the timestamp.\nIf the only instruction in a Containerfile is\nFROM\n, this flag has no effect.\n--tls-verify\n¶\nRequire HTTPS and verify certificates when contacting registries (default:\ntrue\n).\nIf explicitly set to\ntrue\n, TLS verification is used.\nIf set to\nfalse\n, TLS verification is not used.\nIf not specified, TLS verification is used unless the target registry\nis listed as an insecure registry in\ncontainers-registries.conf(5)\n--ulimit\n=\ntype=soft-limit[:hard-limit]\n¶\nSpecifies resource limits to apply to processes launched when processing\nRUN\ninstructions. This option can be specified multiple times.  Recognized resource types include:\n“core”: maximum core dump size (ulimit -c)\n“cpu”: maximum CPU time (ulimit -t)\n“data”: maximum size of a process’s data segment (ulimit -d)\n“fsize”: maximum size of new files (ulimit -f)\n“locks”: maximum number of file locks (ulimit -x)\n“memlock”: maximum amount of locked memory (ulimit -l)\n“msgqueue”: maximum amount of data in message queues (ulimit -q)\n“nice”: niceness adjustment (nice -n, ulimit -e)\n“nofile”: maximum number of open files (ulimit -n)\n“nproc”: maximum number of processes (ulimit -u)\n“rss”: maximum size of a process’s (ulimit -m)\n“rtprio”: maximum real-time scheduling priority (ulimit -r)\n“rttime”: maximum amount of real-time execution between blocking syscalls\n“sigpending”: maximum number of pending signals (ulimit -i)\n“stack”: maximum stack size (ulimit -s)\n--unsetannotation\n=\nannotation\n¶\nUnset the image annotation, causing the annotation not to be inherited from the base image.\n--unsetenv\n=\nenv\n¶\nUnset environment variables from the final image.\n--unsetlabel\n=\nlabel\n¶\nUnset the image label, causing the label not to be inherited from the base image.\n--userns\n=\nhow\n¶\nSets the configuration for user namespaces when handling\nRUN\ninstructions.\nThe configured value can be “” (the empty string) or “container” to indicate that a new user namespace is created, it can be “host” to indicate that the user namespace in which\npodman\nitself is being run is reused, or it can be the path to a user namespace which is already in use by another process.\n--userns-gid-map\n=\nmapping\n¶\nDirectly specifies a GID mapping to be used to set ownership, at the\nfilesystem level, on the working container’s contents.\nCommands run when handling\nRUN\ninstructions defaults to being run in\ntheir own user namespaces, configured using the UID and GID maps.\nEntries in this map take the form of one or more triples of a starting\nin-container GID, a corresponding starting host-level GID, and the number of consecutive IDs which the map entry represents.\nThis option overrides the\nremap-gids\nsetting in the\noptions\nsection of /etc/containers/storage.conf.\nIf this option is not specified, but a global --userns-gid-map setting is supplied, settings from the global option is used.\nIf none of --userns-uid-map-user, --userns-gid-map-group, or --userns-gid-map are specified, but --userns-uid-map is specified, the GID map is set to use the same numeric values as the UID map.\n--userns-gid-map-group\n=\ngroup\n¶\nSpecifies that a GID mapping to be used to set ownership, at the\nfilesystem level, on the working container’s contents, can be found in entries in the\n/etc/subgid\nfile which correspond to the specified group.\nCommands run when handling\nRUN\ninstructions defaults to being run in\ntheir own user namespaces, configured using the UID and GID maps.\nIf --userns-uid-map-user is specified, but --userns-gid-map-group is not specified,\npodman\nassumes that the specified user name is also a\nsuitable group name to use as the default setting for this option.\nNOTE:\nWhen this option is specified by a rootless user, the specified mappings are relative to the rootless user namespace in the container, rather than being relative to the host as it is when run rootful.\n--userns-uid-map\n=\nmapping\n¶\nDirectly specifies a UID mapping to be used to set ownership, at the\nfilesystem level, on the working container’s contents.\nCommands run when handling\nRUN\ninstructions default to being run in\ntheir own user namespaces, configured using the UID and GID maps.\nEntries in this map take the form of one or more triples of a starting\nin-container UID, a corresponding starting host-level UID, and the number of consecutive IDs which the map entry represents.\nThis option overrides the\nremap-uids\nsetting in the\noptions\nsection of /etc/containers/storage.conf.\nIf this option is not specified, but a global --userns-uid-map setting is supplied, settings from the global option is used.\nIf none of --userns-uid-map-user, --userns-gid-map-group, or --userns-uid-map are specified, but --userns-gid-map is specified, the UID map is set to use the same numeric values as the GID map.\n--userns-uid-map-user\n=\nuser\n¶\nSpecifies that a UID mapping to be used to set ownership, at the\nfilesystem level, on the working container’s contents, can be found in entries in the\n/etc/subuid\nfile which correspond to the specified user.\nCommands run when handling\nRUN\ninstructions defaults to being run in\ntheir own user namespaces, configured using the UID and GID maps.\nIf --userns-gid-map-group is specified, but --userns-uid-map-user is not specified,\npodman\nassumes that the specified group name is also a\nsuitable user name to use as the default setting for this option.\nNOTE:\nWhen this option is specified by a rootless user, the specified mappings are relative to the rootless user namespace in the container, rather than being relative to the host as it is when run rootful.\n--uts\n=\nhow\n¶\nSets the configuration for UTS namespaces when handling\nRUN\ninstructions.\nThe configured value can be “” (the empty string) or “container” to indicate that a new UTS namespace to be created, or it can be “host” to indicate that the UTS namespace in which\npodman\nitself is being run is reused, or it can be the path to a UTS namespace which is already in use by another process.\n--variant\n=\nvariant\n¶\nSet the architecture variant of the image to be built, and that of the base\nimage to be pulled, if the build uses one, to the provided value instead of\nusing the architecture variant of the build host.\n--volume\n,\n-v\n=\n[HOST-DIR:CONTAINER-DIR[:OPTIONS]]\n¶\nMount a host directory into containers when executing RUN instructions during\nthe build.\nThe\nOPTIONS\nare a comma-separated list and can be one or more of:\n[rw|ro]\n[z|Z|O]\n[U]\n[\n[r]shared\n|\n[r]slave\n|\n[r]private\n]\n[1]\nThe\nCONTAINER-DIR\nmust be an absolute path such as\n/src/docs\n. The\nHOST-DIR\nmust be an absolute path as well. Podman bind-mounts the\nHOST-DIR\nto the\nspecified path when processing RUN instructions.\nYou can specify multiple\n-v\noptions to mount one or more mounts.\nYou can add the\n:ro\nor\n:rw\nsuffix to a volume to mount it read-only or\nread-write mode, respectively. By default, the volumes are mounted read-write.\nSee examples.\nChowning\nVolume\nMounts\nBy default, Podman does not change the owner and group of source volume\ndirectories mounted. When running using user namespaces, the UID and GID inside\nthe namespace may correspond to another UID and GID on the host.\nThe\n:U\nsuffix tells Podman to use the correct host UID and GID based on the\nUID and GID within the namespace, to change recursively the owner and group of\nthe source volume.\nWarning\nuse with caution since this modifies the host filesystem.\nLabeling\nVolume\nMounts\nLabeling systems like SELinux require that proper labels are placed on volume\ncontent mounted into a container. Without a label, the security system might\nprevent the processes running inside the container from using the content. By\ndefault, Podman does not change the labels set by the OS.\nTo change a label in the container context, add one of these two suffixes\n:z\nor\n:Z\nto the volume mount. These suffixes tell Podman to relabel file\nobjects on the shared volumes. The\nz\noption tells Podman that two containers\nshare the volume content. As a result, Podman labels the content with a shared\ncontent label. Shared volume labels allow all containers to read/write content.\nThe\nZ\noption tells Podman to label the content with a private unshared label.\nOnly the current container can use a private volume.\nNote: Do not relabel system files and directories. Relabeling system content\nmight cause other confined services on the host machine to fail.  For these types\nof containers, disabling SELinux separation is recommended.  The option\n--security-opt\nlabel=disable\ndisables SELinux separation for the container.\nFor example, if a user wanted to volume mount their entire home directory into the build containers, they need to disable SELinux separation.\n$ podman build --security-opt label=disable -v $HOME:/home/user .\nOverlay\nVolume\nMounts\nThe\n:O\nflag tells Podman to mount the directory from the host as a\ntemporary storage using the Overlay file system. The\nRUN\ncommand containers\nare allowed to modify contents within the mountpoint and are stored in the\ncontainer storage in a separate directory.  In Overlay FS terms the source\ndirectory is the lower, and the container storage directory is the\nupper. Modifications to the mount point are destroyed when the\nRUN\ncommand\nfinishes executing, similar to a tmpfs mount point.\nAny subsequent execution of\nRUN\ncommands sees the original source directory\ncontent, any changes from previous RUN commands no longer exists.\nOne use case of the\noverlay\nmount is sharing the package cache from the\nhost into the container to allow speeding up builds.\nNote:\nOverlay mounts are not currently supported in rootless mode.\nThe\nO\nflag is not allowed to be specified with the\nZ\nor\nz\nflags.\nContent mounted into the container is labeled with the private label.\nOn SELinux systems, labels in the source directory needs to be readable\nby the container label. If not, SELinux container separation must be disabled\nfor the container to work.\nModification of the directory volume mounted into the container with an\noverlay mount can cause unexpected failures. Do not modify the directory until\nthe container finishes running.\nBy default bind mounted volumes are\nprivate\n. That means any mounts done\ninside containers are not be visible on the host and vice versa. This behavior\ncan be changed by specifying a volume mount propagation property.\nWhen the mount propagation policy is set to\nshared\n, any mounts completed\ninside the container on that volume is visible to both the host and\ncontainer. When the mount propagation policy is set to\nslave\n, one way mount\npropagation is enabled and any mounts completed on the host for that volume is\nvisible only inside of the container. To control the mount propagation\nproperty of volume use the\n:[r]shared\n,\n:[r]slave\nor\n:[r]private\npropagation flag. For mount propagation to work on the source mount point (mount\npoint where source dir is mounted on) has to have the right propagation properties.\nFor shared volumes, the source mount point has to be shared. And for slave volumes,\nthe source mount has to be either shared or slave.\n[1]\nUse\ndf\n<source-dir>\nto determine the source mount and then use\nfindmnt\n-o\nTARGET,PROPAGATION\n<source-mount-dir>\nto determine propagation\nproperties of source mount, if\nfindmnt\nutility is not available, the source\nmount point can be determined by looking at the mount entry in\n/proc/self/mountinfo\n. Look at\noptional\nfields\nand see if any propagation\nproperties are specified.\nshared:X\nmeans the mount is\nshared\n,\nmaster:X\nmeans the mount is\nslave\nand if nothing is there that means the mount is\nprivate\n.\n[1]\nTo change propagation properties of a mount point use the\nmount\ncommand. For\nexample, to bind mount the source directory\n/foo\ndo\nmount\n--bind\n/foo\n/foo\nand\nmount\n--make-private\n--make-shared\n/foo\n. This\nconverts /foo into a\nshared\nmount point.  The propagation properties of\nthe source mount can be changed directly. For instance if\n/\nis the source\nmount for\n/foo\n, then use\nmount\n--make-shared\n/\nto convert\n/\ninto a\nshared\nmount.\nEXAMPLES\n¶\nBuild an image using local Containerfiles\n¶\nBuild image using Containerfile with content from current directory:\n$ podman build .\nBuild image using specified Containerfile with content from current directory:\n$ podman build -f Containerfile.simple .\nBuild image using Containerfile from stdin with content from current directory:\n$ cat $HOME/Containerfile | podman build -f - .\nBuild image using multiple Containerfiles with content from current directory:\n$ podman build -f Containerfile.simple -f Containerfile.notsosimple .\nBuild image with specified Containerfile with content from $HOME directory. Note\ncpp\nis applied to Containerfile.in before processing as Containerfile:\n$ podman build -f Containerfile.in $HOME\nBuild image with the specified tag with Containerfile and content from current directory:\n$ podman build -t imageName .\nBuild image ignoring registry verification for any images pulled via the Containerfile:\n$ podman build --tls-verify=false -t imageName .\nBuild image with the specified logging format:\n$ podman build --runtime-flag log-format=json .\nBuild image using debug mode for logging:\n$ podman build --runtime-flag debug .\nBuild image using specified registry attributes when pulling images from the selected Containerfile:\n$ podman build --authfile /tmp/auths/myauths.json --cert-dir $HOME/auth --tls-verify=true --creds=username:password -t imageName -f Containerfile.simple .\nBuild image using specified resource controls when running containers during the build:\n$ podman build --memory 40m --cpu-period 10000 --cpu-quota 50000 --ulimit nofile=1024:1028 -t imageName .\nBuild image using specified SELinux labels and cgroup config running containers during the build:\n$ podman build --security-opt label=level:s0:c100,c200 --cgroup-parent /path/to/cgroup/parent -t imageName .\nBuild image with read-only and SELinux relabeled volume mounted from the host into running containers during the build:\n$ podman build --volume /home/test:/myvol:ro,Z -t imageName .\nBuild image with overlay volume mounted from the host into running containers during the build:\n$ podman build -v /var/lib/yum:/var/lib/yum:O -t imageName .\nBuild image using layers and then removing intermediate containers even if the build fails.\n$ podman build --layers --force-rm -t imageName .\nBuild image ignoring cache and not removing intermediate containers even if the build succeeds:\n$ podman build --no-cache --rm=false -t imageName .\nBuild image using the specified network when running containers during the build:\n$ podman build --network mynet .\nBuild an image using a secret stored in an environment variable or file named\nmysecret\nto be used with the instruction\nRUN\n--mount=type=secret,id=mysecret\ncat\n/run/secrets/mysecret\n:\n$ podman build --secret=id=mysecret .\nBuild an image using a secret stored in an environment variable named\nMYSECRET\nto be used with the instruction\nRUN\n--mount=type=secret,id=mysecret\ncat\n/run/secrets/mysecret\n:\n$ podman build --secret=id=mysecret,env=MYSECRET .\n$ podman build --secret=id=mysecret,src=MYSECRET,type=env .\nBuild an image using a secret stored in a file named\n.mysecret\nto be used with the instruction\nRUN\n--mount=type=secret,id=mysecret\ncat\n/run/secrets/mysecret\n:\n$ podman build --secret=id=mysecret,src=.mysecret .\n$ podman build --secret=id=mysecret,src=.mysecret,type=file .\nBuilding a multi-architecture image using the --manifest option (requires emulation software)\n¶\nBuild image using the specified architectures and link to a single manifest on successful completion:\n$ podman build --arch arm --manifest myimage /tmp/mysrc\n$ podman build --arch amd64 --manifest myimage /tmp/mysrc\n$ podman build --arch s390x --manifest myimage /tmp/mysrc\nSimilarly build using a single command\n$ podman build --platform linux/s390x,linux/ppc64le,linux/amd64 --manifest myimage /tmp/mysrc\nBuild image using multiple specified architectures and link to single manifest on successful completion:\n$ podman build --platform linux/arm64 --platform linux/amd64 --manifest myimage /tmp/mysrc\nBuilding an image using a URL, Git repo, or archive\n¶\nThe build context directory can be specified as a URL to a Containerfile, a\nGit repository, or URL to an archive. If the URL is a Containerfile, it is\ndownloaded to a temporary location and used as the context. When a Git\nrepository is set as the URL, the repository is cloned locally to a temporary\nlocation and then used as the context. Lastly, if the URL is an archive, it is\ndownloaded to a temporary location and extracted before being used as the\ncontext.\nBuilding an image using a URL to a Containerfile\n¶\nBuild image from Containerfile downloaded into temporary location used as the build context:\n$ podman build https://10.10.10.1/podman/Containerfile\nBuilding an image using a Git repository\n¶\nPodman clones the specified GitHub repository to a temporary location and\nuses it as the context. The Containerfile at the root of the repository is used\nand it only works if the GitHub repository is a dedicated repository.\nBuild image from specified git repository downloaded into temporary location used as the build context:\n$ podman build -t hello  https://github.com/containers/PodmanHello.git\n$ podman run hello\nNote: GitHub does not support using\ngit://\nfor performing\nclone\noperation due to recent changes in their security guidance (https://github.blog/2021-09-01-improving-git-protocol-security-github/). Use an\nhttps://\nURL if the source repository is hosted on GitHub.\nBuilding an image using a URL to an archive\n¶\nPodman fetches the archive file, decompresses it, and uses its contents as the\nbuild context. The Containerfile at the root of the archive and the rest of the\narchive are used as the context of the build. Passing the\n-f\nPATH/Containerfile\noption as well tells the system to look for that file\ninside the contents of the archive.\n$ podman build -f dev/Containerfile https://10.10.10.1/podman/context.tar.gz\nNote: supported compression formats are ‘xz’, ‘bzip2’, ‘gzip’ and ‘identity’\n(no compression).\nFiles\n¶\n.containerignore/.dockerignore\n¶\nIf the file\n.containerignore\nor\n.dockerignore\nexists in the context directory,\npodman\nbuild\nreads its contents. Use the\n--ignorefile\noption to override the\n.containerignore path location.\nPodman uses the content to exclude files and directories from the context\ndirectory, when executing COPY and ADD directives in the\nContainerfile/Dockerfile\nThe .containerignore and .dockerignore files use the same syntax; if both\nare in the context directory, podman build only uses .containerignore.\nUsers can specify a series of Unix shell globs in a .containerignore file to\nidentify files/directories to exclude.\nPodman supports a special wildcard string\n**\nwhich matches any number of\ndirectories (including zero). For example, **/*.go excludes all files that\nend with .go that are found in all directories.\nExample .containerignore file:\n# exclude this content for image\n*/*.\nc\n**/\noutput\n*\nsrc\n*/*.c\nExcludes files and directories whose names ends with .c in any top level\nsubdirectory. For example, the source file include/rootless.c.\n**/output*\nExcludes files and directories starting with\noutput\nfrom any directory.\nsrc\nExcludes files named src and the directory src as well as any content in it.\nLines starting with ! (exclamation mark) can be used to make exceptions to\nexclusions. The following is an example .containerignore file that uses this\nmechanism:\n*.doc\n!Help.doc\nExclude all doc files except Help.doc from the image.\nThis functionality is compatible with the handling of .containerignore files\ndescribed here:\ncontainerignore(5)\nregistries.conf (\n/etc/containers/registries.conf\n)\n¶\nregistries.conf is the configuration file which specifies which container\nregistries is consulted when completing image names which do not include\na registry or domain portion.\nSee\ncontainers-registries.conf(5)\nTroubleshooting\n¶\nlastlog sparse file\n¶\nUsing a useradd command within a Containerfile with a large UID/GID creates\na large sparse file\n/var/log/lastlog\n.  This can cause the\nbuild to hang forever.  Go language does not support sparse files correctly,\nwhich can lead to some huge files being created in the container image.\nWhen using the\nuseradd\ncommand within the build script, pass the\n--no-log-init\nor\n-l\noption to the\nuseradd\ncommand.  This option tells\nuseradd to stop creating the lastlog file.\nSEE ALSO\n¶\npodman(1)\n,\nbuildah(1)\n,\ncontainers-certs.d(5)\n,\ncontainers-registries.conf(5)\n,\ncrun(1)\n,\nrunc(8)\n,\nuseradd(8)\n,\npodman-ps(1)\n,\npodman-rm(1)\n,\nContainerfile(5)\n,\ncontainerignore(5)\nTroubleshooting\n¶\nSee\npodman-troubleshooting(7)\nfor solutions to common issues.\nSee\npodman-rootless(7)\nfor rootless issues.\nHISTORY\n¶\nAug 2020, Additional options and .containerignore added by Dan Walsh\n<dwalsh@redhat.com>\nMay 2018, Minor revisions added by Joe Doss\n<joe@solidadmin.com>\nDecember 2017, Originally compiled by Tom Sweeney\n<tsweeney@redhat.com>\nFOOTNOTES\n¶\n1\n: The Podman project is committed to inclusivity, a\ncore value of open source. The\nmaster\nand\nslave\nmount propagation\nterminology used here is problematic and divisive, and needs to be changed.\nHowever, these terms are currently used within the Linux kernel and must be\nused as-is at this time. When the kernel maintainers rectify this usage,\nPodman will follow suit immediately.\nPodman\nNavigation\nContents:\nIntroduction\nCommands\nReference\nTutorials\nSearch\nPodman Python\nRelated Topics\nDocumentation overview\n©2019, team.\n|\nPowered by\nSphinx 8.2.3\n&\nAlabaster 1.0.0\n|\nPage source", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://docs.podman.io/en/latest/markdown/podman-build.1.html"}}
{"text": "podman-compose — Podman  documentation\nNAME\n¶\npodman-compose - Run Compose workloads via an external compose provider\nSYNOPSIS\n¶\npodman compose\n[\noptions\n] [\ncommand\n[\narg\n…]]\nDESCRIPTION\n¶\npodman compose\nis a thin wrapper around an external compose provider such as docker-compose or podman-compose.  This means that\npodman\ncompose\nis executing another tool that implements the compose functionality but sets up the environment in a way to let the compose provider communicate transparently with the local Podman socket.  The specified options as well as the command and argument are passed directly to the compose provider.\nThe default compose providers are\ndocker-compose\nand\npodman-compose\n.  If installed,\ndocker-compose\ntakes precedence since it is the original implementation of the Compose specification and is widely used on the supported platforms (i.e., Linux, Mac OS, Windows).\nIf you want to change the default behavior or have a custom installation path for your provider of choice, please change the\ncompose_providers\nfield in\ncontainers.conf(5)\nto\ncompose_providers\n=\n[\"/path/to/provider\"]\n. You may also set the\nPODMAN_COMPOSE_PROVIDER\nenvironment variable.\nBy default,\npodman\ncompose\nwill emit a warning saying that it executes an external command. This warning can be disabled by setting\ncompose_warning_logs\nto false in\ncontainers.conf(5)\nor setting the\nPODMAN_COMPOSE_WARNING_LOGS\nenvironment variable to false. See the man page for\ncontainers.conf(5)\nfor more information.\nOPTIONS\n¶\nTo see supported options of the installed compose provider, please run\npodman\ncompose\n--help\n.\nSEE ALSO\n¶\npodman(1)\n,\ncontainers.conf(5)\nPodman\nNavigation\nContents:\nIntroduction\nCommands\nReference\nTutorials\nSearch\nPodman Python\nRelated Topics\nDocumentation overview\n©2019, team.\n|\nPowered by\nSphinx 8.2.3\n&\nAlabaster 1.0.0\n|\nPage source", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://docs.podman.io/en/latest/markdown/podman-compose.1.html"}}
{"text": "Tutorials — Podman  documentation\nTutorials\n¶\nHere are a number of useful tutorials to get you up and running with Podman. If you are familiar with the Docker\nContainer Engine\nthe commands in\nPodman\nshould be quite familiar. If you are brand new to containers, take a look at our\nIntroduction\n.\nBasic Setup and Use of Podman\n: Learn how to set up Podman and perform some basic commands with the utility.\nBasic Setup and Use of Podman in a Rootless environment\n: The steps required to set up rootless Podman are enumerated.\nPodman for Windows\n: A guide to installing and using Podman on Windows.\nPodman Remote Clients on Mac/Windows\n: Advanced setup for connecting to a remote Linux system using the Podman remote client on Mac and Windows.\nHow to sign and distribute container images using Podman\n: Learn how to set up and use image signing with Podman.\nPodman remote-client tutorial\n: A brief how-to on using the Podman remote-client.\nHow to use libpod for custom/derivative projects\n: How the libpod API can be used within your own project.\nHow to use Podman’s Go RESTful bindings\n: An introduction to using our RESTful Golang bindings in an external application.\nCommon network setups\n: A basic guide to common network setups for Podman.\nSocket activation\n: Learn how to run containers that support socket activation.\nPodman\nNavigation\nContents:\nIntroduction\nCommands\nReference\nTutorials\nSearch\nPodman Python\nRelated Topics\nDocumentation overview\nPrevious:\nReference\nNext:\nSearch\n©2019, team.\n|\nPowered by\nSphinx 8.2.3\n&\nAlabaster 1.0.0\n|\nPage source", "metadata": {"source_type": "vendor_docs", "trust": "vendor_docs", "os": "linux", "distro": "ubuntu-22.04", "license": "CC BY-SA (assumed; verify per site)", "attribution_url": "https://docs.podman.io/en/latest/Tutorials.html"}}
